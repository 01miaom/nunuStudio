"use strict";

/**
 * Reflection probes are used to create CubeTextures dinamically.
 *
 * These CubeTextures can be attributed to materials programatically.
 * 
 * @class CubeCamera
 * @author alteredq
 * @constructor
 * @extends {Object3D}
 * @module Misc
 */

/**
 * CubeCamera near plane.
 * @property near
 * @type {Number}
 */
/**
 * CubeCamera far plane.
 * @property far
 * @type {Number}
 */
/**
 * Resolution of each face. Should be a power of 2 (32, 64, 128, ...).
 * @property resolution
 * @type {Number}
 */
/**
 * Array of 6 cameras used to render each face of the cube.
 * @property cameras
 * @type {Array}
 */
/**
 * CubeTexture generated by this CubeCamera.
 *
 * Can be attached to materials as envMap.
 * 
 * @property cube
 * @type {CubeTexture}
 */
/**
 * WebGL cube render target to where the scene is rendered.
 * @property target
 * @type {WebGLRenderTargetCube}
 */
function CubeCamera(near, far, resolution, autoUpdate)
{
	THREE.Object3D.call(this);

	this.name = "cubecamera";
	this.type = "CubeCamera";

	this.near = (near !== undefined) ? near : 0.01;
	this.far = (far !== undefined) ? far : 10000;
	this.resolution = (resolution !== undefined) ? resolution : 256;
	this.autoUpdate = (autoUpdate !== undefined) ? autoUpdate : false;

	this.cameras = [];
	for(var i = 0; i < 6; i++)
	{
		var camera = new THREE.PerspectiveCamera(90, 1, this.near, this.far);
		camera.parent = this;
		this.cameras.push(camera);
	}

	this.cameras[0].up.set(0, -1, 0);
	this.cameras[0].lookAt(new THREE.Vector3(1, 0, 0));
	this.cameras[1].up.set(0, -1, 0);
	this.cameras[1].lookAt(new THREE.Vector3(-1, 0, 0));
	this.cameras[2].up.set(0, 0, 1);
	this.cameras[2].lookAt(new THREE.Vector3(0, 1, 0));
	this.cameras[3].up.set(0, 0, -1);
	this.cameras[3].lookAt(new THREE.Vector3(0, -1, 0));
	this.cameras[4].up.set(0, -1, 0);
	this.cameras[4].lookAt(new THREE.Vector3(0, 0, 1));
	this.cameras[5].up.set(0, -1, 0);
	this.cameras[5].lookAt(new THREE.Vector3(0, 0, -1));

	this.target = new THREE.WebGLRenderTargetCube(this.resolution, this.resolution,
	{
		format: THREE.RGBFormat,
		magFilter: THREE.LinearFilter,
		minFilter: THREE.LinearFilter
	});

	this.cube = this.target.texture;
	this.cube.generateMipmaps = false;
	this.cube.name = "cube";

	this.scene = null;
	this.renderer = null;
}

THREE._CubeCamera = THREE.CubeCamera;
THREE.CubeCamera = CubeCamera;

CubeCamera.prototype = Object.create(THREE.Object3D.prototype);

/**
 * Initialize CubeCamera object.
 * 
 * Gets the attached scene and the renderer in use.
 *
 * @method initialize
 */
CubeCamera.prototype.initialize = function()
{
	var node = this;
	while(node.parent !== null)
	{
		node = node.parent;
		if(node instanceof Scene)
		{
			this.scene = node;
		}
		else if(node instanceof Program)
		{
			this.renderer = node.renderer;
		}
	}

	for(var i = 0; i < this.children.length; i++)
	{
		this.children[i].initialize();
	}
};


/**
 * Update CubeCamera object.
 *
 * If autoUpdate is set to true the CubeCamera updates the CubeTexture automatically.
 * 
 * @method update
 */
CubeCamera.prototype.update = function(delta)
{
	if(this.autoUpdate)
	{
		this.updateCubeMap(this.renderer, this.scene);
	}

	for(var i = 0; i < this.children.length; i++)
	{
		this.children[i].update(delta);
	}
};


/**
 * Set the CubeCamera resolution.
 *
 * @method setResolution
 * @param {Number} resolution CubeCamera resolution (per face). Should be a 2 pot.
 */
CubeCamera.prototype.setResolution = function(resolution)
{
	this.resolution = resolution;
	this.target.setSize(resolution, resolution);
};

/**
 * Render new cube faces. 
 * 
 * Should be called every time a change in the scene is made.
 *
 * @method updateCubeMap
 * @param {WebGLRenderer} renderer Renderer to be used.
 * @param {Scene} scene Scene to be renderer.
 */
CubeCamera.prototype.updateCubeMap = function(renderer, scene)
{
	var autoClear = renderer.autoClear;
	renderer.autoClear = true;

	for(var i = 0; i < 6; i++)
	{
		this.cameras[i].updateMatrixWorld();
		this.target.activeCubeFace = i;
		renderer.render(scene, this.cameras[i], this.target);
	}

	renderer.autoClear = autoClear;
};

/**
 * Disposes the CubeCamera.
 * 
 * @method dispose
 */
CubeCamera.prototype.dispose = function()
{
	THREE.Object3D.prototype.dispose.call(this);
};

/**
 * Serialize object to JSON.
 *
 * @method toJSON
 * @param {Object} meta Meta data.
 * @return {Object} JSON description.
 */
CubeCamera.prototype.toJSON = function(meta)
{
	var data = THREE.Object3D.prototype.toJSON.call(this, meta);

	data.object.near = this.near;
	data.object.far = this.far;
	data.object.resolution = this.resolution;
	data.object.autoUpdate = this.autoUpdate;

	return data;
};