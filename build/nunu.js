/*


 opentype.js:
   license: MIT (http://opensource.org/licenses/MIT)
   author: Frederik De Bleser <frederik@debleser.be>
   version: 0.6.5

 tiny-inflate:
   license: MIT (http://opensource.org/licenses/MIT)
   author: Devon Govett <devongovett@gmail.com>
   maintainers: devongovett <devongovett@gmail.com>
   homepage: https://github.com/devongovett/tiny-inflate
   version: 1.0.2

 This header is generated by licensify (https://github.com/twada/licensify)


 nunuStudio:
   license: MIT (http://opensource.org/licenses/MIT)
   author: Tentone <tentone@outlook.com>
 LeapJS v0.6.4                                                  
 http://github.com/leapmotion/leapjs/                                        

 Copyright 2013 LeapMotion, Inc. and other contributors                      
 Released under the Apache-2.0 license                                     
 http://github.com/leapmotion/leapjs/blob/master/LICENSE.txt                 
*/
function Nunu() {
}
Nunu.NAME = "nunuStudio";
Nunu.VERSION = "V0.8.9.21 Alpha";
Nunu.TIMESTAMP = "201702260015";
Nunu.webvrAvailable = function() {
  return void 0 !== navigator.getVRDisplays;
};
Nunu.webAudioAvailable = function() {
  return void 0 !== window.AudioContext || void 0 !== window.webkitAudioContext;
};
Nunu.webglAvailable = function() {
  var a = ["webgl", "experimental-webgl", "webgl2", "experimental-webgl"];
  try {
    for (var h = document.createElement("canvas"), l = 0;l < a.length;l++) {
      if (void 0 !== h.getContext(a[l])) {
        return !0;
      }
    }
  } catch (b) {
  }
  return !1;
};
Nunu.runningOnDesktop = function() {
  return void 0 !== window.nw;
};
(function(a, h) {
  "object" === typeof exports && "undefined" !== typeof module ? h(exports) : "function" === typeof define && define.amd ? define(["exports"], h) : h(a.THREE = a.THREE || {});
})(this, function(a) {
  function h() {
  }
  function l(d, m) {
    this.x = d || 0;
    this.y = m || 0;
  }
  function b(d, m, a, c, e, g, q, k, f, p) {
    Object.defineProperty(this, "id", {value:Ye++});
    this.uuid = ka.generateUUID();
    this.name = "";
    this.image = void 0 !== d ? d : b.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = void 0 !== m ? m : b.DEFAULT_MAPPING;
    this.wrapS = void 0 !== a ? a : 1001;
    this.wrapT = void 0 !== c ? c : 1001;
    this.magFilter = void 0 !== e ? e : 1006;
    this.minFilter = void 0 !== g ? g : 1008;
    this.anisotropy = void 0 !== f ? f : 1;
    this.format = void 0 !== q ? q : 1023;
    this.type = void 0 !== k ? k : 1009;
    this.offset = new l(0, 0);
    this.repeat = new l(1, 1);
    this.generateMipmaps = !0;
    this.premultiplyAlpha = !1;
    this.flipY = !0;
    this.unpackAlignment = 4;
    this.encoding = void 0 !== p ? p : 3E3;
    this.version = 0;
    this.onUpdate = null;
  }
  function f(d, m, a, b) {
    this.x = d || 0;
    this.y = m || 0;
    this.z = a || 0;
    this.w = void 0 !== b ? b : 1;
  }
  function k(d, m, a) {
    this.uuid = ka.generateUUID();
    this.width = d;
    this.height = m;
    this.scissor = new f(0, 0, d, m);
    this.scissorTest = !1;
    this.viewport = new f(0, 0, d, m);
    a = a || {};
    void 0 === a.minFilter && (a.minFilter = 1006);
    this.texture = new b(void 0, void 0, a.wrapS, a.wrapT, a.magFilter, a.minFilter, a.format, a.type, a.anisotropy, a.encoding);
    this.depthBuffer = void 0 !== a.depthBuffer ? a.depthBuffer : !0;
    this.stencilBuffer = void 0 !== a.stencilBuffer ? a.stencilBuffer : !0;
    this.depthTexture = void 0 !== a.depthTexture ? a.depthTexture : null;
  }
  function c(d, m, a) {
    k.call(this, d, m, a);
    this.activeMipMapLevel = this.activeCubeFace = 0;
  }
  function g(d, m, a, b) {
    this._x = d || 0;
    this._y = m || 0;
    this._z = a || 0;
    this._w = void 0 !== b ? b : 1;
  }
  function e(d, m, a) {
    this.x = d || 0;
    this.y = m || 0;
    this.z = a || 0;
  }
  function p() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }
  function r(d, m, a, c, e, g, q, k, f, p) {
    d = void 0 !== d ? d : [];
    b.call(this, d, void 0 !== m ? m : 301, a, c, e, g, q, k, f, p);
    this.flipY = !1;
  }
  function w(d, m, a) {
    var A = d[0];
    if (0 >= A || 0 < A) {
      return d;
    }
    var b = m * a, c = Be[b];
    void 0 === c && (c = new Float32Array(b), Be[b] = c);
    if (0 !== m) {
      for (A.toArray(c, 0), A = 1, b = 0;A !== m;++A) {
        b += a, d[A].toArray(c, b);
      }
    }
    return c;
  }
  function n(d, m) {
    var a = Ce[m];
    void 0 === a && (a = new Int32Array(m), Ce[m] = a);
    for (var b = 0;b !== m;++b) {
      a[b] = d.allocTextureUnit();
    }
    return a;
  }
  function t(d, m) {
    d.uniform1f(this.addr, m);
  }
  function v(d, m) {
    d.uniform1i(this.addr, m);
  }
  function y(d, m) {
    void 0 === m.x ? d.uniform2fv(this.addr, m) : d.uniform2f(this.addr, m.x, m.y);
  }
  function x(d, m) {
    void 0 !== m.x ? d.uniform3f(this.addr, m.x, m.y, m.z) : void 0 !== m.r ? d.uniform3f(this.addr, m.r, m.g, m.b) : d.uniform3fv(this.addr, m);
  }
  function q(d, m) {
    void 0 === m.x ? d.uniform4fv(this.addr, m) : d.uniform4f(this.addr, m.x, m.y, m.z, m.w);
  }
  function u(d, m) {
    d.uniformMatrix2fv(this.addr, !1, m.elements || m);
  }
  function B(d, m) {
    void 0 === m.elements ? d.uniformMatrix3fv(this.addr, !1, m) : (De.set(m.elements), d.uniformMatrix3fv(this.addr, !1, De));
  }
  function C(d, m) {
    void 0 === m.elements ? d.uniformMatrix4fv(this.addr, !1, m) : (Ee.set(m.elements), d.uniformMatrix4fv(this.addr, !1, Ee));
  }
  function D(d, m, a) {
    var A = a.allocTextureUnit();
    d.uniform1i(this.addr, A);
    a.setTexture2D(m || Fe, A);
  }
  function F(d, m, a) {
    var A = a.allocTextureUnit();
    d.uniform1i(this.addr, A);
    a.setTextureCube(m || Ge, A);
  }
  function E(d, m) {
    d.uniform2iv(this.addr, m);
  }
  function z(d, m) {
    d.uniform3iv(this.addr, m);
  }
  function I(d, m) {
    d.uniform4iv(this.addr, m);
  }
  function J(d) {
    switch(d) {
      case 5126:
        return t;
      case 35664:
        return y;
      case 35665:
        return x;
      case 35666:
        return q;
      case 35674:
        return u;
      case 35675:
        return B;
      case 35676:
        return C;
      case 35678:
        return D;
      case 35680:
        return F;
      case 5124:
      case 35670:
        return v;
      case 35667:
      case 35671:
        return E;
      case 35668:
      case 35672:
        return z;
      case 35669:
      case 35673:
        return I;
    }
  }
  function R(d, m) {
    d.uniform1fv(this.addr, m);
  }
  function L(d, m) {
    d.uniform1iv(this.addr, m);
  }
  function M(d, m) {
    d.uniform2fv(this.addr, w(m, this.size, 2));
  }
  function P(d, m) {
    d.uniform3fv(this.addr, w(m, this.size, 3));
  }
  function H(d, m) {
    d.uniform4fv(this.addr, w(m, this.size, 4));
  }
  function ba(d, m) {
    d.uniformMatrix2fv(this.addr, !1, w(m, this.size, 4));
  }
  function ha(d, m) {
    d.uniformMatrix3fv(this.addr, !1, w(m, this.size, 9));
  }
  function Z(d, m) {
    d.uniformMatrix4fv(this.addr, !1, w(m, this.size, 16));
  }
  function ea(d, m, a) {
    var A = m.length, b = n(a, A);
    d.uniform1iv(this.addr, b);
    for (d = 0;d !== A;++d) {
      a.setTexture2D(m[d] || Fe, b[d]);
    }
  }
  function S(d, m, a) {
    var A = m.length, b = n(a, A);
    d.uniform1iv(this.addr, b);
    for (d = 0;d !== A;++d) {
      a.setTextureCube(m[d] || Ge, b[d]);
    }
  }
  function V(d) {
    switch(d) {
      case 5126:
        return R;
      case 35664:
        return M;
      case 35665:
        return P;
      case 35666:
        return H;
      case 35674:
        return ba;
      case 35675:
        return ha;
      case 35676:
        return Z;
      case 35678:
        return ea;
      case 35680:
        return S;
      case 5124:
      case 35670:
        return L;
      case 35667:
      case 35671:
        return E;
      case 35668:
      case 35672:
        return z;
      case 35669:
      case 35673:
        return I;
    }
  }
  function N(d, m, a) {
    this.id = d;
    this.addr = a;
    this.setValue = J(m.type);
  }
  function X(d, m, a) {
    this.id = d;
    this.addr = a;
    this.size = m.size;
    this.setValue = V(m.type);
  }
  function ia(d) {
    this.id = d;
    this.seq = [];
    this.map = {};
  }
  function ta(d, m, a) {
    this.seq = [];
    this.map = {};
    this.renderer = a;
    a = d.getProgramParameter(m, d.ACTIVE_UNIFORMS);
    for (var A = 0;A < a;++A) {
      var b = d.getActiveUniform(m, A), c = d.getUniformLocation(m, b.name), e = this, g = b.name, q = g.length;
      for (ae.lastIndex = 0;;) {
        var k = ae.exec(g), f = ae.lastIndex, p = k[1], h = k[3];
        "]" === k[2] && (p |= 0);
        if (void 0 === h || "[" === h && f + 2 === q) {
          g = e;
          b = void 0 === h ? new N(p, b, c) : new X(p, b, c);
          g.seq.push(b);
          g.map[b.id] = b;
          break;
        } else {
          h = e.map[p], void 0 === h && (h = new ia(p), p = e, e = h, p.seq.push(e), p.map[e.id] = e), e = h;
        }
      }
    }
  }
  function T(d, m, a) {
    return void 0 === m && void 0 === a ? this.set(d) : this.setRGB(d, m, a);
  }
  function ra(d, m, a, c, e, g, q, k, f, p, h, r) {
    b.call(this, null, g, q, k, f, p, c, e, h, r);
    this.image = {data:d, width:m, height:a};
    this.magFilter = void 0 !== f ? f : 1003;
    this.minFilter = void 0 !== p ? p : 1003;
    this.flipY = this.generateMipmaps = !1;
    this.unpackAlignment = 1;
  }
  function qa(d, m) {
    this.min = void 0 !== d ? d : new l(Infinity, Infinity);
    this.max = void 0 !== m ? m : new l(-Infinity, -Infinity);
  }
  function pa(d, m) {
    var a, b, c, g, q, k, f, p, h, r, n = d.context, u = d.state, w, t, v, B, y;
    this.render = function(A, G, O) {
      if (0 !== m.length) {
        A = new e;
        var aa = O.w / O.z, ma = .5 * O.z, Q = .5 * O.w, x = 16 / O.w, z = new l(x * aa, x), C = new e(1, 1, 0), Fb = new l(1, 1), F = new qa;
        F.min.set(O.x, O.y);
        F.max.set(O.x + (O.z - 16), O.y + (O.w - 16));
        if (void 0 === v) {
          var x = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]), kb = new Uint16Array([0, 1, 2, 0, 2, 3]);
          w = n.createBuffer();
          t = n.createBuffer();
          n.bindBuffer(n.ARRAY_BUFFER, w);
          n.bufferData(n.ARRAY_BUFFER, x, n.STATIC_DRAW);
          n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t);
          n.bufferData(n.ELEMENT_ARRAY_BUFFER, kb, n.STATIC_DRAW);
          B = n.createTexture();
          y = n.createTexture();
          u.bindTexture(n.TEXTURE_2D, B);
          n.texImage2D(n.TEXTURE_2D, 0, n.RGB, 16, 16, 0, n.RGB, n.UNSIGNED_BYTE, null);
          n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE);
          n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);
          n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST);
          n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST);
          u.bindTexture(n.TEXTURE_2D, y);
          n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, 16, 16, 0, n.RGBA, n.UNSIGNED_BYTE, null);
          n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE);
          n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);
          n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST);
          n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST);
          var x = {vertexShader:"uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}", 
          fragmentShader:"uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"}, kb = n.createProgram(), N = 
          n.createShader(n.FRAGMENT_SHADER), E = n.createShader(n.VERTEX_SHADER), D = "precision " + d.getPrecision() + " float;\n";
          n.shaderSource(N, D + x.fragmentShader);
          n.shaderSource(E, D + x.vertexShader);
          n.compileShader(N);
          n.compileShader(E);
          n.attachShader(kb, N);
          n.attachShader(kb, E);
          n.linkProgram(kb);
          v = kb;
          h = n.getAttribLocation(v, "position");
          r = n.getAttribLocation(v, "uv");
          a = n.getUniformLocation(v, "renderType");
          b = n.getUniformLocation(v, "map");
          c = n.getUniformLocation(v, "occlusionMap");
          g = n.getUniformLocation(v, "opacity");
          q = n.getUniformLocation(v, "color");
          k = n.getUniformLocation(v, "scale");
          f = n.getUniformLocation(v, "rotation");
          p = n.getUniformLocation(v, "screenPosition");
        }
        n.useProgram(v);
        u.initAttributes();
        u.enableAttribute(h);
        u.enableAttribute(r);
        u.disableUnusedAttributes();
        n.uniform1i(c, 0);
        n.uniform1i(b, 1);
        n.bindBuffer(n.ARRAY_BUFFER, w);
        n.vertexAttribPointer(h, 2, n.FLOAT, !1, 16, 0);
        n.vertexAttribPointer(r, 2, n.FLOAT, !1, 16, 8);
        n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t);
        u.disable(n.CULL_FACE);
        u.buffers.depth.setMask(!1);
        kb = 0;
        for (N = m.length;kb < N;kb++) {
          if (x = 16 / O.w, z.set(x * aa, x), E = m[kb], A.set(E.matrixWorld.elements[12], E.matrixWorld.elements[13], E.matrixWorld.elements[14]), A.applyMatrix4(G.matrixWorldInverse), A.applyMatrix4(G.projectionMatrix), C.copy(A), Fb.x = O.x + C.x * ma + ma - 8, Fb.y = O.y + C.y * Q + Q - 8, !0 === F.containsPoint(Fb)) {
            u.activeTexture(n.TEXTURE0);
            u.bindTexture(n.TEXTURE_2D, null);
            u.activeTexture(n.TEXTURE1);
            u.bindTexture(n.TEXTURE_2D, B);
            n.copyTexImage2D(n.TEXTURE_2D, 0, n.RGB, Fb.x, Fb.y, 16, 16, 0);
            n.uniform1i(a, 0);
            n.uniform2f(k, z.x, z.y);
            n.uniform3f(p, C.x, C.y, C.z);
            u.disable(n.BLEND);
            u.enable(n.DEPTH_TEST);
            n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0);
            u.activeTexture(n.TEXTURE0);
            u.bindTexture(n.TEXTURE_2D, y);
            n.copyTexImage2D(n.TEXTURE_2D, 0, n.RGBA, Fb.x, Fb.y, 16, 16, 0);
            n.uniform1i(a, 1);
            u.disable(n.DEPTH_TEST);
            u.activeTexture(n.TEXTURE1);
            u.bindTexture(n.TEXTURE_2D, B);
            n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0);
            E.positionScreen.copy(C);
            E.customUpdateCallback ? E.customUpdateCallback(E) : E.updateLensFlares();
            n.uniform1i(a, 2);
            u.enable(n.BLEND);
            for (var D = 0, Ze = E.lensFlares.length;D < Ze;D++) {
              var Ma = E.lensFlares[D];
              .001 < Ma.opacity && .001 < Ma.scale && (C.x = Ma.x, C.y = Ma.y, C.z = Ma.z, x = Ma.size * Ma.scale / O.w, z.x = x * aa, z.y = x, n.uniform3f(p, C.x, C.y, C.z), n.uniform2f(k, z.x, z.y), n.uniform1f(f, Ma.rotation), n.uniform1f(g, Ma.opacity), n.uniform3f(q, Ma.color.r, Ma.color.g, Ma.color.b), u.setBlending(Ma.blending, Ma.blendEquation, Ma.blendSrc, Ma.blendDst), d.setTexture2D(Ma.texture, 1), n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0));
            }
          }
        }
        u.enable(n.CULL_FACE);
        u.enable(n.DEPTH_TEST);
        u.buffers.depth.setMask(!0);
        d.resetGLState();
      }
    };
  }
  function fa(d, m) {
    function a(d, m) {
      return d.renderOrder !== m.renderOrder ? d.renderOrder - m.renderOrder : d.z !== m.z ? m.z - d.z : m.id - d.id;
    }
    var c, k, q, f, p, h, n, r, l, u, w, t, v, B, y, x, C, z = d.context, F = d.state, E, N, D, I, X = new e, J = new g, Z = new e;
    this.render = function(A, e) {
      if (0 !== m.length) {
        if (void 0 === D) {
          var G = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]), g = new Uint16Array([0, 1, 2, 0, 2, 3]);
          E = z.createBuffer();
          N = z.createBuffer();
          z.bindBuffer(z.ARRAY_BUFFER, E);
          z.bufferData(z.ARRAY_BUFFER, G, z.STATIC_DRAW);
          z.bindBuffer(z.ELEMENT_ARRAY_BUFFER, N);
          z.bufferData(z.ELEMENT_ARRAY_BUFFER, g, z.STATIC_DRAW);
          var G = z.createProgram(), g = z.createShader(z.VERTEX_SHADER), O = z.createShader(z.FRAGMENT_SHADER);
          z.shaderSource(g, ["precision " + d.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n"));
          z.shaderSource(O, ["precision " + d.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n"));
          z.compileShader(g);
          z.compileShader(O);
          z.attachShader(G, g);
          z.attachShader(G, O);
          z.linkProgram(G);
          D = G;
          x = z.getAttribLocation(D, "position");
          C = z.getAttribLocation(D, "uv");
          c = z.getUniformLocation(D, "uvOffset");
          k = z.getUniformLocation(D, "uvScale");
          q = z.getUniformLocation(D, "rotation");
          f = z.getUniformLocation(D, "scale");
          p = z.getUniformLocation(D, "color");
          h = z.getUniformLocation(D, "map");
          n = z.getUniformLocation(D, "opacity");
          r = z.getUniformLocation(D, "modelViewMatrix");
          l = z.getUniformLocation(D, "projectionMatrix");
          u = z.getUniformLocation(D, "fogType");
          w = z.getUniformLocation(D, "fogDensity");
          t = z.getUniformLocation(D, "fogNear");
          v = z.getUniformLocation(D, "fogFar");
          B = z.getUniformLocation(D, "fogColor");
          y = z.getUniformLocation(D, "alphaTest");
          G = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
          G.width = 8;
          G.height = 8;
          g = G.getContext("2d");
          g.fillStyle = "white";
          g.fillRect(0, 0, 8, 8);
          I = new b(G);
          I.needsUpdate = !0;
        }
        z.useProgram(D);
        F.initAttributes();
        F.enableAttribute(x);
        F.enableAttribute(C);
        F.disableUnusedAttributes();
        F.disable(z.CULL_FACE);
        F.enable(z.BLEND);
        z.bindBuffer(z.ARRAY_BUFFER, E);
        z.vertexAttribPointer(x, 2, z.FLOAT, !1, 16, 0);
        z.vertexAttribPointer(C, 2, z.FLOAT, !1, 16, 8);
        z.bindBuffer(z.ELEMENT_ARRAY_BUFFER, N);
        z.uniformMatrix4fv(l, !1, e.projectionMatrix.elements);
        F.activeTexture(z.TEXTURE0);
        z.uniform1i(h, 0);
        g = G = 0;
        (O = A.fog) ? (z.uniform3f(B, O.color.r, O.color.g, O.color.b), O.isFog ? (z.uniform1f(t, O.near), z.uniform1f(v, O.far), z.uniform1i(u, 1), g = G = 1) : O.isFogExp2 && (z.uniform1f(w, O.density), z.uniform1i(u, 2), g = G = 2)) : (z.uniform1i(u, 0), g = G = 0);
        for (var O = 0, aa = m.length;O < aa;O++) {
          var ma = m[O];
          ma.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, ma.matrixWorld);
          ma.z = -ma.modelViewMatrix.elements[14];
        }
        m.sort(a);
        e = [];
        O = 0;
        for (aa = m.length;O < aa;O++) {
          var ma = m[O], Q = ma.material;
          !1 !== Q.visible && (z.uniform1f(y, Q.alphaTest), z.uniformMatrix4fv(r, !1, ma.modelViewMatrix.elements), ma.matrixWorld.decompose(X, J, Z), e[0] = Z.x, e[1] = Z.y, ma = 0, A.fog && Q.fog && (ma = g), G !== ma && (z.uniform1i(u, ma), G = ma), null !== Q.map ? (z.uniform2f(c, Q.map.offset.x, Q.map.offset.y), z.uniform2f(k, Q.map.repeat.x, Q.map.repeat.y)) : (z.uniform2f(c, 0, 0), z.uniform2f(k, 1, 1)), z.uniform1f(n, Q.opacity), z.uniform3f(p, Q.color.r, Q.color.g, Q.color.b), z.uniform1f(q, 
          Q.rotation), z.uniform2fv(f, e), F.setBlending(Q.blending, Q.blendEquation, Q.blendSrc, Q.blendDst), F.buffers.depth.setTest(Q.depthTest), F.buffers.depth.setMask(Q.depthWrite), Q.map ? d.setTexture2D(Q.map, 0) : d.setTexture2D(I, 0), z.drawElements(z.TRIANGLES, 6, z.UNSIGNED_SHORT, 0));
        }
        F.enable(z.CULL_FACE);
        d.resetGLState();
      }
    };
  }
  function W() {
    Object.defineProperty(this, "id", {value:af++});
    this.uuid = ka.generateUUID();
    this.name = "";
    this.type = "Material";
    this.lights = this.fog = !0;
    this.blending = 1;
    this.side = 0;
    this.shading = 2;
    this.vertexColors = 0;
    this.opacity = 1;
    this.transparent = !1;
    this.blendSrc = 204;
    this.blendDst = 205;
    this.blendEquation = 100;
    this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
    this.depthFunc = 3;
    this.depthWrite = this.depthTest = !0;
    this.clippingPlanes = null;
    this.clipShadows = this.clipIntersection = !1;
    this.colorWrite = !0;
    this.precision = null;
    this.polygonOffset = !1;
    this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
    this.premultipliedAlpha = !1;
    this.overdraw = 0;
    this._needsUpdate = this.visible = !0;
  }
  function sa(d) {
    W.call(this);
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    this.linewidth = 1;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.morphNormals = this.morphTargets = this.clipping = this.lights = this.fog = !1;
    this.extensions = {derivatives:!1, fragDepth:!1, drawBuffers:!1, shaderTextureLOD:!1};
    this.defaultAttributeValues = {color:[1, 1, 1], uv:[0, 0], uv2:[0, 0]};
    this.index0AttributeName = void 0;
    void 0 !== d && (void 0 !== d.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(d));
  }
  function xa(d) {
    W.call(this);
    this.type = "MeshDepthMaterial";
    this.depthPacking = 3200;
    this.morphTargets = !1;
    this.displacementMap = this.alphaMap = this.map = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.lights = this.fog = !1;
    this.setValues(d);
  }
  function Aa(d, m) {
    this.min = void 0 !== d ? d : new e(Infinity, Infinity, Infinity);
    this.max = void 0 !== m ? m : new e(-Infinity, -Infinity, -Infinity);
  }
  function Ba(d, m) {
    this.center = void 0 !== d ? d : new e;
    this.radius = void 0 !== m ? m : 0;
  }
  function ya() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }
  function Ea(d, m) {
    this.normal = void 0 !== d ? d : new e(1, 0, 0);
    this.constant = void 0 !== m ? m : 0;
  }
  function Xa(d, m, a, b, c, e) {
    this.planes = [void 0 !== d ? d : new Ea, void 0 !== m ? m : new Ea, void 0 !== a ? a : new Ea, void 0 !== b ? b : new Ea, void 0 !== c ? c : new Ea, void 0 !== e ? e : new Ea];
  }
  function vd(d, m, a, b) {
    function A(m, a, A, b) {
      var c = m.geometry, e;
      e = v;
      var G = m.customDepthMaterial;
      A && (e = B, G = m.customDistanceMaterial);
      G ? e = G : (G = !1, a.morphTargets && (c && c.isBufferGeometry ? G = c.morphAttributes && c.morphAttributes.position && 0 < c.morphAttributes.position.length : c && c.isGeometry && (G = c.morphTargets && 0 < c.morphTargets.length)), m = m.isSkinnedMesh, c = 0, G && (c |= 1), m && (c |= 2), e = e[c]);
      d.localClippingEnabled && !0 === a.clipShadows && 0 !== a.clippingPlanes.length && (c = e.uuid, G = a.uuid, m = y[c], void 0 === m && (m = {}, y[c] = m), c = m[G], void 0 === c && (c = e.clone(), m[G] = c), e = c);
      e.visible = a.visible;
      e.wireframe = a.wireframe;
      G = a.side;
      I.renderSingleSided && 2 == G && (G = 0);
      I.renderReverseSided && (0 === G ? G = 1 : 1 === G && (G = 0));
      e.side = G;
      e.clipShadows = a.clipShadows;
      e.clippingPlanes = a.clippingPlanes;
      e.wireframeLinewidth = a.wireframeLinewidth;
      e.linewidth = a.linewidth;
      A && void 0 !== e.uniforms.lightPos && e.uniforms.lightPos.value.copy(b);
      return e;
    }
    function c(m, b, e, G) {
      if (!1 !== m.visible) {
        if (m.layers.test(b.layers) && (m.isMesh || m.isLine || m.isPoints) && m.castShadow && (!m.frustumCulled || q.intersectsObject(m))) {
          m.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, m.matrixWorld);
          var g = a.update(m), k = m.material;
          if (Array.isArray(k)) {
            for (var f = g.groups, p = 0, h = f.length;p < h;p++) {
              var n = f[p], O = k[n.materialIndex];
              O && O.visible && (O = A(m, O, G, t), d.renderBufferDirect(e, null, g, O, m, n));
            }
          } else {
            k.visible && (O = A(m, k, G, t), d.renderBufferDirect(e, null, g, O, m, null));
          }
        }
        m = m.children;
        g = 0;
        for (k = m.length;g < k;g++) {
          c(m[g], b, e, G);
        }
      }
    }
    var G = d.context, g = d.state, q = new Xa, h = new p, n = m.shadows, r = new l, u = new l(b.maxTextureSize, b.maxTextureSize), w = new e, t = new e, v = Array(4), B = Array(4), y = {}, z = [new e(1, 0, 0), new e(-1, 0, 0), new e(0, 0, 1), new e(0, 0, -1), new e(0, 1, 0), new e(0, -1, 0)], x = [new e(0, 1, 0), new e(0, 1, 0), new e(0, 1, 0), new e(0, 1, 0), new e(0, 0, 1), new e(0, 0, -1)], C = [new f, new f, new f, new f, new f, new f];
    m = new xa;
    m.depthPacking = 3201;
    m.clipping = !0;
    b = zb.distanceRGBA;
    for (var F = Sa.clone(b.uniforms), D = 0;4 !== D;++D) {
      var E = 0 !== (D & 1), N = m.clone();
      N.morphTargets = E;
      v[D] = N;
      E = new sa({defines:{USE_SHADOWMAP:""}, uniforms:F, vertexShader:b.vertexShader, fragmentShader:b.fragmentShader, morphTargets:E, clipping:!0});
      B[D] = E;
    }
    var I = this;
    this.enabled = !1;
    this.autoUpdate = !0;
    this.needsUpdate = !1;
    this.type = 1;
    this.renderSingleSided = this.renderReverseSided = !0;
    this.render = function(m, a) {
      if (!1 !== I.enabled && (!1 !== I.autoUpdate || !1 !== I.needsUpdate) && 0 !== n.length) {
        g.disable(G.BLEND);
        g.buffers.color.setClear(1, 1, 1, 1);
        g.buffers.depth.setTest(!0);
        g.setScissorTest(!1);
        for (var A, b, e = 0, f = n.length;e < f;e++) {
          var p = n[e], O = p.shadow;
          if (void 0 === O) {
            console.warn("THREE.WebGLShadowMap:", p, "has no shadow.");
          } else {
            var l = O.camera;
            r.copy(O.mapSize);
            r.min(u);
            if (p && p.isPointLight) {
              A = 6;
              b = !0;
              var aa = r.x, ma = r.y;
              C[0].set(2 * aa, ma, aa, ma);
              C[1].set(0, ma, aa, ma);
              C[2].set(3 * aa, ma, aa, ma);
              C[3].set(aa, ma, aa, ma);
              C[4].set(3 * aa, 0, aa, ma);
              C[5].set(aa, 0, aa, ma);
              r.x *= 4;
              r.y *= 2;
            } else {
              A = 1, b = !1;
            }
            null === O.map && (O.map = new k(r.x, r.y, {minFilter:1003, magFilter:1003, format:1023}), O.map.texture.name = p.name + ".shadowMap", l.updateProjectionMatrix());
            O.isSpotLightShadow && O.update(p);
            O && O.isRectAreaLightShadow && O.update(p);
            aa = O.map;
            O = O.matrix;
            t.setFromMatrixPosition(p.matrixWorld);
            l.position.copy(t);
            d.setRenderTarget(aa);
            d.clear();
            for (aa = 0;aa < A;aa++) {
              b ? (w.copy(l.position), w.add(z[aa]), l.up.copy(x[aa]), l.lookAt(w), g.viewport(C[aa])) : (w.setFromMatrixPosition(p.target.matrixWorld), l.lookAt(w)), l.updateMatrixWorld(), l.matrixWorldInverse.getInverse(l.matrixWorld), O.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), O.multiply(l.projectionMatrix), O.multiply(l.matrixWorldInverse), h.multiplyMatrices(l.projectionMatrix, l.matrixWorldInverse), q.setFromMatrix(h), c(m, a, l, b);
            }
          }
        }
        A = d.getClearColor();
        b = d.getClearAlpha();
        d.setClearColor(A, b);
        I.needsUpdate = !1;
      }
    };
  }
  function Ta(d, m) {
    this.origin = void 0 !== d ? d : new e;
    this.direction = void 0 !== m ? m : new e;
  }
  function Ua(d, m, a, b) {
    this._x = d || 0;
    this._y = m || 0;
    this._z = a || 0;
    this._order = b || Ua.DefaultOrder;
  }
  function Kc() {
    this.mask = 1;
  }
  function U() {
    Object.defineProperty(this, "id", {value:bf++});
    this.uuid = ka.generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = U.DefaultUp.clone();
    var d = new e, m = new Ua, a = new g, b = new e(1, 1, 1);
    m.onChange(function() {
      a.setFromEuler(m, !1);
    });
    a.onChange(function() {
      m.setFromQuaternion(a, void 0, !1);
    });
    Object.defineProperties(this, {position:{enumerable:!0, value:d}, rotation:{enumerable:!0, value:m}, quaternion:{enumerable:!0, value:a}, scale:{enumerable:!0, value:b}, modelViewMatrix:{value:new p}, normalMatrix:{value:new ya}});
    this.matrix = new p;
    this.matrixWorld = new p;
    this.matrixAutoUpdate = U.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = !1;
    this.layers = new Kc;
    this.visible = !0;
    this.receiveShadow = this.castShadow = !1;
    this.frustumCulled = !0;
    this.renderOrder = 0;
    this.userData = {};
    this.onBeforeRender = function() {
    };
    this.onAfterRender = function() {
    };
  }
  function Ab(d, m) {
    this.start = void 0 !== d ? d : new e;
    this.end = void 0 !== m ? m : new e;
  }
  function Ia(d, m, a) {
    this.a = void 0 !== d ? d : new e;
    this.b = void 0 !== m ? m : new e;
    this.c = void 0 !== a ? a : new e;
  }
  function za(d, m, a, b, c, g) {
    this.a = d;
    this.b = m;
    this.c = a;
    this.normal = b && b.isVector3 ? b : new e;
    this.vertexNormals = Array.isArray(b) ? b : [];
    this.color = c && c.isColor ? c : new T;
    this.vertexColors = Array.isArray(c) ? c : [];
    this.materialIndex = void 0 !== g ? g : 0;
  }
  function Ka(d) {
    W.call(this);
    this.type = "MeshBasicMaterial";
    this.color = new T(16777215);
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.envMap = this.alphaMap = this.specularMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.lights = this.morphTargets = !1;
    this.setValues(d);
  }
  function ja(d, m, a) {
    if (Array.isArray(d)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    Object.defineProperty(this, "id", {value:cf++});
    this.uuid = ka.generateUUID();
    this.array = d;
    this.itemSize = m;
    this.count = void 0 !== d ? d.length / m : 0;
    this.normalized = !0 === a;
    this.dynamic = !1;
    this.updateRange = {offset:0, count:-1};
    this.onUploadCallback = function() {
    };
    this.version = 0;
  }
  function tb(d, m) {
    ja.call(this, new Int8Array(d), m);
  }
  function lb(d, m) {
    ja.call(this, new Uint8Array(d), m);
  }
  function La(d, m) {
    ja.call(this, new Uint8ClampedArray(d), m);
  }
  function Bb(d, m) {
    ja.call(this, new Int16Array(d), m);
  }
  function $a(d, m) {
    ja.call(this, new Uint16Array(d), m);
  }
  function ab(d, m) {
    ja.call(this, new Int32Array(d), m);
  }
  function mb(d, m) {
    ja.call(this, new Uint32Array(d), m);
  }
  function Y(d, m) {
    ja.call(this, new Float32Array(d), m);
  }
  function ub(d, m) {
    ja.call(this, new Float64Array(d), m);
  }
  function Lc() {
    this.indices = [];
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    this.boundingSphere = this.boundingBox = null;
    this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1;
  }
  function nb(d) {
    for (var m = d.length, a = -Infinity;m--;) {
      d[m] > a && (a = d[m]);
    }
    return a;
  }
  function ca() {
    Object.defineProperty(this, "id", {value:be++});
    this.uuid = ka.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingSphere = this.boundingBox = null;
    this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1;
  }
  function da() {
    Object.defineProperty(this, "id", {value:be++});
    this.uuid = ka.generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingSphere = this.boundingBox = null;
    this.drawRange = {start:0, count:Infinity};
  }
  function Ga(d, m) {
    U.call(this);
    this.type = "Mesh";
    this.geometry = void 0 !== d ? d : new da;
    this.material = void 0 !== m ? m : new Ka({color:16777215 * Math.random()});
    this.drawMode = 0;
    this.updateMorphTargets();
  }
  function Na(d, m, a, b, c, e) {
    ca.call(this);
    this.type = "BoxGeometry";
    this.parameters = {width:d, height:m, depth:a, widthSegments:b, heightSegments:c, depthSegments:e};
    this.fromBufferGeometry(new Va(d, m, a, b, c, e));
    this.mergeVertices();
  }
  function Va(d, m, a, b, c, g) {
    function A(d, m, a, A, b, c, g, O, r, l, u) {
      var w = c / r, aa = g / l, t = c / 2, ma = g / 2, v = O / 2;
      g = r + 1;
      var B = l + 1, y = c = 0, Q, z, x = new e;
      for (z = 0;z < B;z++) {
        var C = z * aa - ma;
        for (Q = 0;Q < g;Q++) {
          x[d] = (Q * w - t) * A, x[m] = C * b, x[a] = v, f.push(x.x, x.y, x.z), x[d] = 0, x[m] = 0, x[a] = 0 < O ? 1 : -1, q.push(x.x, x.y, x.z), p.push(Q / r), p.push(1 - z / l), c += 1;
        }
      }
      for (z = 0;z < l;z++) {
        for (Q = 0;Q < r;Q++) {
          d = h + Q + g * (z + 1), m = h + (Q + 1) + g * (z + 1), a = h + (Q + 1) + g * z, k.push(h + Q + g * z, d, a), k.push(d, m, a), y += 6;
        }
      }
      G.addGroup(n, y, u);
      n += y;
      h += c;
    }
    da.call(this);
    this.type = "BoxBufferGeometry";
    this.parameters = {width:d, height:m, depth:a, widthSegments:b, heightSegments:c, depthSegments:g};
    var G = this;
    b = Math.floor(b) || 1;
    c = Math.floor(c) || 1;
    g = Math.floor(g) || 1;
    var k = [], f = [], q = [], p = [], h = 0, n = 0;
    A("z", "y", "x", -1, -1, a, m, d, g, c, 0);
    A("z", "y", "x", 1, -1, a, m, -d, g, c, 1);
    A("x", "z", "y", 1, 1, d, a, m, b, g, 2);
    A("x", "z", "y", 1, -1, d, a, -m, b, g, 3);
    A("x", "y", "z", 1, -1, d, m, a, b, c, 4);
    A("x", "y", "z", -1, -1, d, m, -a, b, c, 5);
    this.setIndex(k);
    this.addAttribute("position", new Y(f, 3));
    this.addAttribute("normal", new Y(q, 3));
    this.addAttribute("uv", new Y(p, 2));
  }
  function ob(d, m, a, b) {
    ca.call(this);
    this.type = "PlaneGeometry";
    this.parameters = {width:d, height:m, widthSegments:a, heightSegments:b};
    this.fromBufferGeometry(new Gb(d, m, a, b));
  }
  function Gb(d, m, a, b) {
    da.call(this);
    this.type = "PlaneBufferGeometry";
    this.parameters = {width:d, height:m, widthSegments:a, heightSegments:b};
    var A = d / 2, c = m / 2;
    a = Math.floor(a) || 1;
    b = Math.floor(b) || 1;
    var e = a + 1, g = b + 1, G = d / a, k = m / b, f = [], q = [], p = [], h = [];
    for (d = 0;d < g;d++) {
      var n = d * k - c;
      for (m = 0;m < e;m++) {
        q.push(m * G - A, -n, 0), p.push(0, 0, 1), h.push(m / a), h.push(1 - d / b);
      }
    }
    for (d = 0;d < b;d++) {
      for (m = 0;m < a;m++) {
        A = m + e * (d + 1), c = m + 1 + e * (d + 1), g = m + 1 + e * d, f.push(m + e * d, A, g), f.push(A, c, g);
      }
    }
    this.setIndex(f);
    this.addAttribute("position", new Y(q, 3));
    this.addAttribute("normal", new Y(p, 3));
    this.addAttribute("uv", new Y(h, 2));
  }
  function Ja() {
    U.call(this);
    this.type = "Camera";
    this.matrixWorldInverse = new p;
    this.projectionMatrix = new p;
  }
  function Oa(d, m, a, b) {
    Ja.call(this);
    this.type = "PerspectiveCamera";
    this.fov = void 0 !== d ? d : 50;
    this.zoom = 1;
    this.near = void 0 !== a ? a : .1;
    this.far = void 0 !== b ? b : 2E3;
    this.focus = 10;
    this.aspect = void 0 !== m ? m : 1;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  function Zb(d, m, a, b, c, e) {
    Ja.call(this);
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = d;
    this.right = m;
    this.top = a;
    this.bottom = b;
    this.near = void 0 !== c ? c : .1;
    this.far = void 0 !== e ? e : 2E3;
    this.updateProjectionMatrix();
  }
  function df(d) {
    var m = {};
    return {get:function(d) {
      d.isInterleavedBufferAttribute && (d = d.data);
      return m[d.id];
    }, remove:function(a) {
      var A = m[a.id];
      A && (d.deleteBuffer(A.buffer), delete m[a.id]);
    }, update:function(a, b) {
      a.isInterleavedBufferAttribute && (a = a.data);
      var A = m[a.id];
      if (void 0 === A) {
        var A = a.id, c = a, e = c.array;
        a = c.dynamic ? d.DYNAMIC_DRAW : d.STATIC_DRAW;
        var g = d.createBuffer();
        d.bindBuffer(b, g);
        d.bufferData(b, e, a);
        c.onUploadCallback();
        a = d.FLOAT;
        e instanceof Float32Array ? a = d.FLOAT : e instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : e instanceof Uint16Array ? a = d.UNSIGNED_SHORT : e instanceof Int16Array ? a = d.SHORT : e instanceof Uint32Array ? a = d.UNSIGNED_INT : e instanceof Int32Array ? a = d.INT : e instanceof Int8Array ? a = d.BYTE : e instanceof Uint8Array && (a = d.UNSIGNED_BYTE);
        m[A] = {buffer:g, type:a, bytesPerElement:e.BYTES_PER_ELEMENT, version:c.version};
      } else {
        A.version < a.version && (c = a, e = c.array, g = c.updateRange, d.bindBuffer(b, A.buffer), !1 === c.dynamic ? d.bufferData(b, e, d.STATIC_DRAW) : -1 === g.count ? d.bufferSubData(b, 0, e) : 0 === g.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (d.bufferSubData(b, g.offset * e.BYTES_PER_ELEMENT, e.subarray(g.offset, g.offset + g.count)), g.count = 
        0), A.version = a.version);
      }
    }};
  }
  function ef(d, m, a) {
    var b, A, c;
    return {setMode:function(d) {
      b = d;
    }, setIndex:function(a) {
      a.array instanceof Uint32Array && m.get("OES_element_index_uint") ? (A = d.UNSIGNED_INT, c = 4) : a.array instanceof Uint16Array ? (A = d.UNSIGNED_SHORT, c = 2) : (A = d.UNSIGNED_BYTE, c = 1);
    }, render:function(m, e) {
      d.drawElements(b, e, A, m * c);
      a.calls++;
      a.vertices += e;
      b === d.TRIANGLES && (a.faces += e / 3);
    }, renderInstances:function(e, g, G) {
      var k = m.get("ANGLE_instanced_arrays");
      null === k ? console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (k.drawElementsInstancedANGLE(b, G, A, g * c, e.maxInstancedCount), a.calls++, a.vertices += G * e.maxInstancedCount, b === d.TRIANGLES && (a.faces += e.maxInstancedCount * G / 3));
    }};
  }
  function ff(d, m, a) {
    var b;
    return {setMode:function(d) {
      b = d;
    }, render:function(m, A) {
      d.drawArrays(b, m, A);
      a.calls++;
      a.vertices += A;
      b === d.TRIANGLES && (a.faces += A / 3);
    }, renderInstances:function(A) {
      var c = m.get("ANGLE_instanced_arrays");
      if (null === c) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      } else {
        var e = A.attributes.position, e = e.isInterleavedBufferAttribute ? e.data.count : e.count;
        c.drawArraysInstancedANGLE(b, 0, e, A.maxInstancedCount);
        a.calls++;
        a.vertices += e * A.maxInstancedCount;
        b === d.TRIANGLES && (a.faces += A.maxInstancedCount * e / 3);
      }
    }};
  }
  function gf(d, m, a) {
    function b(d) {
      d = d.target;
      var e = A[d.id];
      null !== e.index && m.remove(e.index);
      for (var g in e.attributes) {
        m.remove(e.attributes[g]);
      }
      d.removeEventListener("dispose", b);
      delete A[d.id];
      if (g = c[d.id]) {
        m.remove(g), delete c[d.id];
      }
      if (g = c[e.id]) {
        m.remove(g), delete c[e.id];
      }
      a.geometries--;
    }
    var A = {}, c = {};
    return {get:function(d, m) {
      var c = A[m.id];
      if (c) {
        return c;
      }
      m.addEventListener("dispose", b);
      m.isBufferGeometry ? c = m : m.isGeometry && (void 0 === m._bufferGeometry && (m._bufferGeometry = (new da).setFromObject(d)), c = m._bufferGeometry);
      A[m.id] = c;
      a.geometries++;
      return c;
    }, update:function(a) {
      var b = a.index, A = a.attributes;
      null !== b && m.update(b, d.ELEMENT_ARRAY_BUFFER);
      for (var c in A) {
        m.update(A[c], d.ARRAY_BUFFER);
      }
      a = a.morphAttributes;
      for (c in a) {
        for (var b = a[c], A = 0, e = b.length;A < e;A++) {
          m.update(b[A], d.ARRAY_BUFFER);
        }
      }
    }, getWireframeAttribute:function(a) {
      var b = c[a.id];
      if (b) {
        return b;
      }
      var b = [], A = a.index, e = a.attributes;
      if (null !== A) {
        for (var A = A.array, e = 0, g = A.length;e < g;e += 3) {
          var G = A[e + 0], k = A[e + 1], f = A[e + 2];
          b.push(G, k, k, f, f, G);
        }
      } else {
        for (A = e.position.array, e = 0, g = A.length / 3 - 1;e < g;e += 3) {
          G = e + 0, k = e + 1, f = e + 2, b.push(G, k, k, f, f, G);
        }
      }
      b = new (65535 < nb(b) ? mb : $a)(b, 1);
      m.update(b, d.ELEMENT_ARRAY_BUFFER);
      return c[a.id] = b;
    }};
  }
  function hf() {
    var d = {};
    return {get:function(m) {
      if (void 0 !== d[m.id]) {
        return d[m.id];
      }
      var a;
      switch(m.type) {
        case "DirectionalLight":
          a = {direction:new e, color:new T, shadow:!1, shadowBias:0, shadowRadius:1, shadowMapSize:new l};
          break;
        case "SpotLight":
          a = {position:new e, direction:new e, color:new T, distance:0, coneCos:0, penumbraCos:0, decay:0, shadow:!1, shadowBias:0, shadowRadius:1, shadowMapSize:new l};
          break;
        case "PointLight":
          a = {position:new e, color:new T, distance:0, decay:0, shadow:!1, shadowBias:0, shadowRadius:1, shadowMapSize:new l};
          break;
        case "HemisphereLight":
          a = {direction:new e, skyColor:new T, groundColor:new T};
          break;
        case "RectAreaLight":
          a = {color:new T, position:new e, halfWidth:new e, halfHeight:new e};
      }
      return d[m.id] = a;
    }};
  }
  function jf(d, m, a) {
    var b = {};
    return {update:function(d) {
      var A = a.frame, c = d.geometry, e = m.get(d, c);
      b[e.id] !== A && (c.isGeometry && e.updateFromObject(d), m.update(e), b[e.id] = A);
      return e;
    }, clear:function() {
      b = {};
    }};
  }
  function $b(d) {
    d = d.split("\n");
    for (var m = 0;m < d.length;m++) {
      d[m] = m + 1 + ": " + d[m];
    }
    return d.join("\n");
  }
  function pb(d, m, a) {
    var b = d.createShader(m);
    d.shaderSource(b, a);
    d.compileShader(b);
    !1 === d.getShaderParameter(b, d.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile.");
    "" !== d.getShaderInfoLog(b) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", m === d.VERTEX_SHADER ? "vertex" : "fragment", d.getShaderInfoLog(b), $b(a));
    return b;
  }
  function Hb(d) {
    switch(d) {
      case 3E3:
        return ["Linear", "( value )"];
      case 3001:
        return ["sRGB", "( value )"];
      case 3002:
        return ["RGBE", "( value )"];
      case 3004:
        return ["RGBM", "( value, 7.0 )"];
      case 3005:
        return ["RGBM", "( value, 16.0 )"];
      case 3006:
        return ["RGBD", "( value, 256.0 )"];
      case 3007:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      default:
        throw Error("unsupported encoding: " + d);
    }
  }
  function Cb(d, m) {
    m = Hb(m);
    return "vec4 " + d + "( vec4 value ) { return " + m[0] + "ToLinear" + m[1] + "; }";
  }
  function va(d, m) {
    m = Hb(m);
    return "vec4 " + d + "( vec4 value ) { return LinearTo" + m[0] + m[1] + "; }";
  }
  function Wa(d, m) {
    switch(m) {
      case 1:
        m = "Linear";
        break;
      case 2:
        m = "Reinhard";
        break;
      case 3:
        m = "Uncharted2";
        break;
      case 4:
        m = "OptimizedCineon";
        break;
      default:
        throw Error("unsupported toneMapping: " + m);
    }
    return "vec3 " + d + "( vec3 color ) { return " + m + "ToneMapping( color ); }";
  }
  function Db(d, m, a) {
    d = d || {};
    return [d.derivatives || m.envMapCubeUV || m.bumpMap || m.normalMap || m.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (d.fragDepth || m.logarithmicDepthBuffer) && a.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", d.drawBuffers && a.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (d.shaderTextureLOD || m.envMap) && a.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Pa).join("\n");
  }
  function Mc(d) {
    var m = [], a;
    for (a in d) {
      var b = d[a];
      !1 !== b && m.push("#define " + a + " " + b);
    }
    return m.join("\n");
  }
  function Pa(d) {
    return "" !== d;
  }
  function wd(d, m) {
    return d.replace(/NUM_DIR_LIGHTS/g, m.numDirLights).replace(/NUM_SPOT_LIGHTS/g, m.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, m.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, m.numPointLights).replace(/NUM_HEMI_LIGHTS/g, m.numHemiLights);
  }
  function vb(d) {
    return d.replace(/#include +<([\w\d.]+)>/g, function(d, a) {
      d = na[a];
      if (void 0 === d) {
        throw Error("Can not resolve #include <" + a + ">");
      }
      return vb(d);
    });
  }
  function He(d) {
    return d.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(d, a, b, c) {
      d = "";
      for (a = parseInt(a);a < parseInt(b);a++) {
        d += c.replace(/\[ i \]/g, "[ " + a + " ]");
      }
      return d;
    });
  }
  function qb(d, m, a, b) {
    var A = d.context, c = a.extensions, e = a.defines, g = a.__webglShader.vertexShader, k = a.__webglShader.fragmentShader, f = "SHADOWMAP_TYPE_BASIC";
    1 === b.shadowMapType ? f = "SHADOWMAP_TYPE_PCF" : 2 === b.shadowMapType && (f = "SHADOWMAP_TYPE_PCF_SOFT");
    var q = "ENVMAP_TYPE_CUBE", G = "ENVMAP_MODE_REFLECTION", p = "ENVMAP_BLENDING_MULTIPLY";
    if (b.envMap) {
      switch(a.envMap.mapping) {
        case 301:
        case 302:
          q = "ENVMAP_TYPE_CUBE";
          break;
        case 306:
        case 307:
          q = "ENVMAP_TYPE_CUBE_UV";
          break;
        case 303:
        case 304:
          q = "ENVMAP_TYPE_EQUIREC";
          break;
        case 305:
          q = "ENVMAP_TYPE_SPHERE";
      }
      switch(a.envMap.mapping) {
        case 302:
        case 304:
          G = "ENVMAP_MODE_REFRACTION";
      }
      switch(a.combine) {
        case 0:
          p = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case 1:
          p = "ENVMAP_BLENDING_MIX";
          break;
        case 2:
          p = "ENVMAP_BLENDING_ADD";
      }
    }
    var h = 0 < d.gammaFactor ? d.gammaFactor : 1, c = Db(c, b, d.extensions), n = Mc(e), r = A.createProgram();
    a.isRawShaderMaterial ? (e = [n, "\n"].filter(Pa).join("\n"), f = [c, n, "\n"].filter(Pa).join("\n")) : (e = ["precision " + b.precision + " float;", "precision " + b.precision + " int;", "#define SHADER_NAME " + a.__webglShader.name, n, b.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + h, "#define MAX_BONES " + b.maxBones, b.useFog && b.fog ? "#define USE_FOG" : "", b.useFog && b.fogExp ? "#define FOG_EXP2" : "", b.map ? "#define USE_MAP" : "", b.envMap ? "#define USE_ENVMAP" : 
    "", b.envMap ? "#define " + G : "", b.lightMap ? "#define USE_LIGHTMAP" : "", b.aoMap ? "#define USE_AOMAP" : "", b.emissiveMap ? "#define USE_EMISSIVEMAP" : "", b.bumpMap ? "#define USE_BUMPMAP" : "", b.normalMap ? "#define USE_NORMALMAP" : "", b.displacementMap && b.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", b.specularMap ? "#define USE_SPECULARMAP" : "", b.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", b.metalnessMap ? "#define USE_METALNESSMAP" : "", b.alphaMap ? "#define USE_ALPHAMAP" : 
    "", b.vertexColors ? "#define USE_COLOR" : "", b.flatShading ? "#define FLAT_SHADED" : "", b.skinning ? "#define USE_SKINNING" : "", b.useVertexTexture ? "#define BONE_TEXTURE" : "", b.morphTargets ? "#define USE_MORPHTARGETS" : "", b.morphNormals && !1 === b.flatShading ? "#define USE_MORPHNORMALS" : "", b.doubleSided ? "#define DOUBLE_SIDED" : "", b.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + b.numClippingPlanes, b.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", 
    b.shadowMapEnabled ? "#define " + f : "", b.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", b.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", b.logarithmicDepthBuffer && d.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", 
    "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", 
    "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Pa).join("\n"), f = [c, "precision " + b.precision + " float;", "precision " + b.precision + " int;", "#define SHADER_NAME " + a.__webglShader.name, n, b.alphaTest ? "#define ALPHATEST " + b.alphaTest : "", "#define GAMMA_FACTOR " + h, b.useFog && b.fog ? "#define USE_FOG" : "", b.useFog && b.fogExp ? 
    "#define FOG_EXP2" : "", b.map ? "#define USE_MAP" : "", b.envMap ? "#define USE_ENVMAP" : "", b.envMap ? "#define " + q : "", b.envMap ? "#define " + G : "", b.envMap ? "#define " + p : "", b.lightMap ? "#define USE_LIGHTMAP" : "", b.aoMap ? "#define USE_AOMAP" : "", b.emissiveMap ? "#define USE_EMISSIVEMAP" : "", b.bumpMap ? "#define USE_BUMPMAP" : "", b.normalMap ? "#define USE_NORMALMAP" : "", b.specularMap ? "#define USE_SPECULARMAP" : "", b.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", 
    b.metalnessMap ? "#define USE_METALNESSMAP" : "", b.alphaMap ? "#define USE_ALPHAMAP" : "", b.vertexColors ? "#define USE_COLOR" : "", b.gradientMap ? "#define USE_GRADIENTMAP" : "", b.flatShading ? "#define FLAT_SHADED" : "", b.doubleSided ? "#define DOUBLE_SIDED" : "", b.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + b.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (b.numClippingPlanes - b.numClipIntersection), b.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", 
    b.shadowMapEnabled ? "#define " + f : "", b.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", b.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", b.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", b.logarithmicDepthBuffer && d.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", b.envMap && d.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== b.toneMapping ? 
    "#define TONE_MAPPING" : "", 0 !== b.toneMapping ? na.tonemapping_pars_fragment : "", 0 !== b.toneMapping ? Wa("toneMapping", b.toneMapping) : "", b.outputEncoding || b.mapEncoding || b.envMapEncoding || b.emissiveMapEncoding ? na.encodings_pars_fragment : "", b.mapEncoding ? Cb("mapTexelToLinear", b.mapEncoding) : "", b.envMapEncoding ? Cb("envMapTexelToLinear", b.envMapEncoding) : "", b.emissiveMapEncoding ? Cb("emissiveMapTexelToLinear", b.emissiveMapEncoding) : "", b.outputEncoding ? va("linearToOutputTexel", 
    b.outputEncoding) : "", b.depthPacking ? "#define DEPTH_PACKING " + a.depthPacking : "", "\n"].filter(Pa).join("\n"));
    g = vb(g, b);
    g = wd(g, b);
    k = vb(k, b);
    k = wd(k, b);
    a.isShaderMaterial || (g = He(g), k = He(k));
    k = f + k;
    g = pb(A, A.VERTEX_SHADER, e + g);
    k = pb(A, A.FRAGMENT_SHADER, k);
    A.attachShader(r, g);
    A.attachShader(r, k);
    void 0 !== a.index0AttributeName ? A.bindAttribLocation(r, 0, a.index0AttributeName) : !0 === b.morphTargets && A.bindAttribLocation(r, 0, "position");
    A.linkProgram(r);
    b = A.getProgramInfoLog(r);
    q = A.getShaderInfoLog(g);
    G = A.getShaderInfoLog(k);
    h = p = !0;
    if (!1 === A.getProgramParameter(r, A.LINK_STATUS)) {
      p = !1, console.error("THREE.WebGLProgram: shader error: ", A.getError(), "gl.VALIDATE_STATUS", A.getProgramParameter(r, A.VALIDATE_STATUS), "gl.getProgramInfoLog", b, q, G);
    } else {
      if ("" !== b) {
        console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", b);
      } else {
        if ("" === q || "" === G) {
          h = !1;
        }
      }
    }
    h && (this.diagnostics = {runnable:p, material:a, programLog:b, vertexShader:{log:q, prefix:e}, fragmentShader:{log:G, prefix:f}});
    A.deleteShader(g);
    A.deleteShader(k);
    var l;
    this.getUniforms = function() {
      void 0 === l && (l = new ta(A, r, d));
      return l;
    };
    var u;
    this.getAttributes = function() {
      if (void 0 === u) {
        for (var d = {}, m = A.getProgramParameter(r, A.ACTIVE_ATTRIBUTES), a = 0;a < m;a++) {
          var b = A.getActiveAttrib(r, a).name;
          d[b] = A.getAttribLocation(r, b);
        }
        u = d;
      }
      return u;
    };
    this.destroy = function() {
      A.deleteProgram(r);
      this.program = void 0;
    };
    Object.defineProperties(this, {uniforms:{get:function() {
      console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
      return this.getUniforms();
    }}, attributes:{get:function() {
      console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
      return this.getAttributes();
    }}});
    this.id = kf++;
    this.code = m;
    this.usedTimes = 1;
    this.program = r;
    this.vertexShader = g;
    this.fragmentShader = k;
    return this;
  }
  function lf(d, m) {
    function a(d, m) {
      var a;
      d ? d.isTexture ? a = d.encoding : d.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), a = d.texture.encoding) : a = 3E3;
      3E3 === a && m && (a = 3007);
      return a;
    }
    var b = [], c = {MeshDepthMaterial:"depth", MeshNormalMaterial:"normal", MeshBasicMaterial:"basic", MeshLambertMaterial:"lambert", MeshPhongMaterial:"phong", MeshToonMaterial:"phong", MeshStandardMaterial:"physical", MeshPhysicalMaterial:"physical", LineBasicMaterial:"basic", LineDashedMaterial:"dashed", PointsMaterial:"points"}, e = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking".split(" ");
    this.getParameters = function(b, A, e, g, k, f) {
      var q = c[b.type], G;
      if (f.isSkinnedMesh) {
        G = f.skeleton;
        var p = G.bones;
        if (m.floatVertexTextures) {
          if (void 0 === G.boneTexture) {
            var p = Math.sqrt(4 * p.length), p = ka.nextPowerOfTwo(Math.ceil(p)), p = Math.max(p, 4), h = new Float32Array(p * p * 4);
            h.set(G.boneMatrices);
            var n = new ra(h, p, p, 1023, 1015);
            G.boneMatrices = h;
            G.boneTexture = n;
            G.boneTextureSize = p;
          }
          G = 1024;
        } else {
          G = Math.min(Math.floor((m.maxVertexUniforms - 20) / 4), p.length), G < p.length && (console.warn("THREE.WebGLRenderer: Skeleton has " + p.length + " bones. This GPU supports " + G + "."), G = 0);
        }
      } else {
        G = 0;
      }
      p = d.getPrecision();
      null !== b.precision && (p = m.getMaxPrecision(b.precision), p !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", p, "instead."));
      h = d.getCurrentRenderTarget();
      return {shaderID:q, precision:p, supportsVertexTextures:m.vertexTextures, outputEncoding:a(h ? h.texture : null, d.gammaOutput), map:!!b.map, mapEncoding:a(b.map, d.gammaInput), envMap:!!b.envMap, envMapMode:b.envMap && b.envMap.mapping, envMapEncoding:a(b.envMap, d.gammaInput), envMapCubeUV:!!b.envMap && (306 === b.envMap.mapping || 307 === b.envMap.mapping), lightMap:!!b.lightMap, aoMap:!!b.aoMap, emissiveMap:!!b.emissiveMap, emissiveMapEncoding:a(b.emissiveMap, d.gammaInput), bumpMap:!!b.bumpMap, 
      normalMap:!!b.normalMap, displacementMap:!!b.displacementMap, roughnessMap:!!b.roughnessMap, metalnessMap:!!b.metalnessMap, specularMap:!!b.specularMap, alphaMap:!!b.alphaMap, gradientMap:!!b.gradientMap, combine:b.combine, vertexColors:b.vertexColors, fog:!!e, useFog:b.fog, fogExp:e && e.isFogExp2, flatShading:1 === b.shading, sizeAttenuation:b.sizeAttenuation, logarithmicDepthBuffer:m.logarithmicDepthBuffer, skinning:f && f.isSkinnedMesh && 0 < G, maxBones:G, useVertexTexture:m.floatVertexTextures, 
      morphTargets:b.morphTargets, morphNormals:b.morphNormals, maxMorphTargets:d.maxMorphTargets, maxMorphNormals:d.maxMorphNormals, numDirLights:A.directional.length, numPointLights:A.point.length, numSpotLights:A.spot.length, numRectAreaLights:A.rectArea.length, numHemiLights:A.hemi.length, numClippingPlanes:g, numClipIntersection:k, shadowMapEnabled:d.shadowMap.enabled && f.receiveShadow && 0 < A.shadows.length, shadowMapType:d.shadowMap.type, toneMapping:d.toneMapping, physicallyCorrectLights:d.physicallyCorrectLights, 
      premultipliedAlpha:b.premultipliedAlpha, alphaTest:b.alphaTest, doubleSided:2 === b.side, flipSided:1 === b.side, depthPacking:void 0 !== b.depthPacking ? b.depthPacking : !1};
    };
    this.getProgramCode = function(d, m) {
      var a = [];
      m.shaderID ? a.push(m.shaderID) : (a.push(d.fragmentShader), a.push(d.vertexShader));
      if (void 0 !== d.defines) {
        for (var b in d.defines) {
          a.push(b), a.push(d.defines[b]);
        }
      }
      for (b = 0;b < e.length;b++) {
        a.push(m[e[b]]);
      }
      return a.join();
    };
    this.acquireProgram = function(m, a, A) {
      for (var c, e = 0, g = b.length;e < g;e++) {
        var k = b[e];
        if (k.code === A) {
          c = k;
          ++c.usedTimes;
          break;
        }
      }
      void 0 === c && (c = new qb(d, A, m, a), b.push(c));
      return c;
    };
    this.releaseProgram = function(d) {
      if (0 === --d.usedTimes) {
        var m = b.indexOf(d);
        b[m] = b[b.length - 1];
        b.pop();
        d.destroy();
      }
    };
    this.programs = b;
  }
  function mf(d, m, a, b, c, e, g) {
    function A(d, m) {
      if (d.width > m || d.height > m) {
        m /= Math.max(d.width, d.height);
        var a = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        a.width = Math.floor(d.width * m);
        a.height = Math.floor(d.height * m);
        a.getContext("2d").drawImage(d, 0, 0, d.width, d.height, 0, 0, a.width, a.height);
        console.warn("THREE.WebGLRenderer: image is too big (" + d.width + "x" + d.height + "). Resized to " + a.width + "x" + a.height, d);
        return a;
      }
      return d;
    }
    function k(d) {
      return ka.isPowerOfTwo(d.width) && ka.isPowerOfTwo(d.height);
    }
    function f(m) {
      return 1003 === m || 1004 === m || 1005 === m ? d.NEAREST : d.LINEAR;
    }
    function q(m) {
      m = m.target;
      m.removeEventListener("dispose", q);
      a: {
        var a = b.get(m);
        if (m.image && a.__image__webglTextureCube) {
          d.deleteTexture(a.__image__webglTextureCube);
        } else {
          if (void 0 === a.__webglInit) {
            break a;
          }
          d.deleteTexture(a.__webglTexture);
        }
        b.remove(m);
      }
      g.textures--;
    }
    function G(m) {
      m = m.target;
      m.removeEventListener("dispose", G);
      var a = b.get(m), A = b.get(m.texture);
      if (m) {
        void 0 !== A.__webglTexture && d.deleteTexture(A.__webglTexture);
        m.depthTexture && m.depthTexture.dispose();
        if (m.isWebGLRenderTargetCube) {
          for (A = 0;6 > A;A++) {
            d.deleteFramebuffer(a.__webglFramebuffer[A]), a.__webglDepthbuffer && d.deleteRenderbuffer(a.__webglDepthbuffer[A]);
          }
        } else {
          d.deleteFramebuffer(a.__webglFramebuffer), a.__webglDepthbuffer && d.deleteRenderbuffer(a.__webglDepthbuffer);
        }
        b.remove(m.texture);
        b.remove(m);
      }
      g.textures--;
    }
    function p(m, f) {
      var G = b.get(m);
      if (0 < m.version && G.__version !== m.version) {
        var p = m.image;
        if (void 0 === p) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", m);
        } else {
          if (!1 === p.complete) {
            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", m);
          } else {
            void 0 === G.__webglInit && (G.__webglInit = !0, m.addEventListener("dispose", q), G.__webglTexture = d.createTexture(), g.textures++);
            a.activeTexture(d.TEXTURE0 + f);
            a.bindTexture(d.TEXTURE_2D, G.__webglTexture);
            d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, m.flipY);
            d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, m.premultiplyAlpha);
            d.pixelStorei(d.UNPACK_ALIGNMENT, m.unpackAlignment);
            f = A(m.image, c.maxTextureSize);
            if ((1001 !== m.wrapS || 1001 !== m.wrapT || 1003 !== m.minFilter && 1006 !== m.minFilter) && !1 === k(f)) {
              if (p = f, p instanceof HTMLImageElement || p instanceof HTMLCanvasElement) {
                var n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                n.width = ka.nearestPowerOfTwo(p.width);
                n.height = ka.nearestPowerOfTwo(p.height);
                n.getContext("2d").drawImage(p, 0, 0, n.width, n.height);
                console.warn("THREE.WebGLRenderer: image is not power of two (" + p.width + "x" + p.height + "). Resized to " + n.width + "x" + n.height, p);
                f = n;
              } else {
                f = p;
              }
            }
            var p = k(f), n = e(m.format), r = e(m.type);
            h(d.TEXTURE_2D, m, p);
            var l = m.mipmaps;
            if (m.isDepthTexture) {
              l = d.DEPTH_COMPONENT;
              if (1015 === m.type) {
                if (!O) {
                  throw Error("Float Depth Texture only supported in WebGL2.0");
                }
                l = d.DEPTH_COMPONENT32F;
              } else {
                O && (l = d.DEPTH_COMPONENT16);
              }
              1026 === m.format && l === d.DEPTH_COMPONENT && 1012 !== m.type && 1014 !== m.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), m.type = 1012, r = e(m.type));
              1027 === m.format && (l = d.DEPTH_STENCIL, 1020 !== m.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), m.type = 1020, r = e(m.type)));
              a.texImage2D(d.TEXTURE_2D, 0, l, f.width, f.height, 0, n, r, null);
            } else {
              if (m.isDataTexture) {
                if (0 < l.length && p) {
                  for (var u = 0, w = l.length;u < w;u++) {
                    f = l[u], a.texImage2D(d.TEXTURE_2D, u, n, f.width, f.height, 0, n, r, f.data);
                  }
                  m.generateMipmaps = !1;
                } else {
                  a.texImage2D(d.TEXTURE_2D, 0, n, f.width, f.height, 0, n, r, f.data);
                }
              } else {
                if (m.isCompressedTexture) {
                  for (u = 0, w = l.length;u < w;u++) {
                    f = l[u], 1023 !== m.format && 1022 !== m.format ? -1 < a.getCompressedTextureFormats().indexOf(n) ? a.compressedTexImage2D(d.TEXTURE_2D, u, n, f.width, f.height, 0, f.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : a.texImage2D(d.TEXTURE_2D, u, n, f.width, f.height, 0, n, r, f.data);
                  }
                } else {
                  if (0 < l.length && p) {
                    u = 0;
                    for (w = l.length;u < w;u++) {
                      f = l[u], a.texImage2D(d.TEXTURE_2D, u, n, n, r, f);
                    }
                    m.generateMipmaps = !1;
                  } else {
                    a.texImage2D(d.TEXTURE_2D, 0, n, n, r, f);
                  }
                }
              }
            }
            m.generateMipmaps && p && d.generateMipmap(d.TEXTURE_2D);
            G.__version = m.version;
            if (m.onUpdate) {
              m.onUpdate(m);
            }
            return;
          }
        }
      }
      a.activeTexture(d.TEXTURE0 + f);
      a.bindTexture(d.TEXTURE_2D, G.__webglTexture);
    }
    function h(a, A, g) {
      g ? (d.texParameteri(a, d.TEXTURE_WRAP_S, e(A.wrapS)), d.texParameteri(a, d.TEXTURE_WRAP_T, e(A.wrapT)), d.texParameteri(a, d.TEXTURE_MAG_FILTER, e(A.magFilter)), d.texParameteri(a, d.TEXTURE_MIN_FILTER, e(A.minFilter))) : (d.texParameteri(a, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(a, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), 1001 === A.wrapS && 1001 === A.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", 
      A), d.texParameteri(a, d.TEXTURE_MAG_FILTER, f(A.magFilter)), d.texParameteri(a, d.TEXTURE_MIN_FILTER, f(A.minFilter)), 1003 !== A.minFilter && 1006 !== A.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", A));
      !(g = m.get("EXT_texture_filter_anisotropic")) || 1015 === A.type && null === m.get("OES_texture_float_linear") || 1016 === A.type && null === m.get("OES_texture_half_float_linear") || !(1 < A.anisotropy || b.get(A).__currentAnisotropy) || (d.texParameterf(a, g.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(A.anisotropy, c.getMaxAnisotropy())), b.get(A).__currentAnisotropy = A.anisotropy);
    }
    function n(m, A, c, g) {
      var f = e(A.texture.format), k = e(A.texture.type);
      a.texImage2D(g, 0, f, A.width, A.height, 0, f, k, null);
      d.bindFramebuffer(d.FRAMEBUFFER, m);
      d.framebufferTexture2D(d.FRAMEBUFFER, c, g, b.get(A.texture).__webglTexture, 0);
      d.bindFramebuffer(d.FRAMEBUFFER, null);
    }
    function r(m, a) {
      d.bindRenderbuffer(d.RENDERBUFFER, m);
      a.depthBuffer && !a.stencilBuffer ? (d.renderbufferStorage(d.RENDERBUFFER, d.DEPTH_COMPONENT16, a.width, a.height), d.framebufferRenderbuffer(d.FRAMEBUFFER, d.DEPTH_ATTACHMENT, d.RENDERBUFFER, m)) : a.depthBuffer && a.stencilBuffer ? (d.renderbufferStorage(d.RENDERBUFFER, d.DEPTH_STENCIL, a.width, a.height), d.framebufferRenderbuffer(d.FRAMEBUFFER, d.DEPTH_STENCIL_ATTACHMENT, d.RENDERBUFFER, m)) : d.renderbufferStorage(d.RENDERBUFFER, d.RGBA4, a.width, a.height);
      d.bindRenderbuffer(d.RENDERBUFFER, null);
    }
    var O = "undefined" !== typeof WebGL2RenderingContext && d instanceof WebGL2RenderingContext;
    this.setTexture2D = p;
    this.setTextureCube = function(m, f) {
      var G = b.get(m);
      if (6 === m.image.length) {
        if (0 < m.version && G.__version !== m.version) {
          G.__image__webglTextureCube || (m.addEventListener("dispose", q), G.__image__webglTextureCube = d.createTexture(), g.textures++);
          a.activeTexture(d.TEXTURE0 + f);
          a.bindTexture(d.TEXTURE_CUBE_MAP, G.__image__webglTextureCube);
          d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, m.flipY);
          f = m && m.isCompressedTexture;
          for (var p = m.image[0] && m.image[0].isDataTexture, n = [], r = 0;6 > r;r++) {
            n[r] = f || p ? p ? m.image[r].image : m.image[r] : A(m.image[r], c.maxCubemapSize);
          }
          var l = k(n[0]), O = e(m.format), u = e(m.type);
          h(d.TEXTURE_CUBE_MAP, m, l);
          for (r = 0;6 > r;r++) {
            if (f) {
              for (var w, aa = n[r].mipmaps, t = 0, v = aa.length;t < v;t++) {
                w = aa[t], 1023 !== m.format && 1022 !== m.format ? -1 < a.getCompressedTextureFormats().indexOf(O) ? a.compressedTexImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + r, t, O, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : a.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + r, t, O, w.width, w.height, 0, O, u, w.data);
              }
            } else {
              p ? a.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, O, n[r].width, n[r].height, 0, O, u, n[r].data) : a.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, O, O, u, n[r]);
            }
          }
          m.generateMipmaps && l && d.generateMipmap(d.TEXTURE_CUBE_MAP);
          G.__version = m.version;
          if (m.onUpdate) {
            m.onUpdate(m);
          }
        } else {
          a.activeTexture(d.TEXTURE0 + f), a.bindTexture(d.TEXTURE_CUBE_MAP, G.__image__webglTextureCube);
        }
      }
    };
    this.setTextureCubeDynamic = function(m, A) {
      a.activeTexture(d.TEXTURE0 + A);
      a.bindTexture(d.TEXTURE_CUBE_MAP, b.get(m).__webglTexture);
    };
    this.setupRenderTarget = function(m) {
      var A = b.get(m), c = b.get(m.texture);
      m.addEventListener("dispose", G);
      c.__webglTexture = d.createTexture();
      g.textures++;
      var e = !0 === m.isWebGLRenderTargetCube, f = k(m);
      if (e) {
        A.__webglFramebuffer = [];
        for (var q = 0;6 > q;q++) {
          A.__webglFramebuffer[q] = d.createFramebuffer();
        }
      } else {
        A.__webglFramebuffer = d.createFramebuffer();
      }
      if (e) {
        a.bindTexture(d.TEXTURE_CUBE_MAP, c.__webglTexture);
        h(d.TEXTURE_CUBE_MAP, m.texture, f);
        for (q = 0;6 > q;q++) {
          n(A.__webglFramebuffer[q], m, d.COLOR_ATTACHMENT0, d.TEXTURE_CUBE_MAP_POSITIVE_X + q);
        }
        m.texture.generateMipmaps && f && d.generateMipmap(d.TEXTURE_CUBE_MAP);
        a.bindTexture(d.TEXTURE_CUBE_MAP, null);
      } else {
        a.bindTexture(d.TEXTURE_2D, c.__webglTexture), h(d.TEXTURE_2D, m.texture, f), n(A.__webglFramebuffer, m, d.COLOR_ATTACHMENT0, d.TEXTURE_2D), m.texture.generateMipmaps && f && d.generateMipmap(d.TEXTURE_2D), a.bindTexture(d.TEXTURE_2D, null);
      }
      if (m.depthBuffer) {
        A = b.get(m);
        c = !0 === m.isWebGLRenderTargetCube;
        if (m.depthTexture) {
          if (c) {
            throw Error("target.depthTexture not supported in Cube render targets");
          }
          if (m && m.isWebGLRenderTargetCube) {
            throw Error("Depth Texture with cube render targets is not supported!");
          }
          d.bindFramebuffer(d.FRAMEBUFFER, A.__webglFramebuffer);
          if (!m.depthTexture || !m.depthTexture.isDepthTexture) {
            throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          }
          b.get(m.depthTexture).__webglTexture && m.depthTexture.image.width === m.width && m.depthTexture.image.height === m.height || (m.depthTexture.image.width = m.width, m.depthTexture.image.height = m.height, m.depthTexture.needsUpdate = !0);
          p(m.depthTexture, 0);
          A = b.get(m.depthTexture).__webglTexture;
          if (1026 === m.depthTexture.format) {
            d.framebufferTexture2D(d.FRAMEBUFFER, d.DEPTH_ATTACHMENT, d.TEXTURE_2D, A, 0);
          } else {
            if (1027 === m.depthTexture.format) {
              d.framebufferTexture2D(d.FRAMEBUFFER, d.DEPTH_STENCIL_ATTACHMENT, d.TEXTURE_2D, A, 0);
            } else {
              throw Error("Unknown depthTexture format");
            }
          }
        } else {
          if (c) {
            for (A.__webglDepthbuffer = [], c = 0;6 > c;c++) {
              d.bindFramebuffer(d.FRAMEBUFFER, A.__webglFramebuffer[c]), A.__webglDepthbuffer[c] = d.createRenderbuffer(), r(A.__webglDepthbuffer[c], m);
            }
          } else {
            d.bindFramebuffer(d.FRAMEBUFFER, A.__webglFramebuffer), A.__webglDepthbuffer = d.createRenderbuffer(), r(A.__webglDepthbuffer, m);
          }
        }
        d.bindFramebuffer(d.FRAMEBUFFER, null);
      }
    };
    this.updateRenderTargetMipmap = function(m) {
      var A = m.texture;
      A.generateMipmaps && k(m) && 1003 !== A.minFilter && 1006 !== A.minFilter && (m = m && m.isWebGLRenderTargetCube ? d.TEXTURE_CUBE_MAP : d.TEXTURE_2D, A = b.get(A).__webglTexture, a.bindTexture(m, A), d.generateMipmap(m), a.bindTexture(m, null));
    };
  }
  function nf() {
    var d = {};
    return {get:function(m) {
      m = m.uuid;
      var a = d[m];
      void 0 === a && (a = {}, d[m] = a);
      return a;
    }, remove:function(m) {
      delete d[m.uuid];
    }, clear:function() {
      d = {};
    }};
  }
  function of(d, m, a) {
    function b(m, a, b) {
      var A = new Uint8Array(4), c = d.createTexture();
      d.bindTexture(m, c);
      d.texParameteri(m, d.TEXTURE_MIN_FILTER, d.NEAREST);
      d.texParameteri(m, d.TEXTURE_MAG_FILTER, d.NEAREST);
      for (m = 0;m < b;m++) {
        d.texImage2D(a + m, 0, d.RGBA, 1, 1, 0, d.RGBA, d.UNSIGNED_BYTE, A);
      }
      return c;
    }
    function A(m) {
      !0 !== v[m] && (d.enable(m), v[m] = !0);
    }
    function c(m) {
      !1 !== v[m] && (d.disable(m), v[m] = !1);
    }
    function e(m, b, e, g, f, k, q, p) {
      0 !== m ? A(d.BLEND) : c(d.BLEND);
      if (m !== y || p !== N) {
        2 === m ? p ? (d.blendEquationSeparate(d.FUNC_ADD, d.FUNC_ADD), d.blendFuncSeparate(d.ONE, d.ONE, d.ONE, d.ONE)) : (d.blendEquation(d.FUNC_ADD), d.blendFunc(d.SRC_ALPHA, d.ONE)) : 3 === m ? p ? (d.blendEquationSeparate(d.FUNC_ADD, d.FUNC_ADD), d.blendFuncSeparate(d.ZERO, d.ZERO, d.ONE_MINUS_SRC_COLOR, d.ONE_MINUS_SRC_ALPHA)) : (d.blendEquation(d.FUNC_ADD), d.blendFunc(d.ZERO, d.ONE_MINUS_SRC_COLOR)) : 4 === m ? p ? (d.blendEquationSeparate(d.FUNC_ADD, d.FUNC_ADD), d.blendFuncSeparate(d.ZERO, 
        d.SRC_COLOR, d.ZERO, d.SRC_ALPHA)) : (d.blendEquation(d.FUNC_ADD), d.blendFunc(d.ZERO, d.SRC_COLOR)) : p ? (d.blendEquationSeparate(d.FUNC_ADD, d.FUNC_ADD), d.blendFuncSeparate(d.ONE, d.ONE_MINUS_SRC_ALPHA, d.ONE, d.ONE_MINUS_SRC_ALPHA)) : (d.blendEquationSeparate(d.FUNC_ADD, d.FUNC_ADD), d.blendFuncSeparate(d.SRC_ALPHA, d.ONE_MINUS_SRC_ALPHA, d.ONE, d.ONE_MINUS_SRC_ALPHA)), y = m, N = p;
      }
      if (5 === m) {
        f = f || b;
        k = k || e;
        q = q || g;
        if (b !== z || f !== F) {
          d.blendEquationSeparate(a(b), a(f)), z = b, F = f;
        }
        if (e !== x || g !== C || k !== D || q !== E) {
          d.blendFuncSeparate(a(e), a(g), a(k), a(q)), x = e, C = g, D = k, E = q;
        }
      } else {
        E = D = F = C = x = z = null;
      }
    }
    function g(m) {
      I !== m && (m ? d.frontFace(d.CW) : d.frontFace(d.CCW), I = m);
    }
    function k(m) {
      0 !== m ? (A(d.CULL_FACE), m !== X && (1 === m ? d.cullFace(d.BACK) : 2 === m ? d.cullFace(d.FRONT) : d.cullFace(d.FRONT_AND_BACK))) : c(d.CULL_FACE);
      X = m;
    }
    function q(m, a, b) {
      if (m) {
        if (A(d.POLYGON_OFFSET_FILL), Z !== a || L !== b) {
          d.polygonOffset(a, b), Z = a, L = b;
        }
      } else {
        c(d.POLYGON_OFFSET_FILL);
      }
    }
    function p(m) {
      void 0 === m && (m = d.TEXTURE0 + ia - 1);
      ea !== m && (d.activeTexture(m), ea = m);
    }
    var h = new function() {
      var m = !1, a = new f, b = null, A = new f;
      return {setMask:function(a) {
        b === a || m || (d.colorMask(a, a, a, a), b = a);
      }, setLocked:function(d) {
        m = d;
      }, setClear:function(m, b, c, e, g) {
        !0 === g && (m *= e, b *= e, c *= e);
        a.set(m, b, c, e);
        !1 === A.equals(a) && (d.clearColor(m, b, c, e), A.copy(a));
      }, reset:function() {
        m = !1;
        b = null;
        A.set(0, 0, 0, 1);
      }};
    }, n = new function() {
      var m = !1, a = null, b = null, e = null;
      return {setTest:function(m) {
        m ? A(d.DEPTH_TEST) : c(d.DEPTH_TEST);
      }, setMask:function(b) {
        a === b || m || (d.depthMask(b), a = b);
      }, setFunc:function(m) {
        if (b !== m) {
          if (m) {
            switch(m) {
              case 0:
                d.depthFunc(d.NEVER);
                break;
              case 1:
                d.depthFunc(d.ALWAYS);
                break;
              case 2:
                d.depthFunc(d.LESS);
                break;
              case 3:
                d.depthFunc(d.LEQUAL);
                break;
              case 4:
                d.depthFunc(d.EQUAL);
                break;
              case 5:
                d.depthFunc(d.GEQUAL);
                break;
              case 6:
                d.depthFunc(d.GREATER);
                break;
              case 7:
                d.depthFunc(d.NOTEQUAL);
                break;
              default:
                d.depthFunc(d.LEQUAL);
            }
          } else {
            d.depthFunc(d.LEQUAL);
          }
          b = m;
        }
      }, setLocked:function(d) {
        m = d;
      }, setClear:function(m) {
        e !== m && (d.clearDepth(m), e = m);
      }, reset:function() {
        m = !1;
        e = b = a = null;
      }};
    }, r = new function() {
      var m = !1, a = null, b = null, e = null, g = null, f = null, k = null, q = null, p = null;
      return {setTest:function(m) {
        m ? A(d.STENCIL_TEST) : c(d.STENCIL_TEST);
      }, setMask:function(b) {
        a === b || m || (d.stencilMask(b), a = b);
      }, setFunc:function(m, a, A) {
        if (b !== m || e !== a || g !== A) {
          d.stencilFunc(m, a, A), b = m, e = a, g = A;
        }
      }, setOp:function(m, a, b) {
        if (f !== m || k !== a || q !== b) {
          d.stencilOp(m, a, b), f = m, k = a, q = b;
        }
      }, setLocked:function(d) {
        m = d;
      }, setClear:function(m) {
        p !== m && (d.clearStencil(m), p = m);
      }, reset:function() {
        m = !1;
        p = q = k = f = g = e = b = a = null;
      }};
    }, l = d.getParameter(d.MAX_VERTEX_ATTRIBS), u = new Uint8Array(l), w = new Uint8Array(l), t = new Uint8Array(l), v = {}, B = null, y = null, z = null, x = null, C = null, F = null, D = null, E = null, N = !1, I = null, X = null, J = null, Z = null, L = null, S = null, ia = d.getParameter(d.MAX_TEXTURE_IMAGE_UNITS), l = parseFloat(/^WebGL\ ([0-9])/.exec(d.getParameter(d.VERSION))[1]), M = 1 <= parseFloat(l), ea = null, R = {}, H = new f, ba = new f, P = {};
    P[d.TEXTURE_2D] = b(d.TEXTURE_2D, d.TEXTURE_2D, 1);
    P[d.TEXTURE_CUBE_MAP] = b(d.TEXTURE_CUBE_MAP, d.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
    return {buffers:{color:h, depth:n, stencil:r}, init:function() {
      h.setClear(0, 0, 0, 1);
      n.setClear(1);
      r.setClear(0);
      A(d.DEPTH_TEST);
      n.setFunc(3);
      g(!1);
      k(1);
      A(d.CULL_FACE);
      A(d.BLEND);
      e(1);
    }, initAttributes:function() {
      for (var d = 0, m = u.length;d < m;d++) {
        u[d] = 0;
      }
    }, enableAttribute:function(a) {
      u[a] = 1;
      0 === w[a] && (d.enableVertexAttribArray(a), w[a] = 1);
      0 !== t[a] && (m.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(a, 0), t[a] = 0);
    }, enableAttributeAndDivisor:function(m, a, b) {
      u[m] = 1;
      0 === w[m] && (d.enableVertexAttribArray(m), w[m] = 1);
      t[m] !== a && (b.vertexAttribDivisorANGLE(m, a), t[m] = a);
    }, disableUnusedAttributes:function() {
      for (var m = 0, a = w.length;m !== a;++m) {
        w[m] !== u[m] && (d.disableVertexAttribArray(m), w[m] = 0);
      }
    }, enable:A, disable:c, getCompressedTextureFormats:function() {
      if (null === B && (B = [], m.get("WEBGL_compressed_texture_pvrtc") || m.get("WEBGL_compressed_texture_s3tc") || m.get("WEBGL_compressed_texture_etc1"))) {
        for (var a = d.getParameter(d.COMPRESSED_TEXTURE_FORMATS), b = 0;b < a.length;b++) {
          B.push(a[b]);
        }
      }
      return B;
    }, setBlending:e, setMaterial:function(m) {
      2 === m.side ? c(d.CULL_FACE) : A(d.CULL_FACE);
      g(1 === m.side);
      !0 === m.transparent ? e(m.blending, m.blendEquation, m.blendSrc, m.blendDst, m.blendEquationAlpha, m.blendSrcAlpha, m.blendDstAlpha, m.premultipliedAlpha) : e(0);
      n.setFunc(m.depthFunc);
      n.setTest(m.depthTest);
      n.setMask(m.depthWrite);
      h.setMask(m.colorWrite);
      q(m.polygonOffset, m.polygonOffsetFactor, m.polygonOffsetUnits);
    }, setFlipSided:g, setCullFace:k, setLineWidth:function(m) {
      m !== J && (M && d.lineWidth(m), J = m);
    }, setPolygonOffset:q, getScissorTest:function() {
      return S;
    }, setScissorTest:function(m) {
      (S = m) ? A(d.SCISSOR_TEST) : c(d.SCISSOR_TEST);
    }, activeTexture:p, bindTexture:function(m, a) {
      null === ea && p();
      var b = R[ea];
      void 0 === b && (b = {type:void 0, texture:void 0}, R[ea] = b);
      if (b.type !== m || b.texture !== a) {
        d.bindTexture(m, a || P[m]), b.type = m, b.texture = a;
      }
    }, compressedTexImage2D:function() {
      try {
        d.compressedTexImage2D.apply(d, arguments);
      } catch (ce) {
        console.error(ce);
      }
    }, texImage2D:function() {
      try {
        d.texImage2D.apply(d, arguments);
      } catch (ce) {
        console.error(ce);
      }
    }, scissor:function(m) {
      !1 === H.equals(m) && (d.scissor(m.x, m.y, m.z, m.w), H.copy(m));
    }, viewport:function(m) {
      !1 === ba.equals(m) && (d.viewport(m.x, m.y, m.z, m.w), ba.copy(m));
    }, reset:function() {
      for (var m = 0;m < w.length;m++) {
        1 === w[m] && (d.disableVertexAttribArray(m), w[m] = 0);
      }
      v = {};
      ea = B = null;
      R = {};
      X = I = y = null;
      h.reset();
      n.reset();
      r.reset();
    }};
  }
  function pf(d, m, a) {
    function b(m) {
      if ("highp" === m) {
        if (0 < d.getShaderPrecisionFormat(d.VERTEX_SHADER, d.HIGH_FLOAT).precision && 0 < d.getShaderPrecisionFormat(d.FRAGMENT_SHADER, d.HIGH_FLOAT).precision) {
          return "highp";
        }
        m = "mediump";
      }
      return "mediump" === m && 0 < d.getShaderPrecisionFormat(d.VERTEX_SHADER, d.MEDIUM_FLOAT).precision && 0 < d.getShaderPrecisionFormat(d.FRAGMENT_SHADER, d.MEDIUM_FLOAT).precision ? "mediump" : "lowp";
    }
    var A, c = void 0 !== a.precision ? a.precision : "highp", e = b(c);
    e !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", e, "instead."), c = e);
    a = !0 === a.logarithmicDepthBuffer && !!m.get("EXT_frag_depth");
    var e = d.getParameter(d.MAX_TEXTURE_IMAGE_UNITS), g = d.getParameter(d.MAX_VERTEX_TEXTURE_IMAGE_UNITS), f = d.getParameter(d.MAX_TEXTURE_SIZE), k = d.getParameter(d.MAX_CUBE_MAP_TEXTURE_SIZE), q = d.getParameter(d.MAX_VERTEX_ATTRIBS), p = d.getParameter(d.MAX_VERTEX_UNIFORM_VECTORS), h = d.getParameter(d.MAX_VARYING_VECTORS), n = d.getParameter(d.MAX_FRAGMENT_UNIFORM_VECTORS), r = 0 < g, l = !!m.get("OES_texture_float");
    return {getMaxAnisotropy:function() {
      if (void 0 !== A) {
        return A;
      }
      var a = m.get("EXT_texture_filter_anisotropic");
      return A = null !== a ? d.getParameter(a.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
    }, getMaxPrecision:b, precision:c, logarithmicDepthBuffer:a, maxTextures:e, maxVertexTextures:g, maxTextureSize:f, maxCubemapSize:k, maxAttributes:q, maxVertexUniforms:p, maxVaryings:h, maxFragmentUniforms:n, vertexTextures:r, floatFragmentTextures:l, floatVertexTextures:r && l};
  }
  function qf(d) {
    var m = {};
    return {get:function(a) {
      if (void 0 !== m[a]) {
        return m[a];
      }
      var b;
      switch(a) {
        case "WEBGL_depth_texture":
          b = d.getExtension("WEBGL_depth_texture") || d.getExtension("MOZ_WEBGL_depth_texture") || d.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          b = d.getExtension("EXT_texture_filter_anisotropic") || d.getExtension("MOZ_EXT_texture_filter_anisotropic") || d.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          b = d.getExtension("WEBGL_compressed_texture_s3tc") || d.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || d.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          b = d.getExtension("WEBGL_compressed_texture_pvrtc") || d.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        case "WEBGL_compressed_texture_etc1":
          b = d.getExtension("WEBGL_compressed_texture_etc1");
          break;
        default:
          b = d.getExtension(a);
      }
      null === b && console.warn("THREE.WebGLRenderer: " + a + " extension not supported.");
      return m[a] = b;
    }};
  }
  function rf() {
    function d() {
      q.value !== b && (q.value = b, q.needsUpdate = 0 < c);
      a.numPlanes = c;
      a.numIntersection = 0;
    }
    function m(d, m, b, A) {
      var c = null !== d ? d.length : 0, e = null;
      if (0 !== c) {
        e = q.value;
        if (!0 !== A || null === e) {
          A = b + 4 * c;
          m = m.matrixWorldInverse;
          k.getNormalMatrix(m);
          if (null === e || e.length < A) {
            e = new Float32Array(A);
          }
          for (A = 0;A !== c;++A, b += 4) {
            f.copy(d[A]).applyMatrix4(m, k), f.normal.toArray(e, b), e[b + 3] = f.constant;
          }
        }
        q.value = e;
        q.needsUpdate = !0;
      }
      a.numPlanes = c;
      return e;
    }
    var a = this, b = null, c = 0, e = !1, g = !1, f = new Ea, k = new ya, q = {value:null, needsUpdate:!1};
    this.uniform = q;
    this.numIntersection = this.numPlanes = 0;
    this.init = function(d, a, A) {
      var g = 0 !== d.length || a || 0 !== c || e;
      e = a;
      b = m(d, A, 0);
      c = d.length;
      return g;
    };
    this.beginShadows = function() {
      g = !0;
      m(null);
    };
    this.endShadows = function() {
      g = !1;
      d();
    };
    this.setState = function(a, A, f, k, p, G) {
      if (!e || null === a || 0 === a.length || g && !f) {
        g ? m(null) : d();
      } else {
        f = g ? 0 : c;
        var h = 4 * f, n = p.clippingState || null;
        q.value = n;
        n = m(a, k, h, G);
        for (a = 0;a !== h;++a) {
          n[a] = b[a];
        }
        p.clippingState = n;
        this.numIntersection = A ? this.numPlanes : 0;
        this.numPlanes += f;
      }
    };
  }
  function de(d) {
    function m() {
      oa.init();
      oa.scissor(ob.copy(Mc).multiplyScalar(U));
      oa.viewport(qa.copy(xa).multiplyScalar(U));
      oa.buffers.color.setClear(W.r, W.g, W.b, pb, E);
    }
    function a() {
      V = R = null;
      ha = "";
      P = -1;
      oa.reset();
    }
    function b(d) {
      d.preventDefault();
      a();
      m();
      Wa.clear();
      vb.clear();
    }
    function c(d) {
      d = d.target;
      d.removeEventListener("dispose", c);
      g(d);
      Wa.remove(d);
    }
    function g(d) {
      var m = Wa.get(d).program;
      d.program = void 0;
      void 0 !== m && wa.releaseProgram(m);
    }
    function k(d, m, a) {
      d.render(function(d) {
        M.renderBufferImmediate(d, m, a);
      });
    }
    function q(d, m) {
      return Math.abs(m[0]) - Math.abs(d[0]);
    }
    function h(d, m) {
      return d.object.renderOrder !== m.object.renderOrder ? d.object.renderOrder - m.object.renderOrder : d.material.program && m.material.program && d.material.program !== m.material.program ? d.material.program.id - m.material.program.id : d.material.id !== m.material.id ? d.material.id - m.material.id : d.z !== m.z ? d.z - m.z : d.id - m.id;
    }
    function n(d, m) {
      return d.object.renderOrder !== m.object.renderOrder ? d.object.renderOrder - m.object.renderOrder : d.z !== m.z ? m.z - d.z : d.id - m.id;
    }
    function r(d, m, a, b, A) {
      var c;
      a.transparent ? (b = Z, c = ++L) : (b = X, c = ++J);
      (c = b[c]) ? (c.id = d.id, c.object = d, c.geometry = m, c.material = a, c.z = ga.z, c.group = A) : (c = {id:d.id, object:d, geometry:m, material:a, z:ga.z, group:A}, b.push(c));
    }
    function l(d, m, a) {
      if (d.visible) {
        if (d.layers.test(m.layers)) {
          if (d.isLight) {
            I.push(d);
          } else {
            if (d.isSprite) {
              d.frustumCulled && !ya.intersectsSprite(d) || ia.push(d);
            } else {
              if (d.isLensFlare) {
                ea.push(d);
              } else {
                if (d.isImmediateRenderObject) {
                  a && ga.setFromMatrixPosition(d.matrixWorld).applyMatrix4(Hb), r(d, null, d.material, ga.z, null);
                } else {
                  if (d.isMesh || d.isLine || d.isPoints) {
                    if (d.isSkinnedMesh && d.skeleton.update(), !d.frustumCulled || ya.intersectsObject(d)) {
                      a && ga.setFromMatrixPosition(d.matrixWorld).applyMatrix4(Hb);
                      var b = vb.update(d), A = d.material;
                      if (Array.isArray(A)) {
                        for (var c = b.groups, e = 0, g = c.length;e < g;e++) {
                          var f = c[e], k = A[f.materialIndex];
                          k && k.visible && r(d, b, k, ga.z, f);
                        }
                      } else {
                        A.visible && r(d, b, A, ga.z, null);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        d = d.children;
        e = 0;
        for (g = d.length;e < g;e++) {
          l(d[e], m, a);
        }
      }
    }
    function u(d, m, a, b) {
      for (var A = 0, c = d.length;A < c;A++) {
        var e = d[A], g = e.object, f = e.geometry, q = void 0 === b ? e.material : b, e = e.group;
        g.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, g.matrixWorld);
        g.normalMatrix.getNormalMatrix(g.modelViewMatrix);
        g.onBeforeRender(M, m, a, f, q, e);
        if (g.isImmediateRenderObject) {
          oa.setMaterial(q);
          var p = w(a, m.fog, q, g);
          ha = "";
          k(g, p, q);
        } else {
          M.renderBufferDirect(a, m.fog, f, q, g, e);
        }
        g.onAfterRender(M, m, a, f, q, e);
      }
    }
    function w(d, m, a, b) {
      Ja = 0;
      var A = Wa.get(a);
      Ba && (ja || d !== V) && ca.setState(a.clippingPlanes, a.clipIntersection, a.clipShadows, d, A, d === V && a.id === P);
      !1 === a.needsUpdate && (void 0 === A.program ? a.needsUpdate = !0 : a.fog && A.fog !== m ? a.needsUpdate = !0 : a.lights && A.lightsHash !== la.hash ? a.needsUpdate = !0 : void 0 === A.numClippingPlanes || A.numClippingPlanes === ca.numPlanes && A.numIntersection === ca.numIntersection || (a.needsUpdate = !0));
      if (a.needsUpdate) {
        a: {
          var e = Wa.get(a), f = wa.getParameters(a, la, m, ca.numPlanes, ca.numIntersection, b), k = wa.getProgramCode(a, f), q = e.program, p = !0;
          if (void 0 === q) {
            a.addEventListener("dispose", c);
          } else {
            if (q.code !== k) {
              g(a);
            } else {
              if (void 0 !== f.shaderID) {
                break a;
              } else {
                p = !1;
              }
            }
          }
          p && (f.shaderID ? (q = zb[f.shaderID], e.__webglShader = {name:a.type, uniforms:Sa.clone(q.uniforms), vertexShader:q.vertexShader, fragmentShader:q.fragmentShader}) : e.__webglShader = {name:a.type, uniforms:a.uniforms, vertexShader:a.vertexShader, fragmentShader:a.fragmentShader}, a.__webglShader = e.__webglShader, q = wa.acquireProgram(a, f, k), e.program = q, a.program = q);
          f = q.getAttributes();
          if (a.morphTargets) {
            for (k = a.numSupportedMorphTargets = 0;k < M.maxMorphTargets;k++) {
              0 <= f["morphTarget" + k] && a.numSupportedMorphTargets++;
            }
          }
          if (a.morphNormals) {
            for (k = a.numSupportedMorphNormals = 0;k < M.maxMorphNormals;k++) {
              0 <= f["morphNormal" + k] && a.numSupportedMorphNormals++;
            }
          }
          f = e.__webglShader.uniforms;
          if (!a.isShaderMaterial && !a.isRawShaderMaterial || !0 === a.clipping) {
            e.numClippingPlanes = ca.numPlanes, e.numIntersection = ca.numIntersection, f.clippingPlanes = ca.uniform;
          }
          e.fog = m;
          e.lightsHash = la.hash;
          a.lights && (f.ambientLightColor.value = la.ambient, f.directionalLights.value = la.directional, f.spotLights.value = la.spot, f.rectAreaLights.value = la.rectArea, f.pointLights.value = la.point, f.hemisphereLights.value = la.hemi, f.directionalShadowMap.value = la.directionalShadowMap, f.directionalShadowMatrix.value = la.directionalShadowMatrix, f.spotShadowMap.value = la.spotShadowMap, f.spotShadowMatrix.value = la.spotShadowMatrix, f.pointShadowMap.value = la.pointShadowMap, f.pointShadowMatrix.value = 
          la.pointShadowMatrix);
          k = e.program.getUniforms();
          f = ta.seqWithValue(k.seq, f);
          e.uniformsList = f;
        }
        a.needsUpdate = !1;
      }
      var G = !1, p = q = !1, e = A.program, f = e.getUniforms(), k = A.__webglShader.uniforms;
      e.id !== R && (K.useProgram(e.program), R = e.id, p = q = G = !0);
      a.id !== P && (P = a.id, q = !0);
      if (G || d !== V) {
        f.set(K, d, "projectionMatrix");
        Pa.logarithmicDepthBuffer && f.setValue(K, "logDepthBufFC", 2 / (Math.log(d.far + 1) / Math.LN2));
        d !== V && (V = d, p = q = !0);
        if (a.isShaderMaterial || a.isMeshPhongMaterial || a.isMeshStandardMaterial || a.envMap) {
          G = f.map.cameraPosition, void 0 !== G && G.setValue(K, ga.setFromMatrixPosition(d.matrixWorld));
        }
        (a.isMeshPhongMaterial || a.isMeshLambertMaterial || a.isMeshBasicMaterial || a.isMeshStandardMaterial || a.isShaderMaterial || b.isSkinnedMesh) && f.setValue(K, "viewMatrix", d.matrixWorldInverse);
        f.set(K, M, "toneMappingExposure");
        f.set(K, M, "toneMappingWhitePoint");
      }
      b.isSkinnedMesh && (f.setOptional(K, b, "bindMatrix"), f.setOptional(K, b, "bindMatrixInverse"), d = b.skeleton) && (Pa.floatVertexTextures ? (f.set(K, d, "boneTexture"), f.set(K, d, "boneTextureSize")) : f.setOptional(K, d, "boneMatrices"));
      if (q) {
        a.lights && (d = p, k.ambientLightColor.needsUpdate = d, k.directionalLights.needsUpdate = d, k.pointLights.needsUpdate = d, k.spotLights.needsUpdate = d, k.rectAreaLights.needsUpdate = d, k.hemisphereLights.needsUpdate = d);
        m && a.fog && (k.fogColor.value = m.color, m.isFog ? (k.fogNear.value = m.near, k.fogFar.value = m.far) : m.isFogExp2 && (k.fogDensity.value = m.density));
        if (a.isMeshBasicMaterial || a.isMeshLambertMaterial || a.isMeshPhongMaterial || a.isMeshStandardMaterial || a.isMeshNormalMaterial || a.isMeshDepthMaterial) {
          k.opacity.value = a.opacity;
          k.diffuse.value = a.color;
          a.emissive && k.emissive.value.copy(a.emissive).multiplyScalar(a.emissiveIntensity);
          k.map.value = a.map;
          k.specularMap.value = a.specularMap;
          k.alphaMap.value = a.alphaMap;
          a.lightMap && (k.lightMap.value = a.lightMap, k.lightMapIntensity.value = a.lightMapIntensity);
          a.aoMap && (k.aoMap.value = a.aoMap, k.aoMapIntensity.value = a.aoMapIntensity);
          var h;
          a.map ? h = a.map : a.specularMap ? h = a.specularMap : a.displacementMap ? h = a.displacementMap : a.normalMap ? h = a.normalMap : a.bumpMap ? h = a.bumpMap : a.roughnessMap ? h = a.roughnessMap : a.metalnessMap ? h = a.metalnessMap : a.alphaMap ? h = a.alphaMap : a.emissiveMap && (h = a.emissiveMap);
          void 0 !== h && (h.isWebGLRenderTarget && (h = h.texture), m = h.offset, h = h.repeat, k.offsetRepeat.value.set(m.x, m.y, h.x, h.y));
          k.envMap.value = a.envMap;
          k.flipEnvMap.value = a.envMap && a.envMap.isCubeTexture ? -1 : 1;
          k.reflectivity.value = a.reflectivity;
          k.refractionRatio.value = a.refractionRatio;
        }
        a.isLineBasicMaterial ? (k.diffuse.value = a.color, k.opacity.value = a.opacity) : a.isLineDashedMaterial ? (k.diffuse.value = a.color, k.opacity.value = a.opacity, k.dashSize.value = a.dashSize, k.totalSize.value = a.dashSize + a.gapSize, k.scale.value = a.scale) : a.isPointsMaterial ? (k.diffuse.value = a.color, k.opacity.value = a.opacity, k.size.value = a.size * U, k.scale.value = .5 * Y, k.map.value = a.map, null !== a.map && (h = a.map.offset, a = a.map.repeat, k.offsetRepeat.value.set(h.x, 
        h.y, a.x, a.y))) : a.isMeshLambertMaterial ? a.emissiveMap && (k.emissiveMap.value = a.emissiveMap) : a.isMeshToonMaterial ? (t(k, a), a.gradientMap && (k.gradientMap.value = a.gradientMap)) : a.isMeshPhongMaterial ? t(k, a) : a.isMeshPhysicalMaterial ? (k.clearCoat.value = a.clearCoat, k.clearCoatRoughness.value = a.clearCoatRoughness, v(k, a)) : a.isMeshStandardMaterial ? v(k, a) : a.isMeshDepthMaterial ? a.displacementMap && (k.displacementMap.value = a.displacementMap, k.displacementScale.value = 
        a.displacementScale, k.displacementBias.value = a.displacementBias) : a.isMeshNormalMaterial && (a.bumpMap && (k.bumpMap.value = a.bumpMap, k.bumpScale.value = a.bumpScale), a.normalMap && (k.normalMap.value = a.normalMap, k.normalScale.value.copy(a.normalScale)), a.displacementMap && (k.displacementMap.value = a.displacementMap, k.displacementScale.value = a.displacementScale, k.displacementBias.value = a.displacementBias));
        void 0 !== k.ltcMat && (k.ltcMat.value = THREE.UniformsLib.LTC_MAT_TEXTURE);
        void 0 !== k.ltcMag && (k.ltcMag.value = THREE.UniformsLib.LTC_MAG_TEXTURE);
        ta.upload(K, A.uniformsList, k, M);
      }
      f.set(K, b, "modelViewMatrix");
      f.set(K, b, "normalMatrix");
      f.setValue(K, "modelMatrix", b.matrixWorld);
      return e;
    }
    function t(d, m) {
      d.specular.value = m.specular;
      d.shininess.value = Math.max(m.shininess, 1E-4);
      m.emissiveMap && (d.emissiveMap.value = m.emissiveMap);
      m.bumpMap && (d.bumpMap.value = m.bumpMap, d.bumpScale.value = m.bumpScale);
      m.normalMap && (d.normalMap.value = m.normalMap, d.normalScale.value.copy(m.normalScale));
      m.displacementMap && (d.displacementMap.value = m.displacementMap, d.displacementScale.value = m.displacementScale, d.displacementBias.value = m.displacementBias);
    }
    function v(d, m) {
      d.roughness.value = m.roughness;
      d.metalness.value = m.metalness;
      m.roughnessMap && (d.roughnessMap.value = m.roughnessMap);
      m.metalnessMap && (d.metalnessMap.value = m.metalnessMap);
      m.emissiveMap && (d.emissiveMap.value = m.emissiveMap);
      m.bumpMap && (d.bumpMap.value = m.bumpMap, d.bumpScale.value = m.bumpScale);
      m.normalMap && (d.normalMap.value = m.normalMap, d.normalScale.value.copy(m.normalScale));
      m.displacementMap && (d.displacementMap.value = m.displacementMap, d.displacementScale.value = m.displacementScale, d.displacementBias.value = m.displacementBias);
      m.envMap && (d.envMapIntensity.value = m.envMapIntensity);
    }
    function B(d) {
      var m;
      if (1E3 === d) {
        return K.REPEAT;
      }
      if (1001 === d) {
        return K.CLAMP_TO_EDGE;
      }
      if (1002 === d) {
        return K.MIRRORED_REPEAT;
      }
      if (1003 === d) {
        return K.NEAREST;
      }
      if (1004 === d) {
        return K.NEAREST_MIPMAP_NEAREST;
      }
      if (1005 === d) {
        return K.NEAREST_MIPMAP_LINEAR;
      }
      if (1006 === d) {
        return K.LINEAR;
      }
      if (1007 === d) {
        return K.LINEAR_MIPMAP_NEAREST;
      }
      if (1008 === d) {
        return K.LINEAR_MIPMAP_LINEAR;
      }
      if (1009 === d) {
        return K.UNSIGNED_BYTE;
      }
      if (1017 === d) {
        return K.UNSIGNED_SHORT_4_4_4_4;
      }
      if (1018 === d) {
        return K.UNSIGNED_SHORT_5_5_5_1;
      }
      if (1019 === d) {
        return K.UNSIGNED_SHORT_5_6_5;
      }
      if (1010 === d) {
        return K.BYTE;
      }
      if (1011 === d) {
        return K.SHORT;
      }
      if (1012 === d) {
        return K.UNSIGNED_SHORT;
      }
      if (1013 === d) {
        return K.INT;
      }
      if (1014 === d) {
        return K.UNSIGNED_INT;
      }
      if (1015 === d) {
        return K.FLOAT;
      }
      if (1016 === d && (m = va.get("OES_texture_half_float"), null !== m)) {
        return m.HALF_FLOAT_OES;
      }
      if (1021 === d) {
        return K.ALPHA;
      }
      if (1022 === d) {
        return K.RGB;
      }
      if (1023 === d) {
        return K.RGBA;
      }
      if (1024 === d) {
        return K.LUMINANCE;
      }
      if (1025 === d) {
        return K.LUMINANCE_ALPHA;
      }
      if (1026 === d) {
        return K.DEPTH_COMPONENT;
      }
      if (1027 === d) {
        return K.DEPTH_STENCIL;
      }
      if (100 === d) {
        return K.FUNC_ADD;
      }
      if (101 === d) {
        return K.FUNC_SUBTRACT;
      }
      if (102 === d) {
        return K.FUNC_REVERSE_SUBTRACT;
      }
      if (200 === d) {
        return K.ZERO;
      }
      if (201 === d) {
        return K.ONE;
      }
      if (202 === d) {
        return K.SRC_COLOR;
      }
      if (203 === d) {
        return K.ONE_MINUS_SRC_COLOR;
      }
      if (204 === d) {
        return K.SRC_ALPHA;
      }
      if (205 === d) {
        return K.ONE_MINUS_SRC_ALPHA;
      }
      if (206 === d) {
        return K.DST_ALPHA;
      }
      if (207 === d) {
        return K.ONE_MINUS_DST_ALPHA;
      }
      if (208 === d) {
        return K.DST_COLOR;
      }
      if (209 === d) {
        return K.ONE_MINUS_DST_COLOR;
      }
      if (210 === d) {
        return K.SRC_ALPHA_SATURATE;
      }
      if (2001 === d || 2002 === d || 2003 === d || 2004 === d) {
        if (m = va.get("WEBGL_compressed_texture_s3tc"), null !== m) {
          if (2001 === d) {
            return m.COMPRESSED_RGB_S3TC_DXT1_EXT;
          }
          if (2002 === d) {
            return m.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          }
          if (2003 === d) {
            return m.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          }
          if (2004 === d) {
            return m.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
        }
      }
      if (2100 === d || 2101 === d || 2102 === d || 2103 === d) {
        if (m = va.get("WEBGL_compressed_texture_pvrtc"), null !== m) {
          if (2100 === d) {
            return m.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          }
          if (2101 === d) {
            return m.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          }
          if (2102 === d) {
            return m.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          }
          if (2103 === d) {
            return m.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
        }
      }
      if (2151 === d && (m = va.get("WEBGL_compressed_texture_etc1"), null !== m)) {
        return m.COMPRESSED_RGB_ETC1_WEBGL;
      }
      if (103 === d || 104 === d) {
        if (m = va.get("EXT_blend_minmax"), null !== m) {
          if (103 === d) {
            return m.MIN_EXT;
          }
          if (104 === d) {
            return m.MAX_EXT;
          }
        }
      }
      return 1020 === d && (m = va.get("WEBGL_depth_texture"), null !== m) ? m.UNSIGNED_INT_24_8_WEBGL : 0;
    }
    console.log("THREE.WebGLRenderer", "85dev");
    d = d || {};
    var y = void 0 !== d.canvas ? d.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), z = void 0 !== d.context ? d.context : null, x = void 0 !== d.alpha ? d.alpha : !1, C = void 0 !== d.depth ? d.depth : !0, F = void 0 !== d.stencil ? d.stencil : !0, D = void 0 !== d.antialias ? d.antialias : !1, E = void 0 !== d.premultipliedAlpha ? d.premultipliedAlpha : !0, N = void 0 !== d.preserveDrawingBuffer ? d.preserveDrawingBuffer : !1, I = [], X = [], J = -1, Z = [], L = -1, 
    S = new Float32Array(8), ia = [], ea = [];
    this.domElement = y;
    this.context = null;
    this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
    this.clippingPlanes = [];
    this.localClippingEnabled = !1;
    this.gammaFactor = 2;
    this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1;
    this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    var M = this, R = null, H = null, ba = null, P = -1, ha = "", V = null, ob = new f, ra = null, qa = new f, Ja = 0, W = new T(0), pb = 0, $b = y.width, Y = y.height, U = 1, Mc = new f(0, 0, $b, Y), Aa = !1, xa = new f(0, 0, $b, Y), ya = new Xa, ca = new rf, Ba = !1, ja = !1, Hb = new p, ga = new e, ka = new p, Cb = new p, la = {hash:"", ambient:[0, 0, 0], directional:[], directionalShadowMap:[], directionalShadowMatrix:[], spot:[], spotShadowMap:[], spotShadowMatrix:[], rectArea:[], point:[], 
    pointShadowMap:[], pointShadowMatrix:[], hemi:[], shadows:[]}, Ea = {geometries:0, textures:0}, na = {frame:0, calls:0, vertices:0, faces:0, points:0};
    this.info = {render:na, memory:Ea, programs:null};
    var K;
    try {
      x = {alpha:x, depth:C, stencil:F, antialias:D, premultipliedAlpha:E, preserveDrawingBuffer:N};
      K = z || y.getContext("webgl", x) || y.getContext("experimental-webgl", x);
      if (null === K) {
        if (null !== y.getContext("webgl")) {
          throw "Error creating WebGL context with your selected attributes.";
        }
        throw "Error creating WebGL context.";
      }
      void 0 === K.getShaderPrecisionFormat && (K.getShaderPrecisionFormat = function() {
        return {rangeMin:1, rangeMax:1, precision:1};
      });
      y.addEventListener("webglcontextlost", b, !1);
    } catch (sf) {
      console.error("THREE.WebGLRenderer: " + sf);
    }
    var va = new qf(K);
    va.get("WEBGL_depth_texture");
    va.get("OES_texture_float");
    va.get("OES_texture_float_linear");
    va.get("OES_texture_half_float");
    va.get("OES_texture_half_float_linear");
    va.get("OES_standard_derivatives");
    va.get("ANGLE_instanced_arrays");
    va.get("OES_element_index_uint") && (da.MaxIndex = 4294967296);
    var Pa = new pf(K, va, d), oa = new of(K, va, B), Wa = new nf, Db = new mf(K, va, oa, Wa, Pa, B, Ea), ua = new df(K), Ca = new gf(K, ua, Ea), vb = new jf(K, Ca, na), wa = new lf(this, Pa), za = new hf;
    this.info.programs = wa.programs;
    var wd = new ff(K, va, na), Ia = new ef(K, va, na), Ha, Fa, Da, qb;
    m();
    this.context = K;
    this.capabilities = Pa;
    this.extensions = va;
    this.properties = Wa;
    this.state = oa;
    var Na = new vd(this, la, vb, Pa);
    this.shadowMap = Na;
    var Qa = new fa(this, ia), Ra = new pa(this, ea);
    this.getContext = function() {
      return K;
    };
    this.getContextAttributes = function() {
      return K.getContextAttributes();
    };
    this.forceContextLoss = function() {
      va.get("WEBGL_lose_context").loseContext();
    };
    this.getMaxAnisotropy = function() {
      return Pa.getMaxAnisotropy();
    };
    this.getPrecision = function() {
      return Pa.precision;
    };
    this.getPixelRatio = function() {
      return U;
    };
    this.setPixelRatio = function(d) {
      void 0 !== d && (U = d, this.setSize(xa.z, xa.w, !1));
    };
    this.getSize = function() {
      return {width:$b, height:Y};
    };
    this.setSize = function(d, m, a) {
      $b = d;
      Y = m;
      y.width = d * U;
      y.height = m * U;
      !1 !== a && (y.style.width = d + "px", y.style.height = m + "px");
      this.setViewport(0, 0, d, m);
    };
    this.setViewport = function(d, m, a, b) {
      oa.viewport(xa.set(d, m, a, b));
    };
    this.setScissor = function(d, m, a, b) {
      oa.scissor(Mc.set(d, m, a, b));
    };
    this.setScissorTest = function(d) {
      oa.setScissorTest(Aa = d);
    };
    this.getClearColor = function() {
      return W;
    };
    this.setClearColor = function(d, m) {
      W.set(d);
      pb = void 0 !== m ? m : 1;
      oa.buffers.color.setClear(W.r, W.g, W.b, pb, E);
    };
    this.getClearAlpha = function() {
      return pb;
    };
    this.setClearAlpha = function(d) {
      pb = d;
      oa.buffers.color.setClear(W.r, W.g, W.b, pb, E);
    };
    this.clear = function(d, m, a) {
      var b = 0;
      if (void 0 === d || d) {
        b |= K.COLOR_BUFFER_BIT;
      }
      if (void 0 === m || m) {
        b |= K.DEPTH_BUFFER_BIT;
      }
      if (void 0 === a || a) {
        b |= K.STENCIL_BUFFER_BIT;
      }
      K.clear(b);
    };
    this.clearColor = function() {
      this.clear(!0, !1, !1);
    };
    this.clearDepth = function() {
      this.clear(!1, !0, !1);
    };
    this.clearStencil = function() {
      this.clear(!1, !1, !0);
    };
    this.clearTarget = function(d, m, a, b) {
      this.setRenderTarget(d);
      this.clear(m, a, b);
    };
    this.resetGLState = a;
    this.dispose = function() {
      Z = [];
      L = -1;
      X = [];
      J = -1;
      y.removeEventListener("webglcontextlost", b, !1);
    };
    this.renderBufferImmediate = function(d, m, a) {
      oa.initAttributes();
      var b = Wa.get(d);
      d.hasPositions && !b.position && (b.position = K.createBuffer());
      d.hasNormals && !b.normal && (b.normal = K.createBuffer());
      d.hasUvs && !b.uv && (b.uv = K.createBuffer());
      d.hasColors && !b.color && (b.color = K.createBuffer());
      m = m.getAttributes();
      d.hasPositions && (K.bindBuffer(K.ARRAY_BUFFER, b.position), K.bufferData(K.ARRAY_BUFFER, d.positionArray, K.DYNAMIC_DRAW), oa.enableAttribute(m.position), K.vertexAttribPointer(m.position, 3, K.FLOAT, !1, 0, 0));
      if (d.hasNormals) {
        K.bindBuffer(K.ARRAY_BUFFER, b.normal);
        if (!a.isMeshPhongMaterial && !a.isMeshStandardMaterial && !a.isMeshNormalMaterial && 1 === a.shading) {
          for (var A = 0, c = 3 * d.count;A < c;A += 9) {
            var e = d.normalArray, g = (e[A + 0] + e[A + 3] + e[A + 6]) / 3, k = (e[A + 1] + e[A + 4] + e[A + 7]) / 3, f = (e[A + 2] + e[A + 5] + e[A + 8]) / 3;
            e[A + 0] = g;
            e[A + 1] = k;
            e[A + 2] = f;
            e[A + 3] = g;
            e[A + 4] = k;
            e[A + 5] = f;
            e[A + 6] = g;
            e[A + 7] = k;
            e[A + 8] = f;
          }
        }
        K.bufferData(K.ARRAY_BUFFER, d.normalArray, K.DYNAMIC_DRAW);
        oa.enableAttribute(m.normal);
        K.vertexAttribPointer(m.normal, 3, K.FLOAT, !1, 0, 0);
      }
      d.hasUvs && a.map && (K.bindBuffer(K.ARRAY_BUFFER, b.uv), K.bufferData(K.ARRAY_BUFFER, d.uvArray, K.DYNAMIC_DRAW), oa.enableAttribute(m.uv), K.vertexAttribPointer(ua.uv, 2, K.FLOAT, !1, 0, 0));
      d.hasColors && 0 !== a.vertexColors && (K.bindBuffer(K.ARRAY_BUFFER, b.color), K.bufferData(K.ARRAY_BUFFER, d.colorArray, K.DYNAMIC_DRAW), oa.enableAttribute(m.color), K.vertexAttribPointer(m.color, 3, K.FLOAT, !1, 0, 0));
      oa.disableUnusedAttributes();
      K.drawArrays(K.TRIANGLES, 0, d.count);
      d.count = 0;
    };
    var Ta, Ua, La;
    this.renderBufferDirect = function(d, m, a, b, A, c) {
      oa.setMaterial(b);
      Ta = w(d, m, b, A);
      Ua = a.id + "_" + Ta.id + "_" + b.wireframe;
      La = !1;
      Ua !== ha && (ha = Ua, La = !0);
      var e = A.morphTargetInfluences;
      if (void 0 !== e) {
        var g = [];
        d = 0;
        for (var k = e.length;d < k;d++) {
          m = e[d], g.push([m, d]);
        }
        g.sort(q);
        8 < g.length && (g.length = 8);
        e = a.morphAttributes;
        d = 0;
        for (k = g.length;d < k;d++) {
          m = g[d], S[d] = m[0], 0 !== m[0] ? (m = m[1], !0 === b.morphTargets && e.position && a.addAttribute("morphTarget" + d, e.position[m]), !0 === b.morphNormals && e.normal && a.addAttribute("morphNormal" + d, e.normal[m])) : (!0 === b.morphTargets && a.removeAttribute("morphTarget" + d), !0 === b.morphNormals && a.removeAttribute("morphNormal" + d));
        }
        d = g.length;
        for (m = S.length;d < m;d++) {
          S[d] = 0;
        }
        Ta.getUniforms().setValue(K, "morphTargetInfluences", S);
        La = !0;
      }
      m = a.index;
      k = a.attributes.position;
      g = 1;
      !0 === b.wireframe && (m = Ca.getWireframeAttribute(a), g = 2);
      d = wd;
      null !== m && (d = Ia, d.setIndex(m));
      if (La) {
        var f = Ta, e = void 0, p;
        if (a && a.isInstancedBufferGeometry && (p = va.get("ANGLE_instanced_arrays"), null === p)) {
          console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        } else {
          void 0 === e && (e = 0);
          oa.initAttributes();
          var G = a.attributes, f = f.getAttributes(), h = b.defaultAttributeValues, n;
          for (n in f) {
            var r = f[n];
            if (0 <= r) {
              var l = G[n];
              if (void 0 !== l) {
                var O = l.normalized, u = l.itemSize, aa = ua.get(l), t = aa.buffer, v = aa.type, aa = aa.bytesPerElement;
                if (l.isInterleavedBufferAttribute) {
                  var B = l.data, y = B.stride, l = l.offset;
                  B && B.isInstancedInterleavedBuffer ? (oa.enableAttributeAndDivisor(r, B.meshPerAttribute, p), void 0 === a.maxInstancedCount && (a.maxInstancedCount = B.meshPerAttribute * B.count)) : oa.enableAttribute(r);
                  K.bindBuffer(K.ARRAY_BUFFER, t);
                  K.vertexAttribPointer(r, u, v, O, y * aa, (e * y + l) * aa);
                } else {
                  l.isInstancedBufferAttribute ? (oa.enableAttributeAndDivisor(r, l.meshPerAttribute, p), void 0 === a.maxInstancedCount && (a.maxInstancedCount = l.meshPerAttribute * l.count)) : oa.enableAttribute(r), K.bindBuffer(K.ARRAY_BUFFER, t), K.vertexAttribPointer(r, u, v, O, 0, e * u * aa);
                }
              } else {
                if (void 0 !== h && (O = h[n], void 0 !== O)) {
                  switch(O.length) {
                    case 2:
                      K.vertexAttrib2fv(r, O);
                      break;
                    case 3:
                      K.vertexAttrib3fv(r, O);
                      break;
                    case 4:
                      K.vertexAttrib4fv(r, O);
                      break;
                    default:
                      K.vertexAttrib1fv(r, O);
                  }
                }
              }
            }
          }
          oa.disableUnusedAttributes();
        }
        null !== m && K.bindBuffer(K.ELEMENT_ARRAY_BUFFER, ua.get(m).buffer);
      }
      p = 0;
      null !== m ? p = m.count : void 0 !== k && (p = k.count);
      m = a.drawRange.start * g;
      k = null !== c ? c.start * g : 0;
      n = Math.max(m, k);
      c = Math.max(0, Math.min(p, m + a.drawRange.count * g, k + (null !== c ? c.count * g : Infinity)) - 1 - n + 1);
      if (0 !== c) {
        if (A.isMesh) {
          if (!0 === b.wireframe) {
            oa.setLineWidth(b.wireframeLinewidth * (null === H ? U : 1)), d.setMode(K.LINES);
          } else {
            switch(A.drawMode) {
              case 0:
                d.setMode(K.TRIANGLES);
                break;
              case 1:
                d.setMode(K.TRIANGLE_STRIP);
                break;
              case 2:
                d.setMode(K.TRIANGLE_FAN);
            }
          }
        } else {
          A.isLine ? (b = b.linewidth, void 0 === b && (b = 1), oa.setLineWidth(b * (null === H ? U : 1)), A.isLineSegments ? d.setMode(K.LINES) : A.isLineLoop ? d.setMode(K.LINE_LOOP) : d.setMode(K.LINE_STRIP)) : A.isPoints && d.setMode(K.POINTS);
        }
        a && a.isInstancedBufferGeometry ? 0 < a.maxInstancedCount && d.renderInstances(a, n, c) : d.render(n, c);
      }
    };
    this.render = function(d, m, a, b) {
      if (void 0 !== m && !0 !== m.isCamera) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      } else {
        ha = "";
        P = -1;
        V = null;
        !0 === d.autoUpdate && d.updateMatrixWorld();
        null === m.parent && m.updateMatrixWorld();
        m.matrixWorldInverse.getInverse(m.matrixWorld);
        Hb.multiplyMatrices(m.projectionMatrix, m.matrixWorldInverse);
        ya.setFromMatrix(Hb);
        I.length = 0;
        L = J = -1;
        ia.length = 0;
        ea.length = 0;
        ja = this.localClippingEnabled;
        Ba = ca.init(this.clippingPlanes, ja, m);
        l(d, m, M.sortObjects);
        X.length = J + 1;
        Z.length = L + 1;
        !0 === M.sortObjects && (X.sort(h), Z.sort(n));
        Ba && ca.beginShadows();
        for (var A = I, e = 0, c = 0, g = A.length;c < g;c++) {
          var k = A[c];
          k.castShadow && (la.shadows[e] = k, e++);
        }
        la.shadows.length = e;
        Na.render(d, m);
        for (var A = I, f, q = k = 0, G = 0, r, O, w, aa = m.matrixWorldInverse, t = 0, v = 0, B = 0, y = 0, ma = 0, e = 0, c = A.length;e < c;e++) {
          if (g = A[e], f = g.color, r = g.intensity, O = g.distance, w = g.shadow && g.shadow.map ? g.shadow.map.texture : null, g.isAmbientLight) {
            k += f.r * r, q += f.g * r, G += f.b * r;
          } else {
            if (g.isDirectionalLight) {
              var Q = za.get(g);
              Q.color.copy(g.color).multiplyScalar(g.intensity);
              Q.direction.setFromMatrixPosition(g.matrixWorld);
              ga.setFromMatrixPosition(g.target.matrixWorld);
              Q.direction.sub(ga);
              Q.direction.transformDirection(aa);
              if (Q.shadow = g.castShadow) {
                f = g.shadow, Q.shadowBias = f.bias, Q.shadowRadius = f.radius, Q.shadowMapSize = f.mapSize;
              }
              la.directionalShadowMap[t] = w;
              la.directionalShadowMatrix[t] = g.shadow.matrix;
              la.directional[t] = Q;
              t++;
            } else {
              if (g.isSpotLight) {
                Q = za.get(g);
                Q.position.setFromMatrixPosition(g.matrixWorld);
                Q.position.applyMatrix4(aa);
                Q.color.copy(f).multiplyScalar(r);
                Q.distance = O;
                Q.direction.setFromMatrixPosition(g.matrixWorld);
                ga.setFromMatrixPosition(g.target.matrixWorld);
                Q.direction.sub(ga);
                Q.direction.transformDirection(aa);
                Q.coneCos = Math.cos(g.angle);
                Q.penumbraCos = Math.cos(g.angle * (1 - g.penumbra));
                Q.decay = 0 === g.distance ? 0 : g.decay;
                if (Q.shadow = g.castShadow) {
                  f = g.shadow, Q.shadowBias = f.bias, Q.shadowRadius = f.radius, Q.shadowMapSize = f.mapSize;
                }
                la.spotShadowMap[B] = w;
                la.spotShadowMatrix[B] = g.shadow.matrix;
                la.spot[B] = Q;
                B++;
              } else {
                if (g.isRectAreaLight) {
                  Q = za.get(g), Q.color.copy(f).multiplyScalar(r / (g.width * g.height)), Q.position.setFromMatrixPosition(g.matrixWorld), Q.position.applyMatrix4(aa), Cb.identity(), ka.copy(g.matrixWorld), ka.premultiply(aa), Cb.extractRotation(ka), Q.halfWidth.set(.5 * g.width, 0, 0), Q.halfHeight.set(0, .5 * g.height, 0), Q.halfWidth.applyMatrix4(Cb), Q.halfHeight.applyMatrix4(Cb), la.rectArea[y] = Q, y++;
                } else {
                  if (g.isPointLight) {
                    Q = za.get(g);
                    Q.position.setFromMatrixPosition(g.matrixWorld);
                    Q.position.applyMatrix4(aa);
                    Q.color.copy(g.color).multiplyScalar(g.intensity);
                    Q.distance = g.distance;
                    Q.decay = 0 === g.distance ? 0 : g.decay;
                    if (Q.shadow = g.castShadow) {
                      f = g.shadow, Q.shadowBias = f.bias, Q.shadowRadius = f.radius, Q.shadowMapSize = f.mapSize;
                    }
                    la.pointShadowMap[v] = w;
                    void 0 === la.pointShadowMatrix[v] && (la.pointShadowMatrix[v] = new p);
                    ga.setFromMatrixPosition(g.matrixWorld).negate();
                    la.pointShadowMatrix[v].identity().setPosition(ga);
                    la.point[v] = Q;
                    v++;
                  } else {
                    g.isHemisphereLight && (Q = za.get(g), Q.direction.setFromMatrixPosition(g.matrixWorld), Q.direction.transformDirection(aa), Q.direction.normalize(), Q.skyColor.copy(g.color).multiplyScalar(r), Q.groundColor.copy(g.groundColor).multiplyScalar(r), la.hemi[ma] = Q, ma++);
                  }
                }
              }
            }
          }
        }
        la.ambient[0] = k;
        la.ambient[1] = q;
        la.ambient[2] = G;
        la.directional.length = t;
        la.spot.length = B;
        la.rectArea.length = y;
        la.point.length = v;
        la.hemi.length = ma;
        la.hash = t + "," + v + "," + B + "," + y + "," + ma + "," + la.shadows.length;
        Ba && ca.endShadows();
        na.frame++;
        na.calls = 0;
        na.vertices = 0;
        na.faces = 0;
        na.points = 0;
        void 0 === a && (a = null);
        this.setRenderTarget(a);
        A = d.background;
        null === A ? oa.buffers.color.setClear(W.r, W.g, W.b, pb, E) : A && A.isColor && (oa.buffers.color.setClear(A.r, A.g, A.b, 1, E), b = !0);
        (this.autoClear || b) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
        A && A.isCubeTexture ? (void 0 === Da && (Da = new Oa, qb = new Ga(new Va(5, 5, 5), new sa({uniforms:zb.cube.uniforms, vertexShader:zb.cube.vertexShader, fragmentShader:zb.cube.fragmentShader, side:1, depthTest:!1, depthWrite:!1, fog:!1}))), Da.projectionMatrix.copy(m.projectionMatrix), Da.matrixWorld.extractRotation(m.matrixWorld), Da.matrixWorldInverse.getInverse(Da.matrixWorld), qb.material.uniforms.tCube.value = A, qb.modelViewMatrix.multiplyMatrices(Da.matrixWorldInverse, qb.matrixWorld), 
        vb.update(qb), M.renderBufferDirect(Da, null, qb.geometry, qb.material, qb, null)) : A && A.isTexture && (void 0 === Ha && (Ha = new Zb(-1, 1, 1, -1, 0, 1), Fa = new Ga(new Gb(2, 2), new Ka({depthTest:!1, depthWrite:!1, fog:!1}))), Fa.material.map = A, vb.update(Fa), M.renderBufferDirect(Ha, null, Fa.geometry, Fa.material, Fa, null));
        d.overrideMaterial ? (b = d.overrideMaterial, u(X, d, m, b), u(Z, d, m, b)) : (oa.setBlending(0), u(X, d, m), u(Z, d, m));
        Qa.render(d, m);
        Ra.render(d, m, qa);
        a && Db.updateRenderTargetMipmap(a);
        oa.buffers.depth.setTest(!0);
        oa.buffers.depth.setMask(!0);
        oa.buffers.color.setMask(!0);
      }
    };
    this.setFaceCulling = function(d, m) {
      oa.setCullFace(d);
      oa.setFlipSided(0 === m);
    };
    this.allocTextureUnit = function() {
      var d = Ja;
      d >= Pa.maxTextures && console.warn("WebGLRenderer: trying to use " + d + " texture units while this GPU supports only " + Pa.maxTextures);
      Ja += 1;
      return d;
    };
    this.setTexture2D = function() {
      var d = !1;
      return function(m, a) {
        m && m.isWebGLRenderTarget && (d || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), d = !0), m = m.texture);
        Db.setTexture2D(m, a);
      };
    }();
    this.setTexture = function() {
      var d = !1;
      return function(m, a) {
        d || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), d = !0);
        Db.setTexture2D(m, a);
      };
    }();
    this.setTextureCube = function() {
      var d = !1;
      return function(m, a) {
        m && m.isWebGLRenderTargetCube && (d || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), d = !0), m = m.texture);
        m && m.isCubeTexture || Array.isArray(m.image) && 6 === m.image.length ? Db.setTextureCube(m, a) : Db.setTextureCubeDynamic(m, a);
      };
    }();
    this.getCurrentRenderTarget = function() {
      return H;
    };
    this.setRenderTarget = function(d) {
      (H = d) && void 0 === Wa.get(d).__webglFramebuffer && Db.setupRenderTarget(d);
      var m = d && d.isWebGLRenderTargetCube, a;
      d ? (a = Wa.get(d), a = m ? a.__webglFramebuffer[d.activeCubeFace] : a.__webglFramebuffer, ob.copy(d.scissor), ra = d.scissorTest, qa.copy(d.viewport)) : (a = null, ob.copy(Mc).multiplyScalar(U), ra = Aa, qa.copy(xa).multiplyScalar(U));
      ba !== a && (K.bindFramebuffer(K.FRAMEBUFFER, a), ba = a);
      oa.scissor(ob);
      oa.setScissorTest(ra);
      oa.viewport(qa);
      m && (m = Wa.get(d.texture), K.framebufferTexture2D(K.FRAMEBUFFER, K.COLOR_ATTACHMENT0, K.TEXTURE_CUBE_MAP_POSITIVE_X + d.activeCubeFace, m.__webglTexture, d.activeMipMapLevel));
    };
    this.readRenderTargetPixels = function(d, m, a, b, A, e) {
      if (!1 === (d && d.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      } else {
        var c = Wa.get(d).__webglFramebuffer;
        if (c) {
          var g = !1;
          c !== ba && (K.bindFramebuffer(K.FRAMEBUFFER, c), g = !0);
          try {
            var f = d.texture, k = f.format, q = f.type;
            1023 !== k && B(k) !== K.getParameter(K.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === q || B(q) === K.getParameter(K.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === q && (va.get("OES_texture_float") || va.get("WEBGL_color_buffer_float")) || 1016 === q && va.get("EXT_color_buffer_half_float") ? K.checkFramebufferStatus(K.FRAMEBUFFER) === K.FRAMEBUFFER_COMPLETE ? 0 <= 
            m && m <= d.width - b && 0 <= a && a <= d.height - A && K.readPixels(m, a, b, A, B(k), B(q), e) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          } finally {
            g && K.bindFramebuffer(K.FRAMEBUFFER, ba);
          }
        }
      }
    };
  }
  function ac(d, m) {
    this.name = "";
    this.color = new T(d);
    this.density = void 0 !== m ? m : 2.5E-4;
  }
  function bc(d, m, a) {
    this.name = "";
    this.color = new T(d);
    this.near = void 0 !== m ? m : 1;
    this.far = void 0 !== a ? a : 1E3;
  }
  function xd() {
    U.call(this);
    this.type = "Scene";
    this.overrideMaterial = this.fog = this.background = null;
    this.autoUpdate = !0;
  }
  function ee(d, m, a, b, c) {
    U.call(this);
    this.lensFlares = [];
    this.positionScreen = new e;
    this.customUpdateCallback = void 0;
    void 0 !== d && this.add(d, m, a, b, c);
  }
  function Eb(d) {
    W.call(this);
    this.type = "SpriteMaterial";
    this.color = new T(16777215);
    this.map = null;
    this.rotation = 0;
    this.lights = this.fog = !1;
    this.setValues(d);
  }
  function Nc(d) {
    U.call(this);
    this.type = "Sprite";
    this.material = void 0 !== d ? d : new Eb;
  }
  function Oc() {
    U.call(this);
    this.type = "LOD";
    Object.defineProperties(this, {levels:{enumerable:!0, value:[]}});
  }
  function Pc(d, m) {
    this.identityMatrix = new p;
    d = d || [];
    this.bones = d.slice(0);
    this.boneMatrices = new Float32Array(16 * this.bones.length);
    if (void 0 === m) {
      this.calculateInverses();
    } else {
      if (this.bones.length === m.length) {
        this.boneInverses = m.slice(0);
      } else {
        for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], d = 0, m = this.bones.length;d < m;d++) {
          this.boneInverses.push(new p);
        }
      }
    }
  }
  function yd() {
    U.call(this);
    this.type = "Bone";
  }
  function zd(d, m) {
    Ga.call(this, d, m);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new p;
    this.bindMatrixInverse = new p;
    d = [];
    if (this.geometry && void 0 !== this.geometry.bones) {
      for (var a, b = 0, e = this.geometry.bones.length;b < e;++b) {
        a = this.geometry.bones[b], m = new yd, d.push(m), m.name = a.name, m.position.fromArray(a.pos), m.quaternion.fromArray(a.rotq), void 0 !== a.scl && m.scale.fromArray(a.scl);
      }
      b = 0;
      for (e = this.geometry.bones.length;b < e;++b) {
        a = this.geometry.bones[b], -1 !== a.parent && null !== a.parent && void 0 !== d[a.parent] ? d[a.parent].add(d[b]) : this.add(d[b]);
      }
    }
    this.normalizeSkinWeights();
    this.updateMatrixWorld(!0);
    this.bind(new Pc(d), this.matrixWorld);
  }
  function wa(d) {
    W.call(this);
    this.type = "LineBasicMaterial";
    this.color = new T(16777215);
    this.linewidth = 1;
    this.linejoin = this.linecap = "round";
    this.lights = !1;
    this.setValues(d);
  }
  function db(d, m, a) {
    if (1 === a) {
      return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new ua(d, m);
    }
    U.call(this);
    this.type = "Line";
    this.geometry = void 0 !== d ? d : new da;
    this.material = void 0 !== m ? m : new wa({color:16777215 * Math.random()});
  }
  function ua(d, m) {
    db.call(this, d, m);
    this.type = "LineSegments";
  }
  function Ad(d, m) {
    db.call(this, d, m);
    this.type = "LineLoop";
  }
  function eb(d) {
    W.call(this);
    this.type = "PointsMaterial";
    this.color = new T(16777215);
    this.map = null;
    this.size = 1;
    this.sizeAttenuation = !0;
    this.lights = !1;
    this.setValues(d);
  }
  function cc(d, m) {
    U.call(this);
    this.type = "Points";
    this.geometry = void 0 !== d ? d : new da;
    this.material = void 0 !== m ? m : new eb({color:16777215 * Math.random()});
  }
  function Qc() {
    U.call(this);
    this.type = "Group";
  }
  function Bd(d, m, a, e, c, g, f, k, q) {
    function A() {
      requestAnimationFrame(A);
      d.readyState >= d.HAVE_CURRENT_DATA && (p.needsUpdate = !0);
    }
    b.call(this, d, m, a, e, c, g, f, k, q);
    this.generateMipmaps = !1;
    var p = this;
    A();
  }
  function dc(d, m, a, e, c, g, f, k, q, p, h, n) {
    b.call(this, null, g, f, k, q, p, e, c, h, n);
    this.image = {width:m, height:a};
    this.mipmaps = d;
    this.generateMipmaps = this.flipY = !1;
  }
  function Cd(d, m, a, e, c, g, f, k, q) {
    b.call(this, d, m, a, e, c, g, f, k, q);
    this.needsUpdate = !0;
  }
  function Rc(d, m, a, e, c, g, f, k, q, p) {
    p = void 0 !== p ? p : 1026;
    if (1026 !== p && 1027 !== p) {
      throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    void 0 === a && 1026 === p && (a = 1012);
    void 0 === a && 1027 === p && (a = 1020);
    b.call(this, null, e, c, g, f, k, p, a, q);
    this.image = {width:d, height:m};
    this.magFilter = void 0 !== f ? f : 1003;
    this.minFilter = void 0 !== k ? k : 1003;
    this.generateMipmaps = this.flipY = !1;
  }
  function ec(d) {
    function m(d, m) {
      return d - m;
    }
    da.call(this);
    this.type = "WireframeGeometry";
    var a = [], b, c, g, f, k = [0, 0], q = {}, p, h = ["a", "b", "c"];
    if (d && d.isGeometry) {
      var n = d.faces;
      b = 0;
      for (g = n.length;b < g;b++) {
        var r = n[b];
        for (c = 0;3 > c;c++) {
          k[0] = r[h[c]], k[1] = r[h[(c + 1) % 3]], k.sort(m), p = k.toString(), void 0 === q[p] && (q[p] = {index1:k[0], index2:k[1]});
        }
      }
      for (p in q) {
        b = q[p], h = d.vertices[b.index1], a.push(h.x, h.y, h.z), h = d.vertices[b.index2], a.push(h.x, h.y, h.z);
      }
    } else {
      if (d && d.isBufferGeometry) {
        var l, h = new e;
        if (null !== d.index) {
          n = d.attributes.position;
          r = d.index;
          l = d.groups;
          0 === l.length && (l = [{start:0, count:r.count, materialIndex:0}]);
          d = 0;
          for (f = l.length;d < f;++d) {
            for (b = l[d], c = b.start, g = b.count, b = c, g = c + g;b < g;b += 3) {
              for (c = 0;3 > c;c++) {
                k[0] = r.getX(b + c), k[1] = r.getX(b + (c + 1) % 3), k.sort(m), p = k.toString(), void 0 === q[p] && (q[p] = {index1:k[0], index2:k[1]});
              }
            }
          }
          for (p in q) {
            b = q[p], h.fromBufferAttribute(n, b.index1), a.push(h.x, h.y, h.z), h.fromBufferAttribute(n, b.index2), a.push(h.x, h.y, h.z);
          }
        } else {
          for (n = d.attributes.position, b = 0, g = n.count / 3;b < g;b++) {
            for (c = 0;3 > c;c++) {
              q = 3 * b + c, h.fromBufferAttribute(n, q), a.push(h.x, h.y, h.z), q = 3 * b + (c + 1) % 3, h.fromBufferAttribute(n, q), a.push(h.x, h.y, h.z);
            }
          }
        }
      }
    }
    this.addAttribute("position", new Y(a, 3));
  }
  function Sc(d, m, a) {
    ca.call(this);
    this.type = "ParametricGeometry";
    this.parameters = {func:d, slices:m, stacks:a};
    this.fromBufferGeometry(new fc(d, m, a));
    this.mergeVertices();
  }
  function fc(d, m, a) {
    da.call(this);
    this.type = "ParametricBufferGeometry";
    this.parameters = {func:d, slices:m, stacks:a};
    var b = [], A = [], c = [], e, g, k = m + 1;
    for (e = 0;e <= a;e++) {
      var f = e / a;
      for (g = 0;g <= m;g++) {
        var q = g / m, p = d(q, f);
        A.push(p.x, p.y, p.z);
        c.push(q, f);
      }
    }
    for (e = 0;e < a;e++) {
      for (g = 0;g < m;g++) {
        d = e * k + g + 1, f = (e + 1) * k + g + 1, q = (e + 1) * k + g, b.push(e * k + g, d, q), b.push(d, f, q);
      }
    }
    this.setIndex(b);
    this.addAttribute("position", new Y(A, 3));
    this.addAttribute("uv", new Y(c, 2));
    this.computeVertexNormals();
  }
  function Tc(d, m, a, b) {
    ca.call(this);
    this.type = "PolyhedronGeometry";
    this.parameters = {vertices:d, indices:m, radius:a, detail:b};
    this.fromBufferGeometry(new Qa(d, m, a, b));
    this.mergeVertices();
  }
  function Qa(d, m, a, b) {
    function A(d) {
      k.push(d.x, d.y, d.z);
    }
    function c(m, a) {
      m *= 3;
      a.x = d[m + 0];
      a.y = d[m + 1];
      a.z = d[m + 2];
    }
    function g(d, m, a, b) {
      0 > b && 1 === d.x && (f[m] = d.x - 1);
      0 === a.x && 0 === a.z && (f[m] = b / 2 / Math.PI + .5);
    }
    da.call(this);
    this.type = "PolyhedronBufferGeometry";
    this.parameters = {vertices:d, indices:m, radius:a, detail:b};
    a = a || 1;
    var k = [], f = [];
    (function(d) {
      for (var a = new e, b = new e, g = new e, k = 0;k < m.length;k += 3) {
        c(m[k + 0], a);
        c(m[k + 1], b);
        c(m[k + 2], g);
        var f = a, q = b, p = g, G = Math.pow(2, d), h = [], n, r;
        for (n = 0;n <= G;n++) {
          h[n] = [];
          var l = f.clone().lerp(p, n / G), u = q.clone().lerp(p, n / G), O = G - n;
          for (r = 0;r <= O;r++) {
            h[n][r] = 0 === r && n === G ? l : l.clone().lerp(u, r / O);
          }
        }
        for (n = 0;n < G;n++) {
          for (r = 0;r < 2 * (G - n) - 1;r++) {
            f = Math.floor(r / 2), 0 === r % 2 ? (A(h[n][f + 1]), A(h[n + 1][f]), A(h[n][f])) : (A(h[n][f + 1]), A(h[n + 1][f + 1]), A(h[n + 1][f]));
          }
        }
      }
    })(b || 0);
    (function(d) {
      for (var m = new e, a = 0;a < k.length;a += 3) {
        m.x = k[a + 0], m.y = k[a + 1], m.z = k[a + 2], m.normalize().multiplyScalar(d), k[a + 0] = m.x, k[a + 1] = m.y, k[a + 2] = m.z;
      }
    })(a);
    (function() {
      for (var d = new e, m = 0;m < k.length;m += 3) {
        d.x = k[m + 0], d.y = k[m + 1], d.z = k[m + 2], f.push(Math.atan2(d.z, -d.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-d.y, Math.sqrt(d.x * d.x + d.z * d.z)) / Math.PI + .5));
      }
      for (var d = new e, m = new e, a = new e, b = new e, A = new l, c = new l, q = new l, p = 0, G = 0;p < k.length;p += 9, G += 6) {
        d.set(k[p + 0], k[p + 1], k[p + 2]);
        m.set(k[p + 3], k[p + 4], k[p + 5]);
        a.set(k[p + 6], k[p + 7], k[p + 8]);
        A.set(f[G + 0], f[G + 1]);
        c.set(f[G + 2], f[G + 3]);
        q.set(f[G + 4], f[G + 5]);
        b.copy(d).add(m).add(a).divideScalar(3);
        var h = Math.atan2(b.z, -b.x);
        g(A, G + 0, d, h);
        g(c, G + 2, m, h);
        g(q, G + 4, a, h);
      }
      for (d = 0;d < f.length;d += 6) {
        m = f[d + 0], a = f[d + 2], b = f[d + 4], A = Math.min(m, a, b), .9 < Math.max(m, a, b) && .1 > A && (.2 > m && (f[d + 0] += 1), .2 > a && (f[d + 2] += 1), .2 > b && (f[d + 4] += 1));
      }
    })();
    this.addAttribute("position", new Y(k, 3));
    this.addAttribute("normal", new Y(k.slice(), 3));
    this.addAttribute("uv", new Y(f, 2));
    this.normalizeNormals();
  }
  function Uc(d, m) {
    ca.call(this);
    this.type = "TetrahedronGeometry";
    this.parameters = {radius:d, detail:m};
    this.fromBufferGeometry(new gc(d, m));
    this.mergeVertices();
  }
  function gc(d, m) {
    Qa.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], d, m);
    this.type = "TetrahedronBufferGeometry";
    this.parameters = {radius:d, detail:m};
  }
  function Vc(d, m) {
    ca.call(this);
    this.type = "OctahedronGeometry";
    this.parameters = {radius:d, detail:m};
    this.fromBufferGeometry(new Ib(d, m));
    this.mergeVertices();
  }
  function Ib(d, m) {
    Qa.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], d, m);
    this.type = "OctahedronBufferGeometry";
    this.parameters = {radius:d, detail:m};
  }
  function Wc(d, m) {
    ca.call(this);
    this.type = "IcosahedronGeometry";
    this.parameters = {radius:d, detail:m};
    this.fromBufferGeometry(new hc(d, m));
    this.mergeVertices();
  }
  function hc(d, m) {
    var a = (1 + Math.sqrt(5)) / 2;
    Qa.call(this, [-1, a, 0, 1, a, 0, -1, -a, 0, 1, -a, 0, 0, -1, a, 0, 1, a, 0, -1, -a, 0, 1, -a, a, 0, -1, a, 0, 1, -a, 0, -1, -a, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], d, m);
    this.type = "IcosahedronBufferGeometry";
    this.parameters = {radius:d, detail:m};
  }
  function Xc(d, m) {
    ca.call(this);
    this.type = "DodecahedronGeometry";
    this.parameters = {radius:d, detail:m};
    this.fromBufferGeometry(new ic(d, m));
    this.mergeVertices();
  }
  function ic(d, m) {
    var a = (1 + Math.sqrt(5)) / 2, b = 1 / a;
    Qa.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -b, -a, 0, -b, a, 0, b, -a, 0, b, a, -b, -a, 0, -b, a, 0, b, -a, 0, b, a, 0, -a, 0, -b, a, 0, -b, -a, 0, b, a, 0, b], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 
    8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], d, m);
    this.type = "DodecahedronBufferGeometry";
    this.parameters = {radius:d, detail:m};
  }
  function Yc(d, m, a, b, c, e) {
    ca.call(this);
    this.type = "TubeGeometry";
    this.parameters = {path:d, tubularSegments:m, radius:a, radialSegments:b, closed:c};
    void 0 !== e && console.warn("THREE.TubeGeometry: taper has been removed.");
    d = new jc(d, m, a, b, c);
    this.tangents = d.tangents;
    this.normals = d.normals;
    this.binormals = d.binormals;
    this.fromBufferGeometry(d);
    this.mergeVertices();
  }
  function jc(d, m, a, b, c) {
    function A(A) {
      var c = d.getPointAt(A / m), e = g.normals[A];
      A = g.binormals[A];
      for (h = 0;h <= b;h++) {
        var q = h / b * Math.PI * 2, p = Math.sin(q), q = -Math.cos(q);
        f.x = q * e.x + p * A.x;
        f.y = q * e.y + p * A.y;
        f.z = q * e.z + p * A.z;
        f.normalize();
        n.push(f.x, f.y, f.z);
        k.x = c.x + a * f.x;
        k.y = c.y + a * f.y;
        k.z = c.z + a * f.z;
        G.push(k.x, k.y, k.z);
      }
    }
    da.call(this);
    this.type = "TubeBufferGeometry";
    this.parameters = {path:d, tubularSegments:m, radius:a, radialSegments:b, closed:c};
    m = m || 64;
    a = a || 1;
    b = b || 8;
    c = c || !1;
    var g = d.computeFrenetFrames(m, c);
    this.tangents = g.tangents;
    this.normals = g.normals;
    this.binormals = g.binormals;
    var k = new e, f = new e, q = new l, p, h, G = [], n = [], r = [], u = [];
    for (p = 0;p < m;p++) {
      A(p);
    }
    A(!1 === c ? m : 0);
    for (p = 0;p <= m;p++) {
      for (h = 0;h <= b;h++) {
        q.x = p / m, q.y = h / b, r.push(q.x, q.y);
      }
    }
    (function() {
      for (h = 1;h <= m;h++) {
        for (p = 1;p <= b;p++) {
          var d = (b + 1) * h + (p - 1), a = (b + 1) * h + p, A = (b + 1) * (h - 1) + p;
          u.push((b + 1) * (h - 1) + (p - 1), d, A);
          u.push(d, a, A);
        }
      }
    })();
    this.setIndex(u);
    this.addAttribute("position", new Y(G, 3));
    this.addAttribute("normal", new Y(n, 3));
    this.addAttribute("uv", new Y(r, 2));
  }
  function Zc(d, m, a, b, c, e, g) {
    ca.call(this);
    this.type = "TorusKnotGeometry";
    this.parameters = {radius:d, tube:m, tubularSegments:a, radialSegments:b, p:c, q:e};
    void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
    this.fromBufferGeometry(new kc(d, m, a, b, c, e));
    this.mergeVertices();
  }
  function kc(d, m, a, b, c, g) {
    function A(d, m, a, b, A) {
      var c = Math.sin(d);
      m = a / m * d;
      a = Math.cos(m);
      A.x = b * (2 + a) * .5 * Math.cos(d);
      A.y = b * (2 + a) * c * .5;
      A.z = b * Math.sin(m) * .5;
    }
    da.call(this);
    this.type = "TorusKnotBufferGeometry";
    this.parameters = {radius:d, tube:m, tubularSegments:a, radialSegments:b, p:c, q:g};
    d = d || 100;
    m = m || 40;
    a = Math.floor(a) || 64;
    b = Math.floor(b) || 8;
    c = c || 2;
    g = g || 3;
    var k = [], f = [], q = [], p = [], h, G, n = new e, r = new e;
    new l;
    var u = new e, O = new e, w = new e, aa = new e, t = new e;
    for (h = 0;h <= a;++h) {
      for (G = h / a * c * Math.PI * 2, A(G, c, g, d, u), A(G + .01, c, g, d, O), aa.subVectors(O, u), t.addVectors(O, u), w.crossVectors(aa, t), t.crossVectors(w, aa), w.normalize(), t.normalize(), G = 0;G <= b;++G) {
        var v = G / b * Math.PI * 2, B = -m * Math.cos(v), v = m * Math.sin(v);
        n.x = u.x + (B * t.x + v * w.x);
        n.y = u.y + (B * t.y + v * w.y);
        n.z = u.z + (B * t.z + v * w.z);
        f.push(n.x, n.y, n.z);
        r.subVectors(n, u).normalize();
        q.push(r.x, r.y, r.z);
        p.push(h / a);
        p.push(G / b);
      }
    }
    for (G = 1;G <= a;G++) {
      for (h = 1;h <= b;h++) {
        d = (b + 1) * G + (h - 1), m = (b + 1) * G + h, c = (b + 1) * (G - 1) + h, k.push((b + 1) * (G - 1) + (h - 1), d, c), k.push(d, m, c);
      }
    }
    this.setIndex(k);
    this.addAttribute("position", new Y(f, 3));
    this.addAttribute("normal", new Y(q, 3));
    this.addAttribute("uv", new Y(p, 2));
  }
  function $c(d, m, a, b, c) {
    ca.call(this);
    this.type = "TorusGeometry";
    this.parameters = {radius:d, tube:m, radialSegments:a, tubularSegments:b, arc:c};
    this.fromBufferGeometry(new lc(d, m, a, b, c));
  }
  function lc(d, m, a, b, c) {
    da.call(this);
    this.type = "TorusBufferGeometry";
    this.parameters = {radius:d, tube:m, radialSegments:a, tubularSegments:b, arc:c};
    d = d || 100;
    m = m || 40;
    a = Math.floor(a) || 8;
    b = Math.floor(b) || 6;
    c = c || 2 * Math.PI;
    var A = [], g = [], k = [], f = [], q = new e, p = new e, h = new e, G, n;
    for (G = 0;G <= a;G++) {
      for (n = 0;n <= b;n++) {
        var r = n / b * c, l = G / a * Math.PI * 2;
        p.x = (d + m * Math.cos(l)) * Math.cos(r);
        p.y = (d + m * Math.cos(l)) * Math.sin(r);
        p.z = m * Math.sin(l);
        g.push(p.x, p.y, p.z);
        q.x = d * Math.cos(r);
        q.y = d * Math.sin(r);
        h.subVectors(p, q).normalize();
        k.push(h.x, h.y, h.z);
        f.push(n / b);
        f.push(G / a);
      }
    }
    for (G = 1;G <= a;G++) {
      for (n = 1;n <= b;n++) {
        d = (b + 1) * (G - 1) + n - 1, m = (b + 1) * (G - 1) + n, c = (b + 1) * G + n, A.push((b + 1) * G + n - 1, d, c), A.push(d, m, c);
      }
    }
    this.setIndex(A);
    this.addAttribute("position", new Y(g, 3));
    this.addAttribute("normal", new Y(k, 3));
    this.addAttribute("uv", new Y(f, 2));
  }
  function bb(d, m) {
    "undefined" !== typeof d && (ca.call(this), this.type = "ExtrudeGeometry", d = Array.isArray(d) ? d : [d], this.addShapeList(d, m), this.computeFaceNormals());
  }
  function ad(d, m) {
    m = m || {};
    var a = m.font;
    if (!1 === (a && a.isFont)) {
      return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new ca;
    }
    a = a.generateShapes(d, m.size, m.curveSegments);
    m.amount = void 0 !== m.height ? m.height : 50;
    void 0 === m.bevelThickness && (m.bevelThickness = 10);
    void 0 === m.bevelSize && (m.bevelSize = 8);
    void 0 === m.bevelEnabled && (m.bevelEnabled = !1);
    bb.call(this, a, m);
    this.type = "TextGeometry";
  }
  function bd(d, m, a, b, c, e, g) {
    ca.call(this);
    this.type = "SphereGeometry";
    this.parameters = {radius:d, widthSegments:m, heightSegments:a, phiStart:b, phiLength:c, thetaStart:e, thetaLength:g};
    this.fromBufferGeometry(new Jb(d, m, a, b, c, e, g));
  }
  function Jb(d, m, a, b, c, g, k) {
    da.call(this);
    this.type = "SphereBufferGeometry";
    this.parameters = {radius:d, widthSegments:m, heightSegments:a, phiStart:b, phiLength:c, thetaStart:g, thetaLength:k};
    d = d || 50;
    m = Math.max(3, Math.floor(m) || 8);
    a = Math.max(2, Math.floor(a) || 6);
    b = void 0 !== b ? b : 0;
    c = void 0 !== c ? c : 2 * Math.PI;
    g = void 0 !== g ? g : 0;
    k = void 0 !== k ? k : Math.PI;
    var A = g + k, f, q, p = 0, h = [], G = new e, n = new e, r = [], l = [], u = [], O = [];
    for (q = 0;q <= a;q++) {
      var w = [], aa = q / a;
      for (f = 0;f <= m;f++) {
        var t = f / m;
        G.x = -d * Math.cos(b + t * c) * Math.sin(g + aa * k);
        G.y = d * Math.cos(g + aa * k);
        G.z = d * Math.sin(b + t * c) * Math.sin(g + aa * k);
        l.push(G.x, G.y, G.z);
        n.set(G.x, G.y, G.z).normalize();
        u.push(n.x, n.y, n.z);
        O.push(t, 1 - aa);
        w.push(p++);
      }
      h.push(w);
    }
    for (q = 0;q < a;q++) {
      for (f = 0;f < m;f++) {
        d = h[q][f + 1], b = h[q][f], c = h[q + 1][f], k = h[q + 1][f + 1], (0 !== q || 0 < g) && r.push(d, b, k), (q !== a - 1 || A < Math.PI) && r.push(b, c, k);
      }
    }
    this.setIndex(r);
    this.addAttribute("position", new Y(l, 3));
    this.addAttribute("normal", new Y(u, 3));
    this.addAttribute("uv", new Y(O, 2));
  }
  function cd(d, m, a, b, c, e) {
    ca.call(this);
    this.type = "RingGeometry";
    this.parameters = {innerRadius:d, outerRadius:m, thetaSegments:a, phiSegments:b, thetaStart:c, thetaLength:e};
    this.fromBufferGeometry(new mc(d, m, a, b, c, e));
  }
  function mc(d, m, a, b, c, g) {
    da.call(this);
    this.type = "RingBufferGeometry";
    this.parameters = {innerRadius:d, outerRadius:m, thetaSegments:a, phiSegments:b, thetaStart:c, thetaLength:g};
    d = d || 20;
    m = m || 50;
    c = void 0 !== c ? c : 0;
    g = void 0 !== g ? g : 2 * Math.PI;
    a = void 0 !== a ? Math.max(3, a) : 8;
    b = void 0 !== b ? Math.max(1, b) : 1;
    var A = [], k = [], f = [], q = [], p = d, h = (m - d) / b, G = new e, n = new l, r, u;
    for (r = 0;r <= b;r++) {
      for (u = 0;u <= a;u++) {
        d = c + u / a * g, G.x = p * Math.cos(d), G.y = p * Math.sin(d), k.push(G.x, G.y, G.z), f.push(0, 0, 1), n.x = (G.x / m + 1) / 2, n.y = (G.y / m + 1) / 2, q.push(n.x, n.y);
      }
      p += h;
    }
    for (r = 0;r < b;r++) {
      for (m = r * (a + 1), u = 0;u < a;u++) {
        d = u + m, c = d + a + 1, g = d + a + 2, p = d + 1, A.push(d, c, p), A.push(c, g, p);
      }
    }
    this.setIndex(A);
    this.addAttribute("position", new Y(k, 3));
    this.addAttribute("normal", new Y(f, 3));
    this.addAttribute("uv", new Y(q, 2));
  }
  function dd(d, m, a, b) {
    ca.call(this);
    this.type = "LatheGeometry";
    this.parameters = {points:d, segments:m, phiStart:a, phiLength:b};
    this.fromBufferGeometry(new nc(d, m, a, b));
    this.mergeVertices();
  }
  function nc(d, m, a, b) {
    da.call(this);
    this.type = "LatheBufferGeometry";
    this.parameters = {points:d, segments:m, phiStart:a, phiLength:b};
    m = Math.floor(m) || 12;
    a = a || 0;
    b = b || 2 * Math.PI;
    b = ka.clamp(b, 0, 2 * Math.PI);
    var c = [], A = [], g = [], k = 1 / m, f = new e, q = new l, p, h;
    for (p = 0;p <= m;p++) {
      h = a + p * k * b;
      var G = Math.sin(h), n = Math.cos(h);
      for (h = 0;h <= d.length - 1;h++) {
        f.x = d[h].x * G, f.y = d[h].y, f.z = d[h].x * n, A.push(f.x, f.y, f.z), q.x = p / m, q.y = h / (d.length - 1), g.push(q.x, q.y);
      }
    }
    for (p = 0;p < m;p++) {
      for (h = 0;h < d.length - 1;h++) {
        a = h + p * d.length, k = a + d.length, f = a + d.length + 1, q = a + 1, c.push(a, k, q), c.push(k, f, q);
      }
    }
    this.setIndex(c);
    this.addAttribute("position", new Y(A, 3));
    this.addAttribute("uv", new Y(g, 2));
    this.computeVertexNormals();
    if (b === 2 * Math.PI) {
      for (b = this.attributes.normal.array, c = new e, A = new e, g = new e, a = m * d.length * 3, h = p = 0;p < d.length;p++, h += 3) {
        c.x = b[h + 0], c.y = b[h + 1], c.z = b[h + 2], A.x = b[a + h + 0], A.y = b[a + h + 1], A.z = b[a + h + 2], g.addVectors(c, A).normalize(), b[h + 0] = b[a + h + 0] = g.x, b[h + 1] = b[a + h + 1] = g.y, b[h + 2] = b[a + h + 2] = g.z;
      }
    }
  }
  function oc(d, m) {
    ca.call(this);
    this.type = "ShapeGeometry";
    "object" === typeof m && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), m = m.curveSegments);
    this.parameters = {shapes:d, curveSegments:m};
    this.fromBufferGeometry(new pc(d, m));
    this.mergeVertices();
  }
  function pc(d, m) {
    function a(d) {
      var a, A, k = c.length / 3;
      d = d.extractPoints(m);
      var q = d.shape, p = d.holes;
      if (!1 === fb.isClockWise(q)) {
        for (q = q.reverse(), d = 0, a = p.length;d < a;d++) {
          A = p[d], !0 === fb.isClockWise(A) && (p[d] = A.reverse());
        }
      }
      var h = fb.triangulateShape(q, p);
      d = 0;
      for (a = p.length;d < a;d++) {
        A = p[d], q = q.concat(A);
      }
      d = 0;
      for (a = q.length;d < a;d++) {
        A = q[d], c.push(A.x, A.y, 0), e.push(0, 0, 1), g.push(A.x, A.y);
      }
      d = 0;
      for (a = h.length;d < a;d++) {
        q = h[d], b.push(q[0] + k, q[1] + k, q[2] + k), f += 3;
      }
    }
    da.call(this);
    this.type = "ShapeBufferGeometry";
    this.parameters = {shapes:d, curveSegments:m};
    m = m || 12;
    var b = [], c = [], e = [], g = [], k = 0, f = 0;
    if (!1 === Array.isArray(d)) {
      a(d);
    } else {
      for (var q = 0;q < d.length;q++) {
        a(d[q]), this.addGroup(k, f, q), k += f, f = 0;
      }
    }
    this.setIndex(b);
    this.addAttribute("position", new Y(c, 3));
    this.addAttribute("normal", new Y(e, 3));
    this.addAttribute("uv", new Y(g, 2));
  }
  function qc(d, m) {
    function a(d, m) {
      return d - m;
    }
    da.call(this);
    this.type = "EdgesGeometry";
    this.parameters = {thresholdAngle:m};
    var b = [];
    m = Math.cos(ka.DEG2RAD * (void 0 !== m ? m : 1));
    var c = [0, 0], e = {}, g, k = ["a", "b", "c"], f;
    d.isBufferGeometry ? (f = new ca, f.fromBufferGeometry(d)) : f = d.clone();
    f.mergeVertices();
    f.computeFaceNormals();
    d = f.vertices;
    f = f.faces;
    for (var q = 0, p = f.length;q < p;q++) {
      for (var h = f[q], n = 0;3 > n;n++) {
        c[0] = h[k[n]], c[1] = h[k[(n + 1) % 3]], c.sort(a), g = c.toString(), void 0 === e[g] ? e[g] = {index1:c[0], index2:c[1], face1:q, face2:void 0} : e[g].face2 = q;
      }
    }
    for (g in e) {
      if (c = e[g], void 0 === c.face2 || f[c.face1].normal.dot(f[c.face2].normal) <= m) {
        k = d[c.index1], b.push(k.x, k.y, k.z), k = d[c.index2], b.push(k.x, k.y, k.z);
      }
    }
    this.addAttribute("position", new Y(b, 3));
  }
  function Kb(d, m, a, b, c, e, g, k) {
    ca.call(this);
    this.type = "CylinderGeometry";
    this.parameters = {radiusTop:d, radiusBottom:m, height:a, radialSegments:b, heightSegments:c, openEnded:e, thetaStart:g, thetaLength:k};
    this.fromBufferGeometry(new wb(d, m, a, b, c, e, g, k));
    this.mergeVertices();
  }
  function wb(d, m, a, b, c, g, k, f) {
    function A(a) {
      var c, A, g, u = new l, t = new e, aa = 0, v = !0 === a ? d : m, B = !0 === a ? 1 : -1;
      A = r;
      for (c = 1;c <= b;c++) {
        h.push(0, O * B, 0), n.push(0, B, 0), G.push(.5, .5), r++;
      }
      g = r;
      for (c = 0;c <= b;c++) {
        var y = c / b * f + k, ma = Math.cos(y), y = Math.sin(y);
        t.x = v * y;
        t.y = O * B;
        t.z = v * ma;
        h.push(t.x, t.y, t.z);
        n.push(0, B, 0);
        u.x = .5 * ma + .5;
        u.y = .5 * y * B + .5;
        G.push(u.x, u.y);
        r++;
      }
      for (c = 0;c < b;c++) {
        u = A + c, t = g + c, !0 === a ? p.push(t, t + 1, u) : p.push(t + 1, t, u), aa += 3;
      }
      q.addGroup(w, aa, !0 === a ? 1 : 2);
      w += aa;
    }
    da.call(this);
    this.type = "CylinderBufferGeometry";
    this.parameters = {radiusTop:d, radiusBottom:m, height:a, radialSegments:b, heightSegments:c, openEnded:g, thetaStart:k, thetaLength:f};
    var q = this;
    d = void 0 !== d ? d : 20;
    m = void 0 !== m ? m : 20;
    a = void 0 !== a ? a : 100;
    b = Math.floor(b) || 8;
    c = Math.floor(c) || 1;
    g = void 0 !== g ? g : !1;
    k = void 0 !== k ? k : 0;
    f = void 0 !== f ? f : 2 * Math.PI;
    var p = [], h = [], n = [], G = [], r = 0, u = [], O = a / 2, w = 0;
    (function() {
      var A, g, l = new e, t = new e, aa = 0, v = (m - d) / a;
      for (g = 0;g <= c;g++) {
        var B = [], y = g / c, ma = y * (m - d) + d;
        for (A = 0;A <= b;A++) {
          var z = A / b, x = z * f + k, Q = Math.sin(x), x = Math.cos(x);
          t.x = ma * Q;
          t.y = -y * a + O;
          t.z = ma * x;
          h.push(t.x, t.y, t.z);
          l.set(Q, v, x).normalize();
          n.push(l.x, l.y, l.z);
          G.push(z, 1 - y);
          B.push(r++);
        }
        u.push(B);
      }
      for (A = 0;A < b;A++) {
        for (g = 0;g < c;g++) {
          l = u[g + 1][A], t = u[g + 1][A + 1], v = u[g][A + 1], p.push(u[g][A], l, v), p.push(l, t, v), aa += 6;
        }
      }
      q.addGroup(w, aa, 0);
      w += aa;
    })();
    !1 === g && (0 < d && A(!0), 0 < m && A(!1));
    this.setIndex(p);
    this.addAttribute("position", new Y(h, 3));
    this.addAttribute("normal", new Y(n, 3));
    this.addAttribute("uv", new Y(G, 2));
  }
  function ed(d, m, a, b, c, e, g) {
    Kb.call(this, 0, d, m, a, b, c, e, g);
    this.type = "ConeGeometry";
    this.parameters = {radius:d, height:m, radialSegments:a, heightSegments:b, openEnded:c, thetaStart:e, thetaLength:g};
  }
  function fd(d, m, a, b, c, e, g) {
    wb.call(this, 0, d, m, a, b, c, e, g);
    this.type = "ConeBufferGeometry";
    this.parameters = {radius:d, height:m, radialSegments:a, heightSegments:b, openEnded:c, thetaStart:e, thetaLength:g};
  }
  function gd(d, m, a, b) {
    ca.call(this);
    this.type = "CircleGeometry";
    this.parameters = {radius:d, segments:m, thetaStart:a, thetaLength:b};
    this.fromBufferGeometry(new rc(d, m, a, b));
  }
  function rc(d, m, a, b) {
    da.call(this);
    this.type = "CircleBufferGeometry";
    this.parameters = {radius:d, segments:m, thetaStart:a, thetaLength:b};
    d = d || 50;
    m = void 0 !== m ? Math.max(3, m) : 8;
    a = void 0 !== a ? a : 0;
    b = void 0 !== b ? b : 2 * Math.PI;
    var c = [], A = [], g = [], k = [], f, q, p = new e, h = new l;
    A.push(0, 0, 0);
    g.push(0, 0, 1);
    k.push(.5, .5);
    q = 0;
    for (f = 3;q <= m;q++, f += 3) {
      var n = a + q / m * b;
      p.x = d * Math.cos(n);
      p.y = d * Math.sin(n);
      A.push(p.x, p.y, p.z);
      g.push(0, 0, 1);
      h.x = (A[f] / d + 1) / 2;
      h.y = (A[f + 1] / d + 1) / 2;
      k.push(h.x, h.y);
    }
    for (f = 1;f <= m;f++) {
      c.push(f, f + 1, 0);
    }
    this.setIndex(c);
    this.addAttribute("position", new Y(A, 3));
    this.addAttribute("normal", new Y(g, 3));
    this.addAttribute("uv", new Y(k, 2));
  }
  function sc() {
    sa.call(this, {uniforms:Sa.merge([ga.lights, {opacity:{value:1}}]), vertexShader:na.shadow_vert, fragmentShader:na.shadow_frag});
    this.transparent = this.lights = !0;
    Object.defineProperties(this, {opacity:{enumerable:!0, get:function() {
      return this.uniforms.opacity.value;
    }, set:function(d) {
      this.uniforms.opacity.value = d;
    }}});
  }
  function tc(d) {
    sa.call(this, d);
    this.type = "RawShaderMaterial";
  }
  function rb(d) {
    W.call(this);
    this.defines = {STANDARD:""};
    this.type = "MeshStandardMaterial";
    this.color = new T(16777215);
    this.metalness = this.roughness = .5;
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new T(0);
    this.emissiveIntensity = 1;
    this.bumpMap = this.emissiveMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalScale = new l(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = !1;
    this.setValues(d);
  }
  function Lb(d) {
    rb.call(this);
    this.defines = {PHYSICAL:""};
    this.type = "MeshPhysicalMaterial";
    this.reflectivity = .5;
    this.clearCoatRoughness = this.clearCoat = 0;
    this.setValues(d);
  }
  function gb(d) {
    W.call(this);
    this.type = "MeshPhongMaterial";
    this.color = new T(16777215);
    this.specular = new T(1118481);
    this.shininess = 30;
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new T(0);
    this.emissiveIntensity = 1;
    this.bumpMap = this.emissiveMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalScale = new l(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.envMap = this.alphaMap = this.specularMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = !1;
    this.setValues(d);
  }
  function Mb(d) {
    gb.call(this);
    this.defines = {TOON:""};
    this.type = "MeshToonMaterial";
    this.gradientMap = null;
    this.setValues(d);
  }
  function Nb(d) {
    W.call(this, d);
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalScale = new l(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.morphNormals = this.morphTargets = this.lights = this.fog = !1;
    this.setValues(d);
  }
  function Ob(d) {
    W.call(this);
    this.type = "MeshLambertMaterial";
    this.color = new T(16777215);
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new T(0);
    this.emissiveIntensity = 1;
    this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = !1;
    this.setValues(d);
  }
  function Pb(d) {
    W.call(this);
    this.type = "LineDashedMaterial";
    this.color = new T(16777215);
    this.scale = this.linewidth = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.lights = !1;
    this.setValues(d);
  }
  function fe(d, m, a) {
    var b = this, c = !1, A = 0, e = 0;
    this.onStart = void 0;
    this.onLoad = d;
    this.onProgress = m;
    this.onError = a;
    this.itemStart = function(d) {
      e++;
      if (!1 === c && void 0 !== b.onStart) {
        b.onStart(d, A, e);
      }
      c = !0;
    };
    this.itemEnd = function(d) {
      A++;
      if (void 0 !== b.onProgress) {
        b.onProgress(d, A, e);
      }
      if (A === e && (c = !1, void 0 !== b.onLoad)) {
        b.onLoad();
      }
    };
    this.itemError = function(d) {
      if (void 0 !== b.onError) {
        b.onError(d);
      }
    };
  }
  function hb(d) {
    this.manager = void 0 !== d ? d : Ya;
  }
  function Ie(d) {
    this.manager = void 0 !== d ? d : Ya;
    this._parser = null;
  }
  function ge(d) {
    this.manager = void 0 !== d ? d : Ya;
    this._parser = null;
  }
  function hd(d) {
    this.manager = void 0 !== d ? d : Ya;
  }
  function he(d) {
    this.manager = void 0 !== d ? d : Ya;
  }
  function Dd(d) {
    this.manager = void 0 !== d ? d : Ya;
  }
  function Ca(d, m) {
    U.call(this);
    this.type = "Light";
    this.color = new T(d);
    this.intensity = void 0 !== m ? m : 1;
    this.receiveShadow = void 0;
  }
  function Ed(d, m, a) {
    Ca.call(this, d, a);
    this.type = "HemisphereLight";
    this.castShadow = void 0;
    this.position.copy(U.DefaultUp);
    this.updateMatrix();
    this.groundColor = new T(m);
  }
  function Qb(d) {
    this.camera = d;
    this.bias = 0;
    this.radius = 1;
    this.mapSize = new l(512, 512);
    this.map = null;
    this.matrix = new p;
  }
  function Fd() {
    Qb.call(this, new Oa(50, 1, .5, 500));
  }
  function Gd(d, m, a, b, c, e) {
    Ca.call(this, d, m);
    this.type = "SpotLight";
    this.position.copy(U.DefaultUp);
    this.updateMatrix();
    this.target = new U;
    Object.defineProperty(this, "power", {get:function() {
      return this.intensity * Math.PI;
    }, set:function(d) {
      this.intensity = d / Math.PI;
    }});
    this.distance = void 0 !== a ? a : 0;
    this.angle = void 0 !== b ? b : Math.PI / 3;
    this.penumbra = void 0 !== c ? c : 0;
    this.decay = void 0 !== e ? e : 1;
    this.shadow = new Fd;
  }
  function Hd(d, m, a, b) {
    Ca.call(this, d, m);
    this.type = "PointLight";
    Object.defineProperty(this, "power", {get:function() {
      return 4 * this.intensity * Math.PI;
    }, set:function(d) {
      this.intensity = d / (4 * Math.PI);
    }});
    this.distance = void 0 !== a ? a : 0;
    this.decay = void 0 !== b ? b : 1;
    this.shadow = new Qb(new Oa(90, 1, .5, 500));
  }
  function Id() {
    Qb.call(this, new Zb(-5, 5, 5, -5, .5, 500));
  }
  function Jd(d, m) {
    Ca.call(this, d, m);
    this.type = "DirectionalLight";
    this.position.copy(U.DefaultUp);
    this.updateMatrix();
    this.target = new U;
    this.shadow = new Id;
  }
  function Kd(d, m) {
    Ca.call(this, d, m);
    this.type = "AmbientLight";
    this.castShadow = void 0;
  }
  function Ld(d, m, a, b) {
    Ca.call(this, d, m);
    this.type = "RectAreaLight";
    this.position.set(0, 1, 0);
    this.updateMatrix();
    this.width = void 0 !== a ? a : 10;
    this.height = void 0 !== b ? b : 10;
  }
  function Za(d, m, a, b) {
    this.parameterPositions = d;
    this._cachedIndex = 0;
    this.resultBuffer = void 0 !== b ? b : new m.constructor(a);
    this.sampleValues = m;
    this.valueSize = a;
  }
  function Md(d, m, a, b) {
    Za.call(this, d, m, a, b);
    this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0;
  }
  function id(d, m, a, b) {
    Za.call(this, d, m, a, b);
  }
  function Nd(d, m, a, b) {
    Za.call(this, d, m, a, b);
  }
  function Rb(d, m, a, b) {
    if (void 0 === d) {
      throw Error("track name is undefined");
    }
    if (void 0 === m || 0 === m.length) {
      throw Error("no keyframes in track named " + d);
    }
    this.name = d;
    this.times = Fa.convertArray(m, this.TimeBufferType);
    this.values = Fa.convertArray(a, this.ValueBufferType);
    this.setInterpolation(b || this.DefaultInterpolation);
    this.validate();
    this.optimize();
  }
  function uc(d, m, a, b) {
    Rb.call(this, d, m, a, b);
  }
  function Od(d, m, a, b) {
    Za.call(this, d, m, a, b);
  }
  function jd(d, m, a, b) {
    Rb.call(this, d, m, a, b);
  }
  function vc(d, m, a, b) {
    Rb.call(this, d, m, a, b);
  }
  function Pd(d, m, a, b) {
    Rb.call(this, d, m, a, b);
  }
  function Qd(d, m, a) {
    Rb.call(this, d, m, a);
  }
  function Rd(d, m, a, b) {
    Rb.call(this, d, m, a, b);
  }
  function Sb(d, m, a, b) {
    Rb.apply(this, arguments);
  }
  function cb(d, m, a) {
    this.name = d;
    this.tracks = a;
    this.duration = void 0 !== m ? m : -1;
    this.uuid = ka.generateUUID();
    0 > this.duration && this.resetDuration();
    this.optimize();
  }
  function Sd(d) {
    this.manager = void 0 !== d ? d : Ya;
    this.textures = {};
  }
  function ie(d) {
    this.manager = void 0 !== d ? d : Ya;
  }
  function wc() {
    this.onLoadStart = function() {
    };
    this.onLoadProgress = function() {
    };
    this.onLoadComplete = function() {
    };
  }
  function je(d) {
    "boolean" === typeof d && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), d = void 0);
    this.manager = void 0 !== d ? d : Ya;
    this.withCredentials = !1;
  }
  function Je(d) {
    this.manager = void 0 !== d ? d : Ya;
    this.texturePath = "";
  }
  function Ke(d, m, a, b, c) {
    m = .5 * (b - m);
    c = .5 * (c - a);
    var e = d * d;
    return (2 * a - 2 * b + m + c) * d * e + (-3 * a + 3 * b - 2 * m - c) * e + m * d + a;
  }
  function Tb(d, m, a, b) {
    var c = 1 - d;
    return c * c * m + 2 * (1 - d) * d * a + d * d * b;
  }
  function Ub(d, m, a, b, c) {
    var e = 1 - d, A = 1 - d;
    return e * e * e * m + 3 * A * A * d * a + 3 * (1 - d) * d * d * b + d * d * d * c;
  }
  function Ra() {
  }
  function sb(d, m) {
    this.v1 = d;
    this.v2 = m;
  }
  function kd() {
    this.curves = [];
    this.autoClose = !1;
  }
  function xb(d, m, a, b, c, e, g, f) {
    this.aX = d;
    this.aY = m;
    this.xRadius = a;
    this.yRadius = b;
    this.aStartAngle = c;
    this.aEndAngle = e;
    this.aClockwise = g;
    this.aRotation = f || 0;
  }
  function Vb(d) {
    this.points = void 0 === d ? [] : d;
  }
  function xc(d, a, b, c) {
    this.v0 = d;
    this.v1 = a;
    this.v2 = b;
    this.v3 = c;
  }
  function yc(d, a, b) {
    this.v0 = d;
    this.v1 = a;
    this.v2 = b;
  }
  function ld(d) {
    kd.call(this);
    this.currentPoint = new l;
    d && this.fromPoints(d);
  }
  function Wb() {
    ld.apply(this, arguments);
    this.holes = [];
  }
  function ke() {
    this.subPaths = [];
    this.currentPath = null;
  }
  function le(d) {
    this.data = d;
  }
  function Le(d) {
    this.manager = void 0 !== d ? d : Ya;
  }
  function me(d) {
    this.manager = void 0 !== d ? d : Ya;
  }
  function Me() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = .064;
    this.cameraL = new Oa;
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = !1;
    this.cameraR = new Oa;
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = !1;
  }
  function Td(d, a, b) {
    U.call(this);
    this.type = "CubeCamera";
    var m = new Oa(90, 1, d, a);
    m.up.set(0, -1, 0);
    m.lookAt(new e(1, 0, 0));
    this.add(m);
    var A = new Oa(90, 1, d, a);
    A.up.set(0, -1, 0);
    A.lookAt(new e(-1, 0, 0));
    this.add(A);
    var g = new Oa(90, 1, d, a);
    g.up.set(0, 0, 1);
    g.lookAt(new e(0, 1, 0));
    this.add(g);
    var f = new Oa(90, 1, d, a);
    f.up.set(0, 0, -1);
    f.lookAt(new e(0, -1, 0));
    this.add(f);
    var k = new Oa(90, 1, d, a);
    k.up.set(0, -1, 0);
    k.lookAt(new e(0, 0, 1));
    this.add(k);
    var q = new Oa(90, 1, d, a);
    q.up.set(0, -1, 0);
    q.lookAt(new e(0, 0, -1));
    this.add(q);
    this.renderTarget = new c(b, b, {format:1022, magFilter:1006, minFilter:1006});
    this.renderTarget.texture.name = "CubeCamera";
    this.updateCubeMap = function(d, a) {
      null === this.parent && this.updateMatrixWorld();
      var b = this.renderTarget, c = b.texture.generateMipmaps;
      b.texture.generateMipmaps = !1;
      b.activeCubeFace = 0;
      d.render(a, m, b);
      b.activeCubeFace = 1;
      d.render(a, A, b);
      b.activeCubeFace = 2;
      d.render(a, g, b);
      b.activeCubeFace = 3;
      d.render(a, f, b);
      b.activeCubeFace = 4;
      d.render(a, k, b);
      b.texture.generateMipmaps = c;
      b.activeCubeFace = 5;
      d.render(a, q, b);
      d.setRenderTarget(null);
    };
  }
  function ne() {
    U.call(this);
    this.type = "AudioListener";
    this.context = oe.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
  }
  function zc(d) {
    U.call(this);
    this.type = "Audio";
    this.context = d.context;
    this.gain = this.context.createGain();
    this.gain.connect(d.getInput());
    this.autoplay = !1;
    this.buffer = null;
    this.loop = !1;
    this.startTime = 0;
    this.playbackRate = 1;
    this.isPlaying = !1;
    this.hasPlaybackControl = !0;
    this.sourceType = "empty";
    this.filters = [];
  }
  function pe(d) {
    zc.call(this, d);
    this.panner = this.context.createPanner();
    this.panner.connect(this.gain);
  }
  function qe(d, a) {
    this.analyser = d.context.createAnalyser();
    this.analyser.fftSize = void 0 !== a ? a : 2048;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    d.getOutput().connect(this.analyser);
  }
  function re(d, a, b) {
    this.binding = d;
    this.valueSize = b;
    d = Float64Array;
    switch(a) {
      case "quaternion":
        a = this._slerp;
        break;
      case "string":
      case "bool":
        d = Array;
        a = this._select;
        break;
      default:
        a = this._lerp;
    }
    this.buffer = new d(4 * b);
    this._mixBufferRegion = a;
    this.referenceCount = this.useCount = this.cumulativeWeight = 0;
  }
  function Ne(d, a, b) {
    b = b || Da.parseTrackName(a);
    this._targetGroup = d;
    this._bindings = d.subscribe_(a, b);
  }
  function Da(d, a, b) {
    this.path = a;
    this.parsedPath = b || Da.parseTrackName(a);
    this.node = Da.findNode(d, this.parsedPath.nodeName) || d;
    this.rootNode = d;
  }
  function Oe(d) {
    this.uuid = ka.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    var a = {};
    this._indicesByUUID = a;
    for (var b = 0, c = arguments.length;b !== c;++b) {
      a[arguments[b].uuid] = b;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    var e = this;
    this.stats = {objects:{get total() {
      return e._objects.length;
    }, get inUse() {
      return this.total - e.nCachedObjects_;
    }}, get bindingsPerObject() {
      return e._bindings.length;
    }};
  }
  function Pe(d, a, b) {
    this._mixer = d;
    this._clip = a;
    this._localRoot = b || null;
    d = a.tracks;
    a = d.length;
    b = Array(a);
    for (var m = {endingStart:2400, endingEnd:2400}, c = 0;c !== a;++c) {
      var e = d[c].createInterpolant(null);
      b[c] = e;
      e.settings = m;
    }
    this._interpolantSettings = m;
    this._interpolants = b;
    this._propertyBindings = Array(a);
    this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null;
    this.loop = 2201;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1;
    this.repetitions = Infinity;
    this.paused = !1;
    this.enabled = !0;
    this.clampWhenFinished = !1;
    this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
  }
  function Qe(d) {
    this._root = d;
    this._initMemoryManager();
    this.time = this._accuIndex = 0;
    this.timeScale = 1;
  }
  function Ud(d, a) {
    "string" === typeof d && (console.warn("THREE.Uniform: Type parameter is no longer needed."), d = a);
    this.value = d;
  }
  function Xb() {
    da.call(this);
    this.type = "InstancedBufferGeometry";
    this.maxInstancedCount = void 0;
  }
  function se(d, a, b, c) {
    this.uuid = ka.generateUUID();
    this.data = d;
    this.itemSize = a;
    this.offset = b;
    this.normalized = !0 === c;
  }
  function Ac(d, a) {
    this.uuid = ka.generateUUID();
    this.array = d;
    this.stride = a;
    this.count = void 0 !== d ? d.length / a : 0;
    this.dynamic = !1;
    this.updateRange = {offset:0, count:-1};
    this.onUploadCallback = function() {
    };
    this.version = 0;
  }
  function Bc(d, a, b) {
    Ac.call(this, d, a);
    this.meshPerAttribute = b || 1;
  }
  function Cc(d, a, b) {
    ja.call(this, d, a);
    this.meshPerAttribute = b || 1;
  }
  function Re(d, a, b, c) {
    this.ray = new Ta(d, a);
    this.near = b || 0;
    this.far = c || Infinity;
    this.params = {Mesh:{}, Line:{}, LOD:{}, Points:{threshold:1}, Sprite:{}};
    Object.defineProperties(this.params, {PointCloud:{get:function() {
      console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
      return this.Points;
    }}});
  }
  function Se(d, a) {
    return d.distance - a.distance;
  }
  function te(d, a, b, c) {
    if (!1 !== d.visible && (d.raycast(a, b), !0 === c)) {
      d = d.children;
      c = 0;
      for (var m = d.length;c < m;c++) {
        te(d[c], a, b, !0);
      }
    }
  }
  function Te(d) {
    this.autoStart = void 0 !== d ? d : !0;
    this.elapsedTime = this.oldTime = this.startTime = 0;
    this.running = !1;
  }
  function Ue(d, a, b) {
    this.radius = void 0 !== d ? d : 1;
    this.phi = void 0 !== a ? a : 0;
    this.theta = void 0 !== b ? b : 0;
    return this;
  }
  function Ve(d, a, b) {
    this.radius = void 0 !== d ? d : 1;
    this.theta = void 0 !== a ? a : 0;
    this.y = void 0 !== b ? b : 0;
    return this;
  }
  function Ha(d, a) {
    Ga.call(this, d, a);
    this.animationsMap = {};
    this.animationsList = [];
    d = this.geometry.morphTargets.length;
    this.createAnimation("__default", 0, d - 1, d / 1);
    this.setAnimationWeight("__default", 1);
  }
  function md(d) {
    U.call(this);
    this.material = d;
    this.render = function(d) {
    };
  }
  function nd(d, a, b, c) {
    this.object = d;
    this.size = void 0 !== a ? a : 1;
    d = void 0 !== b ? b : 16711680;
    c = void 0 !== c ? c : 1;
    a = 0;
    (b = this.object.geometry) && b.isGeometry ? a = 3 * b.faces.length : b && b.isBufferGeometry && (a = b.attributes.normal.count);
    b = new da;
    a = new Y(6 * a, 3);
    b.addAttribute("position", a);
    ua.call(this, b, new wa({color:d, linewidth:c}));
    this.matrixAutoUpdate = !1;
    this.update();
  }
  function Dc(d) {
    U.call(this);
    this.light = d;
    this.light.updateMatrixWorld();
    this.matrix = d.matrixWorld;
    this.matrixAutoUpdate = !1;
    d = new da;
    for (var a = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], b = 0, c = 1;32 > b;b++, c++) {
      var e = b / 32 * Math.PI * 2, g = c / 32 * Math.PI * 2;
      a.push(Math.cos(e), Math.sin(e), 1, Math.cos(g), Math.sin(g), 1);
    }
    d.addAttribute("position", new Y(a, 3));
    a = new wa({fog:!1});
    this.cone = new ua(d, a);
    this.add(this.cone);
    this.update();
  }
  function Ec(d) {
    this.bones = this.getBoneList(d);
    for (var a = new da, b = [], c = [], e = new T(0, 0, 1), g = new T(0, 1, 0), f = 0;f < this.bones.length;f++) {
      var k = this.bones[f];
      k.parent && k.parent.isBone && (b.push(0, 0, 0), b.push(0, 0, 0), c.push(e.r, e.g, e.b), c.push(g.r, g.g, g.b));
    }
    a.addAttribute("position", new Y(b, 3));
    a.addAttribute("color", new Y(c, 3));
    b = new wa({vertexColors:2, depthTest:!1, depthWrite:!1, transparent:!0});
    ua.call(this, a, b);
    this.root = d;
    this.matrix = d.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.update();
  }
  function Fc(d, a) {
    this.light = d;
    this.light.updateMatrixWorld();
    d = new Jb(a, 4, 2);
    a = new Ka({wireframe:!0, fog:!1});
    a.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    Ga.call(this, d, a);
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = !1;
  }
  function Gc(d) {
    U.call(this);
    this.light = d;
    this.light.updateMatrixWorld();
    var a = new Ka({color:d.color, fog:!1});
    d = new Ka({color:d.color, fog:!1, wireframe:!0});
    var b = new da;
    b.addAttribute("position", new ja(new Float32Array(18), 3));
    this.add(new Ga(b, a));
    this.add(new Ga(b, d));
    this.update();
  }
  function Hc(d, a) {
    U.call(this);
    this.light = d;
    this.light.updateMatrixWorld();
    this.matrix = d.matrixWorld;
    this.matrixAutoUpdate = !1;
    d = new Ib(a);
    d.rotateY(.5 * Math.PI);
    a = new Ka({vertexColors:2, wireframe:!0});
    var m = d.getAttribute("position"), m = new Float32Array(3 * m.count);
    d.addAttribute("color", new ja(m, 3));
    this.add(new Ga(d, a));
    this.update();
  }
  function od(d, a, b, c) {
    d = d || 10;
    a = a || 10;
    b = new T(void 0 !== b ? b : 4473924);
    c = new T(void 0 !== c ? c : 8947848);
    var m = a / 2, e = d / a, g = d / 2;
    d = [];
    for (var A = [], f = 0, k = 0, q = -g;f <= a;f++, q += e) {
      d.push(-g, 0, q, g, 0, q);
      d.push(q, 0, -g, q, 0, g);
      var p = f === m ? b : c;
      p.toArray(A, k);
      k += 3;
      p.toArray(A, k);
      k += 3;
      p.toArray(A, k);
      k += 3;
      p.toArray(A, k);
      k += 3;
    }
    a = new da;
    a.addAttribute("position", new Y(d, 3));
    a.addAttribute("color", new Y(A, 3));
    b = new wa({vertexColors:2});
    ua.call(this, a, b);
  }
  function Vd(d, a, b, c, e, g) {
    d = d || 10;
    a = a || 16;
    b = b || 8;
    c = c || 64;
    e = new T(void 0 !== e ? e : 4473924);
    g = new T(void 0 !== g ? g : 8947848);
    var m = [], A = [], k, f, q, p, h;
    for (q = 0;q <= a;q++) {
      f = q / a * 2 * Math.PI, k = Math.sin(f) * d, f = Math.cos(f) * d, m.push(0, 0, 0), m.push(k, 0, f), h = q & 1 ? e : g, A.push(h.r, h.g, h.b), A.push(h.r, h.g, h.b);
    }
    for (q = 0;q <= b;q++) {
      for (h = q & 1 ? e : g, p = d - d / b * q, a = 0;a < c;a++) {
        f = a / c * 2 * Math.PI, k = Math.sin(f) * p, f = Math.cos(f) * p, m.push(k, 0, f), A.push(h.r, h.g, h.b), f = (a + 1) / c * 2 * Math.PI, k = Math.sin(f) * p, f = Math.cos(f) * p, m.push(k, 0, f), A.push(h.r, h.g, h.b);
      }
    }
    d = new da;
    d.addAttribute("position", new Y(m, 3));
    d.addAttribute("color", new Y(A, 3));
    m = new wa({vertexColors:2});
    ua.call(this, d, m);
  }
  function pd(d, a, b, c) {
    this.object = d;
    this.size = void 0 !== a ? a : 1;
    d = void 0 !== b ? b : 16776960;
    c = void 0 !== c ? c : 1;
    a = 0;
    (b = this.object.geometry) && b.isGeometry ? a = b.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
    b = new da;
    a = new Y(6 * a, 3);
    b.addAttribute("position", a);
    ua.call(this, b, new wa({color:d, linewidth:c}));
    this.matrixAutoUpdate = !1;
    this.update();
  }
  function Ic(d, a) {
    U.call(this);
    this.light = d;
    this.light.updateMatrixWorld();
    this.matrix = d.matrixWorld;
    this.matrixAutoUpdate = !1;
    void 0 === a && (a = 1);
    d = new da;
    d.addAttribute("position", new Y([-a, a, 0, a, a, 0, a, -a, 0, -a, -a, 0, -a, a, 0], 3));
    a = new wa({fog:!1});
    this.add(new db(d, a));
    d = new da;
    d.addAttribute("position", new Y([0, 0, 0, 0, 0, 1], 3));
    this.add(new db(d, a));
    this.update();
  }
  function qd(d) {
    function a(d, a, m) {
      b(d, m);
      b(a, m);
    }
    function b(d, a) {
      g.push(0, 0, 0);
      f.push(a.r, a.g, a.b);
      void 0 === k[d] && (k[d] = []);
      k[d].push(g.length / 3 - 1);
    }
    var c = new da, e = new wa({color:16777215, vertexColors:1}), g = [], f = [], k = {}, q = new T(16755200), p = new T(16711680), h = new T(43775), n = new T(16777215), r = new T(3355443);
    a("n1", "n2", q);
    a("n2", "n4", q);
    a("n4", "n3", q);
    a("n3", "n1", q);
    a("f1", "f2", q);
    a("f2", "f4", q);
    a("f4", "f3", q);
    a("f3", "f1", q);
    a("n1", "f1", q);
    a("n2", "f2", q);
    a("n3", "f3", q);
    a("n4", "f4", q);
    a("p", "n1", p);
    a("p", "n2", p);
    a("p", "n3", p);
    a("p", "n4", p);
    a("u1", "u2", h);
    a("u2", "u3", h);
    a("u3", "u1", h);
    a("c", "t", n);
    a("p", "c", r);
    a("cn1", "cn2", r);
    a("cn3", "cn4", r);
    a("cf1", "cf2", r);
    a("cf3", "cf4", r);
    c.addAttribute("position", new Y(g, 3));
    c.addAttribute("color", new Y(f, 3));
    ua.call(this, c, e);
    this.camera = d;
    this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix();
    this.matrix = d.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.pointMap = k;
    this.update();
  }
  function Jc(d, a) {
    void 0 === a && (a = 16776960);
    var m = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), b = new Float32Array(24), c = new da;
    c.setIndex(new ja(m, 1));
    c.addAttribute("position", new ja(b, 3));
    ua.call(this, c, new wa({color:a}));
    void 0 !== d && this.update(d);
  }
  function Yb(d, a, b, c, e, g) {
    U.call(this);
    void 0 === c && (c = 16776960);
    void 0 === b && (b = 1);
    void 0 === e && (e = .2 * b);
    void 0 === g && (g = .2 * e);
    void 0 === Wd && (Wd = new da, Wd.addAttribute("position", new Y([0, 0, 0, 0, 1, 0], 3)), ue = new wb(0, .5, 1, 5, 1), ue.translate(0, -.5, 0));
    this.position.copy(a);
    this.line = new db(Wd, new wa({color:c}));
    this.line.matrixAutoUpdate = !1;
    this.add(this.line);
    this.cone = new Ga(ue, new Ka({color:c}));
    this.cone.matrixAutoUpdate = !1;
    this.add(this.cone);
    this.setDirection(d);
    this.setLength(b, e, g);
  }
  function Xd(d) {
    d = d || 1;
    var a = [0, 0, 0, d, 0, 0, 0, 0, 0, 0, d, 0, 0, 0, 0, 0, 0, d];
    d = new da;
    d.addAttribute("position", new Y(a, 3));
    d.addAttribute("color", new Y([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
    a = new wa({vertexColors:2});
    ua.call(this, d, a);
  }
  function ve() {
    var d = 0, a = 0, b = 0, c = 0;
    return {initCatmullRom:function(m, e, g, A, f) {
      m = f * (g - m);
      A = f * (A - e);
      d = e;
      a = m;
      b = -3 * e + 3 * g - 2 * m - A;
      c = 2 * e - 2 * g + m + A;
    }, initNonuniformCatmullRom:function(m, e, g, A, f, k, q) {
      m = ((e - m) / f - (g - m) / (f + k) + (g - e) / k) * k;
      A = ((g - e) / k - (A - e) / (k + q) + (A - g) / q) * k;
      d = e;
      a = m;
      b = -3 * e + 3 * g - 2 * m - A;
      c = 2 * e - 2 * g + m + A;
    }, calc:function(m) {
      var e = m * m;
      return d + a * m + b * e + c * e * m;
    }};
  }
  function ib(d) {
    this.points = d || [];
    this.closed = !1;
  }
  function rd(d, a, b, c) {
    this.v0 = d;
    this.v1 = a;
    this.v2 = b;
    this.v3 = c;
  }
  function sd(d, a, b) {
    this.v0 = d;
    this.v1 = a;
    this.v2 = b;
  }
  function td(d, a) {
    this.v1 = d;
    this.v2 = a;
  }
  function Yd(d, a, b, c, e, g) {
    xb.call(this, d, a, b, b, c, e, g);
  }
  function We(d) {
    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    ib.call(this, d);
    this.type = "catmullrom";
    this.closed = !0;
  }
  function Xe(d) {
    console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    ib.call(this, d);
    this.type = "catmullrom";
  }
  function we(d) {
    console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
    ib.call(this, d);
    this.type = "catmullrom";
  }
  void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52));
  void 0 === Math.sign && (Math.sign = function(d) {
    return 0 > d ? -1 : 0 < d ? 1 : +d;
  });
  void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {get:function() {
    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
  }});
  void 0 === Object.assign && function() {
    Object.assign = function(d) {
      if (void 0 === d || null === d) {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      for (var a = Object(d), b = 1;b < arguments.length;b++) {
        var c = arguments[b];
        if (void 0 !== c && null !== c) {
          for (var e in c) {
            Object.prototype.hasOwnProperty.call(c, e) && (a[e] = c[e]);
          }
        }
      }
      return a;
    };
  }();
  Object.assign(h.prototype, {addEventListener:function(d, a) {
    void 0 === this._listeners && (this._listeners = {});
    var m = this._listeners;
    void 0 === m[d] && (m[d] = []);
    -1 === m[d].indexOf(a) && m[d].push(a);
  }, hasEventListener:function(d, a) {
    if (void 0 === this._listeners) {
      return !1;
    }
    var m = this._listeners;
    return void 0 !== m[d] && -1 !== m[d].indexOf(a);
  }, removeEventListener:function(d, a) {
    void 0 !== this._listeners && (d = this._listeners[d], void 0 !== d && (a = d.indexOf(a), -1 !== a && d.splice(a, 1)));
  }, dispatchEvent:function(d) {
    if (void 0 !== this._listeners) {
      var a = this._listeners[d.type];
      if (void 0 !== a) {
        d.target = this;
        var b = [], c, e = a.length;
        for (c = 0;c < e;c++) {
          b[c] = a[c];
        }
        for (c = 0;c < e;c++) {
          b[c].call(this, d);
        }
      }
    }
  }});
  var ka = {DEG2RAD:Math.PI / 180, RAD2DEG:180 / Math.PI, generateUUID:function() {
    var d = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), a = Array(36), b = 0, c;
    return function() {
      for (var m = 0;36 > m;m++) {
        8 === m || 13 === m || 18 === m || 23 === m ? a[m] = "-" : 14 === m ? a[m] = "4" : (2 >= b && (b = 33554432 + 16777216 * Math.random() | 0), c = b & 15, b >>= 4, a[m] = d[19 === m ? c & 3 | 8 : c]);
      }
      return a.join("");
    };
  }(), clamp:function(d, a, b) {
    return Math.max(a, Math.min(b, d));
  }, euclideanModulo:function(d, a) {
    return (d % a + a) % a;
  }, mapLinear:function(d, a, b, c, e) {
    return c + (d - a) * (e - c) / (b - a);
  }, lerp:function(d, a, b) {
    return (1 - b) * d + b * a;
  }, smoothstep:function(d, a, b) {
    if (d <= a) {
      return 0;
    }
    if (d >= b) {
      return 1;
    }
    d = (d - a) / (b - a);
    return d * d * (3 - 2 * d);
  }, smootherstep:function(d, a, b) {
    if (d <= a) {
      return 0;
    }
    if (d >= b) {
      return 1;
    }
    d = (d - a) / (b - a);
    return d * d * d * (d * (6 * d - 15) + 10);
  }, randInt:function(d, a) {
    return d + Math.floor(Math.random() * (a - d + 1));
  }, randFloat:function(d, a) {
    return d + Math.random() * (a - d);
  }, randFloatSpread:function(d) {
    return d * (.5 - Math.random());
  }, degToRad:function(d) {
    return d * ka.DEG2RAD;
  }, radToDeg:function(d) {
    return d * ka.RAD2DEG;
  }, isPowerOfTwo:function(d) {
    return 0 === (d & d - 1) && 0 !== d;
  }, nearestPowerOfTwo:function(d) {
    return Math.pow(2, Math.round(Math.log(d) / Math.LN2));
  }, nextPowerOfTwo:function(d) {
    d--;
    d |= d >> 1;
    d |= d >> 2;
    d |= d >> 4;
    d |= d >> 8;
    d |= d >> 16;
    d++;
    return d;
  }};
  Object.defineProperties(l.prototype, {width:{get:function() {
    return this.x;
  }, set:function(d) {
    this.x = d;
  }}, height:{get:function() {
    return this.y;
  }, set:function(d) {
    this.y = d;
  }}});
  Object.assign(l.prototype, {isVector2:!0, set:function(d, a) {
    this.x = d;
    this.y = a;
    return this;
  }, setScalar:function(d) {
    this.y = this.x = d;
    return this;
  }, setX:function(d) {
    this.x = d;
    return this;
  }, setY:function(d) {
    this.y = d;
    return this;
  }, setComponent:function(d, a) {
    switch(d) {
      case 0:
        this.x = a;
        break;
      case 1:
        this.y = a;
        break;
      default:
        throw Error("index is out of range: " + d);
    }
    return this;
  }, getComponent:function(d) {
    switch(d) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw Error("index is out of range: " + d);
    }
  }, clone:function() {
    return new this.constructor(this.x, this.y);
  }, copy:function(d) {
    this.x = d.x;
    this.y = d.y;
    return this;
  }, add:function(d, a) {
    if (void 0 !== a) {
      return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(d, a);
    }
    this.x += d.x;
    this.y += d.y;
    return this;
  }, addScalar:function(d) {
    this.x += d;
    this.y += d;
    return this;
  }, addVectors:function(d, a) {
    this.x = d.x + a.x;
    this.y = d.y + a.y;
    return this;
  }, addScaledVector:function(d, a) {
    this.x += d.x * a;
    this.y += d.y * a;
    return this;
  }, sub:function(d, a) {
    if (void 0 !== a) {
      return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(d, a);
    }
    this.x -= d.x;
    this.y -= d.y;
    return this;
  }, subScalar:function(d) {
    this.x -= d;
    this.y -= d;
    return this;
  }, subVectors:function(d, a) {
    this.x = d.x - a.x;
    this.y = d.y - a.y;
    return this;
  }, multiply:function(d) {
    this.x *= d.x;
    this.y *= d.y;
    return this;
  }, multiplyScalar:function(d) {
    this.x *= d;
    this.y *= d;
    return this;
  }, divide:function(d) {
    this.x /= d.x;
    this.y /= d.y;
    return this;
  }, divideScalar:function(d) {
    return this.multiplyScalar(1 / d);
  }, min:function(d) {
    this.x = Math.min(this.x, d.x);
    this.y = Math.min(this.y, d.y);
    return this;
  }, max:function(d) {
    this.x = Math.max(this.x, d.x);
    this.y = Math.max(this.y, d.y);
    return this;
  }, clamp:function(d, a) {
    this.x = Math.max(d.x, Math.min(a.x, this.x));
    this.y = Math.max(d.y, Math.min(a.y, this.y));
    return this;
  }, clampScalar:function() {
    var d = new l, a = new l;
    return function(m, b) {
      d.set(m, m);
      a.set(b, b);
      return this.clamp(d, a);
    };
  }(), clampLength:function(d, a) {
    var m = this.length();
    return this.multiplyScalar(Math.max(d, Math.min(a, m)) / m);
  }, floor:function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }, ceil:function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }, round:function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }, roundToZero:function() {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }, negate:function() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }, dot:function(d) {
    return this.x * d.x + this.y * d.y;
  }, lengthSq:function() {
    return this.x * this.x + this.y * this.y;
  }, length:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, lengthManhattan:function() {
    return Math.abs(this.x) + Math.abs(this.y);
  }, normalize:function() {
    return this.divideScalar(this.length());
  }, angle:function() {
    var d = Math.atan2(this.y, this.x);
    0 > d && (d += 2 * Math.PI);
    return d;
  }, distanceTo:function(d) {
    return Math.sqrt(this.distanceToSquared(d));
  }, distanceToSquared:function(d) {
    var a = this.x - d.x;
    d = this.y - d.y;
    return a * a + d * d;
  }, distanceToManhattan:function(d) {
    return Math.abs(this.x - d.x) + Math.abs(this.y - d.y);
  }, setLength:function(d) {
    return this.multiplyScalar(d / this.length());
  }, lerp:function(d, a) {
    this.x += (d.x - this.x) * a;
    this.y += (d.y - this.y) * a;
    return this;
  }, lerpVectors:function(d, a, b) {
    return this.subVectors(a, d).multiplyScalar(b).add(d);
  }, equals:function(d) {
    return d.x === this.x && d.y === this.y;
  }, fromArray:function(d, a) {
    void 0 === a && (a = 0);
    this.x = d[a];
    this.y = d[a + 1];
    return this;
  }, toArray:function(d, a) {
    void 0 === d && (d = []);
    void 0 === a && (a = 0);
    d[a] = this.x;
    d[a + 1] = this.y;
    return d;
  }, fromBufferAttribute:function(d, a, b) {
    void 0 !== b && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    this.x = d.getX(a);
    this.y = d.getY(a);
    return this;
  }, rotateAround:function(d, a) {
    var m = Math.cos(a);
    a = Math.sin(a);
    var b = this.x - d.x, c = this.y - d.y;
    this.x = b * m - c * a + d.x;
    this.y = b * a + c * m + d.y;
    return this;
  }});
  var Ye = 0;
  b.DEFAULT_IMAGE = void 0;
  b.DEFAULT_MAPPING = 300;
  Object.defineProperty(b.prototype, "needsUpdate", {set:function(d) {
    !0 === d && this.version++;
  }});
  Object.assign(b.prototype, h.prototype, {constructor:b, isTexture:!0, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(d) {
    this.name = d.name;
    this.image = d.image;
    this.mipmaps = d.mipmaps.slice(0);
    this.mapping = d.mapping;
    this.wrapS = d.wrapS;
    this.wrapT = d.wrapT;
    this.magFilter = d.magFilter;
    this.minFilter = d.minFilter;
    this.anisotropy = d.anisotropy;
    this.format = d.format;
    this.type = d.type;
    this.offset.copy(d.offset);
    this.repeat.copy(d.repeat);
    this.generateMipmaps = d.generateMipmaps;
    this.premultiplyAlpha = d.premultiplyAlpha;
    this.flipY = d.flipY;
    this.unpackAlignment = d.unpackAlignment;
    this.encoding = d.encoding;
    return this;
  }, toJSON:function(d) {
    if (void 0 !== d.textures[this.uuid]) {
      return d.textures[this.uuid];
    }
    var a = {metadata:{version:4.4, type:"Texture", generator:"Texture.toJSON"}, uuid:this.uuid, name:this.name, mapping:this.mapping, repeat:[this.repeat.x, this.repeat.y], offset:[this.offset.x, this.offset.y], wrap:[this.wrapS, this.wrapT], minFilter:this.minFilter, magFilter:this.magFilter, anisotropy:this.anisotropy, flipY:this.flipY};
    if (void 0 !== this.image) {
      var b = this.image;
      void 0 === b.uuid && (b.uuid = ka.generateUUID());
      if (void 0 === d.images[b.uuid]) {
        var c = d.images, e = b.uuid, g = b.uuid, f;
        void 0 !== b.toDataURL ? f = b : (f = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), f.width = b.width, f.height = b.height, f.getContext("2d").drawImage(b, 0, 0, b.width, b.height));
        f = 2048 < f.width || 2048 < f.height ? f.toDataURL("image/jpeg", .6) : f.toDataURL("image/png");
        c[e] = {uuid:g, url:f};
      }
      a.image = b.uuid;
    }
    return d.textures[this.uuid] = a;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }, transformUv:function(d) {
    if (300 === this.mapping) {
      d.multiply(this.repeat);
      d.add(this.offset);
      if (0 > d.x || 1 < d.x) {
        switch(this.wrapS) {
          case 1E3:
            d.x -= Math.floor(d.x);
            break;
          case 1001:
            d.x = 0 > d.x ? 0 : 1;
            break;
          case 1002:
            d.x = 1 === Math.abs(Math.floor(d.x) % 2) ? Math.ceil(d.x) - d.x : d.x - Math.floor(d.x);
        }
      }
      if (0 > d.y || 1 < d.y) {
        switch(this.wrapT) {
          case 1E3:
            d.y -= Math.floor(d.y);
            break;
          case 1001:
            d.y = 0 > d.y ? 0 : 1;
            break;
          case 1002:
            d.y = 1 === Math.abs(Math.floor(d.y) % 2) ? Math.ceil(d.y) - d.y : d.y - Math.floor(d.y);
        }
      }
      this.flipY && (d.y = 1 - d.y);
    }
  }});
  Object.assign(f.prototype, {isVector4:!0, set:function(d, a, b, c) {
    this.x = d;
    this.y = a;
    this.z = b;
    this.w = c;
    return this;
  }, setScalar:function(d) {
    this.w = this.z = this.y = this.x = d;
    return this;
  }, setX:function(d) {
    this.x = d;
    return this;
  }, setY:function(d) {
    this.y = d;
    return this;
  }, setZ:function(d) {
    this.z = d;
    return this;
  }, setW:function(d) {
    this.w = d;
    return this;
  }, setComponent:function(d, a) {
    switch(d) {
      case 0:
        this.x = a;
        break;
      case 1:
        this.y = a;
        break;
      case 2:
        this.z = a;
        break;
      case 3:
        this.w = a;
        break;
      default:
        throw Error("index is out of range: " + d);
    }
    return this;
  }, getComponent:function(d) {
    switch(d) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw Error("index is out of range: " + d);
    }
  }, clone:function() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }, copy:function(d) {
    this.x = d.x;
    this.y = d.y;
    this.z = d.z;
    this.w = void 0 !== d.w ? d.w : 1;
    return this;
  }, add:function(d, a) {
    if (void 0 !== a) {
      return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(d, a);
    }
    this.x += d.x;
    this.y += d.y;
    this.z += d.z;
    this.w += d.w;
    return this;
  }, addScalar:function(d) {
    this.x += d;
    this.y += d;
    this.z += d;
    this.w += d;
    return this;
  }, addVectors:function(d, a) {
    this.x = d.x + a.x;
    this.y = d.y + a.y;
    this.z = d.z + a.z;
    this.w = d.w + a.w;
    return this;
  }, addScaledVector:function(d, a) {
    this.x += d.x * a;
    this.y += d.y * a;
    this.z += d.z * a;
    this.w += d.w * a;
    return this;
  }, sub:function(d, a) {
    if (void 0 !== a) {
      return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(d, a);
    }
    this.x -= d.x;
    this.y -= d.y;
    this.z -= d.z;
    this.w -= d.w;
    return this;
  }, subScalar:function(d) {
    this.x -= d;
    this.y -= d;
    this.z -= d;
    this.w -= d;
    return this;
  }, subVectors:function(d, a) {
    this.x = d.x - a.x;
    this.y = d.y - a.y;
    this.z = d.z - a.z;
    this.w = d.w - a.w;
    return this;
  }, multiplyScalar:function(d) {
    this.x *= d;
    this.y *= d;
    this.z *= d;
    this.w *= d;
    return this;
  }, applyMatrix4:function(d) {
    var a = this.x, b = this.y, c = this.z, e = this.w;
    d = d.elements;
    this.x = d[0] * a + d[4] * b + d[8] * c + d[12] * e;
    this.y = d[1] * a + d[5] * b + d[9] * c + d[13] * e;
    this.z = d[2] * a + d[6] * b + d[10] * c + d[14] * e;
    this.w = d[3] * a + d[7] * b + d[11] * c + d[15] * e;
    return this;
  }, divideScalar:function(d) {
    return this.multiplyScalar(1 / d);
  }, setAxisAngleFromQuaternion:function(d) {
    this.w = 2 * Math.acos(d.w);
    var a = Math.sqrt(1 - d.w * d.w);
    1E-4 > a ? (this.x = 1, this.z = this.y = 0) : (this.x = d.x / a, this.y = d.y / a, this.z = d.z / a);
    return this;
  }, setAxisAngleFromRotationMatrix:function(d) {
    var a, b, c;
    d = d.elements;
    var e = d[0];
    c = d[4];
    var g = d[8], f = d[1], k = d[5], q = d[9];
    b = d[2];
    a = d[6];
    var p = d[10];
    if (.01 > Math.abs(c - f) && .01 > Math.abs(g - b) && .01 > Math.abs(q - a)) {
      if (.1 > Math.abs(c + f) && .1 > Math.abs(g + b) && .1 > Math.abs(q + a) && .1 > Math.abs(e + k + p - 3)) {
        return this.set(1, 0, 0, 0), this;
      }
      d = Math.PI;
      e = (e + 1) / 2;
      k = (k + 1) / 2;
      p = (p + 1) / 2;
      c = (c + f) / 4;
      g = (g + b) / 4;
      q = (q + a) / 4;
      e > k && e > p ? .01 > e ? (a = 0, c = b = .707106781) : (a = Math.sqrt(e), b = c / a, c = g / a) : k > p ? .01 > k ? (a = .707106781, b = 0, c = .707106781) : (b = Math.sqrt(k), a = c / b, c = q / b) : .01 > p ? (b = a = .707106781, c = 0) : (c = Math.sqrt(p), a = g / c, b = q / c);
      this.set(a, b, c, d);
      return this;
    }
    d = Math.sqrt((a - q) * (a - q) + (g - b) * (g - b) + (f - c) * (f - c));
    .001 > Math.abs(d) && (d = 1);
    this.x = (a - q) / d;
    this.y = (g - b) / d;
    this.z = (f - c) / d;
    this.w = Math.acos((e + k + p - 1) / 2);
    return this;
  }, min:function(d) {
    this.x = Math.min(this.x, d.x);
    this.y = Math.min(this.y, d.y);
    this.z = Math.min(this.z, d.z);
    this.w = Math.min(this.w, d.w);
    return this;
  }, max:function(d) {
    this.x = Math.max(this.x, d.x);
    this.y = Math.max(this.y, d.y);
    this.z = Math.max(this.z, d.z);
    this.w = Math.max(this.w, d.w);
    return this;
  }, clamp:function(d, a) {
    this.x = Math.max(d.x, Math.min(a.x, this.x));
    this.y = Math.max(d.y, Math.min(a.y, this.y));
    this.z = Math.max(d.z, Math.min(a.z, this.z));
    this.w = Math.max(d.w, Math.min(a.w, this.w));
    return this;
  }, clampScalar:function() {
    var d = new f, a = new f;
    return function(m, b) {
      d.set(m, m, m, m);
      a.set(b, b, b, b);
      return this.clamp(d, a);
    };
  }(), floor:function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }, ceil:function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }, round:function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }, roundToZero:function() {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }, negate:function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }, dot:function(d) {
    return this.x * d.x + this.y * d.y + this.z * d.z + this.w * d.w;
  }, lengthSq:function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }, length:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }, lengthManhattan:function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }, normalize:function() {
    return this.divideScalar(this.length());
  }, setLength:function(d) {
    return this.multiplyScalar(d / this.length());
  }, lerp:function(d, a) {
    this.x += (d.x - this.x) * a;
    this.y += (d.y - this.y) * a;
    this.z += (d.z - this.z) * a;
    this.w += (d.w - this.w) * a;
    return this;
  }, lerpVectors:function(d, a, b) {
    return this.subVectors(a, d).multiplyScalar(b).add(d);
  }, equals:function(d) {
    return d.x === this.x && d.y === this.y && d.z === this.z && d.w === this.w;
  }, fromArray:function(d, a) {
    void 0 === a && (a = 0);
    this.x = d[a];
    this.y = d[a + 1];
    this.z = d[a + 2];
    this.w = d[a + 3];
    return this;
  }, toArray:function(d, a) {
    void 0 === d && (d = []);
    void 0 === a && (a = 0);
    d[a] = this.x;
    d[a + 1] = this.y;
    d[a + 2] = this.z;
    d[a + 3] = this.w;
    return d;
  }, fromBufferAttribute:function(d, a, b) {
    void 0 !== b && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    this.x = d.getX(a);
    this.y = d.getY(a);
    this.z = d.getZ(a);
    this.w = d.getW(a);
    return this;
  }});
  Object.assign(k.prototype, h.prototype, {isWebGLRenderTarget:!0, setSize:function(d, a) {
    if (this.width !== d || this.height !== a) {
      this.width = d, this.height = a, this.dispose();
    }
    this.viewport.set(0, 0, d, a);
    this.scissor.set(0, 0, d, a);
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(d) {
    this.width = d.width;
    this.height = d.height;
    this.viewport.copy(d.viewport);
    this.texture = d.texture.clone();
    this.depthBuffer = d.depthBuffer;
    this.stencilBuffer = d.stencilBuffer;
    this.depthTexture = d.depthTexture;
    return this;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }});
  c.prototype = Object.create(k.prototype);
  c.prototype.constructor = c;
  c.prototype.isWebGLRenderTargetCube = !0;
  Object.assign(g, {slerp:function(d, a, b, c) {
    return b.copy(d).slerp(a, c);
  }, slerpFlat:function(d, a, b, c, e, g, f) {
    var m = b[c + 0], k = b[c + 1], A = b[c + 2];
    b = b[c + 3];
    c = e[g + 0];
    var q = e[g + 1], p = e[g + 2];
    e = e[g + 3];
    if (b !== e || m !== c || k !== q || A !== p) {
      g = 1 - f;
      var h = m * c + k * q + A * p + b * e, n = 0 <= h ? 1 : -1, r = 1 - h * h;
      r > Number.EPSILON && (r = Math.sqrt(r), h = Math.atan2(r, h * n), g = Math.sin(g * h) / r, f = Math.sin(f * h) / r);
      n *= f;
      m = m * g + c * n;
      k = k * g + q * n;
      A = A * g + p * n;
      b = b * g + e * n;
      g === 1 - f && (f = 1 / Math.sqrt(m * m + k * k + A * A + b * b), m *= f, k *= f, A *= f, b *= f);
    }
    d[a] = m;
    d[a + 1] = k;
    d[a + 2] = A;
    d[a + 3] = b;
  }});
  Object.defineProperties(g.prototype, {x:{get:function() {
    return this._x;
  }, set:function(d) {
    this._x = d;
    this.onChangeCallback();
  }}, y:{get:function() {
    return this._y;
  }, set:function(d) {
    this._y = d;
    this.onChangeCallback();
  }}, z:{get:function() {
    return this._z;
  }, set:function(d) {
    this._z = d;
    this.onChangeCallback();
  }}, w:{get:function() {
    return this._w;
  }, set:function(d) {
    this._w = d;
    this.onChangeCallback();
  }}});
  Object.assign(g.prototype, {set:function(d, a, b, c) {
    this._x = d;
    this._y = a;
    this._z = b;
    this._w = c;
    this.onChangeCallback();
    return this;
  }, clone:function() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }, copy:function(d) {
    this._x = d.x;
    this._y = d.y;
    this._z = d.z;
    this._w = d.w;
    this.onChangeCallback();
    return this;
  }, setFromEuler:function(d, a) {
    if (!1 === (d && d.isEuler)) {
      throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    var m = d._x, b = d._y, c = d._z;
    d = d.order;
    var e = Math.cos, g = Math.sin, f = e(m / 2), k = e(b / 2), e = e(c / 2), m = g(m / 2), b = g(b / 2), c = g(c / 2);
    "XYZ" === d ? (this._x = m * k * e + f * b * c, this._y = f * b * e - m * k * c, this._z = f * k * c + m * b * e, this._w = f * k * e - m * b * c) : "YXZ" === d ? (this._x = m * k * e + f * b * c, this._y = f * b * e - m * k * c, this._z = f * k * c - m * b * e, this._w = f * k * e + m * b * c) : "ZXY" === d ? (this._x = m * k * e - f * b * c, this._y = f * b * e + m * k * c, this._z = f * k * c + m * b * e, this._w = f * k * e - m * b * c) : "ZYX" === d ? (this._x = m * k * e - f * b * c, this._y = 
    f * b * e + m * k * c, this._z = f * k * c - m * b * e, this._w = f * k * e + m * b * c) : "YZX" === d ? (this._x = m * k * e + f * b * c, this._y = f * b * e + m * k * c, this._z = f * k * c - m * b * e, this._w = f * k * e - m * b * c) : "XZY" === d && (this._x = m * k * e - f * b * c, this._y = f * b * e - m * k * c, this._z = f * k * c + m * b * e, this._w = f * k * e + m * b * c);
    if (!1 !== a) {
      this.onChangeCallback();
    }
    return this;
  }, setFromAxisAngle:function(d, a) {
    a /= 2;
    var m = Math.sin(a);
    this._x = d.x * m;
    this._y = d.y * m;
    this._z = d.z * m;
    this._w = Math.cos(a);
    this.onChangeCallback();
    return this;
  }, setFromRotationMatrix:function(d) {
    var a = d.elements, b = a[0];
    d = a[4];
    var c = a[8], e = a[1], g = a[5], f = a[9], k = a[2], q = a[6], a = a[10], p = b + g + a;
    0 < p ? (b = .5 / Math.sqrt(p + 1), this._w = .25 / b, this._x = (q - f) * b, this._y = (c - k) * b, this._z = (e - d) * b) : b > g && b > a ? (b = 2 * Math.sqrt(1 + b - g - a), this._w = (q - f) / b, this._x = .25 * b, this._y = (d + e) / b, this._z = (c + k) / b) : g > a ? (b = 2 * Math.sqrt(1 + g - b - a), this._w = (c - k) / b, this._x = (d + e) / b, this._y = .25 * b, this._z = (f + q) / b) : (b = 2 * Math.sqrt(1 + a - b - g), this._w = (e - d) / b, this._x = (c + k) / b, this._y = (f + 
    q) / b, this._z = .25 * b);
    this.onChangeCallback();
    return this;
  }, setFromUnitVectors:function() {
    var d = new e, a;
    return function(m, b) {
      void 0 === d && (d = new e);
      a = m.dot(b) + 1;
      1E-6 > a ? (a = 0, Math.abs(m.x) > Math.abs(m.z) ? d.set(-m.y, m.x, 0) : d.set(0, -m.z, m.y)) : d.crossVectors(m, b);
      this._x = d.x;
      this._y = d.y;
      this._z = d.z;
      this._w = a;
      return this.normalize();
    };
  }(), inverse:function() {
    return this.conjugate().normalize();
  }, conjugate:function() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this.onChangeCallback();
    return this;
  }, dot:function(d) {
    return this._x * d._x + this._y * d._y + this._z * d._z + this._w * d._w;
  }, lengthSq:function() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }, length:function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }, normalize:function() {
    var d = this.length();
    0 === d ? (this._z = this._y = this._x = 0, this._w = 1) : (d = 1 / d, this._x *= d, this._y *= d, this._z *= d, this._w *= d);
    this.onChangeCallback();
    return this;
  }, multiply:function(d, a) {
    return void 0 !== a ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(d, a)) : this.multiplyQuaternions(this, d);
  }, premultiply:function(d) {
    return this.multiplyQuaternions(d, this);
  }, multiplyQuaternions:function(d, a) {
    var m = d._x, b = d._y, c = d._z;
    d = d._w;
    var e = a._x, g = a._y, f = a._z;
    a = a._w;
    this._x = m * a + d * e + b * f - c * g;
    this._y = b * a + d * g + c * e - m * f;
    this._z = c * a + d * f + m * g - b * e;
    this._w = d * a - m * e - b * g - c * f;
    this.onChangeCallback();
    return this;
  }, slerp:function(d, a) {
    if (0 === a) {
      return this;
    }
    if (1 === a) {
      return this.copy(d);
    }
    var m = this._x, b = this._y, c = this._z, e = this._w, g = e * d._w + m * d._x + b * d._y + c * d._z;
    0 > g ? (this._w = -d._w, this._x = -d._x, this._y = -d._y, this._z = -d._z, g = -g) : this.copy(d);
    if (1 <= g) {
      return this._w = e, this._x = m, this._y = b, this._z = c, this;
    }
    d = Math.sqrt(1 - g * g);
    if (.001 > Math.abs(d)) {
      return this._w = .5 * (e + this._w), this._x = .5 * (m + this._x), this._y = .5 * (b + this._y), this._z = .5 * (c + this._z), this;
    }
    var f = Math.atan2(d, g), g = Math.sin((1 - a) * f) / d;
    d = Math.sin(a * f) / d;
    this._w = e * g + this._w * d;
    this._x = m * g + this._x * d;
    this._y = b * g + this._y * d;
    this._z = c * g + this._z * d;
    this.onChangeCallback();
    return this;
  }, equals:function(d) {
    return d._x === this._x && d._y === this._y && d._z === this._z && d._w === this._w;
  }, fromArray:function(d, a) {
    void 0 === a && (a = 0);
    this._x = d[a];
    this._y = d[a + 1];
    this._z = d[a + 2];
    this._w = d[a + 3];
    this.onChangeCallback();
    return this;
  }, toArray:function(d, a) {
    void 0 === d && (d = []);
    void 0 === a && (a = 0);
    d[a] = this._x;
    d[a + 1] = this._y;
    d[a + 2] = this._z;
    d[a + 3] = this._w;
    return d;
  }, onChange:function(d) {
    this.onChangeCallback = d;
    return this;
  }, onChangeCallback:function() {
  }});
  Object.assign(e.prototype, {isVector3:!0, set:function(d, a, b) {
    this.x = d;
    this.y = a;
    this.z = b;
    return this;
  }, setScalar:function(d) {
    this.z = this.y = this.x = d;
    return this;
  }, setX:function(d) {
    this.x = d;
    return this;
  }, setY:function(d) {
    this.y = d;
    return this;
  }, setZ:function(d) {
    this.z = d;
    return this;
  }, setComponent:function(d, a) {
    switch(d) {
      case 0:
        this.x = a;
        break;
      case 1:
        this.y = a;
        break;
      case 2:
        this.z = a;
        break;
      default:
        throw Error("index is out of range: " + d);
    }
    return this;
  }, getComponent:function(d) {
    switch(d) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw Error("index is out of range: " + d);
    }
  }, clone:function() {
    return new this.constructor(this.x, this.y, this.z);
  }, copy:function(d) {
    this.x = d.x;
    this.y = d.y;
    this.z = d.z;
    return this;
  }, add:function(d, a) {
    if (void 0 !== a) {
      return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(d, a);
    }
    this.x += d.x;
    this.y += d.y;
    this.z += d.z;
    return this;
  }, addScalar:function(d) {
    this.x += d;
    this.y += d;
    this.z += d;
    return this;
  }, addVectors:function(d, a) {
    this.x = d.x + a.x;
    this.y = d.y + a.y;
    this.z = d.z + a.z;
    return this;
  }, addScaledVector:function(d, a) {
    this.x += d.x * a;
    this.y += d.y * a;
    this.z += d.z * a;
    return this;
  }, sub:function(d, a) {
    if (void 0 !== a) {
      return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(d, a);
    }
    this.x -= d.x;
    this.y -= d.y;
    this.z -= d.z;
    return this;
  }, subScalar:function(d) {
    this.x -= d;
    this.y -= d;
    this.z -= d;
    return this;
  }, subVectors:function(d, a) {
    this.x = d.x - a.x;
    this.y = d.y - a.y;
    this.z = d.z - a.z;
    return this;
  }, multiply:function(d, a) {
    if (void 0 !== a) {
      return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(d, a);
    }
    this.x *= d.x;
    this.y *= d.y;
    this.z *= d.z;
    return this;
  }, multiplyScalar:function(d) {
    this.x *= d;
    this.y *= d;
    this.z *= d;
    return this;
  }, multiplyVectors:function(d, a) {
    this.x = d.x * a.x;
    this.y = d.y * a.y;
    this.z = d.z * a.z;
    return this;
  }, applyEuler:function() {
    var d = new g;
    return function(a) {
      !1 === (a && a.isEuler) && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
      return this.applyQuaternion(d.setFromEuler(a));
    };
  }(), applyAxisAngle:function() {
    var d = new g;
    return function(a, b) {
      return this.applyQuaternion(d.setFromAxisAngle(a, b));
    };
  }(), applyMatrix3:function(d) {
    var a = this.x, b = this.y, c = this.z;
    d = d.elements;
    this.x = d[0] * a + d[3] * b + d[6] * c;
    this.y = d[1] * a + d[4] * b + d[7] * c;
    this.z = d[2] * a + d[5] * b + d[8] * c;
    return this;
  }, applyMatrix4:function(d) {
    var a = this.x, b = this.y, c = this.z;
    d = d.elements;
    this.x = d[0] * a + d[4] * b + d[8] * c + d[12];
    this.y = d[1] * a + d[5] * b + d[9] * c + d[13];
    this.z = d[2] * a + d[6] * b + d[10] * c + d[14];
    return this.divideScalar(d[3] * a + d[7] * b + d[11] * c + d[15]);
  }, applyQuaternion:function(d) {
    var a = this.x, b = this.y, c = this.z, e = d.x, g = d.y, f = d.z;
    d = d.w;
    var k = d * a + g * c - f * b, q = d * b + f * a - e * c, p = d * c + e * b - g * a, a = -e * a - g * b - f * c;
    this.x = k * d + a * -e + q * -f - p * -g;
    this.y = q * d + a * -g + p * -e - k * -f;
    this.z = p * d + a * -f + k * -g - q * -e;
    return this;
  }, project:function() {
    var d = new p;
    return function(a) {
      d.multiplyMatrices(a.projectionMatrix, d.getInverse(a.matrixWorld));
      return this.applyMatrix4(d);
    };
  }(), unproject:function() {
    var d = new p;
    return function(a) {
      d.multiplyMatrices(a.matrixWorld, d.getInverse(a.projectionMatrix));
      return this.applyMatrix4(d);
    };
  }(), transformDirection:function(d) {
    var a = this.x, b = this.y, c = this.z;
    d = d.elements;
    this.x = d[0] * a + d[4] * b + d[8] * c;
    this.y = d[1] * a + d[5] * b + d[9] * c;
    this.z = d[2] * a + d[6] * b + d[10] * c;
    return this.normalize();
  }, divide:function(d) {
    this.x /= d.x;
    this.y /= d.y;
    this.z /= d.z;
    return this;
  }, divideScalar:function(d) {
    return this.multiplyScalar(1 / d);
  }, min:function(d) {
    this.x = Math.min(this.x, d.x);
    this.y = Math.min(this.y, d.y);
    this.z = Math.min(this.z, d.z);
    return this;
  }, max:function(d) {
    this.x = Math.max(this.x, d.x);
    this.y = Math.max(this.y, d.y);
    this.z = Math.max(this.z, d.z);
    return this;
  }, clamp:function(d, a) {
    this.x = Math.max(d.x, Math.min(a.x, this.x));
    this.y = Math.max(d.y, Math.min(a.y, this.y));
    this.z = Math.max(d.z, Math.min(a.z, this.z));
    return this;
  }, clampScalar:function() {
    var d = new e, a = new e;
    return function(m, b) {
      d.set(m, m, m);
      a.set(b, b, b);
      return this.clamp(d, a);
    };
  }(), clampLength:function(d, a) {
    var m = this.length();
    return this.multiplyScalar(Math.max(d, Math.min(a, m)) / m);
  }, floor:function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }, ceil:function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }, round:function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }, roundToZero:function() {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }, negate:function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }, dot:function(d) {
    return this.x * d.x + this.y * d.y + this.z * d.z;
  }, lengthSq:function() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }, length:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }, lengthManhattan:function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }, normalize:function() {
    return this.divideScalar(this.length());
  }, setLength:function(d) {
    return this.multiplyScalar(d / this.length());
  }, lerp:function(d, a) {
    this.x += (d.x - this.x) * a;
    this.y += (d.y - this.y) * a;
    this.z += (d.z - this.z) * a;
    return this;
  }, lerpVectors:function(d, a, b) {
    return this.subVectors(a, d).multiplyScalar(b).add(d);
  }, cross:function(d, a) {
    if (void 0 !== a) {
      return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(d, a);
    }
    a = this.x;
    var m = this.y, b = this.z;
    this.x = m * d.z - b * d.y;
    this.y = b * d.x - a * d.z;
    this.z = a * d.y - m * d.x;
    return this;
  }, crossVectors:function(d, a) {
    var m = d.x, b = d.y;
    d = d.z;
    var c = a.x, e = a.y;
    a = a.z;
    this.x = b * a - d * e;
    this.y = d * c - m * a;
    this.z = m * e - b * c;
    return this;
  }, projectOnVector:function(d) {
    var a = d.dot(this) / d.lengthSq();
    return this.copy(d).multiplyScalar(a);
  }, projectOnPlane:function() {
    var d = new e;
    return function(a) {
      d.copy(this).projectOnVector(a);
      return this.sub(d);
    };
  }(), reflect:function() {
    var d = new e;
    return function(a) {
      return this.sub(d.copy(a).multiplyScalar(2 * this.dot(a)));
    };
  }(), angleTo:function(d) {
    d = this.dot(d) / Math.sqrt(this.lengthSq() * d.lengthSq());
    return Math.acos(ka.clamp(d, -1, 1));
  }, distanceTo:function(d) {
    return Math.sqrt(this.distanceToSquared(d));
  }, distanceToSquared:function(d) {
    var a = this.x - d.x, b = this.y - d.y;
    d = this.z - d.z;
    return a * a + b * b + d * d;
  }, distanceToManhattan:function(d) {
    return Math.abs(this.x - d.x) + Math.abs(this.y - d.y) + Math.abs(this.z - d.z);
  }, setFromSpherical:function(d) {
    var a = Math.sin(d.phi) * d.radius;
    this.x = a * Math.sin(d.theta);
    this.y = Math.cos(d.phi) * d.radius;
    this.z = a * Math.cos(d.theta);
    return this;
  }, setFromCylindrical:function(d) {
    this.x = d.radius * Math.sin(d.theta);
    this.y = d.y;
    this.z = d.radius * Math.cos(d.theta);
    return this;
  }, setFromMatrixPosition:function(d) {
    return this.setFromMatrixColumn(d, 3);
  }, setFromMatrixScale:function(d) {
    var a = this.setFromMatrixColumn(d, 0).length(), b = this.setFromMatrixColumn(d, 1).length();
    d = this.setFromMatrixColumn(d, 2).length();
    this.x = a;
    this.y = b;
    this.z = d;
    return this;
  }, setFromMatrixColumn:function(d, a) {
    return this.fromArray(d.elements, 4 * a);
  }, equals:function(d) {
    return d.x === this.x && d.y === this.y && d.z === this.z;
  }, fromArray:function(d, a) {
    void 0 === a && (a = 0);
    this.x = d[a];
    this.y = d[a + 1];
    this.z = d[a + 2];
    return this;
  }, toArray:function(d, a) {
    void 0 === d && (d = []);
    void 0 === a && (a = 0);
    d[a] = this.x;
    d[a + 1] = this.y;
    d[a + 2] = this.z;
    return d;
  }, fromBufferAttribute:function(d, a, b) {
    void 0 !== b && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    this.x = d.getX(a);
    this.y = d.getY(a);
    this.z = d.getZ(a);
    return this;
  }});
  Object.assign(p.prototype, {isMatrix4:!0, set:function(d, a, b, c, e, g, f, k, q, p, h, n, r, l, u, w) {
    var m = this.elements;
    m[0] = d;
    m[4] = a;
    m[8] = b;
    m[12] = c;
    m[1] = e;
    m[5] = g;
    m[9] = f;
    m[13] = k;
    m[2] = q;
    m[6] = p;
    m[10] = h;
    m[14] = n;
    m[3] = r;
    m[7] = l;
    m[11] = u;
    m[15] = w;
    return this;
  }, identity:function() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }, clone:function() {
    return (new p).fromArray(this.elements);
  }, copy:function(d) {
    var a = this.elements;
    d = d.elements;
    for (var b = 0;16 > b;b++) {
      a[b] = d[b];
    }
    return this;
  }, copyPosition:function(d) {
    var a = this.elements;
    d = d.elements;
    a[12] = d[12];
    a[13] = d[13];
    a[14] = d[14];
    return this;
  }, extractBasis:function(d, a, b) {
    d.setFromMatrixColumn(this, 0);
    a.setFromMatrixColumn(this, 1);
    b.setFromMatrixColumn(this, 2);
    return this;
  }, makeBasis:function(d, a, b) {
    this.set(d.x, a.x, b.x, 0, d.y, a.y, b.y, 0, d.z, a.z, b.z, 0, 0, 0, 0, 1);
    return this;
  }, extractRotation:function() {
    var d = new e;
    return function(a) {
      var m = this.elements, b = a.elements, c = 1 / d.setFromMatrixColumn(a, 0).length(), e = 1 / d.setFromMatrixColumn(a, 1).length();
      a = 1 / d.setFromMatrixColumn(a, 2).length();
      m[0] = b[0] * c;
      m[1] = b[1] * c;
      m[2] = b[2] * c;
      m[4] = b[4] * e;
      m[5] = b[5] * e;
      m[6] = b[6] * e;
      m[8] = b[8] * a;
      m[9] = b[9] * a;
      m[10] = b[10] * a;
      return this;
    };
  }(), makeRotationFromEuler:function(d) {
    !1 === (d && d.isEuler) && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    var a = this.elements, b = d.x, c = d.y, e = d.z, g = Math.cos(b), b = Math.sin(b), f = Math.cos(c), c = Math.sin(c), k = Math.cos(e), e = Math.sin(e);
    if ("XYZ" === d.order) {
      d = g * k;
      var q = g * e, p = b * k, h = b * e;
      a[0] = f * k;
      a[4] = -f * e;
      a[8] = c;
      a[1] = q + p * c;
      a[5] = d - h * c;
      a[9] = -b * f;
      a[2] = h - d * c;
      a[6] = p + q * c;
      a[10] = g * f;
    } else {
      "YXZ" === d.order ? (d = f * k, q = f * e, p = c * k, h = c * e, a[0] = d + h * b, a[4] = p * b - q, a[8] = g * c, a[1] = g * e, a[5] = g * k, a[9] = -b, a[2] = q * b - p, a[6] = h + d * b, a[10] = g * f) : "ZXY" === d.order ? (d = f * k, q = f * e, p = c * k, h = c * e, a[0] = d - h * b, a[4] = -g * e, a[8] = p + q * b, a[1] = q + p * b, a[5] = g * k, a[9] = h - d * b, a[2] = -g * c, a[6] = b, a[10] = g * f) : "ZYX" === d.order ? (d = g * k, q = g * e, p = b * k, h = b * e, a[0] = f * k, a[4] = 
      p * c - q, a[8] = d * c + h, a[1] = f * e, a[5] = h * c + d, a[9] = q * c - p, a[2] = -c, a[6] = b * f, a[10] = g * f) : "YZX" === d.order ? (d = g * f, q = g * c, p = b * f, h = b * c, a[0] = f * k, a[4] = h - d * e, a[8] = p * e + q, a[1] = e, a[5] = g * k, a[9] = -b * k, a[2] = -c * k, a[6] = q * e + p, a[10] = d - h * e) : "XZY" === d.order && (d = g * f, q = g * c, p = b * f, h = b * c, a[0] = f * k, a[4] = -e, a[8] = c * k, a[1] = d * e + h, a[5] = g * k, a[9] = q * e - p, a[2] = p * 
      e - q, a[6] = b * k, a[10] = h * e + d);
    }
    a[3] = 0;
    a[7] = 0;
    a[11] = 0;
    a[12] = 0;
    a[13] = 0;
    a[14] = 0;
    a[15] = 1;
    return this;
  }, makeRotationFromQuaternion:function(d) {
    var a = this.elements, b = d.x, c = d.y, e = d.z, g = d.w, f = b + b, k = c + c, q = e + e;
    d = b * f;
    var p = b * k, b = b * q, h = c * k, c = c * q, e = e * q, f = g * f, k = g * k, g = g * q;
    a[0] = 1 - (h + e);
    a[4] = p - g;
    a[8] = b + k;
    a[1] = p + g;
    a[5] = 1 - (d + e);
    a[9] = c - f;
    a[2] = b - k;
    a[6] = c + f;
    a[10] = 1 - (d + h);
    a[3] = 0;
    a[7] = 0;
    a[11] = 0;
    a[12] = 0;
    a[13] = 0;
    a[14] = 0;
    a[15] = 1;
    return this;
  }, lookAt:function() {
    var d = new e, a = new e, b = new e;
    return function(m, c, e) {
      var g = this.elements;
      b.subVectors(m, c).normalize();
      0 === b.lengthSq() && (b.z = 1);
      d.crossVectors(e, b).normalize();
      0 === d.lengthSq() && (b.z += 1E-4, d.crossVectors(e, b).normalize());
      a.crossVectors(b, d);
      g[0] = d.x;
      g[4] = a.x;
      g[8] = b.x;
      g[1] = d.y;
      g[5] = a.y;
      g[9] = b.y;
      g[2] = d.z;
      g[6] = a.z;
      g[10] = b.z;
      return this;
    };
  }(), multiply:function(d, a) {
    return void 0 !== a ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(d, a)) : this.multiplyMatrices(this, d);
  }, premultiply:function(d) {
    return this.multiplyMatrices(d, this);
  }, multiplyMatrices:function(d, a) {
    d = d.elements;
    a = a.elements;
    var m = this.elements, b = d[0], c = d[4], e = d[8], g = d[12], f = d[1], k = d[5], q = d[9], p = d[13], h = d[2], n = d[6], r = d[10], l = d[14], u = d[3], w = d[7], t = d[11];
    d = d[15];
    var v = a[0], B = a[4], y = a[8], z = a[12], x = a[1], C = a[5], F = a[9], E = a[13], D = a[2], N = a[6], I = a[10], X = a[14], J = a[3], Z = a[7], L = a[11];
    a = a[15];
    m[0] = b * v + c * x + e * D + g * J;
    m[4] = b * B + c * C + e * N + g * Z;
    m[8] = b * y + c * F + e * I + g * L;
    m[12] = b * z + c * E + e * X + g * a;
    m[1] = f * v + k * x + q * D + p * J;
    m[5] = f * B + k * C + q * N + p * Z;
    m[9] = f * y + k * F + q * I + p * L;
    m[13] = f * z + k * E + q * X + p * a;
    m[2] = h * v + n * x + r * D + l * J;
    m[6] = h * B + n * C + r * N + l * Z;
    m[10] = h * y + n * F + r * I + l * L;
    m[14] = h * z + n * E + r * X + l * a;
    m[3] = u * v + w * x + t * D + d * J;
    m[7] = u * B + w * C + t * N + d * Z;
    m[11] = u * y + w * F + t * I + d * L;
    m[15] = u * z + w * E + t * X + d * a;
    return this;
  }, multiplyScalar:function(d) {
    var a = this.elements;
    a[0] *= d;
    a[4] *= d;
    a[8] *= d;
    a[12] *= d;
    a[1] *= d;
    a[5] *= d;
    a[9] *= d;
    a[13] *= d;
    a[2] *= d;
    a[6] *= d;
    a[10] *= d;
    a[14] *= d;
    a[3] *= d;
    a[7] *= d;
    a[11] *= d;
    a[15] *= d;
    return this;
  }, applyToBufferAttribute:function() {
    var d = new e;
    return function(a) {
      for (var m = 0, b = a.count;m < b;m++) {
        d.x = a.getX(m), d.y = a.getY(m), d.z = a.getZ(m), d.applyMatrix4(this), a.setXYZ(m, d.x, d.y, d.z);
      }
      return a;
    };
  }(), determinant:function() {
    var d = this.elements, a = d[0], b = d[4], c = d[8], e = d[12], g = d[1], f = d[5], k = d[9], q = d[13], p = d[2], h = d[6], n = d[10], r = d[14];
    return d[3] * (+e * k * h - c * q * h - e * f * n + b * q * n + c * f * r - b * k * r) + d[7] * (+a * k * r - a * q * n + e * g * n - c * g * r + c * q * p - e * k * p) + d[11] * (+a * q * h - a * f * r - e * g * h + b * g * r + e * f * p - b * q * p) + d[15] * (-c * f * p - a * k * h + a * f * n + c * g * h - b * g * n + b * k * p);
  }, transpose:function() {
    var d = this.elements, a;
    a = d[1];
    d[1] = d[4];
    d[4] = a;
    a = d[2];
    d[2] = d[8];
    d[8] = a;
    a = d[6];
    d[6] = d[9];
    d[9] = a;
    a = d[3];
    d[3] = d[12];
    d[12] = a;
    a = d[7];
    d[7] = d[13];
    d[13] = a;
    a = d[11];
    d[11] = d[14];
    d[14] = a;
    return this;
  }, setPosition:function(d) {
    var a = this.elements;
    a[12] = d.x;
    a[13] = d.y;
    a[14] = d.z;
    return this;
  }, getInverse:function(d, a) {
    var m = this.elements;
    d = d.elements;
    var b = d[0], c = d[1], e = d[2], g = d[3], f = d[4], k = d[5], q = d[6], p = d[7], h = d[8], n = d[9], r = d[10], l = d[11], u = d[12], w = d[13], t = d[14];
    d = d[15];
    var v = n * t * p - w * r * p + w * q * l - k * t * l - n * q * d + k * r * d, B = u * r * p - h * t * p - u * q * l + f * t * l + h * q * d - f * r * d, y = h * w * p - u * n * p + u * k * l - f * w * l - h * k * d + f * n * d, z = u * n * q - h * w * q - u * k * r + f * w * r + h * k * t - f * n * t, x = b * v + c * B + e * y + g * z;
    if (0 === x) {
      if (!0 === a) {
        throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
      }
      console.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
      return this.identity();
    }
    x = 1 / x;
    m[0] = v * x;
    m[1] = (w * r * g - n * t * g - w * e * l + c * t * l + n * e * d - c * r * d) * x;
    m[2] = (k * t * g - w * q * g + w * e * p - c * t * p - k * e * d + c * q * d) * x;
    m[3] = (n * q * g - k * r * g - n * e * p + c * r * p + k * e * l - c * q * l) * x;
    m[4] = B * x;
    m[5] = (h * t * g - u * r * g + u * e * l - b * t * l - h * e * d + b * r * d) * x;
    m[6] = (u * q * g - f * t * g - u * e * p + b * t * p + f * e * d - b * q * d) * x;
    m[7] = (f * r * g - h * q * g + h * e * p - b * r * p - f * e * l + b * q * l) * x;
    m[8] = y * x;
    m[9] = (u * n * g - h * w * g - u * c * l + b * w * l + h * c * d - b * n * d) * x;
    m[10] = (f * w * g - u * k * g + u * c * p - b * w * p - f * c * d + b * k * d) * x;
    m[11] = (h * k * g - f * n * g - h * c * p + b * n * p + f * c * l - b * k * l) * x;
    m[12] = z * x;
    m[13] = (h * w * e - u * n * e + u * c * r - b * w * r - h * c * t + b * n * t) * x;
    m[14] = (u * k * e - f * w * e - u * c * q + b * w * q + f * c * t - b * k * t) * x;
    m[15] = (f * n * e - h * k * e + h * c * q - b * n * q - f * c * r + b * k * r) * x;
    return this;
  }, scale:function(d) {
    var a = this.elements, b = d.x, c = d.y;
    d = d.z;
    a[0] *= b;
    a[4] *= c;
    a[8] *= d;
    a[1] *= b;
    a[5] *= c;
    a[9] *= d;
    a[2] *= b;
    a[6] *= c;
    a[10] *= d;
    a[3] *= b;
    a[7] *= c;
    a[11] *= d;
    return this;
  }, getMaxScaleOnAxis:function() {
    var d = this.elements;
    return Math.sqrt(Math.max(d[0] * d[0] + d[1] * d[1] + d[2] * d[2], d[4] * d[4] + d[5] * d[5] + d[6] * d[6], d[8] * d[8] + d[9] * d[9] + d[10] * d[10]));
  }, makeTranslation:function(d, a, b) {
    this.set(1, 0, 0, d, 0, 1, 0, a, 0, 0, 1, b, 0, 0, 0, 1);
    return this;
  }, makeRotationX:function(d) {
    var a = Math.cos(d);
    d = Math.sin(d);
    this.set(1, 0, 0, 0, 0, a, -d, 0, 0, d, a, 0, 0, 0, 0, 1);
    return this;
  }, makeRotationY:function(d) {
    var a = Math.cos(d);
    d = Math.sin(d);
    this.set(a, 0, d, 0, 0, 1, 0, 0, -d, 0, a, 0, 0, 0, 0, 1);
    return this;
  }, makeRotationZ:function(d) {
    var a = Math.cos(d);
    d = Math.sin(d);
    this.set(a, -d, 0, 0, d, a, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }, makeRotationAxis:function(d, a) {
    var m = Math.cos(a);
    a = Math.sin(a);
    var b = 1 - m, c = d.x, e = d.y;
    d = d.z;
    var g = b * c, f = b * e;
    this.set(g * c + m, g * e - a * d, g * d + a * e, 0, g * e + a * d, f * e + m, f * d - a * c, 0, g * d - a * e, f * d + a * c, b * d * d + m, 0, 0, 0, 0, 1);
    return this;
  }, makeScale:function(d, a, b) {
    this.set(d, 0, 0, 0, 0, a, 0, 0, 0, 0, b, 0, 0, 0, 0, 1);
    return this;
  }, makeShear:function(d, a, b) {
    this.set(1, a, b, 0, d, 1, b, 0, d, a, 1, 0, 0, 0, 0, 1);
    return this;
  }, compose:function(d, a, b) {
    this.makeRotationFromQuaternion(a);
    this.scale(b);
    this.setPosition(d);
    return this;
  }, decompose:function() {
    var d = new e, a = new p;
    return function(m, b, c) {
      var e = this.elements, g = d.set(e[0], e[1], e[2]).length(), f = d.set(e[4], e[5], e[6]).length(), k = d.set(e[8], e[9], e[10]).length();
      0 > this.determinant() && (g = -g);
      m.x = e[12];
      m.y = e[13];
      m.z = e[14];
      for (m = 0;16 > m;m++) {
        a.elements[m] = this.elements[m];
      }
      m = 1 / g;
      var e = 1 / f, q = 1 / k;
      a.elements[0] *= m;
      a.elements[1] *= m;
      a.elements[2] *= m;
      a.elements[4] *= e;
      a.elements[5] *= e;
      a.elements[6] *= e;
      a.elements[8] *= q;
      a.elements[9] *= q;
      a.elements[10] *= q;
      b.setFromRotationMatrix(a);
      c.x = g;
      c.y = f;
      c.z = k;
      return this;
    };
  }(), makePerspective:function(d, a, b, c, e, g) {
    void 0 === g && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    var m = this.elements;
    m[0] = 2 * e / (a - d);
    m[4] = 0;
    m[8] = (a + d) / (a - d);
    m[12] = 0;
    m[1] = 0;
    m[5] = 2 * e / (b - c);
    m[9] = (b + c) / (b - c);
    m[13] = 0;
    m[2] = 0;
    m[6] = 0;
    m[10] = -(g + e) / (g - e);
    m[14] = -2 * g * e / (g - e);
    m[3] = 0;
    m[7] = 0;
    m[11] = -1;
    m[15] = 0;
    return this;
  }, makeOrthographic:function(d, a, b, c, e, g) {
    var m = this.elements, f = 1 / (a - d), k = 1 / (b - c), q = 1 / (g - e);
    m[0] = 2 * f;
    m[4] = 0;
    m[8] = 0;
    m[12] = -((a + d) * f);
    m[1] = 0;
    m[5] = 2 * k;
    m[9] = 0;
    m[13] = -((b + c) * k);
    m[2] = 0;
    m[6] = 0;
    m[10] = -2 * q;
    m[14] = -((g + e) * q);
    m[3] = 0;
    m[7] = 0;
    m[11] = 0;
    m[15] = 1;
    return this;
  }, equals:function(d) {
    var a = this.elements;
    d = d.elements;
    for (var b = 0;16 > b;b++) {
      if (a[b] !== d[b]) {
        return !1;
      }
    }
    return !0;
  }, fromArray:function(d, a) {
    void 0 === a && (a = 0);
    for (var m = 0;16 > m;m++) {
      this.elements[m] = d[m + a];
    }
    return this;
  }, toArray:function(d, a) {
    void 0 === d && (d = []);
    void 0 === a && (a = 0);
    var m = this.elements;
    d[a] = m[0];
    d[a + 1] = m[1];
    d[a + 2] = m[2];
    d[a + 3] = m[3];
    d[a + 4] = m[4];
    d[a + 5] = m[5];
    d[a + 6] = m[6];
    d[a + 7] = m[7];
    d[a + 8] = m[8];
    d[a + 9] = m[9];
    d[a + 10] = m[10];
    d[a + 11] = m[11];
    d[a + 12] = m[12];
    d[a + 13] = m[13];
    d[a + 14] = m[14];
    d[a + 15] = m[15];
    return d;
  }});
  r.prototype = Object.create(b.prototype);
  r.prototype.constructor = r;
  r.prototype.isCubeTexture = !0;
  Object.defineProperty(r.prototype, "images", {get:function() {
    return this.image;
  }, set:function(d) {
    this.image = d;
  }});
  var Fe = new b, Ge = new r, Be = [], Ce = [], Ee = new Float32Array(16), De = new Float32Array(9);
  ia.prototype.setValue = function(d, a) {
    for (var m = this.seq, b = 0, c = m.length;b !== c;++b) {
      var e = m[b];
      e.setValue(d, a[e.id]);
    }
  };
  var ae = /([\w\d_]+)(\])?(\[|\.)?/g;
  ta.prototype.setValue = function(d, a, b) {
    a = this.map[a];
    void 0 !== a && a.setValue(d, b, this.renderer);
  };
  ta.prototype.set = function(d, a, b) {
    var m = this.map[b];
    void 0 !== m && m.setValue(d, a[b], this.renderer);
  };
  ta.prototype.setOptional = function(d, a, b) {
    a = a[b];
    void 0 !== a && this.setValue(d, b, a);
  };
  ta.upload = function(d, a, b, c) {
    for (var m = 0, e = a.length;m !== e;++m) {
      var g = a[m], f = b[g.id];
      !1 !== f.needsUpdate && g.setValue(d, f.value, c);
    }
  };
  ta.seqWithValue = function(d, a) {
    for (var m = [], b = 0, c = d.length;b !== c;++b) {
      var e = d[b];
      e.id in a && m.push(e);
    }
    return m;
  };
  var Sa = {merge:function(d) {
    for (var a = {}, b = 0;b < d.length;b++) {
      var c = this.clone(d[b]), e;
      for (e in c) {
        a[e] = c[e];
      }
    }
    return a;
  }, clone:function(d) {
    var a = {}, b;
    for (b in d) {
      a[b] = {};
      for (var c in d[b]) {
        var e = d[b][c];
        e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? a[b][c] = e.clone() : Array.isArray(e) ? a[b][c] = e.slice() : a[b][c] = e;
      }
    }
    return a;
  }}, na = {alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n", alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n", alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n", aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n", 
  aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex:"\nvec3 transformed = vec3( position );\n", beginnormal_vertex:"\nvec3 objectNormal = vec3( normal );\n", bsdfs:"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\n\tint config = 0;\n\tif ( L[0].z > 0.0 ) config += 1;\n\tif ( L[1].z > 0.0 ) config += 2;\n\tif ( L[2].z > 0.0 ) config += 4;\n\tif ( L[3].z > 0.0 ) config += 8;\n\tn = 0;\n\tif ( config == 0 ) {\n\t} else if ( config == 1 ) {\n\t\tn = 3;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 2 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 3 ) {\n\t\tn = 4;\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 4 ) {\n\t\tn = 3;\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t} else if ( config == 5 ) {\n\t\tn = 0;\n\t} else if ( config == 6 ) {\n\t\tn = 4;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 7 ) {\n\t\tn = 5;\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 8 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] =  L[3];\n\t} else if ( config == 9 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\n\t} else if ( config == 10 ) {\n\t\tn = 0;\n\t} else if ( config == 11 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 12 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t} else if ( config == 13 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = L[2];\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t} else if ( config == 14 ) {\n\t\tn = 5;\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t} else if ( config == 15 ) {\n\t\tn = 4;\n\t}\n\tif ( n == 3 )\n\t\tL[3] = L[0];\n\tif ( n == 4 )\n\t\tL[4] = L[0];\n}\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\n\tfloat cosTheta = dot( v1, v2 );\n\tfloat theta = acos( cosTheta );\n\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\n\treturn res;\n}\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\n\trectPoints[0] = pos - halfWidth - halfHeight;\n\trectPoints[1] = pos + halfWidth - halfHeight;\n\trectPoints[2] = pos + halfWidth + halfHeight;\n\trectPoints[3] = pos - halfWidth + halfHeight;\n}\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot( V, N ));\n\tT2 = - cross( N, T1 );\n\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\n\tvec3 clippedRect[5];\n\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\n\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\n\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\n\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\n\tint n;\n\tclipQuadToHorizon(clippedRect, n);\n\tif ( n == 0 )\n\t\treturn vec3( 0, 0, 0 );\n\tclippedRect[0] = normalize( clippedRect[0] );\n\tclippedRect[1] = normalize( clippedRect[1] );\n\tclippedRect[2] = normalize( clippedRect[2] );\n\tclippedRect[3] = normalize( clippedRect[3] );\n\tclippedRect[4] = normalize( clippedRect[4] );\n\tfloat sum = 0.0;\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\n\tif (n >= 4)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\n\tif (n == 5)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\n\tsum = max( 0.0, sum );\n\tvec3 Lo_i = vec3( sum, sum, sum );\n\treturn Lo_i;\n}\nvec3 Rect_Area_Light_Specular_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\n\t\tconst in float roughness,\n\t\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tvec2 uv = ltcTextureCoords( geometry, roughness );\n\tvec4 brdfLtcApproxParams, t;\n\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\n\tt = texture2D( ltcMat, uv );\n\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\n\tmat3 brdfLtcApproxMat = mat3(\n\t\tvec3(   1,   0, t.y ),\n\t\tvec3(   0, t.z,   0 ),\n\t\tvec3( t.w,   0, t.x )\n\t);\n\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\n\tspecularReflectance *= brdfLtcScalar;\n\treturn specularReflectance;\n}\nvec3 Rect_Area_Light_Diffuse_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tmat3 diffuseBrdfMat = mat3(1);\n\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\n\treturn diffuseReflectance;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n", 
  bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n", 
  clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n", 
  clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n", clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n", clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n", 
  color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n", color_pars_vertex:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex:"#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common:"#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n", 
  cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n", 
  defaultnormal_vertex:"#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n", displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n", displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n", emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n", 
  emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n", encodings_fragment:"  gl_FragColor = linearToOutputTexel( gl_FragColor );\n", encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n", 
  envmap_fragment:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n", 
  envmap_pars_fragment:"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n", 
  envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n", envmap_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n", 
  fog_vertex:"\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif", fog_pars_vertex:"#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n", fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n", fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n", 
  gradientmap_pars_fragment:"#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n", lightmap_fragment:"#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n", 
  lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n", 
  lights_pars:"uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n", 
  lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n", lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n", 
  lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n", 
  lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n", 
  lights_template:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n", 
  logdepthbuf_fragment:"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment:"#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n", logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif", logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n", 
  map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n", map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n", map_particle_fragment:"#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n", map_particle_pars_fragment:"#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n", 
  metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n", metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n", 
  morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n", 
  normal_flip:"#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n", normal_fragment:"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n", 
  normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n", 
  packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n", 
  premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n", project_vertex:"#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n", roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n", 
  roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n", 
  shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n", 
  shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n", 
  shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n", 
  skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n", 
  skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n", skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n", 
  specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment:"#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n", tonemapping_pars_fragment:"#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n", 
  uv_pars_fragment:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n", 
  uv_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif", uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif", 
  uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n", cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n", 
  cube_vert:"varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n", depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n", 
  depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", 
  distanceRGBA_frag:"uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n", distanceRGBA_vert:"varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n", 
  equirect_frag:"uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n", equirect_vert:"varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n", 
  linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
  linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n", 
  meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
  meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n", 
  meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
  meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n", 
  meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
  meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n", 
  meshphysical_frag:"#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
  meshphysical_vert:"#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n", 
  normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n", 
  normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n", 
  points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
  points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n", 
  shadow_frag:"uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n", shadow_vert:"#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"}, tf = {aliceblue:15792383, 
  antiquewhite:16444375, aqua:65535, aquamarine:8388564, azure:15794175, beige:16119260, bisque:16770244, black:0, blanchedalmond:16772045, blue:255, blueviolet:9055202, brown:10824234, burlywood:14596231, cadetblue:6266528, chartreuse:8388352, chocolate:13789470, coral:16744272, cornflowerblue:6591981, cornsilk:16775388, crimson:14423100, cyan:65535, darkblue:139, darkcyan:35723, darkgoldenrod:12092939, darkgray:11119017, darkgreen:25600, darkgrey:11119017, darkkhaki:12433259, darkmagenta:9109643, 
  darkolivegreen:5597999, darkorange:16747520, darkorchid:10040012, darkred:9109504, darksalmon:15308410, darkseagreen:9419919, darkslateblue:4734347, darkslategray:3100495, darkslategrey:3100495, darkturquoise:52945, darkviolet:9699539, deeppink:16716947, deepskyblue:49151, dimgray:6908265, dimgrey:6908265, dodgerblue:2003199, firebrick:11674146, floralwhite:16775920, forestgreen:2263842, fuchsia:16711935, gainsboro:14474460, ghostwhite:16316671, gold:16766720, goldenrod:14329120, gray:8421504, 
  green:32768, greenyellow:11403055, grey:8421504, honeydew:15794160, hotpink:16738740, indianred:13458524, indigo:4915330, ivory:16777200, khaki:15787660, lavender:15132410, lavenderblush:16773365, lawngreen:8190976, lemonchiffon:16775885, lightblue:11393254, lightcoral:15761536, lightcyan:14745599, lightgoldenrodyellow:16448210, lightgray:13882323, lightgreen:9498256, lightgrey:13882323, lightpink:16758465, lightsalmon:16752762, lightseagreen:2142890, lightskyblue:8900346, lightslategray:7833753, 
  lightslategrey:7833753, lightsteelblue:11584734, lightyellow:16777184, lime:65280, limegreen:3329330, linen:16445670, magenta:16711935, maroon:8388608, mediumaquamarine:6737322, mediumblue:205, mediumorchid:12211667, mediumpurple:9662683, mediumseagreen:3978097, mediumslateblue:8087790, mediumspringgreen:64154, mediumturquoise:4772300, mediumvioletred:13047173, midnightblue:1644912, mintcream:16121850, mistyrose:16770273, moccasin:16770229, navajowhite:16768685, navy:128, oldlace:16643558, olive:8421376, 
  olivedrab:7048739, orange:16753920, orangered:16729344, orchid:14315734, palegoldenrod:15657130, palegreen:10025880, paleturquoise:11529966, palevioletred:14381203, papayawhip:16773077, peachpuff:16767673, peru:13468991, pink:16761035, plum:14524637, powderblue:11591910, purple:8388736, red:16711680, rosybrown:12357519, royalblue:4286945, saddlebrown:9127187, salmon:16416882, sandybrown:16032864, seagreen:3050327, seashell:16774638, sienna:10506797, silver:12632256, skyblue:8900331, slateblue:6970061, 
  slategray:7372944, slategrey:7372944, snow:16775930, springgreen:65407, steelblue:4620980, tan:13808780, teal:32896, thistle:14204888, tomato:16737095, turquoise:4251856, violet:15631086, wheat:16113331, white:16777215, whitesmoke:16119285, yellow:16776960, yellowgreen:10145074};
  Object.assign(T.prototype, {isColor:!0, r:1, g:1, b:1, set:function(d) {
    d && d.isColor ? this.copy(d) : "number" === typeof d ? this.setHex(d) : "string" === typeof d && this.setStyle(d);
    return this;
  }, setScalar:function(d) {
    this.b = this.g = this.r = d;
    return this;
  }, setHex:function(d) {
    d = Math.floor(d);
    this.r = (d >> 16 & 255) / 255;
    this.g = (d >> 8 & 255) / 255;
    this.b = (d & 255) / 255;
    return this;
  }, setRGB:function(d, a, b) {
    this.r = d;
    this.g = a;
    this.b = b;
    return this;
  }, setHSL:function() {
    function d(d, a, b) {
      0 > b && (b += 1);
      1 < b && --b;
      return b < 1 / 6 ? d + 6 * (a - d) * b : .5 > b ? a : b < 2 / 3 ? d + 6 * (a - d) * (2 / 3 - b) : d;
    }
    return function(a, b, c) {
      a = ka.euclideanModulo(a, 1);
      b = ka.clamp(b, 0, 1);
      c = ka.clamp(c, 0, 1);
      0 === b ? this.r = this.g = this.b = c : (b = .5 >= c ? c * (1 + b) : c + b - c * b, c = 2 * c - b, this.r = d(c, b, a + 1 / 3), this.g = d(c, b, a), this.b = d(c, b, a - 1 / 3));
      return this;
    };
  }(), setStyle:function(d) {
    function a(a) {
      void 0 !== a && 1 > parseFloat(a) && console.warn("THREE.Color: Alpha component of " + d + " will be ignored.");
    }
    var b;
    if (b = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(d)) {
      var c = b[2];
      switch(b[1]) {
        case "rgb":
        case "rgba":
          if (b = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(c)) {
            return this.r = Math.min(255, parseInt(b[1], 10)) / 255, this.g = Math.min(255, parseInt(b[2], 10)) / 255, this.b = Math.min(255, parseInt(b[3], 10)) / 255, a(b[5]), this;
          }
          if (b = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(c)) {
            return this.r = Math.min(100, parseInt(b[1], 10)) / 100, this.g = Math.min(100, parseInt(b[2], 10)) / 100, this.b = Math.min(100, parseInt(b[3], 10)) / 100, a(b[5]), this;
          }
          break;
        case "hsl":
        case "hsla":
          if (b = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(c)) {
            var c = parseFloat(b[1]) / 360, e = parseInt(b[2], 10) / 100, g = parseInt(b[3], 10) / 100;
            a(b[5]);
            return this.setHSL(c, e, g);
          }
      }
    } else {
      if (b = /^\#([A-Fa-f0-9]+)$/.exec(d)) {
        b = b[1];
        c = b.length;
        if (3 === c) {
          return this.r = parseInt(b.charAt(0) + b.charAt(0), 16) / 255, this.g = parseInt(b.charAt(1) + b.charAt(1), 16) / 255, this.b = parseInt(b.charAt(2) + b.charAt(2), 16) / 255, this;
        }
        if (6 === c) {
          return this.r = parseInt(b.charAt(0) + b.charAt(1), 16) / 255, this.g = parseInt(b.charAt(2) + b.charAt(3), 16) / 255, this.b = parseInt(b.charAt(4) + b.charAt(5), 16) / 255, this;
        }
      }
    }
    d && 0 < d.length && (b = tf[d], void 0 !== b ? this.setHex(b) : console.warn("THREE.Color: Unknown color " + d));
    return this;
  }, clone:function() {
    return new this.constructor(this.r, this.g, this.b);
  }, copy:function(d) {
    this.r = d.r;
    this.g = d.g;
    this.b = d.b;
    return this;
  }, copyGammaToLinear:function(d, a) {
    void 0 === a && (a = 2);
    this.r = Math.pow(d.r, a);
    this.g = Math.pow(d.g, a);
    this.b = Math.pow(d.b, a);
    return this;
  }, copyLinearToGamma:function(d, a) {
    void 0 === a && (a = 2);
    a = 0 < a ? 1 / a : 1;
    this.r = Math.pow(d.r, a);
    this.g = Math.pow(d.g, a);
    this.b = Math.pow(d.b, a);
    return this;
  }, convertGammaToLinear:function() {
    var d = this.r, a = this.g, b = this.b;
    this.r = d * d;
    this.g = a * a;
    this.b = b * b;
    return this;
  }, convertLinearToGamma:function() {
    this.r = Math.sqrt(this.r);
    this.g = Math.sqrt(this.g);
    this.b = Math.sqrt(this.b);
    return this;
  }, getHex:function() {
    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
  }, getHexString:function() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }, getHSL:function(d) {
    d = d || {h:0, s:0, l:0};
    var a = this.r, b = this.g, c = this.b, e = Math.max(a, b, c), g = Math.min(a, b, c), f, k = (g + e) / 2;
    if (g === e) {
      g = f = 0;
    } else {
      var q = e - g, g = .5 >= k ? q / (e + g) : q / (2 - e - g);
      switch(e) {
        case a:
          f = (b - c) / q + (b < c ? 6 : 0);
          break;
        case b:
          f = (c - a) / q + 2;
          break;
        case c:
          f = (a - b) / q + 4;
      }
      f /= 6;
    }
    d.h = f;
    d.s = g;
    d.l = k;
    return d;
  }, getStyle:function() {
    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
  }, offsetHSL:function(d, a, b) {
    var m = this.getHSL();
    m.h += d;
    m.s += a;
    m.l += b;
    this.setHSL(m.h, m.s, m.l);
    return this;
  }, add:function(d) {
    this.r += d.r;
    this.g += d.g;
    this.b += d.b;
    return this;
  }, addColors:function(d, a) {
    this.r = d.r + a.r;
    this.g = d.g + a.g;
    this.b = d.b + a.b;
    return this;
  }, addScalar:function(d) {
    this.r += d;
    this.g += d;
    this.b += d;
    return this;
  }, sub:function(d) {
    this.r = Math.max(0, this.r - d.r);
    this.g = Math.max(0, this.g - d.g);
    this.b = Math.max(0, this.b - d.b);
    return this;
  }, multiply:function(d) {
    this.r *= d.r;
    this.g *= d.g;
    this.b *= d.b;
    return this;
  }, multiplyScalar:function(d) {
    this.r *= d;
    this.g *= d;
    this.b *= d;
    return this;
  }, lerp:function(d, a) {
    this.r += (d.r - this.r) * a;
    this.g += (d.g - this.g) * a;
    this.b += (d.b - this.b) * a;
    return this;
  }, equals:function(d) {
    return d.r === this.r && d.g === this.g && d.b === this.b;
  }, fromArray:function(d, a) {
    void 0 === a && (a = 0);
    this.r = d[a];
    this.g = d[a + 1];
    this.b = d[a + 2];
    return this;
  }, toArray:function(d, a) {
    void 0 === d && (d = []);
    void 0 === a && (a = 0);
    d[a] = this.r;
    d[a + 1] = this.g;
    d[a + 2] = this.b;
    return d;
  }, toJSON:function() {
    return this.getHex();
  }});
  ra.prototype = Object.create(b.prototype);
  ra.prototype.constructor = ra;
  ra.prototype.isDataTexture = !0;
  var ga = {common:{diffuse:{value:new T(15658734)}, opacity:{value:1}, map:{value:null}, offsetRepeat:{value:new f(0, 0, 1, 1)}, specularMap:{value:null}, alphaMap:{value:null}, envMap:{value:null}, flipEnvMap:{value:-1}, reflectivity:{value:1}, refractionRatio:{value:.98}}, aomap:{aoMap:{value:null}, aoMapIntensity:{value:1}}, lightmap:{lightMap:{value:null}, lightMapIntensity:{value:1}}, emissivemap:{emissiveMap:{value:null}}, bumpmap:{bumpMap:{value:null}, bumpScale:{value:1}}, normalmap:{normalMap:{value:null}, 
  normalScale:{value:new l(1, 1)}}, displacementmap:{displacementMap:{value:null}, displacementScale:{value:1}, displacementBias:{value:0}}, roughnessmap:{roughnessMap:{value:null}}, metalnessmap:{metalnessMap:{value:null}}, gradientmap:{gradientMap:{value:null}}, fog:{fogDensity:{value:2.5E-4}, fogNear:{value:1}, fogFar:{value:2E3}, fogColor:{value:new T(16777215)}}, lights:{ambientLightColor:{value:[]}, directionalLights:{value:[], properties:{direction:{}, color:{}, shadow:{}, shadowBias:{}, shadowRadius:{}, 
  shadowMapSize:{}}}, directionalShadowMap:{value:[]}, directionalShadowMatrix:{value:[]}, spotLights:{value:[], properties:{color:{}, position:{}, direction:{}, distance:{}, coneCos:{}, penumbraCos:{}, decay:{}, shadow:{}, shadowBias:{}, shadowRadius:{}, shadowMapSize:{}}}, spotShadowMap:{value:[]}, spotShadowMatrix:{value:[]}, pointLights:{value:[], properties:{color:{}, position:{}, decay:{}, distance:{}, shadow:{}, shadowBias:{}, shadowRadius:{}, shadowMapSize:{}}}, pointShadowMap:{value:[]}, 
  pointShadowMatrix:{value:[]}, hemisphereLights:{value:[], properties:{direction:{}, skyColor:{}, groundColor:{}}}, rectAreaLights:{value:[], properties:{color:{}, position:{}, width:{}, height:{}}}}, points:{diffuse:{value:new T(15658734)}, opacity:{value:1}, size:{value:1}, scale:{value:1}, map:{value:null}, offsetRepeat:{value:new f(0, 0, 1, 1)}}}, zb = {basic:{uniforms:Sa.merge([ga.common, ga.aomap, ga.lightmap, ga.fog]), vertexShader:na.meshbasic_vert, fragmentShader:na.meshbasic_frag}, lambert:{uniforms:Sa.merge([ga.common, 
  ga.aomap, ga.lightmap, ga.emissivemap, ga.fog, ga.lights, {emissive:{value:new T(0)}}]), vertexShader:na.meshlambert_vert, fragmentShader:na.meshlambert_frag}, phong:{uniforms:Sa.merge([ga.common, ga.aomap, ga.lightmap, ga.emissivemap, ga.bumpmap, ga.normalmap, ga.displacementmap, ga.gradientmap, ga.fog, ga.lights, {emissive:{value:new T(0)}, specular:{value:new T(1118481)}, shininess:{value:30}}]), vertexShader:na.meshphong_vert, fragmentShader:na.meshphong_frag}, standard:{uniforms:Sa.merge([ga.common, 
  ga.aomap, ga.lightmap, ga.emissivemap, ga.bumpmap, ga.normalmap, ga.displacementmap, ga.roughnessmap, ga.metalnessmap, ga.fog, ga.lights, {emissive:{value:new T(0)}, roughness:{value:.5}, metalness:{value:0}, envMapIntensity:{value:1}}]), vertexShader:na.meshphysical_vert, fragmentShader:na.meshphysical_frag}, points:{uniforms:Sa.merge([ga.points, ga.fog]), vertexShader:na.points_vert, fragmentShader:na.points_frag}, dashed:{uniforms:Sa.merge([ga.common, ga.fog, {scale:{value:1}, dashSize:{value:1}, 
  totalSize:{value:2}}]), vertexShader:na.linedashed_vert, fragmentShader:na.linedashed_frag}, depth:{uniforms:Sa.merge([ga.common, ga.displacementmap]), vertexShader:na.depth_vert, fragmentShader:na.depth_frag}, normal:{uniforms:Sa.merge([ga.common, ga.bumpmap, ga.normalmap, ga.displacementmap, {opacity:{value:1}}]), vertexShader:na.normal_vert, fragmentShader:na.normal_frag}, cube:{uniforms:{tCube:{value:null}, tFlip:{value:-1}, opacity:{value:1}}, vertexShader:na.cube_vert, fragmentShader:na.cube_frag}, 
  equirect:{uniforms:{tEquirect:{value:null}, tFlip:{value:-1}}, vertexShader:na.equirect_vert, fragmentShader:na.equirect_frag}, distanceRGBA:{uniforms:{lightPos:{value:new e}}, vertexShader:na.distanceRGBA_vert, fragmentShader:na.distanceRGBA_frag}};
  zb.physical = {uniforms:Sa.merge([zb.standard.uniforms, {clearCoat:{value:0}, clearCoatRoughness:{value:0}}]), vertexShader:na.meshphysical_vert, fragmentShader:na.meshphysical_frag};
  Object.assign(qa.prototype, {set:function(d, a) {
    this.min.copy(d);
    this.max.copy(a);
    return this;
  }, setFromPoints:function(d) {
    this.makeEmpty();
    for (var a = 0, b = d.length;a < b;a++) {
      this.expandByPoint(d[a]);
    }
    return this;
  }, setFromCenterAndSize:function() {
    var d = new l;
    return function(a, b) {
      b = d.copy(b).multiplyScalar(.5);
      this.min.copy(a).sub(b);
      this.max.copy(a).add(b);
      return this;
    };
  }(), clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(d) {
    this.min.copy(d.min);
    this.max.copy(d.max);
    return this;
  }, makeEmpty:function() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }, isEmpty:function() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }, getCenter:function(d) {
    d = d || new l;
    return this.isEmpty() ? d.set(0, 0) : d.addVectors(this.min, this.max).multiplyScalar(.5);
  }, getSize:function(d) {
    d = d || new l;
    return this.isEmpty() ? d.set(0, 0) : d.subVectors(this.max, this.min);
  }, expandByPoint:function(d) {
    this.min.min(d);
    this.max.max(d);
    return this;
  }, expandByVector:function(d) {
    this.min.sub(d);
    this.max.add(d);
    return this;
  }, expandByScalar:function(d) {
    this.min.addScalar(-d);
    this.max.addScalar(d);
    return this;
  }, containsPoint:function(d) {
    return d.x < this.min.x || d.x > this.max.x || d.y < this.min.y || d.y > this.max.y ? !1 : !0;
  }, containsBox:function(d) {
    return this.min.x <= d.min.x && d.max.x <= this.max.x && this.min.y <= d.min.y && d.max.y <= this.max.y;
  }, getParameter:function(d, a) {
    return (a || new l).set((d.x - this.min.x) / (this.max.x - this.min.x), (d.y - this.min.y) / (this.max.y - this.min.y));
  }, intersectsBox:function(d) {
    return d.max.x < this.min.x || d.min.x > this.max.x || d.max.y < this.min.y || d.min.y > this.max.y ? !1 : !0;
  }, clampPoint:function(d, a) {
    return (a || new l).copy(d).clamp(this.min, this.max);
  }, distanceToPoint:function() {
    var d = new l;
    return function(a) {
      return d.copy(a).clamp(this.min, this.max).sub(a).length();
    };
  }(), intersect:function(d) {
    this.min.max(d.min);
    this.max.min(d.max);
    return this;
  }, union:function(d) {
    this.min.min(d.min);
    this.max.max(d.max);
    return this;
  }, translate:function(d) {
    this.min.add(d);
    this.max.add(d);
    return this;
  }, equals:function(d) {
    return d.min.equals(this.min) && d.max.equals(this.max);
  }});
  var af = 0;
  Object.defineProperty(W.prototype, "needsUpdate", {get:function() {
    return this._needsUpdate;
  }, set:function(d) {
    !0 === d && this.update();
    this._needsUpdate = d;
  }});
  Object.assign(W.prototype, h.prototype, {isMaterial:!0, setValues:function(d) {
    if (void 0 !== d) {
      for (var a in d) {
        var b = d[a];
        if (void 0 === b) {
          console.warn("THREE.Material: '" + a + "' parameter is undefined.");
        } else {
          var c = this[a];
          void 0 === c ? console.warn("THREE." + this.type + ": '" + a + "' is not a property of this material.") : c && c.isColor ? c.set(b) : c && c.isVector3 && b && b.isVector3 ? c.copy(b) : this[a] = "overdraw" === a ? Number(b) : b;
        }
      }
    }
  }, toJSON:function(d) {
    function a(d) {
      var a = [], b;
      for (b in d) {
        var m = d[b];
        delete m.metadata;
        a.push(m);
      }
      return a;
    }
    var b = void 0 === d;
    b && (d = {textures:{}, images:{}});
    var c = {metadata:{version:4.4, type:"Material", generator:"Material.toJSON"}};
    c.uuid = this.uuid;
    c.type = this.type;
    "" !== this.name && (c.name = this.name);
    this.color && this.color.isColor && (c.color = this.color.getHex());
    void 0 !== this.roughness && (c.roughness = this.roughness);
    void 0 !== this.metalness && (c.metalness = this.metalness);
    this.emissive && this.emissive.isColor && (c.emissive = this.emissive.getHex());
    this.specular && this.specular.isColor && (c.specular = this.specular.getHex());
    void 0 !== this.shininess && (c.shininess = this.shininess);
    void 0 !== this.clearCoat && (c.clearCoat = this.clearCoat);
    void 0 !== this.clearCoatRoughness && (c.clearCoatRoughness = this.clearCoatRoughness);
    this.map && this.map.isTexture && (c.map = this.map.toJSON(d).uuid);
    this.alphaMap && this.alphaMap.isTexture && (c.alphaMap = this.alphaMap.toJSON(d).uuid);
    this.lightMap && this.lightMap.isTexture && (c.lightMap = this.lightMap.toJSON(d).uuid);
    this.bumpMap && this.bumpMap.isTexture && (c.bumpMap = this.bumpMap.toJSON(d).uuid, c.bumpScale = this.bumpScale);
    this.normalMap && this.normalMap.isTexture && (c.normalMap = this.normalMap.toJSON(d).uuid, c.normalScale = this.normalScale.toArray());
    this.displacementMap && this.displacementMap.isTexture && (c.displacementMap = this.displacementMap.toJSON(d).uuid, c.displacementScale = this.displacementScale, c.displacementBias = this.displacementBias);
    this.roughnessMap && this.roughnessMap.isTexture && (c.roughnessMap = this.roughnessMap.toJSON(d).uuid);
    this.metalnessMap && this.metalnessMap.isTexture && (c.metalnessMap = this.metalnessMap.toJSON(d).uuid);
    this.emissiveMap && this.emissiveMap.isTexture && (c.emissiveMap = this.emissiveMap.toJSON(d).uuid);
    this.specularMap && this.specularMap.isTexture && (c.specularMap = this.specularMap.toJSON(d).uuid);
    this.envMap && this.envMap.isTexture && (c.envMap = this.envMap.toJSON(d).uuid, c.reflectivity = this.reflectivity);
    this.gradientMap && this.gradientMap.isTexture && (c.gradientMap = this.gradientMap.toJSON(d).uuid);
    void 0 !== this.size && (c.size = this.size);
    void 0 !== this.sizeAttenuation && (c.sizeAttenuation = this.sizeAttenuation);
    1 !== this.blending && (c.blending = this.blending);
    2 !== this.shading && (c.shading = this.shading);
    0 !== this.side && (c.side = this.side);
    0 !== this.vertexColors && (c.vertexColors = this.vertexColors);
    1 > this.opacity && (c.opacity = this.opacity);
    !0 === this.transparent && (c.transparent = this.transparent);
    c.depthFunc = this.depthFunc;
    c.depthTest = this.depthTest;
    c.depthWrite = this.depthWrite;
    0 < this.alphaTest && (c.alphaTest = this.alphaTest);
    !0 === this.premultipliedAlpha && (c.premultipliedAlpha = this.premultipliedAlpha);
    !0 === this.wireframe && (c.wireframe = this.wireframe);
    1 < this.wireframeLinewidth && (c.wireframeLinewidth = this.wireframeLinewidth);
    "round" !== this.wireframeLinecap && (c.wireframeLinecap = this.wireframeLinecap);
    "round" !== this.wireframeLinejoin && (c.wireframeLinejoin = this.wireframeLinejoin);
    c.morphTargets = this.morphTargets;
    b && (b = a(d.textures), d = a(d.images), 0 < b.length && (c.textures = b), 0 < d.length && (c.images = d));
    return c;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(d) {
    this.name = d.name;
    this.fog = d.fog;
    this.lights = d.lights;
    this.blending = d.blending;
    this.side = d.side;
    this.shading = d.shading;
    this.vertexColors = d.vertexColors;
    this.opacity = d.opacity;
    this.transparent = d.transparent;
    this.blendSrc = d.blendSrc;
    this.blendDst = d.blendDst;
    this.blendEquation = d.blendEquation;
    this.blendSrcAlpha = d.blendSrcAlpha;
    this.blendDstAlpha = d.blendDstAlpha;
    this.blendEquationAlpha = d.blendEquationAlpha;
    this.depthFunc = d.depthFunc;
    this.depthTest = d.depthTest;
    this.depthWrite = d.depthWrite;
    this.colorWrite = d.colorWrite;
    this.precision = d.precision;
    this.polygonOffset = d.polygonOffset;
    this.polygonOffsetFactor = d.polygonOffsetFactor;
    this.polygonOffsetUnits = d.polygonOffsetUnits;
    this.alphaTest = d.alphaTest;
    this.premultipliedAlpha = d.premultipliedAlpha;
    this.overdraw = d.overdraw;
    this.visible = d.visible;
    this.clipShadows = d.clipShadows;
    this.clipIntersection = d.clipIntersection;
    d = d.clippingPlanes;
    var a = null;
    if (null !== d) {
      for (var b = d.length, a = Array(b), c = 0;c !== b;++c) {
        a[c] = d[c].clone();
      }
    }
    this.clippingPlanes = a;
    return this;
  }, update:function() {
    this.dispatchEvent({type:"update"});
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }});
  sa.prototype = Object.create(W.prototype);
  sa.prototype.constructor = sa;
  sa.prototype.isShaderMaterial = !0;
  sa.prototype.copy = function(d) {
    W.prototype.copy.call(this, d);
    this.fragmentShader = d.fragmentShader;
    this.vertexShader = d.vertexShader;
    this.uniforms = Sa.clone(d.uniforms);
    this.defines = d.defines;
    this.wireframe = d.wireframe;
    this.wireframeLinewidth = d.wireframeLinewidth;
    this.lights = d.lights;
    this.clipping = d.clipping;
    this.morphTargets = d.morphTargets;
    this.morphNormals = d.morphNormals;
    this.extensions = d.extensions;
    return this;
  };
  sa.prototype.toJSON = function(d) {
    d = W.prototype.toJSON.call(this, d);
    d.uniforms = this.uniforms;
    d.vertexShader = this.vertexShader;
    d.fragmentShader = this.fragmentShader;
    return d;
  };
  xa.prototype = Object.create(W.prototype);
  xa.prototype.constructor = xa;
  xa.prototype.isMeshDepthMaterial = !0;
  xa.prototype.copy = function(d) {
    W.prototype.copy.call(this, d);
    this.depthPacking = d.depthPacking;
    this.morphTargets = d.morphTargets;
    this.map = d.map;
    this.alphaMap = d.alphaMap;
    this.displacementMap = d.displacementMap;
    this.displacementScale = d.displacementScale;
    this.displacementBias = d.displacementBias;
    this.wireframe = d.wireframe;
    this.wireframeLinewidth = d.wireframeLinewidth;
    return this;
  };
  Object.assign(Aa.prototype, {isBox3:!0, set:function(d, a) {
    this.min.copy(d);
    this.max.copy(a);
    return this;
  }, setFromArray:function(d) {
    for (var a = Infinity, b = Infinity, c = Infinity, e = -Infinity, g = -Infinity, f = -Infinity, k = 0, q = d.length;k < q;k += 3) {
      var p = d[k], h = d[k + 1], n = d[k + 2];
      p < a && (a = p);
      h < b && (b = h);
      n < c && (c = n);
      p > e && (e = p);
      h > g && (g = h);
      n > f && (f = n);
    }
    this.min.set(a, b, c);
    this.max.set(e, g, f);
    return this;
  }, setFromBufferAttribute:function(d) {
    for (var a = Infinity, b = Infinity, c = Infinity, e = -Infinity, g = -Infinity, f = -Infinity, k = 0, q = d.count;k < q;k++) {
      var p = d.getX(k), h = d.getY(k), n = d.getZ(k);
      p < a && (a = p);
      h < b && (b = h);
      n < c && (c = n);
      p > e && (e = p);
      h > g && (g = h);
      n > f && (f = n);
    }
    this.min.set(a, b, c);
    this.max.set(e, g, f);
    return this;
  }, setFromPoints:function(d) {
    this.makeEmpty();
    for (var a = 0, b = d.length;a < b;a++) {
      this.expandByPoint(d[a]);
    }
    return this;
  }, setFromCenterAndSize:function() {
    var d = new e;
    return function(a, b) {
      b = d.copy(b).multiplyScalar(.5);
      this.min.copy(a).sub(b);
      this.max.copy(a).add(b);
      return this;
    };
  }(), setFromObject:function(d) {
    this.makeEmpty();
    return this.expandByObject(d);
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(d) {
    this.min.copy(d.min);
    this.max.copy(d.max);
    return this;
  }, makeEmpty:function() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }, isEmpty:function() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }, getCenter:function(d) {
    d = d || new e;
    return this.isEmpty() ? d.set(0, 0, 0) : d.addVectors(this.min, this.max).multiplyScalar(.5);
  }, getSize:function(d) {
    d = d || new e;
    return this.isEmpty() ? d.set(0, 0, 0) : d.subVectors(this.max, this.min);
  }, expandByPoint:function(d) {
    this.min.min(d);
    this.max.max(d);
    return this;
  }, expandByVector:function(d) {
    this.min.sub(d);
    this.max.add(d);
    return this;
  }, expandByScalar:function(d) {
    this.min.addScalar(-d);
    this.max.addScalar(d);
    return this;
  }, expandByObject:function() {
    var d = new e;
    return function(a) {
      var b = this;
      a.updateMatrixWorld(!0);
      a.traverse(function(a) {
        var m, c;
        m = a.geometry;
        if (void 0 !== m) {
          if (m.isGeometry) {
            var e = m.vertices;
            m = 0;
            for (c = e.length;m < c;m++) {
              d.copy(e[m]), d.applyMatrix4(a.matrixWorld), b.expandByPoint(d);
            }
          } else {
            if (m.isBufferGeometry && (e = m.attributes.position, void 0 !== e)) {
              for (m = 0, c = e.count;m < c;m++) {
                d.fromBufferAttribute(e, m).applyMatrix4(a.matrixWorld), b.expandByPoint(d);
              }
            }
          }
        }
      });
      return this;
    };
  }(), containsPoint:function(d) {
    return d.x < this.min.x || d.x > this.max.x || d.y < this.min.y || d.y > this.max.y || d.z < this.min.z || d.z > this.max.z ? !1 : !0;
  }, containsBox:function(d) {
    return this.min.x <= d.min.x && d.max.x <= this.max.x && this.min.y <= d.min.y && d.max.y <= this.max.y && this.min.z <= d.min.z && d.max.z <= this.max.z;
  }, getParameter:function(d, a) {
    return (a || new e).set((d.x - this.min.x) / (this.max.x - this.min.x), (d.y - this.min.y) / (this.max.y - this.min.y), (d.z - this.min.z) / (this.max.z - this.min.z));
  }, intersectsBox:function(d) {
    return d.max.x < this.min.x || d.min.x > this.max.x || d.max.y < this.min.y || d.min.y > this.max.y || d.max.z < this.min.z || d.min.z > this.max.z ? !1 : !0;
  }, intersectsSphere:function() {
    var d = new e;
    return function(a) {
      this.clampPoint(a.center, d);
      return d.distanceToSquared(a.center) <= a.radius * a.radius;
    };
  }(), intersectsPlane:function(d) {
    var a, b;
    0 < d.normal.x ? (a = d.normal.x * this.min.x, b = d.normal.x * this.max.x) : (a = d.normal.x * this.max.x, b = d.normal.x * this.min.x);
    0 < d.normal.y ? (a += d.normal.y * this.min.y, b += d.normal.y * this.max.y) : (a += d.normal.y * this.max.y, b += d.normal.y * this.min.y);
    0 < d.normal.z ? (a += d.normal.z * this.min.z, b += d.normal.z * this.max.z) : (a += d.normal.z * this.max.z, b += d.normal.z * this.min.z);
    return a <= d.constant && b >= d.constant;
  }, clampPoint:function(d, a) {
    return (a || new e).copy(d).clamp(this.min, this.max);
  }, distanceToPoint:function() {
    var d = new e;
    return function(a) {
      return d.copy(a).clamp(this.min, this.max).sub(a).length();
    };
  }(), getBoundingSphere:function() {
    var d = new e;
    return function(a) {
      a = a || new Ba;
      this.getCenter(a.center);
      a.radius = .5 * this.getSize(d).length();
      return a;
    };
  }(), intersect:function(d) {
    this.min.max(d.min);
    this.max.min(d.max);
    this.isEmpty() && this.makeEmpty();
    return this;
  }, union:function(d) {
    this.min.min(d.min);
    this.max.max(d.max);
    return this;
  }, applyMatrix4:function() {
    var d = [new e, new e, new e, new e, new e, new e, new e, new e];
    return function(a) {
      if (this.isEmpty()) {
        return this;
      }
      d[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(a);
      d[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(a);
      d[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(a);
      d[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(a);
      d[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(a);
      d[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(a);
      d[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(a);
      d[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(a);
      this.setFromPoints(d);
      return this;
    };
  }(), translate:function(d) {
    this.min.add(d);
    this.max.add(d);
    return this;
  }, equals:function(d) {
    return d.min.equals(this.min) && d.max.equals(this.max);
  }});
  Object.assign(Ba.prototype, {set:function(d, a) {
    this.center.copy(d);
    this.radius = a;
    return this;
  }, setFromPoints:function() {
    var d = new Aa;
    return function(a, b) {
      var m = this.center;
      void 0 !== b ? m.copy(b) : d.setFromPoints(a).getCenter(m);
      for (var c = b = 0, e = a.length;c < e;c++) {
        b = Math.max(b, m.distanceToSquared(a[c]));
      }
      this.radius = Math.sqrt(b);
      return this;
    };
  }(), clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(d) {
    this.center.copy(d.center);
    this.radius = d.radius;
    return this;
  }, empty:function() {
    return 0 >= this.radius;
  }, containsPoint:function(d) {
    return d.distanceToSquared(this.center) <= this.radius * this.radius;
  }, distanceToPoint:function(d) {
    return d.distanceTo(this.center) - this.radius;
  }, intersectsSphere:function(d) {
    var a = this.radius + d.radius;
    return d.center.distanceToSquared(this.center) <= a * a;
  }, intersectsBox:function(d) {
    return d.intersectsSphere(this);
  }, intersectsPlane:function(d) {
    return Math.abs(this.center.dot(d.normal) - d.constant) <= this.radius;
  }, clampPoint:function(d, a) {
    var b = this.center.distanceToSquared(d);
    a = a || new e;
    a.copy(d);
    b > this.radius * this.radius && (a.sub(this.center).normalize(), a.multiplyScalar(this.radius).add(this.center));
    return a;
  }, getBoundingBox:function(d) {
    d = d || new Aa;
    d.set(this.center, this.center);
    d.expandByScalar(this.radius);
    return d;
  }, applyMatrix4:function(d) {
    this.center.applyMatrix4(d);
    this.radius *= d.getMaxScaleOnAxis();
    return this;
  }, translate:function(d) {
    this.center.add(d);
    return this;
  }, equals:function(d) {
    return d.center.equals(this.center) && d.radius === this.radius;
  }});
  Object.assign(ya.prototype, {isMatrix3:!0, set:function(d, a, b, c, e, g, f, k, q) {
    var m = this.elements;
    m[0] = d;
    m[1] = c;
    m[2] = f;
    m[3] = a;
    m[4] = e;
    m[5] = k;
    m[6] = b;
    m[7] = g;
    m[8] = q;
    return this;
  }, identity:function() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }, clone:function() {
    return (new this.constructor).fromArray(this.elements);
  }, copy:function(d) {
    var a = this.elements;
    d = d.elements;
    for (var b = 0;9 > b;b++) {
      a[b] = d[b];
    }
    return this;
  }, setFromMatrix4:function(d) {
    d = d.elements;
    this.set(d[0], d[4], d[8], d[1], d[5], d[9], d[2], d[6], d[10]);
    return this;
  }, applyToBufferAttribute:function() {
    var d = new e;
    return function(a) {
      for (var b = 0, m = a.count;b < m;b++) {
        d.x = a.getX(b), d.y = a.getY(b), d.z = a.getZ(b), d.applyMatrix3(this), a.setXYZ(b, d.x, d.y, d.z);
      }
      return a;
    };
  }(), multiplyScalar:function(d) {
    var a = this.elements;
    a[0] *= d;
    a[3] *= d;
    a[6] *= d;
    a[1] *= d;
    a[4] *= d;
    a[7] *= d;
    a[2] *= d;
    a[5] *= d;
    a[8] *= d;
    return this;
  }, determinant:function() {
    var d = this.elements, a = d[0], b = d[1], c = d[2], e = d[3], g = d[4], f = d[5], k = d[6], q = d[7], d = d[8];
    return a * g * d - a * f * q - b * e * d + b * f * k + c * e * q - c * g * k;
  }, getInverse:function(d, a) {
    d && d.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
    d = d.elements;
    var b = this.elements, m = d[0], c = d[1], e = d[2], g = d[3], f = d[4], k = d[5], q = d[6], p = d[7];
    d = d[8];
    var h = d * f - k * p, n = k * q - d * g, r = p * g - f * q, l = m * h + c * n + e * r;
    if (0 === l) {
      if (!0 === a) {
        throw Error("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
      }
      console.warn("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
      return this.identity();
    }
    l = 1 / l;
    b[0] = h * l;
    b[1] = (e * p - d * c) * l;
    b[2] = (k * c - e * f) * l;
    b[3] = n * l;
    b[4] = (d * m - e * q) * l;
    b[5] = (e * g - k * m) * l;
    b[6] = r * l;
    b[7] = (c * q - p * m) * l;
    b[8] = (f * m - c * g) * l;
    return this;
  }, transpose:function() {
    var d, a = this.elements;
    d = a[1];
    a[1] = a[3];
    a[3] = d;
    d = a[2];
    a[2] = a[6];
    a[6] = d;
    d = a[5];
    a[5] = a[7];
    a[7] = d;
    return this;
  }, getNormalMatrix:function(d) {
    return this.setFromMatrix4(d).getInverse(this).transpose();
  }, transposeIntoArray:function(d) {
    var a = this.elements;
    d[0] = a[0];
    d[1] = a[3];
    d[2] = a[6];
    d[3] = a[1];
    d[4] = a[4];
    d[5] = a[7];
    d[6] = a[2];
    d[7] = a[5];
    d[8] = a[8];
    return this;
  }, fromArray:function(d, a) {
    void 0 === a && (a = 0);
    for (var b = 0;9 > b;b++) {
      this.elements[b] = d[b + a];
    }
    return this;
  }, toArray:function(d, a) {
    void 0 === d && (d = []);
    void 0 === a && (a = 0);
    var b = this.elements;
    d[a] = b[0];
    d[a + 1] = b[1];
    d[a + 2] = b[2];
    d[a + 3] = b[3];
    d[a + 4] = b[4];
    d[a + 5] = b[5];
    d[a + 6] = b[6];
    d[a + 7] = b[7];
    d[a + 8] = b[8];
    return d;
  }});
  Object.assign(Ea.prototype, {set:function(d, a) {
    this.normal.copy(d);
    this.constant = a;
    return this;
  }, setComponents:function(d, a, b, c) {
    this.normal.set(d, a, b);
    this.constant = c;
    return this;
  }, setFromNormalAndCoplanarPoint:function(d, a) {
    this.normal.copy(d);
    this.constant = -a.dot(this.normal);
    return this;
  }, setFromCoplanarPoints:function() {
    var d = new e, a = new e;
    return function(b, m, c) {
      m = d.subVectors(c, m).cross(a.subVectors(b, m)).normalize();
      this.setFromNormalAndCoplanarPoint(m, b);
      return this;
    };
  }(), clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(d) {
    this.normal.copy(d.normal);
    this.constant = d.constant;
    return this;
  }, normalize:function() {
    var d = 1 / this.normal.length();
    this.normal.multiplyScalar(d);
    this.constant *= d;
    return this;
  }, negate:function() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }, distanceToPoint:function(d) {
    return this.normal.dot(d) + this.constant;
  }, distanceToSphere:function(d) {
    return this.distanceToPoint(d.center) - d.radius;
  }, projectPoint:function(d, a) {
    return this.orthoPoint(d, a).sub(d).negate();
  }, orthoPoint:function(d, a) {
    d = this.distanceToPoint(d);
    return (a || new e).copy(this.normal).multiplyScalar(d);
  }, intersectLine:function() {
    var d = new e;
    return function(a, b) {
      b = b || new e;
      var m = a.delta(d), c = this.normal.dot(m);
      if (0 === c) {
        if (0 === this.distanceToPoint(a.start)) {
          return b.copy(a.start);
        }
      } else {
        return c = -(a.start.dot(this.normal) + this.constant) / c, 0 > c || 1 < c ? void 0 : b.copy(m).multiplyScalar(c).add(a.start);
      }
    };
  }(), intersectsLine:function(d) {
    var a = this.distanceToPoint(d.start);
    d = this.distanceToPoint(d.end);
    return 0 > a && 0 < d || 0 > d && 0 < a;
  }, intersectsBox:function(d) {
    return d.intersectsPlane(this);
  }, intersectsSphere:function(d) {
    return d.intersectsPlane(this);
  }, coplanarPoint:function(d) {
    return (d || new e).copy(this.normal).multiplyScalar(-this.constant);
  }, applyMatrix4:function() {
    var d = new e, a = new ya;
    return function(b, m) {
      var c = this.coplanarPoint(d).applyMatrix4(b);
      b = m || a.getNormalMatrix(b);
      b = this.normal.applyMatrix3(b).normalize();
      this.constant = -c.dot(b);
      return this;
    };
  }(), translate:function(d) {
    this.constant -= d.dot(this.normal);
    return this;
  }, equals:function(d) {
    return d.normal.equals(this.normal) && d.constant === this.constant;
  }});
  Object.assign(Xa.prototype, {set:function(d, a, b, c, e, g) {
    var m = this.planes;
    m[0].copy(d);
    m[1].copy(a);
    m[2].copy(b);
    m[3].copy(c);
    m[4].copy(e);
    m[5].copy(g);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(d) {
    for (var a = this.planes, b = 0;6 > b;b++) {
      a[b].copy(d.planes[b]);
    }
    return this;
  }, setFromMatrix:function(d) {
    var a = this.planes, b = d.elements;
    d = b[0];
    var c = b[1], e = b[2], g = b[3], f = b[4], k = b[5], q = b[6], p = b[7], h = b[8], n = b[9], r = b[10], l = b[11], u = b[12], w = b[13], t = b[14], b = b[15];
    a[0].setComponents(g - d, p - f, l - h, b - u).normalize();
    a[1].setComponents(g + d, p + f, l + h, b + u).normalize();
    a[2].setComponents(g + c, p + k, l + n, b + w).normalize();
    a[3].setComponents(g - c, p - k, l - n, b - w).normalize();
    a[4].setComponents(g - e, p - q, l - r, b - t).normalize();
    a[5].setComponents(g + e, p + q, l + r, b + t).normalize();
    return this;
  }, intersectsObject:function() {
    var d = new Ba;
    return function(a) {
      var b = a.geometry;
      null === b.boundingSphere && b.computeBoundingSphere();
      d.copy(b.boundingSphere).applyMatrix4(a.matrixWorld);
      return this.intersectsSphere(d);
    };
  }(), intersectsSprite:function() {
    var d = new Ba;
    return function(a) {
      d.center.set(0, 0, 0);
      d.radius = .7071067811865476;
      d.applyMatrix4(a.matrixWorld);
      return this.intersectsSphere(d);
    };
  }(), intersectsSphere:function(d) {
    var a = this.planes, b = d.center;
    d = -d.radius;
    for (var c = 0;6 > c;c++) {
      if (a[c].distanceToPoint(b) < d) {
        return !1;
      }
    }
    return !0;
  }, intersectsBox:function() {
    var d = new e, a = new e;
    return function(b) {
      for (var m = this.planes, c = 0;6 > c;c++) {
        var e = m[c];
        d.x = 0 < e.normal.x ? b.min.x : b.max.x;
        a.x = 0 < e.normal.x ? b.max.x : b.min.x;
        d.y = 0 < e.normal.y ? b.min.y : b.max.y;
        a.y = 0 < e.normal.y ? b.max.y : b.min.y;
        d.z = 0 < e.normal.z ? b.min.z : b.max.z;
        a.z = 0 < e.normal.z ? b.max.z : b.min.z;
        var g = e.distanceToPoint(d), e = e.distanceToPoint(a);
        if (0 > g && 0 > e) {
          return !1;
        }
      }
      return !0;
    };
  }(), containsPoint:function(d) {
    for (var a = this.planes, b = 0;6 > b;b++) {
      if (0 > a[b].distanceToPoint(d)) {
        return !1;
      }
    }
    return !0;
  }});
  Object.assign(Ta.prototype, {set:function(d, a) {
    this.origin.copy(d);
    this.direction.copy(a);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(d) {
    this.origin.copy(d.origin);
    this.direction.copy(d.direction);
    return this;
  }, at:function(d, a) {
    return (a || new e).copy(this.direction).multiplyScalar(d).add(this.origin);
  }, lookAt:function(d) {
    this.direction.copy(d).sub(this.origin).normalize();
    return this;
  }, recast:function() {
    var d = new e;
    return function(a) {
      this.origin.copy(this.at(a, d));
      return this;
    };
  }(), closestPointToPoint:function(d, a) {
    a = a || new e;
    a.subVectors(d, this.origin);
    d = a.dot(this.direction);
    return 0 > d ? a.copy(this.origin) : a.copy(this.direction).multiplyScalar(d).add(this.origin);
  }, distanceToPoint:function(d) {
    return Math.sqrt(this.distanceSqToPoint(d));
  }, distanceSqToPoint:function() {
    var d = new e;
    return function(a) {
      var b = d.subVectors(a, this.origin).dot(this.direction);
      if (0 > b) {
        return this.origin.distanceToSquared(a);
      }
      d.copy(this.direction).multiplyScalar(b).add(this.origin);
      return d.distanceToSquared(a);
    };
  }(), distanceSqToSegment:function() {
    var d = new e, a = new e, b = new e;
    return function(m, c, e, g) {
      d.copy(m).add(c).multiplyScalar(.5);
      a.copy(c).sub(m).normalize();
      b.copy(this.origin).sub(d);
      var f = .5 * m.distanceTo(c), k = -this.direction.dot(a), q = b.dot(this.direction), p = -b.dot(a), h = b.lengthSq(), n = Math.abs(1 - k * k), r;
      0 < n ? (m = k * p - q, c = k * q - p, r = f * n, 0 <= m ? c >= -r ? c <= r ? (f = 1 / n, m *= f, c *= f, k = m * (m + k * c + 2 * q) + c * (k * m + c + 2 * p) + h) : (c = f, m = Math.max(0, -(k * c + q)), k = -m * m + c * (c + 2 * p) + h) : (c = -f, m = Math.max(0, -(k * c + q)), k = -m * m + c * (c + 2 * p) + h) : c <= -r ? (m = Math.max(0, -(-k * f + q)), c = 0 < m ? -f : Math.min(Math.max(-f, -p), f), k = -m * m + c * (c + 2 * p) + h) : c <= r ? (m = 0, c = Math.min(Math.max(-f, -p), f), 
      k = c * (c + 2 * p) + h) : (m = Math.max(0, -(k * f + q)), c = 0 < m ? f : Math.min(Math.max(-f, -p), f), k = -m * m + c * (c + 2 * p) + h)) : (c = 0 < k ? -f : f, m = Math.max(0, -(k * c + q)), k = -m * m + c * (c + 2 * p) + h);
      e && e.copy(this.direction).multiplyScalar(m).add(this.origin);
      g && g.copy(a).multiplyScalar(c).add(d);
      return k;
    };
  }(), intersectSphere:function() {
    var d = new e;
    return function(a, b) {
      d.subVectors(a.center, this.origin);
      var m = d.dot(this.direction), c = d.dot(d) - m * m;
      a = a.radius * a.radius;
      if (c > a) {
        return null;
      }
      a = Math.sqrt(a - c);
      c = m - a;
      m += a;
      return 0 > c && 0 > m ? null : 0 > c ? this.at(m, b) : this.at(c, b);
    };
  }(), intersectsSphere:function(d) {
    return this.distanceToPoint(d.center) <= d.radius;
  }, distanceToPlane:function(d) {
    var a = d.normal.dot(this.direction);
    if (0 === a) {
      return 0 === d.distanceToPoint(this.origin) ? 0 : null;
    }
    d = -(this.origin.dot(d.normal) + d.constant) / a;
    return 0 <= d ? d : null;
  }, intersectPlane:function(d, a) {
    d = this.distanceToPlane(d);
    return null === d ? null : this.at(d, a);
  }, intersectsPlane:function(d) {
    var a = d.distanceToPoint(this.origin);
    return 0 === a || 0 > d.normal.dot(this.direction) * a ? !0 : !1;
  }, intersectBox:function(d, a) {
    var b, m, c, e, g;
    m = 1 / this.direction.x;
    e = 1 / this.direction.y;
    g = 1 / this.direction.z;
    var f = this.origin;
    0 <= m ? (b = (d.min.x - f.x) * m, m *= d.max.x - f.x) : (b = (d.max.x - f.x) * m, m *= d.min.x - f.x);
    0 <= e ? (c = (d.min.y - f.y) * e, e *= d.max.y - f.y) : (c = (d.max.y - f.y) * e, e *= d.min.y - f.y);
    if (b > e || c > m) {
      return null;
    }
    if (c > b || b !== b) {
      b = c;
    }
    if (e < m || m !== m) {
      m = e;
    }
    0 <= g ? (c = (d.min.z - f.z) * g, g *= d.max.z - f.z) : (c = (d.max.z - f.z) * g, g *= d.min.z - f.z);
    if (b > g || c > m) {
      return null;
    }
    if (c > b || b !== b) {
      b = c;
    }
    if (g < m || m !== m) {
      m = g;
    }
    return 0 > m ? null : this.at(0 <= b ? b : m, a);
  }, intersectsBox:function() {
    var d = new e;
    return function(a) {
      return null !== this.intersectBox(a, d);
    };
  }(), intersectTriangle:function() {
    var d = new e, a = new e, b = new e, c = new e;
    return function(m, e, g, f, k) {
      a.subVectors(e, m);
      b.subVectors(g, m);
      c.crossVectors(a, b);
      e = this.direction.dot(c);
      if (0 < e) {
        if (f) {
          return null;
        }
        f = 1;
      } else {
        if (0 > e) {
          f = -1, e = -e;
        } else {
          return null;
        }
      }
      d.subVectors(this.origin, m);
      m = f * this.direction.dot(b.crossVectors(d, b));
      if (0 > m) {
        return null;
      }
      g = f * this.direction.dot(a.cross(d));
      if (0 > g || m + g > e) {
        return null;
      }
      m = -f * d.dot(c);
      return 0 > m ? null : this.at(m / e, k);
    };
  }(), applyMatrix4:function(d) {
    this.direction.add(this.origin).applyMatrix4(d);
    this.origin.applyMatrix4(d);
    this.direction.sub(this.origin);
    this.direction.normalize();
    return this;
  }, equals:function(d) {
    return d.origin.equals(this.origin) && d.direction.equals(this.direction);
  }});
  Ua.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
  Ua.DefaultOrder = "XYZ";
  Object.defineProperties(Ua.prototype, {x:{get:function() {
    return this._x;
  }, set:function(d) {
    this._x = d;
    this.onChangeCallback();
  }}, y:{get:function() {
    return this._y;
  }, set:function(d) {
    this._y = d;
    this.onChangeCallback();
  }}, z:{get:function() {
    return this._z;
  }, set:function(d) {
    this._z = d;
    this.onChangeCallback();
  }}, order:{get:function() {
    return this._order;
  }, set:function(d) {
    this._order = d;
    this.onChangeCallback();
  }}});
  Object.assign(Ua.prototype, {isEuler:!0, set:function(d, a, b, c) {
    this._x = d;
    this._y = a;
    this._z = b;
    this._order = c || this._order;
    this.onChangeCallback();
    return this;
  }, clone:function() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }, copy:function(d) {
    this._x = d._x;
    this._y = d._y;
    this._z = d._z;
    this._order = d._order;
    this.onChangeCallback();
    return this;
  }, setFromRotationMatrix:function(d, a, b) {
    var m = ka.clamp, c = d.elements;
    d = c[0];
    var e = c[4], g = c[8], f = c[1], k = c[5], q = c[9], p = c[2], h = c[6], c = c[10];
    a = a || this._order;
    "XYZ" === a ? (this._y = Math.asin(m(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-q, c), this._z = Math.atan2(-e, d)) : (this._x = Math.atan2(h, k), this._z = 0)) : "YXZ" === a ? (this._x = Math.asin(-m(q, -1, 1)), .99999 > Math.abs(q) ? (this._y = Math.atan2(g, c), this._z = Math.atan2(f, k)) : (this._y = Math.atan2(-p, d), this._z = 0)) : "ZXY" === a ? (this._x = Math.asin(m(h, -1, 1)), .99999 > Math.abs(h) ? (this._y = Math.atan2(-p, c), this._z = Math.atan2(-e, k)) : (this._y = 
    0, this._z = Math.atan2(f, d))) : "ZYX" === a ? (this._y = Math.asin(-m(p, -1, 1)), .99999 > Math.abs(p) ? (this._x = Math.atan2(h, c), this._z = Math.atan2(f, d)) : (this._x = 0, this._z = Math.atan2(-e, k))) : "YZX" === a ? (this._z = Math.asin(m(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(-q, k), this._y = Math.atan2(-p, d)) : (this._x = 0, this._y = Math.atan2(g, c))) : "XZY" === a ? (this._z = Math.asin(-m(e, -1, 1)), .99999 > Math.abs(e) ? (this._x = Math.atan2(h, k), this._y = 
    Math.atan2(g, d)) : (this._x = Math.atan2(-q, c), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + a);
    this._order = a;
    if (!1 !== b) {
      this.onChangeCallback();
    }
    return this;
  }, setFromQuaternion:function() {
    var d = new p;
    return function(a, b, c) {
      d.makeRotationFromQuaternion(a);
      return this.setFromRotationMatrix(d, b, c);
    };
  }(), setFromVector3:function(d, a) {
    return this.set(d.x, d.y, d.z, a || this._order);
  }, reorder:function() {
    var d = new g;
    return function(a) {
      d.setFromEuler(this);
      return this.setFromQuaternion(d, a);
    };
  }(), equals:function(d) {
    return d._x === this._x && d._y === this._y && d._z === this._z && d._order === this._order;
  }, fromArray:function(d) {
    this._x = d[0];
    this._y = d[1];
    this._z = d[2];
    void 0 !== d[3] && (this._order = d[3]);
    this.onChangeCallback();
    return this;
  }, toArray:function(d, a) {
    void 0 === d && (d = []);
    void 0 === a && (a = 0);
    d[a] = this._x;
    d[a + 1] = this._y;
    d[a + 2] = this._z;
    d[a + 3] = this._order;
    return d;
  }, toVector3:function(d) {
    return d ? d.set(this._x, this._y, this._z) : new e(this._x, this._y, this._z);
  }, onChange:function(d) {
    this.onChangeCallback = d;
    return this;
  }, onChangeCallback:function() {
  }});
  Object.assign(Kc.prototype, {set:function(d) {
    this.mask = 1 << d | 0;
  }, enable:function(d) {
    this.mask = this.mask | 1 << d | 0;
  }, toggle:function(d) {
    this.mask ^= 1 << d | 0;
  }, disable:function(d) {
    this.mask &= ~(1 << d | 0);
  }, test:function(d) {
    return 0 !== (this.mask & d.mask);
  }});
  var bf = 0;
  U.DefaultUp = new e(0, 1, 0);
  U.DefaultMatrixAutoUpdate = !0;
  Object.assign(U.prototype, h.prototype, {isObject3D:!0, applyMatrix:function(d) {
    this.matrix.multiplyMatrices(d, this.matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }, setRotationFromAxisAngle:function(d, a) {
    this.quaternion.setFromAxisAngle(d, a);
  }, setRotationFromEuler:function(d) {
    this.quaternion.setFromEuler(d, !0);
  }, setRotationFromMatrix:function(d) {
    this.quaternion.setFromRotationMatrix(d);
  }, setRotationFromQuaternion:function(d) {
    this.quaternion.copy(d);
  }, rotateOnAxis:function() {
    var d = new g;
    return function(a, b) {
      d.setFromAxisAngle(a, b);
      this.quaternion.multiply(d);
      return this;
    };
  }(), rotateX:function() {
    var d = new e(1, 0, 0);
    return function(a) {
      return this.rotateOnAxis(d, a);
    };
  }(), rotateY:function() {
    var d = new e(0, 1, 0);
    return function(a) {
      return this.rotateOnAxis(d, a);
    };
  }(), rotateZ:function() {
    var d = new e(0, 0, 1);
    return function(a) {
      return this.rotateOnAxis(d, a);
    };
  }(), translateOnAxis:function() {
    var d = new e;
    return function(a, b) {
      d.copy(a).applyQuaternion(this.quaternion);
      this.position.add(d.multiplyScalar(b));
      return this;
    };
  }(), translateX:function() {
    var d = new e(1, 0, 0);
    return function(a) {
      return this.translateOnAxis(d, a);
    };
  }(), translateY:function() {
    var d = new e(0, 1, 0);
    return function(a) {
      return this.translateOnAxis(d, a);
    };
  }(), translateZ:function() {
    var d = new e(0, 0, 1);
    return function(a) {
      return this.translateOnAxis(d, a);
    };
  }(), localToWorld:function(d) {
    return d.applyMatrix4(this.matrixWorld);
  }, worldToLocal:function() {
    var d = new p;
    return function(a) {
      return a.applyMatrix4(d.getInverse(this.matrixWorld));
    };
  }(), lookAt:function() {
    var d = new p;
    return function(a) {
      0 === this.position.distanceToSquared(a) ? console.warn("THREE.Object3D.lookAt(): target vector is the same as object position.") : (this.isCamera ? d.lookAt(this.position, a, this.up) : d.lookAt(a, this.position, this.up), this.quaternion.setFromRotationMatrix(d));
    };
  }(), add:function(d) {
    if (1 < arguments.length) {
      for (var a = 0;a < arguments.length;a++) {
        this.add(arguments[a]);
      }
      return this;
    }
    if (d === this) {
      return console.error("THREE.Object3D.add: object can't be added as a child of itself.", d), this;
    }
    d && d.isObject3D ? (null !== d.parent && d.parent.remove(d), d.parent = this, d.dispatchEvent({type:"added"}), this.children.push(d)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", d);
    return this;
  }, remove:function(d) {
    if (1 < arguments.length) {
      for (var a = 0;a < arguments.length;a++) {
        this.remove(arguments[a]);
      }
    }
    a = this.children.indexOf(d);
    -1 !== a && (d.parent = null, d.dispatchEvent({type:"removed"}), this.children.splice(a, 1));
  }, getObjectById:function(d) {
    return this.getObjectByProperty("id", d);
  }, getObjectByName:function(d) {
    return this.getObjectByProperty("name", d);
  }, getObjectByProperty:function(d, a) {
    if (this[d] === a) {
      return this;
    }
    for (var b = 0, m = this.children.length;b < m;b++) {
      var c = this.children[b].getObjectByProperty(d, a);
      if (void 0 !== c) {
        return c;
      }
    }
  }, getWorldPosition:function(d) {
    d = d || new e;
    this.updateMatrixWorld(!0);
    return d.setFromMatrixPosition(this.matrixWorld);
  }, getWorldQuaternion:function() {
    var d = new e, a = new e;
    return function(b) {
      b = b || new g;
      this.updateMatrixWorld(!0);
      this.matrixWorld.decompose(d, b, a);
      return b;
    };
  }(), getWorldRotation:function() {
    var d = new g;
    return function(a) {
      a = a || new Ua;
      this.getWorldQuaternion(d);
      return a.setFromQuaternion(d, this.rotation.order, !1);
    };
  }(), getWorldScale:function() {
    var d = new e, a = new g;
    return function(b) {
      b = b || new e;
      this.updateMatrixWorld(!0);
      this.matrixWorld.decompose(d, a, b);
      return b;
    };
  }(), getWorldDirection:function() {
    var d = new g;
    return function(a) {
      a = a || new e;
      this.getWorldQuaternion(d);
      return a.set(0, 0, 1).applyQuaternion(d);
    };
  }(), raycast:function() {
  }, traverse:function(d) {
    d(this);
    for (var a = this.children, b = 0, c = a.length;b < c;b++) {
      a[b].traverse(d);
    }
  }, traverseVisible:function(d) {
    if (!1 !== this.visible) {
      d(this);
      for (var a = this.children, b = 0, c = a.length;b < c;b++) {
        a[b].traverseVisible(d);
      }
    }
  }, traverseAncestors:function(d) {
    var a = this.parent;
    null !== a && (d(a), a.traverseAncestors(d));
  }, updateMatrix:function() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = !0;
  }, updateMatrixWorld:function(d) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || d) {
      null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, d = !0;
    }
    for (var a = this.children, b = 0, c = a.length;b < c;b++) {
      a[b].updateMatrixWorld(d);
    }
  }, toJSON:function(d) {
    function a(d) {
      var a = [], b;
      for (b in d) {
        var m = d[b];
        delete m.metadata;
        a.push(m);
      }
      return a;
    }
    var b = void 0 === d || "" === d, c = {};
    b && (d = {geometries:{}, materials:{}, textures:{}, images:{}}, c.metadata = {version:4.4, type:"Object", generator:"Object3D.toJSON"});
    var e = {};
    e.uuid = this.uuid;
    e.type = this.type;
    "" !== this.name && (e.name = this.name);
    "{}" !== JSON.stringify(this.userData) && (e.userData = this.userData);
    !0 === this.castShadow && (e.castShadow = !0);
    !0 === this.receiveShadow && (e.receiveShadow = !0);
    !1 === this.visible && (e.visible = !1);
    e.matrix = this.matrix.toArray();
    void 0 !== this.geometry && (void 0 === d.geometries[this.geometry.uuid] && (d.geometries[this.geometry.uuid] = this.geometry.toJSON(d)), e.geometry = this.geometry.uuid);
    void 0 !== this.material && (void 0 === d.materials[this.material.uuid] && (d.materials[this.material.uuid] = this.material.toJSON(d)), e.material = this.material.uuid);
    if (0 < this.children.length) {
      e.children = [];
      for (var g = 0;g < this.children.length;g++) {
        e.children.push(this.children[g].toJSON(d).object);
      }
    }
    if (b) {
      var b = a(d.geometries), g = a(d.materials), f = a(d.textures);
      d = a(d.images);
      0 < b.length && (c.geometries = b);
      0 < g.length && (c.materials = g);
      0 < f.length && (c.textures = f);
      0 < d.length && (c.images = d);
    }
    c.object = e;
    return c;
  }, clone:function(d) {
    return (new this.constructor).copy(this, d);
  }, copy:function(d, a) {
    void 0 === a && (a = !0);
    this.name = d.name;
    this.up.copy(d.up);
    this.position.copy(d.position);
    this.quaternion.copy(d.quaternion);
    this.scale.copy(d.scale);
    this.matrix.copy(d.matrix);
    this.matrixWorld.copy(d.matrixWorld);
    this.matrixAutoUpdate = d.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = d.matrixWorldNeedsUpdate;
    this.layers.mask = d.layers.mask;
    this.visible = d.visible;
    this.castShadow = d.castShadow;
    this.receiveShadow = d.receiveShadow;
    this.frustumCulled = d.frustumCulled;
    this.renderOrder = d.renderOrder;
    this.userData = JSON.parse(JSON.stringify(d.userData));
    if (!0 === a) {
      for (a = 0;a < d.children.length;a++) {
        this.add(d.children[a].clone());
      }
    }
    return this;
  }});
  Object.assign(Ab.prototype, {set:function(d, a) {
    this.start.copy(d);
    this.end.copy(a);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(d) {
    this.start.copy(d.start);
    this.end.copy(d.end);
    return this;
  }, getCenter:function(d) {
    return (d || new e).addVectors(this.start, this.end).multiplyScalar(.5);
  }, delta:function(d) {
    return (d || new e).subVectors(this.end, this.start);
  }, distanceSq:function() {
    return this.start.distanceToSquared(this.end);
  }, distance:function() {
    return this.start.distanceTo(this.end);
  }, at:function(d, a) {
    a = a || new e;
    return this.delta(a).multiplyScalar(d).add(this.start);
  }, closestPointToPointParameter:function() {
    var d = new e, a = new e;
    return function(b, m) {
      d.subVectors(b, this.start);
      a.subVectors(this.end, this.start);
      b = a.dot(a);
      b = a.dot(d) / b;
      m && (b = ka.clamp(b, 0, 1));
      return b;
    };
  }(), closestPointToPoint:function(d, a, b) {
    d = this.closestPointToPointParameter(d, a);
    b = b || new e;
    return this.delta(b).multiplyScalar(d).add(this.start);
  }, applyMatrix4:function(d) {
    this.start.applyMatrix4(d);
    this.end.applyMatrix4(d);
    return this;
  }, equals:function(d) {
    return d.start.equals(this.start) && d.end.equals(this.end);
  }});
  Object.assign(Ia, {normal:function() {
    var d = new e;
    return function(a, b, c, g) {
      g = g || new e;
      g.subVectors(c, b);
      d.subVectors(a, b);
      g.cross(d);
      a = g.lengthSq();
      return 0 < a ? g.multiplyScalar(1 / Math.sqrt(a)) : g.set(0, 0, 0);
    };
  }(), barycoordFromPoint:function() {
    var d = new e, a = new e, b = new e;
    return function(m, c, g, f, k) {
      d.subVectors(f, c);
      a.subVectors(g, c);
      b.subVectors(m, c);
      m = d.dot(d);
      c = d.dot(a);
      g = d.dot(b);
      var q = a.dot(a);
      f = a.dot(b);
      var p = m * q - c * c;
      k = k || new e;
      if (0 === p) {
        return k.set(-2, -1, -1);
      }
      p = 1 / p;
      q = (q * g - c * f) * p;
      m = (m * f - c * g) * p;
      return k.set(1 - q - m, m, q);
    };
  }(), containsPoint:function() {
    var d = new e;
    return function(a, b, c, e) {
      a = Ia.barycoordFromPoint(a, b, c, e, d);
      return 0 <= a.x && 0 <= a.y && 1 >= a.x + a.y;
    };
  }()});
  Object.assign(Ia.prototype, {set:function(d, a, b) {
    this.a.copy(d);
    this.b.copy(a);
    this.c.copy(b);
    return this;
  }, setFromPointsAndIndices:function(d, a, b, c) {
    this.a.copy(d[a]);
    this.b.copy(d[b]);
    this.c.copy(d[c]);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(d) {
    this.a.copy(d.a);
    this.b.copy(d.b);
    this.c.copy(d.c);
    return this;
  }, area:function() {
    var d = new e, a = new e;
    return function() {
      d.subVectors(this.c, this.b);
      a.subVectors(this.a, this.b);
      return .5 * d.cross(a).length();
    };
  }(), midpoint:function(d) {
    return (d || new e).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }, normal:function(d) {
    return Ia.normal(this.a, this.b, this.c, d);
  }, plane:function(d) {
    return (d || new Ea).setFromCoplanarPoints(this.a, this.b, this.c);
  }, barycoordFromPoint:function(d, a) {
    return Ia.barycoordFromPoint(d, this.a, this.b, this.c, a);
  }, containsPoint:function(d) {
    return Ia.containsPoint(d, this.a, this.b, this.c);
  }, closestPointToPoint:function() {
    var d = new Ea, a = [new Ab, new Ab, new Ab], b = new e, c = new e;
    return function(m, g) {
      g = g || new e;
      var f = Infinity;
      d.setFromCoplanarPoints(this.a, this.b, this.c);
      d.projectPoint(m, b);
      if (!0 === this.containsPoint(b)) {
        g.copy(b);
      } else {
        for (a[0].set(this.a, this.b), a[1].set(this.b, this.c), a[2].set(this.c, this.a), m = 0;m < a.length;m++) {
          a[m].closestPointToPoint(b, !0, c);
          var k = b.distanceToSquared(c);
          k < f && (f = k, g.copy(c));
        }
      }
      return g;
    };
  }(), equals:function(d) {
    return d.a.equals(this.a) && d.b.equals(this.b) && d.c.equals(this.c);
  }});
  Object.assign(za.prototype, {clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(d) {
    this.a = d.a;
    this.b = d.b;
    this.c = d.c;
    this.normal.copy(d.normal);
    this.color.copy(d.color);
    this.materialIndex = d.materialIndex;
    for (var a = 0, b = d.vertexNormals.length;a < b;a++) {
      this.vertexNormals[a] = d.vertexNormals[a].clone();
    }
    a = 0;
    for (b = d.vertexColors.length;a < b;a++) {
      this.vertexColors[a] = d.vertexColors[a].clone();
    }
    return this;
  }});
  Ka.prototype = Object.create(W.prototype);
  Ka.prototype.constructor = Ka;
  Ka.prototype.isMeshBasicMaterial = !0;
  Ka.prototype.copy = function(d) {
    W.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.map = d.map;
    this.lightMap = d.lightMap;
    this.lightMapIntensity = d.lightMapIntensity;
    this.aoMap = d.aoMap;
    this.aoMapIntensity = d.aoMapIntensity;
    this.specularMap = d.specularMap;
    this.alphaMap = d.alphaMap;
    this.envMap = d.envMap;
    this.combine = d.combine;
    this.reflectivity = d.reflectivity;
    this.refractionRatio = d.refractionRatio;
    this.wireframe = d.wireframe;
    this.wireframeLinewidth = d.wireframeLinewidth;
    this.wireframeLinecap = d.wireframeLinecap;
    this.wireframeLinejoin = d.wireframeLinejoin;
    this.morphTargets = d.morphTargets;
    return this;
  };
  var cf = 0;
  Object.defineProperty(ja.prototype, "needsUpdate", {set:function(d) {
    !0 === d && this.version++;
  }});
  Object.assign(ja.prototype, {isBufferAttribute:!0, setArray:function(d) {
    if (Array.isArray(d)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.count = void 0 !== d ? d.length / this.itemSize : 0;
    this.array = d;
  }, setDynamic:function(d) {
    this.dynamic = d;
    return this;
  }, copy:function(d) {
    this.array = new d.array.constructor(d.array);
    this.itemSize = d.itemSize;
    this.count = d.count;
    this.normalized = d.normalized;
    this.dynamic = d.dynamic;
    return this;
  }, copyAt:function(d, a, b) {
    d *= this.itemSize;
    b *= a.itemSize;
    for (var m = 0, c = this.itemSize;m < c;m++) {
      this.array[d + m] = a.array[b + m];
    }
    return this;
  }, copyArray:function(d) {
    this.array.set(d);
    return this;
  }, copyColorsArray:function(d) {
    for (var a = this.array, b = 0, c = 0, e = d.length;c < e;c++) {
      var g = d[c];
      void 0 === g && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", c), g = new T);
      a[b++] = g.r;
      a[b++] = g.g;
      a[b++] = g.b;
    }
    return this;
  }, copyIndicesArray:function(d) {
    for (var a = this.array, b = 0, c = 0, e = d.length;c < e;c++) {
      var g = d[c];
      a[b++] = g.a;
      a[b++] = g.b;
      a[b++] = g.c;
    }
    return this;
  }, copyVector2sArray:function(d) {
    for (var a = this.array, b = 0, c = 0, e = d.length;c < e;c++) {
      var g = d[c];
      void 0 === g && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", c), g = new l);
      a[b++] = g.x;
      a[b++] = g.y;
    }
    return this;
  }, copyVector3sArray:function(d) {
    for (var a = this.array, b = 0, c = 0, g = d.length;c < g;c++) {
      var f = d[c];
      void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", c), f = new e);
      a[b++] = f.x;
      a[b++] = f.y;
      a[b++] = f.z;
    }
    return this;
  }, copyVector4sArray:function(d) {
    for (var a = this.array, b = 0, c = 0, e = d.length;c < e;c++) {
      var g = d[c];
      void 0 === g && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", c), g = new f);
      a[b++] = g.x;
      a[b++] = g.y;
      a[b++] = g.z;
      a[b++] = g.w;
    }
    return this;
  }, set:function(d, a) {
    void 0 === a && (a = 0);
    this.array.set(d, a);
    return this;
  }, getX:function(d) {
    return this.array[d * this.itemSize];
  }, setX:function(d, a) {
    this.array[d * this.itemSize] = a;
    return this;
  }, getY:function(d) {
    return this.array[d * this.itemSize + 1];
  }, setY:function(d, a) {
    this.array[d * this.itemSize + 1] = a;
    return this;
  }, getZ:function(d) {
    return this.array[d * this.itemSize + 2];
  }, setZ:function(d, a) {
    this.array[d * this.itemSize + 2] = a;
    return this;
  }, getW:function(d) {
    return this.array[d * this.itemSize + 3];
  }, setW:function(d, a) {
    this.array[d * this.itemSize + 3] = a;
    return this;
  }, setXY:function(d, a, b) {
    d *= this.itemSize;
    this.array[d + 0] = a;
    this.array[d + 1] = b;
    return this;
  }, setXYZ:function(d, a, b, c) {
    d *= this.itemSize;
    this.array[d + 0] = a;
    this.array[d + 1] = b;
    this.array[d + 2] = c;
    return this;
  }, setXYZW:function(d, a, b, c, e) {
    d *= this.itemSize;
    this.array[d + 0] = a;
    this.array[d + 1] = b;
    this.array[d + 2] = c;
    this.array[d + 3] = e;
    return this;
  }, onUpload:function(d) {
    this.onUploadCallback = d;
    return this;
  }, clone:function() {
    return (new this.constructor(this.array, this.itemSize)).copy(this);
  }});
  tb.prototype = Object.create(ja.prototype);
  tb.prototype.constructor = tb;
  lb.prototype = Object.create(ja.prototype);
  lb.prototype.constructor = lb;
  La.prototype = Object.create(ja.prototype);
  La.prototype.constructor = La;
  Bb.prototype = Object.create(ja.prototype);
  Bb.prototype.constructor = Bb;
  $a.prototype = Object.create(ja.prototype);
  $a.prototype.constructor = $a;
  ab.prototype = Object.create(ja.prototype);
  ab.prototype.constructor = ab;
  mb.prototype = Object.create(ja.prototype);
  mb.prototype.constructor = mb;
  Y.prototype = Object.create(ja.prototype);
  Y.prototype.constructor = Y;
  ub.prototype = Object.create(ja.prototype);
  ub.prototype.constructor = ub;
  Object.assign(Lc.prototype, {computeGroups:function(d) {
    var a, b = [], c = void 0;
    d = d.faces;
    for (var e = 0;e < d.length;e++) {
      var g = d[e];
      g.materialIndex !== c && (c = g.materialIndex, void 0 !== a && (a.count = 3 * e - a.start, b.push(a)), a = {start:3 * e, materialIndex:c});
    }
    void 0 !== a && (a.count = 3 * e - a.start, b.push(a));
    this.groups = b;
  }, fromGeometry:function(d) {
    var a = d.faces, b = d.vertices, c = d.faceVertexUvs, e = c[0] && 0 < c[0].length, g = c[1] && 0 < c[1].length, f = d.morphTargets, k = f.length, q;
    if (0 < k) {
      q = [];
      for (var p = 0;p < k;p++) {
        q[p] = [];
      }
      this.morphTargets.position = q;
    }
    var h = d.morphNormals, n = h.length, r;
    if (0 < n) {
      r = [];
      for (p = 0;p < n;p++) {
        r[p] = [];
      }
      this.morphTargets.normal = r;
    }
    for (var u = d.skinIndices, w = d.skinWeights, t = u.length === b.length, v = w.length === b.length, p = 0;p < a.length;p++) {
      var B = a[p];
      this.vertices.push(b[B.a], b[B.b], b[B.c]);
      var y = B.vertexNormals;
      3 === y.length ? this.normals.push(y[0], y[1], y[2]) : (y = B.normal, this.normals.push(y, y, y));
      y = B.vertexColors;
      3 === y.length ? this.colors.push(y[0], y[1], y[2]) : (y = B.color, this.colors.push(y, y, y));
      !0 === e && (y = c[0][p], void 0 !== y ? this.uvs.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", p), this.uvs.push(new l, new l, new l)));
      !0 === g && (y = c[1][p], void 0 !== y ? this.uvs2.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", p), this.uvs2.push(new l, new l, new l)));
      for (y = 0;y < k;y++) {
        var x = f[y].vertices;
        q[y].push(x[B.a], x[B.b], x[B.c]);
      }
      for (y = 0;y < n;y++) {
        x = h[y].vertexNormals[p], r[y].push(x.a, x.b, x.c);
      }
      t && this.skinIndices.push(u[B.a], u[B.b], u[B.c]);
      v && this.skinWeights.push(w[B.a], w[B.b], w[B.c]);
    }
    this.computeGroups(d);
    this.verticesNeedUpdate = d.verticesNeedUpdate;
    this.normalsNeedUpdate = d.normalsNeedUpdate;
    this.colorsNeedUpdate = d.colorsNeedUpdate;
    this.uvsNeedUpdate = d.uvsNeedUpdate;
    this.groupsNeedUpdate = d.groupsNeedUpdate;
    return this;
  }});
  var be = 0;
  Object.assign(ca.prototype, h.prototype, {isGeometry:!0, applyMatrix:function(d) {
    for (var a = (new ya).getNormalMatrix(d), b = 0, c = this.vertices.length;b < c;b++) {
      this.vertices[b].applyMatrix4(d);
    }
    b = 0;
    for (c = this.faces.length;b < c;b++) {
      d = this.faces[b];
      d.normal.applyMatrix3(a).normalize();
      for (var e = 0, g = d.vertexNormals.length;e < g;e++) {
        d.vertexNormals[e].applyMatrix3(a).normalize();
      }
    }
    null !== this.boundingBox && this.computeBoundingBox();
    null !== this.boundingSphere && this.computeBoundingSphere();
    this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
    return this;
  }, rotateX:function() {
    var d = new p;
    return function(a) {
      d.makeRotationX(a);
      this.applyMatrix(d);
      return this;
    };
  }(), rotateY:function() {
    var d = new p;
    return function(a) {
      d.makeRotationY(a);
      this.applyMatrix(d);
      return this;
    };
  }(), rotateZ:function() {
    var d = new p;
    return function(a) {
      d.makeRotationZ(a);
      this.applyMatrix(d);
      return this;
    };
  }(), translate:function() {
    var d = new p;
    return function(a, b, c) {
      d.makeTranslation(a, b, c);
      this.applyMatrix(d);
      return this;
    };
  }(), scale:function() {
    var d = new p;
    return function(a, b, c) {
      d.makeScale(a, b, c);
      this.applyMatrix(d);
      return this;
    };
  }(), lookAt:function() {
    var d = new U;
    return function(a) {
      d.lookAt(a);
      d.updateMatrix();
      this.applyMatrix(d.matrix);
    };
  }(), fromBufferGeometry:function(d) {
    function a(d, a, m, c) {
      var e = void 0 !== k ? [n[d].clone(), n[a].clone(), n[m].clone()] : [], g = void 0 !== q ? [b.colors[d].clone(), b.colors[a].clone(), b.colors[m].clone()] : [];
      c = new za(d, a, m, e, g, c);
      b.faces.push(c);
      void 0 !== p && b.faceVertexUvs[0].push([r[d].clone(), r[a].clone(), r[m].clone()]);
      void 0 !== h && b.faceVertexUvs[1].push([u[d].clone(), u[a].clone(), u[m].clone()]);
    }
    var b = this, c = null !== d.index ? d.index.array : void 0, g = d.attributes, f = g.position.array, k = void 0 !== g.normal ? g.normal.array : void 0, q = void 0 !== g.color ? g.color.array : void 0, p = void 0 !== g.uv ? g.uv.array : void 0, h = void 0 !== g.uv2 ? g.uv2.array : void 0;
    void 0 !== h && (this.faceVertexUvs[1] = []);
    for (var n = [], r = [], u = [], w = g = 0;g < f.length;g += 3, w += 2) {
      b.vertices.push(new e(f[g], f[g + 1], f[g + 2])), void 0 !== k && n.push(new e(k[g], k[g + 1], k[g + 2])), void 0 !== q && b.colors.push(new T(q[g], q[g + 1], q[g + 2])), void 0 !== p && r.push(new l(p[w], p[w + 1])), void 0 !== h && u.push(new l(h[w], h[w + 1]));
    }
    if (void 0 !== c) {
      if (f = d.groups, 0 < f.length) {
        for (g = 0;g < f.length;g++) {
          for (var t = f[g], v = t.start, B = t.count, w = v, v = v + B;w < v;w += 3) {
            a(c[w], c[w + 1], c[w + 2], t.materialIndex);
          }
        }
      } else {
        for (g = 0;g < c.length;g += 3) {
          a(c[g], c[g + 1], c[g + 2]);
        }
      }
    } else {
      for (g = 0;g < f.length / 3;g += 3) {
        a(g, g + 1, g + 2);
      }
    }
    this.computeFaceNormals();
    null !== d.boundingBox && (this.boundingBox = d.boundingBox.clone());
    null !== d.boundingSphere && (this.boundingSphere = d.boundingSphere.clone());
    return this;
  }, center:function() {
    this.computeBoundingBox();
    var d = this.boundingBox.getCenter().negate();
    this.translate(d.x, d.y, d.z);
    return d;
  }, normalize:function() {
    this.computeBoundingSphere();
    var d = this.boundingSphere.center, a = this.boundingSphere.radius, a = 0 === a ? 1 : 1 / a, b = new p;
    b.set(a, 0, 0, -a * d.x, 0, a, 0, -a * d.y, 0, 0, a, -a * d.z, 0, 0, 0, 1);
    this.applyMatrix(b);
    return this;
  }, computeFaceNormals:function() {
    for (var d = new e, a = new e, b = 0, c = this.faces.length;b < c;b++) {
      var g = this.faces[b], f = this.vertices[g.a], k = this.vertices[g.b];
      d.subVectors(this.vertices[g.c], k);
      a.subVectors(f, k);
      d.cross(a);
      d.normalize();
      g.normal.copy(d);
    }
  }, computeVertexNormals:function(d) {
    void 0 === d && (d = !0);
    var a, b, c;
    c = Array(this.vertices.length);
    a = 0;
    for (b = this.vertices.length;a < b;a++) {
      c[a] = new e;
    }
    if (d) {
      var g, f, k, q = new e, p = new e;
      d = 0;
      for (a = this.faces.length;d < a;d++) {
        b = this.faces[d], g = this.vertices[b.a], f = this.vertices[b.b], k = this.vertices[b.c], q.subVectors(k, f), p.subVectors(g, f), q.cross(p), c[b.a].add(q), c[b.b].add(q), c[b.c].add(q);
      }
    } else {
      for (this.computeFaceNormals(), d = 0, a = this.faces.length;d < a;d++) {
        b = this.faces[d], c[b.a].add(b.normal), c[b.b].add(b.normal), c[b.c].add(b.normal);
      }
    }
    a = 0;
    for (b = this.vertices.length;a < b;a++) {
      c[a].normalize();
    }
    d = 0;
    for (a = this.faces.length;d < a;d++) {
      b = this.faces[d], g = b.vertexNormals, 3 === g.length ? (g[0].copy(c[b.a]), g[1].copy(c[b.b]), g[2].copy(c[b.c])) : (g[0] = c[b.a].clone(), g[1] = c[b.b].clone(), g[2] = c[b.c].clone());
    }
    0 < this.faces.length && (this.normalsNeedUpdate = !0);
  }, computeFlatVertexNormals:function() {
    var d, a, b;
    this.computeFaceNormals();
    d = 0;
    for (a = this.faces.length;d < a;d++) {
      b = this.faces[d];
      var c = b.vertexNormals;
      3 === c.length ? (c[0].copy(b.normal), c[1].copy(b.normal), c[2].copy(b.normal)) : (c[0] = b.normal.clone(), c[1] = b.normal.clone(), c[2] = b.normal.clone());
    }
    0 < this.faces.length && (this.normalsNeedUpdate = !0);
  }, computeMorphNormals:function() {
    var d, a, b, c, g;
    b = 0;
    for (c = this.faces.length;b < c;b++) {
      for (g = this.faces[b], g.__originalFaceNormal ? g.__originalFaceNormal.copy(g.normal) : g.__originalFaceNormal = g.normal.clone(), g.__originalVertexNormals || (g.__originalVertexNormals = []), d = 0, a = g.vertexNormals.length;d < a;d++) {
        g.__originalVertexNormals[d] ? g.__originalVertexNormals[d].copy(g.vertexNormals[d]) : g.__originalVertexNormals[d] = g.vertexNormals[d].clone();
      }
    }
    var f = new ca;
    f.faces = this.faces;
    d = 0;
    for (a = this.morphTargets.length;d < a;d++) {
      if (!this.morphNormals[d]) {
        this.morphNormals[d] = {};
        this.morphNormals[d].faceNormals = [];
        this.morphNormals[d].vertexNormals = [];
        g = this.morphNormals[d].faceNormals;
        var k = this.morphNormals[d].vertexNormals, q, p;
        b = 0;
        for (c = this.faces.length;b < c;b++) {
          q = new e, p = {a:new e, b:new e, c:new e}, g.push(q), k.push(p);
        }
      }
      k = this.morphNormals[d];
      f.vertices = this.morphTargets[d].vertices;
      f.computeFaceNormals();
      f.computeVertexNormals();
      b = 0;
      for (c = this.faces.length;b < c;b++) {
        g = this.faces[b], q = k.faceNormals[b], p = k.vertexNormals[b], q.copy(g.normal), p.a.copy(g.vertexNormals[0]), p.b.copy(g.vertexNormals[1]), p.c.copy(g.vertexNormals[2]);
      }
    }
    b = 0;
    for (c = this.faces.length;b < c;b++) {
      g = this.faces[b], g.normal = g.__originalFaceNormal, g.vertexNormals = g.__originalVertexNormals;
    }
  }, computeLineDistances:function() {
    for (var d = 0, a = this.vertices, b = 0, c = a.length;b < c;b++) {
      0 < b && (d += a[b].distanceTo(a[b - 1])), this.lineDistances[b] = d;
    }
  }, computeBoundingBox:function() {
    null === this.boundingBox && (this.boundingBox = new Aa);
    this.boundingBox.setFromPoints(this.vertices);
  }, computeBoundingSphere:function() {
    null === this.boundingSphere && (this.boundingSphere = new Ba);
    this.boundingSphere.setFromPoints(this.vertices);
  }, merge:function(d, a, b) {
    if (!1 === (d && d.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", d);
    } else {
      var c, m = this.vertices.length, e = this.vertices, g = d.vertices, f = this.faces, k = d.faces, q = this.faceVertexUvs[0], p = d.faceVertexUvs[0], h = this.colors, n = d.colors;
      void 0 === b && (b = 0);
      void 0 !== a && (c = (new ya).getNormalMatrix(a));
      d = 0;
      for (var r = g.length;d < r;d++) {
        var l = g[d].clone();
        void 0 !== a && l.applyMatrix4(a);
        e.push(l);
      }
      d = 0;
      for (r = n.length;d < r;d++) {
        h.push(n[d].clone());
      }
      d = 0;
      for (r = k.length;d < r;d++) {
        var g = k[d], u = g.vertexNormals, n = g.vertexColors, h = new za(g.a + m, g.b + m, g.c + m);
        h.normal.copy(g.normal);
        void 0 !== c && h.normal.applyMatrix3(c).normalize();
        a = 0;
        for (e = u.length;a < e;a++) {
          l = u[a].clone(), void 0 !== c && l.applyMatrix3(c).normalize(), h.vertexNormals.push(l);
        }
        h.color.copy(g.color);
        a = 0;
        for (e = n.length;a < e;a++) {
          l = n[a], h.vertexColors.push(l.clone());
        }
        h.materialIndex = g.materialIndex + b;
        f.push(h);
      }
      d = 0;
      for (r = p.length;d < r;d++) {
        if (b = p[d], c = [], void 0 !== b) {
          a = 0;
          for (e = b.length;a < e;a++) {
            c.push(b[a].clone());
          }
          q.push(c);
        }
      }
    }
  }, mergeMesh:function(d) {
    !1 === (d && d.isMesh) ? console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", d) : (d.matrixAutoUpdate && d.updateMatrix(), this.merge(d.geometry, d.matrix));
  }, mergeVertices:function() {
    var d = {}, a = [], b = [], c, e = Math.pow(10, 4), g, f;
    g = 0;
    for (f = this.vertices.length;g < f;g++) {
      c = this.vertices[g], c = Math.round(c.x * e) + "_" + Math.round(c.y * e) + "_" + Math.round(c.z * e), void 0 === d[c] ? (d[c] = g, a.push(this.vertices[g]), b[g] = a.length - 1) : b[g] = b[d[c]];
    }
    d = [];
    g = 0;
    for (f = this.faces.length;g < f;g++) {
      for (e = this.faces[g], e.a = b[e.a], e.b = b[e.b], e.c = b[e.c], e = [e.a, e.b, e.c], c = 0;3 > c;c++) {
        if (e[c] === e[(c + 1) % 3]) {
          d.push(g);
          break;
        }
      }
    }
    for (g = d.length - 1;0 <= g;g--) {
      for (e = d[g], this.faces.splice(e, 1), b = 0, f = this.faceVertexUvs.length;b < f;b++) {
        this.faceVertexUvs[b].splice(e, 1);
      }
    }
    g = this.vertices.length - a.length;
    this.vertices = a;
    return g;
  }, sortFacesByMaterialIndex:function() {
    for (var d = this.faces, a = d.length, b = 0;b < a;b++) {
      d[b]._id = b;
    }
    d.sort(function(d, a) {
      return d.materialIndex - a.materialIndex;
    });
    var c = this.faceVertexUvs[0], e = this.faceVertexUvs[1], g, f;
    c && c.length === a && (g = []);
    e && e.length === a && (f = []);
    for (b = 0;b < a;b++) {
      var k = d[b]._id;
      g && g.push(c[k]);
      f && f.push(e[k]);
    }
    g && (this.faceVertexUvs[0] = g);
    f && (this.faceVertexUvs[1] = f);
  }, toJSON:function() {
    function d(d, a, b) {
      return b ? d | 1 << a : d & ~(1 << a);
    }
    function a(d) {
      var a = d.x.toString() + d.y.toString() + d.z.toString();
      if (void 0 !== p[a]) {
        return p[a];
      }
      p[a] = q.length / 3;
      q.push(d.x, d.y, d.z);
      return p[a];
    }
    function b(d) {
      var a = d.r.toString() + d.g.toString() + d.b.toString();
      if (void 0 !== n[a]) {
        return n[a];
      }
      n[a] = h.length;
      h.push(d.getHex());
      return n[a];
    }
    function c(d) {
      var a = d.x.toString() + d.y.toString();
      if (void 0 !== l[a]) {
        return l[a];
      }
      l[a] = r.length / 2;
      r.push(d.x, d.y);
      return l[a];
    }
    var e = {metadata:{version:4.4, type:"Geometry", generator:"Geometry.toJSON"}};
    e.uuid = this.uuid;
    e.type = this.type;
    "" !== this.name && (e.name = this.name);
    if (void 0 !== this.parameters) {
      var g = this.parameters, f;
      for (f in g) {
        void 0 !== g[f] && (e[f] = g[f]);
      }
      return e;
    }
    g = [];
    for (f = 0;f < this.vertices.length;f++) {
      var k = this.vertices[f];
      g.push(k.x, k.y, k.z);
    }
    var k = [], q = [], p = {}, h = [], n = {}, r = [], l = {};
    for (f = 0;f < this.faces.length;f++) {
      var u = this.faces[f], w = void 0 !== this.faceVertexUvs[0][f], t = 0 < u.normal.length(), v = 0 < u.vertexNormals.length, B = 1 !== u.color.r || 1 !== u.color.g || 1 !== u.color.b, y = 0 < u.vertexColors.length, x = 0, x = d(x, 0, 0), x = d(x, 1, !0), x = d(x, 2, !1), x = d(x, 3, w), x = d(x, 4, t), x = d(x, 5, v), x = d(x, 6, B), x = d(x, 7, y);
      k.push(x);
      k.push(u.a, u.b, u.c);
      k.push(u.materialIndex);
      w && (w = this.faceVertexUvs[0][f], k.push(c(w[0]), c(w[1]), c(w[2])));
      t && k.push(a(u.normal));
      v && (t = u.vertexNormals, k.push(a(t[0]), a(t[1]), a(t[2])));
      B && k.push(b(u.color));
      y && (u = u.vertexColors, k.push(b(u[0]), b(u[1]), b(u[2])));
    }
    e.data = {};
    e.data.vertices = g;
    e.data.normals = q;
    0 < h.length && (e.data.colors = h);
    0 < r.length && (e.data.uvs = [r]);
    e.data.faces = k;
    return e;
  }, clone:function() {
    return (new ca).copy(this);
  }, copy:function(d) {
    var a, b, c, e, g, f;
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingSphere = this.boundingBox = null;
    this.name = d.name;
    c = d.vertices;
    a = 0;
    for (b = c.length;a < b;a++) {
      this.vertices.push(c[a].clone());
    }
    c = d.colors;
    a = 0;
    for (b = c.length;a < b;a++) {
      this.colors.push(c[a].clone());
    }
    c = d.faces;
    a = 0;
    for (b = c.length;a < b;a++) {
      this.faces.push(c[a].clone());
    }
    a = 0;
    for (b = d.faceVertexUvs.length;a < b;a++) {
      var k = d.faceVertexUvs[a];
      void 0 === this.faceVertexUvs[a] && (this.faceVertexUvs[a] = []);
      c = 0;
      for (e = k.length;c < e;c++) {
        var q = k[c], p = [];
        g = 0;
        for (f = q.length;g < f;g++) {
          p.push(q[g].clone());
        }
        this.faceVertexUvs[a].push(p);
      }
    }
    g = d.morphTargets;
    a = 0;
    for (b = g.length;a < b;a++) {
      f = {};
      f.name = g[a].name;
      if (void 0 !== g[a].vertices) {
        for (f.vertices = [], c = 0, e = g[a].vertices.length;c < e;c++) {
          f.vertices.push(g[a].vertices[c].clone());
        }
      }
      if (void 0 !== g[a].normals) {
        for (f.normals = [], c = 0, e = g[a].normals.length;c < e;c++) {
          f.normals.push(g[a].normals[c].clone());
        }
      }
      this.morphTargets.push(f);
    }
    g = d.morphNormals;
    a = 0;
    for (b = g.length;a < b;a++) {
      f = {};
      if (void 0 !== g[a].vertexNormals) {
        for (f.vertexNormals = [], c = 0, e = g[a].vertexNormals.length;c < e;c++) {
          k = g[a].vertexNormals[c], q = {}, q.a = k.a.clone(), q.b = k.b.clone(), q.c = k.c.clone(), f.vertexNormals.push(q);
        }
      }
      if (void 0 !== g[a].faceNormals) {
        for (f.faceNormals = [], c = 0, e = g[a].faceNormals.length;c < e;c++) {
          f.faceNormals.push(g[a].faceNormals[c].clone());
        }
      }
      this.morphNormals.push(f);
    }
    c = d.skinWeights;
    a = 0;
    for (b = c.length;a < b;a++) {
      this.skinWeights.push(c[a].clone());
    }
    c = d.skinIndices;
    a = 0;
    for (b = c.length;a < b;a++) {
      this.skinIndices.push(c[a].clone());
    }
    c = d.lineDistances;
    a = 0;
    for (b = c.length;a < b;a++) {
      this.lineDistances.push(c[a]);
    }
    a = d.boundingBox;
    null !== a && (this.boundingBox = a.clone());
    a = d.boundingSphere;
    null !== a && (this.boundingSphere = a.clone());
    this.elementsNeedUpdate = d.elementsNeedUpdate;
    this.verticesNeedUpdate = d.verticesNeedUpdate;
    this.uvsNeedUpdate = d.uvsNeedUpdate;
    this.normalsNeedUpdate = d.normalsNeedUpdate;
    this.colorsNeedUpdate = d.colorsNeedUpdate;
    this.lineDistancesNeedUpdate = d.lineDistancesNeedUpdate;
    this.groupsNeedUpdate = d.groupsNeedUpdate;
    return this;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }});
  da.MaxIndex = 65535;
  Object.assign(da.prototype, h.prototype, {isBufferGeometry:!0, getIndex:function() {
    return this.index;
  }, setIndex:function(d) {
    Array.isArray(d) ? this.index = new (65535 < nb(d) ? mb : $a)(d, 1) : this.index = d;
  }, addAttribute:function(d, a, b) {
    if (!1 === (a && a.isBufferAttribute) && !1 === (a && a.isInterleavedBufferAttribute)) {
      console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(d, new ja(a, b));
    } else {
      if ("index" === d) {
        console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(a);
      } else {
        return this.attributes[d] = a, this;
      }
    }
  }, getAttribute:function(d) {
    return this.attributes[d];
  }, removeAttribute:function(d) {
    delete this.attributes[d];
    return this;
  }, addGroup:function(d, a, b) {
    this.groups.push({start:d, count:a, materialIndex:void 0 !== b ? b : 0});
  }, clearGroups:function() {
    this.groups = [];
  }, setDrawRange:function(d, a) {
    this.drawRange.start = d;
    this.drawRange.count = a;
  }, applyMatrix:function(d) {
    var a = this.attributes.position;
    void 0 !== a && (d.applyToBufferAttribute(a), a.needsUpdate = !0);
    a = this.attributes.normal;
    void 0 !== a && ((new ya).getNormalMatrix(d).applyToBufferAttribute(a), a.needsUpdate = !0);
    null !== this.boundingBox && this.computeBoundingBox();
    null !== this.boundingSphere && this.computeBoundingSphere();
    return this;
  }, rotateX:function() {
    var d = new p;
    return function(a) {
      d.makeRotationX(a);
      this.applyMatrix(d);
      return this;
    };
  }(), rotateY:function() {
    var d = new p;
    return function(a) {
      d.makeRotationY(a);
      this.applyMatrix(d);
      return this;
    };
  }(), rotateZ:function() {
    var d = new p;
    return function(a) {
      d.makeRotationZ(a);
      this.applyMatrix(d);
      return this;
    };
  }(), translate:function() {
    var d = new p;
    return function(a, b, c) {
      d.makeTranslation(a, b, c);
      this.applyMatrix(d);
      return this;
    };
  }(), scale:function() {
    var d = new p;
    return function(a, b, c) {
      d.makeScale(a, b, c);
      this.applyMatrix(d);
      return this;
    };
  }(), lookAt:function() {
    var d = new U;
    return function(a) {
      d.lookAt(a);
      d.updateMatrix();
      this.applyMatrix(d.matrix);
    };
  }(), center:function() {
    this.computeBoundingBox();
    var d = this.boundingBox.getCenter().negate();
    this.translate(d.x, d.y, d.z);
    return d;
  }, setFromObject:function(d) {
    var a = d.geometry;
    if (d.isPoints || d.isLine) {
      d = new Y(3 * a.vertices.length, 3);
      var b = new Y(3 * a.colors.length, 3);
      this.addAttribute("position", d.copyVector3sArray(a.vertices));
      this.addAttribute("color", b.copyColorsArray(a.colors));
      a.lineDistances && a.lineDistances.length === a.vertices.length && (d = new Y(a.lineDistances.length, 1), this.addAttribute("lineDistance", d.copyArray(a.lineDistances)));
      null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
      null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
    } else {
      d.isMesh && a && a.isGeometry && this.fromGeometry(a);
    }
    return this;
  }, updateFromObject:function(d) {
    var a = d.geometry;
    if (d.isMesh) {
      var b = a.__directGeometry;
      !0 === a.elementsNeedUpdate && (b = void 0, a.elementsNeedUpdate = !1);
      if (void 0 === b) {
        return this.fromGeometry(a);
      }
      b.verticesNeedUpdate = a.verticesNeedUpdate;
      b.normalsNeedUpdate = a.normalsNeedUpdate;
      b.colorsNeedUpdate = a.colorsNeedUpdate;
      b.uvsNeedUpdate = a.uvsNeedUpdate;
      b.groupsNeedUpdate = a.groupsNeedUpdate;
      a.verticesNeedUpdate = !1;
      a.normalsNeedUpdate = !1;
      a.colorsNeedUpdate = !1;
      a.uvsNeedUpdate = !1;
      a.groupsNeedUpdate = !1;
      a = b;
    }
    !0 === a.verticesNeedUpdate && (b = this.attributes.position, void 0 !== b && (b.copyVector3sArray(a.vertices), b.needsUpdate = !0), a.verticesNeedUpdate = !1);
    !0 === a.normalsNeedUpdate && (b = this.attributes.normal, void 0 !== b && (b.copyVector3sArray(a.normals), b.needsUpdate = !0), a.normalsNeedUpdate = !1);
    !0 === a.colorsNeedUpdate && (b = this.attributes.color, void 0 !== b && (b.copyColorsArray(a.colors), b.needsUpdate = !0), a.colorsNeedUpdate = !1);
    a.uvsNeedUpdate && (b = this.attributes.uv, void 0 !== b && (b.copyVector2sArray(a.uvs), b.needsUpdate = !0), a.uvsNeedUpdate = !1);
    a.lineDistancesNeedUpdate && (b = this.attributes.lineDistance, void 0 !== b && (b.copyArray(a.lineDistances), b.needsUpdate = !0), a.lineDistancesNeedUpdate = !1);
    a.groupsNeedUpdate && (a.computeGroups(d.geometry), this.groups = a.groups, a.groupsNeedUpdate = !1);
    return this;
  }, fromGeometry:function(d) {
    d.__directGeometry = (new Lc).fromGeometry(d);
    return this.fromDirectGeometry(d.__directGeometry);
  }, fromDirectGeometry:function(d) {
    var a = new Float32Array(3 * d.vertices.length);
    this.addAttribute("position", (new ja(a, 3)).copyVector3sArray(d.vertices));
    0 < d.normals.length && (a = new Float32Array(3 * d.normals.length), this.addAttribute("normal", (new ja(a, 3)).copyVector3sArray(d.normals)));
    0 < d.colors.length && (a = new Float32Array(3 * d.colors.length), this.addAttribute("color", (new ja(a, 3)).copyColorsArray(d.colors)));
    0 < d.uvs.length && (a = new Float32Array(2 * d.uvs.length), this.addAttribute("uv", (new ja(a, 2)).copyVector2sArray(d.uvs)));
    0 < d.uvs2.length && (a = new Float32Array(2 * d.uvs2.length), this.addAttribute("uv2", (new ja(a, 2)).copyVector2sArray(d.uvs2)));
    0 < d.indices.length && (a = new (65535 < nb(d.indices) ? Uint32Array : Uint16Array)(3 * d.indices.length), this.setIndex((new ja(a, 1)).copyIndicesArray(d.indices)));
    this.groups = d.groups;
    for (var b in d.morphTargets) {
      for (var a = [], c = d.morphTargets[b], e = 0, g = c.length;e < g;e++) {
        var f = c[e], k = new Y(3 * f.length, 3);
        a.push(k.copyVector3sArray(f));
      }
      this.morphAttributes[b] = a;
    }
    0 < d.skinIndices.length && (b = new Y(4 * d.skinIndices.length, 4), this.addAttribute("skinIndex", b.copyVector4sArray(d.skinIndices)));
    0 < d.skinWeights.length && (b = new Y(4 * d.skinWeights.length, 4), this.addAttribute("skinWeight", b.copyVector4sArray(d.skinWeights)));
    null !== d.boundingSphere && (this.boundingSphere = d.boundingSphere.clone());
    null !== d.boundingBox && (this.boundingBox = d.boundingBox.clone());
    return this;
  }, computeBoundingBox:function() {
    null === this.boundingBox && (this.boundingBox = new Aa);
    var d = this.attributes.position;
    void 0 !== d ? this.boundingBox.setFromBufferAttribute(d) : this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }, computeBoundingSphere:function() {
    var d = new Aa, a = new e;
    return function() {
      null === this.boundingSphere && (this.boundingSphere = new Ba);
      var b = this.attributes.position;
      if (b) {
        var c = this.boundingSphere.center;
        d.setFromBufferAttribute(b);
        d.getCenter(c);
        for (var m = 0, e = 0, g = b.count;e < g;e++) {
          a.x = b.getX(e), a.y = b.getY(e), a.z = b.getZ(e), m = Math.max(m, c.distanceToSquared(a));
        }
        this.boundingSphere.radius = Math.sqrt(m);
        isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    };
  }(), computeFaceNormals:function() {
  }, computeVertexNormals:function() {
    var d = this.index, a = this.attributes, b = this.groups;
    if (a.position) {
      var c = a.position.array;
      if (void 0 === a.normal) {
        this.addAttribute("normal", new ja(new Float32Array(c.length), 3));
      } else {
        for (var g = a.normal.array, f = 0, k = g.length;f < k;f++) {
          g[f] = 0;
        }
      }
      var g = a.normal.array, q, p, h, n = new e, r = new e, l = new e, u = new e, w = new e;
      if (d) {
        d = d.array;
        0 === b.length && this.addGroup(0, d.length);
        for (var t = 0, v = b.length;t < v;++t) {
          for (f = b[t], k = f.start, q = f.count, f = k, k += q;f < k;f += 3) {
            q = 3 * d[f + 0], p = 3 * d[f + 1], h = 3 * d[f + 2], n.fromArray(c, q), r.fromArray(c, p), l.fromArray(c, h), u.subVectors(l, r), w.subVectors(n, r), u.cross(w), g[q] += u.x, g[q + 1] += u.y, g[q + 2] += u.z, g[p] += u.x, g[p + 1] += u.y, g[p + 2] += u.z, g[h] += u.x, g[h + 1] += u.y, g[h + 2] += u.z;
          }
        }
      } else {
        for (f = 0, k = c.length;f < k;f += 9) {
          n.fromArray(c, f), r.fromArray(c, f + 3), l.fromArray(c, f + 6), u.subVectors(l, r), w.subVectors(n, r), u.cross(w), g[f] = u.x, g[f + 1] = u.y, g[f + 2] = u.z, g[f + 3] = u.x, g[f + 4] = u.y, g[f + 5] = u.z, g[f + 6] = u.x, g[f + 7] = u.y, g[f + 8] = u.z;
        }
      }
      this.normalizeNormals();
      a.normal.needsUpdate = !0;
    }
  }, merge:function(d, a) {
    if (!1 === (d && d.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", d);
    } else {
      void 0 === a && (a = 0);
      var b = this.attributes, c;
      for (c in b) {
        if (void 0 !== d.attributes[c]) {
          for (var m = b[c].array, e = d.attributes[c], g = e.array, f = 0, e = e.itemSize * a;f < g.length;f++, e++) {
            m[e] = g[f];
          }
        }
      }
      return this;
    }
  }, normalizeNormals:function() {
    for (var d = this.attributes.normal.array, a, b, c, e = 0, g = d.length;e < g;e += 3) {
      a = d[e], b = d[e + 1], c = d[e + 2], a = 1 / Math.sqrt(a * a + b * b + c * c), d[e] *= a, d[e + 1] *= a, d[e + 2] *= a;
    }
  }, toNonIndexed:function() {
    if (null === this.index) {
      return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
    }
    var d = new da, a = this.index.array, b = this.attributes, c;
    for (c in b) {
      for (var e = b[c], g = e.array, e = e.itemSize, f = new g.constructor(a.length * e), k, q = 0, p = 0, h = a.length;p < h;p++) {
        k = a[p] * e;
        for (var n = 0;n < e;n++) {
          f[q++] = g[k++];
        }
      }
      d.addAttribute(c, new ja(f, e));
    }
    return d;
  }, toJSON:function() {
    var d = {metadata:{version:4.4, type:"BufferGeometry", generator:"BufferGeometry.toJSON"}};
    d.uuid = this.uuid;
    d.type = this.type;
    "" !== this.name && (d.name = this.name);
    if (void 0 !== this.parameters) {
      var a = this.parameters, b;
      for (b in a) {
        void 0 !== a[b] && (d[b] = a[b]);
      }
      return d;
    }
    d.data = {attributes:{}};
    var c = this.index;
    null !== c && (a = Array.prototype.slice.call(c.array), d.data.index = {type:c.array.constructor.name, array:a});
    c = this.attributes;
    for (b in c) {
      var e = c[b], a = Array.prototype.slice.call(e.array);
      d.data.attributes[b] = {itemSize:e.itemSize, type:e.array.constructor.name, array:a, normalized:e.normalized};
    }
    b = this.groups;
    0 < b.length && (d.data.groups = JSON.parse(JSON.stringify(b)));
    b = this.boundingSphere;
    null !== b && (d.data.boundingSphere = {center:b.center.toArray(), radius:b.radius});
    return d;
  }, clone:function() {
    return (new da).copy(this);
  }, copy:function(d) {
    var a, b, c;
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingSphere = this.boundingBox = null;
    this.name = d.name;
    b = d.index;
    null !== b && this.setIndex(b.clone());
    b = d.attributes;
    for (a in b) {
      this.addAttribute(a, b[a].clone());
    }
    var e = d.morphAttributes;
    for (a in e) {
      var g = [], f = e[a];
      b = 0;
      for (c = f.length;b < c;b++) {
        g.push(f[b].clone());
      }
      this.morphAttributes[a] = g;
    }
    a = d.groups;
    b = 0;
    for (c = a.length;b < c;b++) {
      e = a[b], this.addGroup(e.start, e.count, e.materialIndex);
    }
    a = d.boundingBox;
    null !== a && (this.boundingBox = a.clone());
    a = d.boundingSphere;
    null !== a && (this.boundingSphere = a.clone());
    this.drawRange.start = d.drawRange.start;
    this.drawRange.count = d.drawRange.count;
    return this;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }});
  Ga.prototype = Object.assign(Object.create(U.prototype), {constructor:Ga, isMesh:!0, setDrawMode:function(d) {
    this.drawMode = d;
  }, copy:function(d) {
    U.prototype.copy.call(this, d);
    this.drawMode = d.drawMode;
    return this;
  }, updateMorphTargets:function() {
    var d = this.geometry.morphTargets;
    if (void 0 !== d && 0 < d.length) {
      this.morphTargetInfluences = [];
      this.morphTargetDictionary = {};
      for (var a = 0, b = d.length;a < b;a++) {
        this.morphTargetInfluences.push(0), this.morphTargetDictionary[d[a].name] = a;
      }
    }
  }, raycast:function() {
    function d(d, a, b, c, e, m, g) {
      Ia.barycoordFromPoint(d, a, b, c, B);
      e.multiplyScalar(B.x);
      m.multiplyScalar(B.y);
      g.multiplyScalar(B.z);
      e.add(m).add(g);
      return e.clone();
    }
    function a(d, a, b, c, e, m, g) {
      var f = d.material;
      if (null === (1 === f.side ? b.intersectTriangle(m, e, c, !0, g) : b.intersectTriangle(c, e, m, 2 !== f.side, g))) {
        return null;
      }
      x.copy(g);
      x.applyMatrix4(d.matrixWorld);
      b = a.ray.origin.distanceTo(x);
      return b < a.near || b > a.far ? null : {distance:b, point:x.clone(), object:d};
    }
    function b(b, c, e, m, g, f, p, n) {
      k.fromBufferAttribute(m, f);
      q.fromBufferAttribute(m, p);
      h.fromBufferAttribute(m, n);
      if (b = a(b, c, e, k, q, h, y)) {
        g && (w.fromBufferAttribute(g, f), t.fromBufferAttribute(g, p), v.fromBufferAttribute(g, n), b.uv = d(y, k, q, h, w, t, v)), b.face = new za(f, p, n, Ia.normal(k, q, h)), b.faceIndex = f;
      }
      return b;
    }
    var c = new p, g = new Ta, f = new Ba, k = new e, q = new e, h = new e, n = new e, r = new e, u = new e, w = new l, t = new l, v = new l, B = new e, y = new e, x = new e;
    return function(e, m) {
      var p = this.geometry, l = this.material, A = this.matrixWorld;
      if (void 0 !== l && (null === p.boundingSphere && p.computeBoundingSphere(), f.copy(p.boundingSphere), f.applyMatrix4(A), !1 !== e.ray.intersectsSphere(f) && (c.getInverse(A), g.copy(e.ray).applyMatrix4(c), null === p.boundingBox || !1 !== g.intersectsBox(p.boundingBox)))) {
        var B;
        if (p.isBufferGeometry) {
          var G, x, l = p.index, z = p.attributes.position, A = p.attributes.uv, C, O;
          if (null !== l) {
            for (C = 0, O = l.count;C < O;C += 3) {
              if (p = l.getX(C), G = l.getX(C + 1), x = l.getX(C + 2), B = b(this, e, g, z, A, p, G, x)) {
                B.faceIndex = Math.floor(C / 3), m.push(B);
              }
            }
          } else {
            for (C = 0, O = z.count;C < O;C += 3) {
              if (p = C, G = C + 1, x = C + 2, B = b(this, e, g, z, A, p, G, x)) {
                B.index = p, m.push(B);
              }
            }
          }
        } else {
          if (p.isGeometry) {
            var F, A = Array.isArray(l);
            C = p.vertices;
            O = p.faces;
            G = p.faceVertexUvs[0];
            0 < G.length && (z = G);
            for (var E = 0, D = O.length;E < D;E++) {
              var N = O[E];
              B = A ? l[N.materialIndex] : l;
              if (void 0 !== B) {
                G = C[N.a];
                x = C[N.b];
                F = C[N.c];
                if (!0 === B.morphTargets) {
                  B = p.morphTargets;
                  var aa = this.morphTargetInfluences;
                  k.set(0, 0, 0);
                  q.set(0, 0, 0);
                  h.set(0, 0, 0);
                  for (var I = 0, X = B.length;I < X;I++) {
                    var J = aa[I];
                    if (0 !== J) {
                      var Q = B[I].vertices;
                      k.addScaledVector(n.subVectors(Q[N.a], G), J);
                      q.addScaledVector(r.subVectors(Q[N.b], x), J);
                      h.addScaledVector(u.subVectors(Q[N.c], F), J);
                    }
                  }
                  k.add(G);
                  q.add(x);
                  h.add(F);
                  G = k;
                  x = q;
                  F = h;
                }
                if (B = a(this, e, g, G, x, F, y)) {
                  z && z[E] && (aa = z[E], w.copy(aa[0]), t.copy(aa[1]), v.copy(aa[2]), B.uv = d(y, G, x, F, w, t, v)), B.face = N, B.faceIndex = E, m.push(B);
                }
              }
            }
          }
        }
      }
    };
  }(), clone:function() {
    return (new this.constructor(this.geometry, this.material)).copy(this);
  }});
  Na.prototype = Object.create(ca.prototype);
  Na.prototype.constructor = Na;
  Va.prototype = Object.create(da.prototype);
  Va.prototype.constructor = Va;
  ob.prototype = Object.create(ca.prototype);
  ob.prototype.constructor = ob;
  Gb.prototype = Object.create(da.prototype);
  Gb.prototype.constructor = Gb;
  Ja.prototype = Object.create(U.prototype);
  Ja.prototype.constructor = Ja;
  Ja.prototype.isCamera = !0;
  Ja.prototype.getWorldDirection = function() {
    var d = new g;
    return function(a) {
      a = a || new e;
      this.getWorldQuaternion(d);
      return a.set(0, 0, -1).applyQuaternion(d);
    };
  }();
  Ja.prototype.clone = function() {
    return (new this.constructor).copy(this);
  };
  Ja.prototype.copy = function(d) {
    U.prototype.copy.call(this, d);
    this.matrixWorldInverse.copy(d.matrixWorldInverse);
    this.projectionMatrix.copy(d.projectionMatrix);
    return this;
  };
  Oa.prototype = Object.assign(Object.create(Ja.prototype), {constructor:Oa, isPerspectiveCamera:!0, copy:function(d) {
    Ja.prototype.copy.call(this, d);
    this.fov = d.fov;
    this.zoom = d.zoom;
    this.near = d.near;
    this.far = d.far;
    this.focus = d.focus;
    this.aspect = d.aspect;
    this.view = null === d.view ? null : Object.assign({}, d.view);
    this.filmGauge = d.filmGauge;
    this.filmOffset = d.filmOffset;
    return this;
  }, setFocalLength:function(d) {
    d = .5 * this.getFilmHeight() / d;
    this.fov = 2 * ka.RAD2DEG * Math.atan(d);
    this.updateProjectionMatrix();
  }, getFocalLength:function() {
    var d = Math.tan(.5 * ka.DEG2RAD * this.fov);
    return .5 * this.getFilmHeight() / d;
  }, getEffectiveFOV:function() {
    return 2 * ka.RAD2DEG * Math.atan(Math.tan(.5 * ka.DEG2RAD * this.fov) / this.zoom);
  }, getFilmWidth:function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }, getFilmHeight:function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }, setViewOffset:function(d, a, b, c, e, g) {
    this.aspect = d / a;
    this.view = {fullWidth:d, fullHeight:a, offsetX:b, offsetY:c, width:e, height:g};
    this.updateProjectionMatrix();
  }, clearViewOffset:function() {
    this.view = null;
    this.updateProjectionMatrix();
  }, updateProjectionMatrix:function() {
    var d = this.near, a = d * Math.tan(.5 * ka.DEG2RAD * this.fov) / this.zoom, b = 2 * a, c = this.aspect * b, e = -.5 * c, g = this.view;
    if (null !== g) {
      var f = g.fullWidth, k = g.fullHeight, e = e + g.offsetX * c / f, a = a - g.offsetY * b / k, c = g.width / f * c, b = g.height / k * b;
    }
    g = this.filmOffset;
    0 !== g && (e += d * g / this.getFilmWidth());
    this.projectionMatrix.makePerspective(e, e + c, a, a - b, d, this.far);
  }, toJSON:function(d) {
    d = U.prototype.toJSON.call(this, d);
    d.object.fov = this.fov;
    d.object.zoom = this.zoom;
    d.object.near = this.near;
    d.object.far = this.far;
    d.object.focus = this.focus;
    d.object.aspect = this.aspect;
    null !== this.view && (d.object.view = Object.assign({}, this.view));
    d.object.filmGauge = this.filmGauge;
    d.object.filmOffset = this.filmOffset;
    return d;
  }});
  Zb.prototype = Object.assign(Object.create(Ja.prototype), {constructor:Zb, isOrthographicCamera:!0, copy:function(d) {
    Ja.prototype.copy.call(this, d);
    this.left = d.left;
    this.right = d.right;
    this.top = d.top;
    this.bottom = d.bottom;
    this.near = d.near;
    this.far = d.far;
    this.zoom = d.zoom;
    this.view = null === d.view ? null : Object.assign({}, d.view);
    return this;
  }, setViewOffset:function(d, a, b, c, e, g) {
    this.view = {fullWidth:d, fullHeight:a, offsetX:b, offsetY:c, width:e, height:g};
    this.updateProjectionMatrix();
  }, clearViewOffset:function() {
    this.view = null;
    this.updateProjectionMatrix();
  }, updateProjectionMatrix:function() {
    var d = (this.right - this.left) / (2 * this.zoom), a = (this.top - this.bottom) / (2 * this.zoom), b = (this.right + this.left) / 2, c = (this.top + this.bottom) / 2, e = b - d, b = b + d, d = c + a, a = c - a;
    if (null !== this.view) {
      var b = this.zoom / (this.view.width / this.view.fullWidth), a = this.zoom / (this.view.height / this.view.fullHeight), g = (this.right - this.left) / this.view.width, c = (this.top - this.bottom) / this.view.height, e = e + this.view.offsetX / b * g, b = e + this.view.width / b * g, d = d - this.view.offsetY / a * c, a = d - this.view.height / a * c;
    }
    this.projectionMatrix.makeOrthographic(e, b, d, a, this.near, this.far);
  }, toJSON:function(d) {
    d = U.prototype.toJSON.call(this, d);
    d.object.zoom = this.zoom;
    d.object.left = this.left;
    d.object.right = this.right;
    d.object.top = this.top;
    d.object.bottom = this.bottom;
    d.object.near = this.near;
    d.object.far = this.far;
    null !== this.view && (d.object.view = Object.assign({}, this.view));
    return d;
  }});
  var kf = 0;
  ac.prototype.isFogExp2 = !0;
  ac.prototype.clone = function() {
    return new ac(this.color.getHex(), this.density);
  };
  ac.prototype.toJSON = function(d) {
    return {type:"FogExp2", color:this.color.getHex(), density:this.density};
  };
  bc.prototype.isFog = !0;
  bc.prototype.clone = function() {
    return new bc(this.color.getHex(), this.near, this.far);
  };
  bc.prototype.toJSON = function(d) {
    return {type:"Fog", color:this.color.getHex(), near:this.near, far:this.far};
  };
  xd.prototype = Object.assign(Object.create(U.prototype), {constructor:xd, copy:function(d, a) {
    U.prototype.copy.call(this, d, a);
    null !== d.background && (this.background = d.background.clone());
    null !== d.fog && (this.fog = d.fog.clone());
    null !== d.overrideMaterial && (this.overrideMaterial = d.overrideMaterial.clone());
    this.autoUpdate = d.autoUpdate;
    this.matrixAutoUpdate = d.matrixAutoUpdate;
    return this;
  }, toJSON:function(d) {
    var a = U.prototype.toJSON.call(this, d);
    null !== this.background && (a.object.background = this.background.toJSON(d));
    null !== this.fog && (a.object.fog = this.fog.toJSON());
    return a;
  }});
  ee.prototype = Object.assign(Object.create(U.prototype), {constructor:ee, isLensFlare:!0, copy:function(d) {
    U.prototype.copy.call(this, d);
    this.positionScreen.copy(d.positionScreen);
    this.customUpdateCallback = d.customUpdateCallback;
    for (var a = 0, b = d.lensFlares.length;a < b;a++) {
      this.lensFlares.push(d.lensFlares[a]);
    }
    return this;
  }, add:function(d, a, b, c, e, g) {
    void 0 === a && (a = -1);
    void 0 === b && (b = 0);
    void 0 === g && (g = 1);
    void 0 === e && (e = new T(16777215));
    void 0 === c && (c = 1);
    b = Math.min(b, Math.max(0, b));
    this.lensFlares.push({texture:d, size:a, distance:b, x:0, y:0, z:0, scale:1, rotation:0, opacity:g, color:e, blending:c});
  }, updateLensFlares:function() {
    var d, a = this.lensFlares.length, b, c = 2 * -this.positionScreen.x, e = 2 * -this.positionScreen.y;
    for (d = 0;d < a;d++) {
      b = this.lensFlares[d], b.x = this.positionScreen.x + c * b.distance, b.y = this.positionScreen.y + e * b.distance, b.wantedRotation = b.x * Math.PI * .25, b.rotation += .25 * (b.wantedRotation - b.rotation);
    }
  }});
  Eb.prototype = Object.create(W.prototype);
  Eb.prototype.constructor = Eb;
  Eb.prototype.isSpriteMaterial = !0;
  Eb.prototype.copy = function(d) {
    W.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.map = d.map;
    this.rotation = d.rotation;
    return this;
  };
  Nc.prototype = Object.assign(Object.create(U.prototype), {constructor:Nc, isSprite:!0, raycast:function() {
    var d = new e, a = new e, b = new e;
    return function(c, e) {
      a.setFromMatrixPosition(this.matrixWorld);
      c.ray.closestPointToPoint(a, d);
      b.setFromMatrixScale(this.matrixWorld);
      var g = b.x * b.y / 4;
      a.distanceToSquared(d) > g || (g = c.ray.origin.distanceTo(d), g < c.near || g > c.far || e.push({distance:g, point:d.clone(), face:null, object:this}));
    };
  }(), clone:function() {
    return (new this.constructor(this.material)).copy(this);
  }});
  Oc.prototype = Object.assign(Object.create(U.prototype), {constructor:Oc, copy:function(d) {
    U.prototype.copy.call(this, d, !1);
    d = d.levels;
    for (var a = 0, b = d.length;a < b;a++) {
      var c = d[a];
      this.addLevel(c.object.clone(), c.distance);
    }
    return this;
  }, addLevel:function(d, a) {
    void 0 === a && (a = 0);
    a = Math.abs(a);
    for (var b = this.levels, c = 0;c < b.length && !(a < b[c].distance);c++) {
    }
    b.splice(c, 0, {distance:a, object:d});
    this.add(d);
  }, getObjectForDistance:function(d) {
    for (var a = this.levels, b = 1, c = a.length;b < c && !(d < a[b].distance);b++) {
    }
    return a[b - 1].object;
  }, raycast:function() {
    var d = new e;
    return function(a, b) {
      d.setFromMatrixPosition(this.matrixWorld);
      var c = a.ray.origin.distanceTo(d);
      this.getObjectForDistance(c).raycast(a, b);
    };
  }(), update:function() {
    var d = new e, a = new e;
    return function(b) {
      var c = this.levels;
      if (1 < c.length) {
        d.setFromMatrixPosition(b.matrixWorld);
        a.setFromMatrixPosition(this.matrixWorld);
        b = d.distanceTo(a);
        c[0].object.visible = !0;
        for (var e = 1, g = c.length;e < g;e++) {
          if (b >= c[e].distance) {
            c[e - 1].object.visible = !1, c[e].object.visible = !0;
          } else {
            break;
          }
        }
        for (;e < g;e++) {
          c[e].object.visible = !1;
        }
      }
    };
  }(), toJSON:function(d) {
    d = U.prototype.toJSON.call(this, d);
    d.object.levels = [];
    for (var a = this.levels, b = 0, c = a.length;b < c;b++) {
      var e = a[b];
      d.object.levels.push({object:e.object.uuid, distance:e.distance});
    }
    return d;
  }});
  Object.assign(Pc.prototype, {calculateInverses:function() {
    this.boneInverses = [];
    for (var d = 0, a = this.bones.length;d < a;d++) {
      var b = new p;
      this.bones[d] && b.getInverse(this.bones[d].matrixWorld);
      this.boneInverses.push(b);
    }
  }, pose:function() {
    for (var d, a = 0, b = this.bones.length;a < b;a++) {
      (d = this.bones[a]) && d.matrixWorld.getInverse(this.boneInverses[a]);
    }
    a = 0;
    for (b = this.bones.length;a < b;a++) {
      if (d = this.bones[a]) {
        d.parent && d.parent.isBone ? (d.matrix.getInverse(d.parent.matrixWorld), d.matrix.multiply(d.matrixWorld)) : d.matrix.copy(d.matrixWorld), d.matrix.decompose(d.position, d.quaternion, d.scale);
      }
    }
  }, update:function() {
    var d = new p;
    return function() {
      for (var a = this.bones, b = this.boneInverses, c = this.boneMatrices, e = this.boneTexture, g = 0, f = a.length;g < f;g++) {
        d.multiplyMatrices(a[g] ? a[g].matrixWorld : this.identityMatrix, b[g]), d.toArray(c, 16 * g);
      }
      void 0 !== e && (e.needsUpdate = !0);
    };
  }(), clone:function() {
    return new Pc(this.bones, this.boneInverses);
  }});
  yd.prototype = Object.assign(Object.create(U.prototype), {constructor:yd, isBone:!0});
  zd.prototype = Object.assign(Object.create(Ga.prototype), {constructor:zd, isSkinnedMesh:!0, bind:function(d, a) {
    this.skeleton = d;
    void 0 === a && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), a = this.matrixWorld);
    this.bindMatrix.copy(a);
    this.bindMatrixInverse.getInverse(a);
  }, pose:function() {
    this.skeleton.pose();
  }, normalizeSkinWeights:function() {
    if (this.geometry && this.geometry.isGeometry) {
      for (var d = 0;d < this.geometry.skinWeights.length;d++) {
        var a = this.geometry.skinWeights[d], b = 1 / a.lengthManhattan();
        Infinity !== b ? a.multiplyScalar(b) : a.set(1, 0, 0, 0);
      }
    } else {
      if (this.geometry && this.geometry.isBufferGeometry) {
        for (var a = new f, c = this.geometry.attributes.skinWeight, d = 0;d < c.count;d++) {
          a.x = c.getX(d), a.y = c.getY(d), a.z = c.getZ(d), a.w = c.getW(d), b = 1 / a.lengthManhattan(), Infinity !== b ? a.multiplyScalar(b) : a.set(1, 0, 0, 0), c.setXYZW(d, a.x, a.y, a.z, a.w);
        }
      }
    }
  }, updateMatrixWorld:function() {
    Ga.prototype.updateMatrixWorld.call(this, !0);
    "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode);
  }, clone:function() {
    return (new this.constructor(this.geometry, this.material)).copy(this);
  }});
  wa.prototype = Object.create(W.prototype);
  wa.prototype.constructor = wa;
  wa.prototype.isLineBasicMaterial = !0;
  wa.prototype.copy = function(d) {
    W.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.linewidth = d.linewidth;
    this.linecap = d.linecap;
    this.linejoin = d.linejoin;
    return this;
  };
  db.prototype = Object.assign(Object.create(U.prototype), {constructor:db, isLine:!0, raycast:function() {
    var d = new p, a = new Ta, b = new Ba;
    return function(c, g) {
      var m = c.linePrecision, m = m * m, f = this.geometry, k = this.matrixWorld;
      null === f.boundingSphere && f.computeBoundingSphere();
      b.copy(f.boundingSphere);
      b.applyMatrix4(k);
      if (!1 !== c.ray.intersectsSphere(b)) {
        d.getInverse(k);
        a.copy(c.ray).applyMatrix4(d);
        var q = new e, p = new e, k = new e, h = new e, n = this && this.isLineSegments ? 2 : 1;
        if (f.isBufferGeometry) {
          var r = f.index, l = f.attributes.position.array;
          if (null !== r) {
            for (var r = r.array, f = 0, u = r.length - 1;f < u;f += n) {
              var w = r[f + 1];
              q.fromArray(l, 3 * r[f]);
              p.fromArray(l, 3 * w);
              w = a.distanceSqToSegment(q, p, h, k);
              w > m || (h.applyMatrix4(this.matrixWorld), w = c.ray.origin.distanceTo(h), w < c.near || w > c.far || g.push({distance:w, point:k.clone().applyMatrix4(this.matrixWorld), index:f, face:null, faceIndex:null, object:this}));
            }
          } else {
            for (f = 0, u = l.length / 3 - 1;f < u;f += n) {
              q.fromArray(l, 3 * f), p.fromArray(l, 3 * f + 3), w = a.distanceSqToSegment(q, p, h, k), w > m || (h.applyMatrix4(this.matrixWorld), w = c.ray.origin.distanceTo(h), w < c.near || w > c.far || g.push({distance:w, point:k.clone().applyMatrix4(this.matrixWorld), index:f, face:null, faceIndex:null, object:this}));
            }
          }
        } else {
          if (f.isGeometry) {
            for (q = f.vertices, p = q.length, f = 0;f < p - 1;f += n) {
              w = a.distanceSqToSegment(q[f], q[f + 1], h, k), w > m || (h.applyMatrix4(this.matrixWorld), w = c.ray.origin.distanceTo(h), w < c.near || w > c.far || g.push({distance:w, point:k.clone().applyMatrix4(this.matrixWorld), index:f, face:null, faceIndex:null, object:this}));
            }
          }
        }
      }
    };
  }(), clone:function() {
    return (new this.constructor(this.geometry, this.material)).copy(this);
  }});
  ua.prototype = Object.assign(Object.create(db.prototype), {constructor:ua, isLineSegments:!0});
  Ad.prototype = Object.assign(Object.create(db.prototype), {constructor:Ad, isLineLoop:!0});
  eb.prototype = Object.create(W.prototype);
  eb.prototype.constructor = eb;
  eb.prototype.isPointsMaterial = !0;
  eb.prototype.copy = function(d) {
    W.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.map = d.map;
    this.size = d.size;
    this.sizeAttenuation = d.sizeAttenuation;
    return this;
  };
  cc.prototype = Object.assign(Object.create(U.prototype), {constructor:cc, isPoints:!0, raycast:function() {
    var d = new p, a = new Ta, b = new Ba;
    return function(c, g) {
      function m(d, b) {
        var e = a.distanceSqToPoint(d);
        if (e < h) {
          d = a.closestPointToPoint(d);
          d.applyMatrix4(q);
          var m = c.ray.origin.distanceTo(d);
          m < c.near || m > c.far || g.push({distance:m, distanceToRay:Math.sqrt(e), point:d.clone(), index:b, face:null, object:f});
        }
      }
      var f = this, k = this.geometry, q = this.matrixWorld, p = c.params.Points.threshold;
      null === k.boundingSphere && k.computeBoundingSphere();
      b.copy(k.boundingSphere);
      b.applyMatrix4(q);
      b.radius += p;
      if (!1 !== c.ray.intersectsSphere(b)) {
        d.getInverse(q);
        a.copy(c.ray).applyMatrix4(d);
        var p = p / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = p * p, p = new e;
        if (k.isBufferGeometry) {
          var n = k.index, k = k.attributes.position.array;
          if (null !== n) {
            for (var r = n.array, n = 0, l = r.length;n < l;n++) {
              var u = r[n];
              p.fromArray(k, 3 * u);
              m(p, u);
            }
          } else {
            for (n = 0, r = k.length / 3;n < r;n++) {
              p.fromArray(k, 3 * n), m(p, n);
            }
          }
        } else {
          for (p = k.vertices, n = 0, r = p.length;n < r;n++) {
            m(p[n], n);
          }
        }
      }
    };
  }(), clone:function() {
    return (new this.constructor(this.geometry, this.material)).copy(this);
  }});
  Qc.prototype = Object.assign(Object.create(U.prototype), {constructor:Qc});
  Bd.prototype = Object.create(b.prototype);
  Bd.prototype.constructor = Bd;
  dc.prototype = Object.create(b.prototype);
  dc.prototype.constructor = dc;
  dc.prototype.isCompressedTexture = !0;
  Cd.prototype = Object.create(b.prototype);
  Cd.prototype.constructor = Cd;
  Rc.prototype = Object.create(b.prototype);
  Rc.prototype.constructor = Rc;
  Rc.prototype.isDepthTexture = !0;
  ec.prototype = Object.create(da.prototype);
  ec.prototype.constructor = ec;
  Sc.prototype = Object.create(ca.prototype);
  Sc.prototype.constructor = Sc;
  fc.prototype = Object.create(da.prototype);
  fc.prototype.constructor = fc;
  Tc.prototype = Object.create(ca.prototype);
  Tc.prototype.constructor = Tc;
  Qa.prototype = Object.create(da.prototype);
  Qa.prototype.constructor = Qa;
  Uc.prototype = Object.create(ca.prototype);
  Uc.prototype.constructor = Uc;
  gc.prototype = Object.create(Qa.prototype);
  gc.prototype.constructor = gc;
  Vc.prototype = Object.create(ca.prototype);
  Vc.prototype.constructor = Vc;
  Ib.prototype = Object.create(Qa.prototype);
  Ib.prototype.constructor = Ib;
  Wc.prototype = Object.create(ca.prototype);
  Wc.prototype.constructor = Wc;
  hc.prototype = Object.create(Qa.prototype);
  hc.prototype.constructor = hc;
  Xc.prototype = Object.create(ca.prototype);
  Xc.prototype.constructor = Xc;
  ic.prototype = Object.create(Qa.prototype);
  ic.prototype.constructor = ic;
  Yc.prototype = Object.create(ca.prototype);
  Yc.prototype.constructor = Yc;
  jc.prototype = Object.create(da.prototype);
  jc.prototype.constructor = jc;
  Zc.prototype = Object.create(ca.prototype);
  Zc.prototype.constructor = Zc;
  kc.prototype = Object.create(da.prototype);
  kc.prototype.constructor = kc;
  $c.prototype = Object.create(ca.prototype);
  $c.prototype.constructor = $c;
  lc.prototype = Object.create(da.prototype);
  lc.prototype.constructor = lc;
  var fb = {area:function(d) {
    for (var a = d.length, b = 0, c = a - 1, e = 0;e < a;c = e++) {
      b += d[c].x * d[e].y - d[e].x * d[c].y;
    }
    return .5 * b;
  }, triangulate:function() {
    return function(d, a) {
      var b = d.length;
      if (3 > b) {
        return null;
      }
      var c = [], e = [], g = [], m, f, k;
      if (0 < fb.area(d)) {
        for (f = 0;f < b;f++) {
          e[f] = f;
        }
      } else {
        for (f = 0;f < b;f++) {
          e[f] = b - 1 - f;
        }
      }
      var q = 2 * b;
      for (f = b - 1;2 < b;) {
        if (0 >= q--) {
          console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
          break;
        }
        m = f;
        b <= m && (m = 0);
        f = m + 1;
        b <= f && (f = 0);
        k = f + 1;
        b <= k && (k = 0);
        var p;
        a: {
          var h, n, r, l, u, w, t, v;
          h = d[e[m]].x;
          n = d[e[m]].y;
          r = d[e[f]].x;
          l = d[e[f]].y;
          u = d[e[k]].x;
          w = d[e[k]].y;
          if (0 >= (r - h) * (w - n) - (l - n) * (u - h)) {
            p = !1;
          } else {
            var B, y, x, z, C, F, E, D, N, I;
            B = u - r;
            y = w - l;
            x = h - u;
            z = n - w;
            C = r - h;
            F = l - n;
            for (p = 0;p < b;p++) {
              if (t = d[e[p]].x, v = d[e[p]].y, !(t === h && v === n || t === r && v === l || t === u && v === w) && (E = t - h, D = v - n, N = t - r, I = v - l, t -= u, v -= w, N = B * I - y * N, E = C * D - F * E, D = x * v - z * t, N >= -Number.EPSILON && D >= -Number.EPSILON && E >= -Number.EPSILON)) {
                p = !1;
                break a;
              }
            }
            p = !0;
          }
        }
        if (p) {
          c.push([d[e[m]], d[e[f]], d[e[k]]]);
          g.push([e[m], e[f], e[k]]);
          m = f;
          for (k = f + 1;k < b;m++, k++) {
            e[m] = e[k];
          }
          b--;
          q = 2 * b;
        }
      }
      return a ? g : c;
    };
  }(), triangulateShape:function(d, a) {
    function b(d) {
      var a = d.length;
      2 < a && d[a - 1].equals(d[0]) && d.pop();
    }
    function c(d, a, b) {
      return d.x !== a.x ? d.x < a.x ? d.x <= b.x && b.x <= a.x : a.x <= b.x && b.x <= d.x : d.y < a.y ? d.y <= b.y && b.y <= a.y : a.y <= b.y && b.y <= d.y;
    }
    function e(d, a, b, e, g) {
      var m = a.x - d.x, f = a.y - d.y, k = e.x - b.x, q = e.y - b.y, p = d.x - b.x, h = d.y - b.y, n = f * k - m * q, r = f * p - m * h;
      if (Math.abs(n) > Number.EPSILON) {
        if (0 < n) {
          if (0 > r || r > n) {
            return [];
          }
          k = q * p - k * h;
          if (0 > k || k > n) {
            return [];
          }
        } else {
          if (0 < r || r < n) {
            return [];
          }
          k = q * p - k * h;
          if (0 < k || k < n) {
            return [];
          }
        }
        if (0 === k) {
          return !g || 0 !== r && r !== n ? [d] : [];
        }
        if (k === n) {
          return !g || 0 !== r && r !== n ? [a] : [];
        }
        if (0 === r) {
          return [b];
        }
        if (r === n) {
          return [e];
        }
        g = k / n;
        return [{x:d.x + g * m, y:d.y + g * f}];
      }
      if (0 !== r || q * p !== k * h) {
        return [];
      }
      f = 0 === m && 0 === f;
      k = 0 === k && 0 === q;
      if (f && k) {
        return d.x !== b.x || d.y !== b.y ? [] : [d];
      }
      if (f) {
        return c(b, e, d) ? [d] : [];
      }
      if (k) {
        return c(d, a, b) ? [b] : [];
      }
      0 !== m ? (d.x < a.x ? (m = d, k = d.x, f = a, d = a.x) : (m = a, k = a.x, f = d, d = d.x), b.x < e.x ? (a = b, n = b.x, q = e, b = e.x) : (a = e, n = e.x, q = b, b = b.x)) : (d.y < a.y ? (m = d, k = d.y, f = a, d = a.y) : (m = a, k = a.y, f = d, d = d.y), b.y < e.y ? (a = b, n = b.y, q = e, b = e.y) : (a = e, n = e.y, q = b, b = b.y));
      return k <= n ? d < n ? [] : d === n ? g ? [] : [a] : d <= b ? [a, f] : [a, q] : k > b ? [] : k === b ? g ? [] : [m] : d <= b ? [m, f] : [m, q];
    }
    function g(d, a, b, c) {
      var e = a.x - d.x, g = a.y - d.y;
      a = b.x - d.x;
      b = b.y - d.y;
      var m = c.x - d.x;
      c = c.y - d.y;
      d = e * b - g * a;
      e = e * c - g * m;
      return Math.abs(d) > Number.EPSILON ? (a = m * b - c * a, 0 < d ? 0 <= e && 0 <= a : 0 <= e || 0 <= a) : 0 < e;
    }
    b(d);
    a.forEach(b);
    var m, f, k, q, p = {};
    k = d.concat();
    m = 0;
    for (f = a.length;m < f;m++) {
      Array.prototype.push.apply(k, a[m]);
    }
    m = 0;
    for (f = k.length;m < f;m++) {
      q = k[m].x + ":" + k[m].y, void 0 !== p[q] && console.warn("THREE.ShapeUtils: Duplicate point", q, m), p[q] = m;
    }
    m = function(d, a) {
      function b(d, a) {
        var b = f.length - 1, c = d - 1;
        0 > c && (c = b);
        var e = d + 1;
        e > b && (e = 0);
        b = g(f[d], f[c], f[e], k[a]);
        if (!b) {
          return !1;
        }
        b = k.length - 1;
        c = a - 1;
        0 > c && (c = b);
        e = a + 1;
        e > b && (e = 0);
        return g(k[a], k[c], k[e], f[d]) ? !0 : !1;
      }
      function c(d, a) {
        var b, c;
        for (b = 0;b < f.length;b++) {
          if (c = b + 1, c %= f.length, c = e(d, a, f[b], f[c], !0), 0 < c.length) {
            return !0;
          }
        }
        return !1;
      }
      function m(d, b) {
        var c, g, m, f;
        for (c = 0;c < q.length;c++) {
          for (g = a[q[c]], m = 0;m < g.length;m++) {
            if (f = m + 1, f %= g.length, f = e(d, b, g[m], g[f], !0), 0 < f.length) {
              return !0;
            }
          }
        }
        return !1;
      }
      var f = d.concat(), k, q = [], p, h, n, r, l = [], u, w, t, A = 0;
      for (d = a.length;A < d;A++) {
        q.push(A);
      }
      u = 0;
      for (var v = 2 * q.length;0 < q.length;) {
        v--;
        if (0 > v) {
          console.log("Infinite Loop! Holes left:" + q.length + ", Probably Hole outside Shape!");
          break;
        }
        for (p = u;p < f.length;p++) {
          h = f[p];
          d = -1;
          for (A = 0;A < q.length;A++) {
            if (n = q[A], r = h.x + ":" + h.y + ":" + n, void 0 === l[r]) {
              k = a[n];
              for (w = 0;w < k.length;w++) {
                if (n = k[w], b(p, w) && !c(h, n) && !m(h, n)) {
                  d = w;
                  q.splice(A, 1);
                  u = f.slice(0, p + 1);
                  n = f.slice(p);
                  w = k.slice(d);
                  t = k.slice(0, d + 1);
                  f = u.concat(w).concat(t).concat(n);
                  u = p;
                  break;
                }
              }
              if (0 <= d) {
                break;
              }
              l[r] = !0;
            }
          }
          if (0 <= d) {
            break;
          }
        }
      }
      return f;
    }(d, a);
    a = fb.triangulate(m, !1);
    m = 0;
    for (f = a.length;m < f;m++) {
      for (d = a[m], k = 0;3 > k;k++) {
        q = d[k].x + ":" + d[k].y, q = p[q], void 0 !== q && (d[k] = q);
      }
    }
    return a.concat();
  }, isClockWise:function(d) {
    return 0 > fb.area(d);
  }};
  bb.prototype = Object.create(ca.prototype);
  bb.prototype.constructor = bb;
  bb.prototype.addShapeList = function(d, a) {
    for (var b = d.length, c = 0;c < b;c++) {
      this.addShape(d[c], a);
    }
  };
  bb.prototype.addShape = function(d, a) {
    function b(d, a, b) {
      a || console.error("THREE.ExtrudeGeometry: vec does not exist");
      return a.clone().multiplyScalar(b).add(d);
    }
    function c(d, a, b) {
      var c, e, g;
      e = d.x - a.x;
      g = d.y - a.y;
      c = b.x - d.x;
      var m = b.y - d.y, f = e * e + g * g;
      if (Math.abs(e * m - g * c) > Number.EPSILON) {
        var k = Math.sqrt(f), q = Math.sqrt(c * c + m * m), f = a.x - g / k;
        a = a.y + e / k;
        m = ((b.x - m / q - f) * m - (b.y + c / q - a) * c) / (e * m - g * c);
        c = f + e * m - d.x;
        e = a + g * m - d.y;
        g = c * c + e * e;
        if (2 >= g) {
          return new l(c, e);
        }
        g = Math.sqrt(g / 2);
      } else {
        d = !1, e > Number.EPSILON ? c > Number.EPSILON && (d = !0) : e < -Number.EPSILON ? c < -Number.EPSILON && (d = !0) : Math.sign(g) === Math.sign(m) && (d = !0), d ? (c = -g, g = Math.sqrt(f)) : (c = e, e = g, g = Math.sqrt(f / 2));
      }
      return new l(c / g, e / g);
    }
    function g(d, a) {
      var b, c;
      for (H = d.length;0 <= --H;) {
        b = H;
        c = H - 1;
        0 > c && (c = d.length - 1);
        var e, g = u + 2 * h;
        for (e = 0;e < g;e++) {
          var m = M * e, f = M * (e + 1), k = a + b + m, m = a + c + m, q = a + c + f, f = a + b + f, k = k + I, m = m + I, q = q + I, f = f + I;
          N.faces.push(new za(k, m, f, null, null, 1));
          N.faces.push(new za(m, q, f, null, null, 1));
          k = B.generateSideWallUV(N, k, m, q, f);
          N.faceVertexUvs[0].push([k[0], k[1], k[3]]);
          N.faceVertexUvs[0].push([k[1], k[2], k[3]]);
        }
      }
    }
    function m(d, a, b) {
      N.vertices.push(new e(d, a, b));
    }
    function f(d, a, b) {
      d += I;
      a += I;
      b += I;
      N.faces.push(new za(d, a, b, null, null, 0));
      d = B.generateTopUV(N, d, a, b);
      N.faceVertexUvs[0].push(d);
    }
    var k = void 0 !== a.amount ? a.amount : 100, q = void 0 !== a.bevelThickness ? a.bevelThickness : 6, p = void 0 !== a.bevelSize ? a.bevelSize : q - 2, h = void 0 !== a.bevelSegments ? a.bevelSegments : 3, n = void 0 !== a.bevelEnabled ? a.bevelEnabled : !0, r = void 0 !== a.curveSegments ? a.curveSegments : 12, u = void 0 !== a.steps ? a.steps : 1, w = a.extrudePath, t, v = !1, B = void 0 !== a.UVGenerator ? a.UVGenerator : bb.WorldUVGenerator, y, x, z, C;
    w && (t = w.getSpacedPoints(u), v = !0, n = !1, y = void 0 !== a.frames ? a.frames : w.computeFrenetFrames(u, !1), x = new e, z = new e, C = new e);
    n || (p = q = h = 0);
    var F, E, D, N = this, I = this.vertices.length, w = d.extractPoints(r), r = w.shape, X = w.holes;
    if (w = !fb.isClockWise(r)) {
      r = r.reverse();
      E = 0;
      for (D = X.length;E < D;E++) {
        F = X[E], fb.isClockWise(F) && (X[E] = F.reverse());
      }
      w = !1;
    }
    var J = fb.triangulateShape(r, X), Z = r;
    E = 0;
    for (D = X.length;E < D;E++) {
      F = X[E], r = r.concat(F);
    }
    var L, S, ia, M = r.length, ea, R = J.length, w = [], H = 0;
    L = Z.length;
    d = L - 1;
    for (a = H + 1;H < L;H++, d++, a++) {
      d === L && (d = 0), a === L && (a = 0), w[H] = c(Z[H], Z[d], Z[a]);
    }
    var ba = [], P, T = w.concat();
    E = 0;
    for (D = X.length;E < D;E++) {
      F = X[E];
      P = [];
      H = 0;
      L = F.length;
      d = L - 1;
      for (a = H + 1;H < L;H++, d++, a++) {
        d === L && (d = 0), a === L && (a = 0), P[H] = c(F[H], F[d], F[a]);
      }
      ba.push(P);
      T = T.concat(P);
    }
    for (d = 0;d < h;d++) {
      L = d / h;
      S = q * Math.cos(L * Math.PI / 2);
      a = p * Math.sin(L * Math.PI / 2);
      H = 0;
      for (L = Z.length;H < L;H++) {
        ia = b(Z[H], w[H], a), m(ia.x, ia.y, -S);
      }
      E = 0;
      for (D = X.length;E < D;E++) {
        for (F = X[E], P = ba[E], H = 0, L = F.length;H < L;H++) {
          ia = b(F[H], P[H], a), m(ia.x, ia.y, -S);
        }
      }
    }
    a = p;
    for (H = 0;H < M;H++) {
      ia = n ? b(r[H], T[H], a) : r[H], v ? (z.copy(y.normals[0]).multiplyScalar(ia.x), x.copy(y.binormals[0]).multiplyScalar(ia.y), C.copy(t[0]).add(z).add(x), m(C.x, C.y, C.z)) : m(ia.x, ia.y, 0);
    }
    for (L = 1;L <= u;L++) {
      for (H = 0;H < M;H++) {
        ia = n ? b(r[H], T[H], a) : r[H], v ? (z.copy(y.normals[L]).multiplyScalar(ia.x), x.copy(y.binormals[L]).multiplyScalar(ia.y), C.copy(t[L]).add(z).add(x), m(C.x, C.y, C.z)) : m(ia.x, ia.y, k / u * L);
      }
    }
    for (d = h - 1;0 <= d;d--) {
      L = d / h;
      S = q * Math.cos(L * Math.PI / 2);
      a = p * Math.sin(L * Math.PI / 2);
      H = 0;
      for (L = Z.length;H < L;H++) {
        ia = b(Z[H], w[H], a), m(ia.x, ia.y, k + S);
      }
      E = 0;
      for (D = X.length;E < D;E++) {
        for (F = X[E], P = ba[E], H = 0, L = F.length;H < L;H++) {
          ia = b(F[H], P[H], a), v ? m(ia.x, ia.y + t[u - 1].y, t[u - 1].x + S) : m(ia.x, ia.y, k + S);
        }
      }
    }
    (function() {
      if (n) {
        var d = 0 * M;
        for (H = 0;H < R;H++) {
          ea = J[H], f(ea[2] + d, ea[1] + d, ea[0] + d);
        }
        d = M * (u + 2 * h);
        for (H = 0;H < R;H++) {
          ea = J[H], f(ea[0] + d, ea[1] + d, ea[2] + d);
        }
      } else {
        for (H = 0;H < R;H++) {
          ea = J[H], f(ea[2], ea[1], ea[0]);
        }
        for (H = 0;H < R;H++) {
          ea = J[H], f(ea[0] + M * u, ea[1] + M * u, ea[2] + M * u);
        }
      }
    })();
    (function() {
      var d = 0;
      g(Z, d);
      d += Z.length;
      E = 0;
      for (D = X.length;E < D;E++) {
        F = X[E], g(F, d), d += F.length;
      }
    })();
  };
  bb.WorldUVGenerator = {generateTopUV:function(d, a, b, c) {
    d = d.vertices;
    a = d[a];
    b = d[b];
    c = d[c];
    return [new l(a.x, a.y), new l(b.x, b.y), new l(c.x, c.y)];
  }, generateSideWallUV:function(d, a, b, c, e) {
    d = d.vertices;
    a = d[a];
    b = d[b];
    c = d[c];
    e = d[e];
    return .01 > Math.abs(a.y - b.y) ? [new l(a.x, 1 - a.z), new l(b.x, 1 - b.z), new l(c.x, 1 - c.z), new l(e.x, 1 - e.z)] : [new l(a.y, 1 - a.z), new l(b.y, 1 - b.z), new l(c.y, 1 - c.z), new l(e.y, 1 - e.z)];
  }};
  ad.prototype = Object.create(bb.prototype);
  ad.prototype.constructor = ad;
  bd.prototype = Object.create(ca.prototype);
  bd.prototype.constructor = bd;
  Jb.prototype = Object.create(da.prototype);
  Jb.prototype.constructor = Jb;
  cd.prototype = Object.create(ca.prototype);
  cd.prototype.constructor = cd;
  mc.prototype = Object.create(da.prototype);
  mc.prototype.constructor = mc;
  dd.prototype = Object.create(ca.prototype);
  dd.prototype.constructor = dd;
  nc.prototype = Object.create(da.prototype);
  nc.prototype.constructor = nc;
  oc.prototype = Object.create(ca.prototype);
  oc.prototype.constructor = oc;
  pc.prototype = Object.create(da.prototype);
  pc.prototype.constructor = pc;
  qc.prototype = Object.create(da.prototype);
  qc.prototype.constructor = qc;
  Kb.prototype = Object.create(ca.prototype);
  Kb.prototype.constructor = Kb;
  wb.prototype = Object.create(da.prototype);
  wb.prototype.constructor = wb;
  ed.prototype = Object.create(Kb.prototype);
  ed.prototype.constructor = ed;
  fd.prototype = Object.create(wb.prototype);
  fd.prototype.constructor = fd;
  gd.prototype = Object.create(ca.prototype);
  gd.prototype.constructor = gd;
  rc.prototype = Object.create(da.prototype);
  rc.prototype.constructor = rc;
  var jb = Object.freeze({WireframeGeometry:ec, ParametricGeometry:Sc, ParametricBufferGeometry:fc, TetrahedronGeometry:Uc, TetrahedronBufferGeometry:gc, OctahedronGeometry:Vc, OctahedronBufferGeometry:Ib, IcosahedronGeometry:Wc, IcosahedronBufferGeometry:hc, DodecahedronGeometry:Xc, DodecahedronBufferGeometry:ic, PolyhedronGeometry:Tc, PolyhedronBufferGeometry:Qa, TubeGeometry:Yc, TubeBufferGeometry:jc, TorusKnotGeometry:Zc, TorusKnotBufferGeometry:kc, TorusGeometry:$c, TorusBufferGeometry:lc, TextGeometry:ad, 
  SphereGeometry:bd, SphereBufferGeometry:Jb, RingGeometry:cd, RingBufferGeometry:mc, PlaneGeometry:ob, PlaneBufferGeometry:Gb, LatheGeometry:dd, LatheBufferGeometry:nc, ShapeGeometry:oc, ShapeBufferGeometry:pc, ExtrudeGeometry:bb, EdgesGeometry:qc, ConeGeometry:ed, ConeBufferGeometry:fd, CylinderGeometry:Kb, CylinderBufferGeometry:wb, CircleGeometry:gd, CircleBufferGeometry:rc, BoxGeometry:Na, BoxBufferGeometry:Va});
  sc.prototype = Object.create(sa.prototype);
  sc.prototype.constructor = sc;
  sc.prototype.isShadowMaterial = !0;
  tc.prototype = Object.create(sa.prototype);
  tc.prototype.constructor = tc;
  tc.prototype.isRawShaderMaterial = !0;
  rb.prototype = Object.create(W.prototype);
  rb.prototype.constructor = rb;
  rb.prototype.isMeshStandardMaterial = !0;
  rb.prototype.copy = function(d) {
    W.prototype.copy.call(this, d);
    this.defines = {STANDARD:""};
    this.color.copy(d.color);
    this.roughness = d.roughness;
    this.metalness = d.metalness;
    this.map = d.map;
    this.lightMap = d.lightMap;
    this.lightMapIntensity = d.lightMapIntensity;
    this.aoMap = d.aoMap;
    this.aoMapIntensity = d.aoMapIntensity;
    this.emissive.copy(d.emissive);
    this.emissiveMap = d.emissiveMap;
    this.emissiveIntensity = d.emissiveIntensity;
    this.bumpMap = d.bumpMap;
    this.bumpScale = d.bumpScale;
    this.normalMap = d.normalMap;
    this.normalScale.copy(d.normalScale);
    this.displacementMap = d.displacementMap;
    this.displacementScale = d.displacementScale;
    this.displacementBias = d.displacementBias;
    this.roughnessMap = d.roughnessMap;
    this.metalnessMap = d.metalnessMap;
    this.alphaMap = d.alphaMap;
    this.envMap = d.envMap;
    this.envMapIntensity = d.envMapIntensity;
    this.refractionRatio = d.refractionRatio;
    this.wireframe = d.wireframe;
    this.wireframeLinewidth = d.wireframeLinewidth;
    this.wireframeLinecap = d.wireframeLinecap;
    this.wireframeLinejoin = d.wireframeLinejoin;
    this.morphTargets = d.morphTargets;
    this.morphNormals = d.morphNormals;
    return this;
  };
  Lb.prototype = Object.create(rb.prototype);
  Lb.prototype.constructor = Lb;
  Lb.prototype.isMeshPhysicalMaterial = !0;
  Lb.prototype.copy = function(d) {
    rb.prototype.copy.call(this, d);
    this.defines = {PHYSICAL:""};
    this.reflectivity = d.reflectivity;
    this.clearCoat = d.clearCoat;
    this.clearCoatRoughness = d.clearCoatRoughness;
    return this;
  };
  gb.prototype = Object.create(W.prototype);
  gb.prototype.constructor = gb;
  gb.prototype.isMeshPhongMaterial = !0;
  gb.prototype.copy = function(d) {
    W.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.specular.copy(d.specular);
    this.shininess = d.shininess;
    this.map = d.map;
    this.lightMap = d.lightMap;
    this.lightMapIntensity = d.lightMapIntensity;
    this.aoMap = d.aoMap;
    this.aoMapIntensity = d.aoMapIntensity;
    this.emissive.copy(d.emissive);
    this.emissiveMap = d.emissiveMap;
    this.emissiveIntensity = d.emissiveIntensity;
    this.bumpMap = d.bumpMap;
    this.bumpScale = d.bumpScale;
    this.normalMap = d.normalMap;
    this.normalScale.copy(d.normalScale);
    this.displacementMap = d.displacementMap;
    this.displacementScale = d.displacementScale;
    this.displacementBias = d.displacementBias;
    this.specularMap = d.specularMap;
    this.alphaMap = d.alphaMap;
    this.envMap = d.envMap;
    this.combine = d.combine;
    this.reflectivity = d.reflectivity;
    this.refractionRatio = d.refractionRatio;
    this.wireframe = d.wireframe;
    this.wireframeLinewidth = d.wireframeLinewidth;
    this.wireframeLinecap = d.wireframeLinecap;
    this.wireframeLinejoin = d.wireframeLinejoin;
    this.morphTargets = d.morphTargets;
    this.morphNormals = d.morphNormals;
    return this;
  };
  Mb.prototype = Object.create(gb.prototype);
  Mb.prototype.constructor = Mb;
  Mb.prototype.isMeshToonMaterial = !0;
  Mb.prototype.copy = function(d) {
    gb.prototype.copy.call(this, d);
    this.gradientMap = d.gradientMap;
    return this;
  };
  Nb.prototype = Object.create(W.prototype);
  Nb.prototype.constructor = Nb;
  Nb.prototype.isMeshNormalMaterial = !0;
  Nb.prototype.copy = function(d) {
    W.prototype.copy.call(this, d);
    this.bumpMap = d.bumpMap;
    this.bumpScale = d.bumpScale;
    this.normalMap = d.normalMap;
    this.normalScale.copy(d.normalScale);
    this.displacementMap = d.displacementMap;
    this.displacementScale = d.displacementScale;
    this.displacementBias = d.displacementBias;
    this.wireframe = d.wireframe;
    this.wireframeLinewidth = d.wireframeLinewidth;
    this.morphTargets = d.morphTargets;
    this.morphNormals = d.morphNormals;
    return this;
  };
  Ob.prototype = Object.create(W.prototype);
  Ob.prototype.constructor = Ob;
  Ob.prototype.isMeshLambertMaterial = !0;
  Ob.prototype.copy = function(d) {
    W.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.map = d.map;
    this.lightMap = d.lightMap;
    this.lightMapIntensity = d.lightMapIntensity;
    this.aoMap = d.aoMap;
    this.aoMapIntensity = d.aoMapIntensity;
    this.emissive.copy(d.emissive);
    this.emissiveMap = d.emissiveMap;
    this.emissiveIntensity = d.emissiveIntensity;
    this.specularMap = d.specularMap;
    this.alphaMap = d.alphaMap;
    this.envMap = d.envMap;
    this.combine = d.combine;
    this.reflectivity = d.reflectivity;
    this.refractionRatio = d.refractionRatio;
    this.wireframe = d.wireframe;
    this.wireframeLinewidth = d.wireframeLinewidth;
    this.wireframeLinecap = d.wireframeLinecap;
    this.wireframeLinejoin = d.wireframeLinejoin;
    this.morphTargets = d.morphTargets;
    this.morphNormals = d.morphNormals;
    return this;
  };
  Pb.prototype = Object.create(W.prototype);
  Pb.prototype.constructor = Pb;
  Pb.prototype.isLineDashedMaterial = !0;
  Pb.prototype.copy = function(d) {
    W.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.linewidth = d.linewidth;
    this.scale = d.scale;
    this.dashSize = d.dashSize;
    this.gapSize = d.gapSize;
    return this;
  };
  var uf = Object.freeze({ShadowMaterial:sc, SpriteMaterial:Eb, RawShaderMaterial:tc, ShaderMaterial:sa, PointsMaterial:eb, MeshPhysicalMaterial:Lb, MeshStandardMaterial:rb, MeshPhongMaterial:gb, MeshToonMaterial:Mb, MeshNormalMaterial:Nb, MeshLambertMaterial:Ob, MeshDepthMaterial:xa, MeshBasicMaterial:Ka, LineDashedMaterial:Pb, LineBasicMaterial:wa, Material:W}), ud = {enabled:!1, files:{}, add:function(d, a) {
    !1 !== this.enabled && (this.files[d] = a);
  }, get:function(d) {
    if (!1 !== this.enabled) {
      return this.files[d];
    }
  }, remove:function(d) {
    delete this.files[d];
  }, clear:function() {
    this.files = {};
  }}, Ya = new fe;
  Object.assign(hb.prototype, {load:function(d, a, b, c) {
    void 0 === d && (d = "");
    void 0 !== this.path && (d = this.path + d);
    var e = this, g = ud.get(d);
    if (void 0 !== g) {
      return e.manager.itemStart(d), setTimeout(function() {
        a && a(g);
        e.manager.itemEnd(d);
      }, 0), g;
    }
    var m = d.match(/^data:(.*?)(;base64)?,(.*)$/);
    if (m) {
      var f = m[1], k = !!m[2], m = m[3], m = window.decodeURIComponent(m);
      k && (m = window.atob(m));
      try {
        var q, p = (this.responseType || "").toLowerCase();
        switch(p) {
          case "arraybuffer":
          case "blob":
            q = new ArrayBuffer(m.length);
            for (var h = new Uint8Array(q), k = 0;k < m.length;k++) {
              h[k] = m.charCodeAt(k);
            }
            "blob" === p && (q = new Blob([q], {type:f}));
            break;
          case "document":
            q = (new DOMParser).parseFromString(m, f);
            break;
          case "json":
            q = JSON.parse(m);
            break;
          default:
            q = m;
        }
        window.setTimeout(function() {
          a && a(q);
          e.manager.itemEnd(d);
        }, 0);
      } catch ($e) {
        window.setTimeout(function() {
          c && c($e);
          e.manager.itemError(d);
        }, 0);
      }
    } else {
      var n = new XMLHttpRequest;
      n.open("GET", d, !0);
      n.addEventListener("load", function(b) {
        var g = b.target.response;
        ud.add(d, g);
        200 === this.status ? (a && a(g), e.manager.itemEnd(d)) : 0 === this.status ? (console.warn("THREE.FileLoader: HTTP Status 0 received."), a && a(g), e.manager.itemEnd(d)) : (c && c(b), e.manager.itemError(d));
      }, !1);
      void 0 !== b && n.addEventListener("progress", function(d) {
        b(d);
      }, !1);
      n.addEventListener("error", function(a) {
        c && c(a);
        e.manager.itemError(d);
      }, !1);
      void 0 !== this.responseType && (n.responseType = this.responseType);
      void 0 !== this.withCredentials && (n.withCredentials = this.withCredentials);
      n.overrideMimeType && n.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
      for (f in this.requestHeader) {
        n.setRequestHeader(f, this.requestHeader[f]);
      }
      n.send(null);
    }
    e.manager.itemStart(d);
    return n;
  }, setPath:function(d) {
    this.path = d;
    return this;
  }, setResponseType:function(d) {
    this.responseType = d;
    return this;
  }, setWithCredentials:function(d) {
    this.withCredentials = d;
    return this;
  }, setMimeType:function(d) {
    this.mimeType = d;
    return this;
  }, setRequestHeader:function(d) {
    this.requestHeader = d;
    return this;
  }});
  Object.assign(Ie.prototype, {load:function(d, a, b, c) {
    function e(e) {
      k.load(d[e], function(d) {
        d = g._parser(d, !0);
        m[e] = {width:d.width, height:d.height, format:d.format, mipmaps:d.mipmaps};
        q += 1;
        6 === q && (1 === d.mipmapCount && (f.minFilter = 1006), f.format = d.format, f.needsUpdate = !0, a && a(f));
      }, b, c);
    }
    var g = this, m = [], f = new dc;
    f.image = m;
    var k = new hb(this.manager);
    k.setPath(this.path);
    k.setResponseType("arraybuffer");
    if (Array.isArray(d)) {
      for (var q = 0, p = 0, h = d.length;p < h;++p) {
        e(p);
      }
    } else {
      k.load(d, function(d) {
        d = g._parser(d, !0);
        if (d.isCubemap) {
          for (var b = d.mipmaps.length / d.mipmapCount, c = 0;c < b;c++) {
            m[c] = {mipmaps:[]};
            for (var e = 0;e < d.mipmapCount;e++) {
              m[c].mipmaps.push(d.mipmaps[c * d.mipmapCount + e]), m[c].format = d.format, m[c].width = d.width, m[c].height = d.height;
            }
          }
        } else {
          f.image.width = d.width, f.image.height = d.height, f.mipmaps = d.mipmaps;
        }
        1 === d.mipmapCount && (f.minFilter = 1006);
        f.format = d.format;
        f.needsUpdate = !0;
        a && a(f);
      }, b, c);
    }
    return f;
  }, setPath:function(d) {
    this.path = d;
    return this;
  }});
  Object.assign(ge.prototype, {load:function(d, a, b, c) {
    var e = this, g = new ra, m = new hb(this.manager);
    m.setResponseType("arraybuffer");
    m.load(d, function(d) {
      if (d = e._parser(d)) {
        void 0 !== d.image ? g.image = d.image : void 0 !== d.data && (g.image.width = d.width, g.image.height = d.height, g.image.data = d.data), g.wrapS = void 0 !== d.wrapS ? d.wrapS : 1001, g.wrapT = void 0 !== d.wrapT ? d.wrapT : 1001, g.magFilter = void 0 !== d.magFilter ? d.magFilter : 1006, g.minFilter = void 0 !== d.minFilter ? d.minFilter : 1008, g.anisotropy = void 0 !== d.anisotropy ? d.anisotropy : 1, void 0 !== d.format && (g.format = d.format), void 0 !== d.type && (g.type = d.type), 
        void 0 !== d.mipmaps && (g.mipmaps = d.mipmaps), 1 === d.mipmapCount && (g.minFilter = 1006), g.needsUpdate = !0, a && a(g, d);
      }
    }, b, c);
    return g;
  }});
  Object.assign(hd.prototype, {load:function(d, a, b, c) {
    void 0 === d && (d = "");
    void 0 !== this.path && (d = this.path + d);
    var e = this, g = ud.get(d);
    if (void 0 !== g) {
      return e.manager.itemStart(d), setTimeout(function() {
        a && a(g);
        e.manager.itemEnd(d);
      }, 0), g;
    }
    b = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    b.addEventListener("load", function() {
      ud.add(d, this);
      a && a(this);
      e.manager.itemEnd(d);
    }, !1);
    b.addEventListener("error", function(a) {
      c && c(a);
      e.manager.itemError(d);
    }, !1);
    "data:" !== d.substr(0, 5) && void 0 !== this.crossOrigin && (b.crossOrigin = this.crossOrigin);
    e.manager.itemStart(d);
    b.src = d;
    return b;
  }, setCrossOrigin:function(d) {
    this.crossOrigin = d;
    return this;
  }, setPath:function(d) {
    this.path = d;
    return this;
  }});
  Object.assign(he.prototype, {load:function(d, a, b, c) {
    function e(b) {
      m.load(d[b], function(d) {
        g.images[b] = d;
        f++;
        6 === f && (g.needsUpdate = !0, a && a(g));
      }, void 0, c);
    }
    var g = new r, m = new hd(this.manager);
    m.setCrossOrigin(this.crossOrigin);
    m.setPath(this.path);
    var f = 0;
    for (b = 0;b < d.length;++b) {
      e(b);
    }
    return g;
  }, setCrossOrigin:function(d) {
    this.crossOrigin = d;
    return this;
  }, setPath:function(d) {
    this.path = d;
    return this;
  }});
  Object.assign(Dd.prototype, {load:function(d, a, c, e) {
    var g = new hd(this.manager);
    g.setCrossOrigin(this.crossOrigin);
    g.setPath(this.path);
    var m = new b;
    m.image = g.load(d, function() {
      var b = 0 < d.search(/\.(jpg|jpeg)$/) || 0 === d.search(/^data\:image\/jpeg/);
      m.format = b ? 1022 : 1023;
      m.needsUpdate = !0;
      void 0 !== a && a(m);
    }, c, e);
    return m;
  }, setCrossOrigin:function(d) {
    this.crossOrigin = d;
    return this;
  }, setPath:function(d) {
    this.path = d;
    return this;
  }});
  Ca.prototype = Object.assign(Object.create(U.prototype), {constructor:Ca, isLight:!0, copy:function(d) {
    U.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.intensity = d.intensity;
    return this;
  }, toJSON:function(d) {
    d = U.prototype.toJSON.call(this, d);
    d.object.color = this.color.getHex();
    d.object.intensity = this.intensity;
    void 0 !== this.groundColor && (d.object.groundColor = this.groundColor.getHex());
    void 0 !== this.distance && (d.object.distance = this.distance);
    void 0 !== this.angle && (d.object.angle = this.angle);
    void 0 !== this.decay && (d.object.decay = this.decay);
    void 0 !== this.penumbra && (d.object.penumbra = this.penumbra);
    void 0 !== this.shadow && (d.object.shadow = this.shadow.toJSON());
    return d;
  }});
  Ed.prototype = Object.assign(Object.create(Ca.prototype), {constructor:Ed, isHemisphereLight:!0, copy:function(d) {
    Ca.prototype.copy.call(this, d);
    this.groundColor.copy(d.groundColor);
    return this;
  }});
  Object.assign(Qb.prototype, {copy:function(d) {
    this.camera = d.camera.clone();
    this.bias = d.bias;
    this.radius = d.radius;
    this.mapSize.copy(d.mapSize);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, toJSON:function() {
    var d = {};
    0 !== this.bias && (d.bias = this.bias);
    1 !== this.radius && (d.radius = this.radius);
    if (512 !== this.mapSize.x || 512 !== this.mapSize.y) {
      d.mapSize = this.mapSize.toArray();
    }
    d.camera = this.camera.toJSON(!1).object;
    delete d.camera.matrix;
    return d;
  }});
  Fd.prototype = Object.assign(Object.create(Qb.prototype), {constructor:Fd, isSpotLightShadow:!0, update:function(d) {
    var a = 2 * ka.RAD2DEG * d.angle, b = this.mapSize.width / this.mapSize.height;
    d = d.distance || 500;
    var c = this.camera;
    if (a !== c.fov || b !== c.aspect || d !== c.far) {
      c.fov = a, c.aspect = b, c.far = d, c.updateProjectionMatrix();
    }
  }});
  Gd.prototype = Object.assign(Object.create(Ca.prototype), {constructor:Gd, isSpotLight:!0, copy:function(d) {
    Ca.prototype.copy.call(this, d);
    this.distance = d.distance;
    this.angle = d.angle;
    this.penumbra = d.penumbra;
    this.decay = d.decay;
    this.target = d.target.clone();
    this.shadow = d.shadow.clone();
    return this;
  }});
  Hd.prototype = Object.assign(Object.create(Ca.prototype), {constructor:Hd, isPointLight:!0, copy:function(d) {
    Ca.prototype.copy.call(this, d);
    this.distance = d.distance;
    this.decay = d.decay;
    this.shadow = d.shadow.clone();
    return this;
  }});
  Id.prototype = Object.assign(Object.create(Qb.prototype), {constructor:Id});
  Jd.prototype = Object.assign(Object.create(Ca.prototype), {constructor:Jd, isDirectionalLight:!0, copy:function(d) {
    Ca.prototype.copy.call(this, d);
    this.target = d.target.clone();
    this.shadow = d.shadow.clone();
    return this;
  }});
  Kd.prototype = Object.assign(Object.create(Ca.prototype), {constructor:Kd, isAmbientLight:!0});
  Ld.prototype = Object.assign(Object.create(Ca.prototype), {constructor:Ld, isRectAreaLight:!0, copy:function(d) {
    Ca.prototype.copy.call(this, d);
    this.width = d.width;
    this.height = d.height;
    return this;
  }, toJSON:function(d) {
    d = Ca.prototype.toJSON.call(this, d);
    d.object.width = this.width;
    d.object.height = this.height;
    return d;
  }});
  var Fa = {arraySlice:function(d, a, b) {
    return Fa.isTypedArray(d) ? new d.constructor(d.subarray(a, void 0 !== b ? b : d.length)) : d.slice(a, b);
  }, convertArray:function(d, a, b) {
    return !d || !b && d.constructor === a ? d : "number" === typeof a.BYTES_PER_ELEMENT ? new a(d) : Array.prototype.slice.call(d);
  }, isTypedArray:function(d) {
    return ArrayBuffer.isView(d) && !(d instanceof DataView);
  }, getKeyframeOrder:function(d) {
    for (var a = d.length, b = Array(a), c = 0;c !== a;++c) {
      b[c] = c;
    }
    b.sort(function(a, b) {
      return d[a] - d[b];
    });
    return b;
  }, sortedArray:function(d, a, b) {
    for (var c = d.length, e = new d.constructor(c), g = 0, m = 0;m !== c;++g) {
      for (var f = b[g] * a, k = 0;k !== a;++k) {
        e[m++] = d[f + k];
      }
    }
    return e;
  }, flattenJSON:function(d, a, b, c) {
    for (var e = 1, g = d[0];void 0 !== g && void 0 === g[c];) {
      g = d[e++];
    }
    if (void 0 !== g) {
      var m = g[c];
      if (void 0 !== m) {
        if (Array.isArray(m)) {
          do {
            m = g[c], void 0 !== m && (a.push(g.time), b.push.apply(b, m)), g = d[e++];
          } while (void 0 !== g);
        } else {
          if (void 0 !== m.toArray) {
            do {
              m = g[c], void 0 !== m && (a.push(g.time), m.toArray(b, b.length)), g = d[e++];
            } while (void 0 !== g);
          } else {
            do {
              m = g[c], void 0 !== m && (a.push(g.time), b.push(m)), g = d[e++];
            } while (void 0 !== g);
          }
        }
      }
    }
  }};
  Object.assign(Za.prototype, {evaluate:function(d) {
    var a = this.parameterPositions, b = this._cachedIndex, c = a[b], e = a[b - 1];
    a: {
      b: {
        c: {
          d: {
            if (!(d < c)) {
              for (var g = b + 2;;) {
                if (void 0 === c) {
                  if (d < e) {
                    break d;
                  }
                  this._cachedIndex = b = a.length;
                  return this.afterEnd_(b - 1, d, e);
                }
                if (b === g) {
                  break;
                }
                e = c;
                c = a[++b];
                if (d < c) {
                  break b;
                }
              }
              c = a.length;
              break c;
            }
          }
          if (d >= e) {
            break a;
          } else {
            g = a[1];
            d < g && (b = 2, e = g);
            for (g = b - 2;;) {
              if (void 0 === e) {
                return this._cachedIndex = 0, this.beforeStart_(0, d, c);
              }
              if (b === g) {
                break;
              }
              c = e;
              e = a[--b - 1];
              if (d >= e) {
                break b;
              }
            }
            c = b;
            b = 0;
          }
        }
        for (;b < c;) {
          e = b + c >>> 1, d < a[e] ? c = e : b = e + 1;
        }
        c = a[b];
        e = a[b - 1];
        if (void 0 === e) {
          return this._cachedIndex = 0, this.beforeStart_(0, d, c);
        }
        if (void 0 === c) {
          return this._cachedIndex = b = a.length, this.afterEnd_(b - 1, e, d);
        }
      }
      this._cachedIndex = b;
      this.intervalChanged_(b, e, c);
    }
    return this.interpolate_(b, e, d, c);
  }, settings:null, DefaultSettings_:{}, getSettings_:function() {
    return this.settings || this.DefaultSettings_;
  }, copySampleValue_:function(d) {
    var a = this.resultBuffer, b = this.sampleValues, c = this.valueSize;
    d *= c;
    for (var e = 0;e !== c;++e) {
      a[e] = b[d + e];
    }
    return a;
  }, interpolate_:function(d, a, b, c) {
    throw Error("call to abstract method");
  }, intervalChanged_:function(d, a, b) {
  }});
  Object.assign(Za.prototype, {beforeStart_:Za.prototype.copySampleValue_, afterEnd_:Za.prototype.copySampleValue_});
  Md.prototype = Object.assign(Object.create(Za.prototype), {constructor:Md, DefaultSettings_:{endingStart:2400, endingEnd:2400}, intervalChanged_:function(d, a, b) {
    var c = this.parameterPositions, e = d - 2, g = d + 1, m = c[e], f = c[g];
    if (void 0 === m) {
      switch(this.getSettings_().endingStart) {
        case 2401:
          e = d;
          m = 2 * a - b;
          break;
        case 2402:
          e = c.length - 2;
          m = a + c[e] - c[e + 1];
          break;
        default:
          e = d, m = b;
      }
    }
    if (void 0 === f) {
      switch(this.getSettings_().endingEnd) {
        case 2401:
          g = d;
          f = 2 * b - a;
          break;
        case 2402:
          g = 1;
          f = b + c[1] - c[0];
          break;
        default:
          g = d - 1, f = a;
      }
    }
    d = .5 * (b - a);
    c = this.valueSize;
    this._weightPrev = d / (a - m);
    this._weightNext = d / (f - b);
    this._offsetPrev = e * c;
    this._offsetNext = g * c;
  }, interpolate_:function(d, a, b, c) {
    var e = this.resultBuffer, g = this.sampleValues, m = this.valueSize;
    d *= m;
    var f = d - m, k = this._offsetPrev, q = this._offsetNext, p = this._weightPrev, h = this._weightNext, n = (b - a) / (c - a);
    b = n * n;
    c = b * n;
    a = -p * c + 2 * p * b - p * n;
    p = (1 + p) * c + (-1.5 - 2 * p) * b + (-.5 + p) * n + 1;
    n = (-1 - h) * c + (1.5 + h) * b + .5 * n;
    h = h * c - h * b;
    for (b = 0;b !== m;++b) {
      e[b] = a * g[k + b] + p * g[f + b] + n * g[d + b] + h * g[q + b];
    }
    return e;
  }});
  id.prototype = Object.assign(Object.create(Za.prototype), {constructor:id, interpolate_:function(d, a, b, c) {
    var e = this.resultBuffer, g = this.sampleValues, m = this.valueSize;
    d *= m;
    var f = d - m;
    a = (b - a) / (c - a);
    b = 1 - a;
    for (c = 0;c !== m;++c) {
      e[c] = g[f + c] * b + g[d + c] * a;
    }
    return e;
  }});
  Nd.prototype = Object.assign(Object.create(Za.prototype), {constructor:Nd, interpolate_:function(d, a, b, c) {
    return this.copySampleValue_(d - 1);
  }});
  var yb;
  yb = {TimeBufferType:Float32Array, ValueBufferType:Float32Array, DefaultInterpolation:2301, InterpolantFactoryMethodDiscrete:function(d) {
    return new Nd(this.times, this.values, this.getValueSize(), d);
  }, InterpolantFactoryMethodLinear:function(d) {
    return new id(this.times, this.values, this.getValueSize(), d);
  }, InterpolantFactoryMethodSmooth:function(d) {
    return new Md(this.times, this.values, this.getValueSize(), d);
  }, setInterpolation:function(d) {
    var a;
    switch(d) {
      case 2300:
        a = this.InterpolantFactoryMethodDiscrete;
        break;
      case 2301:
        a = this.InterpolantFactoryMethodLinear;
        break;
      case 2302:
        a = this.InterpolantFactoryMethodSmooth;
    }
    if (void 0 === a) {
      a = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (void 0 === this.createInterpolant) {
        if (d !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw Error(a);
        }
      }
      console.warn(a);
    } else {
      this.createInterpolant = a;
    }
  }, getInterpolation:function() {
    switch(this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return 2300;
      case this.InterpolantFactoryMethodLinear:
        return 2301;
      case this.InterpolantFactoryMethodSmooth:
        return 2302;
    }
  }, getValueSize:function() {
    return this.values.length / this.times.length;
  }, shift:function(d) {
    if (0 !== d) {
      for (var a = this.times, b = 0, c = a.length;b !== c;++b) {
        a[b] += d;
      }
    }
    return this;
  }, scale:function(d) {
    if (1 !== d) {
      for (var a = this.times, b = 0, c = a.length;b !== c;++b) {
        a[b] *= d;
      }
    }
    return this;
  }, trim:function(d, a) {
    for (var b = this.times, c = b.length, e = 0, g = c - 1;e !== c && b[e] < d;) {
      ++e;
    }
    for (;-1 !== g && b[g] > a;) {
      --g;
    }
    ++g;
    if (0 !== e || g !== c) {
      e >= g && (g = Math.max(g, 1), e = g - 1), c = this.getValueSize(), this.times = Fa.arraySlice(b, e, g), this.values = Fa.arraySlice(this.values, e * c, g * c);
    }
    return this;
  }, validate:function() {
    var d = !0, a = this.getValueSize();
    0 !== a - Math.floor(a) && (console.error("invalid value size in track", this), d = !1);
    var b = this.times, a = this.values, c = b.length;
    0 === c && (console.error("track is empty", this), d = !1);
    for (var e = null, g = 0;g !== c;g++) {
      var f = b[g];
      if ("number" === typeof f && isNaN(f)) {
        console.error("time is not a valid number", this, g, f);
        d = !1;
        break;
      }
      if (null !== e && e > f) {
        console.error("out of order keys", this, g, f, e);
        d = !1;
        break;
      }
      e = f;
    }
    if (void 0 !== a && Fa.isTypedArray(a)) {
      for (g = 0, b = a.length;g !== b;++g) {
        if (c = a[g], isNaN(c)) {
          console.error("value is not a valid number", this, g, c);
          d = !1;
          break;
        }
      }
    }
    return d;
  }, optimize:function() {
    for (var d = this.times, a = this.values, b = this.getValueSize(), c = 2302 === this.getInterpolation(), e = 1, g = d.length - 1, f = 1;f < g;++f) {
      var k = !1, q = d[f];
      if (q !== d[f + 1] && (1 !== f || q !== q[0])) {
        if (c) {
          k = !0;
        } else {
          for (var p = f * b, h = p - b, n = p + b, q = 0;q !== b;++q) {
            var r = a[p + q];
            if (r !== a[h + q] || r !== a[n + q]) {
              k = !0;
              break;
            }
          }
        }
      }
      if (k) {
        if (f !== e) {
          for (d[e] = d[f], k = f * b, p = e * b, q = 0;q !== b;++q) {
            a[p + q] = a[k + q];
          }
        }
        ++e;
      }
    }
    if (0 < g) {
      d[e] = d[g];
      k = g * b;
      p = e * b;
      for (q = 0;q !== b;++q) {
        a[p + q] = a[k + q];
      }
      ++e;
    }
    e !== d.length && (this.times = Fa.arraySlice(d, 0, e), this.values = Fa.arraySlice(a, 0, e * b));
    return this;
  }};
  uc.prototype = Object.assign(Object.create(yb), {constructor:uc, ValueTypeName:"vector"});
  Od.prototype = Object.assign(Object.create(Za.prototype), {constructor:Od, interpolate_:function(d, a, b, c) {
    var e = this.resultBuffer, f = this.sampleValues, m = this.valueSize;
    d *= m;
    a = (b - a) / (c - a);
    for (b = d + m;d !== b;d += 4) {
      g.slerpFlat(e, 0, f, d - m, f, d, a);
    }
    return e;
  }});
  jd.prototype = Object.assign(Object.create(yb), {constructor:jd, ValueTypeName:"quaternion", DefaultInterpolation:2301, InterpolantFactoryMethodLinear:function(d) {
    return new Od(this.times, this.values, this.getValueSize(), d);
  }, InterpolantFactoryMethodSmooth:void 0});
  vc.prototype = Object.assign(Object.create(yb), {constructor:vc, ValueTypeName:"number"});
  Pd.prototype = Object.assign(Object.create(yb), {constructor:Pd, ValueTypeName:"string", ValueBufferType:Array, DefaultInterpolation:2300, InterpolantFactoryMethodLinear:void 0, InterpolantFactoryMethodSmooth:void 0});
  Qd.prototype = Object.assign(Object.create(yb), {constructor:Qd, ValueTypeName:"bool", ValueBufferType:Array, DefaultInterpolation:2300, InterpolantFactoryMethodLinear:void 0, InterpolantFactoryMethodSmooth:void 0});
  Rd.prototype = Object.assign(Object.create(yb), {constructor:Rd, ValueTypeName:"color"});
  Sb.prototype = yb;
  yb.constructor = Sb;
  Object.assign(Sb, {parse:function(d) {
    if (void 0 === d.type) {
      throw Error("track type undefined, can not parse");
    }
    var a = Sb._getTrackTypeForValueTypeName(d.type);
    if (void 0 === d.times) {
      var b = [], c = [];
      Fa.flattenJSON(d.keys, b, c, "value");
      d.times = b;
      d.values = c;
    }
    return void 0 !== a.parse ? a.parse(d) : new a(d.name, d.times, d.values, d.interpolation);
  }, toJSON:function(d) {
    var a = d.constructor;
    if (void 0 !== a.toJSON) {
      a = a.toJSON(d);
    } else {
      var a = {name:d.name, times:Fa.convertArray(d.times, Array), values:Fa.convertArray(d.values, Array)}, b = d.getInterpolation();
      b !== d.DefaultInterpolation && (a.interpolation = b);
    }
    a.type = d.ValueTypeName;
    return a;
  }, _getTrackTypeForValueTypeName:function(d) {
    switch(d.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return vc;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return uc;
      case "color":
        return Rd;
      case "quaternion":
        return jd;
      case "bool":
      case "boolean":
        return Qd;
      case "string":
        return Pd;
    }
    throw Error("Unsupported typeName: " + d);
  }});
  Object.assign(cb, {parse:function(d) {
    for (var a = [], b = d.tracks, c = 1 / (d.fps || 1), e = 0, g = b.length;e !== g;++e) {
      a.push(Sb.parse(b[e]).scale(c));
    }
    return new cb(d.name, d.duration, a);
  }, toJSON:function(d) {
    var a = [], b = d.tracks;
    d = {name:d.name, duration:d.duration, tracks:a};
    for (var c = 0, e = b.length;c !== e;++c) {
      a.push(Sb.toJSON(b[c]));
    }
    return d;
  }, CreateFromMorphTargetSequence:function(d, a, b, c) {
    for (var e = a.length, g = [], f = 0;f < e;f++) {
      var m = [], k = [];
      m.push((f + e - 1) % e, f, (f + 1) % e);
      k.push(0, 1, 0);
      var q = Fa.getKeyframeOrder(m), m = Fa.sortedArray(m, 1, q), k = Fa.sortedArray(k, 1, q);
      c || 0 !== m[0] || (m.push(e), k.push(k[0]));
      g.push((new vc(".morphTargetInfluences[" + a[f].name + "]", m, k)).scale(1 / b));
    }
    return new cb(d, -1, g);
  }, findByName:function(d, a) {
    var b = d;
    Array.isArray(d) || (b = d.geometry && d.geometry.animations || d.animations);
    for (d = 0;d < b.length;d++) {
      if (b[d].name === a) {
        return b[d];
      }
    }
    return null;
  }, CreateClipsFromMorphTargetSequences:function(d, a, b) {
    for (var c = {}, e = /^([\w-]*?)([\d]+)$/, g = 0, f = d.length;g < f;g++) {
      var m = d[g], k = m.name.match(e);
      if (k && 1 < k.length) {
        var q = k[1];
        (k = c[q]) || (c[q] = k = []);
        k.push(m);
      }
    }
    d = [];
    for (q in c) {
      d.push(cb.CreateFromMorphTargetSequence(q, c[q], a, b));
    }
    return d;
  }, parseAnimation:function(d, a) {
    if (!d) {
      return console.error("  no animation in JSONLoader data"), null;
    }
    var b = function(d, a, b, c, e) {
      if (0 !== b.length) {
        var g = [], f = [];
        Fa.flattenJSON(b, g, f, c);
        0 !== g.length && e.push(new d(a, g, f));
      }
    }, c = [], e = d.name || "default", g = d.length || -1, f = d.fps || 30;
    d = d.hierarchy || [];
    for (var m = 0;m < d.length;m++) {
      var k = d[m].keys;
      if (k && 0 !== k.length) {
        if (k[0].morphTargets) {
          for (var g = {}, q = 0;q < k.length;q++) {
            if (k[q].morphTargets) {
              for (var p = 0;p < k[q].morphTargets.length;p++) {
                g[k[q].morphTargets[p]] = -1;
              }
            }
          }
          for (var h in g) {
            for (var n = [], r = [], p = 0;p !== k[q].morphTargets.length;++p) {
              var l = k[q];
              n.push(l.time);
              r.push(l.morphTarget === h ? 1 : 0);
            }
            c.push(new vc(".morphTargetInfluence[" + h + "]", n, r));
          }
          g = g.length * (f || 1);
        } else {
          q = ".bones[" + a[m].name + "]", b(uc, q + ".position", k, "pos", c), b(jd, q + ".quaternion", k, "rot", c), b(uc, q + ".scale", k, "scl", c);
        }
      }
    }
    return 0 === c.length ? null : new cb(e, g, c);
  }});
  Object.assign(cb.prototype, {resetDuration:function() {
    for (var d = 0, a = 0, b = this.tracks.length;a !== b;++a) {
      var c = this.tracks[a], d = Math.max(d, c.times[c.times.length - 1]);
    }
    this.duration = d;
  }, trim:function() {
    for (var d = 0;d < this.tracks.length;d++) {
      this.tracks[d].trim(0, this.duration);
    }
    return this;
  }, optimize:function() {
    for (var d = 0;d < this.tracks.length;d++) {
      this.tracks[d].optimize();
    }
    return this;
  }});
  Object.assign(Sd.prototype, {load:function(d, a, b, c) {
    var e = this;
    (new hb(e.manager)).load(d, function(d) {
      a(e.parse(JSON.parse(d)));
    }, b, c);
  }, setTextures:function(d) {
    this.textures = d;
  }, parse:function(d) {
    function a(d) {
      void 0 === b[d] && console.warn("THREE.MaterialLoader: Undefined texture", d);
      return b[d];
    }
    var b = this.textures, c = new uf[d.type];
    void 0 !== d.uuid && (c.uuid = d.uuid);
    void 0 !== d.name && (c.name = d.name);
    void 0 !== d.color && c.color.setHex(d.color);
    void 0 !== d.roughness && (c.roughness = d.roughness);
    void 0 !== d.metalness && (c.metalness = d.metalness);
    void 0 !== d.emissive && c.emissive.setHex(d.emissive);
    void 0 !== d.specular && c.specular.setHex(d.specular);
    void 0 !== d.shininess && (c.shininess = d.shininess);
    void 0 !== d.clearCoat && (c.clearCoat = d.clearCoat);
    void 0 !== d.clearCoatRoughness && (c.clearCoatRoughness = d.clearCoatRoughness);
    void 0 !== d.uniforms && (c.uniforms = d.uniforms);
    void 0 !== d.vertexShader && (c.vertexShader = d.vertexShader);
    void 0 !== d.fragmentShader && (c.fragmentShader = d.fragmentShader);
    void 0 !== d.vertexColors && (c.vertexColors = d.vertexColors);
    void 0 !== d.fog && (c.fog = d.fog);
    void 0 !== d.shading && (c.shading = d.shading);
    void 0 !== d.blending && (c.blending = d.blending);
    void 0 !== d.side && (c.side = d.side);
    void 0 !== d.opacity && (c.opacity = d.opacity);
    void 0 !== d.transparent && (c.transparent = d.transparent);
    void 0 !== d.alphaTest && (c.alphaTest = d.alphaTest);
    void 0 !== d.depthTest && (c.depthTest = d.depthTest);
    void 0 !== d.depthWrite && (c.depthWrite = d.depthWrite);
    void 0 !== d.colorWrite && (c.colorWrite = d.colorWrite);
    void 0 !== d.wireframe && (c.wireframe = d.wireframe);
    void 0 !== d.wireframeLinewidth && (c.wireframeLinewidth = d.wireframeLinewidth);
    void 0 !== d.wireframeLinecap && (c.wireframeLinecap = d.wireframeLinecap);
    void 0 !== d.wireframeLinejoin && (c.wireframeLinejoin = d.wireframeLinejoin);
    void 0 !== d.morphTargets && (c.morphTargets = d.morphTargets);
    void 0 !== d.size && (c.size = d.size);
    void 0 !== d.sizeAttenuation && (c.sizeAttenuation = d.sizeAttenuation);
    void 0 !== d.map && (c.map = a(d.map));
    void 0 !== d.alphaMap && (c.alphaMap = a(d.alphaMap), c.transparent = !0);
    void 0 !== d.bumpMap && (c.bumpMap = a(d.bumpMap));
    void 0 !== d.bumpScale && (c.bumpScale = d.bumpScale);
    void 0 !== d.normalMap && (c.normalMap = a(d.normalMap));
    if (void 0 !== d.normalScale) {
      var e = d.normalScale;
      !1 === Array.isArray(e) && (e = [e, e]);
      c.normalScale = (new l).fromArray(e);
    }
    void 0 !== d.displacementMap && (c.displacementMap = a(d.displacementMap));
    void 0 !== d.displacementScale && (c.displacementScale = d.displacementScale);
    void 0 !== d.displacementBias && (c.displacementBias = d.displacementBias);
    void 0 !== d.roughnessMap && (c.roughnessMap = a(d.roughnessMap));
    void 0 !== d.metalnessMap && (c.metalnessMap = a(d.metalnessMap));
    void 0 !== d.emissiveMap && (c.emissiveMap = a(d.emissiveMap));
    void 0 !== d.emissiveIntensity && (c.emissiveIntensity = d.emissiveIntensity);
    void 0 !== d.specularMap && (c.specularMap = a(d.specularMap));
    void 0 !== d.envMap && (c.envMap = a(d.envMap));
    void 0 !== d.reflectivity && (c.reflectivity = d.reflectivity);
    void 0 !== d.lightMap && (c.lightMap = a(d.lightMap));
    void 0 !== d.lightMapIntensity && (c.lightMapIntensity = d.lightMapIntensity);
    void 0 !== d.aoMap && (c.aoMap = a(d.aoMap));
    void 0 !== d.aoMapIntensity && (c.aoMapIntensity = d.aoMapIntensity);
    void 0 !== d.gradientMap && (c.gradientMap = a(d.gradientMap));
    if (void 0 !== d.materials) {
      for (var e = 0, g = d.materials.length;e < g;e++) {
        c.materials.push(this.parse(d.materials[e]));
      }
    }
    return c;
  }});
  Object.assign(ie.prototype, {load:function(d, a, b, c) {
    var e = this;
    (new hb(e.manager)).load(d, function(d) {
      a(e.parse(JSON.parse(d)));
    }, b, c);
  }, parse:function(d) {
    var a = new da, b = d.data.index, c = {Int8Array:Int8Array, Uint8Array:Uint8Array, Uint8ClampedArray:Uint8ClampedArray, Int16Array:Int16Array, Uint16Array:Uint16Array, Int32Array:Int32Array, Uint32Array:Uint32Array, Float32Array:Float32Array, Float64Array:Float64Array};
    void 0 !== b && (b = new c[b.type](b.array), a.setIndex(new ja(b, 1)));
    var g = d.data.attributes, f;
    for (f in g) {
      var k = g[f], b = new c[k.type](k.array);
      a.addAttribute(f, new ja(b, k.itemSize, k.normalized));
    }
    c = d.data.groups || d.data.drawcalls || d.data.offsets;
    if (void 0 !== c) {
      for (f = 0, b = c.length;f !== b;++f) {
        g = c[f], a.addGroup(g.start, g.count, g.materialIndex);
      }
    }
    d = d.data.boundingSphere;
    void 0 !== d && (c = new e, void 0 !== d.center && c.fromArray(d.center), a.boundingSphere = new Ba(c, d.radius));
    return a;
  }});
  wc.Handlers = {handlers:[], add:function(d, a) {
    this.handlers.push(d, a);
  }, get:function(d) {
    for (var a = this.handlers, b = 0, c = a.length;b < c;b += 2) {
      var e = a[b + 1];
      if (a[b].test(d)) {
        return e;
      }
    }
    return null;
  }};
  Object.assign(wc.prototype, {crossOrigin:void 0, extractUrlBase:function(d) {
    d = d.split("/");
    if (1 === d.length) {
      return "./";
    }
    d.pop();
    return d.join("/") + "/";
  }, initMaterials:function(d, a, b) {
    for (var c = [], e = 0;e < d.length;++e) {
      c[e] = this.createMaterial(d[e], a, b);
    }
    return c;
  }, createMaterial:function() {
    var d = {NoBlending:0, NormalBlending:1, AdditiveBlending:2, SubtractiveBlending:3, MultiplyBlending:4, CustomBlending:5}, a = new T, b = new Dd, c = new Sd;
    return function(e, g, f) {
      function m(d, a, c, e, m) {
        d = g + d;
        var q = wc.Handlers.get(d);
        null !== q ? d = q.load(d) : (b.setCrossOrigin(f), d = b.load(d));
        void 0 !== a && (d.repeat.fromArray(a), 1 !== a[0] && (d.wrapS = 1E3), 1 !== a[1] && (d.wrapT = 1E3));
        void 0 !== c && d.offset.fromArray(c);
        void 0 !== e && ("repeat" === e[0] && (d.wrapS = 1E3), "mirror" === e[0] && (d.wrapS = 1002), "repeat" === e[1] && (d.wrapT = 1E3), "mirror" === e[1] && (d.wrapT = 1002));
        void 0 !== m && (d.anisotropy = m);
        a = ka.generateUUID();
        k[a] = d;
        return a;
      }
      var k = {}, q = {uuid:ka.generateUUID(), type:"MeshLambertMaterial"}, p;
      for (p in e) {
        var h = e[p];
        switch(p) {
          case "DbgColor":
          case "DbgIndex":
          case "opticalDensity":
          case "illumination":
            break;
          case "DbgName":
            q.name = h;
            break;
          case "blending":
            q.blending = d[h];
            break;
          case "colorAmbient":
          case "mapAmbient":
            console.warn("THREE.Loader.createMaterial:", p, "is no longer supported.");
            break;
          case "colorDiffuse":
            q.color = a.fromArray(h).getHex();
            break;
          case "colorSpecular":
            q.specular = a.fromArray(h).getHex();
            break;
          case "colorEmissive":
            q.emissive = a.fromArray(h).getHex();
            break;
          case "specularCoef":
            q.shininess = h;
            break;
          case "shading":
            "basic" === h.toLowerCase() && (q.type = "MeshBasicMaterial");
            "phong" === h.toLowerCase() && (q.type = "MeshPhongMaterial");
            "standard" === h.toLowerCase() && (q.type = "MeshStandardMaterial");
            break;
          case "mapDiffuse":
            q.map = m(h, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
            break;
          case "mapDiffuseRepeat":
          case "mapDiffuseOffset":
          case "mapDiffuseWrap":
          case "mapDiffuseAnisotropy":
            break;
          case "mapEmissive":
            q.emissiveMap = m(h, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
            break;
          case "mapEmissiveRepeat":
          case "mapEmissiveOffset":
          case "mapEmissiveWrap":
          case "mapEmissiveAnisotropy":
            break;
          case "mapLight":
            q.lightMap = m(h, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
            break;
          case "mapLightRepeat":
          case "mapLightOffset":
          case "mapLightWrap":
          case "mapLightAnisotropy":
            break;
          case "mapAO":
            q.aoMap = m(h, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
            break;
          case "mapAORepeat":
          case "mapAOOffset":
          case "mapAOWrap":
          case "mapAOAnisotropy":
            break;
          case "mapBump":
            q.bumpMap = m(h, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
            break;
          case "mapBumpScale":
            q.bumpScale = h;
            break;
          case "mapBumpRepeat":
          case "mapBumpOffset":
          case "mapBumpWrap":
          case "mapBumpAnisotropy":
            break;
          case "mapNormal":
            q.normalMap = m(h, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
            break;
          case "mapNormalFactor":
            q.normalScale = [h, h];
            break;
          case "mapNormalRepeat":
          case "mapNormalOffset":
          case "mapNormalWrap":
          case "mapNormalAnisotropy":
            break;
          case "mapSpecular":
            q.specularMap = m(h, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
            break;
          case "mapSpecularRepeat":
          case "mapSpecularOffset":
          case "mapSpecularWrap":
          case "mapSpecularAnisotropy":
            break;
          case "mapMetalness":
            q.metalnessMap = m(h, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
            break;
          case "mapMetalnessRepeat":
          case "mapMetalnessOffset":
          case "mapMetalnessWrap":
          case "mapMetalnessAnisotropy":
            break;
          case "mapRoughness":
            q.roughnessMap = m(h, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
            break;
          case "mapRoughnessRepeat":
          case "mapRoughnessOffset":
          case "mapRoughnessWrap":
          case "mapRoughnessAnisotropy":
            break;
          case "mapAlpha":
            q.alphaMap = m(h, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
            break;
          case "mapAlphaRepeat":
          case "mapAlphaOffset":
          case "mapAlphaWrap":
          case "mapAlphaAnisotropy":
            break;
          case "flipSided":
            q.side = 1;
            break;
          case "doubleSided":
            q.side = 2;
            break;
          case "transparency":
            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
            q.opacity = h;
            break;
          case "depthTest":
          case "depthWrite":
          case "colorWrite":
          case "opacity":
          case "reflectivity":
          case "transparent":
          case "visible":
          case "wireframe":
            q[p] = h;
            break;
          case "vertexColors":
            !0 === h && (q.vertexColors = 2);
            "face" === h && (q.vertexColors = 1);
            break;
          default:
            console.error("THREE.Loader.createMaterial: Unsupported", p, h);
        }
      }
      "MeshBasicMaterial" === q.type && delete q.emissive;
      "MeshPhongMaterial" !== q.type && delete q.specular;
      1 > q.opacity && (q.transparent = !0);
      c.setTextures(k);
      return c.parse(q);
    };
  }()});
  Object.assign(je.prototype, {load:function(d, a, b, c) {
    var e = this, g = this.texturePath && "string" === typeof this.texturePath ? this.texturePath : wc.prototype.extractUrlBase(d), f = new hb(this.manager);
    f.setWithCredentials(this.withCredentials);
    f.load(d, function(b) {
      b = JSON.parse(b);
      var c = b.metadata;
      if (void 0 !== c && (c = c.type, void 0 !== c)) {
        if ("object" === c.toLowerCase()) {
          console.error("THREE.JSONLoader: " + d + " should be loaded with THREE.ObjectLoader instead.");
          return;
        }
        if ("scene" === c.toLowerCase()) {
          console.error("THREE.JSONLoader: " + d + " should be loaded with THREE.SceneLoader instead.");
          return;
        }
      }
      b = e.parse(b, g);
      a(b.geometry, b.materials);
    }, b, c);
  }, setTexturePath:function(d) {
    this.texturePath = d;
  }, parse:function(d, a) {
    var b = new ca, c = void 0 !== d.scale ? 1 / d.scale : 1;
    (function(a) {
      var c, g, f, m, k, q, p, h, n, r, u, w, t, v = d.faces;
      q = d.vertices;
      var B = d.normals, y = d.colors, A = 0;
      if (void 0 !== d.uvs) {
        for (c = 0;c < d.uvs.length;c++) {
          d.uvs[c].length && A++;
        }
        for (c = 0;c < A;c++) {
          b.faceVertexUvs[c] = [];
        }
      }
      m = 0;
      for (k = q.length;m < k;) {
        c = new e, c.x = q[m++] * a, c.y = q[m++] * a, c.z = q[m++] * a, b.vertices.push(c);
      }
      m = 0;
      for (k = v.length;m < k;) {
        if (a = v[m++], n = a & 1, f = a & 2, c = a & 8, p = a & 16, r = a & 32, q = a & 64, a &= 128, n) {
          n = new za;
          n.a = v[m];
          n.b = v[m + 1];
          n.c = v[m + 3];
          u = new za;
          u.a = v[m + 1];
          u.b = v[m + 2];
          u.c = v[m + 3];
          m += 4;
          f && (f = v[m++], n.materialIndex = f, u.materialIndex = f);
          f = b.faces.length;
          if (c) {
            for (c = 0;c < A;c++) {
              for (w = d.uvs[c], b.faceVertexUvs[c][f] = [], b.faceVertexUvs[c][f + 1] = [], g = 0;4 > g;g++) {
                h = v[m++], t = w[2 * h], h = w[2 * h + 1], t = new l(t, h), 2 !== g && b.faceVertexUvs[c][f].push(t), 0 !== g && b.faceVertexUvs[c][f + 1].push(t);
              }
            }
          }
          p && (p = 3 * v[m++], n.normal.set(B[p++], B[p++], B[p]), u.normal.copy(n.normal));
          if (r) {
            for (c = 0;4 > c;c++) {
              p = 3 * v[m++], r = new e(B[p++], B[p++], B[p]), 2 !== c && n.vertexNormals.push(r), 0 !== c && u.vertexNormals.push(r);
            }
          }
          q && (q = v[m++], q = y[q], n.color.setHex(q), u.color.setHex(q));
          if (a) {
            for (c = 0;4 > c;c++) {
              q = v[m++], q = y[q], 2 !== c && n.vertexColors.push(new T(q)), 0 !== c && u.vertexColors.push(new T(q));
            }
          }
          b.faces.push(n);
          b.faces.push(u);
        } else {
          n = new za;
          n.a = v[m++];
          n.b = v[m++];
          n.c = v[m++];
          f && (f = v[m++], n.materialIndex = f);
          f = b.faces.length;
          if (c) {
            for (c = 0;c < A;c++) {
              for (w = d.uvs[c], b.faceVertexUvs[c][f] = [], g = 0;3 > g;g++) {
                h = v[m++], t = w[2 * h], h = w[2 * h + 1], t = new l(t, h), b.faceVertexUvs[c][f].push(t);
              }
            }
          }
          p && (p = 3 * v[m++], n.normal.set(B[p++], B[p++], B[p]));
          if (r) {
            for (c = 0;3 > c;c++) {
              p = 3 * v[m++], r = new e(B[p++], B[p++], B[p]), n.vertexNormals.push(r);
            }
          }
          q && (q = v[m++], n.color.setHex(y[q]));
          if (a) {
            for (c = 0;3 > c;c++) {
              q = v[m++], n.vertexColors.push(new T(y[q]));
            }
          }
          b.faces.push(n);
        }
      }
    })(c);
    (function() {
      var a = void 0 !== d.influencesPerVertex ? d.influencesPerVertex : 2;
      if (d.skinWeights) {
        for (var c = 0, e = d.skinWeights.length;c < e;c += a) {
          b.skinWeights.push(new f(d.skinWeights[c], 1 < a ? d.skinWeights[c + 1] : 0, 2 < a ? d.skinWeights[c + 2] : 0, 3 < a ? d.skinWeights[c + 3] : 0));
        }
      }
      if (d.skinIndices) {
        for (c = 0, e = d.skinIndices.length;c < e;c += a) {
          b.skinIndices.push(new f(d.skinIndices[c], 1 < a ? d.skinIndices[c + 1] : 0, 2 < a ? d.skinIndices[c + 2] : 0, 3 < a ? d.skinIndices[c + 3] : 0));
        }
      }
      b.bones = d.bones;
      b.bones && 0 < b.bones.length && (b.skinWeights.length !== b.skinIndices.length || b.skinIndices.length !== b.vertices.length) && console.warn("When skinning, number of vertices (" + b.vertices.length + "), skinIndices (" + b.skinIndices.length + "), and skinWeights (" + b.skinWeights.length + ") should match.");
    })();
    (function(a) {
      if (void 0 !== d.morphTargets) {
        for (var c = 0, g = d.morphTargets.length;c < g;c++) {
          b.morphTargets[c] = {};
          b.morphTargets[c].name = d.morphTargets[c].name;
          b.morphTargets[c].vertices = [];
          for (var f = b.morphTargets[c].vertices, m = d.morphTargets[c].vertices, k = 0, q = m.length;k < q;k += 3) {
            var p = new e;
            p.x = m[k] * a;
            p.y = m[k + 1] * a;
            p.z = m[k + 2] * a;
            f.push(p);
          }
        }
      }
      if (void 0 !== d.morphColors && 0 < d.morphColors.length) {
        for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), a = b.faces, f = d.morphColors[0].colors, c = 0, g = a.length;c < g;c++) {
          a[c].color.fromArray(f, 3 * c);
        }
      }
    })(c);
    (function() {
      var a = [], c = [];
      void 0 !== d.animation && c.push(d.animation);
      void 0 !== d.animations && (d.animations.length ? c = c.concat(d.animations) : c.push(d.animations));
      for (var e = 0;e < c.length;e++) {
        var g = cb.parseAnimation(c[e], b.bones);
        g && a.push(g);
      }
      b.morphTargets && (c = cb.CreateClipsFromMorphTargetSequences(b.morphTargets, 10), a = a.concat(c));
      0 < a.length && (b.animations = a);
    })();
    b.computeFaceNormals();
    b.computeBoundingSphere();
    if (void 0 === d.materials || 0 === d.materials.length) {
      return {geometry:b};
    }
    c = wc.prototype.initMaterials(d.materials, a, this.crossOrigin);
    return {geometry:b, materials:c};
  }});
  Object.assign(Je.prototype, {load:function(a, b, c, e) {
    "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
    var d = this;
    (new hb(d.manager)).load(a, function(c) {
      var g = null;
      try {
        g = JSON.parse(c);
      } catch (Q) {
        void 0 !== e && e(Q);
        console.error("THREE:ObjectLoader: Can't parse " + a + ".", Q.message);
        return;
      }
      c = g.metadata;
      void 0 === c || void 0 === c.type || "geometry" === c.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + a + ". Use THREE.JSONLoader instead.") : d.parse(g, b);
    }, c, e);
  }, setTexturePath:function(a) {
    this.texturePath = a;
  }, setCrossOrigin:function(a) {
    this.crossOrigin = a;
  }, parse:function(a, b) {
    var d = this.parseGeometries(a.geometries), c = this.parseImages(a.images, function() {
      void 0 !== b && b(e);
    }), c = this.parseTextures(a.textures, c), c = this.parseMaterials(a.materials, c), e = this.parseObject(a.object, d, c);
    a.animations && (e.animations = this.parseAnimations(a.animations));
    void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e);
    return e;
  }, parseGeometries:function(a) {
    var d = {};
    if (void 0 !== a) {
      for (var b = new je, c = new ie, e = 0, g = a.length;e < g;e++) {
        var f, k = a[e];
        switch(k.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            f = new jb[k.type](k.width, k.height, k.widthSegments, k.heightSegments);
            break;
          case "BoxGeometry":
          case "BoxBufferGeometry":
          case "CubeGeometry":
            f = new jb[k.type](k.width, k.height, k.depth, k.widthSegments, k.heightSegments, k.depthSegments);
            break;
          case "CircleGeometry":
          case "CircleBufferGeometry":
            f = new jb[k.type](k.radius, k.segments, k.thetaStart, k.thetaLength);
            break;
          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            f = new jb[k.type](k.radiusTop, k.radiusBottom, k.height, k.radialSegments, k.heightSegments, k.openEnded, k.thetaStart, k.thetaLength);
            break;
          case "ConeGeometry":
          case "ConeBufferGeometry":
            f = new jb[k.type](k.radius, k.height, k.radialSegments, k.heightSegments, k.openEnded, k.thetaStart, k.thetaLength);
            break;
          case "SphereGeometry":
          case "SphereBufferGeometry":
            f = new jb[k.type](k.radius, k.widthSegments, k.heightSegments, k.phiStart, k.phiLength, k.thetaStart, k.thetaLength);
            break;
          case "DodecahedronGeometry":
          case "IcosahedronGeometry":
          case "OctahedronGeometry":
          case "TetrahedronGeometry":
            f = new jb[k.type](k.radius, k.detail);
            break;
          case "RingGeometry":
          case "RingBufferGeometry":
            f = new jb[k.type](k.innerRadius, k.outerRadius, k.thetaSegments, k.phiSegments, k.thetaStart, k.thetaLength);
            break;
          case "TorusGeometry":
          case "TorusBufferGeometry":
            f = new jb[k.type](k.radius, k.tube, k.radialSegments, k.tubularSegments, k.arc);
            break;
          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            f = new jb[k.type](k.radius, k.tube, k.tubularSegments, k.radialSegments, k.p, k.q);
            break;
          case "LatheGeometry":
          case "LatheBufferGeometry":
            f = new jb[k.type](k.points, k.segments, k.phiStart, k.phiLength);
            break;
          case "BufferGeometry":
            f = c.parse(k);
            break;
          case "Geometry":
            f = b.parse(k.data, this.texturePath).geometry;
            break;
          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + k.type + '"');
            continue;
        }
        f.uuid = k.uuid;
        void 0 !== k.name && (f.name = k.name);
        d[k.uuid] = f;
      }
    }
    return d;
  }, parseMaterials:function(a, b) {
    var d = {};
    if (void 0 !== a) {
      var c = new Sd;
      c.setTextures(b);
      b = 0;
      for (var e = a.length;b < e;b++) {
        var g = c.parse(a[b]);
        d[g.uuid] = g;
      }
    }
    return d;
  }, parseAnimations:function(a) {
    for (var d = [], b = 0;b < a.length;b++) {
      var c = cb.parse(a[b]);
      d.push(c);
    }
    return d;
  }, parseImages:function(a, b) {
    function d(a) {
      c.manager.itemStart(a);
      return g.load(a, function() {
        c.manager.itemEnd(a);
      }, void 0, function() {
        c.manager.itemError(a);
      });
    }
    var c = this, e = {};
    if (void 0 !== a && 0 < a.length) {
      b = new fe(b);
      var g = new hd(b);
      g.setCrossOrigin(this.crossOrigin);
      b = 0;
      for (var f = a.length;b < f;b++) {
        var k = a[b], m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(k.url) ? k.url : c.texturePath + k.url;
        e[k.uuid] = d(m);
      }
    }
    return e;
  }, parseTextures:function(a, c) {
    function d(a, d) {
      if ("number" === typeof a) {
        return a;
      }
      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a);
      return d[a];
    }
    var e = {UVMapping:300, CubeReflectionMapping:301, CubeRefractionMapping:302, EquirectangularReflectionMapping:303, EquirectangularRefractionMapping:304, SphericalReflectionMapping:305, CubeUVReflectionMapping:306, CubeUVRefractionMapping:307}, g = {RepeatWrapping:1E3, ClampToEdgeWrapping:1001, MirroredRepeatWrapping:1002}, f = {NearestFilter:1003, NearestMipMapNearestFilter:1004, NearestMipMapLinearFilter:1005, LinearFilter:1006, LinearMipMapNearestFilter:1007, LinearMipMapLinearFilter:1008}, 
    k = {};
    if (void 0 !== a) {
      for (var m = 0, q = a.length;m < q;m++) {
        var p = a[m];
        void 0 === p.image && console.warn('THREE.ObjectLoader: No "image" specified for', p.uuid);
        void 0 === c[p.image] && console.warn("THREE.ObjectLoader: Undefined image", p.image);
        var h = new b(c[p.image]);
        h.needsUpdate = !0;
        h.uuid = p.uuid;
        void 0 !== p.name && (h.name = p.name);
        void 0 !== p.mapping && (h.mapping = d(p.mapping, e));
        void 0 !== p.offset && h.offset.fromArray(p.offset);
        void 0 !== p.repeat && h.repeat.fromArray(p.repeat);
        void 0 !== p.wrap && (h.wrapS = d(p.wrap[0], g), h.wrapT = d(p.wrap[1], g));
        void 0 !== p.minFilter && (h.minFilter = d(p.minFilter, f));
        void 0 !== p.magFilter && (h.magFilter = d(p.magFilter, f));
        void 0 !== p.anisotropy && (h.anisotropy = p.anisotropy);
        void 0 !== p.flipY && (h.flipY = p.flipY);
        k[p.uuid] = h;
      }
    }
    return k;
  }, parseObject:function() {
    var a = new p;
    return function(d, b, c) {
      function e(d) {
        void 0 === b[d] && console.warn("THREE.ObjectLoader: Undefined geometry", d);
        return b[d];
      }
      function g(d) {
        if (void 0 !== d) {
          return void 0 === c[d] && console.warn("THREE.ObjectLoader: Undefined material", d), c[d];
        }
      }
      var f;
      switch(d.type) {
        case "Scene":
          f = new xd;
          void 0 !== d.background && Number.isInteger(d.background) && (f.background = new T(d.background));
          void 0 !== d.fog && ("Fog" === d.fog.type ? f.fog = new bc(d.fog.color, d.fog.near, d.fog.far) : "FogExp2" === d.fog.type && (f.fog = new ac(d.fog.color, d.fog.density)));
          break;
        case "PerspectiveCamera":
          f = new Oa(d.fov, d.aspect, d.near, d.far);
          void 0 !== d.focus && (f.focus = d.focus);
          void 0 !== d.zoom && (f.zoom = d.zoom);
          void 0 !== d.filmGauge && (f.filmGauge = d.filmGauge);
          void 0 !== d.filmOffset && (f.filmOffset = d.filmOffset);
          void 0 !== d.view && (f.view = Object.assign({}, d.view));
          break;
        case "OrthographicCamera":
          f = new Zb(d.left, d.right, d.top, d.bottom, d.near, d.far);
          break;
        case "AmbientLight":
          f = new Kd(d.color, d.intensity);
          break;
        case "DirectionalLight":
          f = new Jd(d.color, d.intensity);
          break;
        case "PointLight":
          f = new Hd(d.color, d.intensity, d.distance, d.decay);
          break;
        case "RectAreaLight":
          f = new Ld(d.color, d.intensity, d.width, d.height);
          break;
        case "SpotLight":
          f = new Gd(d.color, d.intensity, d.distance, d.angle, d.penumbra, d.decay);
          break;
        case "HemisphereLight":
          f = new Ed(d.color, d.groundColor, d.intensity);
          break;
        case "SkinnedMesh":
          console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
        case "Mesh":
          f = e(d.geometry);
          var k = g(d.material);
          f = f.bones && 0 < f.bones.length ? new zd(f, k) : new Ga(f, k);
          break;
        case "LOD":
          f = new Oc;
          break;
        case "Line":
          f = new db(e(d.geometry), g(d.material), d.mode);
          break;
        case "LineLoop":
          f = new Ad(e(d.geometry), g(d.material));
          break;
        case "LineSegments":
          f = new ua(e(d.geometry), g(d.material));
          break;
        case "PointCloud":
        case "Points":
          f = new cc(e(d.geometry), g(d.material));
          break;
        case "Sprite":
          f = new Nc(g(d.material));
          break;
        case "Group":
          f = new Qc;
          break;
        default:
          f = new U;
      }
      f.uuid = d.uuid;
      void 0 !== d.name && (f.name = d.name);
      void 0 !== d.matrix ? (a.fromArray(d.matrix), a.decompose(f.position, f.quaternion, f.scale)) : (void 0 !== d.position && f.position.fromArray(d.position), void 0 !== d.rotation && f.rotation.fromArray(d.rotation), void 0 !== d.quaternion && f.quaternion.fromArray(d.quaternion), void 0 !== d.scale && f.scale.fromArray(d.scale));
      void 0 !== d.castShadow && (f.castShadow = d.castShadow);
      void 0 !== d.receiveShadow && (f.receiveShadow = d.receiveShadow);
      d.shadow && (void 0 !== d.shadow.bias && (f.shadow.bias = d.shadow.bias), void 0 !== d.shadow.radius && (f.shadow.radius = d.shadow.radius), void 0 !== d.shadow.mapSize && f.shadow.mapSize.fromArray(d.shadow.mapSize), void 0 !== d.shadow.camera && (f.shadow.camera = this.parseObject(d.shadow.camera)));
      void 0 !== d.visible && (f.visible = d.visible);
      void 0 !== d.userData && (f.userData = d.userData);
      if (void 0 !== d.children) {
        for (var m in d.children) {
          f.add(this.parseObject(d.children[m], b, c));
        }
      }
      if ("LOD" === d.type) {
        for (d = d.levels, k = 0;k < d.length;k++) {
          var q = d[k];
          m = f.getObjectByProperty("uuid", q.object);
          void 0 !== m && f.addLevel(m, q.distance);
        }
      }
      return f;
    };
  }()});
  Object.assign(Ra.prototype, {getPoint:function() {
    console.warn("THREE.Curve: Warning, getPoint() not implemented!");
    return null;
  }, getPointAt:function(d) {
    d = this.getUtoTmapping(d);
    return this.getPoint(d);
  }, getPoints:function(d) {
    void 0 === d && (d = 5);
    for (var a = [], b = 0;b <= d;b++) {
      a.push(this.getPoint(b / d));
    }
    return a;
  }, getSpacedPoints:function(d) {
    void 0 === d && (d = 5);
    for (var a = [], b = 0;b <= d;b++) {
      a.push(this.getPointAt(b / d));
    }
    return a;
  }, getLength:function() {
    var d = this.getLengths();
    return d[d.length - 1];
  }, getLengths:function(d) {
    void 0 === d && (d = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
    if (this.cacheArcLengths && this.cacheArcLengths.length === d + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = !1;
    var a = [], b, c = this.getPoint(0), e, g = 0;
    a.push(0);
    for (e = 1;e <= d;e++) {
      b = this.getPoint(e / d), g += b.distanceTo(c), a.push(g), c = b;
    }
    return this.cacheArcLengths = a;
  }, updateArcLengths:function() {
    this.needsUpdate = !0;
    this.getLengths();
  }, getUtoTmapping:function(d, a) {
    var b = this.getLengths(), c, e = b.length;
    d = a ? a : d * b[e - 1];
    a = 0;
    for (var g = e - 1, f;a <= g;) {
      if (c = Math.floor(a + (g - a) / 2), f = b[c] - d, 0 > f) {
        a = c + 1;
      } else {
        if (0 < f) {
          g = c - 1;
        } else {
          g = c;
          break;
        }
      }
    }
    c = g;
    if (b[c] === d) {
      return c / (e - 1);
    }
    a = b[c];
    return (c + (d - a) / (b[c + 1] - a)) / (e - 1);
  }, getTangent:function(d) {
    var a = d - 1E-4;
    d += 1E-4;
    0 > a && (a = 0);
    1 < d && (d = 1);
    a = this.getPoint(a);
    return this.getPoint(d).clone().sub(a).normalize();
  }, getTangentAt:function(a) {
    a = this.getUtoTmapping(a);
    return this.getTangent(a);
  }, computeFrenetFrames:function(a, b) {
    var d = new e, c = [], g = [], f = [], k = new e, m = new p, q, h;
    for (q = 0;q <= a;q++) {
      h = q / a, c[q] = this.getTangentAt(h), c[q].normalize();
    }
    g[0] = new e;
    f[0] = new e;
    q = Number.MAX_VALUE;
    h = Math.abs(c[0].x);
    var n = Math.abs(c[0].y), r = Math.abs(c[0].z);
    h <= q && (q = h, d.set(1, 0, 0));
    n <= q && (q = n, d.set(0, 1, 0));
    r <= q && d.set(0, 0, 1);
    k.crossVectors(c[0], d).normalize();
    g[0].crossVectors(c[0], k);
    f[0].crossVectors(c[0], g[0]);
    for (q = 1;q <= a;q++) {
      g[q] = g[q - 1].clone(), f[q] = f[q - 1].clone(), k.crossVectors(c[q - 1], c[q]), k.length() > Number.EPSILON && (k.normalize(), d = Math.acos(ka.clamp(c[q - 1].dot(c[q]), -1, 1)), g[q].applyMatrix4(m.makeRotationAxis(k, d))), f[q].crossVectors(c[q], g[q]);
    }
    if (!0 === b) {
      for (d = Math.acos(ka.clamp(g[0].dot(g[a]), -1, 1)), d /= a, 0 < c[0].dot(k.crossVectors(g[0], g[a])) && (d = -d), q = 1;q <= a;q++) {
        g[q].applyMatrix4(m.makeRotationAxis(c[q], d * q)), f[q].crossVectors(c[q], g[q]);
      }
    }
    return {tangents:c, normals:g, binormals:f};
  }});
  sb.prototype = Object.create(Ra.prototype);
  sb.prototype.constructor = sb;
  sb.prototype.isLineCurve = !0;
  sb.prototype.getPoint = function(a) {
    if (1 === a) {
      return this.v2.clone();
    }
    var d = this.v2.clone().sub(this.v1);
    d.multiplyScalar(a).add(this.v1);
    return d;
  };
  sb.prototype.getPointAt = function(a) {
    return this.getPoint(a);
  };
  sb.prototype.getTangent = function(a) {
    return this.v2.clone().sub(this.v1).normalize();
  };
  kd.prototype = Object.assign(Object.create(Ra.prototype), {constructor:kd, add:function(a) {
    this.curves.push(a);
  }, closePath:function() {
    var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
    a.equals(b) || this.curves.push(new sb(b, a));
  }, getPoint:function(a) {
    var d = a * this.getLength(), b = this.getCurveLengths();
    for (a = 0;a < b.length;) {
      if (b[a] >= d) {
        return d = b[a] - d, a = this.curves[a], b = a.getLength(), a.getPointAt(0 === b ? 0 : 1 - d / b);
      }
      a++;
    }
    return null;
  }, getLength:function() {
    var a = this.getCurveLengths();
    return a[a.length - 1];
  }, updateArcLengths:function() {
    this.needsUpdate = !0;
    this.cacheLengths = null;
    this.getLengths();
  }, getCurveLengths:function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    for (var a = [], b = 0, c = 0, e = this.curves.length;c < e;c++) {
      b += this.curves[c].getLength(), a.push(b);
    }
    return this.cacheLengths = a;
  }, getSpacedPoints:function(a) {
    void 0 === a && (a = 40);
    for (var d = [], b = 0;b <= a;b++) {
      d.push(this.getPoint(b / a));
    }
    this.autoClose && d.push(d[0]);
    return d;
  }, getPoints:function(a) {
    a = a || 12;
    for (var d = [], b, c = 0, e = this.curves;c < e.length;c++) {
      for (var g = e[c], g = g.getPoints(g && g.isEllipseCurve ? 2 * a : g && g.isLineCurve ? 1 : g && g.isSplineCurve ? a * g.points.length : a), f = 0;f < g.length;f++) {
        var k = g[f];
        b && b.equals(k) || (d.push(k), b = k);
      }
    }
    this.autoClose && 1 < d.length && !d[d.length - 1].equals(d[0]) && d.push(d[0]);
    return d;
  }, createPointsGeometry:function(a) {
    a = this.getPoints(a);
    return this.createGeometry(a);
  }, createSpacedPointsGeometry:function(a) {
    a = this.getSpacedPoints(a);
    return this.createGeometry(a);
  }, createGeometry:function(a) {
    for (var d = new ca, b = 0, c = a.length;b < c;b++) {
      var g = a[b];
      d.vertices.push(new e(g.x, g.y, g.z || 0));
    }
    return d;
  }});
  xb.prototype = Object.create(Ra.prototype);
  xb.prototype.constructor = xb;
  xb.prototype.isEllipseCurve = !0;
  xb.prototype.getPoint = function(a) {
    for (var d = 2 * Math.PI, b = this.aEndAngle - this.aStartAngle, c = Math.abs(b) < Number.EPSILON;0 > b;) {
      b += d;
    }
    for (;b > d;) {
      b -= d;
    }
    b < Number.EPSILON && (b = c ? 0 : d);
    !0 !== this.aClockwise || c || (b = b === d ? -d : b - d);
    d = this.aStartAngle + a * b;
    a = this.aX + this.xRadius * Math.cos(d);
    var e = this.aY + this.yRadius * Math.sin(d);
    0 !== this.aRotation && (d = Math.cos(this.aRotation), b = Math.sin(this.aRotation), c = a - this.aX, e -= this.aY, a = c * d - e * b + this.aX, e = c * b + e * d + this.aY);
    return new l(a, e);
  };
  Vb.prototype = Object.create(Ra.prototype);
  Vb.prototype.constructor = Vb;
  Vb.prototype.isSplineCurve = !0;
  Vb.prototype.getPoint = function(a) {
    var d = this.points, b = (d.length - 1) * a;
    a = Math.floor(b);
    var b = b - a, c = d[0 === a ? a : a - 1], e = d[a], g = d[a > d.length - 2 ? d.length - 1 : a + 1], d = d[a > d.length - 3 ? d.length - 1 : a + 2];
    return new l(Ke(b, c.x, e.x, g.x, d.x), Ke(b, c.y, e.y, g.y, d.y));
  };
  xc.prototype = Object.create(Ra.prototype);
  xc.prototype.constructor = xc;
  xc.prototype.getPoint = function(a) {
    var d = this.v0, b = this.v1, c = this.v2, e = this.v3;
    return new l(Ub(a, d.x, b.x, c.x, e.x), Ub(a, d.y, b.y, c.y, e.y));
  };
  yc.prototype = Object.create(Ra.prototype);
  yc.prototype.constructor = yc;
  yc.prototype.getPoint = function(a) {
    var d = this.v0, b = this.v1, c = this.v2;
    return new l(Tb(a, d.x, b.x, c.x), Tb(a, d.y, b.y, c.y));
  };
  var xe = Object.assign(Object.create(kd.prototype), {fromPoints:function(a) {
    this.moveTo(a[0].x, a[0].y);
    for (var d = 1, b = a.length;d < b;d++) {
      this.lineTo(a[d].x, a[d].y);
    }
  }, moveTo:function(a, b) {
    this.currentPoint.set(a, b);
  }, lineTo:function(a, b) {
    var d = new sb(this.currentPoint.clone(), new l(a, b));
    this.curves.push(d);
    this.currentPoint.set(a, b);
  }, quadraticCurveTo:function(a, b, c, e) {
    a = new yc(this.currentPoint.clone(), new l(a, b), new l(c, e));
    this.curves.push(a);
    this.currentPoint.set(c, e);
  }, bezierCurveTo:function(a, b, c, e, g, f) {
    a = new xc(this.currentPoint.clone(), new l(a, b), new l(c, e), new l(g, f));
    this.curves.push(a);
    this.currentPoint.set(g, f);
  }, splineThru:function(a) {
    var d = [this.currentPoint.clone()].concat(a), d = new Vb(d);
    this.curves.push(d);
    this.currentPoint.copy(a[a.length - 1]);
  }, arc:function(a, b, c, e, g, f) {
    this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, e, g, f);
  }, absarc:function(a, b, c, e, g, f) {
    this.absellipse(a, b, c, c, e, g, f);
  }, ellipse:function(a, b, c, e, g, f, k, q) {
    this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, e, g, f, k, q);
  }, absellipse:function(a, b, c, e, g, f, k, q) {
    a = new xb(a, b, c, e, g, f, k, q);
    0 < this.curves.length && (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y));
    this.curves.push(a);
    a = a.getPoint(1);
    this.currentPoint.copy(a);
  }});
  ld.prototype = xe;
  xe.constructor = ld;
  Wb.prototype = Object.assign(Object.create(xe), {constructor:Wb, getPointsHoles:function(a) {
    for (var d = [], b = 0, c = this.holes.length;b < c;b++) {
      d[b] = this.holes[b].getPoints(a);
    }
    return d;
  }, extractAllPoints:function(a) {
    return {shape:this.getPoints(a), holes:this.getPointsHoles(a)};
  }, extractPoints:function(a) {
    return this.extractAllPoints(a);
  }});
  Object.assign(ke.prototype, {moveTo:function(a, b) {
    this.currentPath = new ld;
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(a, b);
  }, lineTo:function(a, b) {
    this.currentPath.lineTo(a, b);
  }, quadraticCurveTo:function(a, b, c, e) {
    this.currentPath.quadraticCurveTo(a, b, c, e);
  }, bezierCurveTo:function(a, b, c, e, g, f) {
    this.currentPath.bezierCurveTo(a, b, c, e, g, f);
  }, splineThru:function(a) {
    this.currentPath.splineThru(a);
  }, toShapes:function(a, b) {
    function d(a) {
      for (var d = [], b = 0, c = a.length;b < c;b++) {
        var e = a[b], g = new Wb;
        g.curves = e.curves;
        d.push(g);
      }
      return d;
    }
    function c(a, d) {
      for (var b = d.length, c = !1, e = b - 1, g = 0;g < b;e = g++) {
        var f = d[e], k = d[g], q = k.x - f.x, m = k.y - f.y;
        if (Math.abs(m) > Number.EPSILON) {
          if (0 > m && (f = d[g], q = -q, k = d[e], m = -m), !(a.y < f.y || a.y > k.y)) {
            if (a.y === f.y) {
              if (a.x === f.x) {
                return !0;
              }
            } else {
              e = m * (a.x - f.x) - q * (a.y - f.y);
              if (0 === e) {
                return !0;
              }
              0 > e || (c = !c);
            }
          }
        } else {
          if (a.y === f.y && (k.x <= a.x && a.x <= f.x || f.x <= a.x && a.x <= k.x)) {
            return !0;
          }
        }
      }
      return c;
    }
    var e = fb.isClockWise, g = this.subPaths;
    if (0 === g.length) {
      return [];
    }
    if (!0 === b) {
      return d(g);
    }
    var f, k, q = [];
    if (1 === g.length) {
      return f = g[0], k = new Wb, k.curves = f.curves, q.push(k), q;
    }
    var m = !e(g[0].getPoints()), m = a ? !m : m;
    k = [];
    var p = [], h = [], n = 0, r;
    p[n] = void 0;
    h[n] = [];
    for (var l = 0, u = g.length;l < u;l++) {
      f = g[l], r = f.getPoints(), b = e(r), (b = a ? !b : b) ? (!m && p[n] && n++, p[n] = {s:new Wb, p:r}, p[n].s.curves = f.curves, m && n++, h[n] = []) : h[n].push({h:f, p:r[0]});
    }
    if (!p[0]) {
      return d(g);
    }
    if (1 < p.length) {
      l = !1;
      f = [];
      e = 0;
      for (g = p.length;e < g;e++) {
        k[e] = [];
      }
      e = 0;
      for (g = p.length;e < g;e++) {
        for (b = h[e], m = 0;m < b.length;m++) {
          n = b[m];
          r = !0;
          for (u = 0;u < p.length;u++) {
            c(n.p, p[u].p) && (e !== u && f.push({froms:e, tos:u, hole:m}), r ? (r = !1, k[u].push(n)) : l = !0);
          }
          r && k[e].push(n);
        }
      }
      0 < f.length && (l || (h = k));
    }
    l = 0;
    for (e = p.length;l < e;l++) {
      for (k = p[l].s, q.push(k), f = h[l], g = 0, b = f.length;g < b;g++) {
        k.holes.push(f[g].h);
      }
    }
    return q;
  }});
  Object.assign(le.prototype, {isFont:!0, generateShapes:function(a, b, c) {
    void 0 === b && (b = 100);
    void 0 === c && (c = 4);
    var d = this.data;
    a = String(a).split("");
    var e = b / d.resolution, g = (d.boundingBox.yMax - d.boundingBox.yMin + d.underlineThickness) * e, f = 0, k = 0;
    b = [];
    for (var q = 0;q < a.length;q++) {
      var m = a[q];
      if ("\n" === m) {
        f = 0, k -= g;
      } else {
        var p;
        p = e;
        var h = f, n = k;
        if (m = d.glyphs[m] || d.glyphs["?"]) {
          var r = new ke, l = [], u, w, t, v, B, y, x, z;
          if (m.o) {
            for (var A = m._cachedOutline || (m._cachedOutline = m.o.split(" ")), C = 0, F = A.length;C < F;) {
              switch(A[C++]) {
                case "m":
                  u = A[C++] * p + h;
                  w = A[C++] * p + n;
                  r.moveTo(u, w);
                  break;
                case "l":
                  u = A[C++] * p + h;
                  w = A[C++] * p + n;
                  r.lineTo(u, w);
                  break;
                case "q":
                  u = A[C++] * p + h;
                  w = A[C++] * p + n;
                  B = A[C++] * p + h;
                  y = A[C++] * p + n;
                  r.quadraticCurveTo(B, y, u, w);
                  if (v = l[l.length - 1]) {
                    t = v.x;
                    v = v.y;
                    for (var E = 1;E <= c;E++) {
                      var D = E / c;
                      Tb(D, t, B, u);
                      Tb(D, v, y, w);
                    }
                  }
                  break;
                case "b":
                  if (u = A[C++] * p + h, w = A[C++] * p + n, B = A[C++] * p + h, y = A[C++] * p + n, x = A[C++] * p + h, z = A[C++] * p + n, r.bezierCurveTo(B, y, x, z, u, w), v = l[l.length - 1]) {
                    for (t = v.x, v = v.y, E = 1;E <= c;E++) {
                      D = E / c, Ub(D, t, B, x, u), Ub(D, v, y, z, w);
                    }
                  }
              }
            }
          }
          p = {offsetX:m.ha * p, path:r};
        } else {
          p = void 0;
        }
        f += p.offsetX;
        b.push(p.path);
      }
    }
    c = [];
    d = 0;
    for (a = b.length;d < a;d++) {
      Array.prototype.push.apply(c, b[d].toShapes());
    }
    return c;
  }});
  Object.assign(Le.prototype, {load:function(a, b, c, e) {
    var d = this;
    (new hb(this.manager)).load(a, function(a) {
      var c;
      try {
        c = JSON.parse(a);
      } catch (Q) {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c = JSON.parse(a.substring(65, a.length - 2));
      }
      a = d.parse(c);
      b && b(a);
    }, c, e);
  }, parse:function(a) {
    return new le(a);
  }});
  var Zd, oe = {getContext:function() {
    void 0 === Zd && (Zd = new (window.AudioContext || window.webkitAudioContext));
    return Zd;
  }, setContext:function(a) {
    Zd = a;
  }};
  Object.assign(me.prototype, {load:function(a, b, c, e) {
    var d = new hb(this.manager);
    d.setResponseType("arraybuffer");
    d.load(a, function(a) {
      oe.getContext().decodeAudioData(a, function(a) {
        b(a);
      });
    }, c, e);
  }});
  Object.assign(Me.prototype, {update:function() {
    var a, b, c, e, g, f, k, q, h = new p, n = new p;
    return function(d) {
      if (a !== this || b !== d.focus || c !== d.fov || e !== d.aspect * this.aspect || g !== d.near || f !== d.far || k !== d.zoom || q !== this.eyeSep) {
        a = this;
        b = d.focus;
        c = d.fov;
        e = d.aspect * this.aspect;
        g = d.near;
        f = d.far;
        k = d.zoom;
        var m = d.projectionMatrix.clone();
        q = this.eyeSep / 2;
        var p = q * g / b, r = g * Math.tan(ka.DEG2RAD * c * .5) / k, l, u;
        n.elements[12] = -q;
        h.elements[12] = q;
        l = -r * e + p;
        u = r * e + p;
        m.elements[0] = 2 * g / (u - l);
        m.elements[8] = (u + l) / (u - l);
        this.cameraL.projectionMatrix.copy(m);
        l = -r * e - p;
        u = r * e - p;
        m.elements[0] = 2 * g / (u - l);
        m.elements[8] = (u + l) / (u - l);
        this.cameraR.projectionMatrix.copy(m);
      }
      this.cameraL.matrixWorld.copy(d.matrixWorld).multiply(n);
      this.cameraR.matrixWorld.copy(d.matrixWorld).multiply(h);
    };
  }()});
  Td.prototype = Object.create(U.prototype);
  Td.prototype.constructor = Td;
  ne.prototype = Object.assign(Object.create(U.prototype), {constructor:ne, getInput:function() {
    return this.gain;
  }, removeFilter:function() {
    null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null);
  }, getFilter:function() {
    return this.filter;
  }, setFilter:function(a) {
    null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination);
    this.filter = a;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
  }, getMasterVolume:function() {
    return this.gain.gain.value;
  }, setMasterVolume:function(a) {
    this.gain.gain.value = a;
  }, updateMatrixWorld:function() {
    var a = new e, b = new g, c = new e, f = new e;
    return function(d) {
      U.prototype.updateMatrixWorld.call(this, d);
      d = this.context.listener;
      var e = this.up;
      this.matrixWorld.decompose(a, b, c);
      f.set(0, 0, -1).applyQuaternion(b);
      d.positionX ? (d.positionX.setValueAtTime(a.x, this.context.currentTime), d.positionY.setValueAtTime(a.y, this.context.currentTime), d.positionZ.setValueAtTime(a.z, this.context.currentTime), d.forwardX.setValueAtTime(f.x, this.context.currentTime), d.forwardY.setValueAtTime(f.y, this.context.currentTime), d.forwardZ.setValueAtTime(f.z, this.context.currentTime), d.upX.setValueAtTime(e.x, this.context.currentTime), d.upY.setValueAtTime(e.y, this.context.currentTime), d.upZ.setValueAtTime(e.z, 
      this.context.currentTime)) : (d.setPosition(a.x, a.y, a.z), d.setOrientation(f.x, f.y, f.z, e.x, e.y, e.z));
    };
  }()});
  zc.prototype = Object.assign(Object.create(U.prototype), {constructor:zc, getOutput:function() {
    return this.gain;
  }, setNodeSource:function(a) {
    this.hasPlaybackControl = !1;
    this.sourceType = "audioNode";
    this.source = a;
    this.connect();
    return this;
  }, setBuffer:function(a) {
    this.buffer = a;
    this.sourceType = "buffer";
    this.autoplay && this.play();
    return this;
  }, play:function() {
    if (!0 === this.isPlaying) {
      console.warn("THREE.Audio: Audio is already playing.");
    } else {
      if (!1 === this.hasPlaybackControl) {
        console.warn("THREE.Audio: this Audio has no playback control.");
      } else {
        var a = this.context.createBufferSource();
        a.buffer = this.buffer;
        a.loop = this.loop;
        a.onended = this.onEnded.bind(this);
        a.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
        a.start(0, this.startTime);
        this.isPlaying = !0;
        this.source = a;
        return this.connect();
      }
    }
  }, pause:function() {
    if (!1 === this.hasPlaybackControl) {
      console.warn("THREE.Audio: this Audio has no playback control.");
    } else {
      return this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = !1, this;
    }
  }, stop:function() {
    if (!1 === this.hasPlaybackControl) {
      console.warn("THREE.Audio: this Audio has no playback control.");
    } else {
      return this.source.stop(), this.startTime = 0, this.isPlaying = !1, this;
    }
  }, connect:function() {
    if (0 < this.filters.length) {
      this.source.connect(this.filters[0]);
      for (var a = 1, b = this.filters.length;a < b;a++) {
        this.filters[a - 1].connect(this.filters[a]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    return this;
  }, disconnect:function() {
    if (0 < this.filters.length) {
      this.source.disconnect(this.filters[0]);
      for (var a = 1, b = this.filters.length;a < b;a++) {
        this.filters[a - 1].disconnect(this.filters[a]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    return this;
  }, getFilters:function() {
    return this.filters;
  }, setFilters:function(a) {
    a || (a = []);
    !0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a;
    return this;
  }, getFilter:function() {
    return this.getFilters()[0];
  }, setFilter:function(a) {
    return this.setFilters(a ? [a] : []);
  }, setPlaybackRate:function(a) {
    if (!1 === this.hasPlaybackControl) {
      console.warn("THREE.Audio: this Audio has no playback control.");
    } else {
      return this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
    }
  }, getPlaybackRate:function() {
    return this.playbackRate;
  }, onEnded:function() {
    this.isPlaying = !1;
  }, getLoop:function() {
    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }, setLoop:function(a) {
    if (!1 === this.hasPlaybackControl) {
      console.warn("THREE.Audio: this Audio has no playback control.");
    } else {
      return this.loop = a, !0 === this.isPlaying && (this.source.loop = this.loop), this;
    }
  }, getVolume:function() {
    return this.gain.gain.value;
  }, setVolume:function(a) {
    this.gain.gain.value = a;
    return this;
  }});
  pe.prototype = Object.assign(Object.create(zc.prototype), {constructor:pe, getOutput:function() {
    return this.panner;
  }, getRefDistance:function() {
    return this.panner.refDistance;
  }, setRefDistance:function(a) {
    this.panner.refDistance = a;
  }, getRolloffFactor:function() {
    return this.panner.rolloffFactor;
  }, setRolloffFactor:function(a) {
    this.panner.rolloffFactor = a;
  }, getDistanceModel:function() {
    return this.panner.distanceModel;
  }, setDistanceModel:function(a) {
    this.panner.distanceModel = a;
  }, getMaxDistance:function() {
    return this.panner.maxDistance;
  }, setMaxDistance:function(a) {
    this.panner.maxDistance = a;
  }, updateMatrixWorld:function() {
    var a = new e;
    return function(d) {
      U.prototype.updateMatrixWorld.call(this, d);
      a.setFromMatrixPosition(this.matrixWorld);
      this.panner.setPosition(a.x, a.y, a.z);
    };
  }()});
  Object.assign(qe.prototype, {getFrequencyData:function() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }, getAverageFrequency:function() {
    for (var a = 0, b = this.getFrequencyData(), c = 0;c < b.length;c++) {
      a += b[c];
    }
    return a / b.length;
  }});
  Object.assign(re.prototype, {accumulate:function(a, b) {
    var d = this.buffer, c = this.valueSize;
    a = a * c + c;
    var e = this.cumulativeWeight;
    if (0 === e) {
      for (e = 0;e !== c;++e) {
        d[a + e] = d[e];
      }
      e = b;
    } else {
      e += b, this._mixBufferRegion(d, a, 0, b / e, c);
    }
    this.cumulativeWeight = e;
  }, apply:function(a) {
    var d = this.valueSize, b = this.buffer;
    a = a * d + d;
    var c = this.cumulativeWeight, e = this.binding;
    this.cumulativeWeight = 0;
    1 > c && this._mixBufferRegion(b, a, 3 * d, 1 - c, d);
    for (var c = d, g = d + d;c !== g;++c) {
      if (b[c] !== b[c + d]) {
        e.setValue(b, a);
        break;
      }
    }
  }, saveOriginalState:function() {
    var a = this.buffer, b = this.valueSize, c = 3 * b;
    this.binding.getValue(a, c);
    for (var e = b;e !== c;++e) {
      a[e] = a[c + e % b];
    }
    this.cumulativeWeight = 0;
  }, restoreOriginalState:function() {
    this.binding.setValue(this.buffer, 3 * this.valueSize);
  }, _select:function(a, b, c, e, g) {
    if (.5 <= e) {
      for (e = 0;e !== g;++e) {
        a[b + e] = a[c + e];
      }
    }
  }, _slerp:function(a, b, c, e) {
    g.slerpFlat(a, b, a, b, a, c, e);
  }, _lerp:function(a, b, c, e, g) {
    for (var d = 1 - e, f = 0;f !== g;++f) {
      var k = b + f;
      a[k] = a[k] * d + a[c + f] * e;
    }
  }});
  Object.assign(Ne.prototype, {getValue:function(a, b) {
    this.bind();
    var d = this._bindings[this._targetGroup.nCachedObjects_];
    void 0 !== d && d.getValue(a, b);
  }, setValue:function(a, b) {
    for (var d = this._bindings, c = this._targetGroup.nCachedObjects_, e = d.length;c !== e;++c) {
      d[c].setValue(a, b);
    }
  }, bind:function() {
    for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length;b !== c;++b) {
      a[b].bind();
    }
  }, unbind:function() {
    for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length;b !== c;++b) {
      a[b].unbind();
    }
  }});
  Object.assign(Da, {Composite:Ne, create:function(a, b, c) {
    return a && a.isAnimationObjectGroup ? new Da.Composite(a, b, c) : new Da(a, b, c);
  }, parseTrackName:function(a) {
    var d = /^((?:[\w-]+[\/:])*)([\w-]+)?(?:\.([\w-]+)(?:\[(.+)\])?)?\.([\w-]+)(?:\[(.+)\])?$/.exec(a);
    if (!d) {
      throw Error("cannot parse trackName at all: " + a);
    }
    d = {nodeName:d[2], objectName:d[3], objectIndex:d[4], propertyName:d[5], propertyIndex:d[6]};
    if (null === d.propertyName || 0 === d.propertyName.length) {
      throw Error("can not parse propertyName from trackName: " + a);
    }
    return d;
  }, findNode:function(a, b) {
    if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) {
      return a;
    }
    if (a.skeleton) {
      var d = function(a) {
        for (var d = 0;d < a.bones.length;d++) {
          var c = a.bones[d];
          if (c.name === b) {
            return c;
          }
        }
        return null;
      }(a.skeleton);
      if (d) {
        return d;
      }
    }
    if (a.children) {
      var c = function(a) {
        for (var d = 0;d < a.length;d++) {
          var e = a[d];
          if (e.name === b || e.uuid === b || (e = c(e.children))) {
            return e;
          }
        }
        return null;
      };
      if (d = c(a.children)) {
        return d;
      }
    }
    return null;
  }});
  Object.assign(Da.prototype, {_getValue_unavailable:function() {
  }, _setValue_unavailable:function() {
  }, BindingType:{Direct:0, EntireArray:1, ArrayElement:2, HasFromToArray:3}, Versioning:{None:0, NeedsUpdate:1, MatrixWorldNeedsUpdate:2}, GetterByBindingType:[function(a, b) {
    a[b] = this.node[this.propertyName];
  }, function(a, b) {
    for (var d = this.resolvedProperty, c = 0, e = d.length;c !== e;++c) {
      a[b++] = d[c];
    }
  }, function(a, b) {
    a[b] = this.resolvedProperty[this.propertyIndex];
  }, function(a, b) {
    this.resolvedProperty.toArray(a, b);
  }], SetterByBindingTypeAndVersioning:[[function(a, b) {
    this.node[this.propertyName] = a[b];
  }, function(a, b) {
    this.node[this.propertyName] = a[b];
    this.targetObject.needsUpdate = !0;
  }, function(a, b) {
    this.node[this.propertyName] = a[b];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }], [function(a, b) {
    for (var d = this.resolvedProperty, c = 0, e = d.length;c !== e;++c) {
      d[c] = a[b++];
    }
  }, function(a, b) {
    for (var d = this.resolvedProperty, c = 0, e = d.length;c !== e;++c) {
      d[c] = a[b++];
    }
    this.targetObject.needsUpdate = !0;
  }, function(a, b) {
    for (var d = this.resolvedProperty, c = 0, e = d.length;c !== e;++c) {
      d[c] = a[b++];
    }
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }], [function(a, b) {
    this.resolvedProperty[this.propertyIndex] = a[b];
  }, function(a, b) {
    this.resolvedProperty[this.propertyIndex] = a[b];
    this.targetObject.needsUpdate = !0;
  }, function(a, b) {
    this.resolvedProperty[this.propertyIndex] = a[b];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }], [function(a, b) {
    this.resolvedProperty.fromArray(a, b);
  }, function(a, b) {
    this.resolvedProperty.fromArray(a, b);
    this.targetObject.needsUpdate = !0;
  }, function(a, b) {
    this.resolvedProperty.fromArray(a, b);
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }]], getValue:function(a, b) {
    this.bind();
    this.getValue(a, b);
  }, setValue:function(a, b) {
    this.bind();
    this.setValue(a, b);
  }, bind:function() {
    var a = this.node, b = this.parsedPath, c = b.objectName, e = b.propertyName, g = b.propertyIndex;
    a || (this.node = a = Da.findNode(this.rootNode, b.nodeName) || this.rootNode);
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (a) {
      if (c) {
        var f = b.objectIndex;
        switch(c) {
          case "materials":
            if (!a.material) {
              console.error("  can not bind to material as node does not have a material", this);
              return;
            }
            if (!a.material.materials) {
              console.error("  can not bind to material.materials as node.material does not have a materials array", this);
              return;
            }
            a = a.material.materials;
            break;
          case "bones":
            if (!a.skeleton) {
              console.error("  can not bind to bones as node does not have a skeleton", this);
              return;
            }
            a = a.skeleton.bones;
            for (c = 0;c < a.length;c++) {
              if (a[c].name === f) {
                f = c;
                break;
              }
            }
            break;
          default:
            if (void 0 === a[c]) {
              console.error("  can not bind to objectName of node, undefined", this);
              return;
            }
            a = a[c];
        }
        if (void 0 !== f) {
          if (void 0 === a[f]) {
            console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, a);
            return;
          }
          a = a[f];
        }
      }
      f = a[e];
      if (void 0 === f) {
        console.error("  trying to update property for track: " + b.nodeName + "." + e + " but it wasn't found.", a);
      } else {
        b = this.Versioning.None;
        void 0 !== a.needsUpdate ? (b = this.Versioning.NeedsUpdate, this.targetObject = a) : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = a);
        c = this.BindingType.Direct;
        if (void 0 !== g) {
          if ("morphTargetInfluences" === e) {
            if (!a.geometry) {
              console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
              return;
            }
            if (!a.geometry.morphTargets) {
              console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
              return;
            }
            for (c = 0;c < this.node.geometry.morphTargets.length;c++) {
              if (a.geometry.morphTargets[c].name === g) {
                g = c;
                break;
              }
            }
          }
          c = this.BindingType.ArrayElement;
          this.resolvedProperty = f;
          this.propertyIndex = g;
        } else {
          void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = f) : Array.isArray(f) ? (c = this.BindingType.EntireArray, this.resolvedProperty = f) : this.propertyName = e;
        }
        this.getValue = this.GetterByBindingType[c];
        this.setValue = this.SetterByBindingTypeAndVersioning[c][b];
      }
    } else {
      console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
    }
  }, unbind:function() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }});
  Object.assign(Da.prototype, {_getValue_unbound:Da.prototype.getValue, _setValue_unbound:Da.prototype.setValue});
  Object.assign(Oe.prototype, {isAnimationObjectGroup:!0, add:function(a) {
    for (var d = this._objects, b = d.length, c = this.nCachedObjects_, e = this._indicesByUUID, g = this._paths, f = this._parsedPaths, k = this._bindings, q = k.length, p = 0, h = arguments.length;p !== h;++p) {
      var n = arguments[p], r = n.uuid, l = e[r];
      if (void 0 === l) {
        l = b++;
        e[r] = l;
        d.push(n);
        for (var r = 0, u = q;r !== u;++r) {
          k[r].push(new Da(n, g[r], f[r]));
        }
      } else {
        if (l < c) {
          var w = --c, u = d[w];
          e[u.uuid] = l;
          d[l] = u;
          e[r] = w;
          d[w] = n;
          r = 0;
          for (u = q;r !== u;++r) {
            var t = k[r], v = t[l];
            t[l] = t[w];
            void 0 === v && (v = new Da(n, g[r], f[r]));
            t[w] = v;
          }
        } else {
          void 0 !== d[l] && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...");
        }
      }
    }
    this.nCachedObjects_ = c;
  }, remove:function(a) {
    for (var d = this._objects, b = this.nCachedObjects_, c = this._indicesByUUID, e = this._bindings, g = e.length, f = 0, k = arguments.length;f !== k;++f) {
      var q = arguments[f], p = q.uuid, h = c[p];
      if (void 0 !== h && h >= b) {
        var n = b++, r = d[n];
        c[r.uuid] = h;
        d[h] = r;
        c[p] = n;
        d[n] = q;
        q = 0;
        for (p = g;q !== p;++q) {
          var r = e[q], l = r[h];
          r[h] = r[n];
          r[n] = l;
        }
      }
    }
    this.nCachedObjects_ = b;
  }, uncache:function(a) {
    for (var d = this._objects, b = d.length, c = this.nCachedObjects_, e = this._indicesByUUID, g = this._bindings, f = g.length, k = 0, q = arguments.length;k !== q;++k) {
      var p = arguments[k].uuid, h = e[p];
      if (void 0 !== h) {
        if (delete e[p], h < c) {
          var p = --c, n = d[p], r = --b, l = d[r];
          e[n.uuid] = h;
          d[h] = n;
          e[l.uuid] = p;
          d[p] = l;
          d.pop();
          n = 0;
          for (l = f;n !== l;++n) {
            var u = g[n], w = u[r];
            u[h] = u[p];
            u[p] = w;
            u.pop();
          }
        } else {
          for (r = --b, l = d[r], e[l.uuid] = h, d[h] = l, d.pop(), n = 0, l = f;n !== l;++n) {
            u = g[n], u[h] = u[r], u.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = c;
  }, subscribe_:function(a, b) {
    var d = this._bindingsIndicesByPath, c = d[a], e = this._bindings;
    if (void 0 !== c) {
      return e[c];
    }
    var g = this._paths, f = this._parsedPaths, k = this._objects, q = this.nCachedObjects_, p = Array(k.length), c = e.length;
    d[a] = c;
    g.push(a);
    f.push(b);
    e.push(p);
    d = q;
    for (c = k.length;d !== c;++d) {
      p[d] = new Da(k[d], a, b);
    }
    return p;
  }, unsubscribe_:function(a) {
    var d = this._bindingsIndicesByPath, b = d[a];
    if (void 0 !== b) {
      var c = this._paths, e = this._parsedPaths, g = this._bindings, f = g.length - 1, k = g[f];
      d[a[f]] = b;
      g[b] = k;
      g.pop();
      e[b] = e[f];
      e.pop();
      c[b] = c[f];
      c.pop();
    }
  }});
  Object.assign(Pe.prototype, {play:function() {
    this._mixer._activateAction(this);
    return this;
  }, stop:function() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }, reset:function() {
    this.paused = !1;
    this.enabled = !0;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }, isRunning:function() {
    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
  }, isScheduled:function() {
    return this._mixer._isActiveAction(this);
  }, startAt:function(a) {
    this._startTime = a;
    return this;
  }, setLoop:function(a, b) {
    this.loop = a;
    this.repetitions = b;
    return this;
  }, setEffectiveWeight:function(a) {
    this.weight = a;
    this._effectiveWeight = this.enabled ? a : 0;
    return this.stopFading();
  }, getEffectiveWeight:function() {
    return this._effectiveWeight;
  }, fadeIn:function(a) {
    return this._scheduleFading(a, 0, 1);
  }, fadeOut:function(a) {
    return this._scheduleFading(a, 1, 0);
  }, crossFadeFrom:function(a, b, c) {
    a.fadeOut(b);
    this.fadeIn(b);
    if (c) {
      c = this._clip.duration;
      var d = a._clip.duration, e = c / d;
      a.warp(1, d / c, b);
      this.warp(e, 1, b);
    }
    return this;
  }, crossFadeTo:function(a, b, c) {
    return a.crossFadeFrom(this, b, c);
  }, stopFading:function() {
    var a = this._weightInterpolant;
    null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a));
    return this;
  }, setEffectiveTimeScale:function(a) {
    this.timeScale = a;
    this._effectiveTimeScale = this.paused ? 0 : a;
    return this.stopWarping();
  }, getEffectiveTimeScale:function() {
    return this._effectiveTimeScale;
  }, setDuration:function(a) {
    this.timeScale = this._clip.duration / a;
    return this.stopWarping();
  }, syncWith:function(a) {
    this.time = a.time;
    this.timeScale = a.timeScale;
    return this.stopWarping();
  }, halt:function(a) {
    return this.warp(this._effectiveTimeScale, 0, a);
  }, warp:function(a, b, c) {
    var d = this._mixer, e = d.time, g = this._timeScaleInterpolant, f = this.timeScale;
    null === g && (this._timeScaleInterpolant = g = d._lendControlInterpolant());
    d = g.parameterPositions;
    g = g.sampleValues;
    d[0] = e;
    d[1] = e + c;
    g[0] = a / f;
    g[1] = b / f;
    return this;
  }, stopWarping:function() {
    var a = this._timeScaleInterpolant;
    null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a));
    return this;
  }, getMixer:function() {
    return this._mixer;
  }, getClip:function() {
    return this._clip;
  }, getRoot:function() {
    return this._localRoot || this._mixer._root;
  }, _update:function(a, b, c, e) {
    var d = this._startTime;
    if (null !== d) {
      b = (a - d) * c;
      if (0 > b || 0 === c) {
        return;
      }
      this._startTime = null;
      b *= c;
    }
    b *= this._updateTimeScale(a);
    c = this._updateTime(b);
    a = this._updateWeight(a);
    if (0 < a) {
      b = this._interpolants;
      for (var d = this._propertyBindings, g = 0, f = b.length;g !== f;++g) {
        b[g].evaluate(c), d[g].accumulate(e, a);
      }
    }
  }, _updateWeight:function(a) {
    var d = 0;
    if (this.enabled) {
      var d = this.weight, b = this._weightInterpolant;
      if (null !== b) {
        var c = b.evaluate(a)[0], d = d * c;
        a > b.parameterPositions[1] && (this.stopFading(), 0 === c && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = d;
  }, _updateTimeScale:function(a) {
    var d = 0;
    if (!this.paused) {
      var d = this.timeScale, b = this._timeScaleInterpolant;
      if (null !== b) {
        var c = b.evaluate(a)[0], d = d * c;
        a > b.parameterPositions[1] && (this.stopWarping(), 0 === d ? this.paused = !0 : this.timeScale = d);
      }
    }
    return this._effectiveTimeScale = d;
  }, _updateTime:function(a) {
    var d = this.time + a;
    if (0 === a) {
      return d;
    }
    var b = this._clip.duration, c = this.loop, e = this._loopCount;
    if (2200 === c) {
      a: {
        if (-1 === e && (this._loopCount = 0, this._setEndings(!0, !0, !1)), d >= b) {
          d = b;
        } else {
          if (0 > d) {
            d = 0;
          } else {
            break a;
          }
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1;
        this._mixer.dispatchEvent({type:"finished", action:this, direction:0 > a ? -1 : 1});
      }
    } else {
      c = 2202 === c;
      -1 === e && (0 <= a ? (e = 0, this._setEndings(!0, 0 === this.repetitions, c)) : this._setEndings(0 === this.repetitions, !0, c));
      if (d >= b || 0 > d) {
        var g = Math.floor(d / b), d = d - b * g, e = e + Math.abs(g), f = this.repetitions - e;
        0 > f ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, d = 0 < a ? b : 0, this._mixer.dispatchEvent({type:"finished", action:this, direction:0 < a ? 1 : -1})) : (0 === f ? (a = 0 > a, this._setEndings(a, !a, c)) : this._setEndings(!1, !1, c), this._loopCount = e, this._mixer.dispatchEvent({type:"loop", action:this, loopDelta:g}));
      }
      if (c && 1 === (e & 1)) {
        return this.time = d, b - d;
      }
    }
    return this.time = d;
  }, _setEndings:function(a, b, c) {
    var d = this._interpolantSettings;
    c ? (d.endingStart = 2401, d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, d.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
  }, _scheduleFading:function(a, b, c) {
    var d = this._mixer, e = d.time, g = this._weightInterpolant;
    null === g && (this._weightInterpolant = g = d._lendControlInterpolant());
    d = g.parameterPositions;
    g = g.sampleValues;
    d[0] = e;
    g[0] = b;
    d[1] = e + a;
    g[1] = c;
    return this;
  }});
  Object.assign(Qe.prototype, h.prototype, {_bindAction:function(a, b) {
    var d = a._localRoot || this._root, c = a._clip.tracks, e = c.length, g = a._propertyBindings;
    a = a._interpolants;
    var f = d.uuid, k = this._bindingsByRootAndName, q = k[f];
    void 0 === q && (q = {}, k[f] = q);
    for (k = 0;k !== e;++k) {
      var p = c[k], m = p.name, h = q[m];
      if (void 0 === h) {
        h = g[k];
        if (void 0 !== h) {
          null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, f, m));
          continue;
        }
        h = new re(Da.create(d, m, b && b._propertyBindings[k].binding.parsedPath), p.ValueTypeName, p.getValueSize());
        ++h.referenceCount;
        this._addInactiveBinding(h, f, m);
      }
      g[k] = h;
      a[k].resultBuffer = h.buffer;
    }
  }, _activateAction:function(a) {
    if (!this._isActiveAction(a)) {
      if (null === a._cacheIndex) {
        var d = (a._localRoot || this._root).uuid, b = a._clip.uuid, c = this._actionsByClip[b];
        this._bindAction(a, c && c.knownActions[0]);
        this._addInactiveAction(a, b, d);
      }
      d = a._propertyBindings;
      b = 0;
      for (c = d.length;b !== c;++b) {
        var e = d[b];
        0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState());
      }
      this._lendAction(a);
    }
  }, _deactivateAction:function(a) {
    if (this._isActiveAction(a)) {
      for (var d = a._propertyBindings, b = 0, c = d.length;b !== c;++b) {
        var e = d[b];
        0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e));
      }
      this._takeBackAction(a);
    }
  }, _initMemoryManager:function() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    var a = this;
    this.stats = {actions:{get total() {
      return a._actions.length;
    }, get inUse() {
      return a._nActiveActions;
    }}, bindings:{get total() {
      return a._bindings.length;
    }, get inUse() {
      return a._nActiveBindings;
    }}, controlInterpolants:{get total() {
      return a._controlInterpolants.length;
    }, get inUse() {
      return a._nActiveControlInterpolants;
    }}};
  }, _isActiveAction:function(a) {
    a = a._cacheIndex;
    return null !== a && a < this._nActiveActions;
  }, _addInactiveAction:function(a, b, c) {
    var d = this._actions, e = this._actionsByClip, g = e[b];
    void 0 === g ? (g = {knownActions:[a], actionByRoot:{}}, a._byClipCacheIndex = 0, e[b] = g) : (b = g.knownActions, a._byClipCacheIndex = b.length, b.push(a));
    a._cacheIndex = d.length;
    d.push(a);
    g.actionByRoot[c] = a;
  }, _removeInactiveAction:function(a) {
    var d = this._actions, b = d[d.length - 1], c = a._cacheIndex;
    b._cacheIndex = c;
    d[c] = b;
    d.pop();
    a._cacheIndex = null;
    var d = a._clip.uuid, b = this._actionsByClip, c = b[d], e = c.knownActions, g = e[e.length - 1], f = a._byClipCacheIndex;
    g._byClipCacheIndex = f;
    e[f] = g;
    e.pop();
    a._byClipCacheIndex = null;
    delete c.actionByRoot[(a._localRoot || this._root).uuid];
    0 === e.length && delete b[d];
    this._removeInactiveBindingsForAction(a);
  }, _removeInactiveBindingsForAction:function(a) {
    a = a._propertyBindings;
    for (var d = 0, b = a.length;d !== b;++d) {
      var c = a[d];
      0 === --c.referenceCount && this._removeInactiveBinding(c);
    }
  }, _lendAction:function(a) {
    var d = this._actions, b = a._cacheIndex, c = this._nActiveActions++, e = d[c];
    a._cacheIndex = c;
    d[c] = a;
    e._cacheIndex = b;
    d[b] = e;
  }, _takeBackAction:function(a) {
    var d = this._actions, b = a._cacheIndex, c = --this._nActiveActions, e = d[c];
    a._cacheIndex = c;
    d[c] = a;
    e._cacheIndex = b;
    d[b] = e;
  }, _addInactiveBinding:function(a, b, c) {
    var d = this._bindingsByRootAndName, e = d[b], g = this._bindings;
    void 0 === e && (e = {}, d[b] = e);
    e[c] = a;
    a._cacheIndex = g.length;
    g.push(a);
  }, _removeInactiveBinding:function(a) {
    var d = this._bindings, b = a.binding, c = b.rootNode.uuid, b = b.path, e = this._bindingsByRootAndName, g = e[c], f = d[d.length - 1];
    a = a._cacheIndex;
    f._cacheIndex = a;
    d[a] = f;
    d.pop();
    delete g[b];
    a: {
      for (var k in g) {
        break a;
      }
      delete e[c];
    }
  }, _lendBinding:function(a) {
    var d = this._bindings, b = a._cacheIndex, c = this._nActiveBindings++, e = d[c];
    a._cacheIndex = c;
    d[c] = a;
    e._cacheIndex = b;
    d[b] = e;
  }, _takeBackBinding:function(a) {
    var d = this._bindings, b = a._cacheIndex, c = --this._nActiveBindings, e = d[c];
    a._cacheIndex = c;
    d[c] = a;
    e._cacheIndex = b;
    d[b] = e;
  }, _lendControlInterpolant:function() {
    var a = this._controlInterpolants, b = this._nActiveControlInterpolants++, c = a[b];
    void 0 === c && (c = new id(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c);
    return c;
  }, _takeBackControlInterpolant:function(a) {
    var d = this._controlInterpolants, b = a.__cacheIndex, c = --this._nActiveControlInterpolants, e = d[c];
    a.__cacheIndex = c;
    d[c] = a;
    e.__cacheIndex = b;
    d[b] = e;
  }, _controlInterpolantsResultBuffer:new Float32Array(1), clipAction:function(a, b) {
    var d = b || this._root, c = d.uuid, e = "string" === typeof a ? cb.findByName(d, a) : a, d = null !== e ? e.uuid : a;
    a = this._actionsByClip[d];
    var g = null;
    if (void 0 !== a) {
      g = a.actionByRoot[c];
      if (void 0 !== g) {
        return g;
      }
      g = a.knownActions[0];
      null === e && (e = g._clip);
    }
    if (null === e) {
      return null;
    }
    e = new Pe(this, e, b);
    this._bindAction(e, g);
    this._addInactiveAction(e, d, c);
    return e;
  }, existingAction:function(a, b) {
    b = b || this._root;
    var d = b.uuid;
    b = "string" === typeof a ? cb.findByName(b, a) : a;
    b = this._actionsByClip[b ? b.uuid : a];
    return void 0 !== b ? b.actionByRoot[d] || null : null;
  }, stopAllAction:function() {
    for (var a = this._actions, b = this._nActiveActions, c = this._bindings, e = this._nActiveBindings, g = this._nActiveBindings = this._nActiveActions = 0;g !== b;++g) {
      a[g].reset();
    }
    for (g = 0;g !== e;++g) {
      c[g].useCount = 0;
    }
    return this;
  }, update:function(a) {
    a *= this.timeScale;
    for (var d = this._actions, b = this._nActiveActions, c = this.time += a, e = Math.sign(a), g = this._accuIndex ^= 1, f = 0;f !== b;++f) {
      var k = d[f];
      k.enabled && k._update(c, a, e, g);
    }
    a = this._bindings;
    d = this._nActiveBindings;
    for (f = 0;f !== d;++f) {
      a[f].apply(g);
    }
    return this;
  }, getRoot:function() {
    return this._root;
  }, uncacheClip:function(a) {
    var d = this._actions;
    a = a.uuid;
    var b = this._actionsByClip, c = b[a];
    if (void 0 !== c) {
      for (var c = c.knownActions, e = 0, g = c.length;e !== g;++e) {
        var f = c[e];
        this._deactivateAction(f);
        var k = f._cacheIndex, q = d[d.length - 1];
        f._cacheIndex = null;
        f._byClipCacheIndex = null;
        q._cacheIndex = k;
        d[k] = q;
        d.pop();
        this._removeInactiveBindingsForAction(f);
      }
      delete b[a];
    }
  }, uncacheRoot:function(a) {
    a = a.uuid;
    var d = this._actionsByClip, b;
    for (b in d) {
      var c = d[b].actionByRoot[a];
      void 0 !== c && (this._deactivateAction(c), this._removeInactiveAction(c));
    }
    b = this._bindingsByRootAndName[a];
    if (void 0 !== b) {
      for (var e in b) {
        a = b[e], a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
    }
  }, uncacheAction:function(a, b) {
    a = this.existingAction(a, b);
    null !== a && (this._deactivateAction(a), this._removeInactiveAction(a));
  }});
  Ud.prototype.clone = function() {
    return new Ud(void 0 === this.value.clone ? this.value : this.value.clone());
  };
  Xb.prototype = Object.create(da.prototype);
  Xb.prototype.constructor = Xb;
  Xb.prototype.isInstancedBufferGeometry = !0;
  Xb.prototype.addGroup = function(a, b, c) {
    this.groups.push({start:a, count:b, materialIndex:c});
  };
  Xb.prototype.copy = function(a) {
    var d = a.index;
    null !== d && this.setIndex(d.clone());
    var d = a.attributes, b;
    for (b in d) {
      this.addAttribute(b, d[b].clone());
    }
    a = a.groups;
    b = 0;
    for (d = a.length;b < d;b++) {
      var c = a[b];
      this.addGroup(c.start, c.count, c.materialIndex);
    }
    return this;
  };
  Object.defineProperties(se.prototype, {count:{get:function() {
    return this.data.count;
  }}, array:{get:function() {
    return this.data.array;
  }}});
  Object.assign(se.prototype, {isInterleavedBufferAttribute:!0, setX:function(a, b) {
    this.data.array[a * this.data.stride + this.offset] = b;
    return this;
  }, setY:function(a, b) {
    this.data.array[a * this.data.stride + this.offset + 1] = b;
    return this;
  }, setZ:function(a, b) {
    this.data.array[a * this.data.stride + this.offset + 2] = b;
    return this;
  }, setW:function(a, b) {
    this.data.array[a * this.data.stride + this.offset + 3] = b;
    return this;
  }, getX:function(a) {
    return this.data.array[a * this.data.stride + this.offset];
  }, getY:function(a) {
    return this.data.array[a * this.data.stride + this.offset + 1];
  }, getZ:function(a) {
    return this.data.array[a * this.data.stride + this.offset + 2];
  }, getW:function(a) {
    return this.data.array[a * this.data.stride + this.offset + 3];
  }, setXY:function(a, b, c) {
    a = a * this.data.stride + this.offset;
    this.data.array[a + 0] = b;
    this.data.array[a + 1] = c;
    return this;
  }, setXYZ:function(a, b, c, e) {
    a = a * this.data.stride + this.offset;
    this.data.array[a + 0] = b;
    this.data.array[a + 1] = c;
    this.data.array[a + 2] = e;
    return this;
  }, setXYZW:function(a, b, c, e, g) {
    a = a * this.data.stride + this.offset;
    this.data.array[a + 0] = b;
    this.data.array[a + 1] = c;
    this.data.array[a + 2] = e;
    this.data.array[a + 3] = g;
    return this;
  }});
  Object.defineProperty(Ac.prototype, "needsUpdate", {set:function(a) {
    !0 === a && this.version++;
  }});
  Object.assign(Ac.prototype, {isInterleavedBuffer:!0, setArray:function(a) {
    if (Array.isArray(a)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.count = void 0 !== a ? a.length / this.stride : 0;
    this.array = a;
  }, setDynamic:function(a) {
    this.dynamic = a;
    return this;
  }, copy:function(a) {
    this.array = new a.array.constructor(a.array);
    this.count = a.count;
    this.stride = a.stride;
    this.dynamic = a.dynamic;
    return this;
  }, copyAt:function(a, b, c) {
    a *= this.stride;
    c *= b.stride;
    for (var d = 0, e = this.stride;d < e;d++) {
      this.array[a + d] = b.array[c + d];
    }
    return this;
  }, set:function(a, b) {
    void 0 === b && (b = 0);
    this.array.set(a, b);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, onUpload:function(a) {
    this.onUploadCallback = a;
    return this;
  }});
  Bc.prototype = Object.create(Ac.prototype);
  Bc.prototype.constructor = Bc;
  Bc.prototype.isInstancedInterleavedBuffer = !0;
  Bc.prototype.copy = function(a) {
    Ac.prototype.copy.call(this, a);
    this.meshPerAttribute = a.meshPerAttribute;
    return this;
  };
  Cc.prototype = Object.create(ja.prototype);
  Cc.prototype.constructor = Cc;
  Cc.prototype.isInstancedBufferAttribute = !0;
  Cc.prototype.copy = function(a) {
    ja.prototype.copy.call(this, a);
    this.meshPerAttribute = a.meshPerAttribute;
    return this;
  };
  Object.assign(Re.prototype, {linePrecision:1, set:function(a, b) {
    this.ray.set(a, b);
  }, setFromCamera:function(a, b) {
    b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize()) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
  }, intersectObject:function(a, b) {
    var d = [];
    te(a, this, d, b);
    d.sort(Se);
    return d;
  }, intersectObjects:function(a, b) {
    var d = [];
    if (!1 === Array.isArray(a)) {
      return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), d;
    }
    for (var c = 0, e = a.length;c < e;c++) {
      te(a[c], this, d, b);
    }
    d.sort(Se);
    return d;
  }});
  Object.assign(Te.prototype, {start:function() {
    this.oldTime = this.startTime = ("undefined" === typeof performance ? Date : performance).now();
    this.elapsedTime = 0;
    this.running = !0;
  }, stop:function() {
    this.getElapsedTime();
    this.running = !1;
  }, getElapsedTime:function() {
    this.getDelta();
    return this.elapsedTime;
  }, getDelta:function() {
    var a = 0;
    this.autoStart && !this.running && this.start();
    if (this.running) {
      var b = ("undefined" === typeof performance ? Date : performance).now(), a = (b - this.oldTime) / 1E3;
      this.oldTime = b;
      this.elapsedTime += a;
    }
    return a;
  }});
  Object.assign(Ue.prototype, {set:function(a, b, c) {
    this.radius = a;
    this.phi = b;
    this.theta = c;
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.radius = a.radius;
    this.phi = a.phi;
    this.theta = a.theta;
    return this;
  }, makeSafe:function() {
    this.phi = Math.max(1E-6, Math.min(Math.PI - 1E-6, this.phi));
    return this;
  }, setFromVector3:function(a) {
    this.radius = a.length();
    0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a.x, a.z), this.phi = Math.acos(ka.clamp(a.y / this.radius, -1, 1)));
    return this;
  }});
  Object.assign(Ve.prototype, {set:function(a, b, c) {
    this.radius = a;
    this.theta = b;
    this.y = c;
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.radius = a.radius;
    this.theta = a.theta;
    this.y = a.y;
    return this;
  }, setFromVector3:function(a) {
    this.radius = Math.sqrt(a.x * a.x + a.z * a.z);
    this.theta = Math.atan2(a.x, a.z);
    this.y = a.y;
    return this;
  }});
  Ha.prototype = Object.create(Ga.prototype);
  Ha.prototype.constructor = Ha;
  Ha.prototype.createAnimation = function(a, b, c, e) {
    b = {start:b, end:c, length:c - b + 1, fps:e, duration:(c - b) / e, lastFrame:0, currentFrame:0, active:!1, time:0, direction:1, weight:1, directionBackwards:!1, mirroredLoop:!1};
    this.animationsMap[a] = b;
    this.animationsList.push(b);
  };
  Ha.prototype.autoCreateAnimations = function(a) {
    for (var d = /([a-z]+)_?(\d+)/i, b, c = {}, e = this.geometry, g = 0, f = e.morphTargets.length;g < f;g++) {
      var k = e.morphTargets[g].name.match(d);
      if (k && 1 < k.length) {
        var q = k[1];
        c[q] || (c[q] = {start:Infinity, end:-Infinity});
        k = c[q];
        g < k.start && (k.start = g);
        g > k.end && (k.end = g);
        b || (b = q);
      }
    }
    for (q in c) {
      k = c[q], this.createAnimation(q, k.start, k.end, a);
    }
    this.firstAnimation = b;
  };
  Ha.prototype.setAnimationDirectionForward = function(a) {
    if (a = this.animationsMap[a]) {
      a.direction = 1, a.directionBackwards = !1;
    }
  };
  Ha.prototype.setAnimationDirectionBackward = function(a) {
    if (a = this.animationsMap[a]) {
      a.direction = -1, a.directionBackwards = !0;
    }
  };
  Ha.prototype.setAnimationFPS = function(a, b) {
    (a = this.animationsMap[a]) && (a.fps = b, a.duration = (a.end - a.start) / a.fps);
  };
  Ha.prototype.setAnimationDuration = function(a, b) {
    (a = this.animationsMap[a]) && (a.duration = b, a.fps = (a.end - a.start) / a.duration);
  };
  Ha.prototype.setAnimationWeight = function(a, b) {
    (a = this.animationsMap[a]) && (a.weight = b);
  };
  Ha.prototype.setAnimationTime = function(a, b) {
    (a = this.animationsMap[a]) && (a.time = b);
  };
  Ha.prototype.getAnimationTime = function(a) {
    var d = 0;
    if (a = this.animationsMap[a]) {
      d = a.time;
    }
    return d;
  };
  Ha.prototype.getAnimationDuration = function(a) {
    var d = -1;
    if (a = this.animationsMap[a]) {
      d = a.duration;
    }
    return d;
  };
  Ha.prototype.playAnimation = function(a) {
    var d = this.animationsMap[a];
    d ? (d.time = 0, d.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + a + "] undefined in .playAnimation()");
  };
  Ha.prototype.stopAnimation = function(a) {
    if (a = this.animationsMap[a]) {
      a.active = !1;
    }
  };
  Ha.prototype.update = function(a) {
    for (var d = 0, b = this.animationsList.length;d < b;d++) {
      var c = this.animationsList[d];
      if (c.active) {
        var e = c.duration / c.length;
        c.time += c.direction * a;
        if (c.mirroredLoop) {
          if (c.time > c.duration || 0 > c.time) {
            c.direction *= -1, c.time > c.duration && (c.time = c.duration, c.directionBackwards = !0), 0 > c.time && (c.time = 0, c.directionBackwards = !1);
          }
        } else {
          c.time %= c.duration, 0 > c.time && (c.time += c.duration);
        }
        var g = c.start + ka.clamp(Math.floor(c.time / e), 0, c.length - 1), f = c.weight;
        g !== c.currentFrame && (this.morphTargetInfluences[c.lastFrame] = 0, this.morphTargetInfluences[c.currentFrame] = 1 * f, this.morphTargetInfluences[g] = 0, c.lastFrame = c.currentFrame, c.currentFrame = g);
        e = c.time % e / e;
        c.directionBackwards && (e = 1 - e);
        c.currentFrame !== c.lastFrame ? (this.morphTargetInfluences[c.currentFrame] = e * f, this.morphTargetInfluences[c.lastFrame] = (1 - e) * f) : this.morphTargetInfluences[c.currentFrame] = f;
      }
    }
  };
  md.prototype = Object.create(U.prototype);
  md.prototype.constructor = md;
  md.prototype.isImmediateRenderObject = !0;
  nd.prototype = Object.create(ua.prototype);
  nd.prototype.constructor = nd;
  nd.prototype.update = function() {
    var a = new e, b = new e, c = new ya;
    return function() {
      var d = ["a", "b", "c"];
      this.object.updateMatrixWorld(!0);
      c.getNormalMatrix(this.object.matrixWorld);
      var e = this.object.matrixWorld, g = this.geometry.attributes.position, f = this.object.geometry;
      if (f && f.isGeometry) {
        for (var k = f.vertices, q = f.faces, p = f = 0, h = q.length;p < h;p++) {
          for (var m = q[p], n = 0, r = m.vertexNormals.length;n < r;n++) {
            var l = m.vertexNormals[n];
            a.copy(k[m[d[n]]]).applyMatrix4(e);
            b.copy(l).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
            g.setXYZ(f, a.x, a.y, a.z);
            f += 1;
            g.setXYZ(f, b.x, b.y, b.z);
            f += 1;
          }
        }
      } else {
        if (f && f.isBufferGeometry) {
          for (d = f.attributes.position, k = f.attributes.normal, n = f = 0, r = d.count;n < r;n++) {
            a.set(d.getX(n), d.getY(n), d.getZ(n)).applyMatrix4(e), b.set(k.getX(n), k.getY(n), k.getZ(n)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), g.setXYZ(f, a.x, a.y, a.z), f += 1, g.setXYZ(f, b.x, b.y, b.z), f += 1;
          }
        }
      }
      g.needsUpdate = !0;
      return this;
    };
  }();
  Dc.prototype = Object.create(U.prototype);
  Dc.prototype.constructor = Dc;
  Dc.prototype.dispose = function() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  };
  Dc.prototype.update = function() {
    var a = new e, b = new e;
    return function() {
      var d = this.light.distance ? this.light.distance : 1E3, c = d * Math.tan(this.light.angle);
      this.cone.scale.set(c, c, d);
      a.setFromMatrixPosition(this.light.matrixWorld);
      b.setFromMatrixPosition(this.light.target.matrixWorld);
      this.cone.lookAt(b.sub(a));
      this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    };
  }();
  Ec.prototype = Object.create(ua.prototype);
  Ec.prototype.constructor = Ec;
  Ec.prototype.getBoneList = function(a) {
    var d = [];
    a && a.isBone && d.push(a);
    for (var b = 0;b < a.children.length;b++) {
      d.push.apply(d, this.getBoneList(a.children[b]));
    }
    return d;
  };
  Ec.prototype.update = function() {
    var a = new e, b = new p, c = new p;
    return function() {
      var d = this.geometry, e = d.getAttribute("position");
      c.getInverse(this.root.matrixWorld);
      for (var g = 0, f = 0;g < this.bones.length;g++) {
        var k = this.bones[g];
        k.parent && k.parent.isBone && (b.multiplyMatrices(c, k.matrixWorld), a.setFromMatrixPosition(b), e.setXYZ(f, a.x, a.y, a.z), b.multiplyMatrices(c, k.parent.matrixWorld), a.setFromMatrixPosition(b), e.setXYZ(f + 1, a.x, a.y, a.z), f += 2);
      }
      d.getAttribute("position").needsUpdate = !0;
    };
  }();
  Fc.prototype = Object.create(Ga.prototype);
  Fc.prototype.constructor = Fc;
  Fc.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
  };
  Fc.prototype.update = function() {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  };
  Gc.prototype = Object.create(U.prototype);
  Gc.prototype.constructor = Gc;
  Gc.prototype.dispose = function() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
    this.children[1].geometry.dispose();
    this.children[1].material.dispose();
  };
  Gc.prototype.update = function() {
    var a = new e, b = new e;
    return function() {
      var d = this.children[0], c = this.children[1];
      if (this.light.target) {
        a.setFromMatrixPosition(this.light.matrixWorld);
        b.setFromMatrixPosition(this.light.target.matrixWorld);
        var e = b.clone().sub(a);
        d.lookAt(e);
        c.lookAt(e);
      }
      d.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      c.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      var c = .5 * this.light.width, e = .5 * this.light.height, d = d.geometry.getAttribute("position"), g = d.array;
      g[0] = c;
      g[1] = -e;
      g[2] = 0;
      g[3] = c;
      g[4] = e;
      g[5] = 0;
      g[6] = -c;
      g[7] = e;
      g[8] = 0;
      g[9] = -c;
      g[10] = e;
      g[11] = 0;
      g[12] = -c;
      g[13] = -e;
      g[14] = 0;
      g[15] = c;
      g[16] = -e;
      g[17] = 0;
      d.needsUpdate = !0;
    };
  }();
  Hc.prototype = Object.create(U.prototype);
  Hc.prototype.constructor = Hc;
  Hc.prototype.dispose = function() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  };
  Hc.prototype.update = function() {
    var a = new e, b = new T, c = new T;
    return function() {
      var d = this.children[0], e = d.geometry.getAttribute("color");
      b.copy(this.light.color).multiplyScalar(this.light.intensity);
      c.copy(this.light.groundColor).multiplyScalar(this.light.intensity);
      for (var g = 0, f = e.count;g < f;g++) {
        var k = g < f / 2 ? b : c;
        e.setXYZ(g, k.r, k.g, k.b);
      }
      d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
      e.needsUpdate = !0;
    };
  }();
  od.prototype = Object.create(ua.prototype);
  od.prototype.constructor = od;
  Vd.prototype = Object.create(ua.prototype);
  Vd.prototype.constructor = Vd;
  pd.prototype = Object.create(ua.prototype);
  pd.prototype.constructor = pd;
  pd.prototype.update = function() {
    var a = new e, b = new e, c = new ya;
    return function() {
      this.object.updateMatrixWorld(!0);
      c.getNormalMatrix(this.object.matrixWorld);
      for (var d = this.object.matrixWorld, e = this.geometry.attributes.position, g = this.object.geometry, f = g.vertices, g = g.faces, k = 0, q = 0, p = g.length;q < p;q++) {
        var h = g[q], m = h.normal;
        a.copy(f[h.a]).add(f[h.b]).add(f[h.c]).divideScalar(3).applyMatrix4(d);
        b.copy(m).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
        e.setXYZ(k, a.x, a.y, a.z);
        k += 1;
        e.setXYZ(k, b.x, b.y, b.z);
        k += 1;
      }
      e.needsUpdate = !0;
      return this;
    };
  }();
  Ic.prototype = Object.create(U.prototype);
  Ic.prototype.constructor = Ic;
  Ic.prototype.dispose = function() {
    var a = this.children[0], b = this.children[1];
    a.geometry.dispose();
    a.material.dispose();
    b.geometry.dispose();
    b.material.dispose();
  };
  Ic.prototype.update = function() {
    var a = new e, b = new e, c = new e;
    return function() {
      a.setFromMatrixPosition(this.light.matrixWorld);
      b.setFromMatrixPosition(this.light.target.matrixWorld);
      c.subVectors(b, a);
      var d = this.children[0], e = this.children[1];
      d.lookAt(c);
      d.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      e.lookAt(c);
      e.scale.z = c.length();
    };
  }();
  qd.prototype = Object.create(ua.prototype);
  qd.prototype.constructor = qd;
  qd.prototype.update = function() {
    function a(a, d, e, k) {
      g.set(d, e, k).unproject(f);
      a = c[a];
      if (void 0 !== a) {
        for (d = b.getAttribute("position"), e = 0, k = a.length;e < k;e++) {
          d.setXYZ(a[e], g.x, g.y, g.z);
        }
      }
    }
    var b, c, g = new e, f = new Ja;
    return function() {
      b = this.geometry;
      c = this.pointMap;
      f.projectionMatrix.copy(this.camera.projectionMatrix);
      a("c", 0, 0, -1);
      a("t", 0, 0, 1);
      a("n1", -1, -1, -1);
      a("n2", 1, -1, -1);
      a("n3", -1, 1, -1);
      a("n4", 1, 1, -1);
      a("f1", -1, -1, 1);
      a("f2", 1, -1, 1);
      a("f3", -1, 1, 1);
      a("f4", 1, 1, 1);
      a("u1", .7, 1.1, -1);
      a("u2", -.7, 1.1, -1);
      a("u3", 0, 2, -1);
      a("cf1", -1, 0, 1);
      a("cf2", 1, 0, 1);
      a("cf3", 0, -1, 1);
      a("cf4", 0, 1, 1);
      a("cn1", -1, 0, -1);
      a("cn2", 1, 0, -1);
      a("cn3", 0, -1, -1);
      a("cn4", 0, 1, -1);
      b.getAttribute("position").needsUpdate = !0;
    };
  }();
  Jc.prototype = Object.create(ua.prototype);
  Jc.prototype.constructor = Jc;
  Jc.prototype.update = function() {
    var a = new Aa;
    return function(d) {
      d && d.isBox3 ? a.copy(d) : a.setFromObject(d);
      if (!a.isEmpty()) {
        d = a.min;
        var b = a.max, c = this.geometry.attributes.position, e = c.array;
        e[0] = b.x;
        e[1] = b.y;
        e[2] = b.z;
        e[3] = d.x;
        e[4] = b.y;
        e[5] = b.z;
        e[6] = d.x;
        e[7] = d.y;
        e[8] = b.z;
        e[9] = b.x;
        e[10] = d.y;
        e[11] = b.z;
        e[12] = b.x;
        e[13] = b.y;
        e[14] = d.z;
        e[15] = d.x;
        e[16] = b.y;
        e[17] = d.z;
        e[18] = d.x;
        e[19] = d.y;
        e[20] = d.z;
        e[21] = b.x;
        e[22] = d.y;
        e[23] = d.z;
        c.needsUpdate = !0;
        this.geometry.computeBoundingSphere();
      }
    };
  }();
  var Wd, ue;
  Yb.prototype = Object.create(U.prototype);
  Yb.prototype.constructor = Yb;
  Yb.prototype.setDirection = function() {
    var a = new e, b;
    return function(d) {
      .99999 < d.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > d.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(d.z, 0, -d.x).normalize(), b = Math.acos(d.y), this.quaternion.setFromAxisAngle(a, b));
    };
  }();
  Yb.prototype.setLength = function(a, b, c) {
    void 0 === b && (b = .2 * a);
    void 0 === c && (c = .2 * b);
    this.line.scale.set(1, Math.max(0, a - b), 1);
    this.line.updateMatrix();
    this.cone.scale.set(c, b, c);
    this.cone.position.y = a;
    this.cone.updateMatrix();
  };
  Yb.prototype.setColor = function(a) {
    this.line.material.color.copy(a);
    this.cone.material.color.copy(a);
  };
  Xd.prototype = Object.create(ua.prototype);
  Xd.prototype.constructor = Xd;
  var $d = new e, ye = new ve, ze = new ve, Ae = new ve;
  ib.prototype = Object.create(Ra.prototype);
  ib.prototype.constructor = ib;
  ib.prototype.getPoint = function(a) {
    var d = this.points, b = d.length;
    2 > b && console.log("duh, you need at least 2 points");
    a *= b - (this.closed ? 0 : 1);
    var c = Math.floor(a);
    a -= c;
    this.closed ? c += 0 < c ? 0 : (Math.floor(Math.abs(c) / d.length) + 1) * d.length : 0 === a && c === b - 1 && (c = b - 2, a = 1);
    var g, f, k;
    this.closed || 0 < c ? g = d[(c - 1) % b] : ($d.subVectors(d[0], d[1]).add(d[0]), g = $d);
    f = d[c % b];
    k = d[(c + 1) % b];
    this.closed || c + 2 < b ? d = d[(c + 2) % b] : ($d.subVectors(d[b - 1], d[b - 2]).add(d[b - 1]), d = $d);
    if (void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
      var q = "chordal" === this.type ? .5 : .25, b = Math.pow(g.distanceToSquared(f), q), c = Math.pow(f.distanceToSquared(k), q), q = Math.pow(k.distanceToSquared(d), q);
      1E-4 > c && (c = 1);
      1E-4 > b && (b = c);
      1E-4 > q && (q = c);
      ye.initNonuniformCatmullRom(g.x, f.x, k.x, d.x, b, c, q);
      ze.initNonuniformCatmullRom(g.y, f.y, k.y, d.y, b, c, q);
      Ae.initNonuniformCatmullRom(g.z, f.z, k.z, d.z, b, c, q);
    } else {
      "catmullrom" === this.type && (b = void 0 !== this.tension ? this.tension : .5, ye.initCatmullRom(g.x, f.x, k.x, d.x, b), ze.initCatmullRom(g.y, f.y, k.y, d.y, b), Ae.initCatmullRom(g.z, f.z, k.z, d.z, b));
    }
    return new e(ye.calc(a), ze.calc(a), Ae.calc(a));
  };
  rd.prototype = Object.create(Ra.prototype);
  rd.prototype.constructor = rd;
  rd.prototype.getPoint = function(a) {
    var d = this.v0, b = this.v1, c = this.v2, g = this.v3;
    return new e(Ub(a, d.x, b.x, c.x, g.x), Ub(a, d.y, b.y, c.y, g.y), Ub(a, d.z, b.z, c.z, g.z));
  };
  sd.prototype = Object.create(Ra.prototype);
  sd.prototype.constructor = sd;
  sd.prototype.getPoint = function(a) {
    var d = this.v0, b = this.v1, c = this.v2;
    return new e(Tb(a, d.x, b.x, c.x), Tb(a, d.y, b.y, c.y), Tb(a, d.z, b.z, c.z));
  };
  td.prototype = Object.create(Ra.prototype);
  td.prototype.constructor = td;
  td.prototype.getPoint = function(a) {
    if (1 === a) {
      return this.v2.clone();
    }
    var d = new e;
    d.subVectors(this.v2, this.v1);
    d.multiplyScalar(a);
    d.add(this.v1);
    return d;
  };
  Yd.prototype = Object.create(xb.prototype);
  Yd.prototype.constructor = Yd;
  Ra.create = function(a, b) {
    console.log("THREE.Curve.create() has been deprecated");
    a.prototype = Object.create(Ra.prototype);
    a.prototype.constructor = a;
    a.prototype.getPoint = b;
    return a;
  };
  We.prototype = Object.create(ib.prototype);
  Xe.prototype = Object.create(ib.prototype);
  we.prototype = Object.create(ib.prototype);
  Object.assign(we.prototype, {initFromArray:function(a) {
    console.error("THREE.Spline: .initFromArray() has been removed.");
  }, getControlPointsArray:function(a) {
    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
  }, reparametrizeByArcLength:function(a) {
    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
  }});
  od.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  };
  Object.assign(qa.prototype, {center:function(a) {
    console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
    return this.getCenter(a);
  }, empty:function() {
    console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  }, isIntersectionBox:function(a) {
    console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(a);
  }, size:function(a) {
    console.warn("THREE.Box2: .size() has been renamed to .getSize().");
    return this.getSize(a);
  }});
  Object.assign(Aa.prototype, {center:function(a) {
    console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
    return this.getCenter(a);
  }, empty:function() {
    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  }, isIntersectionBox:function(a) {
    console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(a);
  }, isIntersectionSphere:function(a) {
    console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(a);
  }, size:function(a) {
    console.warn("THREE.Box3: .size() has been renamed to .getSize().");
    return this.getSize(a);
  }});
  Ab.prototype.center = function(a) {
    console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
    return this.getCenter(a);
  };
  ka.random16 = function() {
    console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead.");
    return Math.random();
  };
  Object.assign(ya.prototype, {flattenToArrayOffset:function(a, b) {
    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(a, b);
  }, multiplyVector3:function(a) {
    console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
    return a.applyMatrix3(this);
  }, multiplyVector3Array:function(a) {
    console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
    return this.applyToVector3Array(a);
  }, applyToBuffer:function(a, b, c) {
    console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
    return this.applyToBufferAttribute(a);
  }, applyToVector3Array:function(a, b, c) {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }});
  Object.assign(p.prototype, {extractPosition:function(a) {
    console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
    return this.copyPosition(a);
  }, flattenToArrayOffset:function(a, b) {
    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(a, b);
  }, getPosition:function() {
    var a;
    return function() {
      void 0 === a && (a = new e);
      console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
      return a.setFromMatrixColumn(this, 3);
    };
  }(), setRotationFromQuaternion:function(a) {
    console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
    return this.makeRotationFromQuaternion(a);
  }, multiplyToArray:function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  }, multiplyVector3:function(a) {
    console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return a.applyMatrix4(this);
  }, multiplyVector4:function(a) {
    console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return a.applyMatrix4(this);
  }, multiplyVector3Array:function(a) {
    console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
    return this.applyToVector3Array(a);
  }, rotateAxis:function(a) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
    a.transformDirection(this);
  }, crossVector:function(a) {
    console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return a.applyMatrix4(this);
  }, translate:function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  }, rotateX:function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  }, rotateY:function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  }, rotateZ:function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  }, rotateByAxis:function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  }, applyToBuffer:function(a, b, c) {
    console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
    return this.applyToBufferAttribute(a);
  }, applyToVector3Array:function(a, b, c) {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  }, makeFrustum:function(a, b, c, e, g, f) {
    console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
    return this.makePerspective(a, b, e, c, g, f);
  }});
  Ea.prototype.isIntersectionLine = function(a) {
    console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
    return this.intersectsLine(a);
  };
  g.prototype.multiplyVector3 = function(a) {
    console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
    return a.applyQuaternion(this);
  };
  Object.assign(Ta.prototype, {isIntersectionBox:function(a) {
    console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(a);
  }, isIntersectionPlane:function(a) {
    console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
    return this.intersectsPlane(a);
  }, isIntersectionSphere:function(a) {
    console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(a);
  }});
  Object.assign(Wb.prototype, {extrude:function(a) {
    console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
    return new bb(this, a);
  }, makeGeometry:function(a) {
    console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
    return new oc(this, a);
  }});
  Object.assign(l.prototype, {fromAttribute:function(a, b, c) {
    console.error("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(a, b, c);
  }});
  Object.assign(e.prototype, {setEulerFromRotationMatrix:function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  }, setEulerFromQuaternion:function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  }, getPositionFromMatrix:function(a) {
    console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
    return this.setFromMatrixPosition(a);
  }, getScaleFromMatrix:function(a) {
    console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
    return this.setFromMatrixScale(a);
  }, getColumnFromMatrix:function(a, b) {
    console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
    return this.setFromMatrixColumn(b, a);
  }, applyProjection:function(a) {
    console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
    return this.applyMatrix4(a);
  }, fromAttribute:function(a, b, c) {
    console.error("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(a, b, c);
  }});
  Object.assign(f.prototype, {fromAttribute:function(a, b, c) {
    console.error("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(a, b, c);
  }});
  ca.prototype.computeTangents = function() {
    console.warn("THREE.Geometry: .computeTangents() has been removed.");
  };
  Object.assign(U.prototype, {getChildByName:function(a) {
    console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
    return this.getObjectByName(a);
  }, renderDepth:function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  }, translate:function(a, b) {
    console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
    return this.translateOnAxis(b, a);
  }});
  Object.defineProperties(U.prototype, {eulerOrder:{get:function() {
    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
    return this.rotation.order;
  }, set:function(a) {
    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
    this.rotation.order = a;
  }}, useQuaternion:{get:function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  }, set:function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  }}});
  Object.defineProperties(Oc.prototype, {objects:{get:function() {
    console.warn("THREE.LOD: .objects has been renamed to .levels.");
    return this.levels;
  }}});
  Object.defineProperty(Pc.prototype, "useVertexTexture", {get:function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }, set:function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }});
  Oa.prototype.setLens = function(a, b) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    void 0 !== b && (this.filmGauge = b);
    this.setFocalLength(a);
  };
  Object.defineProperties(Ca.prototype, {onlyShadow:{set:function() {
    console.warn("THREE.Light: .onlyShadow has been removed.");
  }}, shadowCameraFov:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
    this.shadow.camera.fov = a;
  }}, shadowCameraLeft:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
    this.shadow.camera.left = a;
  }}, shadowCameraRight:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
    this.shadow.camera.right = a;
  }}, shadowCameraTop:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
    this.shadow.camera.top = a;
  }}, shadowCameraBottom:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
    this.shadow.camera.bottom = a;
  }}, shadowCameraNear:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
    this.shadow.camera.near = a;
  }}, shadowCameraFar:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
    this.shadow.camera.far = a;
  }}, shadowCameraVisible:{set:function() {
    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
  }}, shadowBias:{set:function(a) {
    console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
    this.shadow.bias = a;
  }}, shadowDarkness:{set:function() {
    console.warn("THREE.Light: .shadowDarkness has been removed.");
  }}, shadowMapWidth:{set:function(a) {
    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
    this.shadow.mapSize.width = a;
  }}, shadowMapHeight:{set:function(a) {
    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
    this.shadow.mapSize.height = a;
  }}});
  Object.defineProperties(ja.prototype, {length:{get:function() {
    console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
    return this.array.length;
  }}});
  Object.assign(da.prototype, {addIndex:function(a) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
    this.setIndex(a);
  }, addDrawCall:function(a, b, c) {
    void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
    this.addGroup(a, b);
  }, clearDrawCalls:function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
    this.clearGroups();
  }, computeTangents:function() {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  }, computeOffsets:function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  }});
  Object.defineProperties(da.prototype, {drawcalls:{get:function() {
    console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
    return this.groups;
  }}, offsets:{get:function() {
    console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
    return this.groups;
  }}});
  Object.defineProperties(Ud.prototype, {dynamic:{set:function() {
    console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
  }}, onUpdate:{value:function() {
    console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
    return this;
  }}});
  Object.defineProperties(W.prototype, {skinning:{get:function() {
    console.warn("THREE.Material: .skinning has been removed.");
  }, set:function() {
    console.warn("THREE.Material: .skinning has been removed.");
  }}, wrapAround:{get:function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  }, set:function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  }}, wrapRGB:{get:function() {
    console.warn("THREE.Material: .wrapRGB has been removed.");
    return new T;
  }}});
  Object.defineProperties(gb.prototype, {metal:{get:function() {
    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
    return !1;
  }, set:function() {
    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
  }}});
  Object.defineProperties(sa.prototype, {derivatives:{get:function() {
    console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
    return this.extensions.derivatives;
  }, set:function(a) {
    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
    this.extensions.derivatives = a;
  }}});
  Object.assign(de.prototype, {supportsFloatTextures:function() {
    console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
    return this.extensions.get("OES_texture_float");
  }, supportsHalfFloatTextures:function() {
    console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
    return this.extensions.get("OES_texture_half_float");
  }, supportsStandardDerivatives:function() {
    console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
    return this.extensions.get("OES_standard_derivatives");
  }, supportsCompressedTextureS3TC:function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
    return this.extensions.get("WEBGL_compressed_texture_s3tc");
  }, supportsCompressedTexturePVRTC:function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
    return this.extensions.get("WEBGL_compressed_texture_pvrtc");
  }, supportsBlendMinMax:function() {
    console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
    return this.extensions.get("EXT_blend_minmax");
  }, supportsVertexTextures:function() {
    console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
    return this.capabilities.vertexTextures;
  }, supportsInstancedArrays:function() {
    console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
    return this.extensions.get("ANGLE_instanced_arrays");
  }, enableScissorTest:function(a) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
    this.setScissorTest(a);
  }, initMaterial:function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  }, addPrePlugin:function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  }, addPostPlugin:function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  }, updateShadowMap:function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  }});
  Object.defineProperties(de.prototype, {shadowMapEnabled:{get:function() {
    return this.shadowMap.enabled;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
    this.shadowMap.enabled = a;
  }}, shadowMapType:{get:function() {
    return this.shadowMap.type;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
    this.shadowMap.type = a;
  }}, shadowMapCullFace:{get:function() {
    return this.shadowMap.cullFace;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.");
    this.shadowMap.cullFace = a;
  }}});
  Object.defineProperties(vd.prototype, {cullFace:{get:function() {
    return this.renderReverseSided ? 2 : 1;
  }, set:function(a) {
    a = 1 !== a;
    console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + a + ".");
    this.renderReverseSided = a;
  }}});
  Object.defineProperties(k.prototype, {wrapS:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
    return this.texture.wrapS;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
    this.texture.wrapS = a;
  }}, wrapT:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
    return this.texture.wrapT;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
    this.texture.wrapT = a;
  }}, magFilter:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
    return this.texture.magFilter;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
    this.texture.magFilter = a;
  }}, minFilter:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
    return this.texture.minFilter;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
    this.texture.minFilter = a;
  }}, anisotropy:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
    return this.texture.anisotropy;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
    this.texture.anisotropy = a;
  }}, offset:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
    return this.texture.offset;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
    this.texture.offset = a;
  }}, repeat:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
    return this.texture.repeat;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
    this.texture.repeat = a;
  }}, format:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
    return this.texture.format;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
    this.texture.format = a;
  }}, type:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
    return this.texture.type;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
    this.texture.type = a;
  }}, generateMipmaps:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
    return this.texture.generateMipmaps;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
    this.texture.generateMipmaps = a;
  }}});
  zc.prototype.load = function(a) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    var d = this;
    (new me).load(a, function(a) {
      d.setBuffer(a);
    });
    return this;
  };
  qe.prototype.getData = function() {
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
    return this.getFrequencyData();
  };
  a.WebGLRenderTargetCube = c;
  a.WebGLRenderTarget = k;
  a.WebGLRenderer = de;
  a.ShaderLib = zb;
  a.UniformsLib = ga;
  a.UniformsUtils = Sa;
  a.ShaderChunk = na;
  a.FogExp2 = ac;
  a.Fog = bc;
  a.Scene = xd;
  a.LensFlare = ee;
  a.Sprite = Nc;
  a.LOD = Oc;
  a.SkinnedMesh = zd;
  a.Skeleton = Pc;
  a.Bone = yd;
  a.Mesh = Ga;
  a.LineSegments = ua;
  a.LineLoop = Ad;
  a.Line = db;
  a.Points = cc;
  a.Group = Qc;
  a.VideoTexture = Bd;
  a.DataTexture = ra;
  a.CompressedTexture = dc;
  a.CubeTexture = r;
  a.CanvasTexture = Cd;
  a.DepthTexture = Rc;
  a.Texture = b;
  a.CompressedTextureLoader = Ie;
  a.DataTextureLoader = ge;
  a.CubeTextureLoader = he;
  a.TextureLoader = Dd;
  a.ObjectLoader = Je;
  a.MaterialLoader = Sd;
  a.BufferGeometryLoader = ie;
  a.DefaultLoadingManager = Ya;
  a.LoadingManager = fe;
  a.JSONLoader = je;
  a.ImageLoader = hd;
  a.FontLoader = Le;
  a.FileLoader = hb;
  a.Loader = wc;
  a.Cache = ud;
  a.AudioLoader = me;
  a.SpotLightShadow = Fd;
  a.SpotLight = Gd;
  a.PointLight = Hd;
  a.RectAreaLight = Ld;
  a.HemisphereLight = Ed;
  a.DirectionalLightShadow = Id;
  a.DirectionalLight = Jd;
  a.AmbientLight = Kd;
  a.LightShadow = Qb;
  a.Light = Ca;
  a.StereoCamera = Me;
  a.PerspectiveCamera = Oa;
  a.OrthographicCamera = Zb;
  a.CubeCamera = Td;
  a.Camera = Ja;
  a.AudioListener = ne;
  a.PositionalAudio = pe;
  a.AudioContext = oe;
  a.AudioAnalyser = qe;
  a.Audio = zc;
  a.VectorKeyframeTrack = uc;
  a.StringKeyframeTrack = Pd;
  a.QuaternionKeyframeTrack = jd;
  a.NumberKeyframeTrack = vc;
  a.ColorKeyframeTrack = Rd;
  a.BooleanKeyframeTrack = Qd;
  a.PropertyMixer = re;
  a.PropertyBinding = Da;
  a.KeyframeTrack = Sb;
  a.AnimationUtils = Fa;
  a.AnimationObjectGroup = Oe;
  a.AnimationMixer = Qe;
  a.AnimationClip = cb;
  a.Uniform = Ud;
  a.InstancedBufferGeometry = Xb;
  a.BufferGeometry = da;
  a.GeometryIdCount = function() {
    return be++;
  };
  a.Geometry = ca;
  a.InterleavedBufferAttribute = se;
  a.InstancedInterleavedBuffer = Bc;
  a.InterleavedBuffer = Ac;
  a.InstancedBufferAttribute = Cc;
  a.Face3 = za;
  a.Object3D = U;
  a.Raycaster = Re;
  a.Layers = Kc;
  a.EventDispatcher = h;
  a.Clock = Te;
  a.QuaternionLinearInterpolant = Od;
  a.LinearInterpolant = id;
  a.DiscreteInterpolant = Nd;
  a.CubicInterpolant = Md;
  a.Interpolant = Za;
  a.Triangle = Ia;
  a.Math = ka;
  a.Spherical = Ue;
  a.Cylindrical = Ve;
  a.Plane = Ea;
  a.Frustum = Xa;
  a.Sphere = Ba;
  a.Ray = Ta;
  a.Matrix4 = p;
  a.Matrix3 = ya;
  a.Box3 = Aa;
  a.Box2 = qa;
  a.Line3 = Ab;
  a.Euler = Ua;
  a.Vector4 = f;
  a.Vector3 = e;
  a.Vector2 = l;
  a.Quaternion = g;
  a.Color = T;
  a.MorphBlendMesh = Ha;
  a.ImmediateRenderObject = md;
  a.VertexNormalsHelper = nd;
  a.SpotLightHelper = Dc;
  a.SkeletonHelper = Ec;
  a.PointLightHelper = Fc;
  a.RectAreaLightHelper = Gc;
  a.HemisphereLightHelper = Hc;
  a.GridHelper = od;
  a.PolarGridHelper = Vd;
  a.FaceNormalsHelper = pd;
  a.DirectionalLightHelper = Ic;
  a.CameraHelper = qd;
  a.BoxHelper = Jc;
  a.ArrowHelper = Yb;
  a.AxisHelper = Xd;
  a.CatmullRomCurve3 = ib;
  a.CubicBezierCurve3 = rd;
  a.QuadraticBezierCurve3 = sd;
  a.LineCurve3 = td;
  a.ArcCurve = Yd;
  a.EllipseCurve = xb;
  a.SplineCurve = Vb;
  a.CubicBezierCurve = xc;
  a.QuadraticBezierCurve = yc;
  a.LineCurve = sb;
  a.Shape = Wb;
  a.Path = ld;
  a.ShapePath = ke;
  a.Font = le;
  a.CurvePath = kd;
  a.Curve = Ra;
  a.ShapeUtils = fb;
  a.SceneUtils = {createMultiMaterialObject:function(a, b) {
    for (var d = new Qc, c = 0, e = b.length;c < e;c++) {
      d.add(new Ga(a, b[c]));
    }
    return d;
  }, detach:function(a, b, c) {
    a.applyMatrix(b.matrixWorld);
    b.remove(a);
    c.add(a);
  }, attach:function(a, b, c) {
    var d = new p;
    d.getInverse(c.matrixWorld);
    a.applyMatrix(d);
    b.remove(a);
    c.add(a);
  }};
  a.WireframeGeometry = ec;
  a.ParametricGeometry = Sc;
  a.ParametricBufferGeometry = fc;
  a.TetrahedronGeometry = Uc;
  a.TetrahedronBufferGeometry = gc;
  a.OctahedronGeometry = Vc;
  a.OctahedronBufferGeometry = Ib;
  a.IcosahedronGeometry = Wc;
  a.IcosahedronBufferGeometry = hc;
  a.DodecahedronGeometry = Xc;
  a.DodecahedronBufferGeometry = ic;
  a.PolyhedronGeometry = Tc;
  a.PolyhedronBufferGeometry = Qa;
  a.TubeGeometry = Yc;
  a.TubeBufferGeometry = jc;
  a.TorusKnotGeometry = Zc;
  a.TorusKnotBufferGeometry = kc;
  a.TorusGeometry = $c;
  a.TorusBufferGeometry = lc;
  a.TextGeometry = ad;
  a.SphereGeometry = bd;
  a.SphereBufferGeometry = Jb;
  a.RingGeometry = cd;
  a.RingBufferGeometry = mc;
  a.PlaneGeometry = ob;
  a.PlaneBufferGeometry = Gb;
  a.LatheGeometry = dd;
  a.LatheBufferGeometry = nc;
  a.ShapeGeometry = oc;
  a.ShapeBufferGeometry = pc;
  a.ExtrudeGeometry = bb;
  a.EdgesGeometry = qc;
  a.ConeGeometry = ed;
  a.ConeBufferGeometry = fd;
  a.CylinderGeometry = Kb;
  a.CylinderBufferGeometry = wb;
  a.CircleGeometry = gd;
  a.CircleBufferGeometry = rc;
  a.BoxGeometry = Na;
  a.BoxBufferGeometry = Va;
  a.ShadowMaterial = sc;
  a.SpriteMaterial = Eb;
  a.RawShaderMaterial = tc;
  a.ShaderMaterial = sa;
  a.PointsMaterial = eb;
  a.MeshPhysicalMaterial = Lb;
  a.MeshStandardMaterial = rb;
  a.MeshPhongMaterial = gb;
  a.MeshToonMaterial = Mb;
  a.MeshNormalMaterial = Nb;
  a.MeshLambertMaterial = Ob;
  a.MeshDepthMaterial = xa;
  a.MeshBasicMaterial = Ka;
  a.LineDashedMaterial = Pb;
  a.LineBasicMaterial = wa;
  a.Material = W;
  a.Float64BufferAttribute = ub;
  a.Float32BufferAttribute = Y;
  a.Uint32BufferAttribute = mb;
  a.Int32BufferAttribute = ab;
  a.Uint16BufferAttribute = $a;
  a.Int16BufferAttribute = Bb;
  a.Uint8ClampedBufferAttribute = La;
  a.Uint8BufferAttribute = lb;
  a.Int8BufferAttribute = tb;
  a.BufferAttribute = ja;
  a.REVISION = "85dev";
  a.MOUSE = {LEFT:0, MIDDLE:1, RIGHT:2};
  a.CullFaceNone = 0;
  a.CullFaceBack = 1;
  a.CullFaceFront = 2;
  a.CullFaceFrontBack = 3;
  a.FrontFaceDirectionCW = 0;
  a.FrontFaceDirectionCCW = 1;
  a.BasicShadowMap = 0;
  a.PCFShadowMap = 1;
  a.PCFSoftShadowMap = 2;
  a.FrontSide = 0;
  a.BackSide = 1;
  a.DoubleSide = 2;
  a.FlatShading = 1;
  a.SmoothShading = 2;
  a.NoColors = 0;
  a.FaceColors = 1;
  a.VertexColors = 2;
  a.NoBlending = 0;
  a.NormalBlending = 1;
  a.AdditiveBlending = 2;
  a.SubtractiveBlending = 3;
  a.MultiplyBlending = 4;
  a.CustomBlending = 5;
  a.AddEquation = 100;
  a.SubtractEquation = 101;
  a.ReverseSubtractEquation = 102;
  a.MinEquation = 103;
  a.MaxEquation = 104;
  a.ZeroFactor = 200;
  a.OneFactor = 201;
  a.SrcColorFactor = 202;
  a.OneMinusSrcColorFactor = 203;
  a.SrcAlphaFactor = 204;
  a.OneMinusSrcAlphaFactor = 205;
  a.DstAlphaFactor = 206;
  a.OneMinusDstAlphaFactor = 207;
  a.DstColorFactor = 208;
  a.OneMinusDstColorFactor = 209;
  a.SrcAlphaSaturateFactor = 210;
  a.NeverDepth = 0;
  a.AlwaysDepth = 1;
  a.LessDepth = 2;
  a.LessEqualDepth = 3;
  a.EqualDepth = 4;
  a.GreaterEqualDepth = 5;
  a.GreaterDepth = 6;
  a.NotEqualDepth = 7;
  a.MultiplyOperation = 0;
  a.MixOperation = 1;
  a.AddOperation = 2;
  a.NoToneMapping = 0;
  a.LinearToneMapping = 1;
  a.ReinhardToneMapping = 2;
  a.Uncharted2ToneMapping = 3;
  a.CineonToneMapping = 4;
  a.UVMapping = 300;
  a.CubeReflectionMapping = 301;
  a.CubeRefractionMapping = 302;
  a.EquirectangularReflectionMapping = 303;
  a.EquirectangularRefractionMapping = 304;
  a.SphericalReflectionMapping = 305;
  a.CubeUVReflectionMapping = 306;
  a.CubeUVRefractionMapping = 307;
  a.RepeatWrapping = 1E3;
  a.ClampToEdgeWrapping = 1001;
  a.MirroredRepeatWrapping = 1002;
  a.NearestFilter = 1003;
  a.NearestMipMapNearestFilter = 1004;
  a.NearestMipMapLinearFilter = 1005;
  a.LinearFilter = 1006;
  a.LinearMipMapNearestFilter = 1007;
  a.LinearMipMapLinearFilter = 1008;
  a.UnsignedByteType = 1009;
  a.ByteType = 1010;
  a.ShortType = 1011;
  a.UnsignedShortType = 1012;
  a.IntType = 1013;
  a.UnsignedIntType = 1014;
  a.FloatType = 1015;
  a.HalfFloatType = 1016;
  a.UnsignedShort4444Type = 1017;
  a.UnsignedShort5551Type = 1018;
  a.UnsignedShort565Type = 1019;
  a.UnsignedInt248Type = 1020;
  a.AlphaFormat = 1021;
  a.RGBFormat = 1022;
  a.RGBAFormat = 1023;
  a.LuminanceFormat = 1024;
  a.LuminanceAlphaFormat = 1025;
  a.RGBEFormat = 1023;
  a.DepthFormat = 1026;
  a.DepthStencilFormat = 1027;
  a.RGB_S3TC_DXT1_Format = 2001;
  a.RGBA_S3TC_DXT1_Format = 2002;
  a.RGBA_S3TC_DXT3_Format = 2003;
  a.RGBA_S3TC_DXT5_Format = 2004;
  a.RGB_PVRTC_4BPPV1_Format = 2100;
  a.RGB_PVRTC_2BPPV1_Format = 2101;
  a.RGBA_PVRTC_4BPPV1_Format = 2102;
  a.RGBA_PVRTC_2BPPV1_Format = 2103;
  a.RGB_ETC1_Format = 2151;
  a.LoopOnce = 2200;
  a.LoopRepeat = 2201;
  a.LoopPingPong = 2202;
  a.InterpolateDiscrete = 2300;
  a.InterpolateLinear = 2301;
  a.InterpolateSmooth = 2302;
  a.ZeroCurvatureEnding = 2400;
  a.ZeroSlopeEnding = 2401;
  a.WrapAroundEnding = 2402;
  a.TrianglesDrawMode = 0;
  a.TriangleStripDrawMode = 1;
  a.TriangleFanDrawMode = 2;
  a.LinearEncoding = 3E3;
  a.sRGBEncoding = 3001;
  a.GammaEncoding = 3007;
  a.RGBEEncoding = 3002;
  a.LogLuvEncoding = 3003;
  a.RGBM7Encoding = 3004;
  a.RGBM16Encoding = 3005;
  a.RGBDEncoding = 3006;
  a.BasicDepthPacking = 3200;
  a.RGBADepthPacking = 3201;
  a.CubeGeometry = Na;
  a.Face4 = function(a, b, c, e, g, f, k) {
    console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
    return new za(a, b, c, g, f, k);
  };
  a.LineStrip = 0;
  a.LinePieces = 1;
  a.MeshFaceMaterial = function(a) {
    console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
    return a;
  };
  a.MultiMaterial = function(a) {
    void 0 === a && (a = []);
    console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
    a.isMultiMaterial = !0;
    a.materials = a;
    a.clone = function() {
      return a.slice();
    };
    return a;
  };
  a.PointCloud = function(a, b) {
    console.warn("THREE.PointCloud has been renamed to THREE.Points.");
    return new cc(a, b);
  };
  a.Particle = function(a) {
    console.warn("THREE.Particle has been renamed to THREE.Sprite.");
    return new Nc(a);
  };
  a.ParticleSystem = function(a, b) {
    console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
    return new cc(a, b);
  };
  a.PointCloudMaterial = function(a) {
    console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
    return new eb(a);
  };
  a.ParticleBasicMaterial = function(a) {
    console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
    return new eb(a);
  };
  a.ParticleSystemMaterial = function(a) {
    console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
    return new eb(a);
  };
  a.Vertex = function(a, b, c) {
    console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
    return new e(a, b, c);
  };
  a.DynamicBufferAttribute = function(a, b) {
    console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");
    return (new ja(a, b)).setDynamic(!0);
  };
  a.Int8Attribute = function(a, b) {
    console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
    return new tb(a, b);
  };
  a.Uint8Attribute = function(a, b) {
    console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
    return new lb(a, b);
  };
  a.Uint8ClampedAttribute = function(a, b) {
    console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
    return new La(a, b);
  };
  a.Int16Attribute = function(a, b) {
    console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
    return new Bb(a, b);
  };
  a.Uint16Attribute = function(a, b) {
    console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
    return new $a(a, b);
  };
  a.Int32Attribute = function(a, b) {
    console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
    return new ab(a, b);
  };
  a.Uint32Attribute = function(a, b) {
    console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
    return new mb(a, b);
  };
  a.Float32Attribute = function(a, b) {
    console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
    return new Y(a, b);
  };
  a.Float64Attribute = function(a, b) {
    console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
    return new ub(a, b);
  };
  a.ClosedSplineCurve3 = We;
  a.SplineCurve3 = Xe;
  a.Spline = we;
  a.BoundingBoxHelper = function(a, b) {
    console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
    return new Jc(a, b);
  };
  a.EdgesHelper = function(a, b) {
    console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
    return new ua(new qc(a.geometry), new wa({color:void 0 !== b ? b : 16777215}));
  };
  a.WireframeHelper = function(a, b) {
    console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
    return new ua(new ec(a.geometry), new wa({color:void 0 !== b ? b : 16777215}));
  };
  a.XHRLoader = function(a) {
    console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
    return new hb(a);
  };
  a.BinaryTextureLoader = function(a) {
    console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
    return new ge(a);
  };
  a.GeometryUtils = {merge:function(a, b, c) {
    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
    var d;
    b.isMesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, b = b.geometry);
    a.merge(b, d, c);
  }, center:function(a) {
    console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
    return a.center();
  }};
  a.ImageUtils = {crossOrigin:void 0, loadTexture:function(a, b, c, e) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    var d = new Dd;
    d.setCrossOrigin(this.crossOrigin);
    a = d.load(a, c, void 0, e);
    b && (a.mapping = b);
    return a;
  }, loadTextureCube:function(a, b, c, e) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    var d = new he;
    d.setCrossOrigin(this.crossOrigin);
    a = d.load(a, c, void 0, e);
    b && (a.mapping = b);
    return a;
  }, loadCompressedTexture:function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  }, loadCompressedTextureCube:function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  }};
  a.Projector = function() {
    console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");
    this.projectVector = function(a, b) {
      console.warn("THREE.Projector: .projectVector() is now vector.project().");
      a.project(b);
    };
    this.unprojectVector = function(a, b) {
      console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
      a.unproject(b);
    };
    this.pickingRay = function() {
      console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
    };
  };
  a.CanvasRenderer = function() {
    console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js");
    this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    this.clear = function() {
    };
    this.render = function() {
    };
    this.setClearColor = function() {
    };
    this.setSize = function() {
    };
  };
  Object.defineProperty(a, "__esModule", {value:!0});
});
THREE.VREffect = function(a, h) {
  var l, b, f, k, c, g, e, p;
  function r(a) {
    v = a;
    0 < a.length ? t = a[0] : h && h("HMD not available");
  }
  function w() {
    var b = u.isPresenting;
    u.isPresenting = void 0 !== t && t.isPresenting;
    if (u.isPresenting) {
      var c = t.getEyeParameters("left"), e = c.renderWidth, c = c.renderHeight;
      b || (D = a.getPixelRatio(), B = a.getSize(), a.setPixelRatio(1), a.setSize(2 * e, c, !1));
    } else {
      b && (a.setPixelRatio(D), a.setSize(B.width, B.height, C));
    }
  }
  function n(a, b, c, e) {
    var g, f = Math.PI / 180;
    g = Math.tan(a.upDegrees * f);
    var k = Math.tan(a.downDegrees * f), q = Math.tan(a.leftDegrees * f);
    a = Math.tan(a.rightDegrees * f);
    c = void 0 === c ? .01 : c;
    e = void 0 === e ? 1E4 : e;
    var f = void 0 === b || b ? -1 : 1, p = new THREE.Matrix4, h = p.elements, n = 2 / (q + a), r = 2 / (g + k);
    b = [n, r];
    g = [(q - a) * n * .5, (g - k) * r * .5];
    h[0] = b[0];
    h[1] = 0;
    h[2] = g[0] * f;
    h[3] = 0;
    h[4] = 0;
    h[5] = b[1];
    h[6] = -g[1] * f;
    h[7] = 0;
    h[8] = 0;
    h[9] = 0;
    h[10] = e / (c - e) * -f;
    h[11] = e * c / (c - e);
    h[12] = 0;
    h[13] = 0;
    h[14] = f;
    h[15] = 0;
    p.transpose();
    return p;
  }
  var t, v, y = new THREE.Vector3, x = new THREE.Vector3, q = null;
  "VRFrameData" in window && (q = new window.VRFrameData);
  navigator.getVRDisplays && navigator.getVRDisplays().then(r).catch(function() {
    console.warn("THREE.VREffect: Unable to get VR Displays");
  });
  this.isPresenting = !1;
  var u = this, B = a.getSize(), C = !1, D = a.getPixelRatio();
  this.getVRDisplay = function() {
    return t;
  };
  this.setVRDisplay = function(a) {
    t = a;
  };
  this.getVRDisplays = function() {
    console.warn("THREE.VREffect: getVRDisplays() is being deprecated.");
    return v;
  };
  this.setSize = function(b, c, e) {
    B = {width:b, height:c};
    C = e;
    u.isPresenting ? (b = t.getEyeParameters("left"), a.setPixelRatio(1), a.setSize(2 * b.renderWidth, b.renderHeight, !1)) : (a.setPixelRatio(D), a.setSize(b, c, e));
  };
  var F = a.domElement, E = [0, 0, .5, 1], z = [.5, 0, .5, 1];
  window.addEventListener("vrdisplaypresentchange", w, !1);
  this.setFullScreen = function(a) {
    return new Promise(function(b, c) {
      void 0 === t ? c(Error("No VR hardware found.")) : u.isPresenting === a ? b() : a ? b(t.requestPresent([{source:F}])) : b(t.exitPresent());
    });
  };
  this.requestPresent = function() {
    return this.setFullScreen(!0);
  };
  this.exitPresent = function() {
    return this.setFullScreen(!1);
  };
  this.requestAnimationFrame = function(a) {
    return void 0 !== t ? t.requestAnimationFrame(a) : window.requestAnimationFrame(a);
  };
  this.cancelAnimationFrame = function(a) {
    void 0 !== t ? t.cancelAnimationFrame(a) : window.cancelAnimationFrame(a);
  };
  this.submitFrame = function() {
    void 0 !== t && u.isPresenting && t.submitFrame();
  };
  this.autoSubmitFrame = !0;
  var I = new THREE.PerspectiveCamera;
  I.layers.enable(1);
  var J = new THREE.PerspectiveCamera;
  J.layers.enable(2);
  this.render = function(h, r, w, v) {
    if (t && u.isPresenting) {
      var B = h.autoUpdate;
      B && (h.updateMatrixWorld(), h.autoUpdate = !1);
      var C = t.getEyeParameters("left"), F = t.getEyeParameters("right");
      y.fromArray(C.offset);
      x.fromArray(F.offset);
      Array.isArray(h) && (console.warn("THREE.VREffect.render() no longer supports arrays. Use object.layers instead."), h = h[0]);
      var D = a.getSize(), L = t.getLayers(), S;
      L.length ? (S = L[0], L = null !== S.leftBounds && 4 === S.leftBounds.length ? S.leftBounds : E, S = null !== S.rightBounds && 4 === S.rightBounds.length ? S.rightBounds : z) : (L = E, S = z);
      c = Math.round(D.width * L[0]);
      g = Math.round(D.height * L[1]);
      e = Math.round(D.width * L[2]);
      p = Math.round(D.height * L[3]);
      l = Math.round(D.width * S[0]);
      b = Math.round(D.height * S[1]);
      f = Math.round(D.width * S[2]);
      k = Math.round(D.height * S[3]);
      w ? (a.setRenderTarget(w), w.scissorTest = !0) : (a.setRenderTarget(null), a.setScissorTest(!0));
      (a.autoClear || v) && a.clear();
      null === r.parent && r.updateMatrixWorld();
      r.matrixWorld.decompose(I.position, I.quaternion, I.scale);
      J.position.copy(I.position);
      J.quaternion.copy(I.quaternion);
      J.scale.copy(I.scale);
      I.translateOnAxis(y, I.scale.x);
      J.translateOnAxis(x, J.scale.x);
      t.getFrameData ? (t.depthNear = r.near, t.depthFar = r.far, t.getFrameData(q), I.projectionMatrix.elements = q.leftProjectionMatrix, J.projectionMatrix.elements = q.rightProjectionMatrix) : (I.projectionMatrix = n(C.fieldOfView, !0, r.near, r.far), J.projectionMatrix = n(F.fieldOfView, !0, r.near, r.far));
      w ? (w.viewport.set(c, g, e, p), w.scissor.set(c, g, e, p)) : (a.setViewport(c, g, e, p), a.setScissor(c, g, e, p));
      a.render(h, I, w, v);
      w ? (w.viewport.set(l, b, f, k), w.scissor.set(l, b, f, k)) : (a.setViewport(l, b, f, k), a.setScissor(l, b, f, k));
      a.render(h, J, w, v);
      w ? (w.viewport.set(0, 0, D.width, D.height), w.scissor.set(0, 0, D.width, D.height), w.scissorTest = !1, a.setRenderTarget(null)) : (a.setViewport(0, 0, D.width, D.height), a.setScissorTest(!1));
      B && (h.autoUpdate = !0);
      u.autoSubmitFrame && u.submitFrame();
    } else {
      a.render(h, r, w, v);
    }
  };
  this.dispose = function() {
    window.removeEventListener("vrdisplaypresentchange", w, !1);
  };
};
THREE.Animation = function(a, h) {
  this.root = a;
  this.data = THREE.AnimationHandler.init(h);
  this.hierarchy = THREE.AnimationHandler.parse(a);
  this.currentTime = 0;
  this.timeScale = 1;
  this.isPlaying = !1;
  this.loop = !0;
  this.weight = 0;
  this.interpolationType = THREE.AnimationHandler.LINEAR;
};
THREE.Animation.prototype = {constructor:THREE.Animation, keyTypes:["pos", "rot", "scl"], play:function(a, h) {
  this.currentTime = void 0 !== a ? a : 0;
  this.weight = void 0 !== h ? h : 1;
  this.isPlaying = !0;
  this.reset();
  THREE.AnimationHandler.play(this);
}, stop:function() {
  this.isPlaying = !1;
  THREE.AnimationHandler.stop(this);
}, reset:function() {
  for (var a = 0, h = this.hierarchy.length;a < h;a++) {
    var l = this.hierarchy[a];
    void 0 === l.animationCache && (l.animationCache = {animations:{}, blending:{positionWeight:0, quaternionWeight:0, scaleWeight:0}});
    var b = this.data.name, f = l.animationCache.animations, k = f[b];
    void 0 === k && (k = {prevKey:{pos:0, rot:0, scl:0}, nextKey:{pos:0, rot:0, scl:0}, originalMatrix:l.matrix}, f[b] = k);
    for (l = 0;3 > l;l++) {
      for (var b = this.keyTypes[l], f = this.data.hierarchy[a].keys[0], c = this.getNextKeyWith(b, a, 1);c.time < this.currentTime && c.index > f.index;) {
        f = c, c = this.getNextKeyWith(b, a, c.index + 1);
      }
      k.prevKey[b] = f;
      k.nextKey[b] = c;
    }
  }
}, resetBlendWeights:function() {
  for (var a = 0, h = this.hierarchy.length;a < h;a++) {
    var l = this.hierarchy[a].animationCache;
    void 0 !== l && (l = l.blending, l.positionWeight = 0, l.quaternionWeight = 0, l.scaleWeight = 0);
  }
}, update:function() {
  var a = [], h = new THREE.Vector3, l = new THREE.Vector3, b = new THREE.Quaternion, f = function(a, b) {
    var c = [], g = [], f, h, n, l;
    b *= a.length - 1;
    f = Math.floor(b);
    b -= f;
    c[0] = 0 === f ? f : f - 1;
    c[1] = f;
    c[2] = f > a.length - 2 ? f : f + 1;
    c[3] = f > a.length - 3 ? f : f + 2;
    f = a[c[0]];
    h = a[c[1]];
    n = a[c[2]];
    l = a[c[3]];
    a = b * b;
    c = b * a;
    g[0] = k(f[0], h[0], n[0], l[0], b, a, c);
    g[1] = k(f[1], h[1], n[1], l[1], b, a, c);
    g[2] = k(f[2], h[2], n[2], l[2], b, a, c);
    return g;
  }, k = function(a, b, e, f, k, h, n) {
    a = .5 * (e - a);
    f = .5 * (f - b);
    return (2 * (b - e) + a + f) * n + (-3 * (b - e) - 2 * a - f) * h + a * k + b;
  };
  return function(c) {
    if (!1 !== this.isPlaying && (this.currentTime += c * this.timeScale, 0 !== this.weight)) {
      c = this.data.length;
      if (this.currentTime > c || 0 > this.currentTime) {
        this.loop ? (this.currentTime %= c, 0 > this.currentTime && (this.currentTime += c), this.reset()) : this.stop();
      }
      c = 0;
      for (var g = this.hierarchy.length;c < g;c++) {
        for (var e = this.hierarchy[c], k = e.animationCache.animations[this.data.name], r = e.animationCache.blending, w = 0;3 > w;w++) {
          var n = this.keyTypes[w], t = k.prevKey[n], v = k.nextKey[n];
          if (0 < this.timeScale && v.time <= this.currentTime || 0 > this.timeScale && t.time >= this.currentTime) {
            t = this.data.hierarchy[c].keys[0];
            for (v = this.getNextKeyWith(n, c, 1);v.time < this.currentTime && v.index > t.index;) {
              t = v, v = this.getNextKeyWith(n, c, v.index + 1);
            }
            k.prevKey[n] = t;
            k.nextKey[n] = v;
          }
          var y = (this.currentTime - t.time) / (v.time - t.time), x = t[n], q = v[n];
          0 > y && (y = 0);
          1 < y && (y = 1);
          if ("pos" === n) {
            if (this.interpolationType === THREE.AnimationHandler.LINEAR) {
              l.x = x[0] + (q[0] - x[0]) * y, l.y = x[1] + (q[1] - x[1]) * y, l.z = x[2] + (q[2] - x[2]) * y, t = this.weight / (this.weight + r.positionWeight), e.position.lerp(l, t), r.positionWeight += this.weight;
            } else {
              if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
                a[0] = this.getPrevKeyWith("pos", c, t.index - 1).pos, a[1] = x, a[2] = q, a[3] = this.getNextKeyWith("pos", c, v.index + 1).pos, y = .33 * y + .33, v = f(a, y), t = this.weight / (this.weight + r.positionWeight), r.positionWeight += this.weight, n = e.position, n.x += (v[0] - n.x) * t, n.y += (v[1] - n.y) * t, n.z += (v[2] - n.z) * t, this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (y = f(a, 1.01 * y), h.set(y[0], y[1], y[2]), h.sub(n), h.y = 0, h.normalize(), 
                e.rotation.set(0, Math.atan2(h.x, h.z), 0));
              }
            }
          } else {
            "rot" === n ? (THREE.Quaternion.slerp(x, q, b, y), 0 === r.quaternionWeight ? (e.quaternion.copy(b), r.quaternionWeight = this.weight) : (t = this.weight / (this.weight + r.quaternionWeight), THREE.Quaternion.slerp(e.quaternion, b, e.quaternion, t), r.quaternionWeight += this.weight)) : "scl" === n && (l.x = x[0] + (q[0] - x[0]) * y, l.y = x[1] + (q[1] - x[1]) * y, l.z = x[2] + (q[2] - x[2]) * y, t = this.weight / (this.weight + r.scaleWeight), e.scale.lerp(l, t), r.scaleWeight += this.weight);
          }
        }
      }
      return !0;
    }
  };
}(), getNextKeyWith:function(a, h, l) {
  var b = this.data.hierarchy[h].keys;
  for (l = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? l < b.length - 1 ? l : b.length - 1 : l % b.length;l < b.length;l++) {
    if (void 0 !== b[l][a]) {
      return b[l];
    }
  }
  return this.data.hierarchy[h].keys[0];
}, getPrevKeyWith:function(a, h, l) {
  var b = this.data.hierarchy[h].keys;
  for (l = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < l ? l : 0 : 0 <= l ? l : l + b.length;0 <= l;l--) {
    if (void 0 !== b[l][a]) {
      return b[l];
    }
  }
  return this.data.hierarchy[h].keys[b.length - 1];
}};
THREE.AnimationHandler = {LINEAR:0, CATMULLROM:1, CATMULLROM_FORWARD:2, add:function() {
  console.warn("THREE.AnimationHandler.add() has been deprecated.");
}, get:function() {
  console.warn("THREE.AnimationHandler.get() has been deprecated.");
}, remove:function() {
  console.warn("THREE.AnimationHandler.remove() has been deprecated.");
}, animations:[], init:function(a) {
  if (!0 === a.initialized) {
    return a;
  }
  for (var h = 0;h < a.hierarchy.length;h++) {
    for (var l = 0;l < a.hierarchy[h].keys.length;l++) {
      if (0 > a.hierarchy[h].keys[l].time && (a.hierarchy[h].keys[l].time = 0), void 0 !== a.hierarchy[h].keys[l].rot && !(a.hierarchy[h].keys[l].rot instanceof THREE.Quaternion)) {
        var b = a.hierarchy[h].keys[l].rot;
        a.hierarchy[h].keys[l].rot = (new THREE.Quaternion).fromArray(b);
      }
    }
    if (a.hierarchy[h].keys.length && void 0 !== a.hierarchy[h].keys[0].morphTargets) {
      b = {};
      for (l = 0;l < a.hierarchy[h].keys.length;l++) {
        for (var f = 0;f < a.hierarchy[h].keys[l].morphTargets.length;f++) {
          var k = a.hierarchy[h].keys[l].morphTargets[f];
          b[k] = -1;
        }
      }
      a.hierarchy[h].usedMorphTargets = b;
      for (l = 0;l < a.hierarchy[h].keys.length;l++) {
        var c = {};
        for (k in b) {
          for (f = 0;f < a.hierarchy[h].keys[l].morphTargets.length;f++) {
            if (a.hierarchy[h].keys[l].morphTargets[f] === k) {
              c[k] = a.hierarchy[h].keys[l].morphTargetsInfluences[f];
              break;
            }
          }
          f === a.hierarchy[h].keys[l].morphTargets.length && (c[k] = 0);
        }
        a.hierarchy[h].keys[l].morphTargetsInfluences = c;
      }
    }
    for (l = 1;l < a.hierarchy[h].keys.length;l++) {
      a.hierarchy[h].keys[l].time === a.hierarchy[h].keys[l - 1].time && (a.hierarchy[h].keys.splice(l, 1), l--);
    }
    for (l = 0;l < a.hierarchy[h].keys.length;l++) {
      a.hierarchy[h].keys[l].index = l;
    }
  }
  a.initialized = !0;
  return a;
}, parse:function(a) {
  var h = function(a, b) {
    b.push(a);
    for (var c = 0;c < a.children.length;c++) {
      h(a.children[c], b);
    }
  }, l = [];
  if (a instanceof THREE.SkinnedMesh) {
    for (var b = 0;b < a.skeleton.bones.length;b++) {
      l.push(a.skeleton.bones[b]);
    }
  } else {
    h(a, l);
  }
  return l;
}, play:function(a) {
  -1 === this.animations.indexOf(a) && this.animations.push(a);
}, stop:function(a) {
  a = this.animations.indexOf(a);
  -1 !== a && this.animations.splice(a, 1);
}, update:function(a) {
  for (var h = 0;h < this.animations.length;h++) {
    this.animations[h].resetBlendWeights();
  }
  for (h = 0;h < this.animations.length;h++) {
    this.animations[h].update(a);
  }
}};
THREE.KeyFrameAnimation = function(a) {
  this.root = a.node;
  this.data = THREE.AnimationHandler.init(a);
  this.hierarchy = THREE.AnimationHandler.parse(this.root);
  this.currentTime = 0;
  this.timeScale = .001;
  this.isPlaying = !1;
  this.loop = this.isPaused = !0;
  a = 0;
  for (var h = this.hierarchy.length;a < h;a++) {
    var l = this.data.hierarchy[a].sids, b = this.hierarchy[a];
    if (this.data.hierarchy[a].keys.length && l) {
      for (var f = 0;f < l.length;f++) {
        var k = l[f], c = this.getNextKeyWith(k, a, 0);
        c && c.apply(k);
      }
      b.matrixAutoUpdate = !1;
      this.data.hierarchy[a].node.updateMatrix();
      b.matrixWorldNeedsUpdate = !0;
    }
  }
};
THREE.KeyFrameAnimation.prototype = {constructor:THREE.KeyFrameAnimation, play:function(a) {
  this.currentTime = void 0 !== a ? a : 0;
  if (!1 === this.isPlaying) {
    this.isPlaying = !0;
    var h = this.hierarchy.length, l, b;
    for (a = 0;a < h;a++) {
      l = this.hierarchy[a], b = this.data.hierarchy[a], void 0 === b.animationCache && (b.animationCache = {}, b.animationCache.prevKey = null, b.animationCache.nextKey = null, b.animationCache.originalMatrix = l.matrix), l = this.data.hierarchy[a].keys, 1 < l.length && (b.animationCache.prevKey = l[0], b.animationCache.nextKey = l[1], this.startTime = Math.min(l[0].time, this.startTime), this.endTime = Math.max(l[l.length - 1].time, this.endTime));
    }
    this.update(0);
  }
  this.isPaused = !1;
}, stop:function() {
  this.isPaused = this.isPlaying = !1;
  for (var a = 0;a < this.data.hierarchy.length;a++) {
    var h = this.hierarchy[a], l = this.data.hierarchy[a];
    if (void 0 !== l.animationCache) {
      var b = l.animationCache.originalMatrix;
      b.copy(h.matrix);
      h.matrix = b;
      delete l.animationCache;
    }
  }
}, update:function(a) {
  if (!1 !== this.isPlaying) {
    this.currentTime += a * this.timeScale;
    a = this.data.length;
    !0 === this.loop && this.currentTime > a && (this.currentTime %= a);
    this.currentTime = Math.min(this.currentTime, a);
    a = 0;
    for (var h = this.hierarchy.length;a < h;a++) {
      var l = this.hierarchy[a], b = this.data.hierarchy[a], f = b.keys, b = b.animationCache;
      if (f.length) {
        var k = b.prevKey, c = b.nextKey;
        if (c.time <= this.currentTime) {
          for (;c.time < this.currentTime && c.index > k.index;) {
            k = c, c = f[k.index + 1];
          }
          b.prevKey = k;
          b.nextKey = c;
        }
        c.time >= this.currentTime ? k.interpolate(c, this.currentTime) : k.interpolate(c, c.time);
        this.data.hierarchy[a].node.updateMatrix();
        l.matrixWorldNeedsUpdate = !0;
      }
    }
  }
}, getNextKeyWith:function(a, h, l) {
  h = this.data.hierarchy[h].keys;
  for (l %= h.length;l < h.length;l++) {
    if (h[l].hasTarget(a)) {
      return h[l];
    }
  }
  return h[0];
}, getPrevKeyWith:function(a, h, l) {
  h = this.data.hierarchy[h].keys;
  for (l = 0 <= l ? l : l + h.length;0 <= l;l--) {
    if (h[l].hasTarget(a)) {
      return h[l];
    }
  }
  return h[h.length - 1];
}};
!function(a) {
  if ("object" == typeof exports && "undefined" != typeof module) {
    module.exports = a();
  } else {
    var h;
    "undefined" != typeof window ? h = window : "undefined" != typeof global ? h = global : "undefined" != typeof self && (h = self);
    h.CANNON = a();
  }
}(function() {
  return function h(l, b, f) {
    function k(e, g) {
      if (!b[e]) {
        if (!l[e]) {
          var p = "function" == typeof require && require;
          if (!g && p) {
            return p(e, !0);
          }
          if (c) {
            return c(e, !0);
          }
          throw Error("Cannot find module '" + e + "'");
        }
        g = b[e] = {exports:{}};
        l[e][0].call(g.exports, function(b) {
          var c = l[e][1][b];
          return k(c ? c : b);
        }, g, g.exports, h, l, b, f);
      }
      return b[e].exports;
    }
    for (var c = "function" == typeof require && require, g = 0;g < f.length;g++) {
      k(f[g]);
    }
    return k;
  }({1:[function(h, l) {
    l.exports = {name:"cannon", version:"0.6.2", description:"A lightweight 3D physics engine written in JavaScript.", homepage:"https://github.com/schteppe/cannon.js", author:"Stefan Hedman <schteppe@gmail.com> (http://steffe.se)", keywords:["cannon.js", "cannon", "physics", "engine", "3d"], main:"./build/cannon.js", engines:{node:"*"}, repository:{type:"git", url:"https://github.com/schteppe/cannon.js.git"}, bugs:{url:"https://github.com/schteppe/cannon.js/issues"}, licenses:[{type:"MIT"}], devDependencies:{jshint:"latest", 
    "uglify-js":"latest", nodeunit:"^0.9.0", grunt:"~0.4.0", "grunt-contrib-jshint":"~0.1.1", "grunt-contrib-nodeunit":"^0.4.1", "grunt-contrib-concat":"~0.1.3", "grunt-contrib-uglify":"^0.5.1", "grunt-browserify":"^2.1.4", "grunt-contrib-yuidoc":"^0.5.2", browserify:"*"}, dependencies:{}};
  }, {}], 2:[function(h, l) {
    l.exports = {version:h("../package.json").version, AABB:h("./collision/AABB"), ArrayCollisionMatrix:h("./collision/ArrayCollisionMatrix"), Body:h("./objects/Body"), Box:h("./shapes/Box"), Broadphase:h("./collision/Broadphase"), Constraint:h("./constraints/Constraint"), ContactEquation:h("./equations/ContactEquation"), Narrowphase:h("./world/Narrowphase"), ConeTwistConstraint:h("./constraints/ConeTwistConstraint"), ContactMaterial:h("./material/ContactMaterial"), ConvexPolyhedron:h("./shapes/ConvexPolyhedron"), 
    Cylinder:h("./shapes/Cylinder"), DistanceConstraint:h("./constraints/DistanceConstraint"), Equation:h("./equations/Equation"), EventTarget:h("./utils/EventTarget"), FrictionEquation:h("./equations/FrictionEquation"), GSSolver:h("./solver/GSSolver"), GridBroadphase:h("./collision/GridBroadphase"), Heightfield:h("./shapes/Heightfield"), HingeConstraint:h("./constraints/HingeConstraint"), LockConstraint:h("./constraints/LockConstraint"), Mat3:h("./math/Mat3"), Material:h("./material/Material"), 
    NaiveBroadphase:h("./collision/NaiveBroadphase"), ObjectCollisionMatrix:h("./collision/ObjectCollisionMatrix"), Pool:h("./utils/Pool"), Particle:h("./shapes/Particle"), Plane:h("./shapes/Plane"), PointToPointConstraint:h("./constraints/PointToPointConstraint"), Quaternion:h("./math/Quaternion"), Ray:h("./collision/Ray"), RaycastVehicle:h("./objects/RaycastVehicle"), RaycastResult:h("./collision/RaycastResult"), RigidVehicle:h("./objects/RigidVehicle"), RotationalEquation:h("./equations/RotationalEquation"), 
    RotationalMotorEquation:h("./equations/RotationalMotorEquation"), SAPBroadphase:h("./collision/SAPBroadphase"), SPHSystem:h("./objects/SPHSystem"), Shape:h("./shapes/Shape"), Solver:h("./solver/Solver"), Sphere:h("./shapes/Sphere"), SplitSolver:h("./solver/SplitSolver"), Spring:h("./objects/Spring"), Trimesh:h("./shapes/Trimesh"), Vec3:h("./math/Vec3"), Vec3Pool:h("./utils/Vec3Pool"), World:h("./world/World")};
  }, {"../package.json":1, "./collision/AABB":3, "./collision/ArrayCollisionMatrix":4, "./collision/Broadphase":5, "./collision/GridBroadphase":6, "./collision/NaiveBroadphase":7, "./collision/ObjectCollisionMatrix":8, "./collision/Ray":9, "./collision/RaycastResult":10, "./collision/SAPBroadphase":11, "./constraints/ConeTwistConstraint":12, "./constraints/Constraint":13, "./constraints/DistanceConstraint":14, "./constraints/HingeConstraint":15, "./constraints/LockConstraint":16, "./constraints/PointToPointConstraint":17, 
  "./equations/ContactEquation":19, "./equations/Equation":20, "./equations/FrictionEquation":21, "./equations/RotationalEquation":22, "./equations/RotationalMotorEquation":23, "./material/ContactMaterial":24, "./material/Material":25, "./math/Mat3":27, "./math/Quaternion":28, "./math/Vec3":30, "./objects/Body":31, "./objects/RaycastVehicle":32, "./objects/RigidVehicle":33, "./objects/SPHSystem":34, "./objects/Spring":35, "./shapes/Box":37, "./shapes/ConvexPolyhedron":38, "./shapes/Cylinder":39, 
  "./shapes/Heightfield":40, "./shapes/Particle":41, "./shapes/Plane":42, "./shapes/Shape":43, "./shapes/Sphere":44, "./shapes/Trimesh":45, "./solver/GSSolver":46, "./solver/Solver":47, "./solver/SplitSolver":48, "./utils/EventTarget":49, "./utils/Pool":51, "./utils/Vec3Pool":54, "./world/Narrowphase":55, "./world/World":56}], 3:[function(h, l) {
    function b(b) {
      b = b || {};
      this.lowerBound = new f;
      b.lowerBound && this.lowerBound.copy(b.lowerBound);
      this.upperBound = new f;
      b.upperBound && this.upperBound.copy(b.upperBound);
    }
    var f = h("../math/Vec3");
    h("../utils/Utils");
    l.exports = b;
    var k = new f;
    b.prototype.setFromPoints = function(b, c, f, h) {
      var e = this.lowerBound, g = this.upperBound;
      e.copy(b[0]);
      f && f.vmult(e, e);
      g.copy(e);
      for (var p = 1;p < b.length;p++) {
        var r = b[p];
        f && (f.vmult(r, k), r = k);
        r.x > g.x && (g.x = r.x);
        r.x < e.x && (e.x = r.x);
        r.y > g.y && (g.y = r.y);
        r.y < e.y && (e.y = r.y);
        r.z > g.z && (g.z = r.z);
        r.z < e.z && (e.z = r.z);
      }
      return c && (c.vadd(e, e), c.vadd(g, g)), h && (e.x -= h, e.y -= h, e.z -= h, g.x += h, g.y += h, g.z += h), this;
    };
    b.prototype.copy = function(b) {
      return this.lowerBound.copy(b.lowerBound), this.upperBound.copy(b.upperBound), this;
    };
    b.prototype.clone = function() {
      return (new b).copy(this);
    };
    b.prototype.extend = function(b) {
      var c = b.lowerBound.x;
      this.lowerBound.x > c && (this.lowerBound.x = c);
      c = b.upperBound.x;
      this.upperBound.x < c && (this.upperBound.x = c);
      c = b.lowerBound.y;
      this.lowerBound.y > c && (this.lowerBound.y = c);
      c = b.upperBound.y;
      this.upperBound.y < c && (this.upperBound.y = c);
      c = b.lowerBound.z;
      this.lowerBound.z > c && (this.lowerBound.z = c);
      c = b.upperBound.z;
      this.upperBound.z < c && (this.upperBound.z = c);
    };
    b.prototype.overlaps = function(b) {
      var c = this.lowerBound, g = this.upperBound, f = b.lowerBound;
      b = b.upperBound;
      return (f.x <= g.x && g.x <= b.x || c.x <= b.x && b.x <= g.x) && (f.y <= g.y && g.y <= b.y || c.y <= b.y && b.y <= g.y) && (f.z <= g.z && g.z <= b.z || c.z <= b.z && b.z <= g.z);
    };
    b.prototype.contains = function(b) {
      var c = this.lowerBound, g = this.upperBound, f = b.lowerBound;
      b = b.upperBound;
      return c.x <= f.x && g.x >= b.x && c.y <= f.y && g.y >= b.y && c.z <= f.z && g.z >= b.z;
    };
    b.prototype.getCorners = function(b, c, f, k, h, n, l, v) {
      var e = this.lowerBound, g = this.upperBound;
      b.copy(e);
      c.set(g.x, e.y, e.z);
      f.set(g.x, g.y, e.z);
      k.set(e.x, g.y, g.z);
      h.set(g.x, e.y, e.z);
      n.set(e.x, g.y, e.z);
      l.set(e.x, e.y, g.z);
      v.copy(g);
    };
    var c = [new f, new f, new f, new f, new f, new f, new f, new f];
    b.prototype.toLocalFrame = function(b, e) {
      this.getCorners(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7]);
      for (var g = 0;8 !== g;g++) {
        var f = c[g];
        b.pointToLocal(f, f);
      }
      return e.setFromPoints(c);
    };
    b.prototype.toWorldFrame = function(b, e) {
      this.getCorners(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7]);
      for (var g = 0;8 !== g;g++) {
        var f = c[g];
        b.pointToWorld(f, f);
      }
      return e.setFromPoints(c);
    };
  }, {"../math/Vec3":30, "../utils/Utils":53}], 4:[function(h, l) {
    function b() {
      this.matrix = [];
    }
    l.exports = b;
    b.prototype.get = function(b, k) {
      if (b = b.index, k = k.index, k > b) {
        b = k = b;
      }
      return this.matrix[(b * (b + 1) >> 1) + k - 1];
    };
    b.prototype.set = function(b, k, c) {
      if (b = b.index, k = k.index, k > b) {
        b = k = b;
      }
      this.matrix[(b * (b + 1) >> 1) + k - 1] = c ? 1 : 0;
    };
    b.prototype.reset = function() {
      for (var b = 0, k = this.matrix.length;b !== k;b++) {
        this.matrix[b] = 0;
      }
    };
    b.prototype.setNumObjects = function(b) {
      this.matrix.length = b * (b - 1) >> 1;
    };
  }, {}], 5:[function(h, l) {
    function b() {
      this.world = null;
      this.useBoundingBoxes = !1;
      this.dirty = !0;
    }
    var f = h("../objects/Body"), k = h("../math/Vec3"), c = h("../math/Quaternion");
    h("../shapes/Shape");
    h("../shapes/Plane");
    l.exports = b;
    b.prototype.collisionPairs = function() {
      throw Error("collisionPairs not implemented for this BroadPhase class!");
    };
    var g = f.STATIC | f.KINEMATIC;
    b.prototype.needBroadphaseCollision = function(b, c) {
      return 0 === (b.collisionFilterGroup & c.collisionFilterMask) || 0 === (c.collisionFilterGroup & b.collisionFilterMask) ? !1 : 0 === (b.type & g) && b.sleepState !== f.SLEEPING || 0 === (c.type & g) && c.sleepState !== f.SLEEPING ? !0 : !1;
    };
    b.prototype.intersectionTest = function(b, c, e, g) {
      this.useBoundingBoxes ? this.doBoundingBoxBroadphase(b, c, e, g) : this.doBoundingSphereBroadphase(b, c, e, g);
    };
    var e = new k;
    new k;
    new c;
    new k;
    b.prototype.doBoundingSphereBroadphase = function(b, c, g, f) {
      c.position.vsub(b.position, e);
      var k = Math.pow(b.boundingRadius + c.boundingRadius, 2), p = e.norm2();
      k > p && (g.push(b), f.push(c));
    };
    b.prototype.doBoundingBoxBroadphase = function(b, c, e, g) {
      b.aabbNeedsUpdate && b.computeAABB();
      c.aabbNeedsUpdate && c.computeAABB();
      b.aabb.overlaps(c.aabb) && (e.push(b), g.push(c));
    };
    var p = {keys:[]}, r = [], w = [];
    b.prototype.makePairsUnique = function(b, c) {
      for (var e = b.length, g = 0;g !== e;g++) {
        r[g] = b[g], w[g] = c[g];
      }
      b.length = 0;
      for (g = c.length = 0;g !== e;g++) {
        var f = r[g].id, k = w[g].id, f = k > f ? f + "," + k : k + "," + f;
        p[f] = g;
        p.keys.push(f);
      }
      for (g = 0;g !== p.keys.length;g++) {
        f = p.keys.pop(), e = p[f], b.push(r[e]), c.push(w[e]), delete p[f];
      }
    };
    b.prototype.setWorld = function() {
    };
    var n = new k;
    b.boundingSphereCheck = function(b, c) {
      return b.position.vsub(c.position, n), Math.pow(b.shape.boundingSphereRadius + c.shape.boundingSphereRadius, 2) > n.norm2();
    };
    b.prototype.aabbQuery = function() {
      return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), [];
    };
  }, {"../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "../shapes/Plane":42, "../shapes/Shape":43}], 6:[function(h, l) {
    function b(b, c, g, h, n) {
      f.apply(this);
      this.nx = g || 10;
      this.ny = h || 10;
      this.nz = n || 10;
      this.aabbMin = b || new k(100, 100, 100);
      this.aabbMax = c || new k(-100, -100, -100);
      b = this.nx * this.ny * this.nz;
      if (0 >= b) {
        throw "GridBroadphase: Each dimension's n must be >0";
      }
      this.bins = [];
      this.binLengths = [];
      this.bins.length = b;
      this.binLengths.length = b;
      for (c = 0;b > c;c++) {
        this.bins[c] = [], this.binLengths[c] = 0;
      }
    }
    l.exports = b;
    var f = h("./Broadphase"), k = h("../math/Vec3"), c = h("../shapes/Shape");
    b.prototype = new f;
    b.prototype.constructor = b;
    var g = new k;
    new k;
    b.prototype.collisionPairs = function(b, f, k) {
      function e(b, c, e, g, f, k, p) {
        b = (b - z) * R | 0;
        c = (c - I) * L | 0;
        e = (e - J) * M | 0;
        g = S((g - z) * R);
        f = S((f - I) * L);
        k = S((k - J) * M);
        0 > b ? b = 0 : b >= l && (b = l - 1);
        0 > c ? c = 0 : c >= x && (c = x - 1);
        0 > e ? e = 0 : e >= q && (e = q - 1);
        0 > g ? g = 0 : g >= l && (g = l - 1);
        0 > f ? f = 0 : f >= x && (f = x - 1);
        0 > k ? k = 0 : k >= q && (k = q - 1);
        b *= u;
        c *= B;
        e *= C;
        g *= u;
        f *= B;
        for (k *= C;g >= b;b += u) {
          for (var h = c;f >= h;h += B) {
            for (var n = e;k >= n;n += C) {
              var r = b + h + n;
              Z[r][ea[r]++] = p;
            }
          }
        }
      }
      var p = b.numObjects();
      b = b.bodies;
      for (var h = this.aabbMax, r = this.aabbMin, l = this.nx, x = this.ny, q = this.nz, u = x * q, B = q, C = 1, D = h.x, F = h.y, E = h.z, z = r.x, I = r.y, J = r.z, R = l / (D - z), L = x / (F - I), M = q / (E - J), D = (D - z) / l, P = (F - I) / x, E = (E - J) / q, H = .5 * Math.sqrt(D * D + P * P + E * E), F = c.types, ba = F.SPHERE, ha = F.PLANE, Z = (F.BOX, F.COMPOUND, F.CONVEXPOLYHEDRON, this.bins), ea = this.binLengths, F = this.bins.length, r = 0;r !== F;r++) {
        ea[r] = 0;
      }
      for (var S = Math.ceil, r = Math.min, h = Math.max, r = 0;r !== p;r++) {
        var h = b[r], V = h.shape;
        switch(V.type) {
          case ba:
            var N = h.position.x, X = h.position.y, ia = h.position.z, V = V.radius;
            e(N - V, X - V, ia - V, N + V, X + V, ia + V, h);
            break;
          case ha:
            V.worldNormalNeedsUpdate && V.computeWorldNormal(h.quaternion);
            var ia = V.worldNormal, V = I + .5 * P - h.position.y, ta = J + .5 * E - h.position.z, T = g;
            T.set(z + .5 * D - h.position.x, V, ta);
            for (var ra = N = 0;N !== l;N++, ra += u, T.y = V, T.x += D) {
              for (var qa = X = 0;X !== x;X++, qa += B, T.z = ta, T.y += P) {
                for (var pa = 0, fa = 0;pa !== q;pa++, fa += C, T.z += E) {
                  if (T.dot(ia) < H) {
                    var W = ra + qa + fa;
                    Z[W][ea[W]++] = h;
                  }
                }
              }
            }
            break;
          default:
            h.aabbNeedsUpdate && h.computeAABB(), e(h.aabb.lowerBound.x, h.aabb.lowerBound.y, h.aabb.lowerBound.z, h.aabb.upperBound.x, h.aabb.upperBound.y, h.aabb.upperBound.z, h);
        }
      }
      for (r = 0;r !== F;r++) {
        if (p = ea[r], 1 < p) {
          for (b = Z[r], N = 0;N !== p;N++) {
            for (h = b[N], X = 0;X !== N;X++) {
              D = b[X], this.needBroadphaseCollision(h, D) && this.intersectionTest(h, D, f, k);
            }
          }
        }
      }
      this.makePairsUnique(f, k);
    };
  }, {"../math/Vec3":30, "../shapes/Shape":43, "./Broadphase":5}], 7:[function(h, l) {
    function b() {
      f.apply(this);
    }
    l.exports = b;
    var f = h("./Broadphase");
    h = h("./AABB");
    b.prototype = new f;
    b.prototype.constructor = b;
    b.prototype.collisionPairs = function(b, c, g) {
      var e, f, k, h = b.bodies, n = h.length;
      for (b = 0;b !== n;b++) {
        for (e = 0;e !== b;e++) {
          f = h[b], k = h[e], this.needBroadphaseCollision(f, k) && this.intersectionTest(f, k, c, g);
        }
      }
    };
    new h;
    b.prototype.aabbQuery = function(b, c, g) {
      g = g || [];
      for (var e = 0;e < b.bodies.length;e++) {
        var f = b.bodies[e];
        f.aabbNeedsUpdate && f.computeAABB();
        f.aabb.overlaps(c) && g.push(f);
      }
      return g;
    };
  }, {"./AABB":3, "./Broadphase":5}], 8:[function(h, l) {
    function b() {
      this.matrix = {};
    }
    l.exports = b;
    b.prototype.get = function(b, k) {
      if (b = b.id, k = k.id, k > b) {
        b = k = b;
      }
      return b + "-" + k in this.matrix;
    };
    b.prototype.set = function(b, k, c) {
      if (b = b.id, k = k.id, k > b) {
        b = k = b;
      }
      c ? this.matrix[b + "-" + k] = !0 : delete this.matrix[b + "-" + k];
    };
    b.prototype.reset = function() {
      this.matrix = {};
    };
    b.prototype.setNumObjects = function() {
    };
  }, {}], 9:[function(h, l) {
    function b(c, e) {
      this.from = c ? c.clone() : new k;
      this.to = e ? e.clone() : new k;
      this._direction = new k;
      this.precision = 1E-4;
      this.checkCollisionResponse = !0;
      this.skipBackfaces = !1;
      this.collisionFilterGroup = this.collisionFilterMask = -1;
      this.mode = b.ANY;
      this.result = new g;
      this.hasHit = !1;
      this.callback = function() {
      };
    }
    function f(b, c, e, g) {
      g.vsub(c, ba);
      e.vsub(c, w);
      b.vsub(c, n);
      var f, k;
      b = ba.dot(ba);
      c = ba.dot(w);
      e = ba.dot(n);
      g = w.dot(w);
      var q = w.dot(n);
      return 0 <= (f = g * e - c * q) && 0 <= (k = b * q - c * e) && b * g - c * c > f + k;
    }
    l.exports = b;
    var k = h("../math/Vec3");
    l = h("../math/Quaternion");
    var c = h("../math/Transform"), g = (h("../shapes/ConvexPolyhedron"), h("../shapes/Box"), h("../collision/RaycastResult")), e = h("../shapes/Shape");
    h = h("../collision/AABB");
    b.prototype.constructor = b;
    b.CLOSEST = 1;
    b.ANY = 2;
    b.ALL = 4;
    var p = new h, r = [];
    b.prototype.intersectWorld = function(c, e) {
      return this.mode = e.mode || b.ANY, this.result = e.result || new g, this.skipBackfaces = !!e.skipBackfaces, this.collisionFilterMask = "undefined" != typeof e.collisionFilterMask ? e.collisionFilterMask : -1, this.collisionFilterGroup = "undefined" != typeof e.collisionFilterGroup ? e.collisionFilterGroup : -1, e.from && this.from.copy(e.from), e.to && this.to.copy(e.to), this.callback = e.callback || function() {
      }, this.hasHit = !1, this.result.reset(), this._updateDirection(), this.getAABB(p), r.length = 0, c.broadphase.aabbQuery(c, p, r), this.intersectBodies(r), this.hasHit;
    };
    var w = new k, n = new k;
    b.pointInTriangle = f;
    var t = new k, v = new l;
    b.prototype.intersectBody = function(b, c) {
      c && (this.result = c, this._updateDirection());
      c = this.checkCollisionResponse;
      if ((!c || b.collisionResponse) && 0 !== (this.collisionFilterGroup & b.collisionFilterMask) && 0 !== (b.collisionFilterGroup & this.collisionFilterMask)) {
        for (var e = 0, g = b.shapes.length;g > e;e++) {
          var f = b.shapes[e];
          if ((!c || f.collisionResponse) && (b.quaternion.mult(b.shapeOrientations[e], v), b.quaternion.vmult(b.shapeOffsets[e], t), t.vadd(b.position, t), this.intersectShape(f, v, t, b), this.result._shouldStop)) {
            break;
          }
        }
      }
    };
    b.prototype.intersectBodies = function(b, c) {
      c && (this.result = c, this._updateDirection());
      c = 0;
      for (var e = b.length;!this.result._shouldStop && e > c;c++) {
        this.intersectBody(b[c]);
      }
    };
    b.prototype._updateDirection = function() {
      this.to.vsub(this.from, this._direction);
      this._direction.normalize();
    };
    b.prototype.intersectShape = function(b, c, e, g) {
      var f = this.from, k = this._direction;
      e.vsub(f, ba);
      var q = ba.dot(k);
      k.mult(q, ha);
      ha.vadd(f, ha);
      e.distanceTo(ha) > b.boundingSphereRadius || (f = this[b.type]) && f.call(this, b, c, e, g);
    };
    var y = (new k, new k, new k), x = new k, q = new k, u = new k;
    new k;
    new g;
    b.prototype.intersectBox = function(b, c, e, g) {
      return this.intersectConvex(b.convexPolyhedronRepresentation, c, e, g);
    };
    b.prototype[e.types.BOX] = b.prototype.intersectBox;
    b.prototype.intersectPlane = function(b, c, e, g) {
      var f = this.from, q = this.to, p = this._direction, h = new k(0, 0, 1);
      c.vmult(h, h);
      var n = new k;
      f.vsub(e, n);
      c = n.dot(h);
      q.vsub(e, n);
      n = n.dot(h);
      if (!(0 < c * n || f.distanceTo(q) < c || (n = h.dot(p), Math.abs(n) < this.precision))) {
        var r = new k, q = new k;
        c = new k;
        f.vsub(e, r);
        e = -h.dot(r) / n;
        p.scale(e, q);
        f.vadd(q, c);
        this.reportIntersection(h, c, b, g, -1);
      }
    };
    b.prototype[e.types.PLANE] = b.prototype.intersectPlane;
    b.prototype.getAABB = function(b) {
      var c = this.to, e = this.from;
      b.lowerBound.x = Math.min(c.x, e.x);
      b.lowerBound.y = Math.min(c.y, e.y);
      b.lowerBound.z = Math.min(c.z, e.z);
      b.upperBound.x = Math.max(c.x, e.x);
      b.upperBound.y = Math.max(c.y, e.y);
      b.upperBound.z = Math.max(c.z, e.z);
    };
    var B = {faceList:[0]};
    b.prototype.intersectHeightfield = function(e, g, f, q) {
      var p = (e.data, e.elementSize, new k), h = new b(this.from, this.to);
      c.pointToLocalFrame(f, g, h.from, h.from);
      c.pointToLocalFrame(f, g, h.to, h.to);
      var n = [], r = null, l = null, u = null, w = null, t = e.getIndexOfPosition(h.from.x, h.from.y, n, !1);
      if (t && (r = n[0], l = n[1], u = n[0], w = n[1]), t = e.getIndexOfPosition(h.to.x, h.to.y, n, !1), t && ((null === r || n[0] < r) && (r = n[0]), (null === u || n[0] > u) && (u = n[0]), (null === l || n[1] < l) && (l = n[1]), (null === w || n[1] > w) && (w = n[1])), null !== r) {
        for (h = [], e.getRectMinMax(r, l, u, w, h), r = (h[0], h[1], r);u >= r;r++) {
          for (h = l;w >= h;h++) {
            if (this.result._shouldStop || (e.getConvexTrianglePillar(r, h, !1), c.pointToWorldFrame(f, g, e.pillarOffset, p), this.intersectConvex(e.pillarConvex, g, p, q, B), this.result._shouldStop)) {
              return;
            }
            e.getConvexTrianglePillar(r, h, !0);
            c.pointToWorldFrame(f, g, e.pillarOffset, p);
            this.intersectConvex(e.pillarConvex, g, p, q, B);
          }
        }
      }
    };
    b.prototype[e.types.HEIGHTFIELD] = b.prototype.intersectHeightfield;
    var C = new k, D = new k;
    b.prototype.intersectSphere = function(b, c, e, g) {
      c = this.from;
      var f = this.to, k = Math.pow(f.x - c.x, 2) + Math.pow(f.y - c.y, 2) + Math.pow(f.z - c.z, 2), q = 2 * ((f.x - c.x) * (c.x - e.x) + (f.y - c.y) * (c.y - e.y) + (f.z - c.z) * (c.z - e.z)), p = Math.pow(q, 2) - 4 * k * (Math.pow(c.x - e.x, 2) + Math.pow(c.y - e.y, 2) + Math.pow(c.z - e.z, 2) - Math.pow(b.radius, 2));
      if (!(0 > p)) {
        if (0 === p) {
          c.lerp(f, p, C), C.vsub(e, D), D.normalize(), this.reportIntersection(D, C, b, g, -1);
        } else {
          var h = (-q - Math.sqrt(p)) / (2 * k), k = (-q + Math.sqrt(p)) / (2 * k);
          (0 <= h && 1 >= h && (c.lerp(f, h, C), C.vsub(e, D), D.normalize(), this.reportIntersection(D, C, b, g, -1)), this.result._shouldStop) || 0 <= k && 1 >= k && (c.lerp(f, k, C), C.vsub(e, D), D.normalize(), this.reportIntersection(D, C, b, g, -1));
        }
      }
    };
    b.prototype[e.types.SPHERE] = b.prototype.intersectSphere;
    var F = new k, E = (new k, new k, new k);
    b.prototype.intersectConvex = function(b, c, e, g, k) {
      k = k && k.faceList || null;
      for (var p = b.faces, h = b.vertices, n = b.faceNormals, r = this._direction, l = this.from, w = l.distanceTo(this.to), t = k ? k.length : p.length, v = this.result, B = 0;!v._shouldStop && t > B;B++) {
        var z = k ? k[B] : B, C = p[z], D = n[z], N = c, I = e;
        E.copy(h[C[0]]);
        N.vmult(E, E);
        E.vadd(I, E);
        E.vsub(l, E);
        N.vmult(D, F);
        D = r.dot(F);
        if (!(Math.abs(D) < this.precision || (D = F.dot(E) / D, 0 > D))) {
          for (r.mult(D, y), y.vadd(l, y), x.copy(h[C[0]]), N.vmult(x, x), I.vadd(x, x), D = 1;!v._shouldStop && D < C.length - 1;D++) {
            q.copy(h[C[D]]);
            u.copy(h[C[D + 1]]);
            N.vmult(q, q);
            N.vmult(u, u);
            I.vadd(q, q);
            I.vadd(u, u);
            var J = y.distanceTo(l);
            !f(y, x, q, u) && !f(y, q, x, u) || J > w || this.reportIntersection(F, y, b, g, z);
          }
        }
      }
    };
    b.prototype[e.types.CONVEXPOLYHEDRON] = b.prototype.intersectConvex;
    var z = new k, I = new k, J = new k, R = new k, L = new k, M = new k, P = (new h, []), H = new c;
    b.prototype.intersectTrimesh = function(b, e, g, k, p) {
      p = (p && p.faceList || null, b.indices);
      var h = (b.vertices, b.faceNormals, this.from), n = this.to, r = this._direction;
      H.position.copy(g);
      H.quaternion.copy(e);
      c.vectorToLocalFrame(g, e, r, I);
      c.pointToLocalFrame(g, e, h, J);
      c.pointToLocalFrame(g, e, n, R);
      h = J.distanceSquared(R);
      b.tree.rayQuery(this, H, P);
      n = 0;
      for (r = P.length;!this.result._shouldStop && n !== r;n++) {
        var l = P[n];
        b.getNormal(l, z);
        b.getVertex(p[3 * l], x);
        x.vsub(J, E);
        var w = I.dot(z), w = z.dot(E) / w;
        0 > w || (I.scale(w, y), y.vadd(J, y), b.getVertex(p[3 * l + 1], q), b.getVertex(p[3 * l + 2], u), w = y.distanceSquared(J), !f(y, q, x, u) && !f(y, x, q, u) || w > h || (c.vectorToWorldFrame(e, z, L), c.pointToWorldFrame(g, e, y, M), this.reportIntersection(L, M, b, k, l)));
      }
      P.length = 0;
    };
    b.prototype[e.types.TRIMESH] = b.prototype.intersectTrimesh;
    b.prototype.reportIntersection = function(c, e, g, f, k) {
      var q = this.from, p = this.to, h = q.distanceTo(e), n = this.result;
      if (!(this.skipBackfaces && 0 < c.dot(this._direction))) {
        switch(n.hitFaceIndex = "undefined" != typeof k ? k : -1, this.mode) {
          case b.ALL:
            this.hasHit = !0;
            n.set(q, p, c, e, g, f, h);
            n.hasHit = !0;
            this.callback(n);
            break;
          case b.CLOSEST:
            (h < n.distance || !n.hasHit) && (this.hasHit = !0, n.hasHit = !0, n.set(q, p, c, e, g, f, h));
            break;
          case b.ANY:
            this.hasHit = !0, n.hasHit = !0, n.set(q, p, c, e, g, f, h), n._shouldStop = !0;
        }
      }
    };
    var ba = new k, ha = new k;
  }, {"../collision/AABB":3, "../collision/RaycastResult":10, "../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "../shapes/Box":37, "../shapes/ConvexPolyhedron":38, "../shapes/Shape":43}], 10:[function(h, l) {
    function b() {
      this.rayFromWorld = new f;
      this.rayToWorld = new f;
      this.hitNormalWorld = new f;
      this.hitPointWorld = new f;
      this.hasHit = !1;
      this.body = this.shape = null;
      this.distance = this.hitFaceIndex = -1;
      this._shouldStop = !1;
    }
    var f = h("../math/Vec3");
    l.exports = b;
    b.prototype.reset = function() {
      this.rayFromWorld.setZero();
      this.rayToWorld.setZero();
      this.hitNormalWorld.setZero();
      this.hitPointWorld.setZero();
      this.hasHit = !1;
      this.body = this.shape = null;
      this.distance = this.hitFaceIndex = -1;
      this._shouldStop = !1;
    };
    b.prototype.abort = function() {
      this._shouldStop = !0;
    };
    b.prototype.set = function(b, c, g, e, f, h, l) {
      this.rayFromWorld.copy(b);
      this.rayToWorld.copy(c);
      this.hitNormalWorld.copy(g);
      this.hitPointWorld.copy(e);
      this.shape = f;
      this.body = h;
      this.distance = l;
    };
  }, {"../math/Vec3":30}], 11:[function(h, l) {
    function b(b) {
      f.apply(this);
      this.axisList = [];
      this.world = null;
      this.axisIndex = 0;
      var c = this.axisList;
      this._addBodyHandler = function(b) {
        c.push(b.body);
      };
      this._removeBodyHandler = function(b) {
        b = c.indexOf(b.body);
        -1 !== b && c.splice(b, 1);
      };
      b && this.setWorld(b);
    }
    var f = (h("../shapes/Shape"), h("../collision/Broadphase"));
    l.exports = b;
    b.prototype = new f;
    b.prototype.setWorld = function(b) {
      for (var c = this.axisList.length = 0;c < b.bodies.length;c++) {
        this.axisList.push(b.bodies[c]);
      }
      b.removeEventListener("addBody", this._addBodyHandler);
      b.removeEventListener("removeBody", this._removeBodyHandler);
      b.addEventListener("addBody", this._addBodyHandler);
      b.addEventListener("removeBody", this._removeBodyHandler);
      this.world = b;
      this.dirty = !0;
    };
    b.insertionSortX = function(b) {
      for (var c = 1, g = b.length;g > c;c++) {
        for (var e = b[c], f = c - 1;0 <= f && !(b[f].aabb.lowerBound.x <= e.aabb.lowerBound.x);f--) {
          b[f + 1] = b[f];
        }
        b[f + 1] = e;
      }
      return b;
    };
    b.insertionSortY = function(b) {
      for (var c = 1, g = b.length;g > c;c++) {
        for (var e = b[c], f = c - 1;0 <= f && !(b[f].aabb.lowerBound.y <= e.aabb.lowerBound.y);f--) {
          b[f + 1] = b[f];
        }
        b[f + 1] = e;
      }
      return b;
    };
    b.insertionSortZ = function(b) {
      for (var c = 1, g = b.length;g > c;c++) {
        for (var e = b[c], f = c - 1;0 <= f && !(b[f].aabb.lowerBound.z <= e.aabb.lowerBound.z);f--) {
          b[f + 1] = b[f];
        }
        b[f + 1] = e;
      }
      return b;
    };
    b.prototype.collisionPairs = function(f, c, g) {
      var e, k = this.axisList, h = k.length, l = this.axisIndex;
      this.dirty && (this.sortList(), this.dirty = !1);
      for (f = 0;f !== h;f++) {
        var n = k[f];
        for (e = f + 1;h > e;e++) {
          var t = k[e];
          if (this.needBroadphaseCollision(n, t)) {
            if (!b.checkBounds(n, t, l)) {
              break;
            }
            this.intersectionTest(n, t, c, g);
          }
        }
      }
    };
    b.prototype.sortList = function() {
      for (var f = this.axisList, c = this.axisIndex, g = f.length, e = 0;e !== g;e++) {
        var p = f[e];
        p.aabbNeedsUpdate && p.computeAABB();
      }
      0 === c ? b.insertionSortX(f) : 1 === c ? b.insertionSortY(f) : 2 === c && b.insertionSortZ(f);
    };
    b.checkBounds = function(b, c, g) {
      var e, f;
      0 === g ? (e = b.position.x, f = c.position.x) : 1 === g ? (e = b.position.y, f = c.position.y) : 2 === g && (e = b.position.z, f = c.position.z);
      return e + b.boundingRadius > f - c.boundingRadius;
    };
    b.prototype.autoDetectAxis = function() {
      for (var b = 0, c = 0, g = 0, e = 0, f = 0, h = 0, l = this.axisList, n = l.length, t = 1 / n, v = 0;v !== n;v++) {
        var y = l[v], x = y.position.x, b = b + x, c = c + x * x, x = y.position.y, g = g + x, e = e + x * x, y = y.position.z, f = f + y, h = h + y * y;
      }
      b = c - b * b * t;
      g = e - g * g * t;
      f = h - f * f * t;
      this.axisIndex = b > g ? b > f ? 0 : 2 : g > f ? 1 : 2;
    };
    b.prototype.aabbQuery = function(b, c, g) {
      g = g || [];
      this.dirty && (this.sortList(), this.dirty = !1);
      b = this.axisIndex;
      var e = "x";
      1 === b && (e = "y");
      2 === b && (e = "z");
      b = this.axisList;
      for (e = (c.lowerBound[e], c.upperBound[e], 0);e < b.length;e++) {
        var f = b[e];
        f.aabbNeedsUpdate && f.computeAABB();
        f.aabb.overlaps(c) && g.push(f);
      }
      return g;
    };
  }, {"../collision/Broadphase":5, "../shapes/Shape":43}], 12:[function(h, l) {
    function b(b, p, h) {
      h = h || {};
      var e = "undefined" != typeof h.maxForce ? h.maxForce : 1E6, n = h.pivotA ? h.pivotA.clone() : new g, r = h.pivotB ? h.pivotB.clone() : new g;
      this.axisA = h.axisA ? h.axisA.clone() : new g;
      this.axisB = h.axisB ? h.axisB.clone() : new g;
      f.call(this, b, n, p, r, e);
      this.collideConnected = !!h.collideConnected;
      this.angle = "undefined" != typeof h.angle ? h.angle : 0;
      n = this.coneEquation = new k(b, p, h);
      b = this.twistEquation = new c(b, p, h);
      this.twistAngle = "undefined" != typeof h.twistAngle ? h.twistAngle : 0;
      n.maxForce = 0;
      n.minForce = -e;
      b.maxForce = 0;
      b.minForce = -e;
      this.equations.push(n, b);
    }
    l.exports = b;
    var f = (h("./Constraint"), h("./PointToPointConstraint")), k = h("../equations/ConeEquation"), c = h("../equations/RotationalEquation"), g = (h("../equations/ContactEquation"), h("../math/Vec3"));
    b.prototype = new f;
    b.constructor = b;
    new g;
    new g;
    b.prototype.update = function() {
      var b = this.bodyA, c = this.bodyB, g = this.coneEquation, k = this.twistEquation;
      f.prototype.update.call(this);
      b.vectorToWorldFrame(this.axisA, g.axisA);
      c.vectorToWorldFrame(this.axisB, g.axisB);
      this.axisA.tangents(k.axisA, k.axisA);
      b.vectorToWorldFrame(k.axisA, k.axisA);
      this.axisB.tangents(k.axisB, k.axisB);
      c.vectorToWorldFrame(k.axisB, k.axisB);
      g.angle = this.angle;
      k.maxAngle = this.twistAngle;
    };
  }, {"../equations/ConeEquation":18, "../equations/ContactEquation":19, "../equations/RotationalEquation":22, "../math/Vec3":30, "./Constraint":13, "./PointToPointConstraint":17}], 13:[function(h, l) {
    function b(k, c, g) {
      g = f.defaults(g, {collideConnected:!0, wakeUpBodies:!0});
      this.equations = [];
      this.bodyA = k;
      this.bodyB = c;
      this.id = b.idCounter++;
      this.collideConnected = g.collideConnected;
      g.wakeUpBodies && (k && k.wakeUp(), c && c.wakeUp());
    }
    l.exports = b;
    var f = h("../utils/Utils");
    b.prototype.update = function() {
      throw Error("method update() not implmemented in this Constraint subclass!");
    };
    b.prototype.enable = function() {
      for (var b = this.equations, c = 0;c < b.length;c++) {
        b[c].enabled = !0;
      }
    };
    b.prototype.disable = function() {
      for (var b = this.equations, c = 0;c < b.length;c++) {
        b[c].enabled = !1;
      }
    };
    b.idCounter = 0;
  }, {"../utils/Utils":53}], 14:[function(h, l) {
    function b(b, g, e, p) {
      f.call(this, b, g);
      "undefined" == typeof e && (e = b.position.distanceTo(g.position));
      "undefined" == typeof p && (p = 1E6);
      this.distance = e;
      b = this.distanceEquation = new k(b, g);
      this.equations.push(b);
      b.minForce = -p;
      b.maxForce = p;
    }
    l.exports = b;
    var f = h("./Constraint"), k = h("../equations/ContactEquation");
    b.prototype = new f;
    b.prototype.update = function() {
      var b = this.distanceEquation, g = .5 * this.distance, e = b.ni;
      this.bodyB.position.vsub(this.bodyA.position, e);
      e.normalize();
      e.mult(g, b.ri);
      e.mult(-g, b.rj);
    };
  }, {"../equations/ContactEquation":19, "./Constraint":13}], 15:[function(h, l) {
    function b(b, e, p) {
      p = p || {};
      var h = "undefined" != typeof p.maxForce ? p.maxForce : 1E6, n = p.pivotA ? p.pivotA.clone() : new g, r = p.pivotB ? p.pivotB.clone() : new g;
      f.call(this, b, n, e, r, h);
      (this.axisA = p.axisA ? p.axisA.clone() : new g(1, 0, 0)).normalize();
      (this.axisB = p.axisB ? p.axisB.clone() : new g(1, 0, 0)).normalize();
      n = this.rotationalEquation1 = new k(b, e, p);
      p = this.rotationalEquation2 = new k(b, e, p);
      b = this.motorEquation = new c(b, e, h);
      b.enabled = !1;
      this.equations.push(n, p, b);
    }
    l.exports = b;
    var f = (h("./Constraint"), h("./PointToPointConstraint")), k = h("../equations/RotationalEquation"), c = h("../equations/RotationalMotorEquation"), g = (h("../equations/ContactEquation"), h("../math/Vec3"));
    b.prototype = new f;
    b.constructor = b;
    b.prototype.enableMotor = function() {
      this.motorEquation.enabled = !0;
    };
    b.prototype.disableMotor = function() {
      this.motorEquation.enabled = !1;
    };
    b.prototype.setMotorSpeed = function(b) {
      this.motorEquation.targetVelocity = b;
    };
    b.prototype.setMotorMaxForce = function(b) {
      this.motorEquation.maxForce = b;
      this.motorEquation.minForce = -b;
    };
    var e = new g, p = new g;
    b.prototype.update = function() {
      var b = this.bodyA, c = this.bodyB, g = this.motorEquation, k = this.rotationalEquation1, h = this.rotationalEquation2, l = this.axisA, x = this.axisB;
      f.prototype.update.call(this);
      b.quaternion.vmult(l, e);
      c.quaternion.vmult(x, p);
      e.tangents(k.axisA, h.axisA);
      k.axisB.copy(p);
      h.axisB.copy(p);
      this.motorEquation.enabled && (b.quaternion.vmult(this.axisA, g.axisA), c.quaternion.vmult(this.axisB, g.axisB));
    };
  }, {"../equations/ContactEquation":19, "../equations/RotationalEquation":22, "../equations/RotationalMotorEquation":23, "../math/Vec3":30, "./Constraint":13, "./PointToPointConstraint":17}], 16:[function(h, l) {
    function b(b, e, p) {
      p = p || {};
      var g = "undefined" != typeof p.maxForce ? p.maxForce : 1E6, h = new c, n = new c, l = new c;
      b.position.vadd(e.position, l);
      l.scale(.5, l);
      e.pointToLocalFrame(l, n);
      b.pointToLocalFrame(l, h);
      f.call(this, b, h, e, n, g);
      g = this.rotationalEquation1 = new k(b, e, p);
      h = this.rotationalEquation2 = new k(b, e, p);
      b = this.rotationalEquation3 = new k(b, e, p);
      this.equations.push(g, h, b);
    }
    l.exports = b;
    var f = (h("./Constraint"), h("./PointToPointConstraint")), k = h("../equations/RotationalEquation"), c = (h("../equations/RotationalMotorEquation"), h("../equations/ContactEquation"), h("../math/Vec3"));
    b.prototype = new f;
    b.constructor = b;
    new c;
    new c;
    b.prototype.update = function() {
      var b = this.bodyA, e = this.bodyB, k = (this.motorEquation, this.rotationalEquation1), h = this.rotationalEquation2, l = this.rotationalEquation3;
      f.prototype.update.call(this);
      b.vectorToWorldFrame(c.UNIT_X, k.axisA);
      e.vectorToWorldFrame(c.UNIT_Y, k.axisB);
      b.vectorToWorldFrame(c.UNIT_Y, h.axisA);
      e.vectorToWorldFrame(c.UNIT_Z, h.axisB);
      b.vectorToWorldFrame(c.UNIT_Z, l.axisA);
      e.vectorToWorldFrame(c.UNIT_X, l.axisB);
    };
  }, {"../equations/ContactEquation":19, "../equations/RotationalEquation":22, "../equations/RotationalMotorEquation":23, "../math/Vec3":30, "./Constraint":13, "./PointToPointConstraint":17}], 17:[function(h, l) {
    function b(b, e, p, h, l) {
      f.call(this, b, p);
      l = "undefined" != typeof l ? l : 1E6;
      this.pivotA = e ? e.clone() : new c;
      this.pivotB = h ? h.clone() : new c;
      e = this.equationX = new k(b, p);
      h = this.equationY = new k(b, p);
      b = this.equationZ = new k(b, p);
      this.equations.push(e, h, b);
      e.minForce = h.minForce = b.minForce = -l;
      e.maxForce = h.maxForce = b.maxForce = l;
      e.ni.set(1, 0, 0);
      h.ni.set(0, 1, 0);
      b.ni.set(0, 0, 1);
    }
    l.exports = b;
    var f = h("./Constraint"), k = h("../equations/ContactEquation"), c = h("../math/Vec3");
    b.prototype = new f;
    b.prototype.update = function() {
      var b = this.bodyB, c = this.equationX, f = this.equationY, k = this.equationZ;
      this.bodyA.quaternion.vmult(this.pivotA, c.ri);
      b.quaternion.vmult(this.pivotB, c.rj);
      f.ri.copy(c.ri);
      f.rj.copy(c.rj);
      k.ri.copy(c.ri);
      k.rj.copy(c.rj);
    };
  }, {"../equations/ContactEquation":19, "../math/Vec3":30, "./Constraint":13}], 18:[function(h, l) {
    function b(b, c, g) {
      g = g || {};
      var e = "undefined" != typeof g.maxForce ? g.maxForce : 1E6;
      k.call(this, b, c, -e, e);
      this.axisA = g.axisA ? g.axisA.clone() : new f(1, 0, 0);
      this.axisB = g.axisB ? g.axisB.clone() : new f(0, 1, 0);
      this.angle = "undefined" != typeof g.angle ? g.angle : 0;
    }
    l.exports = b;
    var f = h("../math/Vec3"), k = (h("../math/Mat3"), h("./Equation"));
    b.prototype = new k;
    b.prototype.constructor = b;
    var c = new f, g = new f;
    b.prototype.computeB = function(b) {
      var e = this.a, f = this.b, k = this.axisA, h = this.axisB, l = this.jacobianElementA, v = this.jacobianElementB;
      k.cross(h, c);
      h.cross(k, g);
      l.rotational.copy(g);
      v.rotational.copy(c);
      k = Math.cos(this.angle) - k.dot(h);
      h = this.computeGW();
      l = this.computeGiMf();
      return -k * e - h * f - b * l;
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 19:[function(h, l) {
    function b(b, c, e) {
      f.call(this, b, c, 0, "undefined" != typeof e ? e : 1E6);
      this.restitution = 0;
      this.ri = new k;
      this.rj = new k;
      this.ni = new k;
    }
    l.exports = b;
    var f = h("./Equation"), k = h("../math/Vec3");
    h("../math/Mat3");
    b.prototype = new f;
    b.prototype.constructor = b;
    var c = new k, g = new k, e = new k;
    b.prototype.computeB = function(b) {
      var f = this.a, k = this.b, q = this.bi, h = this.bj, p = this.ri, n = this.rj, r = q.velocity, l = q.angularVelocity, w = (q.force, q.torque, h.velocity), t = h.angularVelocity, v = (h.force, h.torque, e), J = this.jacobianElementA, R = this.jacobianElementB, L = this.ni;
      p.cross(L, c);
      n.cross(L, g);
      L.negate(J.spatial);
      c.negate(J.rotational);
      R.spatial.copy(L);
      R.rotational.copy(g);
      v.copy(h.position);
      v.vadd(n, v);
      v.vsub(q.position, v);
      v.vsub(p, v);
      q = L.dot(v);
      h = this.restitution + 1;
      r = h * w.dot(L) - h * r.dot(L) + t.dot(g) - l.dot(c);
      l = this.computeGiMf();
      return -q * f - r * k - b * l;
    };
    var p = new k, r = new k, w = new k, n = new k, t = new k;
    b.prototype.getImpactVelocityAlongNormal = function() {
      return this.bi.position.vadd(this.ri, w), this.bj.position.vadd(this.rj, n), this.bi.getVelocityAtWorldPoint(w, p), this.bj.getVelocityAtWorldPoint(n, r), p.vsub(r, t), this.ni.dot(t);
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 20:[function(h, l) {
    function b(c, e, g, k) {
      this.id = b.id++;
      this.minForce = "undefined" == typeof g ? -1E6 : g;
      this.maxForce = "undefined" == typeof k ? 1E6 : k;
      this.bi = c;
      this.bj = e;
      this.eps = this.b = this.a = 0;
      this.jacobianElementA = new f;
      this.jacobianElementB = new f;
      this.enabled = !0;
      this.setSpookParams(1E7, 4, 1 / 60);
    }
    l.exports = b;
    var f = h("../math/JacobianElement");
    h = h("../math/Vec3");
    b.prototype.constructor = b;
    b.id = 0;
    b.prototype.setSpookParams = function(b, c, e) {
      this.a = 4 / (e * (1 + 4 * c));
      this.b = 4 * c / (1 + 4 * c);
      this.eps = 4 / (e * e * b * (1 + 4 * c));
    };
    b.prototype.computeB = function(b, c, e) {
      var g = this.computeGW(), f = this.computeGq(), k = this.computeGiMf();
      return -f * b - g * c - k * e;
    };
    b.prototype.computeGq = function() {
      var b = this.jacobianElementB, c = this.bj.position;
      return this.jacobianElementA.spatial.dot(this.bi.position) + b.spatial.dot(c);
    };
    var k = new h;
    b.prototype.computeGW = function() {
      var b = this.jacobianElementB, c = this.bi, e = this.bj, g = e.velocity, e = e.angularVelocity || k;
      return this.jacobianElementA.multiplyVectors(c.velocity, c.angularVelocity || k) + b.multiplyVectors(g, e);
    };
    b.prototype.computeGWlambda = function() {
      var b = this.jacobianElementB, c = this.bi, e = this.bj, g = e.vlambda, e = e.wlambda || k;
      return this.jacobianElementA.multiplyVectors(c.vlambda, c.wlambda || k) + b.multiplyVectors(g, e);
    };
    var c = new h, g = new h, e = new h, p = new h;
    b.prototype.computeGiMf = function() {
      var b = this.jacobianElementA, f = this.jacobianElementB, k = this.bi, h = this.bj, r = k.force, q = k.torque, l = h.force, w = h.torque, C = k.invMassSolve, D = h.invMassSolve;
      return k.invInertiaWorldSolve ? k.invInertiaWorldSolve.vmult(q, e) : e.set(0, 0, 0), h.invInertiaWorldSolve ? h.invInertiaWorldSolve.vmult(w, p) : p.set(0, 0, 0), r.mult(C, c), l.mult(D, g), b.multiplyVectors(c, e) + f.multiplyVectors(g, p);
    };
    var r = new h;
    b.prototype.computeGiMGt = function() {
      var b = this.jacobianElementA, c = this.jacobianElementB, e = this.bi, g = this.bj, f = e.invInertiaWorldSolve, k = g.invInertiaWorldSolve, e = e.invMassSolve + g.invMassSolve;
      return f && (f.vmult(b.rotational, r), e += r.dot(b.rotational)), k && (k.vmult(c.rotational, r), e += r.dot(c.rotational)), e;
    };
    var w = new h;
    new h;
    new h;
    new h;
    new h;
    new h;
    b.prototype.addToWlambda = function(b) {
      var c = this.jacobianElementA, e = this.jacobianElementB, g = this.bi, f = this.bj;
      c.spatial.mult(g.invMassSolve * b, w);
      g.vlambda.vadd(w, g.vlambda);
      e.spatial.mult(f.invMassSolve * b, w);
      f.vlambda.vadd(w, f.vlambda);
      g.invInertiaWorldSolve && (g.invInertiaWorldSolve.vmult(c.rotational, w), w.mult(b, w), g.wlambda.vadd(w, g.wlambda));
      f.invInertiaWorldSolve && (f.invInertiaWorldSolve.vmult(e.rotational, w), w.mult(b, w), f.wlambda.vadd(w, f.wlambda));
    };
    b.prototype.computeC = function() {
      return this.computeGiMGt() + this.eps;
    };
  }, {"../math/JacobianElement":26, "../math/Vec3":30}], 21:[function(h, l) {
    function b(b, c, g) {
      f.call(this, b, c, -g, g);
      this.ri = new k;
      this.rj = new k;
      this.t = new k;
    }
    l.exports = b;
    var f = h("./Equation"), k = h("../math/Vec3");
    h("../math/Mat3");
    b.prototype = new f;
    b.prototype.constructor = b;
    var c = new k, g = new k;
    b.prototype.computeB = function(b) {
      var e = (this.a, this.b), f = (this.bi, this.bj, this.ri), k = this.rj, h = this.t;
      f.cross(h, c);
      k.cross(h, g);
      f = this.jacobianElementA;
      k = this.jacobianElementB;
      h.negate(f.spatial);
      c.negate(f.rotational);
      k.spatial.copy(h);
      k.rotational.copy(g);
      h = this.computeGW();
      f = this.computeGiMf();
      return -h * e - b * f;
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 22:[function(h, l) {
    function b(b, c, g) {
      g = g || {};
      var e = "undefined" != typeof g.maxForce ? g.maxForce : 1E6;
      k.call(this, b, c, -e, e);
      this.axisA = g.axisA ? g.axisA.clone() : new f(1, 0, 0);
      this.axisB = g.axisB ? g.axisB.clone() : new f(0, 1, 0);
      this.maxAngle = Math.PI / 2;
    }
    l.exports = b;
    var f = h("../math/Vec3"), k = (h("../math/Mat3"), h("./Equation"));
    b.prototype = new k;
    b.prototype.constructor = b;
    var c = new f, g = new f;
    b.prototype.computeB = function(b) {
      var e = this.a, f = this.b, k = this.axisA, h = this.axisB, l = this.jacobianElementA, v = this.jacobianElementB;
      k.cross(h, c);
      h.cross(k, g);
      l.rotational.copy(g);
      v.rotational.copy(c);
      k = Math.cos(this.maxAngle) - k.dot(h);
      h = this.computeGW();
      l = this.computeGiMf();
      return -k * e - h * f - b * l;
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 23:[function(h, l) {
    function b(b, g, e) {
      e = "undefined" != typeof e ? e : 1E6;
      k.call(this, b, g, -e, e);
      this.axisA = new f;
      this.axisB = new f;
      this.targetVelocity = 0;
    }
    l.exports = b;
    var f = h("../math/Vec3"), k = (h("../math/Mat3"), h("./Equation"));
    b.prototype = new k;
    b.prototype.constructor = b;
    b.prototype.computeB = function(b) {
      var c = (this.a, this.b), e = (this.bi, this.bj, this.axisA), f = this.axisB, k = this.jacobianElementB;
      this.jacobianElementA.rotational.copy(e);
      f.negate(k.rotational);
      e = this.computeGW() - this.targetVelocity;
      f = this.computeGiMf();
      return -e * c - b * f;
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 24:[function(h, l) {
    function b(k, c, g) {
      g = f.defaults(g, {friction:.3, restitution:.3, contactEquationStiffness:1E7, contactEquationRelaxation:3, frictionEquationStiffness:1E7, frictionEquationRelaxation:3});
      this.id = b.idCounter++;
      this.materials = [k, c];
      this.friction = g.friction;
      this.restitution = g.restitution;
      this.contactEquationStiffness = g.contactEquationStiffness;
      this.contactEquationRelaxation = g.contactEquationRelaxation;
      this.frictionEquationStiffness = g.frictionEquationStiffness;
      this.frictionEquationRelaxation = g.frictionEquationRelaxation;
    }
    var f = h("../utils/Utils");
    l.exports = b;
    b.idCounter = 0;
  }, {"../utils/Utils":53}], 25:[function(h, l) {
    function b(f) {
      var k = "";
      f = f || {};
      "string" == typeof f ? (k = f, f = {}) : "object" == typeof f && (k = "");
      this.name = k;
      this.id = b.idCounter++;
      this.friction = "undefined" != typeof f.friction ? f.friction : -1;
      this.restitution = "undefined" != typeof f.restitution ? f.restitution : -1;
    }
    l.exports = b;
    b.idCounter = 0;
  }, {}], 26:[function(h, l) {
    function b() {
      this.spatial = new f;
      this.rotational = new f;
    }
    l.exports = b;
    var f = h("./Vec3");
    b.prototype.multiplyElement = function(b) {
      return b.spatial.dot(this.spatial) + b.rotational.dot(this.rotational);
    };
    b.prototype.multiplyVectors = function(b, c) {
      return b.dot(this.spatial) + c.dot(this.rotational);
    };
  }, {"./Vec3":30}], 27:[function(h, l) {
    function b(b) {
      this.elements = b ? b : [0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    l.exports = b;
    var f = h("./Vec3");
    b.prototype.identity = function() {
      var b = this.elements;
      b[0] = 1;
      b[1] = 0;
      b[2] = 0;
      b[3] = 0;
      b[4] = 1;
      b[5] = 0;
      b[6] = 0;
      b[7] = 0;
      b[8] = 1;
    };
    b.prototype.setZero = function() {
      var b = this.elements;
      b[0] = 0;
      b[1] = 0;
      b[2] = 0;
      b[3] = 0;
      b[4] = 0;
      b[5] = 0;
      b[6] = 0;
      b[7] = 0;
      b[8] = 0;
    };
    b.prototype.setTrace = function(b) {
      var c = this.elements;
      c[0] = b.x;
      c[4] = b.y;
      c[8] = b.z;
    };
    b.prototype.getTrace = function(b) {
      b = b || new f;
      var c = this.elements;
      b.x = c[0];
      b.y = c[4];
      b.z = c[8];
    };
    b.prototype.vmult = function(b, c) {
      c = c || new f;
      var g = this.elements, e = b.x, k = b.y;
      b = b.z;
      return c.x = g[0] * e + g[1] * k + g[2] * b, c.y = g[3] * e + g[4] * k + g[5] * b, c.z = g[6] * e + g[7] * k + g[8] * b, c;
    };
    b.prototype.smult = function(b) {
      for (var c = 0;c < this.elements.length;c++) {
        this.elements[c] *= b;
      }
    };
    b.prototype.mmult = function(f, c) {
      c = c || new b;
      for (var g = 0;3 > g;g++) {
        for (var e = 0;3 > e;e++) {
          for (var k = 0, h = 0;3 > h;h++) {
            k += f.elements[g + 3 * h] * this.elements[h + 3 * e];
          }
          c.elements[g + 3 * e] = k;
        }
      }
      return c;
    };
    b.prototype.scale = function(f, c) {
      c = c || new b;
      for (var g = this.elements, e = c.elements, k = 0;3 !== k;k++) {
        e[3 * k + 0] = f.x * g[3 * k + 0], e[3 * k + 1] = f.y * g[3 * k + 1], e[3 * k + 2] = f.z * g[3 * k + 2];
      }
      return c;
    };
    b.prototype.solve = function(b, c) {
      c = c || new f;
      for (var g = [], e = 0;12 > e;e++) {
        g.push(0);
      }
      for (var k, e = 0;3 > e;e++) {
        for (k = 0;3 > k;k++) {
          g[e + 4 * k] = this.elements[e + 3 * k];
        }
      }
      g[3] = b.x;
      g[7] = b.y;
      g[11] = b.z;
      var h, l, n = 3, t = n;
      do {
        if (e = t - n, 0 === g[e + 4 * e]) {
          for (k = e + 1;t > k;k++) {
            if (0 !== g[e + 4 * k]) {
              h = 4;
              do {
                l = 4 - h, g[l + 4 * e] += g[l + 4 * k];
              } while (--h);
              break;
            }
          }
        }
        if (0 !== g[e + 4 * e]) {
          for (k = e + 1;t > k;k++) {
            var v = g[e + 4 * k] / g[e + 4 * e];
            h = 4;
            do {
              l = 4 - h, g[l + 4 * k] = e >= l ? 0 : g[l + 4 * k] - g[l + 4 * e] * v;
            } while (--h);
          }
        }
      } while (--n);
      if (c.z = g[11] / g[10], c.y = (g[7] - g[6] * c.z) / g[5], c.x = (g[3] - g[2] * c.z - g[1] * c.y) / g[0], isNaN(c.x) || isNaN(c.y) || isNaN(c.z) || 1 / 0 === c.x || 1 / 0 === c.y || 1 / 0 === c.z) {
        throw "Could not solve equation! Got x=[" + c.toString() + "], b=[" + b.toString() + "], A=[" + this.toString() + "]";
      }
      return c;
    };
    b.prototype.e = function(b, c, g) {
      return void 0 === g ? this.elements[c + 3 * b] : void(this.elements[c + 3 * b] = g);
    };
    b.prototype.copy = function(b) {
      for (var c = 0;c < b.elements.length;c++) {
        this.elements[c] = b.elements[c];
      }
      return this;
    };
    b.prototype.toString = function() {
      for (var b = "", c = 0;9 > c;c++) {
        b += this.elements[c] + ",";
      }
      return b;
    };
    b.prototype.reverse = function(f) {
      f = f || new b;
      for (var c = [], g = 0;18 > g;g++) {
        c.push(0);
      }
      for (var e, g = 0;3 > g;g++) {
        for (e = 0;3 > e;e++) {
          c[g + 6 * e] = this.elements[g + 3 * e];
        }
      }
      c[3] = 1;
      c[9] = 0;
      c[15] = 0;
      c[4] = 0;
      c[10] = 1;
      c[16] = 0;
      c[5] = 0;
      c[11] = 0;
      c[17] = 1;
      var k, h, l = 3, n = l;
      do {
        if (g = n - l, 0 === c[g + 6 * g]) {
          for (e = g + 1;n > e;e++) {
            if (0 !== c[g + 6 * e]) {
              k = 6;
              do {
                h = 6 - k, c[h + 6 * g] += c[h + 6 * e];
              } while (--k);
              break;
            }
          }
        }
        if (0 !== c[g + 6 * g]) {
          for (e = g + 1;n > e;e++) {
            var t = c[g + 6 * e] / c[g + 6 * g];
            k = 6;
            do {
              h = 6 - k, c[h + 6 * e] = g >= h ? 0 : c[h + 6 * e] - c[h + 6 * g] * t;
            } while (--k);
          }
        }
      } while (--l);
      g = 2;
      do {
        e = g - 1;
        do {
          t = c[g + 6 * e] / c[g + 6 * g];
          k = 6;
          do {
            h = 6 - k, c[h + 6 * e] -= c[h + 6 * g] * t;
          } while (--k);
        } while (e--);
      } while (--g);
      g = 2;
      do {
        t = 1 / c[g + 6 * g];
        k = 6;
        do {
          h = 6 - k, c[h + 6 * g] *= t;
        } while (--k);
      } while (g--);
      g = 2;
      do {
        e = 2;
        do {
          if (h = c[3 + e + 6 * g], isNaN(h) || 1 / 0 === h) {
            throw "Could not reverse! A=[" + this.toString() + "]";
          }
          f.e(g, e, h);
        } while (e--);
      } while (g--);
      return f;
    };
    b.prototype.setRotationFromQuaternion = function(b) {
      var c = b.x, g = b.y, e = b.z, f = b.w, k = c + c, h = g + g, n = e + e;
      b = c * k;
      var l = c * h, c = c * n, v = g * h, g = g * n, e = e * n, k = f * k, h = f * h, f = f * n, n = this.elements;
      return n[0] = 1 - (v + e), n[1] = l - f, n[2] = c + h, n[3] = l + f, n[4] = 1 - (b + e), n[5] = g - k, n[6] = c - h, n[7] = g + k, n[8] = 1 - (b + v), this;
    };
    b.prototype.transpose = function(f) {
      f = f || new b;
      for (var c = f.elements, g = this.elements, e = 0;3 !== e;e++) {
        for (var k = 0;3 !== k;k++) {
          c[3 * e + k] = g[3 * k + e];
        }
      }
      return f;
    };
  }, {"./Vec3":30}], 28:[function(h, l) {
    function b(b, c, e, g) {
      this.x = void 0 !== b ? b : 0;
      this.y = void 0 !== c ? c : 0;
      this.z = void 0 !== e ? e : 0;
      this.w = void 0 !== g ? g : 1;
    }
    l.exports = b;
    var f = h("./Vec3");
    b.prototype.set = function(b, c, e, g) {
      this.x = b;
      this.y = c;
      this.z = e;
      this.w = g;
    };
    b.prototype.toString = function() {
      return this.x + "," + this.y + "," + this.z + "," + this.w;
    };
    b.prototype.toArray = function() {
      return [this.x, this.y, this.z, this.w];
    };
    b.prototype.setFromAxisAngle = function(b, c) {
      var e = Math.sin(.5 * c);
      this.x = b.x * e;
      this.y = b.y * e;
      this.z = b.z * e;
      this.w = Math.cos(.5 * c);
    };
    b.prototype.toAxisAngle = function(b) {
      b = b || new f;
      this.normalize();
      var c = 2 * Math.acos(this.w), e = Math.sqrt(1 - this.w * this.w);
      return .001 > e ? (b.x = this.x, b.y = this.y, b.z = this.z) : (b.x = this.x / e, b.y = this.y / e, b.z = this.z / e), [b, c];
    };
    var k = new f, c = new f;
    b.prototype.setFromVectors = function(b, e) {
      if (b.isAntiparallelTo(e)) {
        b.tangents(k, c), this.setFromAxisAngle(k, Math.PI);
      } else {
        var g = b.cross(e);
        this.x = g.x;
        this.y = g.y;
        this.z = g.z;
        this.w = Math.sqrt(Math.pow(b.norm(), 2) * Math.pow(e.norm(), 2)) + b.dot(e);
        this.normalize();
      }
    };
    var g = new f, e = new f, p = new f;
    b.prototype.mult = function(c, f) {
      f = f || new b;
      var k = this.w;
      return g.set(this.x, this.y, this.z), e.set(c.x, c.y, c.z), f.w = k * c.w - g.dot(e), g.cross(e, p), f.x = k * e.x + c.w * g.x + p.x, f.y = k * e.y + c.w * g.y + p.y, f.z = k * e.z + c.w * g.z + p.z, f;
    };
    b.prototype.inverse = function(c) {
      var e = this.x, g = this.y, f = this.z, k = this.w;
      c = c || new b;
      this.conjugate(c);
      e = 1 / (e * e + g * g + f * f + k * k);
      return c.x *= e, c.y *= e, c.z *= e, c.w *= e, c;
    };
    b.prototype.conjugate = function(c) {
      return c = c || new b, c.x = -this.x, c.y = -this.y, c.z = -this.z, c.w = this.w, c;
    };
    b.prototype.normalize = function() {
      var b = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      0 === b ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (b = 1 / b, this.x *= b, this.y *= b, this.z *= b, this.w *= b);
    };
    b.prototype.normalizeFast = function() {
      var b = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
      0 === b ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= b, this.y *= b, this.z *= b, this.w *= b);
    };
    b.prototype.vmult = function(b, c) {
      c = c || new f;
      var e = b.x, g = b.y, k = b.z;
      b = this.x;
      var h = this.y, p = this.z, q = this.w, l = q * e + h * k - p * g, r = q * g + p * e - b * k, w = q * k + b * g - h * e, e = -b * e - h * g - p * k;
      return c.x = l * q + e * -b + r * -p - w * -h, c.y = r * q + e * -h + w * -b - l * -p, c.z = w * q + e * -p + l * -h - r * -b, c;
    };
    b.prototype.copy = function(b) {
      return this.x = b.x, this.y = b.y, this.z = b.z, this.w = b.w, this;
    };
    b.prototype.toEuler = function(b, c) {
      c = c || "YZX";
      var e, g, f, k = this.x, h = this.y, q = this.z, p = this.w;
      switch(c) {
        case "YZX":
          c = k * h + q * p;
          if (.499 < c && (e = 2 * Math.atan2(k, p), g = Math.PI / 2, f = 0), -.499 > c && (e = -2 * Math.atan2(k, p), g = -Math.PI / 2, f = 0), isNaN(e)) {
            f = q * q, e = Math.atan2(2 * h * p - 2 * k * q, 1 - 2 * h * h - 2 * f), g = Math.asin(2 * c), f = Math.atan2(2 * k * p - 2 * h * q, 1 - 2 * k * k - 2 * f);
          }
          break;
        default:
          throw Error("Euler order " + c + " not supported yet.");
      }
      b.y = e;
      b.z = g;
      b.x = f;
    };
    b.prototype.setFromEuler = function(b, c, e, g) {
      g = g || "XYZ";
      var f = Math.cos(b / 2), k = Math.cos(c / 2), h = Math.cos(e / 2);
      b = Math.sin(b / 2);
      c = Math.sin(c / 2);
      e = Math.sin(e / 2);
      return "XYZ" === g ? (this.x = b * k * h + f * c * e, this.y = f * c * h - b * k * e, this.z = f * k * e + b * c * h, this.w = f * k * h - b * c * e) : "YXZ" === g ? (this.x = b * k * h + f * c * e, this.y = f * c * h - b * k * e, this.z = f * k * e - b * c * h, this.w = f * k * h + b * c * e) : "ZXY" === g ? (this.x = b * k * h - f * c * e, this.y = f * c * h + b * k * e, this.z = f * k * e + b * c * h, this.w = f * k * h - b * c * e) : "ZYX" === g ? (this.x = b * k * h - f * c * e, this.y = 
      f * c * h + b * k * e, this.z = f * k * e - b * c * h, this.w = f * k * h + b * c * e) : "YZX" === g ? (this.x = b * k * h + f * c * e, this.y = f * c * h + b * k * e, this.z = f * k * e - b * c * h, this.w = f * k * h - b * c * e) : "XZY" === g && (this.x = b * k * h - f * c * e, this.y = f * c * h - b * k * e, this.z = f * k * e + b * c * h, this.w = f * k * h + b * c * e), this;
    };
    b.prototype.clone = function() {
      return new b(this.x, this.y, this.z, this.w);
    };
  }, {"./Vec3":30}], 29:[function(h, l) {
    function b(b) {
      b = b || {};
      this.position = new f;
      b.position && this.position.copy(b.position);
      this.quaternion = new k;
      b.quaternion && this.quaternion.copy(b.quaternion);
    }
    var f = h("./Vec3"), k = h("./Quaternion");
    l.exports = b;
    var c = new k;
    b.pointToLocalFrame = function(b, e, k, h) {
      h = h || new f;
      return k.vsub(b, h), e.conjugate(c), c.vmult(h, h), h;
    };
    b.prototype.pointToLocal = function(c, e) {
      return b.pointToLocalFrame(this.position, this.quaternion, c, e);
    };
    b.pointToWorldFrame = function(b, c, k, h) {
      h = h || new f;
      return c.vmult(k, h), h.vadd(b, h), h;
    };
    b.prototype.pointToWorld = function(c, e) {
      return b.pointToWorldFrame(this.position, this.quaternion, c, e);
    };
    b.prototype.vectorToWorldFrame = function(b, c) {
      c = c || new f;
      return this.quaternion.vmult(b, c), c;
    };
    b.vectorToWorldFrame = function(b, c, f) {
      return b.vmult(c, f), f;
    };
    b.vectorToLocalFrame = function(b, c, k, h) {
      h = h || new f;
      return c.w *= -1, c.vmult(k, h), c.w *= -1, h;
    };
  }, {"./Quaternion":28, "./Vec3":30}], 30:[function(h, l) {
    function b(b, c, g) {
      this.x = b || 0;
      this.y = c || 0;
      this.z = g || 0;
    }
    l.exports = b;
    var f = h("./Mat3");
    b.ZERO = new b(0, 0, 0);
    b.UNIT_X = new b(1, 0, 0);
    b.UNIT_Y = new b(0, 1, 0);
    b.UNIT_Z = new b(0, 0, 1);
    b.prototype.cross = function(c, g) {
      var e = c.x, f = c.y;
      c = c.z;
      var k = this.x, h = this.y, p = this.z;
      return g = g || new b, g.x = h * c - p * f, g.y = p * e - k * c, g.z = k * f - h * e, g;
    };
    b.prototype.set = function(b, c, g) {
      return this.x = b, this.y = c, this.z = g, this;
    };
    b.prototype.setZero = function() {
      this.x = this.y = this.z = 0;
    };
    b.prototype.vadd = function(c, g) {
      return g ? (g.x = c.x + this.x, g.y = c.y + this.y, g.z = c.z + this.z, void 0) : new b(this.x + c.x, this.y + c.y, this.z + c.z);
    };
    b.prototype.vsub = function(c, g) {
      return g ? (g.x = this.x - c.x, g.y = this.y - c.y, g.z = this.z - c.z, void 0) : new b(this.x - c.x, this.y - c.y, this.z - c.z);
    };
    b.prototype.crossmat = function() {
      return new f([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
    };
    b.prototype.normalize = function() {
      var b = this.x, c = this.y, g = this.z, b = Math.sqrt(b * b + c * c + g * g);
      0 < b ? (c = 1 / b, this.x *= c, this.y *= c, this.z *= c) : this.z = this.y = this.x = 0;
      return b;
    };
    b.prototype.unit = function(c) {
      c = c || new b;
      var e = this.x, g = this.y, f = this.z, k = Math.sqrt(e * e + g * g + f * f);
      return 0 < k ? (k = 1 / k, c.x = e * k, c.y = g * k, c.z = f * k) : (c.x = 1, c.y = 0, c.z = 0), c;
    };
    b.prototype.norm = function() {
      var b = this.x, c = this.y, g = this.z;
      return Math.sqrt(b * b + c * c + g * g);
    };
    b.prototype.length = b.prototype.norm;
    b.prototype.norm2 = function() {
      return this.dot(this);
    };
    b.prototype.lengthSquared = b.prototype.norm2;
    b.prototype.distanceTo = function(b) {
      var c = this.x, e = this.y, g = this.z, f = b.x, k = b.y;
      b = b.z;
      return Math.sqrt((f - c) * (f - c) + (k - e) * (k - e) + (b - g) * (b - g));
    };
    b.prototype.distanceSquared = function(b) {
      var c = this.x, e = this.y, g = this.z, f = b.x, k = b.y;
      b = b.z;
      return (f - c) * (f - c) + (k - e) * (k - e) + (b - g) * (b - g);
    };
    b.prototype.mult = function(c, g) {
      g = g || new b;
      var e = this.y, f = this.z;
      return g.x = c * this.x, g.y = c * e, g.z = c * f, g;
    };
    b.prototype.scale = b.prototype.mult;
    b.prototype.dot = function(b) {
      return this.x * b.x + this.y * b.y + this.z * b.z;
    };
    b.prototype.isZero = function() {
      return 0 === this.x && 0 === this.y && 0 === this.z;
    };
    b.prototype.negate = function(c) {
      return c = c || new b, c.x = -this.x, c.y = -this.y, c.z = -this.z, c;
    };
    var k = new b, c = new b;
    b.prototype.tangents = function(b, g) {
      var e = this.norm();
      0 < e ? (e = 1 / e, k.set(this.x * e, this.y * e, this.z * e), .9 > Math.abs(k.x) ? (c.set(1, 0, 0), k.cross(c, b)) : (c.set(0, 1, 0), k.cross(c, b)), k.cross(b, g)) : (b.set(1, 0, 0), g.set(0, 1, 0));
    };
    b.prototype.toString = function() {
      return this.x + "," + this.y + "," + this.z;
    };
    b.prototype.toArray = function() {
      return [this.x, this.y, this.z];
    };
    b.prototype.copy = function(b) {
      return this.x = b.x, this.y = b.y, this.z = b.z, this;
    };
    b.prototype.lerp = function(b, c, g) {
      var e = this.x, f = this.y, k = this.z;
      g.x = e + (b.x - e) * c;
      g.y = f + (b.y - f) * c;
      g.z = k + (b.z - k) * c;
    };
    b.prototype.almostEquals = function(b, c) {
      return void 0 === c && (c = 1E-6), Math.abs(this.x - b.x) > c || Math.abs(this.y - b.y) > c || Math.abs(this.z - b.z) > c ? !1 : !0;
    };
    b.prototype.almostZero = function(b) {
      return void 0 === b && (b = 1E-6), Math.abs(this.x) > b || Math.abs(this.y) > b || Math.abs(this.z) > b ? !1 : !0;
    };
    var g = new b;
    b.prototype.isAntiparallelTo = function(b, c) {
      return this.negate(g), g.almostEquals(b, c);
    };
    b.prototype.clone = function() {
      return new b(this.x, this.y, this.z);
    };
  }, {"./Mat3":27}], 31:[function(h, l) {
    function b(q) {
      q = q || {};
      f.apply(this);
      this.id = b.idCounter++;
      this.postStep = this.preStep = this.world = null;
      this.vlambda = new k;
      this.collisionFilterGroup = "number" == typeof q.collisionFilterGroup ? q.collisionFilterGroup : 1;
      this.collisionFilterMask = "number" == typeof q.collisionFilterMask ? q.collisionFilterMask : 1;
      this.collisionResponse = !0;
      this.position = new k;
      q.position && this.position.copy(q.position);
      this.previousPosition = new k;
      this.initPosition = new k;
      this.velocity = new k;
      q.velocity && this.velocity.copy(q.velocity);
      this.initVelocity = new k;
      this.force = new k;
      var h = "number" == typeof q.mass ? q.mass : 0;
      this.mass = h;
      this.invMass = 0 < h ? 1 / h : 0;
      this.material = q.material || null;
      this.linearDamping = "number" == typeof q.linearDamping ? q.linearDamping : .01;
      this.type = 0 >= h ? b.STATIC : b.DYNAMIC;
      typeof q.type == typeof b.STATIC && (this.type = q.type);
      this.allowSleep = "undefined" != typeof q.allowSleep ? q.allowSleep : !0;
      this.sleepState = 0;
      this.sleepSpeedLimit = "undefined" != typeof q.sleepSpeedLimit ? q.sleepSpeedLimit : .1;
      this.sleepTimeLimit = "undefined" != typeof q.sleepTimeLimit ? q.sleepTimeLimit : 1;
      this.timeLastSleepy = 0;
      this._wakeUpAfterNarrowphase = !1;
      this.torque = new k;
      this.quaternion = new g;
      q.quaternion && this.quaternion.copy(q.quaternion);
      this.initQuaternion = new g;
      this.angularVelocity = new k;
      q.angularVelocity && this.angularVelocity.copy(q.angularVelocity);
      this.initAngularVelocity = new k;
      this.interpolatedPosition = new k;
      this.interpolatedQuaternion = new g;
      this.shapes = [];
      this.shapeOffsets = [];
      this.shapeOrientations = [];
      this.inertia = new k;
      this.invInertia = new k;
      this.invInertiaWorld = new c;
      this.invMassSolve = 0;
      this.invInertiaSolve = new k;
      this.invInertiaWorldSolve = new c;
      this.fixedRotation = "undefined" != typeof q.fixedRotation ? q.fixedRotation : !1;
      this.angularDamping = "undefined" != typeof q.angularDamping ? q.angularDamping : .01;
      this.aabb = new e;
      this.aabbNeedsUpdate = !0;
      this.wlambda = new k;
      q.shape && this.addShape(q.shape);
      this.updateMassProperties();
    }
    l.exports = b;
    var f = h("../utils/EventTarget"), k = (h("../shapes/Shape"), h("../math/Vec3")), c = h("../math/Mat3"), g = h("../math/Quaternion"), e = (h("../material/Material"), h("../collision/AABB")), p = h("../shapes/Box");
    b.prototype = new f;
    b.prototype.constructor = b;
    b.DYNAMIC = 1;
    b.STATIC = 2;
    b.KINEMATIC = 4;
    b.AWAKE = 0;
    b.SLEEPY = 1;
    b.SLEEPING = 2;
    b.idCounter = 0;
    b.prototype.wakeUp = function() {
      var c = this.sleepState;
      this.sleepState = 0;
      c === b.SLEEPING && this.dispatchEvent({type:"wakeup"});
    };
    b.prototype.sleep = function() {
      this.sleepState = b.SLEEPING;
      this.velocity.set(0, 0, 0);
      this.angularVelocity.set(0, 0, 0);
    };
    b.sleepyEvent = {type:"sleepy"};
    b.sleepEvent = {type:"sleep"};
    b.prototype.sleepTick = function(c) {
      if (this.allowSleep) {
        var e = this.sleepState, g = this.velocity.norm2() + this.angularVelocity.norm2(), f = Math.pow(this.sleepSpeedLimit, 2);
        e === b.AWAKE && f > g ? (this.sleepState = b.SLEEPY, this.timeLastSleepy = c, this.dispatchEvent(b.sleepyEvent)) : e === b.SLEEPY && g > f ? this.wakeUp() : e === b.SLEEPY && c - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), this.dispatchEvent(b.sleepEvent));
      }
    };
    b.prototype.updateSolveMassProperties = function() {
      this.sleepState === b.SLEEPING || this.type === b.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld));
    };
    b.prototype.pointToLocalFrame = function(b, c) {
      c = c || new k;
      return b.vsub(this.position, c), this.quaternion.conjugate().vmult(c, c), c;
    };
    b.prototype.vectorToLocalFrame = function(b, c) {
      c = c || new k;
      return this.quaternion.conjugate().vmult(b, c), c;
    };
    b.prototype.pointToWorldFrame = function(b, c) {
      c = c || new k;
      return this.quaternion.vmult(b, c), c.vadd(this.position, c), c;
    };
    b.prototype.vectorToWorldFrame = function(b, c) {
      c = c || new k;
      return this.quaternion.vmult(b, c), c;
    };
    var r = new k, w = new g;
    b.prototype.addShape = function(b, c, e) {
      var f = new k, q = new g;
      return c && f.copy(c), e && q.copy(e), this.shapes.push(b), this.shapeOffsets.push(f), this.shapeOrientations.push(q), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, this;
    };
    b.prototype.updateBoundingRadius = function() {
      for (var b = this.shapes, c = this.shapeOffsets, e = b.length, g = 0, f = 0;f !== e;f++) {
        var k = b[f];
        k.updateBoundingSphereRadius();
        var q = c[f].norm(), k = k.boundingSphereRadius;
        q + k > g && (g = q + k);
      }
      this.boundingRadius = g;
    };
    var n = new e;
    b.prototype.computeAABB = function() {
      for (var b = this.shapes, c = this.shapeOffsets, e = this.shapeOrientations, g = b.length, f = this.quaternion, k = this.aabb, q = 0;q !== g;q++) {
        var h = b[q];
        e[q].mult(f, w);
        w.vmult(c[q], r);
        r.vadd(this.position, r);
        h.calculateWorldAABB(r, w, n.lowerBound, n.upperBound);
        0 === q ? k.copy(n) : k.extend(n);
      }
      this.aabbNeedsUpdate = !1;
    };
    var t = new c, v = new c;
    new c;
    b.prototype.updateInertiaWorld = function(b) {
      var c = this.invInertia;
      if (c.x !== c.y || c.y !== c.z || b) {
        t.setRotationFromQuaternion(this.quaternion), t.transpose(v), t.scale(c, t), t.mmult(v, this.invInertiaWorld);
      }
    };
    var y = new k, x = new k;
    b.prototype.applyForce = function(c, e) {
      this.type === b.DYNAMIC && (e.vsub(this.position, y), y.cross(c, x), this.force.vadd(c, this.force), this.torque.vadd(x, this.torque));
    };
    var q = new k, u = new k;
    b.prototype.applyLocalForce = function(c, e) {
      this.type === b.DYNAMIC && (this.vectorToWorldFrame(c, q), this.pointToWorldFrame(e, u), this.applyForce(q, u));
    };
    var B = new k, C = new k, D = new k;
    b.prototype.applyImpulse = function(c, e) {
      this.type === b.DYNAMIC && (e.vsub(this.position, B), C.copy(c), C.mult(this.invMass, C), this.velocity.vadd(C, this.velocity), B.cross(c, D), this.invInertiaWorld.vmult(D, D), this.angularVelocity.vadd(D, this.angularVelocity));
    };
    var F = new k, E = new k;
    b.prototype.applyLocalImpulse = function(c, e) {
      this.type === b.DYNAMIC && (this.vectorToWorldFrame(c, F), this.pointToWorldFrame(e, E), this.applyImpulse(F, E));
    };
    var z = new k;
    b.prototype.updateMassProperties = function() {
      this.invMass = 0 < this.mass ? 1 / this.mass : 0;
      var b = this.inertia, c = this.fixedRotation;
      this.computeAABB();
      z.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);
      p.calculateInertia(z, this.mass, b);
      this.invInertia.set(0 < b.x && !c ? 1 / b.x : 0, 0 < b.y && !c ? 1 / b.y : 0, 0 < b.z && !c ? 1 / b.z : 0);
      this.updateInertiaWorld(!0);
    };
    b.prototype.getVelocityAtWorldPoint = function(b, c) {
      var e = new k;
      return b.vsub(this.position, e), this.angularVelocity.cross(e, c), this.velocity.vadd(c, c), c;
    };
  }, {"../collision/AABB":3, "../material/Material":25, "../math/Mat3":27, "../math/Quaternion":28, "../math/Vec3":30, "../shapes/Box":37, "../shapes/Shape":43, "../utils/EventTarget":49}], 32:[function(h, l) {
    function b(b) {
      this.chassisBody = b.chassisBody;
      this.wheelInfos = [];
      this.sliding = !1;
      this.world = null;
      this.indexRightAxis = "undefined" != typeof b.indexRightAxis ? b.indexRightAxis : 1;
      this.indexForwardAxis = "undefined" != typeof b.indexForwardAxis ? b.indexForwardAxis : 0;
      this.indexUpAxis = "undefined" != typeof b.indexUpAxis ? b.indexUpAxis : 2;
    }
    function f(b, c, e) {
      var g = D, f = F, k = E, q = z;
      return c.vsub(b.position, g), g.cross(e, f), b.invInertiaWorld.vmult(f, q), q.cross(g, k), b.invMass + e.dot(k);
    }
    var k = (h("./Body"), h("../math/Vec3")), c = h("../math/Quaternion"), g = (h("../collision/RaycastResult"), h("../collision/Ray")), e = h("../objects/WheelInfo");
    l.exports = b;
    var p = (new k, new k, new k, new k), r = new k, w = new k;
    new g;
    b.prototype.addWheel = function(b) {
      b = b || {};
      b = new e(b);
      var c = this.wheelInfos.length;
      return this.wheelInfos.push(b), c;
    };
    b.prototype.setSteeringValue = function(b, c) {
      this.wheelInfos[c].steering = b;
    };
    new k;
    b.prototype.applyEngineForce = function(b, c) {
      this.wheelInfos[c].engineForce = b;
    };
    b.prototype.setBrake = function(b, c) {
      this.wheelInfos[c].brake = b;
    };
    b.prototype.addToWorld = function(b) {
      this.constraints;
      b.add(this.chassisBody);
      var c = this;
      this.preStepCallback = function() {
        c.updateVehicle(b.dt);
      };
      b.addEventListener("preStep", this.preStepCallback);
      this.world = b;
    };
    b.prototype.getVehicleAxisWorld = function(b, c) {
      c.set(0 === b ? 1 : 0, 1 === b ? 1 : 0, 2 === b ? 1 : 0);
      this.chassisBody.vectorToWorldFrame(c, c);
    };
    b.prototype.updateVehicle = function(b) {
      for (var c = this.wheelInfos, e = c.length, g = this.chassisBody, f = 0;e > f;f++) {
        this.updateWheelTransform(f);
      }
      this.currentVehicleSpeedKmHour = 3.6 * g.velocity.norm();
      f = new k;
      this.getVehicleAxisWorld(this.indexForwardAxis, f);
      0 > f.dot(g.velocity) && (this.currentVehicleSpeedKmHour *= -1);
      for (f = 0;e > f;f++) {
        this.castRay(c[f]);
      }
      this.updateSuspension(b);
      for (var q = new k, h = new k, f = 0;e > f;f++) {
        var p = c[f], n = p.suspensionForce;
        n > p.maxSuspensionForce && (n = p.maxSuspensionForce);
        p.raycastResult.hitNormalWorld.scale(n * b, q);
        p.raycastResult.hitPointWorld.vsub(g.position, h);
        g.applyImpulse(q, p.raycastResult.hitPointWorld);
      }
      this.updateFriction(b);
      q = new k;
      h = new k;
      n = new k;
      for (f = 0;e > f;f++) {
        p = c[f];
        g.getVelocityAtWorldPoint(p.chassisConnectionPointWorld, n);
        var l = 1;
        switch(this.indexUpAxis) {
          case 1:
            l = -1;
        }
        if (p.isInContact) {
          this.getVehicleAxisWorld(this.indexForwardAxis, h);
          var u = h.dot(p.raycastResult.hitNormalWorld);
          p.raycastResult.hitNormalWorld.scale(u, q);
          h.vsub(q, h);
          u = h.dot(n);
          p.deltaRotation = l * u * b / p.radius;
        }
        !p.sliding && p.isInContact || 0 === p.engineForce || !p.useCustomSlidingRotationalSpeed || (p.deltaRotation = (0 < p.engineForce ? 1 : -1) * p.customSlidingRotationalSpeed * b);
        Math.abs(p.brake) > Math.abs(p.engineForce) && (p.deltaRotation = 0);
        p.rotation += p.deltaRotation;
        p.deltaRotation *= .99;
      }
    };
    b.prototype.updateSuspension = function() {
      for (var b = this.chassisBody.mass, c = this.wheelInfos, e = c.length, g = 0;e > g;g++) {
        var f = c[g];
        if (f.isInContact) {
          var k;
          k = f.suspensionStiffness * (f.suspensionRestLength - f.suspensionLength) * f.clippedInvContactDotSuspension;
          var q = f.suspensionRelativeVelocity;
          k -= (0 > q ? f.dampingCompression : f.dampingRelaxation) * q;
          f.suspensionForce = k * b;
          0 > f.suspensionForce && (f.suspensionForce = 0);
        } else {
          f.suspensionForce = 0;
        }
      }
    };
    b.prototype.removeFromWorld = function(b) {
      this.constraints;
      b.remove(this.chassisBody);
      b.removeEventListener("preStep", this.preStepCallback);
      this.world = null;
    };
    var n = new k, t = new k;
    b.prototype.castRay = function(b) {
      this.updateWheelTransformWorld(b);
      var c = this.chassisBody, e = -1;
      b.directionWorld.scale(b.suspensionRestLength + b.radius, n);
      var g = b.chassisConnectionPointWorld;
      g.vadd(n, t);
      var f = b.raycastResult;
      f.reset();
      var q = c.collisionResponse;
      c.collisionResponse = !1;
      this.world.rayTest(g, t, f);
      c.collisionResponse = q;
      g = f.body;
      (b.raycastResult.groundObject = 0, g) ? (e = f.distance, b.raycastResult.hitNormalWorld = f.hitNormalWorld, b.isInContact = !0, b.suspensionLength = f.distance - b.radius, f = b.suspensionRestLength - b.maxSuspensionTravel, g = b.suspensionRestLength + b.maxSuspensionTravel, b.suspensionLength < f && (b.suspensionLength = f), b.suspensionLength > g && (b.suspensionLength = g, b.raycastResult.reset()), f = b.raycastResult.hitNormalWorld.dot(b.directionWorld), g = new k, c.getVelocityAtWorldPoint(b.raycastResult.hitPointWorld, 
      g), c = b.raycastResult.hitNormalWorld.dot(g), -.1 <= f ? (b.suspensionRelativeVelocity = 0, b.clippedInvContactDotSuspension = 10) : (f = -1 / f, b.suspensionRelativeVelocity = c * f, b.clippedInvContactDotSuspension = f)) : (b.suspensionLength = b.suspensionRestLength + 0 * b.maxSuspensionTravel, b.suspensionRelativeVelocity = 0, b.directionWorld.scale(-1, b.raycastResult.hitNormalWorld), b.clippedInvContactDotSuspension = 1);
      return e;
    };
    b.prototype.updateWheelTransformWorld = function(b) {
      b.isInContact = !1;
      var c = this.chassisBody;
      c.pointToWorldFrame(b.chassisConnectionPointLocal, b.chassisConnectionPointWorld);
      c.vectorToWorldFrame(b.directionLocal, b.directionWorld);
      c.vectorToWorldFrame(b.axleLocal, b.axleWorld);
    };
    b.prototype.updateWheelTransform = function(b) {
      b = this.wheelInfos[b];
      this.updateWheelTransformWorld(b);
      b.directionLocal.scale(-1, p);
      r.copy(b.axleLocal);
      p.cross(r, w);
      w.normalize();
      r.normalize();
      var e = b.steering, g = new c;
      g.setFromAxisAngle(p, e);
      e = new c;
      e.setFromAxisAngle(r, b.rotation);
      var f = b.worldTransform.quaternion;
      this.chassisBody.quaternion.mult(g, f);
      f.mult(e, f);
      f.normalize();
      g = b.worldTransform.position;
      g.copy(b.directionWorld);
      g.scale(b.suspensionLength, g);
      g.vadd(b.chassisConnectionPointWorld, g);
    };
    var v = [new k(1, 0, 0), new k(0, 1, 0), new k(0, 0, 1)];
    b.prototype.getWheelTransformWorld = function(b) {
      return this.wheelInfos[b].worldTransform;
    };
    var y = new k, x = [], q = [];
    b.prototype.updateFriction = function(b) {
      for (var c = this.wheelInfos, e = c.length, g = this.chassisBody, h = 0, p = 0;e > p;p++) {
        var n = c[p], l = n.raycastResult.body;
        l && h++;
        n.sideImpulse = 0;
        n.forwardImpulse = 0;
        q[p] || (q[p] = new k);
        x[p] || (x[p] = new k);
      }
      for (p = 0;e > p;p++) {
        if (n = c[p], l = n.raycastResult.body) {
          var r = x[p];
          this.getWheelTransformWorld(p).vectorToWorldFrame(v[this.indexRightAxis], r);
          var h = n.raycastResult.hitNormalWorld, w = r.dot(h);
          h.scale(w, y);
          r.vsub(y, r);
          r.normalize();
          h.cross(r, q[p]);
          q[p].normalize();
          h = n;
          var w = g, t = n.raycastResult.hitPointWorld, z = n.raycastResult.hitPointWorld;
          if (1.1 < r.norm2()) {
            l = 0;
          } else {
            var F = I, D = J, E = R;
            w.getVelocityAtWorldPoint(t, F);
            l.getVelocityAtWorldPoint(z, D);
            F.vsub(D, E);
            l = -.2 * r.dot(E) * (1 / (w.invMass + l.invMass));
          }
          h.sideImpulse = l;
          n.sideImpulse *= 1;
        }
      }
      this.sliding = !1;
      for (p = 0;e > p;p++) {
        n = c[p];
        l = n.raycastResult.body;
        t = 0;
        if (n.slipInfo = 1, l) {
          var h = n.brake ? n.brake : 0, D = g, z = l, r = n.raycastResult.hitPointWorld, F = q[p], t = h, w = 0, E = r, L = u, qa = B, pa = C;
          D.getVelocityAtWorldPoint(E, L);
          z.getVelocityAtWorldPoint(E, qa);
          L.vsub(qa, pa);
          E = F.dot(pa);
          D = f(D, r, F);
          z = f(z, r, F);
          t = (w = 1 / (D + z) * -E, w > t && (w = t), -t > w && (w = -t), w);
          t += n.engineForce * b;
          h /= t;
          n.slipInfo *= h;
        }
        if (n.forwardImpulse = 0, n.skidInfo = 1, l) {
          if (n.skidInfo = 1, l = n.suspensionForce * b * n.frictionSlip, h = l * l, n.forwardImpulse = t, w = .5 * n.forwardImpulse, t = 1 * n.sideImpulse, w = w * w + t * t, n.sliding = !1, w > h) {
            this.sliding = !0, n.sliding = !0, h = l / Math.sqrt(w), n.skidInfo *= h;
          }
        }
      }
      if (this.sliding) {
        for (p = 0;e > p;p++) {
          n = c[p], 0 !== n.sideImpulse && 1 > n.skidInfo && (n.forwardImpulse *= n.skidInfo, n.sideImpulse *= n.skidInfo);
        }
      }
      for (p = 0;e > p;p++) {
        n = c[p];
        b = new k;
        if (b.copy(n.raycastResult.hitPointWorld), 0 !== n.forwardImpulse) {
          l = new k, q[p].scale(n.forwardImpulse, l), g.applyImpulse(l, b);
        }
        0 !== n.sideImpulse && (l = n.raycastResult.body, h = new k, h.copy(n.raycastResult.hitPointWorld), w = new k, x[p].scale(n.sideImpulse, w), g.pointToLocalFrame(b, b), b["xyz"[this.indexUpAxis]] *= n.rollInfluence, g.pointToWorldFrame(b, b), g.applyImpulse(w, b), w.scale(-1, w), l.applyImpulse(w, h));
      }
    };
    var u = new k, B = new k, C = new k, D = new k, F = new k, E = new k, z = new k, I = new k, J = new k, R = new k;
  }, {"../collision/Ray":9, "../collision/RaycastResult":10, "../math/Quaternion":28, "../math/Vec3":30, "../objects/WheelInfo":36, "./Body":31}], 33:[function(h, l) {
    function b(b) {
      (this.wheelBodies = [], this.coordinateSystem = "undefined" == typeof b.coordinateSystem ? new g(1, 2, 3) : b.coordinateSystem.clone(), this.chassisBody = b.chassisBody, this.chassisBody) || (b = new c(new g(5, 2, .5)), this.chassisBody = new f(1, b));
      this.constraints = [];
      this.wheelAxes = [];
      this.wheelForces = [];
    }
    var f = h("./Body"), k = h("../shapes/Sphere"), c = h("../shapes/Box"), g = h("../math/Vec3"), e = h("../constraints/HingeConstraint");
    l.exports = b;
    b.prototype.addWheel = function(b) {
      b = b || {};
      var c = b.body;
      c || (c = new f(1, new k(1.2)));
      this.wheelBodies.push(c);
      this.wheelForces.push(0);
      var h = (new g, "undefined" != typeof b.position ? b.position.clone() : new g), p = new g;
      this.chassisBody.pointToWorldFrame(h, p);
      c.position.set(p.x, p.y, p.z);
      b = "undefined" != typeof b.axis ? b.axis.clone() : new g(0, 1, 0);
      this.wheelAxes.push(b);
      c = new e(this.chassisBody, c, {pivotA:h, axisA:b, pivotB:g.ZERO, axisB:b, collideConnected:!1});
      return this.constraints.push(c), this.wheelBodies.length - 1;
    };
    b.prototype.setSteeringValue = function(b, c) {
      var e = this.wheelAxes[c], g = Math.cos(b);
      b = Math.sin(b);
      var f = e.x, e = e.y;
      this.constraints[c].axisA.set(g * f - b * e, b * f + g * e, 0);
    };
    b.prototype.setMotorSpeed = function(b, c) {
      c = this.constraints[c];
      c.enableMotor();
      c.motorTargetVelocity = b;
    };
    b.prototype.disableMotor = function(b) {
      this.constraints[b].disableMotor();
    };
    var p = new g;
    b.prototype.setWheelForce = function(b, c) {
      this.wheelForces[c] = b;
    };
    b.prototype.applyWheelForce = function(b, c) {
      var e = this.wheelBodies[c], g = e.torque;
      this.wheelAxes[c].scale(b, p);
      e.vectorToWorldFrame(p, p);
      g.vadd(p, g);
    };
    b.prototype.addToWorld = function(b) {
      for (var c = this.constraints, e = this.wheelBodies.concat([this.chassisBody]), g = 0;g < e.length;g++) {
        b.add(e[g]);
      }
      for (g = 0;g < c.length;g++) {
        b.addConstraint(c[g]);
      }
      b.addEventListener("preStep", this._update.bind(this));
    };
    b.prototype._update = function() {
      for (var b = this.wheelForces, c = 0;c < b.length;c++) {
        this.applyWheelForce(b[c], c);
      }
    };
    b.prototype.removeFromWorld = function(b) {
      for (var c = this.constraints, e = this.wheelBodies.concat([this.chassisBody]), g = 0;g < e.length;g++) {
        b.remove(e[g]);
      }
      for (g = 0;g < c.length;g++) {
        b.removeConstraint(c[g]);
      }
    };
    var r = new g;
    b.prototype.getWheelSpeed = function(b) {
      var c = this.wheelBodies[b].angularVelocity;
      return this.chassisBody.vectorToWorldFrame(this.wheelAxes[b], r), c.dot(r);
    };
  }, {"../constraints/HingeConstraint":15, "../math/Vec3":30, "../shapes/Box":37, "../shapes/Sphere":44, "./Body":31}], 34:[function(h, l) {
    function b() {
      this.particles = [];
      this.speedOfSound = this.smoothingRadius = this.density = 1;
      this.viscosity = .01;
      this.eps = 1E-6;
      this.pressures = [];
      this.densities = [];
      this.neighbors = [];
    }
    l.exports = b;
    l = (h("../shapes/Shape"), h("../math/Vec3"));
    h("../math/Quaternion");
    h("../shapes/Particle");
    h("../objects/Body");
    h("../material/Material");
    b.prototype.add = function(b) {
      this.particles.push(b);
      this.neighbors.length < this.particles.length && this.neighbors.push([]);
    };
    b.prototype.remove = function(b) {
      b = this.particles.indexOf(b);
      -1 !== b && (this.particles.splice(b, 1), this.neighbors.length > this.particles.length && this.neighbors.pop());
    };
    var f = new l;
    b.prototype.getNeighbors = function(b, c) {
      for (var e = this.particles.length, g = b.id, k = this.smoothingRadius * this.smoothingRadius, h = 0;h !== e;h++) {
        var q = this.particles[h];
        q.position.vsub(b.position, f);
        g !== q.id && f.norm2() < k && c.push(q);
      }
    };
    var k = new l, c = new l, g = new l, e = new l, p = new l, r = new l;
    b.prototype.update = function() {
      for (var b = this.particles.length, f = this.speedOfSound, h = this.eps, l = 0;l !== b;l++) {
        var y = this.particles[l], x = this.neighbors[l];
        x.length = 0;
        this.getNeighbors(y, x);
        x.push(this.particles[l]);
        for (var q = x.length, u = 0, B = 0;B !== q;B++) {
          y.position.vsub(x[B].position, k);
          var C = k.norm(), C = this.w(C), u = u + x[B].mass * C;
        }
        this.densities[l] = u;
        this.pressures[l] = f * f * (this.densities[l] - this.density);
      }
      for (l = 0;l !== b;l++) {
        f = this.particles[l];
        c.set(0, 0, 0);
        g.set(0, 0, 0);
        x = this.neighbors[l];
        q = x.length;
        for (B = 0;B !== q;B++) {
          u = x[B], f.position.vsub(u.position, p), C = p.norm(), y = -u.mass * (this.pressures[l] / (this.densities[l] * this.densities[l] + h) + this.pressures[B] / (this.densities[B] * this.densities[B] + h)), this.gradw(p, e), e.mult(y, e), c.vadd(e, c), u.velocity.vsub(f.velocity, r), r.mult(1 / (1E-4 + this.densities[l] * this.densities[B]) * this.viscosity * u.mass, r), y = this.nablaw(C), r.mult(y, r), g.vadd(r, g);
        }
        g.mult(f.mass, g);
        c.mult(f.mass, c);
        f.force.vadd(g, f.force);
        f.force.vadd(c, f.force);
      }
    };
    b.prototype.w = function(b) {
      var c = this.smoothingRadius;
      return 315 / (64 * Math.PI * Math.pow(c, 9)) * Math.pow(c * c - b * b, 3);
    };
    b.prototype.gradw = function(b, c) {
      var e = b.norm(), g = this.smoothingRadius;
      b.mult(945 / (32 * Math.PI * Math.pow(g, 9)) * Math.pow(g * g - e * e, 2), c);
    };
    b.prototype.nablaw = function(b) {
      var c = this.smoothingRadius;
      return 945 / (32 * Math.PI * Math.pow(c, 9)) * (c * c - b * b) * (7 * b * b - 3 * c * c);
    };
  }, {"../material/Material":25, "../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "../shapes/Particle":41, "../shapes/Shape":43}], 35:[function(h, l) {
    function b(b, c, e) {
      e = e || {};
      this.restLength = "number" == typeof e.restLength ? e.restLength : 1;
      this.stiffness = e.stiffness || 100;
      this.damping = e.damping || 1;
      this.bodyA = b;
      this.bodyB = c;
      this.localAnchorA = new f;
      this.localAnchorB = new f;
      e.localAnchorA && this.localAnchorA.copy(e.localAnchorA);
      e.localAnchorB && this.localAnchorB.copy(e.localAnchorB);
      e.worldAnchorA && this.setWorldAnchorA(e.worldAnchorA);
      e.worldAnchorB && this.setWorldAnchorB(e.worldAnchorB);
    }
    var f = h("../math/Vec3");
    l.exports = b;
    b.prototype.setWorldAnchorA = function(b) {
      this.bodyA.pointToLocalFrame(b, this.localAnchorA);
    };
    b.prototype.setWorldAnchorB = function(b) {
      this.bodyB.pointToLocalFrame(b, this.localAnchorB);
    };
    b.prototype.getWorldAnchorA = function(b) {
      this.bodyA.pointToWorldFrame(this.localAnchorA, b);
    };
    b.prototype.getWorldAnchorB = function(b) {
      this.bodyB.pointToWorldFrame(this.localAnchorB, b);
    };
    var k = new f, c = new f, g = new f, e = new f, p = new f, r = new f, w = new f, n = new f, t = new f, v = new f, y = new f;
    b.prototype.applyForce = function() {
      var b = this.stiffness, f = this.damping, h = this.restLength, l = this.bodyA, C = this.bodyB;
      this.getWorldAnchorA(p);
      this.getWorldAnchorB(r);
      p.vsub(l.position, w);
      r.vsub(C.position, n);
      r.vsub(p, k);
      var D = k.norm();
      c.copy(k);
      c.normalize();
      C.velocity.vsub(l.velocity, g);
      C.angularVelocity.cross(n, y);
      g.vadd(y, g);
      l.angularVelocity.cross(w, y);
      g.vsub(y, g);
      c.mult(-b * (D - h) - f * g.dot(c), e);
      l.force.vsub(e, l.force);
      C.force.vadd(e, C.force);
      w.cross(e, t);
      n.cross(e, v);
      l.torque.vsub(t, l.torque);
      C.torque.vadd(v, C.torque);
    };
  }, {"../math/Vec3":30}], 36:[function(h, l) {
    function b(b) {
      b = g.defaults(b, {chassisConnectionPointLocal:new f, chassisConnectionPointWorld:new f, directionLocal:new f, directionWorld:new f, axleLocal:new f, axleWorld:new f, suspensionRestLength:1, suspensionMaxLength:2, radius:1, suspensionStiffness:100, dampingCompression:10, dampingRelaxation:10, frictionSlip:1E4, steering:0, rotation:0, deltaRotation:0, rollInfluence:.01, maxSuspensionForce:Number.MAX_VALUE, isFrontWheel:!0, clippedInvContactDotSuspension:1, suspensionRelativeVelocity:0, suspensionForce:0, 
      skidInfo:0, suspensionLength:0, maxSuspensionTravel:1, useCustomSlidingRotationalSpeed:!1, customSlidingRotationalSpeed:-.1});
      this.maxSuspensionTravel = b.maxSuspensionTravel;
      this.customSlidingRotationalSpeed = b.customSlidingRotationalSpeed;
      this.useCustomSlidingRotationalSpeed = b.useCustomSlidingRotationalSpeed;
      this.sliding = !1;
      this.chassisConnectionPointLocal = b.chassisConnectionPointLocal.clone();
      this.chassisConnectionPointWorld = b.chassisConnectionPointWorld.clone();
      this.directionLocal = b.directionLocal.clone();
      this.directionWorld = b.directionWorld.clone();
      this.axleLocal = b.axleLocal.clone();
      this.axleWorld = b.axleWorld.clone();
      this.suspensionRestLength = b.suspensionRestLength;
      this.suspensionMaxLength = b.suspensionMaxLength;
      this.radius = b.radius;
      this.suspensionStiffness = b.suspensionStiffness;
      this.dampingCompression = b.dampingCompression;
      this.dampingRelaxation = b.dampingRelaxation;
      this.frictionSlip = b.frictionSlip;
      this.deltaRotation = this.rotation = this.steering = 0;
      this.rollInfluence = b.rollInfluence;
      this.maxSuspensionForce = b.maxSuspensionForce;
      this.brake = this.engineForce = 0;
      this.isFrontWheel = b.isFrontWheel;
      this.clippedInvContactDotSuspension = 1;
      this.forwardImpulse = this.sideImpulse = this.suspensionLength = this.skidInfo = this.suspensionForce = this.suspensionRelativeVelocity = 0;
      this.raycastResult = new c;
      this.worldTransform = new k;
      this.isInContact = !1;
    }
    var f = h("../math/Vec3"), k = h("../math/Transform"), c = h("../collision/RaycastResult"), g = h("../utils/Utils");
    l.exports = b;
    var e = new f, p = new f, e = new f;
    b.prototype.updateWheel = function(b) {
      var c = this.raycastResult;
      if (this.isInContact) {
        var g = c.hitNormalWorld.dot(c.directionWorld);
        c.hitPointWorld.vsub(b.position, p);
        b.getVelocityAtWorldPoint(p, e);
        b = c.hitNormalWorld.dot(e);
        -.1 <= g ? (this.suspensionRelativeVelocity = 0, this.clippedInvContactDotSuspension = 10) : (g = -1 / g, this.suspensionRelativeVelocity = b * g, this.clippedInvContactDotSuspension = g);
      } else {
        c.suspensionLength = this.suspensionRestLength, this.suspensionRelativeVelocity = 0, c.directionWorld.scale(-1, c.hitNormalWorld), this.clippedInvContactDotSuspension = 1;
      }
    };
  }, {"../collision/RaycastResult":10, "../math/Transform":29, "../math/Vec3":30, "../utils/Utils":53}], 37:[function(h, l) {
    function b(b) {
      f.call(this);
      this.type = f.types.BOX;
      this.halfExtents = b;
      this.convexPolyhedronRepresentation = null;
      this.updateConvexPolyhedronRepresentation();
      this.updateBoundingSphereRadius();
    }
    l.exports = b;
    var f = h("./Shape"), k = h("../math/Vec3"), c = h("./ConvexPolyhedron");
    b.prototype = new f;
    b.prototype.constructor = b;
    b.prototype.updateConvexPolyhedronRepresentation = function() {
      var b = this.halfExtents.x, e = this.halfExtents.y, g = this.halfExtents.z, b = [new k(-b, -e, -g), new k(b, -e, -g), new k(b, e, -g), new k(-b, e, -g), new k(-b, -e, g), new k(b, -e, g), new k(b, e, g), new k(-b, e, g)];
      this.convexPolyhedronRepresentation = b = (new k(0, 0, 1), new k(0, 1, 0), new k(1, 0, 0), new c(b, [[3, 2, 1, 0], [4, 5, 6, 7], [5, 4, 0, 1], [2, 3, 7, 6], [0, 4, 7, 3], [1, 2, 6, 5]]));
      b.material = this.material;
    };
    b.prototype.calculateLocalInertia = function(c, e) {
      return e = e || new k, b.calculateInertia(this.halfExtents, c, e), e;
    };
    b.calculateInertia = function(b, c, e) {
      e.x = 1 / 12 * c * (4 * b.y * b.y + 4 * b.z * b.z);
      e.y = 1 / 12 * c * (4 * b.x * b.x + 4 * b.z * b.z);
      e.z = 1 / 12 * c * (4 * b.y * b.y + 4 * b.x * b.x);
    };
    b.prototype.getSideNormals = function(b, c) {
      var e = this.halfExtents;
      if (b[0].set(e.x, 0, 0), b[1].set(0, e.y, 0), b[2].set(0, 0, e.z), b[3].set(-e.x, 0, 0), b[4].set(0, -e.y, 0), b[5].set(0, 0, -e.z), void 0 !== c) {
        for (e = 0;e !== b.length;e++) {
          c.vmult(b[e], b[e]);
        }
      }
      return b;
    };
    b.prototype.volume = function() {
      return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
    };
    b.prototype.updateBoundingSphereRadius = function() {
      this.boundingSphereRadius = this.halfExtents.norm();
    };
    var g = new k;
    new k;
    b.prototype.forEachWorldCorner = function(b, c, e) {
      for (var f = this.halfExtents, f = [[f.x, f.y, f.z], [-f.x, f.y, f.z], [-f.x, -f.y, f.z], [-f.x, -f.y, -f.z], [f.x, -f.y, -f.z], [f.x, f.y, -f.z], [-f.x, f.y, -f.z], [f.x, -f.y, f.z]], k = 0;k < f.length;k++) {
        g.set(f[k][0], f[k][1], f[k][2]), c.vmult(g, g), b.vadd(g, g), e(g.x, g.y, g.z);
      }
    };
    var e = [new k, new k, new k, new k, new k, new k, new k, new k];
    b.prototype.calculateWorldAABB = function(b, c, g, f) {
      var k = this.halfExtents;
      e[0].set(k.x, k.y, k.z);
      e[1].set(-k.x, k.y, k.z);
      e[2].set(-k.x, -k.y, k.z);
      e[3].set(-k.x, -k.y, -k.z);
      e[4].set(k.x, -k.y, -k.z);
      e[5].set(k.x, k.y, -k.z);
      e[6].set(-k.x, k.y, -k.z);
      e[7].set(k.x, -k.y, k.z);
      var h = e[0];
      c.vmult(h, h);
      b.vadd(h, h);
      f.copy(h);
      g.copy(h);
      for (k = 1;8 > k;k++) {
        h = e[k];
        c.vmult(h, h);
        b.vadd(h, h);
        var p = h.x, n = h.y, h = h.z;
        p > f.x && (f.x = p);
        n > f.y && (f.y = n);
        h > f.z && (f.z = h);
        p < g.x && (g.x = p);
        n < g.y && (g.y = n);
        h < g.z && (g.z = h);
      }
    };
  }, {"../math/Vec3":30, "./ConvexPolyhedron":38, "./Shape":43}], 38:[function(h, l) {
    function b(b, c, e) {
      f.call(this);
      this.type = f.types.CONVEXPOLYHEDRON;
      this.vertices = b || [];
      this.worldVertices = [];
      this.worldVerticesNeedsUpdate = !0;
      this.faces = c || [];
      this.faceNormals = [];
      this.computeNormals();
      this.worldFaceNormalsNeedsUpdate = !0;
      this.worldFaceNormals = [];
      this.uniqueEdges = [];
      this.uniqueAxes = e ? e.slice() : null;
      this.computeEdges();
      this.updateBoundingSphereRadius();
    }
    l.exports = b;
    var f = h("./Shape"), k = h("../math/Vec3"), c = (h("../math/Quaternion"), h("../math/Transform"));
    b.prototype = new f;
    b.prototype.constructor = b;
    var g = new k;
    b.prototype.computeEdges = function() {
      for (var b = this.faces, c = this.vertices, e = (c.length, this.uniqueEdges), f = e.length = 0;f !== b.length;f++) {
        for (var k = b[f], q = k.length, h = 0;h !== q;h++) {
          c[k[h]].vsub(c[k[(h + 1) % q]], g);
          g.normalize();
          for (var p = !1, n = 0;n !== e.length;n++) {
            if (e[n].almostEquals(g) || e[n].almostEquals(g)) {
              p = !0;
              break;
            }
          }
          p || e.push(g.clone());
        }
      }
    };
    b.prototype.computeNormals = function() {
      this.faceNormals.length = this.faces.length;
      for (var b = 0;b < this.faces.length;b++) {
        for (var c = 0;c < this.faces[b].length;c++) {
          if (!this.vertices[this.faces[b][c]]) {
            throw Error("Vertex " + this.faces[b][c] + " not found!");
          }
        }
        c = this.faceNormals[b] || new k;
        this.getFaceNormal(b, c);
        c.negate(c);
        this.faceNormals[b] = c;
        if (0 > c.dot(this.vertices[this.faces[b][0]])) {
          for (console.error(".faceNormals[" + b + "] = Vec3(" + c.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule."), c = 0;c < this.faces[b].length;c++) {
            console.warn(".vertices[" + this.faces[b][c] + "] = Vec3(" + this.vertices[this.faces[b][c]].toString() + ")");
          }
        }
      }
    };
    var e = new k, p = new k;
    b.computeNormal = function(b, c, g, f) {
      c.vsub(b, p);
      g.vsub(c, e);
      e.cross(p, f);
      f.isZero() || f.normalize();
    };
    b.prototype.getFaceNormal = function(c, e) {
      c = this.faces[c];
      return b.computeNormal(this.vertices[c[0]], this.vertices[c[1]], this.vertices[c[2]], e);
    };
    var r = new k;
    b.prototype.clipAgainstHull = function(b, c, e, g, f, q, h, p, n) {
      for (var l = -1, u = -Number.MAX_VALUE, w = 0;w < e.faces.length;w++) {
        r.copy(e.faceNormals[w]);
        f.vmult(r, r);
        var B = r.dot(q);
        B > u && (u = B, l = w);
      }
      for (var u = [], w = e.faces[l], B = w.length, t = 0;B > t;t++) {
        var v = e.vertices[w[t]], y = new k;
        y.copy(v);
        f.vmult(y, y);
        g.vadd(y, y);
        u.push(y);
      }
      0 <= l && this.clipFaceAgainstHull(q, b, c, u, h, p, n);
    };
    var w = new k, n = new k, t = new k, v = new k, y = new k, x = new k;
    b.prototype.findSeparatingAxis = function(b, c, e, g, f, k, q, h) {
      var p = Number.MAX_VALUE, l = 0;
      if (this.uniqueAxes) {
        for (var u = 0;u !== this.uniqueAxes.length;u++) {
          e.vmult(this.uniqueAxes[u], w);
          var r = this.testSepAxis(w, b, c, e, g, f);
          if (!1 === r) {
            return !1;
          }
          p > r && (p = r, k.copy(w));
        }
      } else {
        for (var B = q ? q.length : this.faces.length, u = 0;B > u;u++) {
          r = q ? q[u] : u;
          w.copy(this.faceNormals[r]);
          e.vmult(w, w);
          r = this.testSepAxis(w, b, c, e, g, f);
          if (!1 === r) {
            return !1;
          }
          p > r && (p = r, k.copy(w));
        }
      }
      if (b.uniqueAxes) {
        for (u = 0;u !== b.uniqueAxes.length;u++) {
          f.vmult(b.uniqueAxes[u], n);
          l++;
          r = this.testSepAxis(n, b, c, e, g, f);
          if (!1 === r) {
            return !1;
          }
          p > r && (p = r, k.copy(n));
        }
      } else {
        for (q = h ? h.length : b.faces.length, u = 0;q > u;u++) {
          r = h ? h[u] : u;
          n.copy(b.faceNormals[r]);
          f.vmult(n, n);
          l++;
          r = this.testSepAxis(n, b, c, e, g, f);
          if (!1 === r) {
            return !1;
          }
          p > r && (p = r, k.copy(n));
        }
      }
      for (h = 0;h !== this.uniqueEdges.length;h++) {
        for (e.vmult(this.uniqueEdges[h], v), l = 0;l !== b.uniqueEdges.length;l++) {
          if (f.vmult(b.uniqueEdges[l], y), v.cross(y, x), !x.almostZero()) {
            x.normalize();
            u = this.testSepAxis(x, b, c, e, g, f);
            if (!1 === u) {
              return !1;
            }
            p > u && (p = u, k.copy(x));
          }
        }
      }
      return g.vsub(c, t), 0 < t.dot(k) && k.negate(k), !0;
    };
    var q = [], u = [];
    b.prototype.testSepAxis = function(c, e, g, f, k, h) {
      b.project(this, c, g, f, q);
      b.project(e, c, k, h, u);
      g = q[0];
      c = q[1];
      e = u[0];
      f = u[1];
      if (f > g || c > e) {
        return !1;
      }
      g -= f;
      c = e - c;
      return c > g ? g : c;
    };
    var B = new k, C = new k;
    b.prototype.calculateLocalInertia = function(b, c) {
      this.computeLocalAABB(B, C);
      var e = C.x - B.x, g = C.y - B.y, f = C.z - B.z;
      c.x = 1 / 12 * b * (4 * g * g + 4 * f * f);
      c.y = 1 / 12 * b * (4 * e * e + 4 * f * f);
      c.z = 1 / 12 * b * (4 * g * g + 4 * e * e);
    };
    b.prototype.getPlaneConstantOfFace = function(b) {
      return -this.faceNormals[b].dot(this.vertices[this.faces[b][0]]);
    };
    var D = new k, F = new k, E = new k, z = new k, I = new k, J = new k, R = new k, L = new k;
    b.prototype.clipFaceAgainstHull = function(b, c, e, g, f, k, q) {
      for (var h = [], p = -1, n = Number.MAX_VALUE, l = 0;l < this.faces.length;l++) {
        D.copy(this.faceNormals[l]);
        e.vmult(D, D);
        var u = D.dot(b);
        n > u && (n = u, p = l);
      }
      if (!(0 > p)) {
        b = this.faces[p];
        b.connectedFaces = [];
        for (n = 0;n < this.faces.length;n++) {
          for (l = 0;l < this.faces[n].length;l++) {
            -1 !== b.indexOf(this.faces[n][l]) && n !== p && -1 === b.connectedFaces.indexOf(n) && b.connectedFaces.push(n);
          }
        }
        n = (g.length, b.length);
        for (l = 0;n > l;l++) {
          u = this.vertices[b[l]];
          u.vsub(this.vertices[b[(l + 1) % n]], F);
          E.copy(F);
          e.vmult(E, E);
          c.vadd(E, E);
          z.copy(this.faceNormals[p]);
          e.vmult(z, z);
          c.vadd(z, z);
          E.cross(z, I);
          I.negate(I);
          J.copy(u);
          e.vmult(J, J);
          c.vadd(J, J);
          u = (-J.dot(I), b.connectedFaces[l]);
          R.copy(this.faceNormals[u]);
          u = this.getPlaneConstantOfFace(u);
          L.copy(R);
          e.vmult(L, L);
          u -= L.dot(c);
          for (this.clipFaceAgainstPlane(g, h, L, u);g.length;) {
            g.shift();
          }
          for (;h.length;) {
            g.push(h.shift());
          }
        }
        R.copy(this.faceNormals[p]);
        u = this.getPlaneConstantOfFace(p);
        L.copy(R);
        e.vmult(L, L);
        u -= L.dot(c);
        for (n = 0;n < g.length;n++) {
          if (c = L.dot(g[n]) + u, f >= c && (console.log("clamped: depth=" + c + " to minDist=" + (f + "")), c = f), k >= c) {
            e = g[n], 0 >= c && q.push({point:e, normal:L, depth:c});
          }
        }
      }
    };
    b.prototype.clipFaceAgainstPlane = function(b, c, e, g) {
      var f, q, h = b.length;
      if (2 > h) {
        return c;
      }
      var p = b[b.length - 1], n = b[0];
      f = e.dot(p) + g;
      for (var l = 0;h > l;l++) {
        if (n = b[l], q = e.dot(n) + g, 0 > f) {
          if (0 > q) {
            var u = new k;
            u.copy(n);
          } else {
            u = new k, p.lerp(n, f / (f - q), u);
          }
          c.push(u);
        } else {
          0 > q && (u = new k, p.lerp(n, f / (f - q), u), c.push(u), c.push(n));
        }
        p = n;
        f = q;
      }
      return c;
    };
    b.prototype.computeWorldVertices = function(b, c) {
      for (var e = this.vertices.length;this.worldVertices.length < e;) {
        this.worldVertices.push(new k);
      }
      for (var g = this.vertices, f = this.worldVertices, q = 0;q !== e;q++) {
        c.vmult(g[q], f[q]), b.vadd(f[q], f[q]);
      }
      this.worldVerticesNeedsUpdate = !1;
    };
    new k;
    b.prototype.computeLocalAABB = function(b, c) {
      var e = this.vertices.length, g = this.vertices;
      b.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      c.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
      for (var f = 0;e > f;f++) {
        var k = g[f];
        k.x < b.x ? b.x = k.x : k.x > c.x && (c.x = k.x);
        k.y < b.y ? b.y = k.y : k.y > c.y && (c.y = k.y);
        k.z < b.z ? b.z = k.z : k.z > c.z && (c.z = k.z);
      }
    };
    b.prototype.computeWorldFaceNormals = function(b) {
      for (var c = this.faceNormals.length;this.worldFaceNormals.length < c;) {
        this.worldFaceNormals.push(new k);
      }
      for (var e = this.faceNormals, g = this.worldFaceNormals, f = 0;f !== c;f++) {
        b.vmult(e[f], g[f]);
      }
      this.worldFaceNormalsNeedsUpdate = !1;
    };
    b.prototype.updateBoundingSphereRadius = function() {
      for (var b = 0, c = this.vertices, e = 0, g = c.length;e !== g;e++) {
        var f = c[e].norm2();
        f > b && (b = f);
      }
      this.boundingSphereRadius = Math.sqrt(b);
    };
    var M = new k;
    b.prototype.calculateWorldAABB = function(b, c, e, g) {
      for (var f, k, q, h, p, n, l = this.vertices.length, u = this.vertices, r = 0;l > r;r++) {
        M.copy(u[r]);
        c.vmult(M, M);
        b.vadd(M, M);
        var w = M;
        w.x < f || void 0 === f ? f = w.x : (w.x > h || void 0 === h) && (h = w.x);
        w.y < k || void 0 === k ? k = w.y : (w.y > p || void 0 === p) && (p = w.y);
        w.z < q || void 0 === q ? q = w.z : (w.z > n || void 0 === n) && (n = w.z);
      }
      e.set(f, k, q);
      g.set(h, p, n);
    };
    b.prototype.volume = function() {
      return 4 * Math.PI * this.boundingSphereRadius / 3;
    };
    b.prototype.getAveragePointLocal = function(b) {
      b = b || new k;
      for (var c = this.vertices.length, e = this.vertices, g = 0;c > g;g++) {
        b.vadd(e[g], b);
      }
      return b.mult(1 / c, b), b;
    };
    b.prototype.transformAllPoints = function(b, c) {
      var e = this.vertices.length, g = this.vertices;
      if (c) {
        for (var f = 0;e > f;f++) {
          var k = g[f];
          c.vmult(k, k);
        }
        for (f = 0;f < this.faceNormals.length;f++) {
          k = this.faceNormals[f], c.vmult(k, k);
        }
      }
      if (b) {
        for (f = 0;e > f;f++) {
          k = g[f], k.vadd(b, k);
        }
      }
    };
    var P = new k, H = new k, ba = new k;
    b.prototype.pointIsInside = function(b) {
      var c, e = this.vertices, g = this.faces, f = this.faceNormals, k = this.faces.length;
      this.getAveragePointLocal(P);
      for (var q = 0;k > q;q++) {
        c = (this.faces[q].length, f[q]);
        var h = e[g[q][0]], p = H;
        b.vsub(h, p);
        var p = c.dot(p), n = ba;
        P.vsub(h, n);
        c = c.dot(n);
        if (0 > p && 0 < c || 0 < p && 0 > c) {
          return !1;
        }
      }
      return -1;
    };
    var ha = (new k, new k), Z = new k;
    b.project = function(b, e, g, f, k) {
      var q = b.vertices.length;
      b = b.vertices;
      Z.setZero();
      c.vectorToLocalFrame(g, f, e, ha);
      c.pointToLocalFrame(g, f, Z, Z);
      f = Z.dot(ha);
      g = e = b[0].dot(ha);
      for (var h = 1;q > h;h++) {
        var p = b[h].dot(ha);
        p > e && (e = p);
        g > p && (g = p);
      }
      if (g -= f, e -= f, g > e) {
        e = g = e;
      }
      k[0] = e;
      k[1] = g;
    };
  }, {"../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "./Shape":43}], 39:[function(h, l) {
    function b(b, e, h, l) {
      var g = [], p = [], r = [], v = [], y = [], x = Math.cos, q = Math.sin;
      g.push(new k(e * x(0), e * q(0), .5 * -h));
      v.push(0);
      g.push(new k(b * x(0), b * q(0), .5 * h));
      y.push(1);
      for (var u = 0;l > u;u++) {
        var B = 2 * Math.PI / l * (u + 1), C = 2 * Math.PI / l * (u + .5);
        l - 1 > u ? (g.push(new k(e * x(B), e * q(B), .5 * -h)), v.push(2 * u + 2), g.push(new k(b * x(B), b * q(B), .5 * h)), y.push(2 * u + 3), r.push([2 * u + 2, 2 * u + 3, 2 * u + 1, 2 * u])) : r.push([0, 1, 2 * u + 1, 2 * u]);
        (1 === l % 2 || l / 2 > u) && p.push(new k(x(C), q(C), 0));
      }
      r.push(y);
      p.push(new k(0, 0, 1));
      b = [];
      for (u = 0;u < v.length;u++) {
        b.push(v[v.length - u - 1]);
      }
      r.push(b);
      this.type = f.types.CONVEXPOLYHEDRON;
      c.call(this, g, r, p);
    }
    l.exports = b;
    var f = h("./Shape"), k = h("../math/Vec3"), c = (h("../math/Quaternion"), h("./ConvexPolyhedron"));
    b.prototype = new c;
  }, {"../math/Quaternion":28, "../math/Vec3":30, "./ConvexPolyhedron":38, "./Shape":43}], 40:[function(h, l) {
    function b(b, h) {
      h = g.defaults(h, {maxValue:null, minValue:null, elementSize:1});
      this.data = b;
      this.maxValue = h.maxValue;
      this.minValue = h.minValue;
      this.elementSize = h.elementSize;
      null === h.minValue && this.updateMinValue();
      null === h.maxValue && this.updateMaxValue();
      this.cacheEnabled = !0;
      f.call(this);
      this.pillarConvex = new k;
      this.pillarOffset = new c;
      this.type = f.types.HEIGHTFIELD;
      this.updateBoundingSphereRadius();
      this._cachedPillars = {};
    }
    var f = h("./Shape"), k = h("./ConvexPolyhedron"), c = h("../math/Vec3"), g = h("../utils/Utils");
    l.exports = b;
    b.prototype = new f;
    b.prototype.update = function() {
      this._cachedPillars = {};
    };
    b.prototype.updateMinValue = function() {
      for (var b = this.data, c = b[0][0], g = 0;g !== b.length;g++) {
        for (var f = 0;f !== b[g].length;f++) {
          var k = b[g][f];
          c > k && (c = k);
        }
      }
      this.minValue = c;
    };
    b.prototype.updateMaxValue = function() {
      for (var b = this.data, c = b[0][0], g = 0;g !== b.length;g++) {
        for (var f = 0;f !== b[g].length;f++) {
          var k = b[g][f];
          k > c && (c = k);
        }
      }
      this.maxValue = c;
    };
    b.prototype.setHeightValueAtIndex = function(b, c, g) {
      this.data[b][c] = g;
      this.clearCachedConvexTrianglePillar(b, c, !1);
      0 < b && (this.clearCachedConvexTrianglePillar(b - 1, c, !0), this.clearCachedConvexTrianglePillar(b - 1, c, !1));
      0 < c && (this.clearCachedConvexTrianglePillar(b, c - 1, !0), this.clearCachedConvexTrianglePillar(b, c - 1, !1));
      0 < c && 0 < b && this.clearCachedConvexTrianglePillar(b - 1, c - 1, !0);
    };
    b.prototype.getRectMinMax = function(b, c, g, f, k) {
      k = k || [];
      for (var e = this.data, h = this.minValue;g >= b;b++) {
        for (var p = c;f >= p;p++) {
          var l = e[b][p];
          l > h && (h = l);
        }
      }
      k[0] = this.minValue;
      k[1] = h;
    };
    b.prototype.getIndexOfPosition = function(b, c, g, f) {
      var e = this.elementSize, k = this.data;
      b = Math.floor(b / e);
      c = Math.floor(c / e);
      return g[0] = b, g[1] = c, f && (0 > b && (b = 0), 0 > c && (c = 0), b >= k.length - 1 && (b = k.length - 1), c >= k[0].length - 1 && (c = k[0].length - 1)), 0 > b || 0 > c || b >= k.length - 1 || c >= k[0].length - 1 ? !1 : !0;
    };
    b.prototype.getHeightAt = function(b, c, g) {
      var e = [];
      this.getIndexOfPosition(b, c, e, g);
      b = [];
      return this.getRectMinMax(e[0], e[1] + 1, e[0], e[1] + 1, b), (b[0] + b[1]) / 2;
    };
    b.prototype.getCacheConvexTrianglePillarKey = function(b, c, g) {
      return b + "_" + c + "_" + (g ? 1 : 0);
    };
    b.prototype.getCachedConvexTrianglePillar = function(b, c, g) {
      return this._cachedPillars[this.getCacheConvexTrianglePillarKey(b, c, g)];
    };
    b.prototype.setCachedConvexTrianglePillar = function(b, c, g, f, k) {
      this._cachedPillars[this.getCacheConvexTrianglePillarKey(b, c, g)] = {convex:f, offset:k};
    };
    b.prototype.clearCachedConvexTrianglePillar = function(b, c, g) {
      delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(b, c, g)];
    };
    b.prototype.getConvexTrianglePillar = function(b, g, f) {
      var e = this.pillarConvex, h = this.pillarOffset;
      if (this.cacheEnabled) {
        var p = this.getCachedConvexTrianglePillar(b, g, f);
        if (p) {
          return this.pillarConvex = p.convex, void(this.pillarOffset = p.offset);
        }
        e = new k;
        h = new c;
        this.pillarConvex = e;
        this.pillarOffset = h;
      }
      var p = this.data, l = this.elementSize, r = e.faces;
      e.vertices.length = 6;
      for (var x = 0;6 > x;x++) {
        e.vertices[x] || (e.vertices[x] = new c);
      }
      r.length = 5;
      for (x = 0;5 > x;x++) {
        r[x] || (r[x] = []);
      }
      var x = e.vertices, q = (Math.min(p[b][g], p[b + 1][g], p[b][g + 1], p[b + 1][g + 1]) - this.minValue) / 2 + this.minValue;
      f ? (h.set((b + .75) * l, (g + .75) * l, q), x[0].set(.25 * l, .25 * l, p[b + 1][g + 1] - q), x[1].set(-.75 * l, .25 * l, p[b][g + 1] - q), x[2].set(.25 * l, -.75 * l, p[b + 1][g] - q), x[3].set(.25 * l, .25 * l, -q - 1), x[4].set(-.75 * l, .25 * l, -q - 1), x[5].set(.25 * l, -.75 * l, -q - 1), r[0][0] = 0, r[0][1] = 1, r[0][2] = 2, r[1][0] = 5, r[1][1] = 4, r[1][2] = 3, r[2][0] = 2, r[2][1] = 5, r[2][2] = 3, r[2][3] = 0, r[3][0] = 3, r[3][1] = 4, r[3][2] = 1, r[3][3] = 0, r[4][0] = 1, r[4][1] = 
      4, r[4][2] = 5, r[4][3] = 2) : (h.set((b + .25) * l, (g + .25) * l, q), x[0].set(-.25 * l, -.25 * l, p[b][g] - q), x[1].set(.75 * l, -.25 * l, p[b + 1][g] - q), x[2].set(-.25 * l, .75 * l, p[b][g + 1] - q), x[3].set(-.25 * l, -.25 * l, -q - 1), x[4].set(.75 * l, -.25 * l, -q - 1), x[5].set(-.25 * l, .75 * l, -q - 1), r[0][0] = 0, r[0][1] = 1, r[0][2] = 2, r[1][0] = 5, r[1][1] = 4, r[1][2] = 3, r[2][0] = 0, r[2][1] = 2, r[2][2] = 5, r[2][3] = 3, r[3][0] = 1, r[3][1] = 0, r[3][2] = 3, r[3][3] = 
      4, r[4][0] = 4, r[4][1] = 5, r[4][2] = 2, r[4][3] = 1);
      e.computeNormals();
      e.computeEdges();
      e.updateBoundingSphereRadius();
      this.setCachedConvexTrianglePillar(b, g, f, e, h);
    };
    b.prototype.calculateLocalInertia = function(b, g) {
      return g = g || new c, g.set(0, 0, 0), g;
    };
    b.prototype.volume = function() {
      return Number.MAX_VALUE;
    };
    b.prototype.calculateWorldAABB = function(b, c, g, f) {
      g.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
      f.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    };
    b.prototype.updateBoundingSphereRadius = function() {
      var b = this.data, g = this.elementSize;
      this.boundingSphereRadius = (new c(b.length * g, b[0].length * g, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue)))).norm();
    };
  }, {"../math/Vec3":30, "../utils/Utils":53, "./ConvexPolyhedron":38, "./Shape":43}], 41:[function(h, l) {
    function b() {
      f.call(this);
      this.type = f.types.PARTICLE;
    }
    l.exports = b;
    var f = h("./Shape"), k = h("../math/Vec3");
    b.prototype = new f;
    b.prototype.constructor = b;
    b.prototype.calculateLocalInertia = function(b, g) {
      return g = g || new k, g.set(0, 0, 0), g;
    };
    b.prototype.volume = function() {
      return 0;
    };
    b.prototype.updateBoundingSphereRadius = function() {
      this.boundingSphereRadius = 0;
    };
    b.prototype.calculateWorldAABB = function(b, g, e, f) {
      e.copy(b);
      f.copy(b);
    };
  }, {"../math/Vec3":30, "./Shape":43}], 42:[function(h, l) {
    function b() {
      f.call(this);
      this.type = f.types.PLANE;
      this.worldNormal = new k;
      this.worldNormalNeedsUpdate = !0;
      this.boundingSphereRadius = Number.MAX_VALUE;
    }
    l.exports = b;
    var f = h("./Shape"), k = h("../math/Vec3");
    b.prototype = new f;
    b.prototype.constructor = b;
    b.prototype.computeWorldNormal = function(b) {
      var c = this.worldNormal;
      c.set(0, 0, 1);
      b.vmult(c, c);
      this.worldNormalNeedsUpdate = !1;
    };
    b.prototype.calculateLocalInertia = function(b, c) {
      return c || new k;
    };
    b.prototype.volume = function() {
      return Number.MAX_VALUE;
    };
    var c = new k;
    b.prototype.calculateWorldAABB = function(b, e, f, k) {
      c.set(0, 0, 1);
      e.vmult(c, c);
      e = Number.MAX_VALUE;
      f.set(-e, -e, -e);
      k.set(e, e, e);
      1 === c.x && (k.x = b.x);
      1 === c.y && (k.y = b.y);
      1 === c.z && (k.z = b.z);
      -1 === c.x && (f.x = b.x);
      -1 === c.y && (f.y = b.y);
      -1 === c.z && (f.z = b.z);
    };
    b.prototype.updateBoundingSphereRadius = function() {
      this.boundingSphereRadius = Number.MAX_VALUE;
    };
  }, {"../math/Vec3":30, "./Shape":43}], 43:[function(h, l) {
    function b() {
      this.id = b.idCounter++;
      this.boundingSphereRadius = this.type = 0;
      this.collisionResponse = !0;
      this.material = null;
    }
    l.exports = b;
    b = h("./Shape");
    h("../math/Vec3");
    h("../math/Quaternion");
    h("../material/Material");
    b.prototype.constructor = b;
    b.prototype.updateBoundingSphereRadius = function() {
      throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
    };
    b.prototype.volume = function() {
      throw "volume() not implemented for shape type " + this.type;
    };
    b.prototype.calculateLocalInertia = function() {
      throw "calculateLocalInertia() not implemented for shape type " + this.type;
    };
    b.idCounter = 0;
    b.types = {SPHERE:1, PLANE:2, BOX:4, COMPOUND:8, CONVEXPOLYHEDRON:16, HEIGHTFIELD:32, PARTICLE:64, CYLINDER:128, TRIMESH:256};
  }, {"../material/Material":25, "../math/Quaternion":28, "../math/Vec3":30, "./Shape":43}], 44:[function(h, l) {
    function b(b) {
      if (f.call(this), this.radius = void 0 !== b ? Number(b) : 1, this.type = f.types.SPHERE, 0 > this.radius) {
        throw Error("The sphere radius cannot be negative.");
      }
      this.updateBoundingSphereRadius();
    }
    l.exports = b;
    var f = h("./Shape"), k = h("../math/Vec3");
    b.prototype = new f;
    b.prototype.constructor = b;
    b.prototype.calculateLocalInertia = function(b, g) {
      g = g || new k;
      b = 2 * b * this.radius * this.radius / 5;
      return g.x = b, g.y = b, g.z = b, g;
    };
    b.prototype.volume = function() {
      return 4 * Math.PI * this.radius / 3;
    };
    b.prototype.updateBoundingSphereRadius = function() {
      this.boundingSphereRadius = this.radius;
    };
    b.prototype.calculateWorldAABB = function(b, g, e, f) {
      g = this.radius;
      for (var c = ["x", "y", "z"], k = 0;k < c.length;k++) {
        var h = c[k];
        e[h] = b[h] - g;
        f[h] = b[h] + g;
      }
    };
  }, {"../math/Vec3":30, "./Shape":43}], 45:[function(h, l) {
    function b(b, c) {
      f.call(this);
      this.type = f.types.TRIMESH;
      this.vertices = new Float32Array(b);
      this.indices = new Int16Array(c);
      this.normals = new Float32Array(c.length);
      this.aabb = new g;
      this.edges = null;
      this.scale = new k(1, 1, 1);
      this.tree = new e;
      this.updateEdges();
      this.updateNormals();
      this.updateAABB();
      this.updateBoundingSphereRadius();
      this.updateTree();
    }
    l.exports = b;
    var f = h("./Shape"), k = h("../math/Vec3"), c = (h("../math/Quaternion"), h("../math/Transform")), g = h("../collision/AABB"), e = h("../utils/Octree");
    b.prototype = new f;
    b.prototype.constructor = b;
    var p = new k;
    b.prototype.updateTree = function() {
      var b = this.tree;
      b.reset();
      b.aabb.copy(this.aabb);
      var c = this.scale;
      b.aabb.lowerBound.x *= 1 / c.x;
      b.aabb.lowerBound.y *= 1 / c.y;
      b.aabb.lowerBound.z *= 1 / c.z;
      b.aabb.upperBound.x *= 1 / c.x;
      b.aabb.upperBound.y *= 1 / c.y;
      b.aabb.upperBound.z *= 1 / c.z;
      for (var c = new g, e = new k, f = new k, q = new k, h = [e, f, q], p = 0;p < this.indices.length / 3;p++) {
        var l = 3 * p;
        this._getUnscaledVertex(this.indices[l], e);
        this._getUnscaledVertex(this.indices[l + 1], f);
        this._getUnscaledVertex(this.indices[l + 2], q);
        c.setFromPoints(h);
        b.insert(c, p);
      }
      b.removeEmptyNodes();
    };
    var r = new g;
    b.prototype.getTrianglesInAABB = function(b, c) {
      r.copy(b);
      var e = this.scale;
      b = e.x;
      var g = e.y, e = e.z, f = r.lowerBound, k = r.upperBound;
      return f.x /= b, f.y /= g, f.z /= e, k.x /= b, k.y /= g, k.z /= e, this.tree.aabbQuery(r, c);
    };
    b.prototype.setScale = function(b) {
      var c = b.x === b.y === b.z;
      this.scale.x === this.scale.y === this.scale.z && c || this.updateNormals();
      this.scale.copy(b);
      this.updateAABB();
      this.updateBoundingSphereRadius();
    };
    b.prototype.updateNormals = function() {
      for (var c = this.normals, e = 0;e < this.indices.length / 3;e++) {
        var g = 3 * e, f = this.indices[g + 1], k = this.indices[g + 2];
        this.getVertex(this.indices[g], y);
        this.getVertex(f, x);
        this.getVertex(k, q);
        b.computeNormal(x, y, q, p);
        c[g] = p.x;
        c[g + 1] = p.y;
        c[g + 2] = p.z;
      }
    };
    b.prototype.updateEdges = function() {
      for (var b = {}, c = function() {
        b[k > f ? f + "_" + k : k + "_" + f] = !0;
      }, e = 0;e < this.indices.length / 3;e++) {
        var g = 3 * e, f = this.indices[g], k = this.indices[g + 1], g = this.indices[g + 2];
        c(f, k);
        c(k, g);
        c(g, f);
      }
      c = Object.keys(b);
      this.edges = new Int16Array(2 * c.length);
      for (e = 0;e < c.length;e++) {
        g = c[e].split("_"), this.edges[2 * e] = parseInt(g[0], 10), this.edges[2 * e + 1] = parseInt(g[1], 10);
      }
    };
    b.prototype.getEdgeVertex = function(b, c, e) {
      this.getVertex(this.edges[2 * b + (c ? 1 : 0)], e);
    };
    var w = new k, n = new k;
    b.prototype.getEdgeVector = function(b, c) {
      this.getEdgeVertex(b, 0, w);
      this.getEdgeVertex(b, 1, n);
      n.vsub(w, c);
    };
    var t = new k, v = new k;
    b.computeNormal = function(b, c, e, g) {
      c.vsub(b, v);
      e.vsub(c, t);
      t.cross(v, g);
      g.isZero() || g.normalize();
    };
    var y = new k, x = new k, q = new k;
    b.prototype.getVertex = function(b, c) {
      var e = this.scale;
      return this._getUnscaledVertex(b, c), c.x *= e.x, c.y *= e.y, c.z *= e.z, c;
    };
    b.prototype._getUnscaledVertex = function(b, c) {
      b *= 3;
      var e = this.vertices;
      return c.set(e[b], e[b + 1], e[b + 2]);
    };
    b.prototype.getWorldVertex = function(b, e, g, f) {
      return this.getVertex(b, f), c.pointToWorldFrame(e, g, f, f), f;
    };
    b.prototype.getTriangleVertices = function(b, c, e, g) {
      b *= 3;
      this.getVertex(this.indices[b], c);
      this.getVertex(this.indices[b + 1], e);
      this.getVertex(this.indices[b + 2], g);
    };
    b.prototype.getNormal = function(b, c) {
      b *= 3;
      return c.set(this.normals[b], this.normals[b + 1], this.normals[b + 2]);
    };
    var u = new g;
    b.prototype.calculateLocalInertia = function(b, c) {
      this.computeLocalAABB(u);
      var e = u.upperBound.x - u.lowerBound.x, g = u.upperBound.y - u.lowerBound.y, f = u.upperBound.z - u.lowerBound.z;
      return c.set(1 / 12 * b * (4 * g * g + 4 * f * f), 1 / 12 * b * (4 * e * e + 4 * f * f), 1 / 12 * b * (4 * g * g + 4 * e * e));
    };
    var B = new k;
    b.prototype.computeLocalAABB = function(b) {
      var c = b.lowerBound;
      b = b.upperBound;
      var e = this.vertices.length, g = (this.vertices, B);
      this.getVertex(0, g);
      c.copy(g);
      b.copy(g);
      for (var f = 0;f !== e;f++) {
        this.getVertex(f, g), g.x < c.x ? c.x = g.x : g.x > b.x && (b.x = g.x), g.y < c.y ? c.y = g.y : g.y > b.y && (b.y = g.y), g.z < c.z ? c.z = g.z : g.z > b.z && (b.z = g.z);
      }
    };
    b.prototype.updateAABB = function() {
      this.computeLocalAABB(this.aabb);
    };
    b.prototype.updateBoundingSphereRadius = function() {
      for (var b = 0, c = this.vertices, e = new k, g = 0, c = c.length / 3;g !== c;g++) {
        this.getVertex(g, e);
        var f = e.norm2();
        f > b && (b = f);
      }
      this.boundingSphereRadius = Math.sqrt(b);
    };
    var C = (new k, new c), D = new g;
    b.prototype.calculateWorldAABB = function(b, c, e, g) {
      C.position = b;
      C.quaternion = c;
      this.aabb.toWorldFrame(C, D);
      e.copy(D.lowerBound);
      g.copy(D.upperBound);
    };
    b.prototype.volume = function() {
      return 4 * Math.PI * this.boundingSphereRadius / 3;
    };
    b.createTorus = function(c, e, g, f, k) {
      c = c || 1;
      e = e || .5;
      g = g || 8;
      f = f || 6;
      k = k || 2 * Math.PI;
      for (var q = [], h = [], p = 0;g >= p;p++) {
        for (var l = 0;f >= l;l++) {
          var n = l / f * k, u = p / g * Math.PI * 2;
          q.push((c + e * Math.cos(u)) * Math.cos(n), (c + e * Math.cos(u)) * Math.sin(n), e * Math.sin(u));
        }
      }
      for (p = 1;g >= p;p++) {
        for (l = 1;f >= l;l++) {
          c = (f + 1) * (p - 1) + l - 1, e = (f + 1) * (p - 1) + l, k = (f + 1) * p + l, h.push((f + 1) * p + l - 1, c, k), h.push(c, e, k);
        }
      }
      return new b(q, h);
    };
  }, {"../collision/AABB":3, "../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "../utils/Octree":50, "./Shape":43}], 46:[function(h, l) {
    function b() {
      f.call(this);
      this.iterations = 10;
      this.tolerance = 1E-7;
    }
    l.exports = b;
    var f = (h("../math/Vec3"), h("../math/Quaternion"), h("./Solver"));
    b.prototype = new f;
    var k = [], c = [], g = [];
    b.prototype.solve = function(b, f) {
      var e, h, p, l, v = 0, y = this.iterations, x = this.tolerance * this.tolerance, q = this.equations, u = q.length;
      f = f.bodies;
      var B = f.length;
      if (0 !== u) {
        for (p = 0;p !== B;p++) {
          f[p].updateSolveMassProperties();
        }
      }
      c.length = u;
      g.length = u;
      k.length = u;
      for (p = 0;p !== u;p++) {
        var C = q[p];
        k[p] = 0;
        g[p] = C.computeB(b);
        c[p] = 1 / C.computeC();
      }
      if (0 !== u) {
        for (p = 0;p !== B;p++) {
          C = f[p], v = C.wlambda, C.vlambda.set(0, 0, 0), v && v.set(0, 0, 0);
        }
        for (v = 0;v !== y;v++) {
          for (var D = p = 0;D !== u;D++) {
            C = q[D], e = g[D], h = c[D], b = k[D], l = C.computeGWlambda(), e = h * (e - l - C.eps * b), b + e < C.minForce ? e = C.minForce - b : b + e > C.maxForce && (e = C.maxForce - b), k[D] += e, p += 0 < e ? e : -e, C.addToWlambda(e);
          }
          if (x > p * p) {
            break;
          }
        }
        for (p = 0;p !== B;p++) {
          C = f[p], y = C.velocity, x = C.angularVelocity, y.vadd(C.vlambda, y), x && x.vadd(C.wlambda, x);
        }
      }
      return v;
    };
  }, {"../math/Quaternion":28, "../math/Vec3":30, "./Solver":47}], 47:[function(h, l) {
    function b() {
      this.equations = [];
    }
    l.exports = b;
    b.prototype.solve = function() {
      return 0;
    };
    b.prototype.addEquation = function(b) {
      b.enabled && this.equations.push(b);
    };
    b.prototype.removeEquation = function(b) {
      var f = this.equations;
      b = f.indexOf(b);
      -1 !== b && f.splice(b, 1);
    };
    b.prototype.removeAllEquations = function() {
      this.equations.length = 0;
    };
  }, {}], 48:[function(h, l) {
    function b(b) {
      g.call(this);
      this.iterations = 10;
      this.tolerance = 1E-7;
      this.subsolver = b;
      this.nodes = [];
      for (this.nodePool = [];128 > this.nodePool.length;) {
        this.nodePool.push(this.createNode());
      }
    }
    function f(b) {
      for (var c = b.length, e = 0;e !== c;e++) {
        var g = b[e];
        if (!(g.visited || g.body.type & w)) {
          return g;
        }
      }
      return !1;
    }
    function k(b, c, e) {
      c.push(b.body);
      c = b.eqs.length;
      for (var g = 0;g !== c;g++) {
        var f = b.eqs[g];
        -1 === e.indexOf(f) && e.push(f);
      }
    }
    function c(b, c) {
      return c.id - b.id;
    }
    l.exports = b;
    var g = (h("../math/Vec3"), h("../math/Quaternion"), h("./Solver"));
    h = h("../objects/Body");
    b.prototype = new g;
    var e = [], p = [], r = {bodies:[]}, w = h.STATIC, n = [];
    b.prototype.createNode = function() {
      return {body:null, children:[], eqs:[], visited:!1};
    };
    b.prototype.solve = function(b, g) {
      var h = this.nodePool, l = g.bodies, q = this.equations, u = q.length, w = l.length;
      for (g = this.subsolver;h.length < w;) {
        h.push(this.createNode());
      }
      e.length = w;
      for (var t = 0;w > t;t++) {
        e[t] = h[t];
      }
      for (t = 0;t !== w;t++) {
        h = e[t], h.body = l[t], h.children.length = 0, h.eqs.length = 0, h.visited = !1;
      }
      for (h = 0;h !== u;h++) {
        var w = q[h], t = l.indexOf(w.bi), v = l.indexOf(w.bj), t = e[t], v = e[v];
        t.children.push(v);
        t.eqs.push(w);
        v.children.push(t);
        v.eqs.push(w);
      }
      l = 0;
      q = p;
      g.tolerance = this.tolerance;
      for (g.iterations = this.iterations;t = f(e);) {
        q.length = 0;
        r.bodies.length = 0;
        w = t;
        t = k;
        u = r.bodies;
        h = q;
        n.push(w);
        w.visited = !0;
        for (t(w, u, h);n.length;) {
          for (v = n.pop();w = f(v.children);) {
            w.visited = !0, t(w, u, h), n.push(w);
          }
        }
        u = q.length;
        q = q.sort(c);
        for (t = 0;t !== u;t++) {
          g.addEquation(q[t]);
        }
        g.solve(b, r);
        g.removeAllEquations();
        l++;
      }
      return l;
    };
  }, {"../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "./Solver":47}], 49:[function(h, l) {
    h = function() {
    };
    l.exports = h;
    h.prototype = {constructor:h, addEventListener:function(b, f) {
      void 0 === this._listeners && (this._listeners = {});
      var k = this._listeners;
      return void 0 === k[b] && (k[b] = []), -1 === k[b].indexOf(f) && k[b].push(f), this;
    }, hasEventListener:function(b, f) {
      if (void 0 === this._listeners) {
        return !1;
      }
      var k = this._listeners;
      return void 0 !== k[b] && -1 !== k[b].indexOf(f) ? !0 : !1;
    }, removeEventListener:function(b, f) {
      if (void 0 === this._listeners) {
        return this;
      }
      var k = this._listeners;
      if (void 0 === k[b]) {
        return this;
      }
      f = k[b].indexOf(f);
      return -1 !== f && k[b].splice(f, 1), this;
    }, dispatchEvent:function(b) {
      if (void 0 === this._listeners) {
        return this;
      }
      var f = this._listeners[b.type];
      if (void 0 !== f) {
        b.target = this;
        for (var k = 0, c = f.length;c > k;k++) {
          f[k].call(this, b);
        }
      }
      return this;
    }};
  }, {}], 50:[function(h, l) {
    function b(b) {
      b = b || {};
      this.root = b.root || null;
      this.aabb = b.aabb ? b.aabb.clone() : new k;
      this.data = [];
      this.children = [];
    }
    function f(c, e) {
      e = e || {};
      e.root = null;
      e.aabb = c;
      b.call(this, e);
      this.maxDepth = "undefined" != typeof e.maxDepth ? e.maxDepth : 8;
    }
    var k = h("../collision/AABB"), c = h("../math/Vec3");
    l.exports = f;
    f.prototype = new b;
    b.prototype.reset = function() {
      this.children.length = this.data.length = 0;
    };
    b.prototype.insert = function(b, c, e) {
      var g = this.data;
      if (e = e || 0, !this.aabb.contains(b)) {
        return !1;
      }
      var f = this.children;
      if (e < (this.maxDepth || this.root.maxDepth)) {
        var k = !1;
        f.length || (this.subdivide(), k = !0);
        for (var h = 0;8 !== h;h++) {
          if (f[h].insert(b, c, e + 1)) {
            return !0;
          }
        }
        k && (f.length = 0);
      }
      return g.push(c), !0;
    };
    var g = new c;
    b.prototype.subdivide = function() {
      var e = this.aabb, f = e.lowerBound, h = e.upperBound, e = this.children;
      e.push(new b({aabb:new k({lowerBound:new c(0, 0, 0)})}), new b({aabb:new k({lowerBound:new c(1, 0, 0)})}), new b({aabb:new k({lowerBound:new c(1, 1, 0)})}), new b({aabb:new k({lowerBound:new c(1, 1, 1)})}), new b({aabb:new k({lowerBound:new c(0, 1, 1)})}), new b({aabb:new k({lowerBound:new c(0, 0, 1)})}), new b({aabb:new k({lowerBound:new c(1, 0, 1)})}), new b({aabb:new k({lowerBound:new c(0, 1, 0)})}));
      h.vsub(f, g);
      g.scale(.5, g);
      for (var h = this.root || this, l = 0;8 !== l;l++) {
        var t = e[l];
        t.root = h;
        var v = t.aabb.lowerBound;
        v.x *= g.x;
        v.y *= g.y;
        v.z *= g.z;
        v.vadd(f, v);
        v.vadd(g, t.aabb.upperBound);
      }
    };
    b.prototype.aabbQuery = function(b, c) {
      for (var e = (this.data, this.children, [this]);e.length;) {
        var g = e.pop();
        g.aabb.overlaps(b) && Array.prototype.push.apply(c, g.data);
        Array.prototype.push.apply(e, g.children);
      }
      return c;
    };
    var e = new k;
    b.prototype.rayQuery = function(b, c, g) {
      return b.getAABB(e), e.toLocalFrame(c, e), this.aabbQuery(e, g), g;
    };
    b.prototype.removeEmptyNodes = function() {
      for (var b = [this];b.length;) {
        for (var c = b.pop(), e = c.children.length - 1;0 <= e;e--) {
          c.children[e].data.length || c.children.splice(e, 1);
        }
        Array.prototype.push.apply(b, c.children);
      }
    };
  }, {"../collision/AABB":3, "../math/Vec3":30}], 51:[function(h, l) {
    function b() {
      this.objects = [];
      this.type = Object;
    }
    l.exports = b;
    b.prototype.release = function() {
      for (var b = arguments.length, k = 0;k !== b;k++) {
        this.objects.push(arguments[k]);
      }
    };
    b.prototype.get = function() {
      return 0 === this.objects.length ? this.constructObject() : this.objects.pop();
    };
    b.prototype.constructObject = function() {
      throw Error("constructObject() not implemented in this Pool subclass yet!");
    };
  }, {}], 52:[function(h, l) {
    function b() {
      this.data = {keys:[]};
    }
    l.exports = b;
    b.prototype.get = function(b, k) {
      b > k && (b = k = b);
      return this.data[b + "-" + k];
    };
    b.prototype.set = function(b, k, c) {
      b > k && (b = k = b);
      var g = b + "-" + k;
      this.get(b, k) || this.data.keys.push(g);
      this.data[g] = c;
    };
    b.prototype.reset = function() {
      for (var b = this.data, k = b.keys;0 < k.length;) {
        var c = k.pop();
        delete b[c];
      }
    };
  }, {}], 53:[function(h, l) {
    function b() {
    }
    l.exports = b;
    b.defaults = function(b, k) {
      b = b || {};
      for (var c in k) {
        c in b || (b[c] = k[c]);
      }
      return b;
    };
  }, {}], 54:[function(h, l) {
    function b() {
      k.call(this);
      this.type = f;
    }
    l.exports = b;
    var f = h("../math/Vec3"), k = h("./Pool");
    b.prototype = new k;
    b.prototype.constructObject = function() {
      return new f;
    };
  }, {"../math/Vec3":30, "./Pool":51}], 55:[function(h, l) {
    function b(b) {
      this.contactPointPool = [];
      this.frictionEquationPool = [];
      this.result = [];
      this.frictionResult = [];
      this.v3pool = new p;
      this.world = b;
      this.currentContactMaterial = null;
      this.enableFrictionReduction = !1;
    }
    l.exports = b;
    l = h("../collision/AABB");
    var f = h("../shapes/Shape"), k = h("../collision/Ray"), c = h("../math/Vec3"), g = h("../math/Transform"), e = (h("../shapes/ConvexPolyhedron"), h("../math/Quaternion")), p = (h("../solver/Solver"), h("../utils/Vec3Pool")), r = h("../equations/ContactEquation"), w = h("../equations/FrictionEquation");
    b.prototype.createContactEquation = function(b, c, e, g, f, k) {
      var q;
      this.contactPointPool.length ? (q = this.contactPointPool.pop(), q.bi = b, q.bj = c) : q = new r(b, c);
      q.enabled = b.collisionResponse && c.collisionResponse && e.collisionResponse && g.collisionResponse;
      var h = this.currentContactMaterial;
      q.restitution = h.restitution;
      q.setSpookParams(h.contactEquationStiffness, h.contactEquationRelaxation, this.world.dt);
      b = e.material || b.material;
      c = g.material || c.material;
      return b && c && 0 <= b.restitution && 0 <= c.restitution && (q.restitution = b.restitution * c.restitution), q.si = f || e, q.sj = k || g, q;
    };
    b.prototype.createFrictionEquationsFromContact = function(b, c) {
      var e = b.bi, g = b.bj, f = this.world, k = this.currentContactMaterial, q = k.friction, h = b.si.material || e.material, p = b.sj.material || g.material;
      if (h && p && 0 <= h.friction && 0 <= p.friction && (q = h.friction * p.friction), 0 < q) {
        q *= f.gravity.length();
        h = e.invMass + g.invMass;
        0 < h && (h = 1 / h);
        var l = this.frictionEquationPool, p = l.length ? l.pop() : new w(e, g, q * h), l = l.length ? l.pop() : new w(e, g, q * h);
        return p.bi = l.bi = e, p.bj = l.bj = g, p.minForce = l.minForce = -q * h, p.maxForce = l.maxForce = q * h, p.ri.copy(b.ri), p.rj.copy(b.rj), l.ri.copy(b.ri), l.rj.copy(b.rj), b.ni.tangents(p.t, l.t), p.setSpookParams(k.frictionEquationStiffness, k.frictionEquationRelaxation, f.dt), l.setSpookParams(k.frictionEquationStiffness, k.frictionEquationRelaxation, f.dt), p.enabled = l.enabled = b.enabled, c.push(p, l), !0;
      }
      return !1;
    };
    var n = new c, t = new c, v = new c;
    b.prototype.createFrictionFromAverage = function(b) {
      var c = this.result[this.result.length - 1];
      if (this.createFrictionEquationsFromContact(c, this.frictionResult) && 1 !== b) {
        var e = this.frictionResult[this.frictionResult.length - 2], g = this.frictionResult[this.frictionResult.length - 1];
        n.setZero();
        t.setZero();
        v.setZero();
        for (var f = c.bi, k = (c.bj, 0);k !== b;k++) {
          c = this.result[this.result.length - 1 - k], c.bodyA !== f ? (n.vadd(c.ni, n), t.vadd(c.ri, t), v.vadd(c.rj, v)) : (n.vsub(c.ni, n), t.vadd(c.rj, t), v.vadd(c.ri, v));
        }
        b = 1 / b;
        t.scale(b, e.ri);
        v.scale(b, e.rj);
        g.ri.copy(e.ri);
        g.rj.copy(e.rj);
        n.normalize();
        n.tangents(e.t, g.t);
      }
    };
    var y = new c, x = new c, q = new e, u = new e;
    b.prototype.getContacts = function(b, c, e, g, f, k, h) {
      this.contactPointPool = f;
      this.frictionEquationPool = h;
      this.result = g;
      this.frictionResult = k;
      g = 0;
      for (f = b.length;g !== f;g++) {
        k = b[g];
        h = c[g];
        var p = null;
        k.material && h.material && (p = e.getContactMaterial(k.material, h.material) || null);
        for (var l = 0;l < k.shapes.length;l++) {
          k.quaternion.mult(k.shapeOrientations[l], q);
          k.quaternion.vmult(k.shapeOffsets[l], y);
          y.vadd(k.position, y);
          for (var n = k.shapes[l], r = 0;r < h.shapes.length;r++) {
            h.quaternion.mult(h.shapeOrientations[r], u);
            h.quaternion.vmult(h.shapeOffsets[r], x);
            x.vadd(h.position, x);
            var w = h.shapes[r];
            if (!(y.distanceTo(x) > n.boundingSphereRadius + w.boundingSphereRadius)) {
              var B = null;
              n.material && w.material && (B = e.getContactMaterial(n.material, w.material) || null);
              this.currentContactMaterial = B || p || e.defaultContactMaterial;
              (B = this[n.type | w.type]) && (n.type < w.type ? B.call(this, n, w, y, x, q, u, k, h, n, w) : B.call(this, w, n, x, y, u, q, h, k, n, w));
            }
          }
        }
      }
    };
    b.prototype[f.types.BOX | f.types.BOX] = b.prototype.boxBox = function(b, c, e, g, f, k, h, q) {
      b.convexPolyhedronRepresentation.material = b.material;
      c.convexPolyhedronRepresentation.material = c.material;
      b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
      c.convexPolyhedronRepresentation.collisionResponse = c.collisionResponse;
      this.convexConvex(b.convexPolyhedronRepresentation, c.convexPolyhedronRepresentation, e, g, f, k, h, q, b, c);
    };
    b.prototype[f.types.BOX | f.types.CONVEXPOLYHEDRON] = b.prototype.boxConvex = function(b, c, e, g, f, k, h, q) {
      b.convexPolyhedronRepresentation.material = b.material;
      b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
      this.convexConvex(b.convexPolyhedronRepresentation, c, e, g, f, k, h, q, b, c);
    };
    b.prototype[f.types.BOX | f.types.PARTICLE] = b.prototype.boxParticle = function(b, c, e, g, f, k, h, q) {
      b.convexPolyhedronRepresentation.material = b.material;
      b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
      this.convexParticle(b.convexPolyhedronRepresentation, c, e, g, f, k, h, q, b, c);
    };
    b.prototype[f.types.SPHERE] = b.prototype.sphereSphere = function(b, c, e, g, f, k, h, q) {
      f = this.createContactEquation(h, q, b, c);
      g.vsub(e, f.ni);
      f.ni.normalize();
      f.ri.copy(f.ni);
      f.rj.copy(f.ni);
      f.ri.mult(b.radius, f.ri);
      f.rj.mult(-c.radius, f.rj);
      f.ri.vadd(e, f.ri);
      f.ri.vsub(h.position, f.ri);
      f.rj.vadd(g, f.rj);
      f.rj.vsub(q.position, f.rj);
      this.result.push(f);
      this.createFrictionEquationsFromContact(f, this.frictionResult);
    };
    var B = new c, C = new c, D = new c;
    b.prototype[f.types.PLANE | f.types.TRIMESH] = b.prototype.planeTrimesh = function(b, e, f, k, h, q, p, l) {
      var n = new c;
      B.set(0, 0, 1);
      h.vmult(B, B);
      for (h = 0;h < e.vertices.length / 3;h++) {
        e.getVertex(h, n);
        var u = new c;
        u.copy(n);
        g.pointToWorldFrame(k, q, u, n);
        u = C;
        n.vsub(f, u);
        if (0 >= B.dot(u)) {
          var r = this.createContactEquation(p, l, b, e);
          r.ni.copy(B);
          var w = D;
          B.scale(u.dot(B), w);
          n.vsub(w, w);
          r.ri.copy(w);
          r.ri.vsub(p.position, r.ri);
          r.rj.copy(n);
          r.rj.vsub(l.position, r.rj);
          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }
    };
    var F = new c, E = new c, z = (new c, new c), I = new c, J = new c, R = new c, L = new c, M = new c, P = new c, H = new c, ba = new c, ha = new c, Z = new c, ea = new l, S = [];
    b.prototype[f.types.SPHERE | f.types.TRIMESH] = b.prototype.sphereTrimesh = function(b, c, e, f, h, q, p, l) {
      g.pointToLocalFrame(f, q, e, P);
      h = b.radius;
      ea.lowerBound.set(P.x - h, P.y - h, P.z - h);
      ea.upperBound.set(P.x + h, P.y + h, P.z + h);
      c.getTrianglesInAABB(ea, S);
      var n = b.radius * b.radius;
      for (h = 0;h < S.length;h++) {
        for (var u = 0;3 > u;u++) {
          if (c.getVertex(c.indices[3 * S[h] + u], z), z.vsub(P, E), E.norm2() <= n) {
            I.copy(z);
            g.pointToWorldFrame(f, q, I, z);
            z.vsub(e, E);
            var r = this.createContactEquation(p, l, b, c);
            r.ni.copy(E);
            r.ni.normalize();
            r.ri.copy(r.ni);
            r.ri.scale(b.radius, r.ri);
            r.ri.vadd(e, r.ri);
            r.ri.vsub(p.position, r.ri);
            r.rj.copy(z);
            r.rj.vsub(l.position, r.rj);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          }
        }
      }
      for (h = 0;h < S.length;h++) {
        for (u = 0;3 > u;u++) {
          c.getVertex(c.indices[3 * S[h] + u], J), c.getVertex(c.indices[3 * S[h] + (u + 1) % 3], R), R.vsub(J, L), P.vsub(R, H), e = H.dot(L), P.vsub(J, H), r = H.dot(L), 0 < r && 0 > e && (P.vsub(J, H), M.copy(L), M.normalize(), r = H.dot(M), M.scale(r, H), H.vadd(J, H), e = H.distanceTo(P), e < b.radius && (r = this.createContactEquation(p, l, b, c), H.vsub(P, r.ni), r.ni.normalize(), r.ni.scale(b.radius, r.ri), g.pointToWorldFrame(f, q, H, H), H.vsub(l.position, r.rj), g.vectorToWorldFrame(q, 
          r.ni, r.ni), g.vectorToWorldFrame(q, r.ri, r.ri), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult)));
        }
      }
      h = 0;
      for (u = S.length;h !== u;h++) {
        if (c.getTriangleVertices(S[h], ba, ha, Z), c.getNormal(S[h], F), P.vsub(ba, H), e = H.dot(F), F.scale(e, H), P.vsub(H, H), e = H.distanceTo(P), k.pointInTriangle(H, ba, ha, Z) && e < b.radius) {
          r = this.createContactEquation(p, l, b, c), H.vsub(P, r.ni), r.ni.normalize(), r.ni.scale(b.radius, r.ri), g.pointToWorldFrame(f, q, H, H), H.vsub(l.position, r.rj), g.vectorToWorldFrame(q, r.ni, r.ni), g.vectorToWorldFrame(q, r.ri, r.ri), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }
      S.length = 0;
    };
    var V = new c, N = new c;
    b.prototype[f.types.SPHERE | f.types.PLANE] = b.prototype.spherePlane = function(b, c, e, g, f, k, h, q) {
      c = this.createContactEquation(h, q, b, c);
      if (c.ni.set(0, 0, 1), k.vmult(c.ni, c.ni), c.ni.negate(c.ni), c.ni.normalize(), c.ni.mult(b.radius, c.ri), e.vsub(g, V), c.ni.mult(c.ni.dot(V), N), V.vsub(N, c.rj), -V.dot(c.ni) <= b.radius) {
        b = c.ri, k = c.rj, b.vadd(e, b), b.vsub(h.position, b), k.vadd(g, k), k.vsub(q.position, k), this.result.push(c), this.createFrictionEquationsFromContact(c, this.frictionResult);
      }
    };
    var X = new c, ia = new c, ta = new c, T = new c, ra = new c, qa = new c, pa = new c, fa = [new c, new c, new c, new c, new c, new c], W = new c, sa = new c, xa = new c, Aa = new c;
    b.prototype[f.types.SPHERE | f.types.BOX] = b.prototype.sphereBox = function(b, c, e, g, f, k, h, q) {
      f = this.v3pool;
      e.vsub(g, T);
      c.getSideNormals(fa, k);
      k = b.radius;
      for (var p = !1, l = null, n = 0, u = 0, r = 0, w = null, B = 0, t = fa.length;B !== t && !1 === p;B++) {
        var v = ra;
        v.copy(fa[B]);
        var y = v.norm();
        v.normalize();
        var z = T.dot(v);
        if (y + k > z && 0 < z) {
          var C = qa, x = pa;
          C.copy(fa[(B + 1) % 3]);
          x.copy(fa[(B + 2) % 3]);
          var D = C.norm(), F = x.norm();
          C.normalize();
          x.normalize();
          var E = T.dot(C), N = T.dot(x);
          D > E && E > -D && F > N && N > -F && (z = Math.abs(z - y - k), (null === w || w > z) && (w = z, u = E, r = N, l = y, sa.copy(v), xa.copy(C), Aa.copy(x), n++));
        }
      }
      n && (p = !0, n = this.createContactEquation(h, q, b, c), sa.mult(-k, n.ri), n.ni.copy(sa), n.ni.negate(n.ni), sa.mult(l, sa), xa.mult(u, xa), sa.vadd(xa, sa), Aa.mult(r, Aa), sa.vadd(Aa, n.rj), n.ri.vadd(e, n.ri), n.ri.vsub(h.position, n.ri), n.rj.vadd(g, n.rj), n.rj.vsub(q.position, n.rj), this.result.push(n), this.createFrictionEquationsFromContact(n, this.frictionResult));
      z = f.get();
      for (l = 0;2 !== l && !p;l++) {
        for (u = 0;2 !== u && !p;u++) {
          for (r = 0;2 !== r && !p;r++) {
            if (z.set(0, 0, 0), l ? z.vadd(fa[0], z) : z.vsub(fa[0], z), u ? z.vadd(fa[1], z) : z.vsub(fa[1], z), r ? z.vadd(fa[2], z) : z.vsub(fa[2], z), g.vadd(z, W), W.vsub(e, W), W.norm2() < k * k) {
              p = !0, n = this.createContactEquation(h, q, b, c), n.ri.copy(W), n.ri.normalize(), n.ni.copy(n.ri), n.ri.mult(k, n.ri), n.rj.copy(z), n.ri.vadd(e, n.ri), n.ri.vsub(h.position, n.ri), n.rj.vadd(g, n.rj), n.rj.vsub(q.position, n.rj), this.result.push(n), this.createFrictionEquationsFromContact(n, this.frictionResult);
            }
          }
        }
      }
      f.release(z);
      w = f.get();
      B = f.get();
      n = f.get();
      t = f.get();
      z = f.get();
      v = fa.length;
      for (l = 0;l !== v && !p;l++) {
        for (u = 0;u !== v && !p;u++) {
          if (l % 3 !== u % 3) {
            fa[u].cross(fa[l], w);
            w.normalize();
            fa[l].vadd(fa[u], B);
            n.copy(e);
            n.vsub(B, n);
            n.vsub(g, n);
            y = n.dot(w);
            w.mult(y, t);
            for (r = 0;r === l % 3 || r === u % 3;) {
              r++;
            }
            z.copy(e);
            z.vsub(t, z);
            z.vsub(B, z);
            z.vsub(g, z);
            y = Math.abs(y);
            C = z.norm();
            y < fa[r].norm() && k > C && (p = !0, r = this.createContactEquation(h, q, b, c), B.vadd(t, r.rj), r.rj.copy(r.rj), z.negate(r.ni), r.ni.normalize(), r.ri.copy(r.rj), r.ri.vadd(g, r.ri), r.ri.vsub(e, r.ri), r.ri.normalize(), r.ri.mult(k, r.ri), r.ri.vadd(e, r.ri), r.ri.vsub(h.position, r.ri), r.rj.vadd(g, r.rj), r.rj.vsub(q.position, r.rj), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult));
          }
        }
      }
      f.release(w, B, n, t, z);
    };
    var Ba = new c, ya = new c, Ea = new c, Xa = new c, vd = new c, Ta = new c, Ua = new c, Kc = new c, U = new c, Ab = new c;
    b.prototype[f.types.SPHERE | f.types.CONVEXPOLYHEDRON] = b.prototype.sphereConvex = function(b, c, e, g, f, k, h, q) {
      f = this.v3pool;
      e.vsub(g, Ba);
      for (var p = c.faceNormals, l = c.faces, n = c.vertices, u = b.radius, r = 0;r !== n.length;r++) {
        var w = vd;
        k.vmult(n[r], w);
        g.vadd(w, w);
        var B = Xa;
        if (w.vsub(e, B), B.norm2() < u * u) {
          return b = this.createContactEquation(h, q, b, c), b.ri.copy(B), b.ri.normalize(), b.ni.copy(b.ri), b.ri.mult(u, b.ri), w.vsub(g, b.rj), b.ri.vadd(e, b.ri), b.ri.vsub(h.position, b.ri), b.rj.vadd(g, b.rj), b.rj.vsub(q.position, b.rj), this.result.push(b), void this.createFrictionEquationsFromContact(b, this.frictionResult);
        }
      }
      r = 0;
      for (w = l.length;r !== w;r++) {
        var B = l[r], t = Ta;
        k.vmult(p[r], t);
        var v = Ua;
        k.vmult(n[B[0]], v);
        v.vadd(g, v);
        var y = Kc;
        t.mult(-u, y);
        e.vadd(y, y);
        var z = U;
        y.vsub(v, z);
        y = z.dot(t);
        z = Ab;
        if (e.vsub(v, z), 0 > y && 0 < z.dot(t)) {
          for (var v = [], z = 0, C = B.length;z !== C;z++) {
            var x = f.get();
            k.vmult(n[B[z]], x);
            g.vadd(x, x);
            v.push(x);
          }
          a: {
            for (var z = v, C = t, x = e, D = null, F = z.length, E = 0;E !== F;E++) {
              var N = z[E], J = X;
              z[(E + 1) % F].vsub(N, J);
              var I = ia;
              J.cross(C, I);
              J = ta;
              x.vsub(N, J);
              N = I.dot(J);
              if (!(null === D || 0 < N && !0 === D || 0 >= N && !1 === D)) {
                z = !1;
                break a;
              }
              null === D && (D = 0 < N);
            }
            z = !0;
          }
          if (z) {
            b = this.createContactEquation(h, q, b, c);
            t.mult(-u, b.ri);
            t.negate(b.ni);
            c = f.get();
            t.mult(-y, c);
            k = f.get();
            t.mult(-u, k);
            e.vsub(g, b.rj);
            b.rj.vadd(k, b.rj);
            b.rj.vadd(c, b.rj);
            b.rj.vadd(g, b.rj);
            b.rj.vsub(q.position, b.rj);
            b.ri.vadd(e, b.ri);
            b.ri.vsub(h.position, b.ri);
            f.release(c);
            f.release(k);
            this.result.push(b);
            this.createFrictionEquationsFromContact(b, this.frictionResult);
            z = 0;
            for (B = v.length;z !== B;z++) {
              f.release(v[z]);
            }
            break;
          }
          for (z = 0;z !== B.length;z++) {
            t = f.get();
            y = f.get();
            k.vmult(n[B[(z + 1) % B.length]], t);
            k.vmult(n[B[(z + 2) % B.length]], y);
            g.vadd(t, t);
            g.vadd(y, y);
            F = ya;
            y.vsub(t, F);
            D = Ea;
            F.unit(D);
            C = f.get();
            x = f.get();
            e.vsub(t, x);
            E = x.dot(D);
            D.mult(E, C);
            C.vadd(t, C);
            D = f.get();
            if (C.vsub(e, D), 0 < E && E * E < F.norm2() && D.norm2() < u * u) {
              b = this.createContactEquation(h, q, b, c);
              C.vsub(g, b.rj);
              C.vsub(e, b.ni);
              b.ni.normalize();
              b.ni.mult(u, b.ri);
              b.rj.vadd(g, b.rj);
              b.rj.vsub(q.position, b.rj);
              b.ri.vadd(e, b.ri);
              b.ri.vsub(h.position, b.ri);
              this.result.push(b);
              this.createFrictionEquationsFromContact(b, this.frictionResult);
              z = 0;
              for (B = v.length;z !== B;z++) {
                f.release(v[z]);
              }
              return f.release(t), f.release(y), f.release(C), f.release(D), void f.release(x);
            }
            f.release(t);
            f.release(y);
            f.release(C);
            f.release(D);
            f.release(x);
          }
          z = 0;
          for (B = v.length;z !== B;z++) {
            f.release(v[z]);
          }
        }
      }
    };
    new c;
    new c;
    b.prototype[f.types.PLANE | f.types.BOX] = b.prototype.planeBox = function(b, c, e, g, f, k, h, q) {
      c.convexPolyhedronRepresentation.material = c.material;
      c.convexPolyhedronRepresentation.collisionResponse = c.collisionResponse;
      this.planeConvex(b, c.convexPolyhedronRepresentation, e, g, f, k, h, q);
    };
    var Ia = new c, za = new c, Ka = new c, ja = new c;
    b.prototype[f.types.PLANE | f.types.CONVEXPOLYHEDRON] = b.prototype.planeConvex = function(b, c, e, g, f, k, h, q) {
      za.set(0, 0, 1);
      f.vmult(za, za);
      for (var p = f = 0;p !== c.vertices.length;p++) {
        if (Ia.copy(c.vertices[p]), k.vmult(Ia, Ia), g.vadd(Ia, Ia), Ia.vsub(e, Ka), 0 >= za.dot(Ka)) {
          var l = this.createContactEquation(h, q, b, c), n = ja;
          za.mult(za.dot(Ka), n);
          Ia.vsub(n, n);
          n.vsub(e, l.ri);
          l.ni.copy(za);
          Ia.vsub(g, l.rj);
          l.ri.vadd(e, l.ri);
          l.ri.vsub(h.position, l.ri);
          l.rj.vadd(g, l.rj);
          l.rj.vsub(q.position, l.rj);
          this.result.push(l);
          f++;
          this.enableFrictionReduction || this.createFrictionEquationsFromContact(l, this.frictionResult);
        }
      }
      this.enableFrictionReduction && f && this.createFrictionFromAverage(f);
    };
    var tb = new c, lb = new c;
    b.prototype[f.types.CONVEXPOLYHEDRON] = b.prototype.convexConvex = function(b, c, e, g, f, k, h, q, p, l, n, u) {
      if (!(e.distanceTo(g) > b.boundingSphereRadius + c.boundingSphereRadius) && b.findSeparatingAxis(c, e, f, g, k, tb, n, u)) {
        n = [];
        b.clipAgainstHull(e, f, c, g, k, tb, -100, 100, n);
        for (k = f = 0;k !== n.length;k++) {
          u = this.createContactEquation(h, q, b, c, p, l);
          var r = u.ri, w = u.rj;
          tb.negate(u.ni);
          n[k].normal.negate(lb);
          lb.mult(n[k].depth, lb);
          n[k].point.vadd(lb, r);
          w.copy(n[k].point);
          r.vsub(e, r);
          w.vsub(g, w);
          r.vadd(e, r);
          r.vsub(h.position, r);
          w.vadd(g, w);
          w.vsub(q.position, w);
          this.result.push(u);
          f++;
          this.enableFrictionReduction || this.createFrictionEquationsFromContact(u, this.frictionResult);
        }
        this.enableFrictionReduction && f && this.createFrictionFromAverage(f);
      }
    };
    var La = new c, Bb = new c, $a = new c;
    b.prototype[f.types.PLANE | f.types.PARTICLE] = b.prototype.planeParticle = function(b, c, e, g, f, k, h, q) {
      La.set(0, 0, 1);
      h.quaternion.vmult(La, La);
      g.vsub(h.position, Bb);
      0 >= La.dot(Bb) && (b = this.createContactEquation(q, h, c, b), b.ni.copy(La), b.ni.negate(b.ni), b.ri.set(0, 0, 0), La.mult(La.dot(g), $a), g.vsub($a, $a), b.rj.copy($a), this.result.push(b), this.createFrictionEquationsFromContact(b, this.frictionResult));
    };
    var ab = new c;
    b.prototype[f.types.PARTICLE | f.types.SPHERE] = b.prototype.sphereParticle = function(b, c, e, g, f, k, h, q) {
      ab.set(0, 0, 1);
      g.vsub(e, ab);
      ab.norm2() <= b.radius * b.radius && (c = this.createContactEquation(q, h, c, b), ab.normalize(), c.rj.copy(ab), c.rj.mult(b.radius, c.rj), c.ni.copy(ab), c.ni.negate(c.ni), c.ri.set(0, 0, 0), this.result.push(c), this.createFrictionEquationsFromContact(c, this.frictionResult));
    };
    var mb = new e, Y = new c, ub = (new c, new c), Lc = new c, nb = new c;
    b.prototype[f.types.PARTICLE | f.types.CONVEXPOLYHEDRON] = b.prototype.convexParticle = function(b, c, e, g, f, k, h, q) {
      var p = -1;
      k = null;
      var l = 0;
      if (Y.copy(g), Y.vsub(e, Y), f.conjugate(mb), mb.vmult(Y, Y), b.pointIsInside(Y)) {
        b.worldVerticesNeedsUpdate && b.computeWorldVertices(e, f);
        b.worldFaceNormalsNeedsUpdate && b.computeWorldFaceNormals(f);
        f = 0;
        for (var n = b.faces.length;f !== n;f++) {
          var u = b.worldFaceNormals[f];
          g.vsub(b.worldVertices[b.faces[f][0]], Lc);
          var r = -u.dot(Lc);
          (null === k || Math.abs(r) < Math.abs(k)) && (k = r, p = f, ub.copy(u), l++);
        }
        -1 !== p ? (b = this.createContactEquation(q, h, c, b), ub.mult(k, nb), nb.vadd(g, nb), nb.vsub(e, nb), b.rj.copy(nb), ub.negate(b.ni), b.ri.set(0, 0, 0), c = b.ri, k = b.rj, c.vadd(g, c), c.vsub(q.position, c), k.vadd(e, k), k.vsub(h.position, k), this.result.push(b), this.createFrictionEquationsFromContact(b, this.frictionResult)) : console.warn("Point found inside convex, but did not find penetrating face!");
      }
    };
    b.prototype[f.types.BOX | f.types.HEIGHTFIELD] = b.prototype.boxHeightfield = function(b, c, e, g, f, k, h, q) {
      b.convexPolyhedronRepresentation.material = b.material;
      b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
      this.convexHeightfield(b.convexPolyhedronRepresentation, c, e, g, f, k, h, q);
    };
    var ca = new c, da = new c, Ga = [0];
    b.prototype[f.types.CONVEXPOLYHEDRON | f.types.HEIGHTFIELD] = b.prototype.convexHeightfield = function(b, c, e, f, k, h, q, p) {
      var l = c.data, n = c.elementSize, u = b.boundingSphereRadius;
      g.pointToLocalFrame(f, h, e, ca);
      var r = Math.floor((ca.x - u) / n) - 1, w = Math.ceil((ca.x + u) / n) + 1, B = Math.floor((ca.y - u) / n) - 1, n = Math.ceil((ca.y + u) / n) + 1;
      if (!(0 > w || 0 > n || r > l.length || B > l[0].length)) {
        0 > r && (r = 0);
        0 > w && (w = 0);
        0 > B && (B = 0);
        0 > n && (n = 0);
        r >= l.length && (r = l.length - 1);
        w >= l.length && (w = l.length - 1);
        n >= l[0].length && (n = l[0].length - 1);
        B >= l[0].length && (B = l[0].length - 1);
        l = [];
        c.getRectMinMax(r, B, w, n, l);
        var t = l[0];
        if (!(ca.z - u > l[1] || ca.z + u < t)) {
          for (u = r;w > u;u++) {
            for (r = B;n > r;r++) {
              c.getConvexTrianglePillar(u, r, !1), g.pointToWorldFrame(f, h, c.pillarOffset, da), e.distanceTo(da) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.convexConvex(b, c.pillarConvex, e, da, k, h, q, p, null, null, Ga, null), c.getConvexTrianglePillar(u, r, !0), g.pointToWorldFrame(f, h, c.pillarOffset, da), e.distanceTo(da) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.convexConvex(b, c.pillarConvex, e, da, k, h, q, p, null, null, Ga, null);
            }
          }
        }
      }
    };
    var Na = new c, Va = new c;
    b.prototype[f.types.SPHERE | f.types.HEIGHTFIELD] = b.prototype.sphereHeightfield = function(b, c, e, f, k, h, q, p) {
      var l = c.data, n = b.radius, u = c.elementSize;
      g.pointToLocalFrame(f, h, e, Na);
      var r = Math.floor((Na.x - n) / u) - 1, w = Math.ceil((Na.x + n) / u) + 1, B = Math.floor((Na.y - n) / u) - 1, u = Math.ceil((Na.y + n) / u) + 1;
      if (!(0 > w || 0 > u || r > l.length || u > l[0].length)) {
        0 > r && (r = 0);
        0 > w && (w = 0);
        0 > B && (B = 0);
        0 > u && (u = 0);
        r >= l.length && (r = l.length - 1);
        w >= l.length && (w = l.length - 1);
        u >= l[0].length && (u = l[0].length - 1);
        B >= l[0].length && (B = l[0].length - 1);
        l = [];
        c.getRectMinMax(r, B, w, u, l);
        var t = l[0];
        if (!(Na.z - n > l[1] || Na.z + n < t)) {
          for (n = this.result;w > r;r++) {
            for (l = B;u > l;l++) {
              if (t = n.length, c.getConvexTrianglePillar(r, l, !1), g.pointToWorldFrame(f, h, c.pillarOffset, Va), e.distanceTo(Va) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.sphereConvex(b, c.pillarConvex, e, Va, k, h, q, p), c.getConvexTrianglePillar(r, l, !0), g.pointToWorldFrame(f, h, c.pillarOffset, Va), e.distanceTo(Va) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.sphereConvex(b, c.pillarConvex, e, Va, k, h, q, p), 2 < n.length - t) {
                return;
              }
            }
          }
        }
      }
    };
  }, {"../collision/AABB":3, "../collision/Ray":9, "../equations/ContactEquation":19, "../equations/FrictionEquation":21, "../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "../shapes/ConvexPolyhedron":38, "../shapes/Shape":43, "../solver/Solver":47, "../utils/Vec3Pool":54}], 56:[function(h, l) {
    function b() {
      e.apply(this);
      this.dt = -1;
      this.allowSleep = !1;
      this.contacts = [];
      this.frictionEquations = [];
      this.quatNormalizeSkip = 0;
      this.quatNormalizeFast = !1;
      this.stepnumber = this.time = 0;
      this.default_dt = 1 / 60;
      this.nextId = 0;
      this.gravity = new k;
      this.broadphase = new q;
      this.bodies = [];
      this.solver = new c;
      this.constraints = [];
      this.narrowphase = new g(this);
      this.collisionMatrix = new p;
      this.collisionMatrixPrevious = new p;
      this.materials = [];
      this.contactmaterials = [];
      this.contactMaterialTable = new t;
      this.defaultMaterial = new r("default");
      this.defaultContactMaterial = new w(this.defaultMaterial, this.defaultMaterial, {friction:.3, restitution:0});
      this.doProfiling = !1;
      this.profile = {solve:0, makeContactConstraints:0, broadphase:0, integrate:0, narrowphase:0};
      this.subsystems = [];
      this.addBodyEvent = {type:"addBody", body:null};
      this.removeBodyEvent = {type:"removeBody", body:null};
    }
    l.exports = b;
    var f = h("../shapes/Shape"), k = h("../math/Vec3");
    l = h("../math/Quaternion");
    var c = h("../solver/GSSolver"), g = (h("../utils/Vec3Pool"), h("../equations/ContactEquation"), h("../equations/FrictionEquation"), h("./Narrowphase")), e = h("../utils/EventTarget"), p = h("../collision/ArrayCollisionMatrix"), r = h("../material/Material"), w = h("../material/ContactMaterial"), n = h("../objects/Body"), t = h("../utils/TupleDictionary"), v = h("../collision/RaycastResult"), y = h("../collision/AABB"), x = h("../collision/Ray"), q = h("../collision/NaiveBroadphase");
    b.prototype = new e;
    var u = (new y, new x);
    if (b.prototype.getContactMaterial = function(b, c) {
      return this.contactMaterialTable.get(b.id, c.id);
    }, b.prototype.numObjects = function() {
      return this.bodies.length;
    }, b.prototype.collisionMatrixTick = function() {
      var b = this.collisionMatrixPrevious;
      this.collisionMatrixPrevious = this.collisionMatrix;
      this.collisionMatrix = b;
      this.collisionMatrix.reset();
    }, b.prototype.add = b.prototype.addBody = function(b) {
      -1 === this.bodies.indexOf(b) && (b.index = this.bodies.length, this.bodies.push(b), b.world = this, b.initPosition.copy(b.position), b.initVelocity.copy(b.velocity), b.timeLastSleepy = this.time, b instanceof n && (b.initAngularVelocity.copy(b.angularVelocity), b.initQuaternion.copy(b.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), this.addBodyEvent.body = b, this.dispatchEvent(this.addBodyEvent));
    }, b.prototype.addConstraint = function(b) {
      this.constraints.push(b);
    }, b.prototype.removeConstraint = function(b) {
      b = this.constraints.indexOf(b);
      -1 !== b && this.constraints.splice(b, 1);
    }, b.prototype.rayTest = function(b, c, e) {
      e instanceof v ? this.raycastClosest(b, c, {skipBackfaces:!0}, e) : this.raycastAll(b, c, {skipBackfaces:!0}, e);
    }, b.prototype.raycastAll = function(b, c, e, g) {
      return e.mode = x.ALL, e.from = b, e.to = c, e.callback = g, u.intersectWorld(this, e);
    }, b.prototype.raycastAny = function(b, c, e, g) {
      return e.mode = x.ANY, e.from = b, e.to = c, e.result = g, u.intersectWorld(this, e);
    }, b.prototype.raycastClosest = function(b, c, e, g) {
      return e.mode = x.CLOSEST, e.from = b, e.to = c, e.result = g, u.intersectWorld(this, e);
    }, b.prototype.remove = function(b) {
      b.world = null;
      var c = this.bodies.length - 1, e = this.bodies, g = e.indexOf(b);
      if (-1 !== g) {
        e.splice(g, 1);
        for (g = 0;g !== e.length;g++) {
          e[g].index = g;
        }
        this.collisionMatrix.setNumObjects(c);
        this.removeBodyEvent.body = b;
        this.dispatchEvent(this.removeBodyEvent);
      }
    }, b.prototype.removeBody = b.prototype.remove, b.prototype.addMaterial = function(b) {
      this.materials.push(b);
    }, b.prototype.addContactMaterial = function(b) {
      this.contactmaterials.push(b);
      this.contactMaterialTable.set(b.materials[0].id, b.materials[1].id, b);
    }, "undefined" == typeof performance && (performance = {}), !performance.now) {
      var B = Date.now();
      performance.timing && performance.timing.navigationStart && (B = performance.timing.navigationStart);
      performance.now = function() {
        return Date.now() - B;
      };
    }
    var C = new k;
    b.prototype.step = function(b, c, e) {
      if (e = e || 10, c = c || 0, 0 === c) {
        this.internalStep(b), this.time += b;
      } else {
        var g = Math.floor((this.time + c) / b) - Math.floor(this.time / b), g = Math.min(g, e);
        e = performance.now();
        for (var f = 0;f !== g && (this.internalStep(b), !(performance.now() - e > 1E3 * b));f++) {
        }
        this.time += c;
        b = this.time % b / b;
        c = this.bodies;
        for (g = 0;g !== c.length;g++) {
          e = c[g], e.type !== n.STATIC && e.sleepState !== n.SLEEPING ? (e.position.vsub(e.previousPosition, C), C.scale(b, C), e.position.vadd(C, e.interpolatedPosition)) : (e.interpolatedPosition.copy(e.position), e.interpolatedQuaternion.copy(e.quaternion));
        }
      }
    };
    var D = {type:"postStep"}, F = {type:"preStep"}, E = {type:"collide", body:null, contact:null}, z = [], I = [], J = [], R = [], L = (new k, new k, new k, new k, new k, new k, new k, new k, new k, new l, new l), M = new l, P = new k;
    b.prototype.internalStep = function(b) {
      this.dt = b;
      var c, e = this.contacts, g = this.numObjects(), k = this.bodies, h = this.solver, q = this.gravity, p = this.doProfiling, l = this.profile, u = n.DYNAMIC, r = this.constraints, w = (q.norm(), q.x), B = q.y, t = q.z;
      p && (c = performance.now());
      for (q = 0;q !== g;q++) {
        var v = k[q];
        if (v.type & u) {
          var y = v.force, v = v.mass;
          y.x += v * w;
          y.y += v * B;
          y.z += v * t;
        }
      }
      q = 0;
      for (v = this.subsystems.length;q !== v;q++) {
        this.subsystems[q].update();
      }
      p && (c = performance.now());
      J.length = 0;
      R.length = 0;
      this.broadphase.collisionPairs(this, J, R);
      p && (l.broadphase = performance.now() - c);
      v = r.length;
      for (q = 0;q !== v;q++) {
        if (w = r[q], !w.collideConnected) {
          for (B = J.length - 1;0 <= B;--B) {
            (w.bodyA === J[B] && w.bodyB === R[B] || w.bodyB === J[B] && w.bodyA === R[B]) && (J.splice(B, 1), R.splice(B, 1));
          }
        }
      }
      this.collisionMatrixTick();
      p && (c = performance.now());
      v = e.length;
      for (q = 0;q !== v;q++) {
        z.push(e[q]);
      }
      e.length = 0;
      v = this.frictionEquations.length;
      for (q = 0;q !== v;q++) {
        I.push(this.frictionEquations[q]);
      }
      this.frictionEquations.length = 0;
      this.narrowphase.getContacts(J, R, this, e, z, this.frictionEquations, I);
      p && (l.narrowphase = performance.now() - c);
      p && (c = performance.now());
      for (q = 0;q < this.frictionEquations.length;q++) {
        h.addEquation(this.frictionEquations[q]);
      }
      q = e.length;
      for (B = 0;B !== q;B++) {
        w = e[B], v = w.bi, t = w.bj, w.si, w.sj, v.material && t.material && this.getContactMaterial(v.material, t.material), (v.material && t.material && 0 <= v.material.restitution && 0 <= t.material.restitution && (w.restitution = v.material.restitution * t.material.restitution), h.addEquation(w), v.allowSleep && v.type === n.DYNAMIC && v.sleepState === n.SLEEPING && t.sleepState === n.AWAKE && t.type !== n.STATIC) && t.velocity.norm2() + t.angularVelocity.norm2() >= 2 * Math.pow(t.sleepSpeedLimit, 
        2) && (v._wakeUpAfterNarrowphase = !0), t.allowSleep && t.type === n.DYNAMIC && t.sleepState === n.SLEEPING && v.sleepState === n.AWAKE && v.type !== n.STATIC && v.velocity.norm2() + v.angularVelocity.norm2() >= 2 * Math.pow(v.sleepSpeedLimit, 2) && (t._wakeUpAfterNarrowphase = !0), this.collisionMatrix.set(v, t, !0), this.collisionMatrixPrevious.get(v, t) || (E.body = t, E.contact = w, v.dispatchEvent(E), E.body = v, t.dispatchEvent(E));
      }
      p && (l.makeContactConstraints = performance.now() - c, c = performance.now());
      for (q = 0;q !== g;q++) {
        v = k[q], v._wakeUpAfterNarrowphase && (v.wakeUp(), v._wakeUpAfterNarrowphase = !1);
      }
      v = r.length;
      for (q = 0;q !== v;q++) {
        for (w = r[q], w.update(), B = 0, e = w.equations.length;B !== e;B++) {
          h.addEquation(w.equations[B]);
        }
      }
      h.solve(b, this);
      p && (l.solve = performance.now() - c);
      h.removeAllEquations();
      h = Math.pow;
      for (q = 0;q !== g;q++) {
        if (v = k[q], v.type & u && (r = h(1 - v.linearDamping, b), e = v.velocity, e.mult(r, e), r = v.angularVelocity)) {
          e = h(1 - v.angularDamping, b), r.mult(e, r);
        }
      }
      this.dispatchEvent(F);
      for (q = 0;q !== g;q++) {
        v = k[q], v.preStep && v.preStep.call(v);
      }
      p && (c = performance.now());
      u = n.DYNAMIC | n.KINEMATIC;
      h = 0 === this.stepnumber % (this.quatNormalizeSkip + 1);
      r = this.quatNormalizeFast;
      e = .5 * b;
      f.types.PLANE;
      f.types.CONVEXPOLYHEDRON;
      for (q = 0;q !== g;q++) {
        if (v = k[q], w = v.force, B = v.torque, v.type & u && v.sleepState !== n.SLEEPING) {
          var t = v.velocity, y = v.angularVelocity, C = v.position, x = v.quaternion, H = v.invMass, Aa = v.invInertiaWorld;
          t.x += w.x * H * b;
          t.y += w.y * H * b;
          t.z += w.z * H * b;
          v.angularVelocity && (Aa.vmult(B, P), P.mult(b, P), P.vadd(y, y));
          C.x += t.x * b;
          C.y += t.y * b;
          C.z += t.z * b;
          v.angularVelocity && (L.set(y.x, y.y, y.z, 0), L.mult(x, M), x.x += e * M.x, x.y += e * M.y, x.z += e * M.z, x.w += e * M.w, h && (r ? x.normalizeFast() : x.normalize()));
          v.aabb && (v.aabbNeedsUpdate = !0);
          v.updateInertiaWorld && v.updateInertiaWorld();
        }
      }
      this.clearForces();
      this.broadphase.dirty = !0;
      p && (l.integrate = performance.now() - c);
      this.time += b;
      this.stepnumber += 1;
      this.dispatchEvent(D);
      for (q = 0;q !== g;q++) {
        v = k[q], (b = v.postStep) && b.call(v);
      }
      if (this.allowSleep) {
        for (q = 0;q !== g;q++) {
          k[q].sleepTick(this.time);
        }
      }
    };
    b.prototype.clearForces = function() {
      for (var b = this.bodies, c = b.length, e = 0;e !== c;e++) {
        var g = b[e];
        g.force;
        g.torque;
        g.force.set(0, 0, 0);
        g.torque.set(0, 0, 0);
      }
    };
  }, {"../collision/AABB":3, "../collision/ArrayCollisionMatrix":4, "../collision/NaiveBroadphase":7, "../collision/Ray":9, "../collision/RaycastResult":10, "../equations/ContactEquation":19, "../equations/FrictionEquation":21, "../material/ContactMaterial":24, "../material/Material":25, "../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "../shapes/Shape":43, "../solver/GSSolver":46, "../utils/EventTarget":49, "../utils/TupleDictionary":52, "../utils/Vec3Pool":54, "./Narrowphase":55}]}, 
  {}, [2])(2);
});
!function(a, h, l) {
  function b(c, g) {
    if (!h[c]) {
      if (!a[c]) {
        var e = "function" == typeof require && require;
        if (!g && e) {
          return e(c, !0);
        }
        if (f) {
          return f(c, !0);
        }
        throw Error("Cannot find module '" + c + "'");
      }
      g = h[c] = {exports:{}};
      a[c][0].call(g.exports, function(e) {
        var g = a[c][1][e];
        return b(g ? g : e);
      }, g, g.exports);
    }
    return h[c].exports;
  }
  for (var f = "function" == typeof require && require, k = 0;k < l.length;k++) {
    b(l[k]);
  }
  return b;
}({1:[function(a, h) {
  var l = (a("./pointable"), a("gl-matrix")), b = l.vec3, f = l.mat3, k = l.mat4;
  a = (a("underscore"), h.exports = function(a, g) {
    this.finger = a;
    this._matrix = this._center = null;
    this.type = g.type;
    this.prevJoint = g.prevJoint;
    this.nextJoint = g.nextJoint;
    this.width = g.width;
    a = Array(3);
    b.sub(a, g.nextJoint, g.prevJoint);
    this.length = b.length(a);
    this.basis = g.basis;
  });
  a.prototype.left = function() {
    return this._left ? this._left : (this._left = 0 > f.determinant(this.basis[0].concat(this.basis[1]).concat(this.basis[2])), this._left);
  };
  a.prototype.matrix = function() {
    if (this._matrix) {
      return this._matrix;
    }
    var a = this.basis, b = this._matrix = k.create();
    return b[0] = a[0][0], b[1] = a[0][1], b[2] = a[0][2], b[4] = a[1][0], b[5] = a[1][1], b[6] = a[1][2], b[8] = a[2][0], b[9] = a[2][1], b[10] = a[2][2], b[3] = this.center()[0], b[7] = this.center()[1], b[11] = this.center()[2], this.left() && (b[0] *= -1, b[1] *= -1, b[2] *= -1), this._matrix;
  };
  a.prototype.lerp = function(a, g) {
    b.lerp(a, this.prevJoint, this.nextJoint, g);
  };
  a.prototype.center = function() {
    if (this._center) {
      return this._center;
    }
    var a = b.create();
    return this.lerp(a, .5), this._center = a, a;
  };
  a.prototype.direction = function() {
    return [-1 * this.basis[2][0], -1 * this.basis[2][1], -1 * this.basis[2][2]];
  };
}, {"./pointable":14, "gl-matrix":23, underscore:24}], 2:[function(a, h) {
  a = h.exports = function(a) {
    this.pos = 0;
    this._buf = [];
    this.size = a;
  };
  a.prototype.get = function(a) {
    return void 0 == a && (a = 0), a >= this.size ? void 0 : a >= this._buf.length ? void 0 : this._buf[(this.pos - a - 1) % this.size];
  };
  a.prototype.push = function(a) {
    return this._buf[this.pos % this.size] = a, this.pos++;
  };
}, {}], 3:[function(a, h) {
  var l = a("../protocol").chooseProtocol, b = a("events").EventEmitter, f = a("underscore"), k = h.exports = function(a) {
    this.opts = f.defaults(a || {}, {host:"127.0.0.1", enableGestures:!1, scheme:this.getScheme(), port:this.getPort(), background:!1, optimizeHMD:!1, requestProtocolVersion:k.defaultProtocolVersion});
    this.host = this.opts.host;
    this.port = this.opts.port;
    this.scheme = this.opts.scheme;
    this.protocolVersionVerified = !1;
    this.optimizeHMD = this.background = null;
    this.on("ready", function() {
      this.enableGestures(this.opts.enableGestures);
      this.setBackground(this.opts.background);
      this.setOptimizeHMD(this.opts.optimizeHMD);
      console.log(this.opts.optimizeHMD ? "Optimized for head mounted display usage." : "Optimized for desktop usage.");
    });
  };
  k.defaultProtocolVersion = 6;
  k.prototype.getUrl = function() {
    return this.scheme + "//" + this.host + ":" + this.port + "/v" + this.opts.requestProtocolVersion + ".json";
  };
  k.prototype.getScheme = function() {
    return "ws:";
  };
  k.prototype.getPort = function() {
    return 6437;
  };
  k.prototype.setBackground = function(a) {
    this.opts.background = a;
    this.protocol && this.protocol.sendBackground && this.background !== this.opts.background && (this.background = this.opts.background, this.protocol.sendBackground(this, this.opts.background));
  };
  k.prototype.setOptimizeHMD = function(a) {
    this.opts.optimizeHMD = a;
    this.protocol && this.protocol.sendOptimizeHMD && this.optimizeHMD !== this.opts.optimizeHMD && (this.optimizeHMD = this.opts.optimizeHMD, this.protocol.sendOptimizeHMD(this, this.opts.optimizeHMD));
  };
  k.prototype.handleOpen = function() {
    this.connected || (this.connected = !0, this.emit("connect"));
  };
  k.prototype.enableGestures = function(a) {
    this.gesturesEnabled = a ? !0 : !1;
    this.send(this.protocol.encode({enableGestures:this.gesturesEnabled}));
  };
  k.prototype.handleClose = function(a) {
    this.connected && (this.disconnect(), 1001 === a && 1 < this.opts.requestProtocolVersion && (this.protocolVersionVerified ? this.protocolVersionVerified = !1 : this.opts.requestProtocolVersion--), this.startReconnection());
  };
  k.prototype.startReconnection = function() {
    var a = this;
    this.reconnectionTimer || (this.reconnectionTimer = setInterval(function() {
      a.reconnect();
    }, 500));
  };
  k.prototype.stopReconnection = function() {
    this.reconnectionTimer = clearInterval(this.reconnectionTimer);
  };
  k.prototype.disconnect = function(a) {
    return a || this.stopReconnection(), this.socket ? (this.socket.close(), delete this.socket, delete this.protocol, delete this.background, delete this.optimizeHMD, delete this.focusedState, this.connected && (this.connected = !1, this.emit("disconnect")), !0) : void 0;
  };
  k.prototype.reconnect = function() {
    this.connected ? this.stopReconnection() : (this.disconnect(!0), this.connect());
  };
  k.prototype.handleData = function(a) {
    var b;
    a = JSON.parse(a);
    void 0 === this.protocol ? (b = this.protocol = l(a), this.protocolVersionVerified = !0, this.emit("ready")) : b = this.protocol(a);
    this.emit(b.type, b);
  };
  k.prototype.connect = function() {
    return this.socket ? void 0 : (this.socket = this.setupSocket(), !0);
  };
  k.prototype.send = function(a) {
    this.socket.send(a);
  };
  k.prototype.reportFocus = function(a) {
    this.connected && this.focusedState !== a && (this.focusedState = a, this.emit(this.focusedState ? "focus" : "blur"), this.protocol && this.protocol.sendFocused && this.protocol.sendFocused(this, this.focusedState));
  };
  f.extend(k.prototype, b.prototype);
}, {"../protocol":15, events:21, underscore:24}], 4:[function(a, h) {
  var l = h.exports = a("./base");
  a = a("underscore");
  h = h.exports = function(a) {
    l.call(this, a);
    var b = this;
    this.on("ready", function() {
      b.startFocusLoop();
    });
    this.on("disconnect", function() {
      b.stopFocusLoop();
    });
  };
  a.extend(h.prototype, l.prototype);
  h.__proto__ = l;
  h.prototype.useSecure = function() {
    return "https:" === location.protocol;
  };
  h.prototype.getScheme = function() {
    return this.useSecure() ? "wss:" : "ws:";
  };
  h.prototype.getPort = function() {
    return this.useSecure() ? 6436 : 6437;
  };
  h.prototype.setupSocket = function() {
    var a = this, f = new WebSocket(this.getUrl());
    return f.onopen = function() {
      a.handleOpen();
    }, f.onclose = function(b) {
      a.handleClose(b.code, b.reason);
    }, f.onmessage = function(b) {
      a.handleData(b.data);
    }, f.onerror = function() {
      a.useSecure() && "wss:" === a.scheme && (a.scheme = "ws:", a.port = 6437, a.disconnect(), a.connect());
    }, f;
  };
  h.prototype.startFocusLoop = function() {
    if (!this.focusDetectorTimer) {
      var a = this, f = null, f = "undefined" != typeof document.hidden ? "hidden" : "undefined" != typeof document.mozHidden ? "mozHidden" : "undefined" != typeof document.msHidden ? "msHidden" : "undefined" != typeof document.webkitHidden ? "webkitHidden" : void 0;
      void 0 === a.windowVisible && (a.windowVisible = void 0 === f ? !0 : !1 === document[f]);
      var k = window.addEventListener("focus", function() {
        a.windowVisible = !0;
        g();
      }), c = window.addEventListener("blur", function() {
        a.windowVisible = !1;
        g();
      });
      this.on("disconnect", function() {
        window.removeEventListener("focus", k);
        window.removeEventListener("blur", c);
      });
      var g = function() {
        a.reportFocus((void 0 === f ? !0 : !1 === document[f]) && a.windowVisible);
      };
      g();
      this.focusDetectorTimer = setInterval(g, 100);
    }
  };
  h.prototype.stopFocusLoop = function() {
    this.focusDetectorTimer && (clearTimeout(this.focusDetectorTimer), delete this.focusDetectorTimer);
  };
}, {"./base":3, underscore:24}], 5:[function(a, h) {
  var l = a("__browserify_process"), b = a("./frame"), f = a("./hand"), k = a("./pointable"), c = a("./finger"), g = a("./circular_buffer"), e = a("./pipeline"), p = a("events").EventEmitter, r = a("./gesture").gestureListener, w = a("./dialog"), n = a("underscore"), t = h.exports = function(c) {
    var e = this;
    c = n.defaults(c || {}, {inNode:"undefined" != typeof l && l.versions && l.versions.node});
    this.inNode = c.inNode;
    c = n.defaults(c || {}, {frameEventName:this.useAnimationLoop() ? "animationFrame" : "deviceFrame", suppressAnimationLoop:!this.useAnimationLoop(), loopWhileDisconnected:!0, useAllPlugins:!1, checkVersion:!0});
    this.animationFrameRequested = !1;
    this.onAnimationFrame = function(a) {
      e.lastConnectionFrame.valid && e.emit("animationFrame", e.lastConnectionFrame);
      e.emit("frameEnd", a);
      e.loopWhileDisconnected && (!1 !== e.connection.focusedState || e.connection.opts.background) ? window.requestAnimationFrame(e.onAnimationFrame) : e.animationFrameRequested = !1;
    };
    this.suppressAnimationLoop = c.suppressAnimationLoop;
    this.loopWhileDisconnected = c.loopWhileDisconnected;
    this.frameEventName = c.frameEventName;
    this.useAllPlugins = c.useAllPlugins;
    this.history = new g(200);
    this.lastConnectionFrame = this.lastValidFrame = this.lastFrame = b.Invalid;
    this.accumulatedGestures = [];
    this.checkVersion = c.checkVersion;
    this.connectionType = void 0 === c.connectionType ? a(this.inBrowser() ? "./connection/browser" : "./connection/node") : c.connectionType;
    this.connection = new this.connectionType(c);
    this.streamingCount = 0;
    this.devices = {};
    this.plugins = {};
    this._pluginPipelineSteps = {};
    this._pluginExtendedMethods = {};
    c.useAllPlugins && this.useRegisteredPlugins();
    this.setupFrameEvents(c);
    this.setupConnectionEvents();
    this.startAnimationLoop();
  };
  t.prototype.gesture = function(a, b) {
    a = r(this, a);
    return void 0 !== b && a.stop(b), a;
  };
  t.prototype.setBackground = function(a) {
    return this.connection.setBackground(a), this;
  };
  t.prototype.setOptimizeHMD = function(a) {
    return this.connection.setOptimizeHMD(a), this;
  };
  t.prototype.inBrowser = function() {
    return !this.inNode;
  };
  t.prototype.useAnimationLoop = function() {
    return this.inBrowser() && !this.inBackgroundPage();
  };
  t.prototype.inBackgroundPage = function() {
    return "undefined" != typeof chrome && chrome.extension && chrome.extension.getBackgroundPage && chrome.extension.getBackgroundPage() === window;
  };
  t.prototype.connect = function() {
    return this.connection.connect(), this;
  };
  t.prototype.streaming = function() {
    return 0 < this.streamingCount;
  };
  t.prototype.connected = function() {
    return !!this.connection.connected;
  };
  t.prototype.startAnimationLoop = function() {
    this.suppressAnimationLoop || this.animationFrameRequested || (this.animationFrameRequested = !0, window.requestAnimationFrame(this.onAnimationFrame));
  };
  t.prototype.disconnect = function() {
    return this.connection.disconnect(), this;
  };
  t.prototype.frame = function(a) {
    return this.history.get(a) || b.Invalid;
  };
  t.prototype.loop = function(a) {
    return a && ("function" == typeof a ? this.on(this.frameEventName, a) : this.setupFrameEvents(a)), this.connect();
  };
  t.prototype.addStep = function(a) {
    this.pipeline || (this.pipeline = new e(this));
    this.pipeline.addStep(a);
  };
  t.prototype.processFrame = function(a) {
    a.gestures && (this.accumulatedGestures = this.accumulatedGestures.concat(a.gestures));
    this.lastConnectionFrame = a;
    this.startAnimationLoop();
    this.emit("deviceFrame", a);
  };
  t.prototype.processFinishedFrame = function(a) {
    if (this.lastFrame = a, a.valid && (this.lastValidFrame = a), a.controller = this, a.historyIdx = this.history.push(a), a.gestures) {
      a.gestures = this.accumulatedGestures;
      this.accumulatedGestures = [];
      for (var c = 0;c != a.gestures.length;c++) {
        this.emit("gesture", a.gestures[c], a);
      }
    }
    this.pipeline && (a = this.pipeline.run(a), a || (a = b.Invalid));
    this.emit("frame", a);
    this.emitHandEvents(a);
  };
  t.prototype.emitHandEvents = function(a) {
    for (var b = 0;b < a.hands.length;b++) {
      this.emit("hand", a.hands[b]);
    }
  };
  t.prototype.setupFrameEvents = function(a) {
    a.frame && this.on("frame", a.frame);
    a.hand && this.on("hand", a.hand);
  };
  t.prototype.setupConnectionEvents = function() {
    var a = this;
    this.connection.on("frame", function(b) {
      a.processFrame(b);
    });
    this.on(this.frameEventName, function(b) {
      a.processFinishedFrame(b);
    });
    var b = function() {
      if (5 > a.connection.opts.requestProtocolVersion && 0 == a.streamingCount) {
        a.streamingCount = 1;
        var c = {attached:!0, streaming:!0, type:"unknown", id:"Lx00000000000"};
        a.devices[c.id] = c;
        a.emit("deviceAttached", c);
        a.emit("deviceStreaming", c);
        a.emit("streamingStarted", c);
        a.connection.removeListener("frame", b);
      }
    }, c = function() {
      if (0 < a.streamingCount) {
        for (var b in a.devices) {
          a.emit("deviceStopped", a.devices[b]), a.emit("deviceRemoved", a.devices[b]);
        }
        a.emit("streamingStopped", a.devices[b]);
        a.streamingCount = 0;
        for (b in a.devices) {
          delete a.devices[b];
        }
      }
    };
    this.connection.on("focus", function() {
      a.loopWhileDisconnected && a.startAnimationLoop();
      a.emit("focus");
    });
    this.connection.on("blur", function() {
      a.emit("blur");
    });
    this.connection.on("protocol", function(b) {
      b.on("beforeFrameCreated", function(b) {
        a.emit("beforeFrameCreated", b);
      });
      b.on("afterFrameCreated", function(b, c) {
        a.emit("afterFrameCreated", b, c);
      });
      a.emit("protocol", b);
    });
    this.connection.on("ready", function() {
      a.checkVersion && !a.inNode && a.checkOutOfDate();
      a.emit("ready");
    });
    this.connection.on("connect", function() {
      a.emit("connect");
      a.connection.removeListener("frame", b);
      a.connection.on("frame", b);
    });
    this.connection.on("disconnect", function() {
      a.emit("disconnect");
      c();
    });
    this.connection.on("deviceConnect", function(e) {
      e.state ? (a.emit("deviceConnected"), a.connection.removeListener("frame", b), a.connection.on("frame", b)) : (a.emit("deviceDisconnected"), c());
    });
    this.connection.on("deviceEvent", function(b) {
      b = b.state;
      var c = a.devices[b.id], e = {}, g;
      for (g in b) {
        c && c.hasOwnProperty(g) && c[g] == b[g] || (e[g] = !0);
      }
      a.devices[b.id] = b;
      e.attached && a.emit(b.attached ? "deviceAttached" : "deviceRemoved", b);
      e.streaming && (b.streaming ? (a.streamingCount++, a.emit("deviceStreaming", b), 1 == a.streamingCount && a.emit("streamingStarted", b), e.attached || a.emit("deviceConnected")) : e.attached && b.attached || (a.streamingCount--, a.emit("deviceStopped", b), 0 == a.streamingCount && a.emit("streamingStopped", b), a.emit("deviceDisconnected")));
    });
    this.on("newListener", function(a) {
      "deviceConnected" != a && "deviceDisconnected" != a || console.warn(a + " events are depricated.  Consider using 'streamingStarted/streamingStopped' or 'deviceStreaming/deviceStopped' instead");
    });
  };
  t.prototype.checkOutOfDate = function() {
    console.assert(this.connection && this.connection.protocol);
    var a = this.connection.protocol.serviceVersion, b = this.connection.protocol.version, c = this.connectionType.defaultProtocolVersion;
    return c > b ? (console.warn("Your Protocol Version is v" + b + ", this app was designed for v" + c), w.warnOutOfDate({sV:a, pV:b}), !0) : !1;
  };
  t._pluginFactories = {};
  t.plugin = function(a, b) {
    return this._pluginFactories[a] && console.warn('Plugin "' + a + '" already registered'), this._pluginFactories[a] = b;
  };
  t.plugins = function() {
    return n.keys(this._pluginFactories);
  };
  t.prototype.use = function(a, g) {
    var h, q;
    if (h = "function" == typeof a ? a : t._pluginFactories[a], !h) {
      throw "Leap Plugin " + a + " not found.";
    }
    if (g || (g = {}), this.plugins[a]) {
      return n.extend(this.plugins[a], g), this;
    }
    this.plugins[a] = g;
    g = h.call(this, g);
    for (q in g) {
      if (h = g[q], "function" == typeof h) {
        var p = a, l = q;
        -1 != ["beforeFrameCreated", "afterFrameCreated"].indexOf(l) ? this.on(l, h) : (this.pipeline || (this.pipeline = new e(this)), this._pluginPipelineSteps[p] || (this._pluginPipelineSteps[p] = []), this._pluginPipelineSteps[p].push(this.pipeline.addWrappedStep(l, h)));
      } else {
        p = a;
        l = q;
        switch(this._pluginExtendedMethods[p] || (this._pluginExtendedMethods[p] = []), l) {
          case "frame":
            l = b;
            break;
          case "hand":
            l = f;
            break;
          case "pointable":
            l = k;
            n.extend(c.prototype, h);
            n.extend(c.Invalid, h);
            break;
          case "finger":
            l = c;
            break;
          default:
            throw p + ' specifies invalid object type "' + l + '" for prototypical extension';
        }
        n.extend(l.prototype, h);
        n.extend(l.Invalid, h);
        this._pluginExtendedMethods[p].push([l, h]);
      }
    }
    return this;
  };
  t.prototype.stopUsing = function(a) {
    var b, c;
    b = this._pluginPipelineSteps[a];
    var e = this._pluginExtendedMethods[a], g;
    if (this.plugins[a]) {
      if (b) {
        for (g = 0;g < b.length;g++) {
          this.pipeline.removeStep(b[g]);
        }
      }
      if (e) {
        for (g = 0;g < e.length;g++) {
          b = e[g][0];
          c = e[g][1];
          for (var f in c) {
            delete b.prototype[f], delete b.Invalid[f];
          }
        }
      }
      return delete this.plugins[a], this;
    }
  };
  t.prototype.useRegisteredPlugins = function() {
    for (var a in t._pluginFactories) {
      this.use(a);
    }
  };
  n.extend(t.prototype, p.prototype);
}, {"./circular_buffer":2, "./connection/browser":4, "./connection/node":20, "./dialog":6, "./finger":7, "./frame":8, "./gesture":9, "./hand":10, "./pipeline":13, "./pointable":14, __browserify_process:22, events:21, underscore:24}], 6:[function(a, h) {
  var l = a("__browserify_process"), b = h.exports = function(a, b) {
    this.options = b || {};
    this.message = a;
    this.createElement();
  };
  b.prototype.createElement = function() {
    this.element = document.createElement("div");
    this.element.className = "leapjs-dialog";
    this.element.style.position = "fixed";
    this.element.style.top = "8px";
    this.element.style.left = 0;
    this.element.style.right = 0;
    this.element.style.textAlign = "center";
    this.element.style.zIndex = 1E3;
    var a = document.createElement("div");
    this.element.appendChild(a);
    a.style.className = "leapjs-dialog";
    a.style.display = "inline-block";
    a.style.margin = "auto";
    a.style.padding = "8px";
    a.style.color = "#222";
    a.style.background = "#eee";
    a.style.borderRadius = "4px";
    a.style.border = "1px solid #999";
    a.style.textAlign = "left";
    a.style.cursor = "pointer";
    a.style.whiteSpace = "nowrap";
    a.style.transition = "box-shadow 1s linear";
    a.innerHTML = this.message;
    this.options.onclick && a.addEventListener("click", this.options.onclick);
    this.options.onmouseover && a.addEventListener("mouseover", this.options.onmouseover);
    this.options.onmouseout && a.addEventListener("mouseout", this.options.onmouseout);
    this.options.onmousemove && a.addEventListener("mousemove", this.options.onmousemove);
  };
  b.prototype.show = function() {
    return document.body.appendChild(this.element), this;
  };
  b.prototype.hide = function() {
    return document.body.removeChild(this.element), this;
  };
  b.warnOutOfDate = function(a) {
    a || (a = {});
    var f = "http://developer.leapmotion.com?";
    a.returnTo = window.location.href;
    for (var c in a) {
      f += c + "=" + encodeURIComponent(a[c]) + "&";
    }
    var g;
    return g = new b("This site requires Leap Motion Tracking V2.<button id='leapjs-accept-upgrade'  style='color: #444; transition: box-shadow 100ms linear; cursor: pointer; vertical-align: baseline; margin-left: 16px;'>Upgrade</button><button id='leapjs-decline-upgrade' style='color: #444; transition: box-shadow 100ms linear; cursor: pointer; vertical-align: baseline; margin-left: 8px; '>Not Now</button>", {onclick:function(a) {
      "leapjs-decline-upgrade" != a.target.id && (a = window.open(f, "_blank", "height=800,width=1000,location=1,menubar=1,resizable=1,status=1,toolbar=1,scrollbars=1"), window.focus && a.focus());
      return g.hide(), !0;
    }, onmousemove:function(a) {
      a.target == document.getElementById("leapjs-decline-upgrade") ? (document.getElementById("leapjs-decline-upgrade").style.color = "#000", document.getElementById("leapjs-decline-upgrade").style.boxShadow = "0px 0px 2px #5daa00", document.getElementById("leapjs-accept-upgrade").style.color = "#444", document.getElementById("leapjs-accept-upgrade").style.boxShadow = "none") : (document.getElementById("leapjs-accept-upgrade").style.color = "#000", document.getElementById("leapjs-accept-upgrade").style.boxShadow = 
      "0px 0px 2px #5daa00", document.getElementById("leapjs-decline-upgrade").style.color = "#444", document.getElementById("leapjs-decline-upgrade").style.boxShadow = "none");
    }, onmouseout:function() {
      document.getElementById("leapjs-decline-upgrade").style.color = "#444";
      document.getElementById("leapjs-decline-upgrade").style.boxShadow = "none";
      document.getElementById("leapjs-accept-upgrade").style.color = "#444";
      document.getElementById("leapjs-accept-upgrade").style.boxShadow = "none";
    }}), g.show();
  };
  b.hasWarnedBones = !1;
  b.warnBones = function() {
    this.hasWarnedBones || (this.hasWarnedBones = !0, console.warn("Your Leap Service is out of date"), "undefined" != typeof l && l.versions && l.versions.node || this.warnOutOfDate({reason:"bones"}));
  };
}, {__browserify_process:22}], 7:[function(a, h) {
  var l = a("./pointable"), b = a("./bone"), f = a("./dialog");
  a = a("underscore");
  h = h.exports = function(a) {
    l.call(this, a);
    this.dipPosition = a.dipPosition;
    this.pipPosition = a.pipPosition;
    this.mcpPosition = a.mcpPosition;
    this.carpPosition = a.carpPosition;
    this.extended = a.extended;
    this.type = a.type;
    this.finger = !0;
    this.positions = [this.carpPosition, this.mcpPosition, this.pipPosition, this.dipPosition, this.tipPosition];
    a.bases ? this.addBones(a) : f.warnBones();
  };
  a.extend(h.prototype, l.prototype);
  h.prototype.addBones = function(a) {
    this.metacarpal = new b(this, {type:0, width:this.width, prevJoint:this.carpPosition, nextJoint:this.mcpPosition, basis:a.bases[0]});
    this.proximal = new b(this, {type:1, width:this.width, prevJoint:this.mcpPosition, nextJoint:this.pipPosition, basis:a.bases[1]});
    this.medial = new b(this, {type:2, width:this.width, prevJoint:this.pipPosition, nextJoint:this.dipPosition, basis:a.bases[2]});
    this.distal = new b(this, {type:3, width:this.width, prevJoint:this.dipPosition, nextJoint:a.btipPosition, basis:a.bases[3]});
    this.bones = [this.metacarpal, this.proximal, this.medial, this.distal];
  };
  h.prototype.toString = function() {
    return "Finger [ id:" + this.id + " " + this.length + "mmx | width:" + this.width + "mm | direction:" + this.direction + " ]";
  };
  h.Invalid = {valid:!1};
}, {"./bone":1, "./dialog":6, "./pointable":14, underscore:24}], 8:[function(a, h) {
  var l = a("./hand"), b = a("./pointable"), f = a("./gesture").createGesture, k = a("gl-matrix"), c = k.mat3, g = k.vec3, e = a("./interaction_box"), p = a("./finger"), r = a("underscore");
  a = h.exports = function(a) {
    if (this.valid = !0, this.id = a.id, this.timestamp = a.timestamp, this.hands = [], this.handsMap = {}, this.pointables = [], this.tools = [], this.fingers = [], a.interactionBox && (this.interactionBox = new e(a.interactionBox)), this.gestures = [], this.pointablesMap = {}, this._translation = a.t, this._rotation = r.flatten(a.r), this._scaleFactor = a.s, this.data = a, this.type = "frame", this.currentFrameRate = a.currentFrameRate, a.gestures) {
      for (var b = 0, c = a.gestures.length;b != c;b++) {
        this.gestures.push(f(a.gestures[b]));
      }
    }
    this.postprocessData(a);
  };
  a.prototype.postprocessData = function(a) {
    a || (a = this.data);
    for (var c = 0, e = a.hands.length;c != e;c++) {
      var g = new l(a.hands[c]);
      g.frame = this;
      this.hands.push(g);
      this.handsMap[g.id] = g;
    }
    a.pointables = r.sortBy(a.pointables, function(a) {
      return a.id;
    });
    c = 0;
    for (e = a.pointables.length;c != e;c++) {
      g = a.pointables[c], g = g.dipPosition ? new p(g) : new b(g), g.frame = this, this.addPointable(g);
    }
  };
  a.prototype.addPointable = function(a) {
    if (this.pointables.push(a), this.pointablesMap[a.id] = a, (a.tool ? this.tools : this.fingers).push(a), void 0 !== a.handId && this.handsMap.hasOwnProperty(a.handId)) {
      var b = this.handsMap[a.handId];
      switch(b.pointables.push(a), (a.tool ? b.tools : b.fingers).push(a), a.type) {
        case 0:
          b.thumb = a;
          break;
        case 1:
          b.indexFinger = a;
          break;
        case 2:
          b.middleFinger = a;
          break;
        case 3:
          b.ringFinger = a;
          break;
        case 4:
          b.pinky = a;
      }
    }
  };
  a.prototype.tool = function(a) {
    a = this.pointable(a);
    return a.tool ? a : b.Invalid;
  };
  a.prototype.pointable = function(a) {
    return this.pointablesMap[a] || b.Invalid;
  };
  a.prototype.finger = function(a) {
    a = this.pointable(a);
    return a.tool ? b.Invalid : a;
  };
  a.prototype.hand = function(a) {
    return this.handsMap[a] || l.Invalid;
  };
  a.prototype.rotationAngle = function(a, b) {
    if (!this.valid || !a.valid) {
      return 0;
    }
    var c = this.rotationMatrix(a), c = Math.acos(.5 * (c[0] + c[4] + c[8] - 1));
    if (c = isNaN(c) ? 0 : c, void 0 !== b) {
      a = this.rotationAxis(a), c *= g.dot(a, g.normalize(g.create(), b));
    }
    return c;
  };
  a.prototype.rotationAxis = function(a) {
    return this.valid && a.valid ? g.normalize(g.create(), [this._rotation[7] - a._rotation[5], this._rotation[2] - a._rotation[6], this._rotation[3] - a._rotation[1]]) : g.create();
  };
  a.prototype.rotationMatrix = function(a) {
    if (!this.valid || !a.valid) {
      return c.create();
    }
    var b = c.transpose(c.create(), this._rotation);
    return c.multiply(c.create(), a._rotation, b);
  };
  a.prototype.scaleFactor = function(a) {
    return this.valid && a.valid ? Math.exp(this._scaleFactor - a._scaleFactor) : 1;
  };
  a.prototype.translation = function(a) {
    return this.valid && a.valid ? g.subtract(g.create(), this._translation, a._translation) : g.create();
  };
  a.prototype.toString = function() {
    var a = "Frame [ id:" + this.id + " | timestamp:" + this.timestamp + " | Hand count:(" + this.hands.length + ") | Pointable count:(" + this.pointables.length + ")";
    return this.gestures && (a += " | Gesture count:(" + this.gestures.length + ")"), a + " ]";
  };
  a.prototype.dump = function() {
    var a;
    a = "Frame Info:<br/>" + this.toString();
    a += "<br/><br/>Hands:<br/>";
    for (var b = 0, c = this.hands.length;b != c;b++) {
      a += "  " + this.hands[b].toString() + "<br/>";
    }
    a += "<br/><br/>Pointables:<br/>";
    b = 0;
    for (c = this.pointables.length;b != c;b++) {
      a += "  " + this.pointables[b].toString() + "<br/>";
    }
    if (this.gestures) {
      for (a += "<br/><br/>Gestures:<br/>", b = 0, c = this.gestures.length;b != c;b++) {
        a += "  " + this.gestures[b].toString() + "<br/>";
      }
    }
    return a += "<br/><br/>Raw JSON:<br/>", a + JSON.stringify(this.data);
  };
  a.Invalid = {valid:!1, hands:[], fingers:[], tools:[], gestures:[], pointables:[], pointable:function() {
    return b.Invalid;
  }, finger:function() {
    return b.Invalid;
  }, hand:function() {
    return l.Invalid;
  }, toString:function() {
    return "invalid frame";
  }, dump:function() {
    return this.toString();
  }, rotationAngle:function() {
    return 0;
  }, rotationMatrix:function() {
    return c.create();
  }, rotationAxis:function() {
    return g.create();
  }, scaleFactor:function() {
    return 1;
  }, translation:function() {
    return g.create();
  }};
}, {"./finger":7, "./gesture":9, "./hand":10, "./interaction_box":12, "./pointable":14, "gl-matrix":23, underscore:24}], 9:[function(a, h, l) {
  var b = a("gl-matrix").vec3;
  h = a("events").EventEmitter;
  var f = a("underscore"), k = (l.createGesture = function(a) {
    var b;
    switch(a.type) {
      case "circle":
        b = new c(a);
        break;
      case "swipe":
        b = new g(a);
        break;
      case "screenTap":
        b = new e(a);
        break;
      case "keyTap":
        b = new p(a);
        break;
      default:
        throw "unknown gesture type";
    }
    return b.id = a.id, b.handIds = a.handIds.slice(), b.pointableIds = a.pointableIds.slice(), b.duration = a.duration, b.state = a.state, b.type = a.type, b;
  }, l.gestureListener = function(a, b) {
    var c = {}, e = {};
    a.on("gesture", function(a, g) {
      if (a.type == b) {
        if (("start" == a.state || "stop" == a.state) && void 0 === e[a.id]) {
          var h = new k(a, g);
          e[a.id] = h;
          f.each(c, function(a, b) {
            h.on(b, a);
          });
        }
        e[a.id].update(a, g);
        "stop" == a.state && delete e[a.id];
      }
    });
    var g = {start:function(a) {
      return c.start = a, g;
    }, stop:function(a) {
      return c.stop = a, g;
    }, complete:function(a) {
      return c.stop = a, g;
    }, update:function(a) {
      return c.update = a, g;
    }};
    return g;
  }, l.Gesture = function(a, b) {
    this.gestures = [a];
    this.frames = [b];
  });
  k.prototype.update = function(a, b) {
    this.lastGesture = a;
    this.lastFrame = b;
    this.gestures.push(a);
    this.frames.push(b);
    this.emit(a.state, this);
  };
  k.prototype.translation = function() {
    return b.subtract(b.create(), this.lastGesture.startPosition, this.lastGesture.position);
  };
  f.extend(k.prototype, h.prototype);
  var c = function(a) {
    this.center = a.center;
    this.normal = a.normal;
    this.progress = a.progress;
    this.radius = a.radius;
  };
  c.prototype.toString = function() {
    return "CircleGesture [" + JSON.stringify(this) + "]";
  };
  var g = function(a) {
    this.startPosition = a.startPosition;
    this.position = a.position;
    this.direction = a.direction;
    this.speed = a.speed;
  };
  g.prototype.toString = function() {
    return "SwipeGesture [" + JSON.stringify(this) + "]";
  };
  var e = function(a) {
    this.position = a.position;
    this.direction = a.direction;
    this.progress = a.progress;
  };
  e.prototype.toString = function() {
    return "ScreenTapGesture [" + JSON.stringify(this) + "]";
  };
  var p = function(a) {
    this.position = a.position;
    this.direction = a.direction;
    this.progress = a.progress;
  };
  p.prototype.toString = function() {
    return "KeyTapGesture [" + JSON.stringify(this) + "]";
  };
}, {events:21, "gl-matrix":23, underscore:24}], 10:[function(a, h) {
  var l = a("./pointable"), b = a("./bone"), f = a("gl-matrix"), k = f.mat3, c = f.vec3, g = a("underscore");
  a = h.exports = function(a) {
    this.id = a.id;
    this.palmPosition = a.palmPosition;
    this.direction = a.direction;
    this.palmVelocity = a.palmVelocity;
    this.palmNormal = a.palmNormal;
    this.sphereCenter = a.sphereCenter;
    this.sphereRadius = a.sphereRadius;
    this.valid = !0;
    this.pointables = [];
    this.fingers = [];
    this.arm = a.armBasis ? new b(this, {type:4, width:a.armWidth, prevJoint:a.elbow, nextJoint:a.wrist, basis:a.armBasis}) : null;
    this.tools = [];
    this._translation = a.t;
    this._rotation = g.flatten(a.r);
    this._scaleFactor = a.s;
    this.timeVisible = a.timeVisible;
    this.stabilizedPalmPosition = a.stabilizedPalmPosition;
    this.type = a.type;
    this.grabStrength = a.grabStrength;
    this.pinchStrength = a.pinchStrength;
    this.confidence = a.confidence;
  };
  a.prototype.finger = function(a) {
    return (a = this.frame.finger(a)) && a.handId == this.id ? a : l.Invalid;
  };
  a.prototype.rotationAngle = function(a, b) {
    if (!this.valid || !a.valid || !a.hand(this.id).valid) {
      return 0;
    }
    var e = this.rotationMatrix(a), e = Math.acos(.5 * (e[0] + e[4] + e[8] - 1));
    if (e = isNaN(e) ? 0 : e, void 0 !== b) {
      a = this.rotationAxis(a), e *= c.dot(a, c.normalize(c.create(), b));
    }
    return e;
  };
  a.prototype.rotationAxis = function(a) {
    if (!this.valid || !a.valid) {
      return c.create();
    }
    a = a.hand(this.id);
    return a.valid ? c.normalize(c.create(), [this._rotation[7] - a._rotation[5], this._rotation[2] - a._rotation[6], this._rotation[3] - a._rotation[1]]) : c.create();
  };
  a.prototype.rotationMatrix = function(a) {
    if (!this.valid || !a.valid) {
      return k.create();
    }
    a = a.hand(this.id);
    if (!a.valid) {
      return k.create();
    }
    var b = k.transpose(k.create(), this._rotation);
    return k.multiply(k.create(), a._rotation, b);
  };
  a.prototype.scaleFactor = function(a) {
    if (!this.valid || !a.valid) {
      return 1;
    }
    a = a.hand(this.id);
    return a.valid ? Math.exp(this._scaleFactor - a._scaleFactor) : 1;
  };
  a.prototype.translation = function(a) {
    if (!this.valid || !a.valid) {
      return c.create();
    }
    a = a.hand(this.id);
    return a.valid ? [this._translation[0] - a._translation[0], this._translation[1] - a._translation[1], this._translation[2] - a._translation[2]] : c.create();
  };
  a.prototype.toString = function() {
    return "Hand (" + this.type + ") [ id: " + this.id + " | palm velocity:" + this.palmVelocity + " | sphere center:" + this.sphereCenter + " ] ";
  };
  a.prototype.pitch = function() {
    return Math.atan2(this.direction[1], -this.direction[2]);
  };
  a.prototype.yaw = function() {
    return Math.atan2(this.direction[0], -this.direction[2]);
  };
  a.prototype.roll = function() {
    return Math.atan2(this.palmNormal[0], -this.palmNormal[1]);
  };
  a.Invalid = {valid:!1, fingers:[], tools:[], pointables:[], left:!1, pointable:function() {
    return l.Invalid;
  }, finger:function() {
    return l.Invalid;
  }, toString:function() {
    return "invalid frame";
  }, dump:function() {
    return this.toString();
  }, rotationAngle:function() {
    return 0;
  }, rotationMatrix:function() {
    return k.create();
  }, rotationAxis:function() {
    return c.create();
  }, scaleFactor:function() {
    return 1;
  }, translation:function() {
    return c.create();
  }};
}, {"./bone":1, "./pointable":14, "gl-matrix":23, underscore:24}], 11:[function(a, h) {
  h.exports = {Controller:a("./controller"), Frame:a("./frame"), Gesture:a("./gesture"), Hand:a("./hand"), Pointable:a("./pointable"), Finger:a("./finger"), InteractionBox:a("./interaction_box"), CircularBuffer:a("./circular_buffer"), UI:a("./ui"), JSONProtocol:a("./protocol").JSONProtocol, glMatrix:a("gl-matrix"), mat3:a("gl-matrix").mat3, vec3:a("gl-matrix").vec3, loopController:void 0, version:a("./version.js"), _:a("underscore"), EventEmitter:a("events").EventEmitter, loop:function(a, b) {
    return a && void 0 === b && "[object Function]" === {}.toString.call(a) && (b = a, a = {}), this.loopController ? a && this.loopController.setupFrameEvents(a) : this.loopController = new this.Controller(a), this.loopController.loop(b), this.loopController;
  }, plugin:function(a, b) {
    this.Controller.plugin(a, b);
  }};
}, {"./circular_buffer":2, "./controller":5, "./finger":7, "./frame":8, "./gesture":9, "./hand":10, "./interaction_box":12, "./pointable":14, "./protocol":15, "./ui":16, "./version.js":19, events:21, "gl-matrix":23, underscore:24}], 12:[function(a, h) {
  var l = a("gl-matrix").vec3;
  a = h.exports = function(a) {
    this.valid = !0;
    this.center = a.center;
    this.size = a.size;
    this.width = a.size[0];
    this.height = a.size[1];
    this.depth = a.size[2];
  };
  a.prototype.denormalizePoint = function(a) {
    return l.fromValues((a[0] - .5) * this.size[0] + this.center[0], (a[1] - .5) * this.size[1] + this.center[1], (a[2] - .5) * this.size[2] + this.center[2]);
  };
  a.prototype.normalizePoint = function(a, f) {
    a = l.fromValues((a[0] - this.center[0]) / this.size[0] + .5, (a[1] - this.center[1]) / this.size[1] + .5, (a[2] - this.center[2]) / this.size[2] + .5);
    return f && (a[0] = Math.min(Math.max(a[0], 0), 1), a[1] = Math.min(Math.max(a[1], 0), 1), a[2] = Math.min(Math.max(a[2], 0), 1)), a;
  };
  a.prototype.toString = function() {
    return "InteractionBox [ width:" + this.width + " | height:" + this.height + " | depth:" + this.depth + " ]";
  };
  a.Invalid = {valid:!1};
}, {"gl-matrix":23}], 13:[function(a, h) {
  a = h.exports = function(a) {
    this.steps = [];
    this.controller = a;
  };
  a.prototype.addStep = function(a) {
    this.steps.push(a);
  };
  a.prototype.run = function(a) {
    for (var b = this.steps.length, f = 0;f != b && a;f++) {
      a = this.steps[f](a);
    }
    return a;
  };
  a.prototype.removeStep = function(a) {
    a = this.steps.indexOf(a);
    if (-1 === a) {
      throw "Step not found in pipeline";
    }
    this.steps.splice(a, 1);
  };
  a.prototype.addWrappedStep = function(a, b) {
    var f = this.controller, k = function(c) {
      var g, e, k;
      g = "frame" == a ? [c] : c[a + "s"] || [];
      e = 0;
      for (k = g.length;k > e;e++) {
        b.call(f, g[e]);
      }
      return c;
    };
    return this.addStep(k), k;
  };
}, {}], 14:[function(a, h) {
  a = a("gl-matrix");
  h = (a.vec3, h.exports = function(a) {
    this.valid = !0;
    this.id = a.id;
    this.handId = a.handId;
    this.length = a.length;
    this.tool = a.tool;
    this.width = a.width;
    this.direction = a.direction;
    this.stabilizedTipPosition = a.stabilizedTipPosition;
    this.tipPosition = a.tipPosition;
    this.tipVelocity = a.tipVelocity;
    this.touchZone = a.touchZone;
    this.touchDistance = a.touchDistance;
    this.timeVisible = a.timeVisible;
  });
  h.prototype.toString = function() {
    return "Pointable [ id:" + this.id + " " + this.length + "mmx | width:" + this.width + "mm | direction:" + this.direction + " ]";
  };
  h.prototype.hand = function() {
    return this.frame.hand(this.handId);
  };
  h.Invalid = {valid:!1};
}, {"gl-matrix":23}], 15:[function(a, h, l) {
  var b = a("./frame"), f = (a("./hand"), a("./pointable"), a("./finger"), a("underscore")), k = a("events").EventEmitter, c = function(a) {
    this.type = a.type;
    this.state = a.state;
  };
  l.chooseProtocol = function(a) {
    var b;
    switch(a.version) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
        b = g(a);
        b.sendBackground = function(a, c) {
          a.send(b.encode({background:c}));
        };
        b.sendFocused = function(a, c) {
          a.send(b.encode({focused:c}));
        };
        b.sendOptimizeHMD = function(a, c) {
          a.send(b.encode({optimizeHMD:c}));
        };
        break;
      default:
        throw "unrecognized version";
    }
    return b;
  };
  var g = l.JSONProtocol = function(a) {
    var e = function(a) {
      if (a.event) {
        return new c(a.event);
      }
      e.emit("beforeFrameCreated", a);
      var g = new b(a);
      return e.emit("afterFrameCreated", g, a), g;
    };
    return e.encode = function(a) {
      return JSON.stringify(a);
    }, e.version = a.version, e.serviceVersion = a.serviceVersion, e.versionLong = "Version " + a.version, e.type = "protocol", f.extend(e, k.prototype), e;
  };
}, {"./finger":7, "./frame":8, "./hand":10, "./pointable":14, events:21, underscore:24}], 16:[function(a, h, l) {
  l.UI = {Region:a("./ui/region"), Cursor:a("./ui/cursor")};
}, {"./ui/cursor":17, "./ui/region":18}], 17:[function(a, h) {
  h.exports = function() {
    return function(a) {
      var b = a.pointables.sort(function(a, b) {
        return a.z - b.z;
      })[0];
      return b && b.valid && (a.cursorPosition = b.tipPosition), a;
    };
  };
}, {}], 18:[function(a, h) {
  var l = a("events").EventEmitter;
  a = a("underscore");
  var b = h.exports = function(a, b) {
    this.start = new Vector(a);
    this.end = new Vector(b);
    this.enteredFrame = null;
  };
  b.prototype.hasPointables = function(a) {
    for (var b = 0;b != a.pointables.length;b++) {
      var c = a.pointables[b].tipPosition;
      if (c.x >= this.start.x && c.x <= this.end.x && c.y >= this.start.y && c.y <= this.end.y && c.z >= this.start.z && c.z <= this.end.z) {
        return !0;
      }
    }
    return !1;
  };
  b.prototype.listener = function(a) {
    var b = this;
    return a && a.nearThreshold && this.setupNearRegion(a.nearThreshold), function(a) {
      return b.updatePosition(a);
    };
  };
  b.prototype.clipper = function() {
    var a = this;
    return function(b) {
      return a.updatePosition(b), a.enteredFrame ? b : null;
    };
  };
  b.prototype.setupNearRegion = function(a) {
    a = this.nearRegion = new b([this.start.x - a, this.start.y - a, this.start.z - a], [this.end.x + a, this.end.y + a, this.end.z + a]);
    var f = this;
    a.on("enter", function(a) {
      f.emit("near", a);
    });
    a.on("exit", function(a) {
      f.emit("far", a);
    });
    f.on("exit", function(a) {
      f.emit("near", a);
    });
  };
  b.prototype.updatePosition = function(a) {
    return this.nearRegion && this.nearRegion.updatePosition(a), this.hasPointables(a) && null == this.enteredFrame ? (this.enteredFrame = a, this.emit("enter", this.enteredFrame)) : this.hasPointables(a) || null == this.enteredFrame || (this.enteredFrame = null, this.emit("exit", this.enteredFrame)), a;
  };
  b.prototype.normalize = function(a) {
    return new Vector([(a.x - this.start.x) / (this.end.x - this.start.x), (a.y - this.start.y) / (this.end.y - this.start.y), (a.z - this.start.z) / (this.end.z - this.start.z)]);
  };
  b.prototype.mapToXY = function(a, b, c) {
    a = this.normalize(a);
    var g = a.x, e = a.y;
    return 1 < g ? g = 1 : -1 > g && (g = -1), 1 < e ? e = 1 : -1 > e && (e = -1), [(g + 1) / 2 * b, (1 - e) / 2 * c, a.z];
  };
  a.extend(b.prototype, l.prototype);
}, {events:21, underscore:24}], 19:[function(a, h) {
  h.exports = {full:"0.6.4", major:0, minor:6, dot:4};
}, {}], 20:[function() {
}, {}], 21:[function(a, h, l) {
  a = a("__browserify_process");
  a.EventEmitter || (a.EventEmitter = function() {
  });
  l = l.EventEmitter = a.EventEmitter;
  var b = "function" == typeof Array.isArray ? Array.isArray : function(a) {
    return "[object Array]" === Object.prototype.toString.call(a);
  };
  l.prototype.setMaxListeners = function(a) {
    this._events || (this._events = {});
    this._events.maxListeners = a;
  };
  l.prototype.emit = function(a) {
    if ("error" === a && (!this._events || !this._events.error || b(this._events.error) && !this._events.error.length)) {
      throw arguments[1] instanceof Error ? arguments[1] : Error("Uncaught, unspecified 'error' event.");
    }
    if (!this._events) {
      return !1;
    }
    var f = this._events[a];
    if (!f) {
      return !1;
    }
    if ("function" == typeof f) {
      switch(arguments.length) {
        case 1:
          f.call(this);
          break;
        case 2:
          f.call(this, arguments[1]);
          break;
        case 3:
          f.call(this, arguments[1], arguments[2]);
          break;
        default:
          var c = Array.prototype.slice.call(arguments, 1);
          f.apply(this, c);
      }
      return !0;
    }
    if (b(f)) {
      for (var c = Array.prototype.slice.call(arguments, 1), f = f.slice(), g = 0, e = f.length;e > g;g++) {
        f[g].apply(this, c);
      }
      return !0;
    }
    return !1;
  };
  l.prototype.addListener = function(a, k) {
    if ("function" != typeof k) {
      throw Error("addListener only takes instances of Function");
    }
    if (this._events || (this._events = {}), this.emit("newListener", a, k), this._events[a]) {
      if (b(this._events[a])) {
        if (!this._events[a].warned) {
          var c;
          (c = void 0 !== this._events.maxListeners ? this._events.maxListeners : 10) && 0 < c && this._events[a].length > c && (this._events[a].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[a].length), console.trace());
        }
        this._events[a].push(k);
      } else {
        this._events[a] = [this._events[a], k];
      }
    } else {
      this._events[a] = k;
    }
    return this;
  };
  l.prototype.on = l.prototype.addListener;
  l.prototype.once = function(a, b) {
    var c = this;
    return c.on(a, function e() {
      c.removeListener(a, e);
      b.apply(this, arguments);
    }), this;
  };
  l.prototype.removeListener = function(a, k) {
    if ("function" != typeof k) {
      throw Error("removeListener only takes instances of Function");
    }
    if (!this._events || !this._events[a]) {
      return this;
    }
    var c = this._events[a];
    if (b(c)) {
      a: {
        if (c.indexOf) {
          k = c.indexOf(k);
        } else {
          for (var g = 0;g < c.length;g++) {
            if (k === c[g]) {
              k = g;
              break a;
            }
          }
          k = -1;
        }
      }
      if (0 > k) {
        return this;
      }
      c.splice(k, 1);
      0 == c.length && delete this._events[a];
    } else {
      this._events[a] === k && delete this._events[a];
    }
    return this;
  };
  l.prototype.removeAllListeners = function(a) {
    return 0 === arguments.length ? (this._events = {}, this) : (a && this._events && this._events[a] && (this._events[a] = null), this);
  };
  l.prototype.listeners = function(a) {
    return this._events || (this._events = {}), this._events[a] || (this._events[a] = []), b(this._events[a]) || (this._events[a] = [this._events[a]]), this._events[a];
  };
  l.listenerCount = function(a, b) {
    return a._events && a._events[b] ? "function" == typeof a._events[b] ? 1 : a._events[b].length : 0;
  };
}, {__browserify_process:22}], 22:[function(a, h) {
  a = h.exports = {};
  a.nextTick = function() {
    if ("undefined" != typeof window && window.setImmediate) {
      return function(a) {
        return window.setImmediate(a);
      };
    }
    if ("undefined" != typeof window && window.postMessage && window.addEventListener) {
      var a = [];
      return window.addEventListener("message", function(b) {
        var f = b.source;
        (f === window || null === f) && "process-tick" === b.data && (b.stopPropagation(), 0 < a.length) && a.shift()();
      }, !0), function(b) {
        a.push(b);
        window.postMessage("process-tick", "*");
      };
    }
    return function(a) {
      setTimeout(a, 0);
    };
  }();
  a.title = "browser";
  a.browser = !0;
  a.env = {};
  a.argv = [];
  a.binding = function() {
    throw Error("process.binding is not supported");
  };
  a.cwd = function() {
    return "/";
  };
  a.chdir = function() {
    throw Error("process.chdir is not supported");
  };
}, {}], 23:[function(a, h, l) {
  !function(a) {
    var b;
    "undefined" == typeof l ? "function" == typeof define && "object" == typeof define.amd && define.amd ? (b = {}, define(function() {
      return b;
    })) : b = "undefined" != typeof window ? window : a : b = l;
    (function(a) {
      if (!b) {
        var b = 1E-6;
      }
      if (!g) {
        var g = "undefined" != typeof Float32Array ? Float32Array : Array;
      }
      if (!e) {
        var e = Math.random;
      }
      var f = {setMatrixArrayType:function(a) {
        g = a;
      }};
      "undefined" != typeof a && (a.glMatrix = f);
      var k = Math.PI / 180;
      f.toRadian = function(a) {
        return a * k;
      };
      var h = {create:function() {
        var a = new g(2);
        return a[0] = 0, a[1] = 0, a;
      }, clone:function(a) {
        var b = new g(2);
        return b[0] = a[0], b[1] = a[1], b;
      }, fromValues:function(a, b) {
        var c = new g(2);
        return c[0] = a, c[1] = b, c;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a;
      }, set:function(a, b, c) {
        return a[0] = b, a[1] = c, a;
      }, add:function(a, b, c) {
        return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a;
      }, subtract:function(a, b, c) {
        return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a;
      }};
      h.sub = h.subtract;
      h.multiply = function(a, b, c) {
        return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a;
      };
      h.mul = h.multiply;
      h.divide = function(a, b, c) {
        return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a;
      };
      h.div = h.divide;
      h.min = function(a, b, c) {
        return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a;
      };
      h.max = function(a, b, c) {
        return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a;
      };
      h.scale = function(a, b, c) {
        return a[0] = b[0] * c, a[1] = b[1] * c, a;
      };
      h.scaleAndAdd = function(a, b, c, e) {
        return a[0] = b[0] + c[0] * e, a[1] = b[1] + c[1] * e, a;
      };
      h.distance = function(a, b) {
        var c = b[0] - a[0];
        a = b[1] - a[1];
        return Math.sqrt(c * c + a * a);
      };
      h.dist = h.distance;
      h.squaredDistance = function(a, b) {
        var c = b[0] - a[0];
        a = b[1] - a[1];
        return c * c + a * a;
      };
      h.sqrDist = h.squaredDistance;
      h.length = function(a) {
        var b = a[0];
        a = a[1];
        return Math.sqrt(b * b + a * a);
      };
      h.len = h.length;
      h.squaredLength = function(a) {
        var b = a[0];
        a = a[1];
        return b * b + a * a;
      };
      h.sqrLen = h.squaredLength;
      h.negate = function(a, b) {
        return a[0] = -b[0], a[1] = -b[1], a;
      };
      h.normalize = function(a, b) {
        var c = b[0], e = b[1], c = c * c + e * e;
        return 0 < c && (c = 1 / Math.sqrt(c), a[0] = b[0] * c, a[1] = b[1] * c), a;
      };
      h.dot = function(a, b) {
        return a[0] * b[0] + a[1] * b[1];
      };
      h.cross = function(a, b, c) {
        b = b[0] * c[1] - b[1] * c[0];
        return a[0] = a[1] = 0, a[2] = b, a;
      };
      h.lerp = function(a, b, c, e) {
        var g = b[0];
        b = b[1];
        return a[0] = g + e * (c[0] - g), a[1] = b + e * (c[1] - b), a;
      };
      h.random = function(a, b) {
        b = b || 1;
        var c = 2 * e() * Math.PI;
        return a[0] = Math.cos(c) * b, a[1] = Math.sin(c) * b, a;
      };
      h.transformMat2 = function(a, b, c) {
        var e = b[0];
        b = b[1];
        return a[0] = c[0] * e + c[2] * b, a[1] = c[1] * e + c[3] * b, a;
      };
      h.transformMat2d = function(a, b, c) {
        var e = b[0];
        b = b[1];
        return a[0] = c[0] * e + c[2] * b + c[4], a[1] = c[1] * e + c[3] * b + c[5], a;
      };
      h.transformMat3 = function(a, b, c) {
        var e = b[0];
        b = b[1];
        return a[0] = c[0] * e + c[3] * b + c[6], a[1] = c[1] * e + c[4] * b + c[7], a;
      };
      h.transformMat4 = function(a, b, c) {
        var e = b[0];
        b = b[1];
        return a[0] = c[0] * e + c[4] * b + c[12], a[1] = c[1] * e + c[5] * b + c[13], a;
      };
      h.forEach = function() {
        var a = h.create();
        return function(b, c, e, g, f, k) {
          c || (c = 2);
          e || (e = 0);
          for (g = g ? Math.min(g * c + e, b.length) : b.length;g > e;e += c) {
            a[0] = b[e], a[1] = b[e + 1], f(a, a, k), b[e] = a[0], b[e + 1] = a[1];
          }
          return b;
        };
      }();
      h.str = function(a) {
        return "vec2(" + a[0] + ", " + a[1] + ")";
      };
      "undefined" != typeof a && (a.vec2 = h);
      var l = {create:function() {
        var a = new g(3);
        return a[0] = 0, a[1] = 0, a[2] = 0, a;
      }, clone:function(a) {
        var b = new g(3);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b;
      }, fromValues:function(a, b, c) {
        var e = new g(3);
        return e[0] = a, e[1] = b, e[2] = c, e;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a;
      }, set:function(a, b, c, e) {
        return a[0] = b, a[1] = c, a[2] = e, a;
      }, add:function(a, b, c) {
        return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a[2] = b[2] + c[2], a;
      }, subtract:function(a, b, c) {
        return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a[2] = b[2] - c[2], a;
      }};
      l.sub = l.subtract;
      l.multiply = function(a, b, c) {
        return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a[2] = b[2] * c[2], a;
      };
      l.mul = l.multiply;
      l.divide = function(a, b, c) {
        return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a[2] = b[2] / c[2], a;
      };
      l.div = l.divide;
      l.min = function(a, b, c) {
        return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a[2] = Math.min(b[2], c[2]), a;
      };
      l.max = function(a, b, c) {
        return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a[2] = Math.max(b[2], c[2]), a;
      };
      l.scale = function(a, b, c) {
        return a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a;
      };
      l.scaleAndAdd = function(a, b, c, e) {
        return a[0] = b[0] + c[0] * e, a[1] = b[1] + c[1] * e, a[2] = b[2] + c[2] * e, a;
      };
      l.distance = function(a, b) {
        var c = b[0] - a[0], e = b[1] - a[1];
        a = b[2] - a[2];
        return Math.sqrt(c * c + e * e + a * a);
      };
      l.dist = l.distance;
      l.squaredDistance = function(a, b) {
        var c = b[0] - a[0], e = b[1] - a[1];
        a = b[2] - a[2];
        return c * c + e * e + a * a;
      };
      l.sqrDist = l.squaredDistance;
      l.length = function(a) {
        var b = a[0], c = a[1];
        a = a[2];
        return Math.sqrt(b * b + c * c + a * a);
      };
      l.len = l.length;
      l.squaredLength = function(a) {
        var b = a[0], c = a[1];
        a = a[2];
        return b * b + c * c + a * a;
      };
      l.sqrLen = l.squaredLength;
      l.negate = function(a, b) {
        return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a;
      };
      l.normalize = function(a, b) {
        var c = b[0], e = b[1], g = b[2], c = c * c + e * e + g * g;
        return 0 < c && (c = 1 / Math.sqrt(c), a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c), a;
      };
      l.dot = function(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      };
      l.cross = function(a, b, c) {
        var e = b[0], g = b[1];
        b = b[2];
        var f = c[0], k = c[1];
        c = c[2];
        return a[0] = g * c - b * k, a[1] = b * f - e * c, a[2] = e * k - g * f, a;
      };
      l.lerp = function(a, b, c, e) {
        var g = b[0], f = b[1];
        b = b[2];
        return a[0] = g + e * (c[0] - g), a[1] = f + e * (c[1] - f), a[2] = b + e * (c[2] - b), a;
      };
      l.random = function(a, b) {
        b = b || 1;
        var c = 2 * e() * Math.PI, g = 2 * e() - 1, f = Math.sqrt(1 - g * g) * b;
        return a[0] = Math.cos(c) * f, a[1] = Math.sin(c) * f, a[2] = g * b, a;
      };
      l.transformMat4 = function(a, b, c) {
        var e = b[0], g = b[1];
        b = b[2];
        return a[0] = c[0] * e + c[4] * g + c[8] * b + c[12], a[1] = c[1] * e + c[5] * g + c[9] * b + c[13], a[2] = c[2] * e + c[6] * g + c[10] * b + c[14], a;
      };
      l.transformMat3 = function(a, b, c) {
        var e = b[0], g = b[1];
        b = b[2];
        return a[0] = e * c[0] + g * c[3] + b * c[6], a[1] = e * c[1] + g * c[4] + b * c[7], a[2] = e * c[2] + g * c[5] + b * c[8], a;
      };
      l.transformQuat = function(a, b, c) {
        var e = b[0], g = b[1], f = b[2];
        b = c[0];
        var k = c[1], h = c[2];
        c = c[3];
        var q = c * e + k * f - h * g, p = c * g + h * e - b * f, l = c * f + b * g - k * e, e = -b * e - k * g - h * f;
        return a[0] = q * c + e * -b + p * -h - l * -k, a[1] = p * c + e * -k + l * -b - q * -h, a[2] = l * c + e * -h + q * -k - p * -b, a;
      };
      l.rotateX = function(a, b, c, e) {
        var g = [], f = [];
        return g[0] = b[0] - c[0], g[1] = b[1] - c[1], g[2] = b[2] - c[2], f[0] = g[0], f[1] = g[1] * Math.cos(e) - g[2] * Math.sin(e), f[2] = g[1] * Math.sin(e) + g[2] * Math.cos(e), a[0] = f[0] + c[0], a[1] = f[1] + c[1], a[2] = f[2] + c[2], a;
      };
      l.rotateY = function(a, b, c, e) {
        var g = [], f = [];
        return g[0] = b[0] - c[0], g[1] = b[1] - c[1], g[2] = b[2] - c[2], f[0] = g[2] * Math.sin(e) + g[0] * Math.cos(e), f[1] = g[1], f[2] = g[2] * Math.cos(e) - g[0] * Math.sin(e), a[0] = f[0] + c[0], a[1] = f[1] + c[1], a[2] = f[2] + c[2], a;
      };
      l.rotateZ = function(a, b, c, e) {
        var g = [], f = [];
        return g[0] = b[0] - c[0], g[1] = b[1] - c[1], g[2] = b[2] - c[2], f[0] = g[0] * Math.cos(e) - g[1] * Math.sin(e), f[1] = g[0] * Math.sin(e) + g[1] * Math.cos(e), f[2] = g[2], a[0] = f[0] + c[0], a[1] = f[1] + c[1], a[2] = f[2] + c[2], a;
      };
      l.forEach = function() {
        var a = l.create();
        return function(b, c, e, g, f, k) {
          c || (c = 3);
          e || (e = 0);
          for (g = g ? Math.min(g * c + e, b.length) : b.length;g > e;e += c) {
            a[0] = b[e], a[1] = b[e + 1], a[2] = b[e + 2], f(a, a, k), b[e] = a[0], b[e + 1] = a[1], b[e + 2] = a[2];
          }
          return b;
        };
      }();
      l.str = function(a) {
        return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
      };
      "undefined" != typeof a && (a.vec3 = l);
      var t = {create:function() {
        var a = new g(4);
        return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 0, a;
      }, clone:function(a) {
        var b = new g(4);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b;
      }, fromValues:function(a, b, c, e) {
        var f = new g(4);
        return f[0] = a, f[1] = b, f[2] = c, f[3] = e, f;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a;
      }, set:function(a, b, c, e, g) {
        return a[0] = b, a[1] = c, a[2] = e, a[3] = g, a;
      }, add:function(a, b, c) {
        return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a[2] = b[2] + c[2], a[3] = b[3] + c[3], a;
      }, subtract:function(a, b, c) {
        return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a[2] = b[2] - c[2], a[3] = b[3] - c[3], a;
      }};
      t.sub = t.subtract;
      t.multiply = function(a, b, c) {
        return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a[2] = b[2] * c[2], a[3] = b[3] * c[3], a;
      };
      t.mul = t.multiply;
      t.divide = function(a, b, c) {
        return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a[2] = b[2] / c[2], a[3] = b[3] / c[3], a;
      };
      t.div = t.divide;
      t.min = function(a, b, c) {
        return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a[2] = Math.min(b[2], c[2]), a[3] = Math.min(b[3], c[3]), a;
      };
      t.max = function(a, b, c) {
        return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a[2] = Math.max(b[2], c[2]), a[3] = Math.max(b[3], c[3]), a;
      };
      t.scale = function(a, b, c) {
        return a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a[3] = b[3] * c, a;
      };
      t.scaleAndAdd = function(a, b, c, e) {
        return a[0] = b[0] + c[0] * e, a[1] = b[1] + c[1] * e, a[2] = b[2] + c[2] * e, a[3] = b[3] + c[3] * e, a;
      };
      t.distance = function(a, b) {
        var c = b[0] - a[0], e = b[1] - a[1], g = b[2] - a[2];
        a = b[3] - a[3];
        return Math.sqrt(c * c + e * e + g * g + a * a);
      };
      t.dist = t.distance;
      t.squaredDistance = function(a, b) {
        var c = b[0] - a[0], e = b[1] - a[1], g = b[2] - a[2];
        a = b[3] - a[3];
        return c * c + e * e + g * g + a * a;
      };
      t.sqrDist = t.squaredDistance;
      t.length = function(a) {
        var b = a[0], c = a[1], e = a[2];
        a = a[3];
        return Math.sqrt(b * b + c * c + e * e + a * a);
      };
      t.len = t.length;
      t.squaredLength = function(a) {
        var b = a[0], c = a[1], e = a[2];
        a = a[3];
        return b * b + c * c + e * e + a * a;
      };
      t.sqrLen = t.squaredLength;
      t.negate = function(a, b) {
        return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a[3] = -b[3], a;
      };
      t.normalize = function(a, b) {
        var c = b[0], e = b[1], g = b[2], f = b[3], c = c * c + e * e + g * g + f * f;
        return 0 < c && (c = 1 / Math.sqrt(c), a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a[3] = b[3] * c), a;
      };
      t.dot = function(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
      };
      t.lerp = function(a, b, c, e) {
        var g = b[0], f = b[1], k = b[2];
        b = b[3];
        return a[0] = g + e * (c[0] - g), a[1] = f + e * (c[1] - f), a[2] = k + e * (c[2] - k), a[3] = b + e * (c[3] - b), a;
      };
      t.random = function(a, b) {
        return b = b || 1, a[0] = e(), a[1] = e(), a[2] = e(), a[3] = e(), t.normalize(a, a), t.scale(a, a, b), a;
      };
      t.transformMat4 = function(a, b, c) {
        var e = b[0], g = b[1], f = b[2];
        b = b[3];
        return a[0] = c[0] * e + c[4] * g + c[8] * f + c[12] * b, a[1] = c[1] * e + c[5] * g + c[9] * f + c[13] * b, a[2] = c[2] * e + c[6] * g + c[10] * f + c[14] * b, a[3] = c[3] * e + c[7] * g + c[11] * f + c[15] * b, a;
      };
      t.transformQuat = function(a, b, c) {
        var e = b[0], g = b[1], f = b[2];
        b = c[0];
        var k = c[1], h = c[2];
        c = c[3];
        var q = c * e + k * f - h * g, p = c * g + h * e - b * f, l = c * f + b * g - k * e, e = -b * e - k * g - h * f;
        return a[0] = q * c + e * -b + p * -h - l * -k, a[1] = p * c + e * -k + l * -b - q * -h, a[2] = l * c + e * -h + q * -k - p * -b, a;
      };
      t.forEach = function() {
        var a = t.create();
        return function(b, c, e, g, f, k) {
          c || (c = 4);
          e || (e = 0);
          for (g = g ? Math.min(g * c + e, b.length) : b.length;g > e;e += c) {
            a[0] = b[e], a[1] = b[e + 1], a[2] = b[e + 2], a[3] = b[e + 3], f(a, a, k), b[e] = a[0], b[e + 1] = a[1], b[e + 2] = a[2], b[e + 3] = a[3];
          }
          return b;
        };
      }();
      t.str = function(a) {
        return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
      };
      "undefined" != typeof a && (a.vec4 = t);
      f = {create:function() {
        var a = new g(4);
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a;
      }, clone:function(a) {
        var b = new g(4);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a;
      }, identity:function(a) {
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a;
      }, transpose:function(a, b) {
        if (a === b) {
          var c = b[1];
          a[1] = b[2];
          a[2] = c;
        } else {
          a[0] = b[0], a[1] = b[2], a[2] = b[1], a[3] = b[3];
        }
        return a;
      }, invert:function(a, b) {
        var c = b[0], e = b[1], g = b[2];
        b = b[3];
        var f = c * b - g * e;
        return f ? (f = 1 / f, a[0] = b * f, a[1] = -e * f, a[2] = -g * f, a[3] = c * f, a) : null;
      }, adjoint:function(a, b) {
        var c = b[0];
        return a[0] = b[3], a[1] = -b[1], a[2] = -b[2], a[3] = c, a;
      }, determinant:function(a) {
        return a[0] * a[3] - a[2] * a[1];
      }, multiply:function(a, b, c) {
        var e = b[0], g = b[1], f = b[2];
        b = b[3];
        var k = c[0], h = c[1], p = c[2];
        c = c[3];
        return a[0] = e * k + f * h, a[1] = g * k + b * h, a[2] = e * p + f * c, a[3] = g * p + b * c, a;
      }};
      f.mul = f.multiply;
      f.rotate = function(a, b, c) {
        var e = b[0], g = b[1], f = b[2];
        b = b[3];
        var k = Math.sin(c);
        c = Math.cos(c);
        return a[0] = e * c + f * k, a[1] = g * c + b * k, a[2] = e * -k + f * c, a[3] = g * -k + b * c, a;
      };
      f.scale = function(a, b, c) {
        var e = b[1], g = b[2], f = b[3], k = c[0];
        c = c[1];
        return a[0] = b[0] * k, a[1] = e * k, a[2] = g * c, a[3] = f * c, a;
      };
      f.str = function(a) {
        return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
      };
      f.frob = function(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
      };
      f.LDU = function(a, b, c, e) {
        return a[2] = e[2] / e[0], c[0] = e[0], c[1] = e[1], c[3] = e[3] - a[2] * c[1], [a, b, c];
      };
      "undefined" != typeof a && (a.mat2 = f);
      f = {create:function() {
        var a = new g(6);
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a[4] = 0, a[5] = 0, a;
      }, clone:function(a) {
        var b = new g(6);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], a;
      }, identity:function(a) {
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a[4] = 0, a[5] = 0, a;
      }, invert:function(a, b) {
        var c = b[0], e = b[1], g = b[2], f = b[3], k = b[4];
        b = b[5];
        var h = c * f - e * g;
        return h ? (h = 1 / h, a[0] = f * h, a[1] = -e * h, a[2] = -g * h, a[3] = c * h, a[4] = (g * b - f * k) * h, a[5] = (e * k - c * b) * h, a) : null;
      }, determinant:function(a) {
        return a[0] * a[3] - a[1] * a[2];
      }, multiply:function(a, b, c) {
        var e = b[0], g = b[1], f = b[2], k = b[3], h = b[4];
        b = b[5];
        var p = c[0], q = c[1], l = c[2], n = c[3], r = c[4];
        c = c[5];
        return a[0] = e * p + f * q, a[1] = g * p + k * q, a[2] = e * l + f * n, a[3] = g * l + k * n, a[4] = e * r + f * c + h, a[5] = g * r + k * c + b, a;
      }};
      f.mul = f.multiply;
      f.rotate = function(a, b, c) {
        var e = b[0], g = b[1], f = b[2], k = b[3], h = b[4];
        b = b[5];
        var p = Math.sin(c);
        c = Math.cos(c);
        return a[0] = e * c + f * p, a[1] = g * c + k * p, a[2] = e * -p + f * c, a[3] = g * -p + k * c, a[4] = h, a[5] = b, a;
      };
      f.scale = function(a, b, c) {
        var e = b[1], g = b[2], f = b[3], k = b[4], h = b[5], p = c[0];
        c = c[1];
        return a[0] = b[0] * p, a[1] = e * p, a[2] = g * c, a[3] = f * c, a[4] = k, a[5] = h, a;
      };
      f.translate = function(a, b, c) {
        var e = b[0], g = b[1], f = b[2], k = b[3], h = b[4];
        b = b[5];
        var p = c[0];
        c = c[1];
        return a[0] = e, a[1] = g, a[2] = f, a[3] = k, a[4] = e * p + f * c + h, a[5] = g * p + k * c + b, a;
      };
      f.str = function(a) {
        return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
      };
      f.frob = function(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
      };
      "undefined" != typeof a && (a.mat2d = f);
      var v = {create:function() {
        var a = new g(9);
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 1, a[5] = 0, a[6] = 0, a[7] = 0, a[8] = 1, a;
      }, fromMat4:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[4], a[4] = b[5], a[5] = b[6], a[6] = b[8], a[7] = b[9], a[8] = b[10], a;
      }, clone:function(a) {
        var b = new g(9);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], b;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[8] = b[8], a;
      }, identity:function(a) {
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 1, a[5] = 0, a[6] = 0, a[7] = 0, a[8] = 1, a;
      }, transpose:function(a, b) {
        if (a === b) {
          var c = b[1], e = b[2], g = b[5];
          a[1] = b[3];
          a[2] = b[6];
          a[3] = c;
          a[5] = b[7];
          a[6] = e;
          a[7] = g;
        } else {
          a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], a[6] = b[2], a[7] = b[5], a[8] = b[8];
        }
        return a;
      }, invert:function(a, b) {
        var c = b[0], e = b[1], g = b[2], f = b[3], k = b[4], h = b[5], p = b[6], l = b[7];
        b = b[8];
        var q = b * k - h * l, n = -b * f + h * p, r = l * f - k * p, u = c * q + e * n + g * r;
        return u ? (u = 1 / u, a[0] = q * u, a[1] = (-b * e + g * l) * u, a[2] = (h * e - g * k) * u, a[3] = n * u, a[4] = (b * c - g * p) * u, a[5] = (-h * c + g * f) * u, a[6] = r * u, a[7] = (-l * c + e * p) * u, a[8] = (k * c - e * f) * u, a) : null;
      }, adjoint:function(a, b) {
        var c = b[0], e = b[1], g = b[2], f = b[3], k = b[4], h = b[5], p = b[6], l = b[7];
        b = b[8];
        return a[0] = k * b - h * l, a[1] = g * l - e * b, a[2] = e * h - g * k, a[3] = h * p - f * b, a[4] = c * b - g * p, a[5] = g * f - c * h, a[6] = f * l - k * p, a[7] = e * p - c * l, a[8] = c * k - e * f, a;
      }, determinant:function(a) {
        var b = a[3], c = a[4], e = a[5], g = a[6], f = a[7], k = a[8];
        return a[0] * (k * c - e * f) + a[1] * (-k * b + e * g) + a[2] * (f * b - c * g);
      }, multiply:function(a, b, c) {
        var e = b[0], g = b[1], f = b[2], k = b[3], h = b[4], p = b[5], l = b[6], q = b[7];
        b = b[8];
        var n = c[0], r = c[1], u = c[2], w = c[3], t = c[4], v = c[5], y = c[6], x = c[7];
        c = c[8];
        return a[0] = n * e + r * k + u * l, a[1] = n * g + r * h + u * q, a[2] = n * f + r * p + u * b, a[3] = w * e + t * k + v * l, a[4] = w * g + t * h + v * q, a[5] = w * f + t * p + v * b, a[6] = y * e + x * k + c * l, a[7] = y * g + x * h + c * q, a[8] = y * f + x * p + c * b, a;
      }};
      v.mul = v.multiply;
      v.translate = function(a, b, c) {
        var e = b[0], g = b[1], f = b[2], k = b[3], h = b[4], p = b[5], l = b[6], q = b[7];
        b = b[8];
        var n = c[0];
        c = c[1];
        return a[0] = e, a[1] = g, a[2] = f, a[3] = k, a[4] = h, a[5] = p, a[6] = n * e + c * k + l, a[7] = n * g + c * h + q, a[8] = n * f + c * p + b, a;
      };
      v.rotate = function(a, b, c) {
        var e = b[0], g = b[1], f = b[2], k = b[3], h = b[4], p = b[5], l = b[6], q = b[7];
        b = b[8];
        var n = Math.sin(c);
        c = Math.cos(c);
        return a[0] = c * e + n * k, a[1] = c * g + n * h, a[2] = c * f + n * p, a[3] = c * k - n * e, a[4] = c * h - n * g, a[5] = c * p - n * f, a[6] = l, a[7] = q, a[8] = b, a;
      };
      v.scale = function(a, b, c) {
        var e = c[0];
        c = c[1];
        return a[0] = e * b[0], a[1] = e * b[1], a[2] = e * b[2], a[3] = c * b[3], a[4] = c * b[4], a[5] = c * b[5], a[6] = b[6], a[7] = b[7], a[8] = b[8], a;
      };
      v.fromMat2d = function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = 0, a[3] = b[2], a[4] = b[3], a[5] = 0, a[6] = b[4], a[7] = b[5], a[8] = 1, a;
      };
      v.fromQuat = function(a, b) {
        var c = b[0], e = b[1], g = b[2];
        b = b[3];
        var f = c + c, k = e + e, h = g + g, c = c * f, p = e * f, e = e * k, l = g * f, q = g * k, g = g * h, f = b * f, k = b * k;
        b *= h;
        return a[0] = 1 - e - g, a[3] = p - b, a[6] = l + k, a[1] = p + b, a[4] = 1 - c - g, a[7] = q - f, a[2] = l - k, a[5] = q + f, a[8] = 1 - c - e, a;
      };
      v.normalFromMat4 = function(a, b) {
        var c = b[0], e = b[1], g = b[2], f = b[3], k = b[4], h = b[5], p = b[6], l = b[7], q = b[8], n = b[9], r = b[10], u = b[11], w = b[12], t = b[13], v = b[14];
        b = b[15];
        var y = c * h - e * k, x = c * p - g * k, S = c * l - f * k, V = e * p - g * h, N = e * l - f * h, X = g * l - f * p, ia = q * t - n * w, ta = q * v - r * w, q = q * b - u * w, T = n * v - r * t, n = n * b - u * t, r = r * b - u * v;
        return (u = y * r - x * n + S * T + V * q - N * ta + X * ia) ? (u = 1 / u, a[0] = (h * r - p * n + l * T) * u, a[1] = (p * q - k * r - l * ta) * u, a[2] = (k * n - h * q + l * ia) * u, a[3] = (g * n - e * r - f * T) * u, a[4] = (c * r - g * q + f * ta) * u, a[5] = (e * q - c * n - f * ia) * u, a[6] = (t * X - v * N + b * V) * u, a[7] = (v * S - w * X - b * x) * u, a[8] = (w * N - t * S + b * y) * u, a) : null;
      };
      v.str = function(a) {
        return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
      };
      v.frob = function(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
      };
      "undefined" != typeof a && (a.mat3 = v);
      var y = {create:function() {
        var a = new g(16);
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
      }, clone:function(a) {
        var b = new g(16);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], b[9] = a[9], b[10] = a[10], b[11] = a[11], b[12] = a[12], b[13] = a[13], b[14] = a[14], b[15] = a[15], b;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[8] = b[8], a[9] = b[9], a[10] = b[10], a[11] = b[11], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15], a;
      }, identity:function(a) {
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
      }, transpose:function(a, b) {
        if (a === b) {
          var c = b[1], e = b[2], g = b[3], f = b[6], k = b[7], h = b[11];
          a[1] = b[4];
          a[2] = b[8];
          a[3] = b[12];
          a[4] = c;
          a[6] = b[9];
          a[7] = b[13];
          a[8] = e;
          a[9] = f;
          a[11] = b[14];
          a[12] = g;
          a[13] = k;
          a[14] = h;
        } else {
          a[0] = b[0], a[1] = b[4], a[2] = b[8], a[3] = b[12], a[4] = b[1], a[5] = b[5], a[6] = b[9], a[7] = b[13], a[8] = b[2], a[9] = b[6], a[10] = b[10], a[11] = b[14], a[12] = b[3], a[13] = b[7], a[14] = b[11], a[15] = b[15];
        }
        return a;
      }, invert:function(a, b) {
        var c = b[0], e = b[1], g = b[2], f = b[3], k = b[4], h = b[5], p = b[6], l = b[7], n = b[8], q = b[9], r = b[10], w = b[11], u = b[12], t = b[13], v = b[14];
        b = b[15];
        var y = c * h - e * k, x = c * p - g * k, S = c * l - f * k, V = e * p - g * h, N = e * l - f * h, X = g * l - f * p, ia = n * t - q * u, ta = n * v - r * u, T = n * b - w * u, ra = q * v - r * t, qa = q * b - w * t, pa = r * b - w * v, fa = y * pa - x * qa + S * ra + V * T - N * ta + X * ia;
        return fa ? (fa = 1 / fa, a[0] = (h * pa - p * qa + l * ra) * fa, a[1] = (g * qa - e * pa - f * ra) * fa, a[2] = (t * X - v * N + b * V) * fa, a[3] = (r * N - q * X - w * V) * fa, a[4] = (p * T - k * pa - l * ta) * fa, a[5] = (c * pa - g * T + f * ta) * fa, a[6] = (v * S - u * X - b * x) * fa, a[7] = (n * X - r * S + w * x) * fa, a[8] = (k * qa - h * T + l * ia) * fa, a[9] = (e * T - c * qa - f * ia) * fa, a[10] = (u * N - t * S + b * y) * fa, a[11] = (q * S - n * N - w * y) * fa, a[12] = 
        (h * ta - k * ra - p * ia) * fa, a[13] = (c * ra - e * ta + g * ia) * fa, a[14] = (t * x - u * V - v * y) * fa, a[15] = (n * V - q * x + r * y) * fa, a) : null;
      }, adjoint:function(a, b) {
        var c = b[0], e = b[1], g = b[2], f = b[3], k = b[4], h = b[5], p = b[6], l = b[7], n = b[8], q = b[9], r = b[10], w = b[11], u = b[12], t = b[13], v = b[14];
        b = b[15];
        return a[0] = h * (r * b - w * v) - q * (p * b - l * v) + t * (p * w - l * r), a[1] = -(e * (r * b - w * v) - q * (g * b - f * v) + t * (g * w - f * r)), a[2] = e * (p * b - l * v) - h * (g * b - f * v) + t * (g * l - f * p), a[3] = -(e * (p * w - l * r) - h * (g * w - f * r) + q * (g * l - f * p)), a[4] = -(k * (r * b - w * v) - n * (p * b - l * v) + u * (p * w - l * r)), a[5] = c * (r * b - w * v) - n * (g * b - f * v) + u * (g * w - f * r), a[6] = -(c * (p * b - l * v) - k * (g * b - f * 
        v) + u * (g * l - f * p)), a[7] = c * (p * w - l * r) - k * (g * w - f * r) + n * (g * l - f * p), a[8] = k * (q * b - w * t) - n * (h * b - l * t) + u * (h * w - l * q), a[9] = -(c * (q * b - w * t) - n * (e * b - f * t) + u * (e * w - f * q)), a[10] = c * (h * b - l * t) - k * (e * b - f * t) + u * (e * l - f * h), a[11] = -(c * (h * w - l * q) - k * (e * w - f * q) + n * (e * l - f * h)), a[12] = -(k * (q * v - r * t) - n * (h * v - p * t) + u * (h * r - p * q)), a[13] = c * (q * v - r * 
        t) - n * (e * v - g * t) + u * (e * r - g * q), a[14] = -(c * (h * v - p * t) - k * (e * v - g * t) + u * (e * p - g * h)), a[15] = c * (h * r - p * q) - k * (e * r - g * q) + n * (e * p - g * h), a;
      }, determinant:function(a) {
        var b = a[0], c = a[1], e = a[2], g = a[3], f = a[4], k = a[5], h = a[6], p = a[7], l = a[8], n = a[9], q = a[10], r = a[11], w = a[12], t = a[13], v = a[14];
        a = a[15];
        return (b * k - c * f) * (q * a - r * v) - (b * h - e * f) * (n * a - r * t) + (b * p - g * f) * (n * v - q * t) + (c * h - e * k) * (l * a - r * w) - (c * p - g * k) * (l * v - q * w) + (e * p - g * h) * (l * t - n * w);
      }, multiply:function(a, b, c) {
        var e = b[0], g = b[1], f = b[2], k = b[3], h = b[4], p = b[5], l = b[6], n = b[7], q = b[8], r = b[9], w = b[10], t = b[11], u = b[12], v = b[13], y = b[14];
        b = b[15];
        var x = c[0], B = c[1], V = c[2], N = c[3];
        return a[0] = x * e + B * h + V * q + N * u, a[1] = x * g + B * p + V * r + N * v, a[2] = x * f + B * l + V * w + N * y, a[3] = x * k + B * n + V * t + N * b, x = c[4], B = c[5], V = c[6], N = c[7], a[4] = x * e + B * h + V * q + N * u, a[5] = x * g + B * p + V * r + N * v, a[6] = x * f + B * l + V * w + N * y, a[7] = x * k + B * n + V * t + N * b, x = c[8], B = c[9], V = c[10], N = c[11], a[8] = x * e + B * h + V * q + N * u, a[9] = x * g + B * p + V * r + N * v, a[10] = x * f + B * l + 
        V * w + N * y, a[11] = x * k + B * n + V * t + N * b, x = c[12], B = c[13], V = c[14], N = c[15], a[12] = x * e + B * h + V * q + N * u, a[13] = x * g + B * p + V * r + N * v, a[14] = x * f + B * l + V * w + N * y, a[15] = x * k + B * n + V * t + N * b, a;
      }};
      y.mul = y.multiply;
      y.translate = function(a, b, c) {
        var e, g, f, k, h, p, l, n, q, r, w, t, u = c[0], v = c[1];
        c = c[2];
        return b === a ? (a[12] = b[0] * u + b[4] * v + b[8] * c + b[12], a[13] = b[1] * u + b[5] * v + b[9] * c + b[13], a[14] = b[2] * u + b[6] * v + b[10] * c + b[14], a[15] = b[3] * u + b[7] * v + b[11] * c + b[15]) : (e = b[0], g = b[1], f = b[2], k = b[3], h = b[4], p = b[5], l = b[6], n = b[7], q = b[8], r = b[9], w = b[10], t = b[11], a[0] = e, a[1] = g, a[2] = f, a[3] = k, a[4] = h, a[5] = p, a[6] = l, a[7] = n, a[8] = q, a[9] = r, a[10] = w, a[11] = t, a[12] = e * u + h * v + q * c + b[12], 
        a[13] = g * u + p * v + r * c + b[13], a[14] = f * u + l * v + w * c + b[14], a[15] = k * u + n * v + t * c + b[15]), a;
      };
      y.scale = function(a, b, c) {
        var e = c[0], g = c[1];
        c = c[2];
        return a[0] = b[0] * e, a[1] = b[1] * e, a[2] = b[2] * e, a[3] = b[3] * e, a[4] = b[4] * g, a[5] = b[5] * g, a[6] = b[6] * g, a[7] = b[7] * g, a[8] = b[8] * c, a[9] = b[9] * c, a[10] = b[10] * c, a[11] = b[11] * c, a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15], a;
      };
      y.rotate = function(a, c, e, g) {
        var f, k, h, p, l, n, q, r, w, t, u, v, y, x, B, C, V, N, X, ia, ta, T, ra, qa, pa = g[0], fa = g[1];
        g = g[2];
        var W = Math.sqrt(pa * pa + fa * fa + g * g);
        return Math.abs(W) < b ? null : (W = 1 / W, pa *= W, fa *= W, g *= W, f = Math.sin(e), k = Math.cos(e), h = 1 - k, p = c[0], l = c[1], n = c[2], q = c[3], r = c[4], w = c[5], t = c[6], u = c[7], v = c[8], y = c[9], x = c[10], B = c[11], C = pa * pa * h + k, V = fa * pa * h + g * f, N = g * pa * h - fa * f, X = pa * fa * h - g * f, ia = fa * fa * h + k, ta = g * fa * h + pa * f, T = pa * g * h + fa * f, ra = fa * g * h - pa * f, qa = g * g * h + k, a[0] = p * C + r * V + v * N, a[1] = l * 
        C + w * V + y * N, a[2] = n * C + t * V + x * N, a[3] = q * C + u * V + B * N, a[4] = p * X + r * ia + v * ta, a[5] = l * X + w * ia + y * ta, a[6] = n * X + t * ia + x * ta, a[7] = q * X + u * ia + B * ta, a[8] = p * T + r * ra + v * qa, a[9] = l * T + w * ra + y * qa, a[10] = n * T + t * ra + x * qa, a[11] = q * T + u * ra + B * qa, c !== a && (a[12] = c[12], a[13] = c[13], a[14] = c[14], a[15] = c[15]), a);
      };
      y.rotateX = function(a, b, c) {
        var e = Math.sin(c);
        c = Math.cos(c);
        var g = b[4], f = b[5], k = b[6], h = b[7], p = b[8], l = b[9], n = b[10], q = b[11];
        return b !== a && (a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[4] = g * c + p * e, a[5] = f * c + l * e, a[6] = k * c + n * e, a[7] = h * c + q * e, a[8] = p * c - g * e, a[9] = l * c - f * e, a[10] = n * c - k * e, a[11] = q * c - h * e, a;
      };
      y.rotateY = function(a, b, c) {
        var e = Math.sin(c);
        c = Math.cos(c);
        var g = b[0], f = b[1], k = b[2], h = b[3], p = b[8], l = b[9], n = b[10], q = b[11];
        return b !== a && (a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[0] = g * c - p * e, a[1] = f * c - l * e, a[2] = k * c - n * e, a[3] = h * c - q * e, a[8] = g * e + p * c, a[9] = f * e + l * c, a[10] = k * e + n * c, a[11] = h * e + q * c, a;
      };
      y.rotateZ = function(a, b, c) {
        var e = Math.sin(c);
        c = Math.cos(c);
        var g = b[0], f = b[1], k = b[2], h = b[3], p = b[4], l = b[5], n = b[6], q = b[7];
        return b !== a && (a[8] = b[8], a[9] = b[9], a[10] = b[10], a[11] = b[11], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[0] = g * c + p * e, a[1] = f * c + l * e, a[2] = k * c + n * e, a[3] = h * c + q * e, a[4] = p * c - g * e, a[5] = l * c - f * e, a[6] = n * c - k * e, a[7] = q * c - h * e, a;
      };
      y.fromRotationTranslation = function(a, b, c) {
        var e = b[0], g = b[1], f = b[2], k = b[3], h = e + e, p = g + g, l = f + f;
        b = e * h;
        var n = e * p, e = e * l, q = g * p, g = g * l, f = f * l, h = k * h, p = k * p, k = k * l;
        return a[0] = 1 - (q + f), a[1] = n + k, a[2] = e - p, a[3] = 0, a[4] = n - k, a[5] = 1 - (b + f), a[6] = g + h, a[7] = 0, a[8] = e + p, a[9] = g - h, a[10] = 1 - (b + q), a[11] = 0, a[12] = c[0], a[13] = c[1], a[14] = c[2], a[15] = 1, a;
      };
      y.fromQuat = function(a, b) {
        var c = b[0], e = b[1], g = b[2];
        b = b[3];
        var f = c + c, k = e + e, h = g + g, c = c * f, p = e * f, e = e * k, l = g * f, n = g * k, g = g * h, f = b * f, k = b * k;
        b *= h;
        return a[0] = 1 - e - g, a[1] = p + b, a[2] = l - k, a[3] = 0, a[4] = p - b, a[5] = 1 - c - g, a[6] = n + f, a[7] = 0, a[8] = l + k, a[9] = n - f, a[10] = 1 - c - e, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
      };
      y.frustum = function(a, b, c, e, g, f, k) {
        var h = 1 / (c - b), p = 1 / (g - e), l = 1 / (f - k);
        return a[0] = 2 * f * h, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 * f * p, a[6] = 0, a[7] = 0, a[8] = (c + b) * h, a[9] = (g + e) * p, a[10] = (k + f) * l, a[11] = -1, a[12] = 0, a[13] = 0, a[14] = k * f * 2 * l, a[15] = 0, a;
      };
      y.perspective = function(a, b, c, e, g) {
        b = 1 / Math.tan(b / 2);
        var f = 1 / (e - g);
        return a[0] = b / c, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = b, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = (g + e) * f, a[11] = -1, a[12] = 0, a[13] = 0, a[14] = 2 * g * e * f, a[15] = 0, a;
      };
      y.ortho = function(a, b, c, e, g, f, k) {
        var h = 1 / (b - c), p = 1 / (e - g), l = 1 / (f - k);
        return a[0] = -2 * h, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = -2 * p, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 2 * l, a[11] = 0, a[12] = (b + c) * h, a[13] = (g + e) * p, a[14] = (k + f) * l, a[15] = 1, a;
      };
      y.lookAt = function(a, c, e, g) {
        var f, k, h, p, l, n, r, q, w, t, u = c[0], v = c[1];
        c = c[2];
        var x = g[0], B = g[1];
        g = g[2];
        var C = e[0], S = e[1];
        e = e[2];
        return Math.abs(u - C) < b && Math.abs(v - S) < b && Math.abs(c - e) < b ? y.identity(a) : (r = u - C, q = v - S, w = c - e, t = 1 / Math.sqrt(r * r + q * q + w * w), r *= t, q *= t, w *= t, f = B * w - g * q, k = g * r - x * w, h = x * q - B * r, t = Math.sqrt(f * f + k * k + h * h), t ? (t = 1 / t, f *= t, k *= t, h *= t) : (f = 0, k = 0, h = 0), p = q * h - w * k, l = w * f - r * h, n = r * k - q * f, t = Math.sqrt(p * p + l * l + n * n), t ? (t = 1 / t, p *= t, l *= t, n *= t) : (p = 
        0, l = 0, n = 0), a[0] = f, a[1] = p, a[2] = r, a[3] = 0, a[4] = k, a[5] = l, a[6] = q, a[7] = 0, a[8] = h, a[9] = n, a[10] = w, a[11] = 0, a[12] = -(f * u + k * v + h * c), a[13] = -(p * u + l * v + n * c), a[14] = -(r * u + q * v + w * c), a[15] = 1, a);
      };
      y.str = function(a) {
        return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
      };
      y.frob = function(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
      };
      "undefined" != typeof a && (a.mat4 = y);
      var x = {create:function() {
        var a = new g(4);
        return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a;
      }};
      x.rotationTo = function() {
        var a = l.create(), b = l.fromValues(1, 0, 0), c = l.fromValues(0, 1, 0);
        return function(e, g, f) {
          var k = l.dot(g, f);
          return -.999999 > k ? (l.cross(a, b, g), 1E-6 > l.length(a) && l.cross(a, c, g), l.normalize(a, a), x.setAxisAngle(e, a, Math.PI), e) : .999999 < k ? (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e) : (l.cross(a, g, f), e[0] = a[0], e[1] = a[1], e[2] = a[2], e[3] = 1 + k, x.normalize(e, e));
        };
      }();
      x.setAxes = function() {
        var a = v.create();
        return function(b, c, e, g) {
          return a[0] = e[0], a[3] = e[1], a[6] = e[2], a[1] = g[0], a[4] = g[1], a[7] = g[2], a[2] = -c[0], a[5] = -c[1], a[8] = -c[2], x.normalize(b, x.fromMat3(b, a));
        };
      }();
      x.clone = t.clone;
      x.fromValues = t.fromValues;
      x.copy = t.copy;
      x.set = t.set;
      x.identity = function(a) {
        return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a;
      };
      x.setAxisAngle = function(a, b, c) {
        c *= .5;
        var e = Math.sin(c);
        return a[0] = e * b[0], a[1] = e * b[1], a[2] = e * b[2], a[3] = Math.cos(c), a;
      };
      x.add = t.add;
      x.multiply = function(a, b, c) {
        var e = b[0], g = b[1], f = b[2];
        b = b[3];
        var k = c[0], h = c[1], p = c[2];
        c = c[3];
        return a[0] = e * c + b * k + g * p - f * h, a[1] = g * c + b * h + f * k - e * p, a[2] = f * c + b * p + e * h - g * k, a[3] = b * c - e * k - g * h - f * p, a;
      };
      x.mul = x.multiply;
      x.scale = t.scale;
      x.rotateX = function(a, b, c) {
        c *= .5;
        var e = b[0], g = b[1], f = b[2];
        b = b[3];
        var k = Math.sin(c);
        c = Math.cos(c);
        return a[0] = e * c + b * k, a[1] = g * c + f * k, a[2] = f * c - g * k, a[3] = b * c - e * k, a;
      };
      x.rotateY = function(a, b, c) {
        c *= .5;
        var e = b[0], g = b[1], f = b[2];
        b = b[3];
        var k = Math.sin(c);
        c = Math.cos(c);
        return a[0] = e * c - f * k, a[1] = g * c + b * k, a[2] = f * c + e * k, a[3] = b * c - g * k, a;
      };
      x.rotateZ = function(a, b, c) {
        c *= .5;
        var e = b[0], g = b[1], f = b[2];
        b = b[3];
        var k = Math.sin(c);
        c = Math.cos(c);
        return a[0] = e * c + g * k, a[1] = g * c - e * k, a[2] = f * c + b * k, a[3] = b * c - f * k, a;
      };
      x.calculateW = function(a, b) {
        var c = b[0], e = b[1];
        b = b[2];
        return a[0] = c, a[1] = e, a[2] = b, a[3] = -Math.sqrt(Math.abs(1 - c * c - e * e - b * b)), a;
      };
      x.dot = t.dot;
      x.lerp = t.lerp;
      x.slerp = function(a, b, c, e) {
        var g, f, k, h, p, l = b[0], n = b[1], r = b[2];
        b = b[3];
        var q = c[0], w = c[1], t = c[2];
        c = c[3];
        return f = l * q + n * w + r * t + b * c, 0 > f && (f = -f, q = -q, w = -w, t = -t, c = -c), 1E-6 < 1 - f ? (g = Math.acos(f), k = Math.sin(g), h = Math.sin((1 - e) * g) / k, p = Math.sin(e * g) / k) : (h = 1 - e, p = e), a[0] = h * l + p * q, a[1] = h * n + p * w, a[2] = h * r + p * t, a[3] = h * b + p * c, a;
      };
      x.invert = function(a, b) {
        var c = b[0], e = b[1], g = b[2];
        b = b[3];
        var f = c * c + e * e + g * g + b * b, f = f ? 1 / f : 0;
        return a[0] = -c * f, a[1] = -e * f, a[2] = -g * f, a[3] = b * f, a;
      };
      x.conjugate = function(a, b) {
        return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a[3] = b[3], a;
      };
      x.length = t.length;
      x.len = x.length;
      x.squaredLength = t.squaredLength;
      x.sqrLen = x.squaredLength;
      x.normalize = t.normalize;
      x.fromMat3 = function(a, b) {
        var c;
        c = b[0] + b[4] + b[8];
        if (0 < c) {
          c = Math.sqrt(c + 1), a[3] = .5 * c, c = .5 / c, a[0] = (b[7] - b[5]) * c, a[1] = (b[2] - b[6]) * c, a[2] = (b[3] - b[1]) * c;
        } else {
          var e = 0;
          b[4] > b[0] && (e = 1);
          b[8] > b[3 * e + e] && (e = 2);
          var g = (e + 1) % 3, f = (e + 2) % 3;
          c = Math.sqrt(b[3 * e + e] - b[3 * g + g] - b[3 * f + f] + 1);
          a[e] = .5 * c;
          c = .5 / c;
          a[3] = (b[3 * f + g] - b[3 * g + f]) * c;
          a[g] = (b[3 * g + e] + b[3 * e + g]) * c;
          a[f] = (b[3 * f + e] + b[3 * e + f]) * c;
        }
        return a;
      };
      x.str = function(a) {
        return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
      };
      "undefined" != typeof a && (a.quat = x);
    })(b);
  }(this);
}, {}], 24:[function(a, h, l) {
  (function() {
    var a = this, f = a._, k = {}, c = Array.prototype, g = Object.prototype, e = c.push, p = c.slice, r = c.concat, w = g.toString, n = g.hasOwnProperty, t = c.forEach, v = c.map, y = c.reduce, x = c.reduceRight, q = c.filter, u = c.every, B = c.some, C = c.indexOf, D = c.lastIndexOf, g = Array.isArray, F = Object.keys, E = Function.prototype.bind, z = function(a) {
      return a instanceof z ? a : this instanceof z ? void(this._wrapped = a) : new z(a);
    };
    "undefined" != typeof l ? ("undefined" != typeof h && h.exports && (l = h.exports = z), l._ = z) : a._ = z;
    z.VERSION = "1.4.4";
    var I = z.each = z.forEach = function(a, b, c) {
      if (null != a) {
        if (t && a.forEach === t) {
          a.forEach(b, c);
        } else {
          if (a.length === +a.length) {
            for (var e = 0, g = a.length;g > e && b.call(c, a[e], e, a) !== k;e++) {
            }
          } else {
            for (e in a) {
              if (z.has(a, e) && b.call(c, a[e], e, a) === k) {
                break;
              }
            }
          }
        }
      }
    };
    z.map = z.collect = function(a, b, c) {
      var e = [];
      return null == a ? e : v && a.map === v ? a.map(b, c) : (I(a, function(a, g, f) {
        e[e.length] = b.call(c, a, g, f);
      }), e);
    };
    z.reduce = z.foldl = z.inject = function(a, b, c, e) {
      var g = 2 < arguments.length;
      if (null == a && (a = []), y && a.reduce === y) {
        return e && (b = z.bind(b, e)), g ? a.reduce(b, c) : a.reduce(b);
      }
      if (I(a, function(a, f, k) {
        g ? c = b.call(e, c, a, f, k) : (c = a, g = !0);
      }), !g) {
        throw new TypeError("Reduce of empty array with no initial value");
      }
      return c;
    };
    z.reduceRight = z.foldr = function(a, b, c, e) {
      var g = 2 < arguments.length;
      if (null == a && (a = []), x && a.reduceRight === x) {
        return e && (b = z.bind(b, e)), g ? a.reduceRight(b, c) : a.reduceRight(b);
      }
      var f = a.length;
      if (f !== +f) {
        var k = z.keys(a), f = k.length;
      }
      if (I(a, function(h, p, l) {
        p = k ? k[--f] : --f;
        g ? c = b.call(e, c, a[p], p, l) : (c = a[p], g = !0);
      }), !g) {
        throw new TypeError("Reduce of empty array with no initial value");
      }
      return c;
    };
    z.find = z.detect = function(a, b, c) {
      var e;
      return J(a, function(a, g, f) {
        return b.call(c, a, g, f) ? (e = a, !0) : void 0;
      }), e;
    };
    z.filter = z.select = function(a, b, c) {
      var e = [];
      return null == a ? e : q && a.filter === q ? a.filter(b, c) : (I(a, function(a, g, f) {
        b.call(c, a, g, f) && (e[e.length] = a);
      }), e);
    };
    z.reject = function(a, b, c) {
      return z.filter(a, function(a, e, g) {
        return !b.call(c, a, e, g);
      }, c);
    };
    z.every = z.all = function(a, b, c) {
      b || (b = z.identity);
      var e = !0;
      return null == a ? e : u && a.every === u ? a.every(b, c) : (I(a, function(a, g, f) {
        return (e = e && b.call(c, a, g, f)) ? void 0 : k;
      }), !!e);
    };
    var J = z.some = z.any = function(a, b, c) {
      b || (b = z.identity);
      var e = !1;
      return null == a ? e : B && a.some === B ? a.some(b, c) : (I(a, function(a, g, f) {
        return e || (e = b.call(c, a, g, f)) ? k : void 0;
      }), !!e);
    };
    z.contains = z.include = function(a, b) {
      return null == a ? !1 : C && a.indexOf === C ? -1 != a.indexOf(b) : J(a, function(a) {
        return a === b;
      });
    };
    z.invoke = function(a, b) {
      var c = p.call(arguments, 2), e = z.isFunction(b);
      return z.map(a, function(a) {
        return (e ? b : a[b]).apply(a, c);
      });
    };
    z.pluck = function(a, b) {
      return z.map(a, function(a) {
        return a[b];
      });
    };
    z.where = function(a, b, c) {
      return z.isEmpty(b) ? c ? null : [] : z[c ? "find" : "filter"](a, function(a) {
        for (var c in b) {
          if (b[c] !== a[c]) {
            return !1;
          }
        }
        return !0;
      });
    };
    z.findWhere = function(a, b) {
      return z.where(a, b, !0);
    };
    z.max = function(a, b, c) {
      if (!b && z.isArray(a) && a[0] === +a[0] && 65535 > a.length) {
        return Math.max.apply(Math, a);
      }
      if (!b && z.isEmpty(a)) {
        return -1 / 0;
      }
      var e = {computed:-1 / 0, value:-1 / 0};
      return I(a, function(a, g, f) {
        g = b ? b.call(c, a, g, f) : a;
        g >= e.computed && (e = {value:a, computed:g});
      }), e.value;
    };
    z.min = function(a, b, c) {
      if (!b && z.isArray(a) && a[0] === +a[0] && 65535 > a.length) {
        return Math.min.apply(Math, a);
      }
      if (!b && z.isEmpty(a)) {
        return 1 / 0;
      }
      var e = {computed:1 / 0, value:1 / 0};
      return I(a, function(a, g, f) {
        g = b ? b.call(c, a, g, f) : a;
        g < e.computed && (e = {value:a, computed:g});
      }), e.value;
    };
    z.shuffle = function(a) {
      var b, c = 0, e = [];
      return I(a, function(a) {
        b = z.random(c++);
        e[c - 1] = e[b];
        e[b] = a;
      }), e;
    };
    var R = function(a) {
      return z.isFunction(a) ? a : function(b) {
        return b[a];
      };
    };
    z.sortBy = function(a, b, c) {
      var e = R(b);
      return z.pluck(z.map(a, function(a, b, g) {
        return {value:a, index:b, criteria:e.call(c, a, b, g)};
      }).sort(function(a, b) {
        var c = a.criteria, e = b.criteria;
        if (c !== e) {
          if (c > e || void 0 === c) {
            return 1;
          }
          if (e > c || void 0 === e) {
            return -1;
          }
        }
        return a.index < b.index ? -1 : 1;
      }), "value");
    };
    var L = function(a, b, c, e) {
      var g = {}, f = R(b || z.identity);
      return I(a, function(b, k) {
        k = f.call(c, b, k, a);
        e(g, k, b);
      }), g;
    };
    z.groupBy = function(a, b, c) {
      return L(a, b, c, function(a, b, c) {
        (z.has(a, b) ? a[b] : a[b] = []).push(c);
      });
    };
    z.countBy = function(a, b, c) {
      return L(a, b, c, function(a, b) {
        z.has(a, b) || (a[b] = 0);
        a[b]++;
      });
    };
    z.sortedIndex = function(a, b, c, e) {
      c = null == c ? z.identity : R(c);
      b = c.call(e, b);
      for (var g = 0, f = a.length;f > g;) {
        var k = g + f >>> 1;
        c.call(e, a[k]) < b ? g = k + 1 : f = k;
      }
      return g;
    };
    z.toArray = function(a) {
      return a ? z.isArray(a) ? p.call(a) : a.length === +a.length ? z.map(a, z.identity) : z.values(a) : [];
    };
    z.size = function(a) {
      return null == a ? 0 : a.length === +a.length ? a.length : z.keys(a).length;
    };
    z.first = z.head = z.take = function(a, b, c) {
      return null == a ? void 0 : null == b || c ? a[0] : p.call(a, 0, b);
    };
    z.initial = function(a, b, c) {
      return p.call(a, 0, a.length - (null == b || c ? 1 : b));
    };
    z.last = function(a, b, c) {
      return null == a ? void 0 : null == b || c ? a[a.length - 1] : p.call(a, Math.max(a.length - b, 0));
    };
    z.rest = z.tail = z.drop = function(a, b, c) {
      return p.call(a, null == b || c ? 1 : b);
    };
    z.compact = function(a) {
      return z.filter(a, z.identity);
    };
    var M = function(a, b, c) {
      return I(a, function(a) {
        z.isArray(a) ? b ? e.apply(c, a) : M(a, b, c) : c.push(a);
      }), c;
    };
    z.flatten = function(a, b) {
      return M(a, b, []);
    };
    z.without = function(a) {
      return z.difference(a, p.call(arguments, 1));
    };
    z.uniq = z.unique = function(a, b, c, e) {
      z.isFunction(b) && (e = c, c = b, b = !1);
      c = c ? z.map(a, c, e) : a;
      var g = [], f = [];
      return I(c, function(c, e) {
        (b ? e && f[f.length - 1] === c : z.contains(f, c)) || (f.push(c), g.push(a[e]));
      }), g;
    };
    z.union = function() {
      return z.uniq(r.apply(c, arguments));
    };
    z.intersection = function(a) {
      var b = p.call(arguments, 1);
      return z.filter(z.uniq(a), function(a) {
        return z.every(b, function(b) {
          return 0 <= z.indexOf(b, a);
        });
      });
    };
    z.difference = function(a) {
      var b = r.apply(c, p.call(arguments, 1));
      return z.filter(a, function(a) {
        return !z.contains(b, a);
      });
    };
    z.zip = function() {
      for (var a = p.call(arguments), b = z.max(z.pluck(a, "length")), c = Array(b), e = 0;b > e;e++) {
        c[e] = z.pluck(a, "" + e);
      }
      return c;
    };
    z.object = function(a, b) {
      if (null == a) {
        return {};
      }
      for (var c = {}, e = 0, g = a.length;g > e;e++) {
        b ? c[a[e]] = b[e] : c[a[e][0]] = a[e][1];
      }
      return c;
    };
    z.indexOf = function(a, b, c) {
      if (null == a) {
        return -1;
      }
      var e = 0, g = a.length;
      if (c) {
        if ("number" != typeof c) {
          return e = z.sortedIndex(a, b), a[e] === b ? e : -1;
        }
        e = 0 > c ? Math.max(0, g + c) : c;
      }
      if (C && a.indexOf === C) {
        return a.indexOf(b, c);
      }
      for (;g > e;e++) {
        if (a[e] === b) {
          return e;
        }
      }
      return -1;
    };
    z.lastIndexOf = function(a, b, c) {
      if (null == a) {
        return -1;
      }
      var e = null != c;
      if (D && a.lastIndexOf === D) {
        return e ? a.lastIndexOf(b, c) : a.lastIndexOf(b);
      }
      for (c = e ? c : a.length;c--;) {
        if (a[c] === b) {
          return c;
        }
      }
      return -1;
    };
    z.range = function(a, b, c) {
      1 >= arguments.length && (b = a || 0, a = 0);
      c = arguments[2] || 1;
      for (var e = Math.max(Math.ceil((b - a) / c), 0), g = 0, f = Array(e);e > g;) {
        f[g++] = a, a += c;
      }
      return f;
    };
    z.bind = function(a, b) {
      if (a.bind === E && E) {
        return E.apply(a, p.call(arguments, 1));
      }
      var c = p.call(arguments, 2);
      return function() {
        return a.apply(b, c.concat(p.call(arguments)));
      };
    };
    z.partial = function(a) {
      var b = p.call(arguments, 1);
      return function() {
        return a.apply(this, b.concat(p.call(arguments)));
      };
    };
    z.bindAll = function(a) {
      var b = p.call(arguments, 1);
      return 0 === b.length && (b = z.functions(a)), I(b, function(b) {
        a[b] = z.bind(a[b], a);
      }), a;
    };
    z.memoize = function(a, b) {
      var c = {};
      return b || (b = z.identity), function() {
        var e = b.apply(this, arguments);
        return z.has(c, e) ? c[e] : c[e] = a.apply(this, arguments);
      };
    };
    z.delay = function(a, b) {
      var c = p.call(arguments, 2);
      return setTimeout(function() {
        return a.apply(null, c);
      }, b);
    };
    z.defer = function(a) {
      return z.delay.apply(z, [a, 1].concat(p.call(arguments, 1)));
    };
    z.throttle = function(a, b) {
      var c, e, g, f, k = 0, h = function() {
        k = new Date;
        g = null;
        f = a.apply(c, e);
      };
      return function() {
        var p = new Date, l = b - (p - k);
        return c = this, e = arguments, 0 >= l ? (clearTimeout(g), g = null, k = p, f = a.apply(c, e)) : g || (g = setTimeout(h, l)), f;
      };
    };
    z.debounce = function(a, b, c) {
      var e, g;
      return function() {
        var f = this, k = arguments, h = c && !e;
        return clearTimeout(e), e = setTimeout(function() {
          e = null;
          c || (g = a.apply(f, k));
        }, b), h && (g = a.apply(f, k)), g;
      };
    };
    z.once = function(a) {
      var b, c = !1;
      return function() {
        return c ? b : (c = !0, b = a.apply(this, arguments), a = null, b);
      };
    };
    z.wrap = function(a, b) {
      return function() {
        var c = [a];
        return e.apply(c, arguments), b.apply(this, c);
      };
    };
    z.compose = function() {
      var a = arguments;
      return function() {
        for (var b = arguments, c = a.length - 1;0 <= c;c--) {
          b = [a[c].apply(this, b)];
        }
        return b[0];
      };
    };
    z.after = function(a, b) {
      return 0 >= a ? b() : function() {
        return 1 > --a ? b.apply(this, arguments) : void 0;
      };
    };
    z.keys = F || function(a) {
      if (a !== Object(a)) {
        throw new TypeError("Invalid object");
      }
      var b = [], c;
      for (c in a) {
        z.has(a, c) && (b[b.length] = c);
      }
      return b;
    };
    z.values = function(a) {
      var b = [], c;
      for (c in a) {
        z.has(a, c) && b.push(a[c]);
      }
      return b;
    };
    z.pairs = function(a) {
      var b = [], c;
      for (c in a) {
        z.has(a, c) && b.push([c, a[c]]);
      }
      return b;
    };
    z.invert = function(a) {
      var b = {}, c;
      for (c in a) {
        z.has(a, c) && (b[a[c]] = c);
      }
      return b;
    };
    z.functions = z.methods = function(a) {
      var b = [], c;
      for (c in a) {
        z.isFunction(a[c]) && b.push(c);
      }
      return b.sort();
    };
    z.extend = function(a) {
      return I(p.call(arguments, 1), function(b) {
        if (b) {
          for (var c in b) {
            a[c] = b[c];
          }
        }
      }), a;
    };
    z.pick = function(a) {
      var b = {}, e = r.apply(c, p.call(arguments, 1));
      return I(e, function(c) {
        c in a && (b[c] = a[c]);
      }), b;
    };
    z.omit = function(a) {
      var b = {}, e = r.apply(c, p.call(arguments, 1)), g;
      for (g in a) {
        z.contains(e, g) || (b[g] = a[g]);
      }
      return b;
    };
    z.defaults = function(a) {
      return I(p.call(arguments, 1), function(b) {
        if (b) {
          for (var c in b) {
            null == a[c] && (a[c] = b[c]);
          }
        }
      }), a;
    };
    z.clone = function(a) {
      return z.isObject(a) ? z.isArray(a) ? a.slice() : z.extend({}, a) : a;
    };
    z.tap = function(a, b) {
      return b(a), a;
    };
    var P = function(a, b, c, e) {
      if (a === b) {
        return 0 !== a || 1 / a == 1 / b;
      }
      if (null == a || null == b) {
        return a === b;
      }
      a instanceof z && (a = a._wrapped);
      b instanceof z && (b = b._wrapped);
      var g = w.call(a);
      if (g != w.call(b)) {
        return !1;
      }
      switch(g) {
        case "[object String]":
          return a == String(b);
        case "[object Number]":
          return a != +a ? b != +b : 0 == a ? 1 / a == 1 / b : a == +b;
        case "[object Date]":
        case "[object Boolean]":
          return +a == +b;
        case "[object RegExp]":
          return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
      }
      if ("object" != typeof a || "object" != typeof b) {
        return !1;
      }
      for (var f = c.length;f--;) {
        if (c[f] == a) {
          return e[f] == b;
        }
      }
      c.push(a);
      e.push(b);
      var f = 0, k = !0;
      if ("[object Array]" == g) {
        if (f = a.length, k = f == b.length) {
          for (;f-- && (k = P(a[f], b[f], c, e));) {
          }
        }
      } else {
        var g = a.constructor, h = b.constructor;
        if (g !== h && !(z.isFunction(g) && g instanceof g && z.isFunction(h) && h instanceof h)) {
          return !1;
        }
        for (var p in a) {
          if (z.has(a, p) && (f++, !(k = z.has(b, p) && P(a[p], b[p], c, e)))) {
            break;
          }
        }
        if (k) {
          for (p in b) {
            if (z.has(b, p) && !f--) {
              break;
            }
          }
          k = !f;
        }
      }
      return c.pop(), e.pop(), k;
    };
    z.isEqual = function(a, b) {
      return P(a, b, [], []);
    };
    z.isEmpty = function(a) {
      if (null == a) {
        return !0;
      }
      if (z.isArray(a) || z.isString(a)) {
        return 0 === a.length;
      }
      for (var b in a) {
        if (z.has(a, b)) {
          return !1;
        }
      }
      return !0;
    };
    z.isElement = function(a) {
      return !(!a || 1 !== a.nodeType);
    };
    z.isArray = g || function(a) {
      return "[object Array]" == w.call(a);
    };
    z.isObject = function(a) {
      return a === Object(a);
    };
    I("Arguments Function String Number Date RegExp".split(" "), function(a) {
      z["is" + a] = function(b) {
        return w.call(b) == "[object " + a + "]";
      };
    });
    z.isArguments(arguments) || (z.isArguments = function(a) {
      return !(!a || !z.has(a, "callee"));
    });
    "function" != typeof/./ && (z.isFunction = function(a) {
      return "function" == typeof a;
    });
    z.isFinite = function(a) {
      return isFinite(a) && !isNaN(parseFloat(a));
    };
    z.isNaN = function(a) {
      return z.isNumber(a) && a != +a;
    };
    z.isBoolean = function(a) {
      return !0 === a || !1 === a || "[object Boolean]" == w.call(a);
    };
    z.isNull = function(a) {
      return null === a;
    };
    z.isUndefined = function(a) {
      return void 0 === a;
    };
    z.has = function(a, b) {
      return n.call(a, b);
    };
    z.noConflict = function() {
      return a._ = f, this;
    };
    z.identity = function(a) {
      return a;
    };
    z.times = function(a, b, c) {
      for (var e = Array(a), g = 0;a > g;g++) {
        e[g] = b.call(c, g);
      }
      return e;
    };
    z.random = function(a, b) {
      return null == b && (b = a, a = 0), a + Math.floor(Math.random() * (b - a + 1));
    };
    var H = {escape:{"&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#x27;", "/":"&#x2F;"}};
    H.unescape = z.invert(H.escape);
    var ba = {escape:new RegExp("[" + z.keys(H.escape).join("") + "]", "g"), unescape:new RegExp("(" + z.keys(H.unescape).join("|") + ")", "g")};
    z.each(["escape", "unescape"], function(a) {
      z[a] = function(b) {
        return null == b ? "" : ("" + b).replace(ba[a], function(b) {
          return H[a][b];
        });
      };
    });
    z.result = function(a, b) {
      if (null == a) {
        return null;
      }
      b = a[b];
      return z.isFunction(b) ? b.call(a) : b;
    };
    z.mixin = function(a) {
      I(z.functions(a), function(b) {
        var c = z[b] = a[b];
        z.prototype[b] = function() {
          var a = [this._wrapped];
          return e.apply(a, arguments), V.call(this, c.apply(z, a));
        };
      });
    };
    var ha = 0;
    z.uniqueId = function(a) {
      var b = ++ha + "";
      return a ? a + b : b;
    };
    z.templateSettings = {evaluate:/<%([\s\S]+?)%>/g, interpolate:/<%=([\s\S]+?)%>/g, escape:/<%-([\s\S]+?)%>/g};
    var Z = /(.)^/, ea = {"'":"'", "\\":"\\", "\r":"r", "\n":"n", "\t":"t", "\u2028":"u2028", "\u2029":"u2029"}, S = /\\|'|\r|\n|\t|\u2028|\u2029/g;
    z.template = function(a, b, c) {
      var e;
      c = z.defaults({}, c, z.templateSettings);
      var g = new RegExp([(c.escape || Z).source, (c.interpolate || Z).source, (c.evaluate || Z).source].join("|") + "|$", "g"), f = 0, k = "__p+='";
      a.replace(g, function(b, c, e, g, h) {
        return k += a.slice(f, h).replace(S, function(a) {
          return "\\" + ea[a];
        }), c && (k += "'+\n((__t=(" + c + "))==null?'':_.escape(__t))+\n'"), e && (k += "'+\n((__t=(" + e + "))==null?'':__t)+\n'"), g && (k += "';\n" + g + "\n__p+='"), f = h + b.length, b;
      });
      k += "';\n";
      c.variable || (k = "with(obj||{}){\n" + k + "}\n");
      k = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + k + "return __p;\n";
      try {
        e = new Function(c.variable || "obj", "_", k);
      } catch (pa) {
        throw pa.source = k, pa;
      }
      if (b) {
        return e(b, z);
      }
      b = function(a) {
        return e.call(this, a, z);
      };
      return b.source = "function(" + (c.variable || "obj") + "){\n" + k + "}", b;
    };
    z.chain = function(a) {
      return z(a).chain();
    };
    var V = function(a) {
      return this._chain ? z(a).chain() : a;
    };
    z.mixin(z);
    I("pop push reverse shift sort splice unshift".split(" "), function(a) {
      var b = c[a];
      z.prototype[a] = function() {
        var c = this._wrapped;
        return b.apply(c, arguments), "shift" != a && "splice" != a || 0 !== c.length || delete c[0], V.call(this, c);
      };
    });
    I(["concat", "join", "slice"], function(a) {
      var b = c[a];
      z.prototype[a] = function() {
        return V.call(this, b.apply(this._wrapped, arguments));
      };
    });
    z.extend(z.prototype, {chain:function() {
      return this._chain = !0, this;
    }, value:function() {
      return this._wrapped;
    }});
  }).call(this);
}, {}], 25:[function(a) {
  "undefined" != typeof window && "function" != typeof window.requestAnimationFrame && (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a) {
    setTimeout(a, 1E3 / 60);
  });
  Leap = a("../lib/index");
}, {"../lib/index":11}]}, {}, [25]);
var Stats = function() {
  function a(a) {
    b.appendChild(a.dom);
    return a;
  }
  function h(a) {
    for (var c = 0;c < b.children.length;c++) {
      b.children[c].style.display = c === a ? "block" : "none";
    }
    l = a;
  }
  var l = 0, b = document.createElement("div");
  b.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";
  b.addEventListener("click", function(a) {
    a.preventDefault();
    h(++l % b.children.length);
  }, !1);
  var f = (performance || Date).now(), k = f, c = 0, g = a(new Stats.Panel("FPS", "#fff", "#222")), e = a(new Stats.Panel("MS", "#fff", "#222"));
  if (self.performance && self.performance.memory) {
    var p = a(new Stats.Panel("MB", "#fff", "#222"));
  }
  h(0);
  return {REVISION:17, dom:b, addPanel:a, showPanel:h, begin:function() {
    f = (performance || Date).now();
  }, end:function() {
    c++;
    var a = (performance || Date).now();
    e.update(a - f, 200);
    if (a > k + 1E3 && (g.update(1E3 * c / (a - k), 100), k = a, c = 0, p)) {
      var b = performance.memory;
      p.update(b.usedJSHeapSize / 1048576, b.jsHeapSizeLimit / 1048576);
    }
    return a;
  }, update:function() {
    f = this.end();
  }, domElement:b, setMode:h};
};
Stats.Panel = function(a, h, l) {
  var b = Infinity, f = 0, k = Math.round, c = k(window.devicePixelRatio || 1), g = 80 * c, e = 48 * c, p = 3 * c, r = 2 * c, w = 3 * c, n = 15 * c, t = 74 * c, v = 30 * c, y = document.createElement("canvas");
  y.width = g;
  y.height = e;
  y.style.cssText = "width:80px;height:48px";
  var x = y.getContext("2d");
  x.font = "bold " + 9 * c + "px Helvetica,Arial,sans-serif";
  x.textBaseline = "top";
  x.fillStyle = l;
  x.fillRect(0, 0, g, e);
  x.fillStyle = h;
  x.fillText(a, p, r);
  x.fillRect(w, n, t, v);
  x.fillStyle = l;
  x.globalAlpha = .9;
  x.fillRect(w, n, t, v);
  return {dom:y, update:function(e, u) {
    b = Math.min(b, e);
    f = Math.max(f, e);
    x.fillStyle = l;
    x.globalAlpha = 1;
    x.fillRect(0, 0, g, n);
    x.fillStyle = h;
    x.fillText(k(e) + " " + a + " (" + k(b) + "-" + k(f) + ")", p, r);
    x.drawImage(y, w + c, n, t - c, v, w, n, t - c, v);
    x.fillRect(w + t - c, n, c, v);
    x.fillStyle = l;
    x.globalAlpha = .9;
    x.fillRect(w + t - c, n, c, k((1 - e / u) * v));
  }};
};
"object" === typeof module && (module.exports = Stats);
var SPE = {distributions:{BOX:1, SPHERE:2, DISC:3}, valueOverLifetimeLength:4};
"function" == typeof define && define.amd ? define("spe", SPE) : "undefined" != typeof exports && "undefined" != typeof module && (module.exports = SPE);
SPE.TypedArrayHelper = function(a, h, l, b) {
  this.componentSize = l || 1;
  this.size = h || 1;
  this.TypedArrayConstructor = a || Float32Array;
  this.array = new a(h * this.componentSize);
  this.indexOffset = b || 0;
};
SPE.TypedArrayHelper.constructor = SPE.TypedArrayHelper;
SPE.TypedArrayHelper.prototype.setSize = function(a, h) {
  var l = this.array.length;
  return h || (a *= this.componentSize), l > a ? this.shrink(a) : a > l ? this.grow(a) : void console.info("TypedArray is already of size:", a + ".", "Will not resize.");
};
SPE.TypedArrayHelper.prototype.shrink = function(a) {
  return this.array = this.array.subarray(0, a), this.size = a, this;
};
SPE.TypedArrayHelper.prototype.grow = function(a) {
  var h = this.array, l = new this.TypedArrayConstructor(a);
  return l.set(h), this.array = l, this.size = a, this;
};
SPE.TypedArrayHelper.prototype.splice = function(a, h) {
  a *= this.componentSize;
  h *= this.componentSize;
  for (var l = [], b = this.array, f = b.length, k = 0;f > k;++k) {
    (a > k || k >= h) && l.push(b[k]);
  }
  return this.setFromArray(0, l), this;
};
SPE.TypedArrayHelper.prototype.setFromArray = function(a, h) {
  var l = a + h.length;
  return l > this.array.length ? this.grow(l) : l < this.array.length && this.shrink(l), this.array.set(h, this.indexOffset + a), this;
};
SPE.TypedArrayHelper.prototype.setVec2 = function(a, h) {
  return this.setVec2Components(a, h.x, h.y);
};
SPE.TypedArrayHelper.prototype.setVec2Components = function(a, h, l) {
  var b = this.array;
  a = this.indexOffset + a * this.componentSize;
  return b[a] = h, b[a + 1] = l, this;
};
SPE.TypedArrayHelper.prototype.setVec3 = function(a, h) {
  return this.setVec3Components(a, h.x, h.y, h.z);
};
SPE.TypedArrayHelper.prototype.setVec3Components = function(a, h, l, b) {
  var f = this.array;
  a = this.indexOffset + a * this.componentSize;
  return f[a] = h, f[a + 1] = l, f[a + 2] = b, this;
};
SPE.TypedArrayHelper.prototype.setVec4 = function(a, h) {
  return this.setVec4Components(a, h.x, h.y, h.z, h.w);
};
SPE.TypedArrayHelper.prototype.setVec4Components = function(a, h, l, b, f) {
  var k = this.array;
  a = this.indexOffset + a * this.componentSize;
  return k[a] = h, k[a + 1] = l, k[a + 2] = b, k[a + 3] = f, this;
};
SPE.TypedArrayHelper.prototype.setMat3 = function(a, h) {
  return this.setFromArray(this.indexOffset + a * this.componentSize, h.elements);
};
SPE.TypedArrayHelper.prototype.setMat4 = function(a, h) {
  return this.setFromArray(this.indexOffset + a * this.componentSize, h.elements);
};
SPE.TypedArrayHelper.prototype.setColor = function(a, h) {
  return this.setVec3Components(a, h.r, h.g, h.b);
};
SPE.TypedArrayHelper.prototype.setNumber = function(a, h) {
  return this.array[this.indexOffset + a * this.componentSize] = h, this;
};
SPE.TypedArrayHelper.prototype.getValueAtIndex = function(a) {
  return this.array[this.indexOffset + a];
};
SPE.TypedArrayHelper.prototype.getComponentValueAtIndex = function(a) {
  return this.array.subarray(this.indexOffset + a * this.componentSize);
};
SPE.ShaderAttribute = function(a, h, l) {
  var b = SPE.ShaderAttribute.typeSizeMap;
  this.type = "string" == typeof a && b.hasOwnProperty(a) ? a : "f";
  this.componentSize = b[this.type];
  this.arrayType = l || Float32Array;
  this.bufferAttribute = this.typedArray = null;
  this.dynamicBuffer = !!h;
  this.updateMax = this.updateMin = 0;
};
SPE.ShaderAttribute.constructor = SPE.ShaderAttribute;
SPE.ShaderAttribute.typeSizeMap = {f:1, v2:2, v3:3, v4:4, c:3, m3:9, m4:16};
SPE.ShaderAttribute.prototype.setUpdateRange = function(a, h) {
  this.updateMin = Math.min(a * this.componentSize, this.updateMin * this.componentSize);
  this.updateMax = Math.max(h * this.componentSize, this.updateMax * this.componentSize);
};
SPE.ShaderAttribute.prototype.flagUpdate = function() {
  var a = this.bufferAttribute, h = a.updateRange;
  h.offset = this.updateMin;
  h.count = Math.min(this.updateMax - this.updateMin + this.componentSize, this.typedArray.array.length);
  a.needsUpdate = !0;
};
SPE.ShaderAttribute.prototype.resetUpdateRange = function() {
  this.updateMax = this.updateMin = 0;
};
SPE.ShaderAttribute.prototype.resetDynamic = function() {
  this.bufferAttribute.dynamic = this.dynamicBuffer;
};
SPE.ShaderAttribute.prototype.splice = function(a, h) {
  this.typedArray.splice(a, h);
  this.forceUpdateAll();
};
SPE.ShaderAttribute.prototype.forceUpdateAll = function() {
  this.bufferAttribute.array = this.typedArray.array;
  this.bufferAttribute.updateRange.offset = 0;
  this.bufferAttribute.updateRange.count = -1;
  this.bufferAttribute.dynamic = !1;
  this.bufferAttribute.needsUpdate = !0;
};
SPE.ShaderAttribute.prototype._ensureTypedArray = function(a) {
  null !== this.typedArray && this.typedArray.size === a * this.componentSize || (null !== this.typedArray && this.typedArray.size !== a ? this.typedArray.setSize(a) : null === this.typedArray && (this.typedArray = new SPE.TypedArrayHelper(this.arrayType, a, this.componentSize)));
};
SPE.ShaderAttribute.prototype._createBufferAttribute = function(a) {
  return this._ensureTypedArray(a), null !== this.bufferAttribute ? (this.bufferAttribute.array = this.typedArray.array, 81 <= parseFloat(THREE.REVISION) && (this.bufferAttribute.count = this.bufferAttribute.array.length / this.bufferAttribute.itemSize), void(this.bufferAttribute.needsUpdate = !0)) : (this.bufferAttribute = new THREE.BufferAttribute(this.typedArray.array, this.componentSize), void(this.bufferAttribute.dynamic = this.dynamicBuffer));
};
SPE.ShaderAttribute.prototype.getLength = function() {
  return null === this.typedArray ? 0 : this.typedArray.array.length;
};
SPE.shaderChunks = {defines:"#define PACKED_COLOR_SIZE 256.0\n#define PACKED_COLOR_DIVISOR 255.0", uniforms:"uniform float deltaTime;\nuniform float runTime;\nuniform sampler2D texture;\nuniform vec4 textureAnimation;\nuniform float scale;", attributes:"attribute vec4 acceleration;\nattribute vec3 velocity;\nattribute vec4 rotation;\nattribute vec3 rotationCenter;\nattribute vec4 params;\nattribute vec4 size;\nattribute vec4 angle;\nattribute vec4 color;\nattribute vec4 opacity;", varyings:"varying vec4 vColor;\n#ifdef SHOULD_ROTATE_TEXTURE\n    varying float vAngle;\n#endif\n#ifdef SHOULD_CALCULATE_SPRITE\n    varying vec4 vSpriteSheet;\n#endif", 
branchAvoidanceFunctions:"float when_gt(float x, float y) {\n    return max(sign(x - y), 0.0);\n}\nfloat when_lt(float x, float y) {\n    return min( max(1.0 - sign(x - y), 0.0), 1.0 );\n}\nfloat when_eq( float x, float y ) {\n    return 1.0 - abs( sign( x - y ) );\n}\nfloat when_ge(float x, float y) {\n  return 1.0 - when_lt(x, y);\n}\nfloat when_le(float x, float y) {\n  return 1.0 - when_gt(x, y);\n}\nfloat and(float a, float b) {\n    return a * b;\n}\nfloat or(float a, float b) {\n    return min(a + b, 1.0);\n}", 
unpackColor:"vec3 unpackColor( in float hex ) {\n   vec3 c = vec3( 0.0 );\n   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );\n   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );\n   float b = mod( hex, PACKED_COLOR_SIZE );\n   c.r = r / PACKED_COLOR_DIVISOR;\n   c.g = g / PACKED_COLOR_DIVISOR;\n   c.b = b / PACKED_COLOR_DIVISOR;\n   return c;\n}", unpackRotationAxis:"vec3 unpackRotationAxis( in float hex ) {\n   vec3 c = vec3( 0.0 );\n   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );\n   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );\n   float b = mod( hex, PACKED_COLOR_SIZE );\n   c.r = r / PACKED_COLOR_DIVISOR;\n   c.g = g / PACKED_COLOR_DIVISOR;\n   c.b = b / PACKED_COLOR_DIVISOR;\n   c *= vec3( 2.0 );\n   c -= vec3( 1.0 );\n   return c;\n}", 
floatOverLifetime:"float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {\n    highp float value = 0.0;\n    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );\n    float fIndex = 0.0;\n    float shouldApplyValue = 0.0;\n    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );\n\n    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {\n       fIndex = float( i );\n       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );\n       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );\n    }\n\n    return value;\n}", 
colorOverLifetime:"vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {\n    vec3 value = vec3( 0.0 );\n    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );\n    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );\n    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );\n    return value;\n}", 
paramFetchingFunctions:"float getAlive() {\n   return params.x;\n}\nfloat getAge() {\n   return params.y;\n}\nfloat getMaxAge() {\n   return params.z;\n}\nfloat getWiggle() {\n   return params.w;\n}", forceFetchingFunctions:"vec4 getPosition( in float age ) {\n   return modelViewMatrix * vec4( position, 1.0 );\n}\nvec3 getVelocity( in float age ) {\n   return velocity * age;\n}\nvec3 getAcceleration( in float age ) {\n   return acceleration.xyz * age;\n}", rotationFunctions:"#ifdef SHOULD_ROTATE_PARTICLES\n   mat4 getRotationMatrix( in vec3 axis, in float angle) {\n       axis = normalize(axis);\n       float s = sin(angle);\n       float c = cos(angle);\n       float oc = 1.0 - c;\n\n       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                   0.0,                                0.0,                                0.0,                                1.0);\n   }\n\n   vec3 getRotation( in vec3 pos, in float positionInTime ) {\n      if( rotation.y == 0.0 ) {\n           return pos;\n      }\n\n      vec3 axis = unpackRotationAxis( rotation.x );\n      vec3 center = rotationCenter;\n      vec3 translated;\n      mat4 rotationMatrix;\n      float angle = 0.0;\n      angle += when_eq( rotation.z, 0.0 ) * rotation.y;\n      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );\n      translated = rotationCenter - pos;\n      rotationMatrix = getRotationMatrix( axis, angle );\n      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );\n   }\n#endif", 
rotateTexture:"    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );\n\n    #ifdef SHOULD_ROTATE_TEXTURE\n       float x = gl_PointCoord.x - 0.5;\n       float y = 1.0 - gl_PointCoord.y - 0.5;\n       float c = cos( -vAngle );\n       float s = sin( -vAngle );\n       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );\n    #endif\n\n    #ifdef SHOULD_CALCULATE_SPRITE\n        float framesX = vSpriteSheet.x;\n        float framesY = vSpriteSheet.y;\n        float columnNorm = vSpriteSheet.z;\n        float rowNorm = vSpriteSheet.w;\n        vUv.x = gl_PointCoord.x * framesX + columnNorm;\n        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);\n    #endif\n\n    vec4 rotatedTexture = texture2D( texture, vUv );"};
SPE.shaders = {vertex:[SPE.shaderChunks.defines, SPE.shaderChunks.uniforms, SPE.shaderChunks.attributes, SPE.shaderChunks.varyings, THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, THREE.ShaderChunk.fog_pars_vertex, SPE.shaderChunks.branchAvoidanceFunctions, SPE.shaderChunks.unpackColor, SPE.shaderChunks.unpackRotationAxis, SPE.shaderChunks.floatOverLifetime, SPE.shaderChunks.colorOverLifetime, SPE.shaderChunks.paramFetchingFunctions, SPE.shaderChunks.forceFetchingFunctions, SPE.shaderChunks.rotationFunctions, 
"void main() {\n    highp float age = getAge();\n    highp float alive = getAlive();\n    highp float maxAge = getMaxAge();\n    highp float positionInTime = (age / maxAge);\n    highp float isAlive = when_gt( alive, 0.0 );\n    #ifdef SHOULD_WIGGLE_PARTICLES\n        float wiggleAmount = positionInTime * getWiggle();\n        float wiggleSin = isAlive * sin( wiggleAmount );\n        float wiggleCos = isAlive * cos( wiggleAmount );\n    #endif\n    vec3 vel = getVelocity( age );\n    vec3 accel = getAcceleration( age );\n    vec3 force = vec3( 0.0 );\n    vec3 pos = vec3( position );\n    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;\n    force += vel;\n    force *= drag;\n    force += accel * age;\n    pos += force;\n    #ifdef SHOULD_WIGGLE_PARTICLES\n        pos.x += wiggleSin;\n        pos.y += wiggleCos;\n        pos.z += wiggleSin;\n    #endif\n    #ifdef SHOULD_ROTATE_PARTICLES\n        pos = getRotation( pos, positionInTime );\n    #endif\n    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );\n    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;\n    #ifdef HAS_PERSPECTIVE\n        float perspective = scale / length( mvPosition.xyz );\n    #else\n        float perspective = 1.0;\n    #endif\n    float pointSizePerspective = pointSize * perspective;\n    #ifdef COLORIZE\n       vec3 c = isAlive * getColorOverLifetime(\n           positionInTime,\n           unpackColor( color.x ),\n           unpackColor( color.y ),\n           unpackColor( color.z ),\n           unpackColor( color.w )\n       );\n    #else\n       vec3 c = vec3(1.0);\n    #endif\n    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );\n    vColor = vec4( c, o );\n    #ifdef SHOULD_ROTATE_TEXTURE\n        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );\n    #endif\n    #ifdef SHOULD_CALCULATE_SPRITE\n        float framesX = textureAnimation.x;\n        float framesY = textureAnimation.y;\n        float loopCount = textureAnimation.w;\n        float totalFrames = textureAnimation.z;\n        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );\n        float column = floor(mod( frameNumber, framesX ));\n        float row = floor( (frameNumber - column) / framesX );\n        float columnNorm = column / framesX;\n        float rowNorm = row / framesY;\n        vSpriteSheet.x = 1.0 / framesX;\n        vSpriteSheet.y = 1.0 / framesY;\n        vSpriteSheet.z = columnNorm;\n        vSpriteSheet.w = rowNorm;\n    #endif\n    gl_PointSize = pointSizePerspective;\n    gl_Position = projectionMatrix * mvPosition;", 
THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.fog_vertex, "}"].join("\n"), fragment:[SPE.shaderChunks.uniforms, THREE.ShaderChunk.common, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, SPE.shaderChunks.varyings, SPE.shaderChunks.branchAvoidanceFunctions, "void main() {\n    vec3 outgoingLight = vColor.xyz;\n    \n    #ifdef ALPHATEST\n       if ( vColor.w < float(ALPHATEST) ) discard;\n    #endif", SPE.shaderChunks.rotateTexture, THREE.ShaderChunk.logdepthbuf_fragment, 
"    outgoingLight = vColor.xyz * rotatedTexture.xyz;\n    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );", THREE.ShaderChunk.fog_fragment, "}"].join("\n")};
SPE.utils = {types:{BOOLEAN:"boolean", STRING:"string", NUMBER:"number", OBJECT:"object"}, ensureTypedArg:function(a, h, l) {
  return typeof a === h ? a : l;
}, ensureArrayTypedArg:function(a, h, l) {
  if (Array.isArray(a)) {
    for (var b = a.length - 1;0 <= b;--b) {
      if (typeof a[b] !== h) {
        return l;
      }
    }
    return a;
  }
  return this.ensureTypedArg(a, h, l);
}, ensureInstanceOf:function(a, h, l) {
  return void 0 !== h && a instanceof h ? a : l;
}, ensureArrayInstanceOf:function(a, h, l) {
  if (Array.isArray(a)) {
    for (var b = a.length - 1;0 <= b;--b) {
      if (void 0 !== h && 0 == a[b] instanceof h) {
        return l;
      }
    }
    return a;
  }
  return this.ensureInstanceOf(a, h, l);
}, ensureValueOverLifetimeCompliance:function(a, h, l) {
  h = h || 3;
  l = l || 3;
  !1 === Array.isArray(a._value) && (a._value = [a._value]);
  !1 === Array.isArray(a._spread) && (a._spread = [a._spread]);
  var b = this.clamp(a._value.length, h, l);
  h = this.clamp(a._spread.length, h, l);
  b = Math.max(b, h);
  a._value.length !== b && (a._value = this.interpolateArray(a._value, b));
  a._spread.length !== b && (a._spread = this.interpolateArray(a._spread, b));
}, interpolateArray:function(a, h) {
  for (var l = a.length, b = ["function" == typeof a[0].clone ? a[0].clone() : a[0]], f = (l - 1) / (h - 1), k = 1;h - 1 > k;++k) {
    var c = k * f, g = Math.floor(c);
    b[k] = this.lerpTypeAgnostic(a[g], a[Math.ceil(c)], c - g);
  }
  return b.push("function" == typeof a[l - 1].clone ? a[l - 1].clone() : a[l - 1]), b;
}, clamp:function(a, h, l) {
  return Math.max(h, Math.min(a, l));
}, zeroToEpsilon:function(a, h) {
  var l = a;
  return l = h ? 1E-4 * Math.random() : 1E-5, 0 > a && -1E-5 < a && (l = -l), l;
}, lerpTypeAgnostic:function(a, h, l) {
  var b, f = this.types;
  return typeof a === f.NUMBER && typeof h === f.NUMBER ? a + (h - a) * l : a instanceof THREE.Vector2 && h instanceof THREE.Vector2 ? (b = a.clone(), b.x = this.lerp(a.x, h.x, l), b.y = this.lerp(a.y, h.y, l), b) : a instanceof THREE.Vector3 && h instanceof THREE.Vector3 ? (b = a.clone(), b.x = this.lerp(a.x, h.x, l), b.y = this.lerp(a.y, h.y, l), b.z = this.lerp(a.z, h.z, l), b) : a instanceof THREE.Vector4 && h instanceof THREE.Vector4 ? (b = a.clone(), b.x = this.lerp(a.x, h.x, l), b.y = this.lerp(a.y, 
  h.y, l), b.z = this.lerp(a.z, h.z, l), b.w = this.lerp(a.w, h.w, l), b) : a instanceof THREE.Color && h instanceof THREE.Color ? (b = a.clone(), b.r = this.lerp(a.r, h.r, l), b.g = this.lerp(a.g, h.g, l), b.b = this.lerp(a.b, h.b, l), b) : void console.warn("Invalid argument types, or argument types do not match:", a, h);
}, lerp:function(a, h, l) {
  return a + (h - a) * l;
}, roundToNearestMultiple:function(a, h) {
  var l = 0;
  return 0 === h ? a : (l = Math.abs(a) % h, 0 === l ? a : 0 > a ? -(Math.abs(a) - l) : a + h - l);
}, arrayValuesAreEqual:function(a) {
  for (var h = 0;h < a.length - 1;++h) {
    if (a[h] !== a[h + 1]) {
      return !1;
    }
  }
  return !0;
}, randomFloat:function(a, h) {
  return a + h * (Math.random() - .5);
}, randomVector3:function(a, h, l, b, f) {
  var k = l.x + (Math.random() * b.x - .5 * b.x), c = l.y + (Math.random() * b.y - .5 * b.y);
  l = l.z + (Math.random() * b.z - .5 * b.z);
  f && (k = .5 * -f.x + this.roundToNearestMultiple(k, f.x), c = .5 * -f.y + this.roundToNearestMultiple(c, f.y), l = .5 * -f.z + this.roundToNearestMultiple(l, f.z));
  a.typedArray.setVec3Components(h, k, c, l);
}, randomColor:function(a, h, l, b) {
  var f = l.r + Math.random() * b.x, k = l.g + Math.random() * b.y;
  l = l.b + Math.random() * b.z;
  f = this.clamp(f, 0, 1);
  k = this.clamp(k, 0, 1);
  l = this.clamp(l, 0, 1);
  a.typedArray.setVec3Components(h, f, k, l);
}, randomColorAsHex:function() {
  var a = new THREE.Color;
  return function(h, l, b, f) {
    for (var k = b.length, c = [], g = 0;k > g;++g) {
      var e = f[g];
      a.copy(b[g]);
      a.r += Math.random() * e.x - .5 * e.x;
      a.g += Math.random() * e.y - .5 * e.y;
      a.b += Math.random() * e.z - .5 * e.z;
      a.r = this.clamp(a.r, 0, 1);
      a.g = this.clamp(a.g, 0, 1);
      a.b = this.clamp(a.b, 0, 1);
      c.push(a.getHex());
    }
    h.typedArray.setVec4Components(l, c[0], c[1], c[2], c[3]);
  };
}(), randomVector3OnSphere:function(a, h, l, b, f, k, c, g) {
  g = 2 * Math.random() - 1;
  var e = 6.2832 * Math.random(), p = Math.sqrt(1 - g * g);
  b = this.randomFloat(b, f);
  c && (b = Math.round(b / c) * c);
  c = p * Math.cos(e) * b;
  e = p * Math.sin(e) * b;
  c *= k.x;
  e *= k.y;
  k = g * b * k.z;
  c += l.x;
  e += l.y;
  k += l.z;
  a.typedArray.setVec3Components(h, c, e, k);
}, seededRandom:function(a) {
  a = 1E4 * Math.sin(a);
  return a - (0 | a);
}, randomVector3OnDisc:function(a, h, l, b, f, k, c) {
  var g = 6.2832 * Math.random();
  b = Math.abs(this.randomFloat(b, f));
  c && (b = Math.round(b / c) * c);
  c = Math.cos(g) * b;
  g = Math.sin(g) * b;
  c *= k.x;
  g *= k.y;
  c += l.x;
  g += l.y;
  l = 0 + l.z;
  a.typedArray.setVec3Components(h, c, g, l);
}, randomDirectionVector3OnSphere:function() {
  var a = new THREE.Vector3;
  return function(h, l, b, f, k, c, g, e) {
    a.copy(c);
    a.x -= b;
    a.y -= f;
    a.z -= k;
    a.normalize().multiplyScalar(-this.randomFloat(g, e));
    h.typedArray.setVec3Components(l, a.x, a.y, a.z);
  };
}(), randomDirectionVector3OnDisc:function() {
  var a = new THREE.Vector3;
  return function(h, l, b, f, k, c, g, e) {
    a.copy(c);
    a.x -= b;
    a.y -= f;
    a.z -= k;
    a.normalize().multiplyScalar(-this.randomFloat(g, e));
    h.typedArray.setVec3Components(l, a.x, a.y, 0);
  };
}(), getPackedRotationAxis:function() {
  var a = new THREE.Vector3, h = new THREE.Vector3, l = new THREE.Color, b = new THREE.Vector3(1, 1, 1);
  return function(f, k) {
    return a.copy(f).normalize(), h.copy(k).normalize(), a.x += .5 * -k.x + Math.random() * k.x, a.y += .5 * -k.y + Math.random() * k.y, a.z += .5 * -k.z + Math.random() * k.z, a.normalize().add(b).multiplyScalar(.5), l.setRGB(a.x, a.y, a.z), l.getHex();
  };
}()};
SPE.Group = function(a) {
  var h = SPE.utils, l = h.types;
  a = h.ensureTypedArg(a, l.OBJECT, {});
  a.texture = h.ensureTypedArg(a.texture, l.OBJECT, {});
  this.uuid = THREE.Math.generateUUID();
  this.fixedTimeStep = h.ensureTypedArg(a.fixedTimeStep, l.NUMBER, .016);
  this.texture = h.ensureInstanceOf(a.texture.value, THREE.Texture, null);
  this.textureFrames = h.ensureInstanceOf(a.texture.frames, THREE.Vector2, new THREE.Vector2(1, 1));
  this.textureFrameCount = h.ensureTypedArg(a.texture.frameCount, l.NUMBER, this.textureFrames.x * this.textureFrames.y);
  this.textureLoop = h.ensureTypedArg(a.texture.loop, l.NUMBER, 1);
  this.textureFrames.max(new THREE.Vector2(1, 1));
  this.hasPerspective = h.ensureTypedArg(a.hasPerspective, l.BOOLEAN, !0);
  this.colorize = h.ensureTypedArg(a.colorize, l.BOOLEAN, !0);
  this.maxParticleCount = h.ensureTypedArg(a.maxParticleCount, l.NUMBER, null);
  this.blending = h.ensureTypedArg(a.blending, l.NUMBER, THREE.AdditiveBlending);
  this.transparent = h.ensureTypedArg(a.transparent, l.BOOLEAN, !0);
  this.alphaTest = parseFloat(h.ensureTypedArg(a.alphaTest, l.NUMBER, 0));
  this.depthWrite = h.ensureTypedArg(a.depthWrite, l.BOOLEAN, !1);
  this.depthTest = h.ensureTypedArg(a.depthTest, l.BOOLEAN, !0);
  this.fog = h.ensureTypedArg(a.fog, l.BOOLEAN, !0);
  this.scale = h.ensureTypedArg(a.scale, l.NUMBER, 300);
  this.emitters = [];
  this.emitterIDs = [];
  this._pool = [];
  this._poolCreationSettings = null;
  this._createNewWhenPoolEmpty = 0;
  this._attributesNeedDynamicReset = this._attributesNeedRefresh = !1;
  this.particleCount = 0;
  this.uniforms = {texture:{type:"t", value:this.texture}, textureAnimation:{type:"v4", value:new THREE.Vector4(this.textureFrames.x, this.textureFrames.y, this.textureFrameCount, Math.max(Math.abs(this.textureLoop), 1))}, fogColor:{type:"c", value:null}, fogNear:{type:"f", value:10}, fogFar:{type:"f", value:200}, fogDensity:{type:"f", value:.5}, deltaTime:{type:"f", value:0}, runTime:{type:"f", value:0}, scale:{type:"f", value:this.scale}};
  this.defines = {HAS_PERSPECTIVE:this.hasPerspective, COLORIZE:this.colorize, VALUE_OVER_LIFETIME_LENGTH:SPE.valueOverLifetimeLength, SHOULD_ROTATE_TEXTURE:!1, SHOULD_ROTATE_PARTICLES:!1, SHOULD_WIGGLE_PARTICLES:!1, SHOULD_CALCULATE_SPRITE:1 < this.textureFrames.x || 1 < this.textureFrames.y};
  this.attributes = {position:new SPE.ShaderAttribute("v3", !0), acceleration:new SPE.ShaderAttribute("v4", !0), velocity:new SPE.ShaderAttribute("v3", !0), rotation:new SPE.ShaderAttribute("v4", !0), rotationCenter:new SPE.ShaderAttribute("v3", !0), params:new SPE.ShaderAttribute("v4", !0), size:new SPE.ShaderAttribute("v4", !0), angle:new SPE.ShaderAttribute("v4", !0), color:new SPE.ShaderAttribute("v4", !0), opacity:new SPE.ShaderAttribute("v4", !0)};
  this.attributeKeys = Object.keys(this.attributes);
  this.attributeCount = this.attributeKeys.length;
  this.material = new THREE.ShaderMaterial({uniforms:this.uniforms, vertexShader:SPE.shaders.vertex, fragmentShader:SPE.shaders.fragment, blending:this.blending, transparent:this.transparent, alphaTest:this.alphaTest, depthWrite:this.depthWrite, depthTest:this.depthTest, defines:this.defines, fog:this.fog});
  this.geometry = new THREE.BufferGeometry;
  this.mesh = new THREE.Points(this.geometry, this.material);
  null === this.maxParticleCount && console.warn("SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.");
};
SPE.Group.constructor = SPE.Group;
SPE.Group.prototype._updateDefines = function() {
  var a, h = this.emitters, l = h.length - 1, b = this.defines;
  for (l;0 <= l;--l) {
    a = h[l], b.SHOULD_CALCULATE_SPRITE || (b.SHOULD_ROTATE_TEXTURE = b.SHOULD_ROTATE_TEXTURE || !!Math.max(Math.max.apply(null, a.angle.value), Math.max.apply(null, a.angle.spread))), b.SHOULD_ROTATE_PARTICLES = b.SHOULD_ROTATE_PARTICLES || !!Math.max(a.rotation.angle, a.rotation.angleSpread), b.SHOULD_WIGGLE_PARTICLES = b.SHOULD_WIGGLE_PARTICLES || !!Math.max(a.wiggle.value, a.wiggle.spread);
  }
  this.material.needsUpdate = !0;
};
SPE.Group.prototype._applyAttributesToGeometry = function() {
  var a, h, l = this.attributes, b = this.geometry, f = b.attributes, k;
  for (k in l) {
    l.hasOwnProperty(k) && (a = l[k], h = f[k], h ? h.array = a.typedArray.array : b.addAttribute(k, a.bufferAttribute), a.bufferAttribute.needsUpdate = !0);
  }
  this.geometry.setDrawRange(0, this.particleCount);
};
SPE.Group.prototype.addEmitter = function(a) {
  if (0 == a instanceof SPE.Emitter) {
    return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", a);
  }
  if (-1 < this.emitterIDs.indexOf(a.uuid)) {
    return void console.error("Emitter already exists in this group. Will not add again.");
  }
  if (null !== a.group) {
    return void console.error("Emitter already belongs to another group. Will not add to requested group.");
  }
  var h = this.attributes, l = this.particleCount, b = l + a.particleCount;
  this.particleCount = b;
  null !== this.maxParticleCount && this.particleCount > this.maxParticleCount && console.warn("SPE.Group: maxParticleCount exceeded. Requesting", this.particleCount, "particles, can support only", this.maxParticleCount);
  a._calculatePPSValue(a.maxAge._value + a.maxAge._spread);
  a._setBufferUpdateRanges(this.attributeKeys);
  a._setAttributeOffset(l);
  a.group = this;
  a.attributes = this.attributes;
  for (var f in h) {
    h.hasOwnProperty(f) && h[f]._createBufferAttribute(null !== this.maxParticleCount ? this.maxParticleCount : this.particleCount);
  }
  for (h = l;b > h;++h) {
    a._assignPositionValue(h), a._assignForceValue(h, "velocity"), a._assignForceValue(h, "acceleration"), a._assignAbsLifetimeValue(h, "opacity"), a._assignAbsLifetimeValue(h, "size"), a._assignAngleValue(h), a._assignRotationValue(h), a._assignParamsValue(h), a._assignColorValue(h);
  }
  return this._applyAttributesToGeometry(), this.emitters.push(a), this.emitterIDs.push(a.uuid), this._updateDefines(a), this.material.needsUpdate = !0, this.geometry.needsUpdate = !0, this._attributesNeedRefresh = !0, this;
};
SPE.Group.prototype.removeEmitter = function(a) {
  var h = this.emitterIDs.indexOf(a.uuid);
  if (0 == a instanceof SPE.Emitter) {
    return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", a);
  }
  if (-1 === h) {
    return void console.error("Emitter does not exist in this group. Will not remove.");
  }
  for (var l = a.attributeOffset, b = l + a.particleCount, f = this.attributes.params.typedArray, k = l;b > k;++k) {
    f.array[4 * k] = 0, f.array[4 * k + 1] = 0;
  }
  this.emitters.splice(h, 1);
  this.emitterIDs.splice(h, 1);
  for (var c in this.attributes) {
    this.attributes.hasOwnProperty(c) && this.attributes[c].splice(l, b);
  }
  this.particleCount -= a.particleCount;
  a._onRemove();
  this._attributesNeedRefresh = !0;
};
SPE.Group.prototype.getFromPool = function() {
  var a = this._pool, h = this._createNewWhenPoolEmpty;
  return a.length ? a.pop() : h ? (a = new SPE.Emitter(this._poolCreationSettings), this.addEmitter(a), a) : null;
};
SPE.Group.prototype.releaseIntoPool = function(a) {
  return 0 == a instanceof SPE.Emitter ? void console.error("Argument is not instanceof SPE.Emitter:", a) : (a.reset(), this._pool.unshift(a), this);
};
SPE.Group.prototype.getPool = function() {
  return this._pool;
};
SPE.Group.prototype.addPool = function(a, h, l) {
  this._poolCreationSettings = h;
  this._createNewWhenPoolEmpty = !!l;
  for (var b = 0;a > b;++b) {
    l = Array.isArray(h) ? new SPE.Emitter(h[b]) : new SPE.Emitter(h), this.addEmitter(l), this.releaseIntoPool(l);
  }
  return this;
};
SPE.Group.prototype._triggerSingleEmitter = function(a) {
  var h = this.getFromPool(), l = this;
  return null === h ? void console.log("SPE.Group pool ran out.") : (a instanceof THREE.Vector3 && (h.position.value.copy(a), h.position.value = h.position.value), h.enable(), setTimeout(function() {
    h.disable();
    l.releaseIntoPool(h);
  }, 1E3 * Math.max(h.duration, h.maxAge.value + h.maxAge.spread)), this);
};
SPE.Group.prototype.triggerPoolEmitter = function(a, h) {
  if ("number" == typeof a && 1 < a) {
    for (var l = 0;a > l;++l) {
      this._triggerSingleEmitter(h);
    }
  } else {
    this._triggerSingleEmitter(h);
  }
  return this;
};
SPE.Group.prototype._updateUniforms = function(a) {
  this.uniforms.runTime.value += a;
  this.uniforms.deltaTime.value = a;
};
SPE.Group.prototype._resetBufferRanges = function() {
  var a = this.attributeKeys, h = this.attributeCount - 1, l = this.attributes;
  for (h;0 <= h;--h) {
    l[a[h]].resetUpdateRange();
  }
};
SPE.Group.prototype._updateBuffers = function(a) {
  var h, l = this.attributeKeys, b = this.attributeCount - 1, f = this.attributes, k = a.bufferUpdateRanges;
  for (b;0 <= b;--b) {
    h = l[b], a = k[h], h = f[h], h.setUpdateRange(a.min, a.max), h.flagUpdate();
  }
};
SPE.Group.prototype.tick = function(a) {
  var h = this.emitters, l = h.length, b = a || this.fixedTimeStep, f = this.attributeKeys, k = this.attributes;
  if (this._updateUniforms(b), this._resetBufferRanges(), 0 !== l || !1 !== this._attributesNeedRefresh || !1 !== this._attributesNeedDynamicReset) {
    var c;
    for (a = 0;l > a;++a) {
      c = h[a], c.tick(b), this._updateBuffers(c);
    }
    if (!0 === this._attributesNeedDynamicReset) {
      for (a = this.attributeCount - 1;0 <= a;--a) {
        k[f[a]].resetDynamic();
      }
      this._attributesNeedDynamicReset = !1;
    }
    if (!0 === this._attributesNeedRefresh) {
      for (a = this.attributeCount - 1;0 <= a;--a) {
        k[f[a]].forceUpdateAll();
      }
      this._attributesNeedRefresh = !1;
      this._attributesNeedDynamicReset = !0;
    }
  }
};
SPE.Group.prototype.dispose = function() {
  return this.geometry.dispose(), this.material.dispose(), this;
};
SPE.Emitter = function(a) {
  var h = SPE.utils, l = h.types, b = SPE.valueOverLifetimeLength;
  a = h.ensureTypedArg(a, l.OBJECT, {});
  a.position = h.ensureTypedArg(a.position, l.OBJECT, {});
  a.velocity = h.ensureTypedArg(a.velocity, l.OBJECT, {});
  a.acceleration = h.ensureTypedArg(a.acceleration, l.OBJECT, {});
  a.radius = h.ensureTypedArg(a.radius, l.OBJECT, {});
  a.drag = h.ensureTypedArg(a.drag, l.OBJECT, {});
  a.rotation = h.ensureTypedArg(a.rotation, l.OBJECT, {});
  a.color = h.ensureTypedArg(a.color, l.OBJECT, {});
  a.opacity = h.ensureTypedArg(a.opacity, l.OBJECT, {});
  a.size = h.ensureTypedArg(a.size, l.OBJECT, {});
  a.angle = h.ensureTypedArg(a.angle, l.OBJECT, {});
  a.wiggle = h.ensureTypedArg(a.wiggle, l.OBJECT, {});
  a.maxAge = h.ensureTypedArg(a.maxAge, l.OBJECT, {});
  a.onParticleSpawn && console.warn("onParticleSpawn has been removed. Please set properties directly to alter values at runtime.");
  this.uuid = THREE.Math.generateUUID();
  this.type = h.ensureTypedArg(a.type, l.NUMBER, SPE.distributions.BOX);
  this.position = {_value:h.ensureInstanceOf(a.position.value, THREE.Vector3, new THREE.Vector3), _spread:h.ensureInstanceOf(a.position.spread, THREE.Vector3, new THREE.Vector3), _spreadClamp:h.ensureInstanceOf(a.position.spreadClamp, THREE.Vector3, new THREE.Vector3), _distribution:h.ensureTypedArg(a.position.distribution, l.NUMBER, this.type), _randomise:h.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1), _radius:h.ensureTypedArg(a.position.radius, l.NUMBER, 10), _radiusScale:h.ensureInstanceOf(a.position.radiusScale, 
  THREE.Vector3, new THREE.Vector3(1, 1, 1)), _distributionClamp:h.ensureTypedArg(a.position.distributionClamp, l.NUMBER, 0)};
  this.velocity = {_value:h.ensureInstanceOf(a.velocity.value, THREE.Vector3, new THREE.Vector3), _spread:h.ensureInstanceOf(a.velocity.spread, THREE.Vector3, new THREE.Vector3), _distribution:h.ensureTypedArg(a.velocity.distribution, l.NUMBER, this.type), _randomise:h.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1)};
  this.acceleration = {_value:h.ensureInstanceOf(a.acceleration.value, THREE.Vector3, new THREE.Vector3), _spread:h.ensureInstanceOf(a.acceleration.spread, THREE.Vector3, new THREE.Vector3), _distribution:h.ensureTypedArg(a.acceleration.distribution, l.NUMBER, this.type), _randomise:h.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1)};
  this.drag = {_value:h.ensureTypedArg(a.drag.value, l.NUMBER, 0), _spread:h.ensureTypedArg(a.drag.spread, l.NUMBER, 0), _randomise:h.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1)};
  this.wiggle = {_value:h.ensureTypedArg(a.wiggle.value, l.NUMBER, 0), _spread:h.ensureTypedArg(a.wiggle.spread, l.NUMBER, 0)};
  this.rotation = {_axis:h.ensureInstanceOf(a.rotation.axis, THREE.Vector3, new THREE.Vector3(0, 1, 0)), _axisSpread:h.ensureInstanceOf(a.rotation.axisSpread, THREE.Vector3, new THREE.Vector3), _angle:h.ensureTypedArg(a.rotation.angle, l.NUMBER, 0), _angleSpread:h.ensureTypedArg(a.rotation.angleSpread, l.NUMBER, 0), _static:h.ensureTypedArg(a.rotation["static"], l.BOOLEAN, !1), _center:h.ensureInstanceOf(a.rotation.center, THREE.Vector3, this.position._value.clone()), _randomise:h.ensureTypedArg(a.position.randomise, 
  l.BOOLEAN, !1)};
  this.maxAge = {_value:h.ensureTypedArg(a.maxAge.value, l.NUMBER, 2), _spread:h.ensureTypedArg(a.maxAge.spread, l.NUMBER, 0)};
  this.color = {_value:h.ensureArrayInstanceOf(a.color.value, THREE.Color, new THREE.Color), _spread:h.ensureArrayInstanceOf(a.color.spread, THREE.Vector3, new THREE.Vector3), _randomise:h.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1)};
  this.opacity = {_value:h.ensureArrayTypedArg(a.opacity.value, l.NUMBER, 1), _spread:h.ensureArrayTypedArg(a.opacity.spread, l.NUMBER, 0), _randomise:h.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1)};
  this.size = {_value:h.ensureArrayTypedArg(a.size.value, l.NUMBER, 1), _spread:h.ensureArrayTypedArg(a.size.spread, l.NUMBER, 0), _randomise:h.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1)};
  this.angle = {_value:h.ensureArrayTypedArg(a.angle.value, l.NUMBER, 0), _spread:h.ensureArrayTypedArg(a.angle.spread, l.NUMBER, 0), _randomise:h.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1)};
  this.particleCount = h.ensureTypedArg(a.particleCount, l.NUMBER, 100);
  this.duration = h.ensureTypedArg(a.duration, l.NUMBER, null);
  this.isStatic = h.ensureTypedArg(a.isStatic, l.BOOLEAN, !1);
  this.activeMultiplier = h.ensureTypedArg(a.activeMultiplier, l.NUMBER, 1);
  this.direction = h.ensureTypedArg(a.direction, l.NUMBER, 1);
  this.alive = h.ensureTypedArg(a.alive, l.BOOLEAN, !0);
  this.activeParticleCount = this.age = this.attributeEnd = this.attributeOffset = this.activationIndex = this.particlesPerSecond = 0;
  this.paramsArray = this.attributes = this.group = null;
  this.resetFlags = {position:h.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1) || h.ensureTypedArg(a.radius.randomise, l.BOOLEAN, !1), velocity:h.ensureTypedArg(a.velocity.randomise, l.BOOLEAN, !1), acceleration:h.ensureTypedArg(a.acceleration.randomise, l.BOOLEAN, !1) || h.ensureTypedArg(a.drag.randomise, l.BOOLEAN, !1), rotation:h.ensureTypedArg(a.rotation.randomise, l.BOOLEAN, !1), rotationCenter:h.ensureTypedArg(a.rotation.randomise, l.BOOLEAN, !1), size:h.ensureTypedArg(a.size.randomise, 
  l.BOOLEAN, !1), color:h.ensureTypedArg(a.color.randomise, l.BOOLEAN, !1), opacity:h.ensureTypedArg(a.opacity.randomise, l.BOOLEAN, !1), angle:h.ensureTypedArg(a.angle.randomise, l.BOOLEAN, !1)};
  this.updateFlags = {};
  this.updateCounts = {};
  this.updateMap = {maxAge:"params", position:"position", velocity:"velocity", acceleration:"acceleration", drag:"acceleration", wiggle:"params", rotation:"rotation", size:"size", color:"color", opacity:"opacity", angle:"angle"};
  for (var f in this.updateMap) {
    this.updateMap.hasOwnProperty(f) && (this.updateCounts[this.updateMap[f]] = 0, this.updateFlags[this.updateMap[f]] = !1, this._createGetterSetters(this[f], f));
  }
  this.bufferUpdateRanges = {};
  this.attributeKeys = null;
  this.attributeCount = 0;
  h.ensureValueOverLifetimeCompliance(this.color, b, b);
  h.ensureValueOverLifetimeCompliance(this.opacity, b, b);
  h.ensureValueOverLifetimeCompliance(this.size, b, b);
  h.ensureValueOverLifetimeCompliance(this.angle, b, b);
};
SPE.Emitter.constructor = SPE.Emitter;
SPE.Emitter.prototype._createGetterSetters = function(a, h) {
  var l = this, b;
  for (b in a) {
    if (a.hasOwnProperty(b)) {
      var f = b.replace("_", "");
      Object.defineProperty(a, f, {get:function(a) {
        return function() {
          return this[a];
        };
      }(b), set:function(a) {
        return function(b) {
          var c = l.updateMap[h], e = this[a], f = SPE.valueOverLifetimeLength;
          "_rotationCenter" === a ? (l.updateFlags.rotationCenter = !0, l.updateCounts.rotationCenter = 0) : "_randomise" === a ? l.resetFlags[c] = b : (l.updateFlags[c] = !0, l.updateCounts[c] = 0);
          l.group._updateDefines();
          this[a] = b;
          Array.isArray(e) && SPE.utils.ensureValueOverLifetimeCompliance(l[h], f, f);
        };
      }(b)});
    }
  }
};
SPE.Emitter.prototype._setBufferUpdateRanges = function(a) {
  this.attributeKeys = a;
  this.attributeCount = a.length;
  for (var h = this.attributeCount - 1;0 <= h;--h) {
    this.bufferUpdateRanges[a[h]] = {min:Number.POSITIVE_INFINITY, max:Number.NEGATIVE_INFINITY};
  }
};
SPE.Emitter.prototype._calculatePPSValue = function(a) {
  var h = this.particleCount;
  this.duration ? this.particlesPerSecond = h / (a < this.duration ? a : this.duration) : this.particlesPerSecond = h / a;
};
SPE.Emitter.prototype._setAttributeOffset = function(a) {
  this.activationIndex = this.attributeOffset = a;
  this.activationEnd = a + this.particleCount;
};
SPE.Emitter.prototype._assignValue = function(a, h) {
  switch(a) {
    case "position":
      this._assignPositionValue(h);
      break;
    case "velocity":
    case "acceleration":
      this._assignForceValue(h, a);
      break;
    case "size":
    case "opacity":
      this._assignAbsLifetimeValue(h, a);
      break;
    case "angle":
      this._assignAngleValue(h);
      break;
    case "params":
      this._assignParamsValue(h);
      break;
    case "rotation":
      this._assignRotationValue(h);
      break;
    case "color":
      this._assignColorValue(h);
  }
};
SPE.Emitter.prototype._assignPositionValue = function(a) {
  var h = SPE.distributions, l = SPE.utils, b = this.position, f = this.attributes.position, k = b._value, c = b._spread;
  switch(b._distribution) {
    case h.BOX:
      l.randomVector3(f, a, k, c, b._spreadClamp);
      break;
    case h.SPHERE:
      l.randomVector3OnSphere(f, a, k, b._radius, b._spread.x, b._radiusScale, b._spreadClamp.x, b._distributionClamp || this.particleCount);
      break;
    case h.DISC:
      l.randomVector3OnDisc(f, a, k, b._radius, b._spread.x, b._radiusScale, b._spreadClamp.x);
  }
};
SPE.Emitter.prototype._assignForceValue = function(a, h) {
  var l, b, f, k;
  b = SPE.distributions;
  var c = SPE.utils, g = this[h];
  f = g._value;
  l = g._spread;
  switch(g._distribution) {
    case b.BOX:
      c.randomVector3(this.attributes[h], a, f, l);
      break;
    case b.SPHERE:
      l = this.attributes.position.typedArray.array;
      k = 3 * a;
      b = l[k];
      f = l[k + 1];
      l = l[k + 2];
      c.randomDirectionVector3OnSphere(this.attributes[h], a, b, f, l, this.position._value, g._value.x, g._spread.x);
      break;
    case b.DISC:
      l = this.attributes.position.typedArray.array, k = 3 * a, b = l[k], f = l[k + 1], l = l[k + 2], c.randomDirectionVector3OnDisc(this.attributes[h], a, b, f, l, this.position._value, g._value.x, g._spread.x);
  }
  "acceleration" === h && (h = c.clamp(c.randomFloat(this.drag._value, this.drag._spread), 0, 1), this.attributes.acceleration.typedArray.array[4 * a + 3] = h);
};
SPE.Emitter.prototype._assignAbsLifetimeValue = function(a, h) {
  var l, b = this.attributes[h].typedArray;
  h = this[h];
  var f = SPE.utils;
  f.arrayValuesAreEqual(h._value) && f.arrayValuesAreEqual(h._spread) ? (l = Math.abs(f.randomFloat(h._value[0], h._spread[0])), b.setVec4Components(a, l, l, l, l)) : b.setVec4Components(a, Math.abs(f.randomFloat(h._value[0], h._spread[0])), Math.abs(f.randomFloat(h._value[1], h._spread[1])), Math.abs(f.randomFloat(h._value[2], h._spread[2])), Math.abs(f.randomFloat(h._value[3], h._spread[3])));
};
SPE.Emitter.prototype._assignAngleValue = function(a) {
  var h, l = this.attributes.angle.typedArray, b = this.angle, f = SPE.utils;
  f.arrayValuesAreEqual(b._value) && f.arrayValuesAreEqual(b._spread) ? (h = f.randomFloat(b._value[0], b._spread[0]), l.setVec4Components(a, h, h, h, h)) : l.setVec4Components(a, f.randomFloat(b._value[0], b._spread[0]), f.randomFloat(b._value[1], b._spread[1]), f.randomFloat(b._value[2], b._spread[2]), f.randomFloat(b._value[3], b._spread[3]));
};
SPE.Emitter.prototype._assignParamsValue = function(a) {
  this.attributes.params.typedArray.setVec4Components(a, this.isStatic ? 1 : 0, 0, Math.abs(SPE.utils.randomFloat(this.maxAge._value, this.maxAge._spread)), SPE.utils.randomFloat(this.wiggle._value, this.wiggle._spread));
};
SPE.Emitter.prototype._assignRotationValue = function(a) {
  this.attributes.rotation.typedArray.setVec3Components(a, SPE.utils.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread), SPE.utils.randomFloat(this.rotation._angle, this.rotation._angleSpread), this.rotation._static ? 0 : 1);
  this.attributes.rotationCenter.typedArray.setVec3(a, this.rotation._center);
};
SPE.Emitter.prototype._assignColorValue = function(a) {
  SPE.utils.randomColorAsHex(this.attributes.color, a, this.color._value, this.color._spread);
};
SPE.Emitter.prototype._resetParticle = function(a) {
  for (var h, l, b = this.resetFlags, f = this.updateFlags, k = this.updateCounts, c = this.attributeKeys, g = this.attributeCount - 1;0 <= g;--g) {
    h = c[g], l = f[h], !0 !== b[h] && !0 !== l || (this._assignValue(h, a), this._updateAttributeUpdateRange(h, a), !0 === l && k[h] === this.particleCount ? (f[h] = !1, k[h] = 0) : 1 == l && ++k[h]);
  }
};
SPE.Emitter.prototype._updateAttributeUpdateRange = function(a, h) {
  a = this.bufferUpdateRanges[a];
  a.min = Math.min(h, a.min);
  a.max = Math.max(h, a.max);
};
SPE.Emitter.prototype._resetBufferRanges = function() {
  var a, h = this.bufferUpdateRanges, l = this.bufferUpdateKeys, b = this.bufferUpdateCount - 1;
  for (b;0 <= b;--b) {
    a = l[b], h[a].min = Number.POSITIVE_INFINITY, h[a].max = Number.NEGATIVE_INFINITY;
  }
};
SPE.Emitter.prototype._onRemove = function() {
  this.activeParticleCount = this.activationIndex = this.attributeOffset = this.particlesPerSecond = 0;
  this.paramsArray = this.attributes = this.group = null;
  this.age = 0;
};
SPE.Emitter.prototype._decrementParticleCount = function() {
  --this.activeParticleCount;
};
SPE.Emitter.prototype._incrementParticleCount = function() {
  ++this.activeParticleCount;
};
SPE.Emitter.prototype._checkParticleAges = function(a, h, l, b) {
  for (var f, k, c, g = h - 1;g >= a;--g) {
    h = 4 * g, c = l[h], 0 !== c && (k = l[h + 1], f = l[h + 2], 1 === this.direction ? (k += b, k >= f && (k = 0, c = 0, this._decrementParticleCount())) : (k -= b, 0 >= k && (k = f, c = 0, this._decrementParticleCount())), l[h] = c, l[h + 1] = k, this._updateAttributeUpdateRange("params", g));
  }
};
SPE.Emitter.prototype._activateParticles = function(a, h, l, b) {
  for (var f, k, c = this.direction, g = a;h > g;++g) {
    f = 4 * g, 0 != l[f] && 1 !== this.particleCount || (this._incrementParticleCount(), l[f] = 1, this._resetParticle(g), k = b * (g - a), l[f + 1] = -1 === c ? l[f + 2] - k : k, this._updateAttributeUpdateRange("params", g));
  }
};
SPE.Emitter.prototype.tick = function(a) {
  if (!this.isStatic) {
    null === this.paramsArray && (this.paramsArray = this.attributes.params.typedArray.array);
    var h = this.attributeOffset, l = h + this.particleCount, b = this.paramsArray, f = this.particlesPerSecond * this.activeMultiplier * a, k = this.activationIndex;
    if (this._resetBufferRanges(), this._checkParticleAges(h, l, b, a), !1 === this.alive) {
      return void(this.age = 0);
    }
    if (null !== this.duration && this.age > this.duration) {
      return this.alive = !1, void(this.age = 0);
    }
    var k = 1 === this.particleCount ? k : 0 | k, c = Math.min(k + f, this.activationEnd), g = c - this.activationIndex | 0;
    this._activateParticles(k, c, b, 0 < g ? a / g : 0);
    this.activationIndex += f;
    this.activationIndex > l && (this.activationIndex = h);
    this.age += a;
  }
};
SPE.Emitter.prototype.reset = function(a) {
  if (this.age = 0, this.alive = !1, !0 === a) {
    for (var h = this.attributeOffset, l = this.paramsArray, b = this.attributes.params.bufferAttribute, f = h + this.particleCount - 1;f >= h;--f) {
      a = 4 * f, l[a] = 0, l[a + 1] = 0;
    }
    b.updateRange.offset = 0;
    b.updateRange.count = -1;
    b.needsUpdate = !0;
  }
  return this;
};
SPE.Emitter.prototype.enable = function() {
  return this.alive = !0, this;
};
SPE.Emitter.prototype.disable = function() {
  return this.alive = !1, this;
};
SPE.Emitter.prototype.remove = function() {
  return null !== this.group ? this.group.removeEmitter(this) : console.error("Emitter does not belong to a group, cannot remove."), this;
};
var __extends = this && this.__extends || function(a, h) {
  function l() {
    this.constructor = a;
  }
  for (var b in h) {
    h.hasOwnProperty(b) && (a[b] = h[b]);
  }
  a.prototype = null === h ? Object.create(h) : (l.prototype = h.prototype, new l);
}, spine;
(function(a) {
  var h = function() {
    function a(a, b, c) {
      if (null == a) {
        throw Error("name cannot be null.");
      }
      if (null == b) {
        throw Error("timelines cannot be null.");
      }
      this.name = a;
      this.timelines = b;
      this.duration = c;
    }
    a.prototype.apply = function(a, b, c, f, k, h, l, v) {
      if (null == a) {
        throw Error("skeleton cannot be null.");
      }
      f && 0 != this.duration && (c %= this.duration, 0 < b && (b %= this.duration));
      f = this.timelines;
      for (var e = 0, g = f.length;e < g;e++) {
        f[e].apply(a, b, c, k, h, l, v);
      }
    };
    a.binarySearch = function(a, b, c) {
      void 0 === c && (c = 1);
      var e = 0, g = a.length / c - 2;
      if (0 == g) {
        return c;
      }
      for (var f = g >>> 1;;) {
        a[(f + 1) * c] <= b ? e = f + 1 : g = f;
        if (e == g) {
          return (e + 1) * c;
        }
        f = e + g >>> 1;
      }
    };
    a.linearSearch = function(a, b, c) {
      for (var e = 0, g = a.length - c;e <= g;e += c) {
        if (a[e] > b) {
          return e;
        }
      }
      return -1;
    };
    return a;
  }();
  a.Animation = h;
  (function(a) {
    a[a.rotate = 0] = "rotate";
    a[a.translate = 1] = "translate";
    a[a.scale = 2] = "scale";
    a[a.shear = 3] = "shear";
    a[a.attachment = 4] = "attachment";
    a[a.color = 5] = "color";
    a[a.deform = 6] = "deform";
    a[a.event = 7] = "event";
    a[a.drawOrder = 8] = "drawOrder";
    a[a.ikConstraint = 9] = "ikConstraint";
    a[a.transformConstraint = 10] = "transformConstraint";
    a[a.pathConstraintPosition = 11] = "pathConstraintPosition";
    a[a.pathConstraintSpacing = 12] = "pathConstraintSpacing";
    a[a.pathConstraintMix = 13] = "pathConstraintMix";
  })(a.TimelineType || (a.TimelineType = {}));
  var l = a.TimelineType, b = function() {
    function b(c) {
      if (0 >= c) {
        throw Error("frameCount must be > 0: " + c);
      }
      this.curves = a.Utils.newFloatArray((c - 1) * b.BEZIER_SIZE);
    }
    b.prototype.getFrameCount = function() {
      return this.curves.length / b.BEZIER_SIZE + 1;
    };
    b.prototype.setLinear = function(a) {
      this.curves[a * b.BEZIER_SIZE] = b.LINEAR;
    };
    b.prototype.setStepped = function(a) {
      this.curves[a * b.BEZIER_SIZE] = b.STEPPED;
    };
    b.prototype.getCurveType = function(a) {
      a *= b.BEZIER_SIZE;
      if (a == this.curves.length) {
        return b.LINEAR;
      }
      a = this.curves[a];
      return a == b.LINEAR ? b.LINEAR : a == b.STEPPED ? b.STEPPED : b.BEZIER;
    };
    b.prototype.setCurve = function(a, c, f, k, h) {
      var e = .03 * (2 * -c + k), g = .03 * (2 * -f + h);
      k = .006 * (3 * (c - k) + 1);
      h = .006 * (3 * (f - h) + 1);
      var p = 2 * e + k, l = 2 * g + h;
      c = .3 * c + e + .16666667 * k;
      f = .3 * f + g + .16666667 * h;
      a *= b.BEZIER_SIZE;
      g = this.curves;
      g[a++] = b.BEZIER;
      for (var e = c, r = f, q = a + b.BEZIER_SIZE - 1;a < q;a += 2) {
        g[a] = e, g[a + 1] = r, c += p, f += l, p += k, l += h, e += c, r += f;
      }
    };
    b.prototype.getCurvePercent = function(c, e) {
      e = a.MathUtils.clamp(e, 0, 1);
      var g = this.curves;
      c *= b.BEZIER_SIZE;
      var f = g[c];
      if (f == b.LINEAR) {
        return e;
      }
      if (f == b.STEPPED) {
        return 0;
      }
      c++;
      for (var f = 0, k = c, h = c + b.BEZIER_SIZE - 1;c < h;c += 2) {
        if (f = g[c], f >= e) {
          return c == k ? h = k = 0 : (k = g[c - 2], h = g[c - 1]), h + (g[c + 1] - h) * (e - k) / (f - k);
        }
      }
      g = g[c - 1];
      return g + (1 - g) * (e - f) / (1 - f);
    };
    b.LINEAR = 0;
    b.STEPPED = 1;
    b.BEZIER = 2;
    b.BEZIER_SIZE = 19;
    return b;
  }();
  a.CurveTimeline = b;
  var f = function(b) {
    function c(c) {
      b.call(this, c);
      this.frames = a.Utils.newFloatArray(c << 1);
    }
    __extends(c, b);
    c.prototype.getPropertyId = function() {
      return (l.rotate << 24) + this.boneIndex;
    };
    c.prototype.setFrame = function(a, b, g) {
      a <<= 1;
      this.frames[a] = b;
      this.frames[a + c.ROTATION] = g;
    };
    c.prototype.apply = function(a, b, g, f, k, l, v) {
      b = this.frames;
      a = a.bones[this.boneIndex];
      if (g < b[0]) {
        l && (a.rotation = a.data.rotation);
      } else {
        if (g >= b[b.length - c.ENTRIES]) {
          l ? a.rotation = a.data.rotation + b[b.length + c.PREV_ROTATION] * k : (l = a.data.rotation + b[b.length + c.PREV_ROTATION] - a.rotation, a.rotation += (l - 360 * (16384 - (16384.499999999996 - l / 360 | 0))) * k);
        } else {
          v = h.binarySearch(b, g, c.ENTRIES);
          f = b[v + c.PREV_ROTATION];
          var e = b[v];
          g = this.getCurvePercent((v >> 1) - 1, 1 - (g - e) / (b[v + c.PREV_TIME] - e));
          b = b[v + c.ROTATION] - f;
          b = f + (b - 360 * (16384 - (16384.499999999996 - b / 360 | 0))) * g;
          l ? a.rotation = a.data.rotation + (b - 360 * (16384 - (16384.499999999996 - b / 360 | 0))) * k : (b = a.data.rotation + b - a.rotation, a.rotation += (b - 360 * (16384 - (16384.499999999996 - b / 360 | 0))) * k);
        }
      }
    };
    c.ENTRIES = 2;
    c.PREV_TIME = -2;
    c.PREV_ROTATION = -1;
    c.ROTATION = 1;
    return c;
  }(b);
  a.RotateTimeline = f;
  f = function(b) {
    function c(e) {
      b.call(this, e);
      this.frames = a.Utils.newFloatArray(e * c.ENTRIES);
    }
    __extends(c, b);
    c.prototype.getPropertyId = function() {
      return (l.translate << 24) + this.boneIndex;
    };
    c.prototype.setFrame = function(a, b, g, f) {
      a *= c.ENTRIES;
      this.frames[a] = b;
      this.frames[a + c.X] = g;
      this.frames[a + c.Y] = f;
    };
    c.prototype.apply = function(a, b, g, f, k, l, v) {
      b = this.frames;
      a = a.bones[this.boneIndex];
      if (g < b[0]) {
        l && (a.x = a.data.x, a.y = a.data.y);
      } else {
        if (g >= b[b.length - c.ENTRIES]) {
          f = b[b.length + c.PREV_X], v = b[b.length + c.PREV_Y];
        } else {
          var e = h.binarySearch(b, g, c.ENTRIES);
          f = b[e + c.PREV_X];
          v = b[e + c.PREV_Y];
          var p = b[e];
          g = this.getCurvePercent(e / c.ENTRIES - 1, 1 - (g - p) / (b[e + c.PREV_TIME] - p));
          f += (b[e + c.X] - f) * g;
          v += (b[e + c.Y] - v) * g;
        }
        l ? (a.x = a.data.x + f * k, a.y = a.data.y + v * k) : (a.x += (a.data.x + f - a.x) * k, a.y += (a.data.y + v - a.y) * k);
      }
    };
    c.ENTRIES = 3;
    c.PREV_TIME = -3;
    c.PREV_X = -2;
    c.PREV_Y = -1;
    c.X = 1;
    c.Y = 2;
    return c;
  }(b);
  a.TranslateTimeline = f;
  var k = function(b) {
    function c(a) {
      b.call(this, a);
    }
    __extends(c, b);
    c.prototype.getPropertyId = function() {
      return (l.scale << 24) + this.boneIndex;
    };
    c.prototype.apply = function(b, g, f, k, l, t, v) {
      var e = this.frames;
      b = b.bones[this.boneIndex];
      if (f < e[0]) {
        t && (b.scaleX = b.data.scaleX, b.scaleY = b.data.scaleY);
      } else {
        if (f >= e[e.length - c.ENTRIES]) {
          g = e[e.length + c.PREV_X] * b.data.scaleX, k = e[e.length + c.PREV_Y] * b.data.scaleY;
        } else {
          var p = h.binarySearch(e, f, c.ENTRIES);
          g = e[p + c.PREV_X];
          k = e[p + c.PREV_Y];
          var n = e[p];
          f = this.getCurvePercent(p / c.ENTRIES - 1, 1 - (f - n) / (e[p + c.PREV_TIME] - n));
          g = (g + (e[p + c.X] - g) * f) * b.data.scaleX;
          k = (k + (e[p + c.Y] - k) * f) * b.data.scaleY;
        }
        1 == l ? (b.scaleX = g, b.scaleY = k) : (t ? (t = b.data.scaleX, f = b.data.scaleY) : (t = b.scaleX, f = b.scaleY), v ? (g = Math.abs(g) * a.MathUtils.signum(t), k = Math.abs(k) * a.MathUtils.signum(f)) : (t = Math.abs(t) * a.MathUtils.signum(g), f = Math.abs(f) * a.MathUtils.signum(k)), b.scaleX = t + (g - t) * l, b.scaleY = f + (k - f) * l);
      }
    };
    return c;
  }(f);
  a.ScaleTimeline = k;
  f = function(a) {
    function b(b) {
      a.call(this, b);
    }
    __extends(b, a);
    b.prototype.getPropertyId = function() {
      return (l.shear << 24) + this.boneIndex;
    };
    b.prototype.apply = function(a, c, g, f, k, l, v) {
      c = this.frames;
      a = a.bones[this.boneIndex];
      if (g < c[0]) {
        l && (a.shearX = a.data.shearX, a.shearY = a.data.shearY);
      } else {
        if (g >= c[c.length - b.ENTRIES]) {
          f = c[c.length + b.PREV_X], v = c[c.length + b.PREV_Y];
        } else {
          var e = h.binarySearch(c, g, b.ENTRIES);
          f = c[e + b.PREV_X];
          v = c[e + b.PREV_Y];
          var p = c[e];
          g = this.getCurvePercent(e / b.ENTRIES - 1, 1 - (g - p) / (c[e + b.PREV_TIME] - p));
          f += (c[e + b.X] - f) * g;
          v += (c[e + b.Y] - v) * g;
        }
        l ? (a.shearX = a.data.shearX + f * k, a.shearY = a.data.shearY + v * k) : (a.shearX += (a.data.shearX + f - a.shearX) * k, a.shearY += (a.data.shearY + v - a.shearY) * k);
      }
    };
    return b;
  }(f);
  a.ShearTimeline = f;
  f = function(b) {
    function c(e) {
      b.call(this, e);
      this.frames = a.Utils.newFloatArray(e * c.ENTRIES);
    }
    __extends(c, b);
    c.prototype.getPropertyId = function() {
      return (l.color << 24) + this.slotIndex;
    };
    c.prototype.setFrame = function(a, b, g, f, k, h) {
      a *= c.ENTRIES;
      this.frames[a] = b;
      this.frames[a + c.R] = g;
      this.frames[a + c.G] = f;
      this.frames[a + c.B] = k;
      this.frames[a + c.A] = h;
    };
    c.prototype.apply = function(a, b, g, f, k, l, v) {
      a = a.slots[this.slotIndex];
      var e = this.frames;
      if (g < e[0]) {
        l && a.color.setFromColor(a.data.color);
      } else {
        var p;
        if (g >= e[e.length - c.ENTRIES]) {
          g = e.length, b = e[g + c.PREV_R], f = e[g + c.PREV_G], v = e[g + c.PREV_B], p = e[g + c.PREV_A];
        } else {
          var n = h.binarySearch(e, g, c.ENTRIES);
          b = e[n + c.PREV_R];
          f = e[n + c.PREV_G];
          v = e[n + c.PREV_B];
          p = e[n + c.PREV_A];
          var r = e[n];
          g = this.getCurvePercent(n / c.ENTRIES - 1, 1 - (g - r) / (e[n + c.PREV_TIME] - r));
          b += (e[n + c.R] - b) * g;
          f += (e[n + c.G] - f) * g;
          v += (e[n + c.B] - v) * g;
          p += (e[n + c.A] - p) * g;
        }
        1 == k ? a.color.set(b, f, v, p) : (g = a.color, l && g.setFromColor(a.data.color), g.add((b - g.r) * k, (f - g.g) * k, (v - g.b) * k, (p - g.a) * k));
      }
    };
    c.ENTRIES = 5;
    c.PREV_TIME = -5;
    c.PREV_R = -4;
    c.PREV_G = -3;
    c.PREV_B = -2;
    c.PREV_A = -1;
    c.R = 1;
    c.G = 2;
    c.B = 3;
    c.A = 4;
    return c;
  }(b);
  a.ColorTimeline = f;
  f = function() {
    function b(b) {
      this.frames = a.Utils.newFloatArray(b);
      this.attachmentNames = Array(b);
    }
    b.prototype.getPropertyId = function() {
      return (l.attachment << 24) + this.slotIndex;
    };
    b.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    b.prototype.setFrame = function(a, b, c) {
      this.frames[a] = b;
      this.attachmentNames[a] = c;
    };
    b.prototype.apply = function(a, b, c, f, k, l, t) {
      b = a.slots[this.slotIndex];
      t && l ? (c = b.data.attachmentName, b.setAttachment(null == c ? null : a.getAttachment(this.slotIndex, c))) : (t = this.frames, c < t[0] ? l && (c = b.data.attachmentName, b.setAttachment(null == c ? null : a.getAttachment(this.slotIndex, c))) : (c = c >= t[t.length - 1] ? t.length - 1 : h.binarySearch(t, c, 1) - 1, c = this.attachmentNames[c], a.slots[this.slotIndex].setAttachment(null == c ? null : a.getAttachment(this.slotIndex, c))));
    };
    return b;
  }();
  a.AttachmentTimeline = f;
  f = function(b) {
    function c(c) {
      b.call(this, c);
      this.frames = a.Utils.newFloatArray(c);
      this.frameVertices = Array(c);
    }
    __extends(c, b);
    c.prototype.getPropertyId = function() {
      return (l.deform << 24) + this.slotIndex;
    };
    c.prototype.setFrame = function(a, b, c) {
      this.frames[a] = b;
      this.frameVertices[a] = c;
    };
    c.prototype.apply = function(b, c, g, f, k, l, v) {
      b = b.slots[this.slotIndex];
      var e = b.getAttachment();
      if (e instanceof a.VertexAttachment && e.applyDeform(this.attachment)) {
        var p = this.frames;
        c = b.attachmentVertices;
        if (g < p[0]) {
          l && a.Utils.setArraySize(c, 0);
        } else {
          if (v = this.frameVertices, b = v[0].length, c.length != b && (k = 1), c = a.Utils.setArraySize(c, b), g >= p[p.length - 1]) {
            if (g = v[p.length - 1], 1 == k) {
              a.Utils.arrayCopy(g, 0, c, 0, b);
            } else {
              if (l) {
                if (l = e, null == l.bones) {
                  for (l = l.vertices, e = 0;e < b;e++) {
                    p = l[e], c[e] = p + (g[e] - p) * k;
                  }
                } else {
                  for (e = 0;e < b;e++) {
                    c[e] = g[e] * k;
                  }
                }
              } else {
                for (e = 0;e < b;e++) {
                  c[e] += (g[e] - c[e]) * k;
                }
              }
            }
          } else {
            var n = h.binarySearch(p, g);
            f = v[n - 1];
            v = v[n];
            var r = p[n];
            g = this.getCurvePercent(n - 1, 1 - (g - r) / (p[n - 1] - r));
            if (1 == k) {
              for (e = 0;e < b;e++) {
                n = f[e], c[e] = n + (v[e] - n) * g;
              }
            } else {
              if (l) {
                if (l = e, null == l.bones) {
                  for (l = l.vertices, e = 0;e < b;e++) {
                    n = f[e], p = l[e], c[e] = p + (n + (v[e] - n) * g - p) * k;
                  }
                } else {
                  for (e = 0;e < b;e++) {
                    n = f[e], c[e] = (n + (v[e] - n) * g) * k;
                  }
                }
              } else {
                for (e = 0;e < b;e++) {
                  n = f[e], c[e] += (n + (v[e] - n) * g - c[e]) * k;
                }
              }
            }
          }
        }
      }
    };
    return c;
  }(b);
  a.DeformTimeline = f;
  f = function() {
    function b(b) {
      this.frames = a.Utils.newFloatArray(b);
      this.events = Array(b);
    }
    b.prototype.getPropertyId = function() {
      return l.event << 24;
    };
    b.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    b.prototype.setFrame = function(a, b) {
      this.frames[a] = b.time;
      this.events[a] = b;
    };
    b.prototype.apply = function(a, b, c, f, k, l, t) {
      if (null != f) {
        var e = this.frames, g = this.frames.length;
        if (b > c) {
          this.apply(a, b, Number.MAX_VALUE, f, k, l, t), b = -1;
        } else {
          if (b >= e[g - 1]) {
            return;
          }
        }
        if (!(c < e[0])) {
          if (b < e[0]) {
            a = 0;
          } else {
            for (a = h.binarySearch(e, b), b = e[a];0 < a && e[a - 1] == b;) {
              a--;
            }
          }
          for (;a < g && c >= e[a];a++) {
            f.push(this.events[a]);
          }
        }
      }
    };
    return b;
  }();
  a.EventTimeline = f;
  f = function() {
    function b(b) {
      this.frames = a.Utils.newFloatArray(b);
      this.drawOrders = Array(b);
    }
    b.prototype.getPropertyId = function() {
      return l.drawOrder << 24;
    };
    b.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    b.prototype.setFrame = function(a, b, c) {
      this.frames[a] = b;
      this.drawOrders[a] = c;
    };
    b.prototype.apply = function(b, c, f, k, l, n, t) {
      c = b.drawOrder;
      k = b.slots;
      if (t && n) {
        a.Utils.arrayCopy(b.slots, 0, b.drawOrder, 0, b.slots.length);
      } else {
        if (t = this.frames, f < t[0]) {
          n && a.Utils.arrayCopy(b.slots, 0, b.drawOrder, 0, b.slots.length);
        } else {
          if (b = f >= t[t.length - 1] ? t.length - 1 : h.binarySearch(t, f) - 1, b = this.drawOrders[b], null == b) {
            a.Utils.arrayCopy(k, 0, c, 0, k.length);
          } else {
            for (f = 0, n = b.length;f < n;f++) {
              c[f] = k[b[f]];
            }
          }
        }
      }
    };
    return b;
  }();
  a.DrawOrderTimeline = f;
  f = function(b) {
    function c(e) {
      b.call(this, e);
      this.frames = a.Utils.newFloatArray(e * c.ENTRIES);
    }
    __extends(c, b);
    c.prototype.getPropertyId = function() {
      return (l.ikConstraint << 24) + this.ikConstraintIndex;
    };
    c.prototype.setFrame = function(a, b, g, f) {
      a *= c.ENTRIES;
      this.frames[a] = b;
      this.frames[a + c.MIX] = g;
      this.frames[a + c.BEND_DIRECTION] = f;
    };
    c.prototype.apply = function(a, b, g, f, k, l, v) {
      b = this.frames;
      a = a.ikConstraints[this.ikConstraintIndex];
      if (g < b[0]) {
        l && (a.mix = a.data.mix, a.bendDirection = a.data.bendDirection);
      } else {
        if (g >= b[b.length - c.ENTRIES]) {
          l ? (a.mix = a.data.mix + (b[b.length + c.PREV_MIX] - a.data.mix) * k, a.bendDirection = v ? a.data.bendDirection : b[b.length + c.PREV_BEND_DIRECTION]) : (a.mix += (b[b.length + c.PREV_MIX] - a.mix) * k, v || (a.bendDirection = b[b.length + c.PREV_BEND_DIRECTION]));
        } else {
          f = h.binarySearch(b, g, c.ENTRIES);
          var e = b[f + c.PREV_MIX], p = b[f];
          g = this.getCurvePercent(f / c.ENTRIES - 1, 1 - (g - p) / (b[f + c.PREV_TIME] - p));
          l ? (a.mix = a.data.mix + (e + (b[f + c.MIX] - e) * g - a.data.mix) * k, a.bendDirection = v ? a.data.bendDirection : b[f + c.PREV_BEND_DIRECTION]) : (a.mix += (e + (b[f + c.MIX] - e) * g - a.mix) * k, v || (a.bendDirection = b[f + c.PREV_BEND_DIRECTION]));
        }
      }
    };
    c.ENTRIES = 3;
    c.PREV_TIME = -3;
    c.PREV_MIX = -2;
    c.PREV_BEND_DIRECTION = -1;
    c.MIX = 1;
    c.BEND_DIRECTION = 2;
    return c;
  }(b);
  a.IkConstraintTimeline = f;
  f = function(b) {
    function c(e) {
      b.call(this, e);
      this.frames = a.Utils.newFloatArray(e * c.ENTRIES);
    }
    __extends(c, b);
    c.prototype.getPropertyId = function() {
      return (l.transformConstraint << 24) + this.transformConstraintIndex;
    };
    c.prototype.setFrame = function(a, b, g, f, k, h) {
      a *= c.ENTRIES;
      this.frames[a] = b;
      this.frames[a + c.ROTATE] = g;
      this.frames[a + c.TRANSLATE] = f;
      this.frames[a + c.SCALE] = k;
      this.frames[a + c.SHEAR] = h;
    };
    c.prototype.apply = function(a, b, g, f, k, l, v) {
      b = this.frames;
      a = a.transformConstraints[this.transformConstraintIndex];
      if (g < b[0]) {
        l && (l = a.data, a.rotateMix = l.rotateMix, a.translateMix = l.rotateMix, a.scaleMix = l.scaleMix, a.shearMix = l.shearMix);
      } else {
        var e, p;
        if (g >= b[b.length - c.ENTRIES]) {
          g = b.length, f = b[g + c.PREV_ROTATE], v = b[g + c.PREV_TRANSLATE], e = b[g + c.PREV_SCALE], p = b[g + c.PREV_SHEAR];
        } else {
          var n = h.binarySearch(b, g, c.ENTRIES);
          f = b[n + c.PREV_ROTATE];
          v = b[n + c.PREV_TRANSLATE];
          e = b[n + c.PREV_SCALE];
          p = b[n + c.PREV_SHEAR];
          var r = b[n];
          g = this.getCurvePercent(n / c.ENTRIES - 1, 1 - (g - r) / (b[n + c.PREV_TIME] - r));
          f += (b[n + c.ROTATE] - f) * g;
          v += (b[n + c.TRANSLATE] - v) * g;
          e += (b[n + c.SCALE] - e) * g;
          p += (b[n + c.SHEAR] - p) * g;
        }
        l ? (l = a.data, a.rotateMix = l.rotateMix + (f - l.rotateMix) * k, a.translateMix = l.translateMix + (v - l.translateMix) * k, a.scaleMix = l.scaleMix + (e - l.scaleMix) * k, a.shearMix = l.shearMix + (p - l.shearMix) * k) : (a.rotateMix += (f - a.rotateMix) * k, a.translateMix += (v - a.translateMix) * k, a.scaleMix += (e - a.scaleMix) * k, a.shearMix += (p - a.shearMix) * k);
      }
    };
    c.ENTRIES = 5;
    c.PREV_TIME = -5;
    c.PREV_ROTATE = -4;
    c.PREV_TRANSLATE = -3;
    c.PREV_SCALE = -2;
    c.PREV_SHEAR = -1;
    c.ROTATE = 1;
    c.TRANSLATE = 2;
    c.SCALE = 3;
    c.SHEAR = 4;
    return c;
  }(b);
  a.TransformConstraintTimeline = f;
  f = function(b) {
    function c(e) {
      b.call(this, e);
      this.frames = a.Utils.newFloatArray(e * c.ENTRIES);
    }
    __extends(c, b);
    c.prototype.getPropertyId = function() {
      return (l.pathConstraintPosition << 24) + this.pathConstraintIndex;
    };
    c.prototype.setFrame = function(a, b, g) {
      a *= c.ENTRIES;
      this.frames[a] = b;
      this.frames[a + c.VALUE] = g;
    };
    c.prototype.apply = function(a, b, g, f, k, l, v) {
      b = this.frames;
      a = a.pathConstraints[this.pathConstraintIndex];
      if (g < b[0]) {
        l && (a.position = a.data.position);
      } else {
        if (g >= b[b.length - c.ENTRIES]) {
          f = b[b.length + c.PREV_VALUE];
        } else {
          v = h.binarySearch(b, g, c.ENTRIES);
          f = b[v + c.PREV_VALUE];
          var e = b[v];
          g = this.getCurvePercent(v / c.ENTRIES - 1, 1 - (g - e) / (b[v + c.PREV_TIME] - e));
          f += (b[v + c.VALUE] - f) * g;
        }
        a.position = l ? a.data.position + (f - a.data.position) * k : a.position + (f - a.position) * k;
      }
    };
    c.ENTRIES = 2;
    c.PREV_TIME = -2;
    c.PREV_VALUE = -1;
    c.VALUE = 1;
    return c;
  }(b);
  a.PathConstraintPositionTimeline = f;
  f = function(a) {
    function b(b) {
      a.call(this, b);
    }
    __extends(b, a);
    b.prototype.getPropertyId = function() {
      return (l.pathConstraintSpacing << 24) + this.pathConstraintIndex;
    };
    b.prototype.apply = function(a, c, g, f, k, l, v) {
      c = this.frames;
      a = a.pathConstraints[this.pathConstraintIndex];
      if (g < c[0]) {
        l && (a.spacing = a.data.spacing);
      } else {
        if (g >= c[c.length - b.ENTRIES]) {
          f = c[c.length + b.PREV_VALUE];
        } else {
          v = h.binarySearch(c, g, b.ENTRIES);
          f = c[v + b.PREV_VALUE];
          var e = c[v];
          g = this.getCurvePercent(v / b.ENTRIES - 1, 1 - (g - e) / (c[v + b.PREV_TIME] - e));
          f += (c[v + b.VALUE] - f) * g;
        }
        a.spacing = l ? a.data.spacing + (f - a.data.spacing) * k : a.spacing + (f - a.spacing) * k;
      }
    };
    return b;
  }(f);
  a.PathConstraintSpacingTimeline = f;
  b = function(b) {
    function c(e) {
      b.call(this, e);
      this.frames = a.Utils.newFloatArray(e * c.ENTRIES);
    }
    __extends(c, b);
    c.prototype.getPropertyId = function() {
      return (l.pathConstraintMix << 24) + this.pathConstraintIndex;
    };
    c.prototype.setFrame = function(a, b, g, f) {
      a *= c.ENTRIES;
      this.frames[a] = b;
      this.frames[a + c.ROTATE] = g;
      this.frames[a + c.TRANSLATE] = f;
    };
    c.prototype.apply = function(a, b, g, f, k, l, v) {
      b = this.frames;
      a = a.pathConstraints[this.pathConstraintIndex];
      if (g < b[0]) {
        l && (a.rotateMix = a.data.rotateMix, a.translateMix = a.data.translateMix);
      } else {
        if (g >= b[b.length - c.ENTRIES]) {
          f = b[b.length + c.PREV_ROTATE], v = b[b.length + c.PREV_TRANSLATE];
        } else {
          var e = h.binarySearch(b, g, c.ENTRIES);
          f = b[e + c.PREV_ROTATE];
          v = b[e + c.PREV_TRANSLATE];
          var p = b[e];
          g = this.getCurvePercent(e / c.ENTRIES - 1, 1 - (g - p) / (b[e + c.PREV_TIME] - p));
          f += (b[e + c.ROTATE] - f) * g;
          v += (b[e + c.TRANSLATE] - v) * g;
        }
        l ? (a.rotateMix = a.data.rotateMix + (f - a.data.rotateMix) * k, a.translateMix = a.data.translateMix + (v - a.data.translateMix) * k) : (a.rotateMix += (f - a.rotateMix) * k, a.translateMix += (v - a.translateMix) * k);
      }
    };
    c.ENTRIES = 3;
    c.PREV_TIME = -3;
    c.PREV_ROTATE = -2;
    c.PREV_TRANSLATE = -1;
    c.ROTATE = 1;
    c.TRANSLATE = 2;
    return c;
  }(b);
  a.PathConstraintMixTimeline = b;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function f(c) {
      this.tracks = [];
      this.events = [];
      this.listeners = [];
      this.queue = new b(this);
      this.propertyIDs = new a.IntSet;
      this.animationsChanged = !1;
      this.timeScale = 1;
      this.trackEntryPool = new a.Pool(function() {
        return new l;
      });
      this.data = c;
    }
    f.prototype.update = function(a) {
      a *= this.timeScale;
      for (var b = this.tracks, c = 0, f = b.length;c < f;c++) {
        var k = b[c];
        if (null != k) {
          k.animationLast = k.nextAnimationLast;
          k.trackLast = k.nextTrackLast;
          var h = a * k.timeScale;
          if (0 < k.delay) {
            k.delay -= h;
            if (0 < k.delay) {
              continue;
            }
            h = -k.delay;
            k.delay = 0;
          }
          var l = k.next;
          if (null != l) {
            var t = k.trackLast - l.delay;
            if (0 <= t) {
              l.delay = 0;
              l.trackTime = t + a * l.timeScale;
              k.trackTime += h;
              for (this.setCurrent(c, l);null != l.mixingFrom;) {
                l.mixTime += h, l = l.mixingFrom;
              }
              continue;
            }
          } else {
            if (k.trackLast >= k.trackEnd && null == k.mixingFrom) {
              b[c] = null;
              this.queue.end(k);
              this.disposeNext(k);
              continue;
            }
          }
          this.updateMixingFrom(k, a);
          k.trackTime += h;
        }
      }
      this.queue.drain();
    };
    f.prototype.updateMixingFrom = function(a, b) {
      var c = a.mixingFrom;
      null != c && (this.updateMixingFrom(c, b), a.mixTime >= a.mixDuration && null != c.mixingFrom && 0 < a.mixTime ? (a.mixingFrom = null, this.queue.end(c)) : (c.animationLast = c.nextAnimationLast, c.trackLast = c.nextTrackLast, c.trackTime += b * c.timeScale, a.mixTime += b * c.timeScale));
    };
    f.prototype.apply = function(b) {
      if (null == b) {
        throw Error("skeleton cannot be null.");
      }
      this.animationsChanged && this._animationsChanged();
      for (var c = this.events, e = this.tracks, f = 0, k = e.length;f < k;f++) {
        var h = e[f];
        if (!(null == h || 0 < h.delay)) {
          var l = h.alpha;
          null != h.mixingFrom ? l *= this.applyMixingFrom(h, b) : h.trackTime >= h.trackEnd && (l = 0);
          var t = h.animationLast, v = h.getAnimationTime(), y = h.animation.timelines.length, x = h.animation.timelines;
          if (1 == l) {
            for (var q = 0;q < y;q++) {
              x[q].apply(b, t, v, c, 1, !0, !1);
            }
          } else {
            var u = 0 == h.timelinesRotation.length;
            u && a.Utils.setArraySize(h.timelinesRotation, y << 1, null);
            for (var B = h.timelinesRotation, C = h.timelinesFirst, q = 0;q < y;q++) {
              var D = x[q];
              D instanceof a.RotateTimeline ? this.applyRotateTimeline(D, b, v, l, C[q], B, q << 1, u) : D.apply(b, t, v, c, l, C[q], !1);
            }
          }
          this.queueEvents(h, v);
          h.nextAnimationLast = v;
          h.nextTrackLast = h.trackTime;
        }
      }
      this.queue.drain();
    };
    f.prototype.applyMixingFrom = function(b, g) {
      var c = b.mixingFrom;
      null != c.mixingFrom && this.applyMixingFrom(c, g);
      var f;
      0 == b.mixDuration ? f = 1 : (f = b.mixTime / b.mixDuration, 1 < f && (f = 1));
      var k = f < c.eventThreshold ? this.events : null, h = f < c.attachmentThreshold, l = f < c.drawOrderThreshold, t = c.animationLast, v = c.getAnimationTime(), y = c.animation.timelines.length, x = c.animation.timelines, q = c.timelinesFirst;
      b = c.alpha * b.mixAlpha * (1 - f);
      var u = 0 == c.timelinesRotation.length;
      u && a.Utils.setArraySize(c.timelinesRotation, y << 1, null);
      for (var B = c.timelinesRotation, C = 0;C < y;C++) {
        var D = x[C], F = q[C];
        if (D instanceof a.RotateTimeline) {
          this.applyRotateTimeline(D, g, v, b, F, B, C << 1, u);
        } else {
          if (!F) {
            if (!h && D instanceof a.AttachmentTimeline) {
              continue;
            }
            if (!l && D instanceof a.DrawOrderTimeline) {
              continue;
            }
          }
          D.apply(g, t, v, k, b, F, !0);
        }
      }
      this.queueEvents(c, v);
      c.nextAnimationLast = v;
      c.nextTrackLast = c.trackTime;
      return f;
    };
    f.prototype.applyRotateTimeline = function(b, g, e, f, k, h, l, t) {
      if (1 == f) {
        b.apply(g, 0, e, null, 1, k, !1);
      } else {
        var c = b.frames;
        g = g.bones[b.boneIndex];
        if (e < c[0]) {
          k && (g.rotation = g.data.rotation);
        } else {
          if (e >= c[c.length - a.RotateTimeline.ENTRIES]) {
            c = g.data.rotation + c[c.length + a.RotateTimeline.PREV_ROTATION];
          } else {
            var p = a.Animation.binarySearch(c, e, a.RotateTimeline.ENTRIES), n = c[p + a.RotateTimeline.PREV_ROTATION], r = c[p];
            b = b.getCurvePercent((p >> 1) - 1, 1 - (e - r) / (c[p + a.RotateTimeline.PREV_TIME] - r));
            c = c[p + a.RotateTimeline.ROTATION] - n;
            c = n + (c - 360 * (16384 - (16384.499999999996 - c / 360 | 0))) * b + g.data.rotation;
            c -= 360 * (16384 - (16384.499999999996 - c / 360 | 0));
          }
          k = k ? g.data.rotation : g.rotation;
          c -= k;
          0 == c ? e = t ? h[l] = 0 : h[l] : (c -= 360 * (16384 - (16384.499999999996 - c / 360 | 0)), t ? (t = 0, e = c) : (t = h[l], e = h[l + 1]), n = 0 < c, b = 0 <= t, a.MathUtils.signum(e) != a.MathUtils.signum(c) && 90 >= Math.abs(e) && (180 < Math.abs(t) && (t += 360 * a.MathUtils.signum(t)), b = n), e = c + t - t % 360, b != n && (e += 360 * a.MathUtils.signum(t)), h[l] = e);
          h[l + 1] = c;
          k += e * f;
          g.rotation = k - 360 * (16384 - (16384.499999999996 - k / 360 | 0));
        }
      }
    };
    f.prototype.queueEvents = function(a, b) {
      for (var c = a.animationStart, g = a.animationEnd, f = g - c, k = a.trackLast % f, h = this.events, l = 0, v = h.length;l < v;l++) {
        var y = h[l];
        if (y.time < k) {
          break;
        }
        y.time > g || this.queue.event(a, y);
      }
      for ((a.loop ? k > a.trackTime % f : b >= g && a.animationLast < g) && this.queue.complete(a);l < v;l++) {
        h[l].time < c || this.queue.event(a, h[l]);
      }
      this.events.length = 0;
    };
    f.prototype.clearTracks = function() {
      this.queue.drainDisabled = !0;
      for (var a = 0, b = this.tracks.length;a < b;a++) {
        this.clearTrack(a);
      }
      this.tracks.length = 0;
      this.queue.drainDisabled = !1;
      this.queue.drain();
    };
    f.prototype.clearTrack = function(a) {
      if (!(a >= this.tracks.length) && (a = this.tracks[a], null != a)) {
        this.queue.end(a);
        this.disposeNext(a);
        for (var b = a;;) {
          var c = b.mixingFrom;
          if (null == c) {
            break;
          }
          this.queue.end(c);
          b.mixingFrom = null;
          b = c;
        }
        this.tracks[a.trackIndex] = null;
        this.queue.drain();
      }
    };
    f.prototype.setCurrent = function(a, b) {
      var c = this.expandToIndex(a);
      this.tracks[a] = b;
      null != c && (this.queue.interrupt(c), b.mixingFrom = c, b.mixTime = 0, null != c.mixingFrom && (b.mixAlpha *= Math.min(c.mixTime / c.mixDuration, 1)));
      this.queue.start(b);
    };
    f.prototype.setAnimation = function(a, b, e) {
      var c = this.data.skeletonData.findAnimation(b);
      if (null == c) {
        throw Error("Animation not found: " + b);
      }
      return this.setAnimationWith(a, c, e);
    };
    f.prototype.setAnimationWith = function(a, b, e) {
      if (null == b) {
        throw Error("animation cannot be null.");
      }
      var c = this.expandToIndex(a);
      null != c && (-1 == c.nextTrackLast ? (this.tracks[a] = c.mixingFrom, this.queue.interrupt(c), this.queue.end(c), this.disposeNext(c), c = c.mixingFrom) : this.disposeNext(c));
      b = this.trackEntry(a, b, e, c);
      this.setCurrent(a, b);
      this.queue.drain();
      return b;
    };
    f.prototype.addAnimation = function(a, b, e, f) {
      var c = this.data.skeletonData.findAnimation(b);
      if (null == c) {
        throw Error("Animation not found: " + b);
      }
      return this.addAnimationWith(a, c, e, f);
    };
    f.prototype.addAnimationWith = function(a, b, e, f) {
      if (null == b) {
        throw Error("animation cannot be null.");
      }
      var c = this.expandToIndex(a);
      if (null != c) {
        for (;null != c.next;) {
          c = c.next;
        }
      }
      e = this.trackEntry(a, b, e, c);
      null == c ? (this.setCurrent(a, e), this.queue.drain()) : (c.next = e, 0 >= f && (a = c.animationEnd - c.animationStart, f = 0 != a ? f + (a * (1 + (c.trackTime / a | 0)) - this.data.getMix(c.animation, b)) : 0));
      e.delay = f;
      return e;
    };
    f.prototype.setEmptyAnimation = function(a, b) {
      a = this.setAnimationWith(a, f.emptyAnimation, !1);
      a.mixDuration = b;
      a.trackEnd = b;
      return a;
    };
    f.prototype.addEmptyAnimation = function(a, b, e) {
      0 >= e && (e -= b);
      a = this.addAnimationWith(a, f.emptyAnimation, !1, e);
      a.mixDuration = b;
      a.trackEnd = b;
      return a;
    };
    f.prototype.setEmptyAnimations = function(a) {
      this.queue.drainDisabled = !0;
      for (var b = 0, c = this.tracks.length;b < c;b++) {
        var f = this.tracks[b];
        null != f && this.setEmptyAnimation(f.trackIndex, a);
      }
      this.queue.drainDisabled = !1;
      this.queue.drain();
    };
    f.prototype.expandToIndex = function(b) {
      if (b < this.tracks.length) {
        return this.tracks[b];
      }
      a.Utils.ensureArrayCapacity(this.tracks, b - this.tracks.length + 1, null);
      this.tracks.length = b + 1;
      return null;
    };
    f.prototype.trackEntry = function(a, b, e, f) {
      var c = this.trackEntryPool.obtain();
      c.trackIndex = a;
      c.animation = b;
      c.loop = e;
      c.eventThreshold = 0;
      c.attachmentThreshold = 0;
      c.drawOrderThreshold = 0;
      c.animationStart = 0;
      c.animationEnd = b.duration;
      c.animationLast = -1;
      c.nextAnimationLast = -1;
      c.delay = 0;
      c.trackTime = 0;
      c.trackLast = -1;
      c.nextTrackLast = -1;
      c.trackEnd = e ? Number.MAX_VALUE : c.animationEnd;
      c.timeScale = 1;
      c.alpha = 1;
      c.mixAlpha = 1;
      c.mixTime = 0;
      c.mixDuration = null == f ? 0 : this.data.getMix(f.animation, b);
      return c;
    };
    f.prototype.disposeNext = function(a) {
      for (var b = a.next;null != b;) {
        this.queue.dispose(b), b = b.next;
      }
      a.next = null;
    };
    f.prototype._animationsChanged = function() {
      this.animationsChanged = !1;
      var a = 0, b = this.tracks.length;
      for (this.propertyIDs.clear();a < b;a++) {
        var e = this.tracks[a];
        if (null != e) {
          this.setTimelinesFirst(e);
          a++;
          break;
        }
      }
      for (;a < b;a++) {
        e = this.tracks[a], null != e && this.checkTimelinesFirst(e);
      }
    };
    f.prototype.setTimelinesFirst = function(b) {
      if (null != b.mixingFrom) {
        this.setTimelinesFirst(b.mixingFrom), this.checkTimelinesUsage(b, b.timelinesFirst);
      } else {
        var c = this.propertyIDs, e = b.animation.timelines, f = e.length;
        b = a.Utils.setArraySize(b.timelinesFirst, f, !1);
        for (var k = 0;k < f;k++) {
          c.add(e[k].getPropertyId()), b[k] = !0;
        }
      }
    };
    f.prototype.checkTimelinesFirst = function(a) {
      null != a.mixingFrom && this.checkTimelinesFirst(a.mixingFrom);
      this.checkTimelinesUsage(a, a.timelinesFirst);
    };
    f.prototype.checkTimelinesUsage = function(b, f) {
      var c = this.propertyIDs;
      b = b.animation.timelines;
      var g = b.length;
      f = a.Utils.setArraySize(f, g);
      for (var k = 0;k < g;k++) {
        f[k] = c.add(b[k].getPropertyId());
      }
    };
    f.prototype.getCurrent = function(a) {
      return a >= this.tracks.length ? null : this.tracks[a];
    };
    f.prototype.addListener = function(a) {
      if (null == a) {
        throw Error("listener cannot be null.");
      }
      this.listeners.push(a);
    };
    f.prototype.removeListener = function(a) {
      a = this.listeners.indexOf(a);
      0 <= a && this.listeners.splice(a, 1);
    };
    f.prototype.clearListeners = function() {
      this.listeners.length = 0;
    };
    f.prototype.clearListenerNotifications = function() {
      this.queue.clear();
    };
    f.emptyAnimation = new a.Animation("<empty>", [], 0);
    return f;
  }();
  a.AnimationState = h;
  var l = function() {
    function a() {
      this.timelinesFirst = [];
      this.timelinesRotation = [];
    }
    a.prototype.reset = function() {
      this.listener = this.animation = this.mixingFrom = this.next = null;
      this.timelinesFirst.length = 0;
      this.timelinesRotation.length = 0;
    };
    a.prototype.getAnimationTime = function() {
      if (this.loop) {
        var a = this.animationEnd - this.animationStart;
        return 0 == a ? this.animationStart : this.trackTime % a + this.animationStart;
      }
      return Math.min(this.trackTime + this.animationStart, this.animationEnd);
    };
    a.prototype.setAnimationLast = function(a) {
      this.nextAnimationLast = this.animationLast = a;
    };
    a.prototype.isComplete = function() {
      return this.trackTime >= this.animationEnd - this.animationStart;
    };
    a.prototype.resetRotationDirections = function() {
      this.timelinesRotation.length = 0;
    };
    return a;
  }();
  a.TrackEntry = l;
  var b = function() {
    function a(a) {
      this.objects = [];
      this.drainDisabled = !1;
      this.animState = a;
    }
    a.prototype.start = function(a) {
      this.objects.push(f.start);
      this.objects.push(a);
      this.animState.animationsChanged = !0;
    };
    a.prototype.interrupt = function(a) {
      this.objects.push(f.interrupt);
      this.objects.push(a);
    };
    a.prototype.end = function(a) {
      this.objects.push(f.end);
      this.objects.push(a);
      this.animState.animationsChanged = !0;
    };
    a.prototype.dispose = function(a) {
      this.objects.push(f.dispose);
      this.objects.push(a);
    };
    a.prototype.complete = function(a) {
      this.objects.push(f.complete);
      this.objects.push(a);
    };
    a.prototype.event = function(a, b) {
      this.objects.push(f.event);
      this.objects.push(a);
      this.objects.push(b);
    };
    a.prototype.drain = function() {
      if (!this.drainDisabled) {
        this.drainDisabled = !0;
        for (var a = this.objects, b = this.animState.listeners, e = 0;e < a.length;e += 2) {
          var k = a[e + 1];
          switch(a[e]) {
            case f.start:
              null != k.listener && k.listener.start && k.listener.start(k);
              for (var h = 0;h < b.length;h++) {
                b[h].start && b[h].start(k);
              }
              break;
            case f.interrupt:
              null != k.listener && k.listener.interrupt && k.listener.interrupt(k);
              for (h = 0;h < b.length;h++) {
                b[h].interrupt && b[h].interrupt(k);
              }
              break;
            case f.end:
              for (null != k.listener && k.listener.end && k.listener.end(k), h = 0;h < b.length;h++) {
                b[h].end && b[h].end(k);
              }
            case f.dispose:
              null != k.listener && k.listener.dispose && k.listener.dispose(k);
              for (h = 0;h < b.length;h++) {
                b[h].dispose && b[h].dispose(k);
              }
              this.animState.trackEntryPool.free(k);
              break;
            case f.complete:
              null != k.listener && k.listener.complete && k.listener.complete(k);
              for (h = 0;h < b.length;h++) {
                b[h].complete && b[h].complete(k);
              }
              break;
            case f.event:
              var l = a[e++ + 2];
              null != k.listener && k.listener.event && k.listener.event(k, l);
              for (h = 0;h < b.length;h++) {
                b[h].event && b[h].event(k, l);
              }
          }
        }
        this.clear();
        this.drainDisabled = !1;
      }
    };
    a.prototype.clear = function() {
      this.objects.length = 0;
    };
    return a;
  }();
  a.EventQueue = b;
  (function(a) {
    a[a.start = 0] = "start";
    a[a.interrupt = 1] = "interrupt";
    a[a.end = 2] = "end";
    a[a.dispose = 3] = "dispose";
    a[a.complete = 4] = "complete";
    a[a.event = 5] = "event";
  })(a.EventType || (a.EventType = {}));
  var f = a.EventType, h = function() {
    function a() {
    }
    a.prototype.start = function(a) {
    };
    a.prototype.interrupt = function(a) {
    };
    a.prototype.end = function(a) {
    };
    a.prototype.dispose = function(a) {
    };
    a.prototype.complete = function(a) {
    };
    a.prototype.event = function(a, b) {
    };
    return a;
  }();
  a.AnimationStateAdapter2 = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function a(a) {
      this.animationToMixTime = {};
      this.defaultMix = 0;
      if (null == a) {
        throw Error("skeletonData cannot be null.");
      }
      this.skeletonData = a;
    }
    a.prototype.setMix = function(a, f, k) {
      var b = this.skeletonData.findAnimation(a);
      if (null == b) {
        throw Error("Animation not found: " + a);
      }
      a = this.skeletonData.findAnimation(f);
      if (null == a) {
        throw Error("Animation not found: " + f);
      }
      this.setMixWith(b, a, k);
    };
    a.prototype.setMixWith = function(a, f, k) {
      if (null == a) {
        throw Error("from cannot be null.");
      }
      if (null == f) {
        throw Error("to cannot be null.");
      }
      this.animationToMixTime[a.name + f.name] = k;
    };
    a.prototype.getMix = function(a, f) {
      a = this.animationToMixTime[a.name + f.name];
      return void 0 === a ? this.defaultMix : a;
    };
    return a;
  }();
  a.AnimationStateData = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function a(a, f) {
      void 0 === f && (f = "");
      this.assets = {};
      this.errors = {};
      this.loaded = this.toLoad = 0;
      this.textureLoader = a;
      this.pathPrefix = f;
    }
    a.prototype.loadText = function(a, f, k) {
      var b = this;
      void 0 === f && (f = null);
      void 0 === k && (k = null);
      a = this.pathPrefix + a;
      this.toLoad++;
      var g = new XMLHttpRequest;
      g.onreadystatechange = function() {
        g.readyState == XMLHttpRequest.DONE && (200 <= g.status && 300 > g.status ? (b.assets[a] = g.responseText, f && f(a, g.responseText)) : (b.errors[a] = "Couldn't load text " + a + ": status " + g.status + ", " + g.responseText, k && k(a, "Couldn't load text " + a + ": status " + g.status + ", " + g.responseText)), b.toLoad--, b.loaded++);
      };
      g.open("GET", a, !0);
      g.send();
    };
    a.prototype.loadTexture = function(a, f, k) {
      var b = this;
      void 0 === f && (f = null);
      void 0 === k && (k = null);
      a = this.pathPrefix + a;
      this.toLoad++;
      var g = new Image;
      g.crossOrigin = "anonymous";
      g.src = a;
      g.onload = function(c) {
        c = b.textureLoader(g);
        b.assets[a] = c;
        b.toLoad--;
        b.loaded++;
        f && f(a, g);
      };
      g.onerror = function(c) {
        b.errors[a] = "Couldn't load image " + a;
        b.toLoad--;
        b.loaded++;
        k && k(a, "Couldn't load image " + a);
      };
    };
    a.prototype.get = function(a) {
      a = this.pathPrefix + a;
      return this.assets[a];
    };
    a.prototype.remove = function(a) {
      a = this.pathPrefix + a;
      var b = this.assets[a];
      b.dispose && b.dispose();
      this.assets[a] = null;
    };
    a.prototype.removeAll = function() {
      for (var a in this.assets) {
        var f = this.assets[a];
        f.dispose && f.dispose();
      }
      this.assets = {};
    };
    a.prototype.isLoadingComplete = function() {
      return 0 == this.toLoad;
    };
    a.prototype.getToLoad = function() {
      return this.toLoad;
    };
    a.prototype.getLoaded = function() {
      return this.loaded;
    };
    a.prototype.dispose = function() {
      this.removeAll();
    };
    a.prototype.hasErrors = function() {
      return 0 < Object.keys(this.errors).length;
    };
    a.prototype.getErrors = function() {
      return this.errors;
    };
    return a;
  }();
  a.AssetManager = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function h(a) {
      this.atlas = a;
    }
    h.prototype.newRegionAttachment = function(b, f, k) {
      b = this.atlas.findRegion(k);
      if (null == b) {
        throw Error("Region not found in atlas: " + k + " (region attachment: " + f + ")");
      }
      b.renderObject = b;
      f = new a.RegionAttachment(f);
      f.setRegion(b);
      return f;
    };
    h.prototype.newMeshAttachment = function(b, f, k) {
      b = this.atlas.findRegion(k);
      if (null == b) {
        throw Error("Region not found in atlas: " + k + " (mesh attachment: " + f + ")");
      }
      b.renderObject = b;
      f = new a.MeshAttachment(f);
      f.region = b;
      return f;
    };
    h.prototype.newBoundingBoxAttachment = function(b, f) {
      return new a.BoundingBoxAttachment(f);
    };
    h.prototype.newPathAttachment = function(b, f) {
      return new a.PathAttachment(f);
    };
    return h;
  }();
  a.AtlasAttachmentLoader = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    return function(a) {
      if (null == a) {
        throw Error("name cannot be null.");
      }
      this.name = a;
    };
  }();
  a.Attachment = h;
  h = function(a) {
    function b(b) {
      a.call(this, b);
      this.worldVerticesLength = 0;
    }
    __extends(b, a);
    b.prototype.computeWorldVertices = function(a, b) {
      this.computeWorldVerticesWith(a, 0, this.worldVerticesLength, b, 0);
    };
    b.prototype.computeWorldVerticesWith = function(a, b, c, g, e) {
      c += e;
      var f = a.bone.skeleton, k = a.attachmentVertices, h = this.vertices, l = this.bones;
      if (null == l) {
        0 < k.length && (h = k);
        a = a.bone;
        var k = a.worldX, l = a.worldY, t = a.a, f = a.b, v = a.c;
        a = a.d;
        for (var y = b;e < c;y += 2, e += 2) {
          b = h[y];
          var x = h[y + 1];
          g[e] = b * t + x * f + k;
          g[e + 1] = b * v + x * a + l;
        }
      } else {
        for (x = a = t = 0;x < b;x += 2) {
          v = l[t], t += v + 1, a += v;
        }
        y = f.bones;
        if (0 == k.length) {
          for (f = 3 * a;e < c;e += 2) {
            for (var q = 0, u = 0, v = l[t++], v = v + t;t < v;t++, f += 3) {
              a = y[l[t]];
              b = h[f];
              var x = h[f + 1], B = h[f + 2], q = q + (b * a.a + x * a.b + a.worldX) * B, u = u + (b * a.c + x * a.d + a.worldY) * B;
            }
            g[e] = q;
            g[e + 1] = u;
          }
        } else {
          for (var f = 3 * a, C = a << 1;e < c;e += 2) {
            u = q = 0;
            v = l[t++];
            for (v += t;t < v;t++, f += 3, C += 2) {
              a = y[l[t]], b = h[f] + k[C], x = h[f + 1] + k[C + 1], B = h[f + 2], q += (b * a.a + x * a.b + a.worldX) * B, u += (b * a.c + x * a.d + a.worldY) * B;
            }
            g[e] = q;
            g[e + 1] = u;
          }
        }
      }
    };
    b.prototype.applyDeform = function(a) {
      return this == a;
    };
    return b;
  }(h);
  a.VertexAttachment = h;
})(spine || (spine = {}));
(function(a) {
  a = a.AttachmentType || (a.AttachmentType = {});
  a[a.Region = 0] = "Region";
  a[a.BoundingBox = 1] = "BoundingBox";
  a[a.Mesh = 2] = "Mesh";
  a[a.LinkedMesh = 3] = "LinkedMesh";
  a[a.Path = 4] = "Path";
})(spine || (spine = {}));
(function(a) {
  var h = function(h) {
    function b(b) {
      h.call(this, b);
      this.color = new a.Color(1, 1, 1, 1);
    }
    __extends(b, h);
    return b;
  }(a.VertexAttachment);
  a.BoundingBoxAttachment = h;
})(spine || (spine = {}));
(function(a) {
  var h = function(h) {
    function b(b) {
      h.call(this, b);
      this.color = new a.Color(1, 1, 1, 1);
      this.inheritDeform = !1;
      this.tempColor = new a.Color(0, 0, 0, 0);
    }
    __extends(b, h);
    b.prototype.updateUVs = function() {
      var b = this.regionUVs, k = b.length, c = 8 * (k >> 1);
      if (null == this.worldVertices || this.worldVertices.length != c) {
        this.worldVertices = a.Utils.newFloatArray(c);
      }
      var g, e, h;
      null == this.region ? (c = g = 0, e = h = 1) : (c = this.region.u, g = this.region.v, e = this.region.u2 - c, h = this.region.v2 - g);
      if (this.region.rotate) {
        for (var l = 0, w = 6;l < k;l += 2, w += 8) {
          this.worldVertices[w] = c + b[l + 1] * e, this.worldVertices[w + 1] = g + h - b[l] * h;
        }
      } else {
        for (l = 0, w = 6;l < k;l += 2, w += 8) {
          this.worldVertices[w] = c + b[l] * e, this.worldVertices[w + 1] = g + b[l + 1] * h;
        }
      }
    };
    b.prototype.updateWorldVertices = function(a, b) {
      var c = a.bone.skeleton, f = c.color, e = a.color, k = this.color, h = f.a * e.a * k.a;
      b = b ? h : 1;
      var l = this.tempColor;
      l.set(f.r * e.r * k.r * b, f.g * e.g * k.g * b, f.b * e.b * k.b * b, h);
      var n = a.attachmentVertices, f = this.vertices, e = this.worldVertices, t = this.bones;
      if (null == t) {
        t = f.length;
        0 < n.length && (f = n);
        a = a.bone;
        var n = a.worldX, v = a.worldY, y = a.a, c = a.b, x = a.c;
        a = a.d;
        for (h = k = 0;k < t;k += 2, h += 8) {
          b = f[k];
          var q = f[k + 1];
          e[h] = b * y + q * c + n;
          e[h + 1] = b * x + q * a + v;
          e[h + 2] = l.r;
          e[h + 3] = l.g;
          e[h + 4] = l.b;
          e[h + 5] = l.a;
        }
        return e;
      }
      v = c.bones;
      if (0 == n.length) {
        for (c = k = h = 0, y = t.length;k < y;h += 8) {
          for (var u = x = 0, B = t[k++] + k;k < B;k++, c += 3) {
            a = v[t[k]];
            b = f[c];
            var q = f[c + 1], C = f[c + 2], x = x + (b * a.a + q * a.b + a.worldX) * C, u = u + (b * a.c + q * a.d + a.worldY) * C;
          }
          e[h] = x;
          e[h + 1] = u;
          e[h + 2] = l.r;
          e[h + 3] = l.g;
          e[h + 4] = l.b;
          e[h + 5] = l.a;
        }
      } else {
        for (var D = c = k = h = 0, y = t.length;k < y;h += 8) {
          u = x = 0;
          for (B = t[k++] + k;k < B;k++, c += 3, D += 2) {
            a = v[t[k]], b = f[c] + n[D], q = f[c + 1] + n[D + 1], C = f[c + 2], x += (b * a.a + q * a.b + a.worldX) * C, u += (b * a.c + q * a.d + a.worldY) * C;
          }
          e[h] = x;
          e[h + 1] = u;
          e[h + 2] = l.r;
          e[h + 3] = l.g;
          e[h + 4] = l.b;
          e[h + 5] = l.a;
        }
      }
      return e;
    };
    b.prototype.applyDeform = function(a) {
      return this == a || this.inheritDeform && this.parentMesh == a;
    };
    b.prototype.getParentMesh = function() {
      return this.parentMesh;
    };
    b.prototype.setParentMesh = function(a) {
      this.parentMesh = a;
      null != a && (this.bones = a.bones, this.vertices = a.vertices, this.regionUVs = a.regionUVs, this.triangles = a.triangles, this.hullLength = a.hullLength);
    };
    return b;
  }(a.VertexAttachment);
  a.MeshAttachment = h;
})(spine || (spine = {}));
(function(a) {
  var h = function(h) {
    function b(b) {
      h.call(this, b);
      this.constantSpeed = this.closed = !1;
      this.color = new a.Color(1, 1, 1, 1);
    }
    __extends(b, h);
    return b;
  }(a.VertexAttachment);
  a.PathAttachment = h;
})(spine || (spine = {}));
(function(a) {
  var h = function(h) {
    function b(b) {
      h.call(this, b);
      this.y = this.x = 0;
      this.scaleY = this.scaleX = 1;
      this.height = this.width = this.rotation = 0;
      this.color = new a.Color(1, 1, 1, 1);
      this.offset = a.Utils.newFloatArray(8);
      this.vertices = a.Utils.newFloatArray(32);
      this.tempColor = new a.Color(1, 1, 1, 1);
    }
    __extends(b, h);
    b.prototype.setRegion = function(a) {
      var f = this.vertices;
      a.rotate ? (f[b.U2] = a.u, f[b.V2] = a.v2, f[b.U3] = a.u, f[b.V3] = a.v, f[b.U4] = a.u2, f[b.V4] = a.v, f[b.U1] = a.u2, f[b.V1] = a.v2) : (f[b.U1] = a.u, f[b.V1] = a.v2, f[b.U2] = a.u, f[b.V2] = a.v, f[b.U3] = a.u2, f[b.V3] = a.v, f[b.U4] = a.u2, f[b.V4] = a.v2);
      this.region = a;
    };
    b.prototype.updateOffset = function() {
      var a = this.width / this.region.originalWidth * this.scaleX, k = this.height / this.region.originalHeight * this.scaleY, c = -this.width / 2 * this.scaleX + this.region.offsetX * a, g = -this.height / 2 * this.scaleY + this.region.offsetY * k, e = c + this.region.width * a, a = g + this.region.height * k, k = this.rotation * Math.PI / 180, h = Math.cos(k), l = Math.sin(k), k = c * h + this.x, c = c * l, w = g * h + this.y, g = g * l, n = e * h + this.x, e = e * l, h = a * h + this.y, a = a * 
      l, l = this.offset;
      l[b.OX1] = k - g;
      l[b.OY1] = w + c;
      l[b.OX2] = k - a;
      l[b.OY2] = h + c;
      l[b.OX3] = n - a;
      l[b.OY3] = h + e;
      l[b.OX4] = n - g;
      l[b.OY4] = w + e;
    };
    b.prototype.updateWorldVertices = function(a, k) {
      var c = a.bone.skeleton.color, g = a.color, e = this.color, f = c.a * g.a * e.a;
      k = k ? f : 1;
      var h = this.tempColor;
      h.set(c.r * g.r * e.r * k, c.g * g.g * e.g * k, c.b * g.b * e.b * k, f);
      c = this.vertices;
      g = this.offset;
      a = a.bone;
      e = a.worldX;
      f = a.worldY;
      k = a.a;
      var l = a.b, n = a.c;
      a = a.d;
      var t, v;
      t = g[b.OX1];
      v = g[b.OY1];
      c[b.X1] = t * k + v * l + e;
      c[b.Y1] = t * n + v * a + f;
      c[b.C1R] = h.r;
      c[b.C1G] = h.g;
      c[b.C1B] = h.b;
      c[b.C1A] = h.a;
      t = g[b.OX2];
      v = g[b.OY2];
      c[b.X2] = t * k + v * l + e;
      c[b.Y2] = t * n + v * a + f;
      c[b.C2R] = h.r;
      c[b.C2G] = h.g;
      c[b.C2B] = h.b;
      c[b.C2A] = h.a;
      t = g[b.OX3];
      v = g[b.OY3];
      c[b.X3] = t * k + v * l + e;
      c[b.Y3] = t * n + v * a + f;
      c[b.C3R] = h.r;
      c[b.C3G] = h.g;
      c[b.C3B] = h.b;
      c[b.C3A] = h.a;
      t = g[b.OX4];
      v = g[b.OY4];
      c[b.X4] = t * k + v * l + e;
      c[b.Y4] = t * n + v * a + f;
      c[b.C4R] = h.r;
      c[b.C4G] = h.g;
      c[b.C4B] = h.b;
      c[b.C4A] = h.a;
      return c;
    };
    b.OX1 = 0;
    b.OY1 = 1;
    b.OX2 = 2;
    b.OY2 = 3;
    b.OX3 = 4;
    b.OY3 = 5;
    b.OX4 = 6;
    b.OY4 = 7;
    b.X1 = 0;
    b.Y1 = 1;
    b.C1R = 2;
    b.C1G = 3;
    b.C1B = 4;
    b.C1A = 5;
    b.U1 = 6;
    b.V1 = 7;
    b.X2 = 8;
    b.Y2 = 9;
    b.C2R = 10;
    b.C2G = 11;
    b.C2B = 12;
    b.C2A = 13;
    b.U2 = 14;
    b.V2 = 15;
    b.X3 = 16;
    b.Y3 = 17;
    b.C3R = 18;
    b.C3G = 19;
    b.C3B = 20;
    b.C3A = 21;
    b.U3 = 22;
    b.V3 = 23;
    b.X4 = 24;
    b.Y4 = 25;
    b.C4R = 26;
    b.C4G = 27;
    b.C4B = 28;
    b.C4A = 29;
    b.U4 = 30;
    b.V4 = 31;
    return b;
  }(a.Attachment);
  a.RegionAttachment = h;
})(spine || (spine = {}));
(function(a) {
  a = a.BlendMode || (a.BlendMode = {});
  a[a.Normal = 0] = "Normal";
  a[a.Additive = 1] = "Additive";
  a[a.Multiply = 2] = "Multiply";
  a[a.Screen = 3] = "Screen";
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function h(a, f, k) {
      this.children = [];
      this.ashearY = this.ashearX = this.ascaleY = this.ascaleX = this.arotation = this.ay = this.ax = this.shearY = this.shearX = this.scaleY = this.scaleX = this.rotation = this.y = this.x = 0;
      this.appliedValid = !1;
      this.worldY = this.d = this.c = this.worldX = this.b = this.a = 0;
      this.sorted = !1;
      if (null == a) {
        throw Error("data cannot be null.");
      }
      if (null == f) {
        throw Error("skeleton cannot be null.");
      }
      this.data = a;
      this.skeleton = f;
      this.parent = k;
      this.setToSetupPose();
    }
    h.prototype.update = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    h.prototype.updateWorldTransform = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    h.prototype.updateWorldTransformWith = function(b, f, k, c, g, e, h) {
      this.ax = b;
      this.ay = f;
      this.arotation = k;
      this.ascaleX = c;
      this.ascaleY = g;
      this.ashearX = e;
      this.ashearY = h;
      this.appliedValid = !0;
      var l = this.parent;
      if (null == l) {
        h = k + 90 + h;
        var l = a.MathUtils.cosDeg(k + e) * c, p = a.MathUtils.cosDeg(h) * g;
        c *= a.MathUtils.sinDeg(k + e);
        g *= a.MathUtils.sinDeg(h);
        var n = this.skeleton;
        n.flipX && (b = -b, l = -l, p = -p);
        n.flipY && (f = -f, c = -c, g = -g);
        this.a = l;
        this.b = p;
        this.c = c;
        this.d = g;
        this.worldX = b + n.x;
        this.worldY = f + n.y;
      } else {
        var n = l.a, t = l.b, v = l.c, y = l.d;
        this.worldX = n * b + t * f + l.worldX;
        this.worldY = v * b + y * f + l.worldY;
        switch(this.data.transformMode) {
          case a.TransformMode.Normal:
            h = k + 90 + h;
            l = a.MathUtils.cosDeg(k + e) * c;
            p = a.MathUtils.cosDeg(h) * g;
            c *= a.MathUtils.sinDeg(k + e);
            g *= a.MathUtils.sinDeg(h);
            this.a = n * l + t * c;
            this.b = n * p + t * g;
            this.c = v * l + y * c;
            this.d = v * p + y * g;
            return;
          case a.TransformMode.OnlyTranslation:
            h = k + 90 + h;
            this.a = a.MathUtils.cosDeg(k + e) * c;
            this.b = a.MathUtils.cosDeg(h) * g;
            this.c = a.MathUtils.sinDeg(k + e) * c;
            this.d = a.MathUtils.sinDeg(h) * g;
            break;
          case a.TransformMode.NoRotationOrReflection:
            l = n * n + v * v;
            1E-4 < l ? (l = Math.abs(n * y - t * v) / l, t = v * l, y = n * l, l = Math.atan2(v, n) * a.MathUtils.radDeg) : (v = n = 0, l = 90 - Math.atan2(y, t) * a.MathUtils.radDeg);
            e = k + e - l;
            h = k + h - l + 90;
            l = a.MathUtils.cosDeg(e) * c;
            p = a.MathUtils.cosDeg(h) * g;
            c *= a.MathUtils.sinDeg(e);
            g *= a.MathUtils.sinDeg(h);
            this.a = n * l - t * c;
            this.b = n * p - t * g;
            this.c = v * l + y * c;
            this.d = v * p + y * g;
            break;
          case a.TransformMode.NoScale:
          case a.TransformMode.NoScaleOrReflection:
            l = a.MathUtils.cosDeg(k);
            p = a.MathUtils.sinDeg(k);
            k = n * l + t * p;
            b = v * l + y * p;
            l = Math.sqrt(k * k + b * b);
            1E-5 < l && (l = 1 / l);
            k *= l;
            b *= l;
            l = Math.sqrt(k * k + b * b);
            p = Math.PI / 2 + Math.atan2(b, k);
            f = Math.cos(p) * l;
            var x = Math.sin(p) * l, l = a.MathUtils.cosDeg(e) * c, p = a.MathUtils.cosDeg(90 + h) * g;
            c *= a.MathUtils.sinDeg(e);
            g *= a.MathUtils.sinDeg(90 + h);
            this.a = k * l + f * c;
            this.b = k * p + f * g;
            this.c = b * l + x * c;
            this.d = b * p + x * g;
            if (this.data.transformMode != a.TransformMode.NoScaleOrReflection ? 0 > n * y - t * v : this.skeleton.flipX != this.skeleton.flipY) {
              this.b = -this.b, this.d = -this.d;
            }
            return;
        }
        this.skeleton.flipX && (this.a = -this.a, this.b = -this.b);
        this.skeleton.flipY && (this.c = -this.c, this.d = -this.d);
      }
    };
    h.prototype.setToSetupPose = function() {
      var a = this.data;
      this.x = a.x;
      this.y = a.y;
      this.rotation = a.rotation;
      this.scaleX = a.scaleX;
      this.scaleY = a.scaleY;
      this.shearX = a.shearX;
      this.shearY = a.shearY;
    };
    h.prototype.getWorldRotationX = function() {
      return Math.atan2(this.c, this.a) * a.MathUtils.radDeg;
    };
    h.prototype.getWorldRotationY = function() {
      return Math.atan2(this.d, this.b) * a.MathUtils.radDeg;
    };
    h.prototype.getWorldScaleX = function() {
      return Math.sqrt(this.a * this.a + this.c * this.c);
    };
    h.prototype.getWorldScaleY = function() {
      return Math.sqrt(this.b * this.b + this.d * this.d);
    };
    h.prototype.worldToLocalRotationX = function() {
      var b = this.parent;
      if (null == b) {
        return this.arotation;
      }
      var f = this.a, k = this.c;
      return Math.atan2(b.a * k - b.c * f, b.d * f - b.b * k) * a.MathUtils.radDeg;
    };
    h.prototype.worldToLocalRotationY = function() {
      var b = this.parent;
      if (null == b) {
        return this.arotation;
      }
      var f = this.b, k = this.d;
      return Math.atan2(b.a * k - b.c * f, b.d * f - b.b * k) * a.MathUtils.radDeg;
    };
    h.prototype.rotateWorld = function(b) {
      var f = this.a, k = this.b, c = this.c, g = this.d, e = a.MathUtils.cosDeg(b);
      b = a.MathUtils.sinDeg(b);
      this.a = e * f - b * c;
      this.b = e * k - b * g;
      this.c = b * f + e * c;
      this.d = b * k + e * g;
      this.appliedValid = !1;
    };
    h.prototype.updateAppliedTransform = function() {
      this.appliedValid = !0;
      var b = this.parent;
      if (null == b) {
        this.ax = this.worldX, this.ay = this.worldY, this.arotation = Math.atan2(this.c, this.a) * a.MathUtils.radDeg, this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c), this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d), this.ashearX = 0, this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * a.MathUtils.radDeg;
      } else {
        var f = b.a, k = b.b, c = b.c, g = b.d, e = 1 / (f * g - k * c), h = this.worldX - b.worldX, b = this.worldY - b.worldY;
        this.ax = h * g * e - b * k * e;
        this.ay = b * f * e - h * c * e;
        g *= e;
        f *= e;
        k *= e;
        e *= c;
        c = g * this.a - k * this.c;
        k = g * this.b - k * this.d;
        g = f * this.c - e * this.a;
        e = f * this.d - e * this.b;
        this.ashearX = 0;
        this.ascaleX = Math.sqrt(c * c + g * g);
        1E-4 < this.ascaleX ? (f = c * e - k * g, this.ascaleY = f / this.ascaleX, this.ashearY = Math.atan2(c * k + g * e, f) * a.MathUtils.radDeg, this.arotation = Math.atan2(g, c) * a.MathUtils.radDeg) : (this.ascaleX = 0, this.ascaleY = Math.sqrt(k * k + e * e), this.ashearY = 0, this.arotation = 90 - Math.atan2(e, k) * a.MathUtils.radDeg);
      }
    };
    h.prototype.worldToLocal = function(a) {
      var b = this.a, k = this.b, c = this.c, g = this.d, e = 1 / (b * g - k * c), h = a.x - this.worldX, l = a.y - this.worldY;
      a.x = h * g * e - l * k * e;
      a.y = l * b * e - h * c * e;
      return a;
    };
    h.prototype.localToWorld = function(a) {
      var b = a.x, k = a.y;
      a.x = b * this.a + k * this.b + this.worldX;
      a.y = b * this.c + k * this.d + this.worldY;
      return a;
    };
    return h;
  }();
  a.Bone = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    return function(a, f, k) {
      this.rotation = this.y = this.x = 0;
      this.scaleY = this.scaleX = 1;
      this.shearY = this.shearX = 0;
      this.transformMode = l.Normal;
      if (0 > a) {
        throw Error("index must be >= 0.");
      }
      if (null == f) {
        throw Error("name cannot be null.");
      }
      this.index = a;
      this.name = f;
      this.parent = k;
    };
  }();
  a.BoneData = h;
  (function(a) {
    a[a.Normal = 0] = "Normal";
    a[a.OnlyTranslation = 1] = "OnlyTranslation";
    a[a.NoRotationOrReflection = 2] = "NoRotationOrReflection";
    a[a.NoScale = 3] = "NoScale";
    a[a.NoScaleOrReflection = 4] = "NoScaleOrReflection";
  })(a.TransformMode || (a.TransformMode = {}));
  var l = a.TransformMode;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    return function(a, b) {
      if (null == b) {
        throw Error("data cannot be null.");
      }
      this.time = a;
      this.data = b;
    };
  }();
  a.Event = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    return function(a) {
      this.name = a;
    };
  }();
  a.EventData = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function h(a, f) {
      this.mix = 1;
      this.bendDirection = 0;
      if (null == a) {
        throw Error("data cannot be null.");
      }
      if (null == f) {
        throw Error("skeleton cannot be null.");
      }
      this.data = a;
      this.mix = a.mix;
      this.bendDirection = a.bendDirection;
      this.bones = [];
      for (var b = 0;b < a.bones.length;b++) {
        this.bones.push(f.findBone(a.bones[b].name));
      }
      this.target = f.findBone(a.target.name);
    }
    h.prototype.getOrder = function() {
      return this.data.order;
    };
    h.prototype.apply = function() {
      this.update();
    };
    h.prototype.update = function() {
      var a = this.target, f = this.bones;
      switch(f.length) {
        case 1:
          this.apply1(f[0], a.worldX, a.worldY, this.mix);
          break;
        case 2:
          this.apply2(f[0], f[1], a.worldX, a.worldY, this.bendDirection, this.mix);
      }
    };
    h.prototype.apply1 = function(b, f, k, c) {
      b.appliedValid || b.updateAppliedTransform();
      var g = b.parent, e = 1 / (g.a * g.d - g.b * g.c);
      f -= g.worldX;
      k -= g.worldY;
      g = Math.atan2((k * g.a - f * g.c) * e - b.ay, (f * g.d - k * g.b) * e - b.ax) * a.MathUtils.radDeg - b.ashearX - b.arotation;
      0 > b.ascaleX && (g += 180);
      180 < g ? g -= 360 : -180 > g && (g += 360);
      b.updateWorldTransformWith(b.ax, b.ay, b.arotation + g * c, b.ascaleX, b.ascaleY, b.ashearX, b.ashearY);
    };
    h.prototype.apply2 = function(b, f, k, c, g, e) {
      if (0 == e) {
        f.updateWorldTransform();
      } else {
        b.appliedValid || b.updateAppliedTransform();
        f.appliedValid || f.updateAppliedTransform();
        var h = b.ax, l = b.ay, w = b.ascaleX, n = b.ascaleY, t = f.ascaleX, v, y, x;
        0 > w ? (w = -w, v = 180, x = -1) : (v = 0, x = 1);
        0 > n && (n = -n, x = -x);
        0 > t ? (t = -t, y = 180) : y = 0;
        var q = f.ax, u, B, C, D = b.a, F = b.b, E = b.c, z = b.d, I = 1E-4 >= Math.abs(w - n);
        I ? (u = f.ay, B = D * q + F * u + b.worldX, C = E * q + z * u + b.worldY) : (u = 0, B = D * q + b.worldX, C = E * q + b.worldY);
        var J = b.parent, D = J.a, F = J.b, E = J.c, z = J.d, R = 1 / (D * z - F * E);
        k -= J.worldX;
        c -= J.worldY;
        var L = (k * z - c * F) * R - h, M = (c * D - k * E) * R - l;
        k = B - J.worldX;
        c = C - J.worldY;
        F = (k * z - c * F) * R - h;
        D = (c * D - k * E) * R - l;
        R = Math.sqrt(F * F + D * D);
        F = f.data.length * t;
        if (I) {
          F *= w, D = (L * L + M * M - R * R - F * F) / (2 * R * F), -1 > D ? D = -1 : 1 < D && (D = 1), g *= Math.acos(D), D = R + F * D, F *= Math.sin(g), D = Math.atan2(M * D - L * F, L * D + M * F);
        } else {
          if (D = w * F, F *= n, c = D * D, t = F * F, I = L * L + M * M, L = Math.atan2(M, L), E = t * R * R + c * I - c * t, k = -2 * t * R, M = t - c, z = k * k - 4 * M * E, 0 <= z && (z = Math.sqrt(z), 0 > k && (z = -z), z = -(k + z) / 2, k = z / M, z = E / z, z = Math.abs(k) < Math.abs(z) ? k : z, z * z <= I)) {
            c = Math.sqrt(I - z * z) * g, D = L - Math.atan2(c, z), g = Math.atan2(c / n, (z - R) / w);
          } else {
            var w = 0, E = Number.MAX_VALUE, P = J = C = n = B = M = 0;
            k = R + D;
            z = k * k;
            z > C && (n = 0, C = z, J = k);
            k = R - D;
            z = k * k;
            z < E && (w = a.MathUtils.PI, E = z, M = k);
            t = Math.acos(-D * R / (c - t));
            k = D * Math.cos(t) + R;
            c = F * Math.sin(t);
            z = k * k + c * c;
            z < E && (w = t, E = z, M = k, B = c);
            z > C && (n = t, C = z, J = k, P = c);
            I <= (E + C) / 2 ? (D = L - Math.atan2(B * g, M), g *= w) : (D = L - Math.atan2(P * g, J), g *= n);
          }
        }
        F = Math.atan2(u, q) * x;
        R = b.arotation;
        D = (D - F) * a.MathUtils.radDeg + v - R;
        180 < D ? D -= 360 : -180 > D && (D += 360);
        b.updateWorldTransformWith(h, l, R + D * e, b.ascaleX, b.ascaleY, 0, 0);
        R = f.arotation;
        g = ((g + F) * a.MathUtils.radDeg - f.ashearX) * x + y - R;
        180 < g ? g -= 360 : -180 > g && (g += 360);
        f.updateWorldTransformWith(q, u, R + g * e, f.ascaleX, f.ascaleY, f.ashearX, f.ashearY);
      }
    };
    return h;
  }();
  a.IkConstraint = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    return function(a) {
      this.order = 0;
      this.bones = [];
      this.mix = this.bendDirection = 1;
      this.name = a;
    };
  }();
  a.IkConstraintData = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function h(a, f) {
      this.translateMix = this.rotateMix = this.spacing = this.position = 0;
      this.spaces = [];
      this.positions = [];
      this.world = [];
      this.curves = [];
      this.lengths = [];
      this.segments = [];
      if (null == a) {
        throw Error("data cannot be null.");
      }
      if (null == f) {
        throw Error("skeleton cannot be null.");
      }
      this.data = a;
      this.bones = [];
      for (var b = 0, c = a.bones.length;b < c;b++) {
        this.bones.push(f.findBone(a.bones[b].name));
      }
      this.target = f.findSlot(a.target.name);
      this.position = a.position;
      this.spacing = a.spacing;
      this.rotateMix = a.rotateMix;
      this.translateMix = a.translateMix;
    }
    h.prototype.apply = function() {
      this.update();
    };
    h.prototype.update = function() {
      var b = this.target.getAttachment();
      if (b instanceof a.PathAttachment) {
        var f = this.rotateMix, k = this.translateMix, c = 0 < f;
        if (0 < k || c) {
          var g = this.data, e = g.spacingMode, h = e == a.SpacingMode.Length, l = g.rotateMode, w = l == a.RotateMode.Tangent, n = l == a.RotateMode.ChainScale, t = this.bones.length, v = w ? t : t + 1, y = this.bones, x = a.Utils.setArraySize(this.spaces, v), q = null, u = this.spacing;
          if (n || h) {
            n && (q = a.Utils.setArraySize(this.lengths, t));
            for (var B = 0, C = v - 1;B < C;) {
              var D = y[B], F = D.data.length, E = F * D.a, F = F * D.c, F = Math.sqrt(E * E + F * F);
              n && (q[B] = F);
              x[++B] = h ? Math.max(0, F + u) : u;
            }
          } else {
            for (B = 1;B < v;B++) {
              x[B] = u;
            }
          }
          b = this.computeWorldPositions(b, v, w, g.positionMode == a.PositionMode.Percent, e == a.SpacingMode.Percent);
          e = b[0];
          h = b[1];
          g = g.offsetRotation;
          0 == g ? l = l == a.RotateMode.Chain : (l = !1, v = this.target.bone, g *= 0 < v.a * v.d - v.b * v.c ? a.MathUtils.degRad : -a.MathUtils.degRad);
          B = 0;
          for (v = 3;B < t;B++, v += 3) {
            D = y[B];
            D.worldX += (e - D.worldX) * k;
            D.worldY += (h - D.worldY) * k;
            E = b[v];
            F = b[v + 1];
            u = E - e;
            C = F - h;
            n && (e = q[B], 0 != e && (e = (Math.sqrt(u * u + C * C) / e - 1) * f + 1, D.a *= e, D.c *= e));
            e = E;
            h = F;
            if (c) {
              var E = D.a, F = D.b, z = D.c, I = D.d, J, R, L;
              J = w ? b[v - 1] : 0 == x[B + 1] ? b[v + 2] : Math.atan2(C, u);
              J -= Math.atan2(z, E);
              if (l) {
                R = Math.cos(J);
                L = Math.sin(J);
                var M = D.data.length, e = e + (M * (R * E - L * z) - u) * f, h = h + (M * (L * E + R * z) - C) * f;
              } else {
                J += g;
              }
              J > a.MathUtils.PI ? J -= a.MathUtils.PI2 : J < -a.MathUtils.PI && (J += a.MathUtils.PI2);
              J *= f;
              R = Math.cos(J);
              L = Math.sin(J);
              D.a = R * E - L * z;
              D.b = R * F - L * I;
              D.c = L * E + R * z;
              D.d = L * F + R * I;
            }
            D.appliedValid = !1;
          }
        }
      }
    };
    h.prototype.computeWorldPositions = function(b, f, k, c, g) {
      var e = this.target, l = this.position, r = this.spaces, w = a.Utils.setArraySize(this.positions, 3 * f + 2), n, t = b.closed, v = b.worldVerticesLength, y = v / 6, x = h.NONE;
      if (!b.constantSpeed) {
        var q = b.lengths, y = y - (t ? 1 : 2), u = q[y];
        c && (l *= u);
        if (g) {
          for (var B = 0;B < f;B++) {
            r[B] *= u;
          }
        }
        n = a.Utils.setArraySize(this.world, 8);
        for (g = c = B = 0;B < f;B++, c += 3) {
          var C = r[B], D = l += C;
          if (t) {
            D %= u, 0 > D && (D += u), g = 0;
          } else {
            if (0 > D) {
              x != h.BEFORE && (x = h.BEFORE, b.computeWorldVerticesWith(e, 2, 4, n, 0));
              this.addBeforePosition(D, n, 0, w, c);
              continue;
            } else {
              if (D > u) {
                x != h.AFTER && (x = h.AFTER, b.computeWorldVerticesWith(e, v - 6, 4, n, 0));
                this.addAfterPosition(D - u, n, 0, w, c);
                continue;
              }
            }
          }
          for (;;g++) {
            var F = q[g];
            if (!(D > F)) {
              if (0 == g) {
                D /= F;
              } else {
                var E = q[g - 1], D = (D - E) / (F - E);
              }
              break;
            }
          }
          g != x && (x = g, t && g == y ? (b.computeWorldVerticesWith(e, v - 4, 4, n, 0), b.computeWorldVerticesWith(e, 0, 4, n, 4)) : b.computeWorldVerticesWith(e, 6 * g + 2, 8, n, 0));
          this.addCurvePosition(D, n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], w, c, k || 0 < B && 0 == C);
        }
        return w;
      }
      t ? (v += 2, n = a.Utils.setArraySize(this.world, v), b.computeWorldVerticesWith(e, 2, v - 4, n, 0), b.computeWorldVerticesWith(e, 0, 2, n, v - 4), n[v - 2] = n[0], n[v - 1] = n[1]) : (y--, v -= 4, n = a.Utils.setArraySize(this.world, v), b.computeWorldVerticesWith(e, 2, v, n, 0));
      b = a.Utils.setArraySize(this.curves, y);
      for (var e = 0, q = n[0], u = n[1], z = F = 0, I = 0, J = 0, R = 0, L = 0, M, P, H, ba, ha, B = 0, C = 2;B < y;B++, C += 6) {
        F = n[C], z = n[C + 1], I = n[C + 2], J = n[C + 3], R = n[C + 4], L = n[C + 5], M = .1875 * (q - 2 * F + I), P = .1875 * (u - 2 * z + J), E = .09375 * (3 * (F - I) - q + R), H = .09375 * (3 * (z - J) - u + L), ba = 2 * M + E, ha = 2 * P + H, M = .75 * (F - q) + M + .16666667 * E, P = .75 * (z - u) + P + .16666667 * H, e += Math.sqrt(M * M + P * P), M += ba, P += ha, ba += E, ha += H, e += Math.sqrt(M * M + P * P), M += ba, P += ha, e += Math.sqrt(M * M + P * P), M += ba + E, P += ha + H, 
        e += Math.sqrt(M * M + P * P), b[B] = e, q = R, u = L;
      }
      c && (l *= e);
      if (g) {
        for (B = 0;B < f;B++) {
          r[B] *= e;
        }
      }
      var y = this.segments, Z = 0;
      for (H = g = c = B = 0;B < f;B++, c += 3) {
        C = r[B];
        D = l += C;
        if (t) {
          D %= e, 0 > D && (D += e), g = 0;
        } else {
          if (0 > D) {
            this.addBeforePosition(D, n, 0, w, c);
            continue;
          } else {
            if (D > e) {
              this.addAfterPosition(D - e, n, v - 4, w, c);
              continue;
            }
          }
        }
        for (;;g++) {
          if (ba = b[g], !(D > ba)) {
            0 == g ? D /= ba : (E = b[g - 1], D = (D - E) / (ba - E));
            break;
          }
        }
        if (g != x) {
          var x = g, ea = 6 * g, q = n[ea], u = n[ea + 1], F = n[ea + 2], z = n[ea + 3], I = n[ea + 4], J = n[ea + 5], R = n[ea + 6], L = n[ea + 7];
          M = .03 * (q - 2 * F + I);
          P = .03 * (u - 2 * z + J);
          E = .006 * (3 * (F - I) - q + R);
          H = .006 * (3 * (z - J) - u + L);
          ba = 2 * M + E;
          ha = 2 * P + H;
          M = .3 * (F - q) + M + .16666667 * E;
          P = .3 * (z - u) + P + .16666667 * H;
          Z = Math.sqrt(M * M + P * P);
          y[0] = Z;
          for (ea = 1;8 > ea;ea++) {
            M += ba, P += ha, ba += E, ha += H, Z += Math.sqrt(M * M + P * P), y[ea] = Z;
          }
          M += ba;
          P += ha;
          Z += Math.sqrt(M * M + P * P);
          y[8] = Z;
          M += ba + E;
          P += ha + H;
          Z += Math.sqrt(M * M + P * P);
          y[9] = Z;
          H = 0;
        }
        for (D *= Z;;H++) {
          if (ba = y[H], !(D > ba)) {
            0 == H ? D /= ba : (E = y[H - 1], D = H + (D - E) / (ba - E));
            break;
          }
        }
        this.addCurvePosition(.1 * D, q, u, F, z, I, J, R, L, w, c, k || 0 < B && 0 == C);
      }
      return w;
    };
    h.prototype.addBeforePosition = function(a, f, k, c, g) {
      var b = f[k], h = f[k + 1];
      f = Math.atan2(f[k + 3] - h, f[k + 2] - b);
      c[g] = b + a * Math.cos(f);
      c[g + 1] = h + a * Math.sin(f);
      c[g + 2] = f;
    };
    h.prototype.addAfterPosition = function(a, f, k, c, g) {
      var b = f[k + 2], h = f[k + 3];
      f = Math.atan2(h - f[k + 1], b - f[k]);
      c[g] = b + a * Math.cos(f);
      c[g + 1] = h + a * Math.sin(f);
      c[g + 2] = f;
    };
    h.prototype.addCurvePosition = function(a, f, k, c, g, e, h, l, w, n, t, v) {
      if (0 == a || isNaN(a)) {
        a = 1E-4;
      }
      var b = a * a, p = b * a, q = 1 - a, r = q * q, B = r * q, C = q * a, D = 3 * C, q = q * D;
      a *= D;
      l = f * B + c * q + e * a + l * p;
      w = k * B + g * q + h * a + w * p;
      n[t] = l;
      n[t + 1] = w;
      v && (n[t + 2] = Math.atan2(w - (k * r + g * C * 2 + h * b), l - (f * r + c * C * 2 + e * b)));
    };
    h.prototype.getOrder = function() {
      return this.data.order;
    };
    h.NONE = -1;
    h.BEFORE = -2;
    h.AFTER = -3;
    return h;
  }();
  a.PathConstraint = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    return function(a) {
      this.order = 0;
      this.bones = [];
      this.name = a;
    };
  }();
  a.PathConstraintData = h;
  (function(a) {
    a[a.Fixed = 0] = "Fixed";
    a[a.Percent = 1] = "Percent";
  })(a.PositionMode || (a.PositionMode = {}));
  (function(a) {
    a[a.Length = 0] = "Length";
    a[a.Fixed = 1] = "Fixed";
    a[a.Percent = 2] = "Percent";
  })(a.SpacingMode || (a.SpacingMode = {}));
  (function(a) {
    a[a.Tangent = 0] = "Tangent";
    a[a.Chain = 1] = "Chain";
    a[a.ChainScale = 2] = "ChainScale";
  })(a.RotateMode || (a.RotateMode = {}));
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function a(a) {
      this.toLoad = [];
      this.assets = {};
      this.clientId = a;
    }
    a.prototype.loaded = function() {
      var a = 0, b;
      for (b in this.assets) {
        a++;
      }
      return a;
    };
    return a;
  }(), l = function() {
    function a(a) {
      void 0 === a && (a = "");
      this.clientAssets = {};
      this.queuedAssets = {};
      this.rawAssets = {};
      this.errors = {};
      this.pathPrefix = a;
    }
    a.prototype.queueAsset = function(a, b, c) {
      var g = this.clientAssets[a];
      if (null === g || void 0 === g) {
        g = new h(a), this.clientAssets[a] = g;
      }
      null !== b && (g.textureLoader = b);
      g.toLoad.push(c);
      if (this.queuedAssets[c] === c) {
        return !1;
      }
      this.queuedAssets[c] = c;
      return !0;
    };
    a.prototype.loadText = function(a, b) {
      var c = this;
      b = this.pathPrefix + b;
      if (this.queueAsset(a, null, b)) {
        var g = new XMLHttpRequest;
        g.onreadystatechange = function() {
          g.readyState == XMLHttpRequest.DONE && (200 <= g.status && 300 > g.status ? c.rawAssets[b] = g.responseText : c.errors[b] = "Couldn't load text " + b + ": status " + g.status + ", " + g.responseText);
        };
        g.open("GET", b, !0);
        g.send();
      }
    };
    a.prototype.loadJson = function(a, b) {
      var c = this;
      b = this.pathPrefix + b;
      if (this.queueAsset(a, null, b)) {
        var g = new XMLHttpRequest;
        g.onreadystatechange = function() {
          g.readyState == XMLHttpRequest.DONE && (200 <= g.status && 300 > g.status ? c.rawAssets[b] = JSON.parse(g.responseText) : c.errors[b] = "Couldn't load text " + b + ": status " + g.status + ", " + g.responseText);
        };
        g.open("GET", b, !0);
        g.send();
      }
    };
    a.prototype.loadTexture = function(a, b, c) {
      var g = this;
      c = this.pathPrefix + c;
      if (this.queueAsset(a, b, c)) {
        var e = new Image;
        e.src = c;
        e.crossOrigin = "anonymous";
        e.onload = function(a) {
          g.rawAssets[c] = e;
        };
        e.onerror = function(a) {
          g.errors[c] = "Couldn't load image " + c;
        };
      }
    };
    a.prototype.get = function(a, b) {
      b = this.pathPrefix + b;
      a = this.clientAssets[a];
      return null === a || void 0 === a ? !0 : a.assets[b];
    };
    a.prototype.updateClientAssets = function(a) {
      for (var b = 0;b < a.toLoad.length;b++) {
        var c = a.toLoad[b], g = a.assets[c];
        if (null === g || void 0 === g) {
          g = this.rawAssets[c], null !== g && void 0 !== g && (a.assets[c] = g instanceof HTMLImageElement ? a.textureLoader(g) : g);
        }
      }
    };
    a.prototype.isLoadingComplete = function(a) {
      a = this.clientAssets[a];
      if (null === a || void 0 === a) {
        return !0;
      }
      this.updateClientAssets(a);
      return a.toLoad.length == a.loaded();
    };
    a.prototype.dispose = function() {
    };
    a.prototype.hasErrors = function() {
      return 0 < Object.keys(this.errors).length;
    };
    a.prototype.getErrors = function() {
      return this.errors;
    };
    return a;
  }();
  a.SharedAssetManager = l;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function h(b) {
      this._updateCache = [];
      this.updateCacheReset = [];
      this.time = 0;
      this.flipY = this.flipX = !1;
      this.y = this.x = 0;
      if (null == b) {
        throw Error("data cannot be null.");
      }
      this.data = b;
      this.bones = [];
      for (var f = 0;f < b.bones.length;f++) {
        var k = b.bones[f];
        if (null == k.parent) {
          k = new a.Bone(k, this, null);
        } else {
          var c = this.bones[k.parent.index], k = new a.Bone(k, this, c);
          c.children.push(k);
        }
        this.bones.push(k);
      }
      this.slots = [];
      this.drawOrder = [];
      for (f = 0;f < b.slots.length;f++) {
        c = b.slots[f], k = this.bones[c.boneData.index], k = new a.Slot(c, k), this.slots.push(k), this.drawOrder.push(k);
      }
      this.ikConstraints = [];
      for (f = 0;f < b.ikConstraints.length;f++) {
        this.ikConstraints.push(new a.IkConstraint(b.ikConstraints[f], this));
      }
      this.transformConstraints = [];
      for (f = 0;f < b.transformConstraints.length;f++) {
        this.transformConstraints.push(new a.TransformConstraint(b.transformConstraints[f], this));
      }
      this.pathConstraints = [];
      for (f = 0;f < b.pathConstraints.length;f++) {
        this.pathConstraints.push(new a.PathConstraint(b.pathConstraints[f], this));
      }
      this.color = new a.Color(1, 1, 1, 1);
      this.updateCache();
    }
    h.prototype.updateCache = function() {
      this._updateCache.length = 0;
      for (var a = this.bones, f = 0, k = a.length;f < k;f++) {
        a[f].sorted = !1;
      }
      var k = this.ikConstraints, c = this.transformConstraints, g = this.pathConstraints, e = k.length, h = c.length, l = g.length, w = e + h + l, f = 0;
      a: for (;f < w;f++) {
        for (var n = 0;n < e;n++) {
          var t = k[n];
          if (t.data.order == f) {
            this.sortIkConstraint(t);
            continue a;
          }
        }
        for (n = 0;n < h;n++) {
          if (t = c[n], t.data.order == f) {
            this.sortTransformConstraint(t);
            continue a;
          }
        }
        for (n = 0;n < l;n++) {
          if (t = g[n], t.data.order == f) {
            this.sortPathConstraint(t);
            continue a;
          }
        }
      }
      f = 0;
      for (k = a.length;f < k;f++) {
        this.sortBone(a[f]);
      }
    };
    h.prototype.sortIkConstraint = function(a) {
      this.sortBone(a.target);
      var b = a.bones, k = b[0];
      this.sortBone(k);
      if (1 < b.length) {
        var c = b[b.length - 1];
        -1 < this._updateCache.indexOf(c) || this.updateCacheReset.push(c);
      }
      this._updateCache.push(a);
      this.sortReset(k.children);
      b[b.length - 1].sorted = !0;
    };
    h.prototype.sortPathConstraint = function(b) {
      var f = b.target, k = f.data.index, c = f.bone;
      null != this.skin && this.sortPathConstraintAttachment(this.skin, k, c);
      null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, k, c);
      for (var g = 0, e = this.data.skins.length;g < e;g++) {
        this.sortPathConstraintAttachment(this.data.skins[g], k, c);
      }
      g = f.getAttachment();
      g instanceof a.PathAttachment && this.sortPathConstraintAttachmentWith(g, c);
      c = b.bones;
      f = c.length;
      for (g = 0;g < f;g++) {
        this.sortBone(c[g]);
      }
      this._updateCache.push(b);
      for (g = 0;g < f;g++) {
        this.sortReset(c[g].children);
      }
      for (g = 0;g < f;g++) {
        c[g].sorted = !0;
      }
    };
    h.prototype.sortTransformConstraint = function(a) {
      this.sortBone(a.target);
      for (var b = a.bones, k = b.length, c = 0;c < k;c++) {
        this.sortBone(b[c]);
      }
      this._updateCache.push(a);
      for (c = 0;c < k;c++) {
        this.sortReset(b[c].children);
      }
      for (c = 0;c < k;c++) {
        b[c].sorted = !0;
      }
    };
    h.prototype.sortPathConstraintAttachment = function(a, f, k) {
      if (a = a.attachments[f]) {
        for (var b in a) {
          this.sortPathConstraintAttachmentWith(a[b], k);
        }
      }
    };
    h.prototype.sortPathConstraintAttachmentWith = function(b, f) {
      if (b instanceof a.PathAttachment) {
        if (b = b.bones, null == b) {
          this.sortBone(f);
        } else {
          f = this.bones;
          for (var k = 0;k < b.length;) {
            for (var c = b[k++], c = k + c;k < c;k++) {
              this.sortBone(f[b[k]]);
            }
          }
        }
      }
    };
    h.prototype.sortBone = function(a) {
      if (!a.sorted) {
        var b = a.parent;
        null != b && this.sortBone(b);
        a.sorted = !0;
        this._updateCache.push(a);
      }
    };
    h.prototype.sortReset = function(a) {
      for (var b = 0, k = a.length;b < k;b++) {
        var c = a[b];
        c.sorted && this.sortReset(c.children);
        c.sorted = !1;
      }
    };
    h.prototype.updateWorldTransform = function() {
      for (var a = this.updateCacheReset, f = 0, k = a.length;f < k;f++) {
        var c = a[f];
        c.ax = c.x;
        c.ay = c.y;
        c.arotation = c.rotation;
        c.ascaleX = c.scaleX;
        c.ascaleY = c.scaleY;
        c.ashearX = c.shearX;
        c.ashearY = c.shearY;
        c.appliedValid = !0;
      }
      a = this._updateCache;
      f = 0;
      for (k = a.length;f < k;f++) {
        a[f].update();
      }
    };
    h.prototype.setToSetupPose = function() {
      this.setBonesToSetupPose();
      this.setSlotsToSetupPose();
    };
    h.prototype.setBonesToSetupPose = function() {
      for (var a = this.bones, f = 0, k = a.length;f < k;f++) {
        a[f].setToSetupPose();
      }
      for (var c = this.ikConstraints, f = 0, k = c.length;f < k;f++) {
        a = c[f], a.bendDirection = a.data.bendDirection, a.mix = a.data.mix;
      }
      for (var g = this.transformConstraints, f = 0, k = g.length;f < k;f++) {
        a = g[f], c = a.data, a.rotateMix = c.rotateMix, a.translateMix = c.translateMix, a.scaleMix = c.scaleMix, a.shearMix = c.shearMix;
      }
      g = this.pathConstraints;
      f = 0;
      for (k = g.length;f < k;f++) {
        a = g[f], c = a.data, a.position = c.position, a.spacing = c.spacing, a.rotateMix = c.rotateMix, a.translateMix = c.translateMix;
      }
    };
    h.prototype.setSlotsToSetupPose = function() {
      var b = this.slots;
      a.Utils.arrayCopy(b, 0, this.drawOrder, 0, b.length);
      for (var f = 0, k = b.length;f < k;f++) {
        b[f].setToSetupPose();
      }
    };
    h.prototype.getRootBone = function() {
      return 0 == this.bones.length ? null : this.bones[0];
    };
    h.prototype.findBone = function(a) {
      if (null == a) {
        throw Error("boneName cannot be null.");
      }
      for (var b = this.bones, k = 0, c = b.length;k < c;k++) {
        var g = b[k];
        if (g.data.name == a) {
          return g;
        }
      }
      return null;
    };
    h.prototype.findBoneIndex = function(a) {
      if (null == a) {
        throw Error("boneName cannot be null.");
      }
      for (var b = this.bones, k = 0, c = b.length;k < c;k++) {
        if (b[k].data.name == a) {
          return k;
        }
      }
      return -1;
    };
    h.prototype.findSlot = function(a) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var b = this.slots, k = 0, c = b.length;k < c;k++) {
        var g = b[k];
        if (g.data.name == a) {
          return g;
        }
      }
      return null;
    };
    h.prototype.findSlotIndex = function(a) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var b = this.slots, k = 0, c = b.length;k < c;k++) {
        if (b[k].data.name == a) {
          return k;
        }
      }
      return -1;
    };
    h.prototype.setSkinByName = function(a) {
      var b = this.data.findSkin(a);
      if (null == b) {
        throw Error("Skin not found: " + a);
      }
      this.setSkin(b);
    };
    h.prototype.setSkin = function(a) {
      if (null != a) {
        if (null != this.skin) {
          a.attachAll(this, this.skin);
        } else {
          for (var b = this.slots, k = 0, c = b.length;k < c;k++) {
            var g = b[k], e = g.data.attachmentName;
            null != e && (e = a.getAttachment(k, e), null != e && g.setAttachment(e));
          }
        }
      }
      this.skin = a;
    };
    h.prototype.getAttachmentByName = function(a, f) {
      return this.getAttachment(this.data.findSlotIndex(a), f);
    };
    h.prototype.getAttachment = function(a, f) {
      if (null == f) {
        throw Error("attachmentName cannot be null.");
      }
      if (null != this.skin) {
        var b = this.skin.getAttachment(a, f);
        if (null != b) {
          return b;
        }
      }
      return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(a, f) : null;
    };
    h.prototype.setAttachment = function(a, f) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var b = this.slots, c = 0, g = b.length;c < g;c++) {
        var e = b[c];
        if (e.data.name == a) {
          b = null;
          if (null != f && (b = this.getAttachment(c, f), null == b)) {
            throw Error("Attachment not found: " + f + ", for slot: " + a);
          }
          e.setAttachment(b);
          return;
        }
      }
      throw Error("Slot not found: " + a);
    };
    h.prototype.findIkConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var b = this.ikConstraints, k = 0, c = b.length;k < c;k++) {
        var g = b[k];
        if (g.data.name == a) {
          return g;
        }
      }
      return null;
    };
    h.prototype.findTransformConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var b = this.transformConstraints, k = 0, c = b.length;k < c;k++) {
        var g = b[k];
        if (g.data.name == a) {
          return g;
        }
      }
      return null;
    };
    h.prototype.findPathConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var b = this.pathConstraints, k = 0, c = b.length;k < c;k++) {
        var g = b[k];
        if (g.data.name == a) {
          return g;
        }
      }
      return null;
    };
    h.prototype.getBounds = function(b, f) {
      if (null == b) {
        throw Error("offset cannot be null.");
      }
      if (null == f) {
        throw Error("size cannot be null.");
      }
      for (var k = this.drawOrder, c = Number.POSITIVE_INFINITY, g = Number.POSITIVE_INFINITY, e = Number.NEGATIVE_INFINITY, h = Number.NEGATIVE_INFINITY, l = 0, w = k.length;l < w;l++) {
        var n = k[l], t = null, v = n.getAttachment();
        v instanceof a.RegionAttachment ? t = v.updateWorldVertices(n, !1) : v instanceof a.MeshAttachment && (t = v.updateWorldVertices(n, !0));
        if (null != t) {
          for (n = 0, v = t.length;n < v;n += 8) {
            var y = t[n], x = t[n + 1], c = Math.min(c, y), g = Math.min(g, x), e = Math.max(e, y), h = Math.max(h, x);
          }
        }
      }
      b.set(c, g);
      f.set(e - c, h - g);
    };
    h.prototype.update = function(a) {
      this.time += a;
    };
    return h;
  }();
  a.Skeleton = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function h() {
      this.maxY = this.maxX = this.minY = this.minX = 0;
      this.boundingBoxes = [];
      this.polygons = [];
      this.polygonPool = new a.Pool(function() {
        return a.Utils.newFloatArray(16);
      });
    }
    h.prototype.update = function(b, f) {
      if (null == b) {
        throw Error("skeleton cannot be null.");
      }
      var k = this.boundingBoxes, c = this.polygons, g = this.polygonPool;
      b = b.slots;
      var e = b.length;
      k.length = 0;
      g.freeAll(c);
      for (var h = c.length = 0;h < e;h++) {
        var l = b[h], w = l.getAttachment();
        if (w instanceof a.BoundingBoxAttachment) {
          k.push(w);
          var n = g.obtain();
          n.length != w.worldVerticesLength && (n = a.Utils.newFloatArray(w.worldVerticesLength));
          c.push(n);
          w.computeWorldVertices(l, n);
        }
      }
      f ? this.aabbCompute() : (this.minY = this.minX = Number.POSITIVE_INFINITY, this.maxY = this.maxX = Number.NEGATIVE_INFINITY);
    };
    h.prototype.aabbCompute = function() {
      for (var a = Number.POSITIVE_INFINITY, f = Number.POSITIVE_INFINITY, k = Number.NEGATIVE_INFINITY, c = Number.NEGATIVE_INFINITY, g = this.polygons, e = 0, h = g.length;e < h;e++) {
        for (var l = g[e], w = l, n = 0, l = l.length;n < l;n += 2) {
          var t = w[n], v = w[n + 1], a = Math.min(a, t), f = Math.min(f, v), k = Math.max(k, t), c = Math.max(c, v);
        }
      }
      this.minX = a;
      this.minY = f;
      this.maxX = k;
      this.maxY = c;
    };
    h.prototype.aabbContainsPoint = function(a, f) {
      return a >= this.minX && a <= this.maxX && f >= this.minY && f <= this.maxY;
    };
    h.prototype.aabbIntersectsSegment = function(a, f, k, c) {
      var b = this.minX, e = this.minY, h = this.maxX, l = this.maxY;
      if (a <= b && k <= b || f <= e && c <= e || a >= h && k >= h || f >= l && c >= l) {
        return !1;
      }
      k = (c - f) / (k - a);
      c = k * (b - a) + f;
      if (c > e && c < l) {
        return !0;
      }
      c = k * (h - a) + f;
      if (c > e && c < l) {
        return !0;
      }
      e = (e - f) / k + a;
      if (e > b && e < h) {
        return !0;
      }
      e = (l - f) / k + a;
      return e > b && e < h ? !0 : !1;
    };
    h.prototype.aabbIntersectsSkeleton = function(a) {
      return this.minX < a.maxX && this.maxX > a.minX && this.minY < a.maxY && this.maxY > a.minY;
    };
    h.prototype.containsPoint = function(a, f) {
      for (var b = this.polygons, c = 0, g = b.length;c < g;c++) {
        if (this.containsPointPolygon(b[c], a, f)) {
          return this.boundingBoxes[c];
        }
      }
      return null;
    };
    h.prototype.containsPointPolygon = function(a, f, k) {
      for (var b = a.length, g = b - 2, e = !1, h = 0;h < b;h += 2) {
        var l = a[h + 1], w = a[g + 1];
        if (l < k && w >= k || w < k && l >= k) {
          var n = a[h];
          n + (k - l) / (w - l) * (a[g] - n) < f && (e = !e);
        }
        g = h;
      }
      return e;
    };
    h.prototype.intersectsSegment = function(a, f, k, c) {
      for (var b = this.polygons, e = 0, h = b.length;e < h;e++) {
        if (this.intersectsSegmentPolygon(b[e], a, f, k, c)) {
          return this.boundingBoxes[e];
        }
      }
      return null;
    };
    h.prototype.intersectsSegmentPolygon = function(a, f, k, c, g) {
      for (var b = a.length, h = f - c, l = k - g, w = f * g - k * c, n = a[b - 2], t = a[b - 1], v = 0;v < b;v += 2) {
        var y = a[v], x = a[v + 1], q = n * x - t * y, u = n - y, B = t - x, C = h * B - l * u, u = (w * u - h * q) / C;
        if ((u >= n && u <= y || u >= y && u <= n) && (u >= f && u <= c || u >= c && u <= f) && (n = (w * B - l * q) / C, (n >= t && n <= x || n >= x && n <= t) && (n >= k && n <= g || n >= g && n <= k))) {
          return !0;
        }
        n = y;
        t = x;
      }
      return !1;
    };
    h.prototype.getPolygon = function(a) {
      if (null == a) {
        throw Error("boundingBox cannot be null.");
      }
      a = this.boundingBoxes.indexOf(a);
      return -1 == a ? null : this.polygons[a];
    };
    h.prototype.getWidth = function() {
      return this.maxX - this.minX;
    };
    h.prototype.getHeight = function() {
      return this.maxY - this.minY;
    };
    return h;
  }();
  a.SkeletonBounds = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function a() {
      this.bones = [];
      this.slots = [];
      this.skins = [];
      this.events = [];
      this.animations = [];
      this.ikConstraints = [];
      this.transformConstraints = [];
      this.pathConstraints = [];
      this.fps = 0;
    }
    a.prototype.findBone = function(a) {
      if (null == a) {
        throw Error("boneName cannot be null.");
      }
      for (var b = this.bones, h = 0, c = b.length;h < c;h++) {
        var g = b[h];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findBoneIndex = function(a) {
      if (null == a) {
        throw Error("boneName cannot be null.");
      }
      for (var b = this.bones, h = 0, c = b.length;h < c;h++) {
        if (b[h].name == a) {
          return h;
        }
      }
      return -1;
    };
    a.prototype.findSlot = function(a) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var b = this.slots, h = 0, c = b.length;h < c;h++) {
        var g = b[h];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findSlotIndex = function(a) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var b = this.slots, h = 0, c = b.length;h < c;h++) {
        if (b[h].name == a) {
          return h;
        }
      }
      return -1;
    };
    a.prototype.findSkin = function(a) {
      if (null == a) {
        throw Error("skinName cannot be null.");
      }
      for (var b = this.skins, h = 0, c = b.length;h < c;h++) {
        var g = b[h];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findEvent = function(a) {
      if (null == a) {
        throw Error("eventDataName cannot be null.");
      }
      for (var b = this.events, h = 0, c = b.length;h < c;h++) {
        var g = b[h];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findAnimation = function(a) {
      if (null == a) {
        throw Error("animationName cannot be null.");
      }
      for (var b = this.animations, h = 0, c = b.length;h < c;h++) {
        var g = b[h];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findIkConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var b = this.ikConstraints, h = 0, c = b.length;h < c;h++) {
        var g = b[h];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findTransformConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var b = this.transformConstraints, h = 0, c = b.length;h < c;h++) {
        var g = b[h];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findPathConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var b = this.pathConstraints, h = 0, c = b.length;h < c;h++) {
        var g = b[h];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findPathConstraintIndex = function(a) {
      if (null == a) {
        throw Error("pathConstraintName cannot be null.");
      }
      for (var b = this.pathConstraints, h = 0, c = b.length;h < c;h++) {
        if (b[h].name == a) {
          return h;
        }
      }
      return -1;
    };
    return a;
  }();
  a.SkeletonData = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function b(a) {
      this.scale = 1;
      this.linkedMeshes = [];
      this.attachmentLoader = a;
    }
    b.prototype.readSkeletonData = function(f) {
      var h = this.scale, c = new a.SkeletonData;
      f = "string" === typeof f ? JSON.parse(f) : f;
      var g = f.skeleton;
      null != g && (c.hash = g.hash, c.version = g.spine, c.width = g.width, c.height = g.height, c.fps = g.fps, c.imagesPath = g.images);
      if (f.bones) {
        for (g = 0;g < f.bones.length;g++) {
          var e = f.bones[g], l = null, r = this.getValue(e, "parent", null);
          if (null != r && (l = c.findBone(r), null == l)) {
            throw Error("Parent bone not found: " + r);
          }
          l = new a.BoneData(c.bones.length, e.name, l);
          l.length = this.getValue(e, "length", 0) * h;
          l.x = this.getValue(e, "x", 0) * h;
          l.y = this.getValue(e, "y", 0) * h;
          l.rotation = this.getValue(e, "rotation", 0);
          l.scaleX = this.getValue(e, "scaleX", 1);
          l.scaleY = this.getValue(e, "scaleY", 1);
          l.shearX = this.getValue(e, "shearX", 0);
          l.shearY = this.getValue(e, "shearY", 0);
          l.transformMode = b.transformModeFromString(this.getValue(e, "transform", "normal"));
          c.bones.push(l);
        }
      }
      if (f.slots) {
        for (g = 0;g < f.slots.length;g++) {
          var e = f.slots[g], w = e.name, r = e.bone, l = c.findBone(r);
          if (null == l) {
            throw Error("Slot bone not found: " + r);
          }
          l = new a.SlotData(c.slots.length, w, l);
          r = this.getValue(e, "color", null);
          null != r && l.color.setFromString(r);
          l.attachmentName = this.getValue(e, "attachment", null);
          l.blendMode = b.blendModeFromString(this.getValue(e, "blend", "normal"));
          c.slots.push(l);
        }
      }
      if (f.ik) {
        for (g = 0;g < f.ik.length;g++) {
          e = f.ik[g];
          l = new a.IkConstraintData(e.name);
          l.order = this.getValue(e, "order", 0);
          for (var n = 0;n < e.bones.length;n++) {
            var r = e.bones[n], t = c.findBone(r);
            if (null == t) {
              throw Error("IK bone not found: " + r);
            }
            l.bones.push(t);
          }
          r = e.target;
          l.target = c.findBone(r);
          if (null == l.target) {
            throw Error("IK target bone not found: " + r);
          }
          l.bendDirection = this.getValue(e, "bendPositive", !0) ? 1 : -1;
          l.mix = this.getValue(e, "mix", 1);
          c.ikConstraints.push(l);
        }
      }
      if (f.transform) {
        for (g = 0;g < f.transform.length;g++) {
          e = f.transform[g];
          l = new a.TransformConstraintData(e.name);
          l.order = this.getValue(e, "order", 0);
          for (n = 0;n < e.bones.length;n++) {
            r = e.bones[n];
            t = c.findBone(r);
            if (null == t) {
              throw Error("Transform constraint bone not found: " + r);
            }
            l.bones.push(t);
          }
          r = e.target;
          l.target = c.findBone(r);
          if (null == l.target) {
            throw Error("Transform constraint target bone not found: " + r);
          }
          l.offsetRotation = this.getValue(e, "rotation", 0);
          l.offsetX = this.getValue(e, "x", 0) * h;
          l.offsetY = this.getValue(e, "y", 0) * h;
          l.offsetScaleX = this.getValue(e, "scaleX", 0);
          l.offsetScaleY = this.getValue(e, "scaleY", 0);
          l.offsetShearY = this.getValue(e, "shearY", 0);
          l.rotateMix = this.getValue(e, "rotateMix", 1);
          l.translateMix = this.getValue(e, "translateMix", 1);
          l.scaleMix = this.getValue(e, "scaleMix", 1);
          l.shearMix = this.getValue(e, "shearMix", 1);
          c.transformConstraints.push(l);
        }
      }
      if (f.path) {
        for (g = 0;g < f.path.length;g++) {
          e = f.path[g];
          l = new a.PathConstraintData(e.name);
          l.order = this.getValue(e, "order", 0);
          for (n = 0;n < e.bones.length;n++) {
            r = e.bones[n];
            t = c.findBone(r);
            if (null == t) {
              throw Error("Transform constraint bone not found: " + r);
            }
            l.bones.push(t);
          }
          r = e.target;
          l.target = c.findSlot(r);
          if (null == l.target) {
            throw Error("Path target slot not found: " + r);
          }
          l.positionMode = b.positionModeFromString(this.getValue(e, "positionMode", "percent"));
          l.spacingMode = b.spacingModeFromString(this.getValue(e, "spacingMode", "length"));
          l.rotateMode = b.rotateModeFromString(this.getValue(e, "rotateMode", "tangent"));
          l.offsetRotation = this.getValue(e, "rotation", 0);
          l.position = this.getValue(e, "position", 0);
          l.positionMode == a.PositionMode.Fixed && (l.position *= h);
          l.spacing = this.getValue(e, "spacing", 0);
          if (l.spacingMode == a.SpacingMode.Length || l.spacingMode == a.SpacingMode.Fixed) {
            l.spacing *= h;
          }
          l.rotateMix = this.getValue(e, "rotateMix", 1);
          l.translateMix = this.getValue(e, "translateMix", 1);
          c.pathConstraints.push(l);
        }
      }
      if (f.skins) {
        for (var v in f.skins) {
          g = f.skins[v];
          h = new a.Skin(v);
          for (w in g) {
            l = c.findSlotIndex(w);
            if (-1 == l) {
              throw Error("Slot not found: " + w);
            }
            var e = g[w], y;
            for (y in e) {
              r = this.readAttachment(e[y], h, l, y), null != r && h.addAttachment(l, y, r);
            }
          }
          c.skins.push(h);
          "default" == h.name && (c.defaultSkin = h);
        }
      }
      g = 0;
      for (w = this.linkedMeshes.length;g < w;g++) {
        v = this.linkedMeshes[g];
        h = null == v.skin ? c.defaultSkin : c.findSkin(v.skin);
        if (null == h) {
          throw Error("Skin not found: " + v.skin);
        }
        y = h.getAttachment(v.slotIndex, v.parent);
        if (null == y) {
          throw Error("Parent mesh not found: " + v.parent);
        }
        v.mesh.setParentMesh(y);
        v.mesh.updateUVs();
      }
      this.linkedMeshes.length = 0;
      if (f.events) {
        for (var x in f.events) {
          w = f.events[x], l = new a.EventData(x), l.intValue = this.getValue(w, "int", 0), l.floatValue = this.getValue(w, "float", 0), l.stringValue = this.getValue(w, "string", ""), c.events.push(l);
        }
      }
      if (f.animations) {
        for (var q in f.animations) {
          this.readAnimation(f.animations[q], q, c);
        }
      }
      return c;
    };
    b.prototype.readAttachment = function(b, h, c, g) {
      var e = this.scale;
      g = this.getValue(b, "name", g);
      switch(this.getValue(b, "type", "region")) {
        case "region":
          var f = this.getValue(b, "path", g);
          c = this.attachmentLoader.newRegionAttachment(h, g, f);
          if (null == c) {
            break;
          }
          c.path = f;
          c.x = this.getValue(b, "x", 0) * e;
          c.y = this.getValue(b, "y", 0) * e;
          c.scaleX = this.getValue(b, "scaleX", 1);
          c.scaleY = this.getValue(b, "scaleY", 1);
          c.rotation = this.getValue(b, "rotation", 0);
          c.width = b.width * e;
          c.height = b.height * e;
          e = this.getValue(b, "color", null);
          null != e && c.color.setFromString(e);
          c.updateOffset();
          return c;
        case "boundingbox":
          f = this.attachmentLoader.newBoundingBoxAttachment(h, g);
          if (null == f) {
            break;
          }
          this.readVertices(b, f, b.vertexCount << 1);
          e = this.getValue(b, "color", null);
          null != e && f.color.setFromString(e);
          return f;
        case "mesh":
        case "linkedmesh":
          f = this.getValue(b, "path", g);
          h = this.attachmentLoader.newMeshAttachment(h, g, f);
          if (null == h) {
            break;
          }
          h.path = f;
          e = this.getValue(b, "color", null);
          null != e && h.color.setFromString(e);
          f = this.getValue(b, "parent", null);
          if (null != f) {
            return h.inheritDeform = this.getValue(b, "deform", !0), this.linkedMeshes.push(new l(h, this.getValue(b, "skin", null), c, f)), h;
          }
          f = b.uvs;
          this.readVertices(b, h, f.length);
          h.triangles = b.triangles;
          h.regionUVs = f;
          h.updateUVs();
          h.hullLength = 2 * this.getValue(b, "hull", 0);
          return h;
        case "path":
          if (f = this.attachmentLoader.newPathAttachment(h, g), null != f) {
            f.closed = this.getValue(b, "closed", !1);
            f.constantSpeed = this.getValue(b, "constantSpeed", !0);
            c = b.vertexCount;
            this.readVertices(b, f, c << 1);
            c = a.Utils.newArray(c / 3, 0);
            for (h = 0;h < b.lengths.length;h++) {
              c[h++] = b.lengths[h] * e;
            }
            f.lengths = c;
            e = this.getValue(b, "color", null);
            null != e && f.color.setFromString(e);
            return f;
          }
      }
      return null;
    };
    b.prototype.readVertices = function(b, h, c) {
      var g = this.scale;
      h.worldVerticesLength = c;
      b = b.vertices;
      if (c == b.length) {
        if (1 != g) {
          c = 0;
          for (var e = b.length;c < e;c++) {
            b[c] *= g;
          }
        }
        h.vertices = a.Utils.toFloatArray(b);
      } else {
        var f = [], k = [];
        c = 0;
        for (e = b.length;c < e;) {
          var l = b[c++];
          k.push(l);
          for (l = c + 4 * l;c < l;c += 4) {
            k.push(b[c]), f.push(b[c + 1] * g), f.push(b[c + 2] * g), f.push(b[c + 3]);
          }
        }
        h.bones = k;
        h.vertices = a.Utils.toFloatArray(f);
      }
    };
    b.prototype.readAnimation = function(b, h, c) {
      var g = this.scale, e = [], f = 0;
      if (b.slots) {
        for (var k in b.slots) {
          var l = b.slots[k], n = c.findSlotIndex(k);
          if (-1 == n) {
            throw Error("Slot not found: " + k);
          }
          for (var t in l) {
            var v = l[t];
            if ("color" == t) {
              var y = new a.ColorTimeline(v.length);
              y.slotIndex = n;
              for (var x = 0, q = 0;q < v.length;q++) {
                var u = v[q], B = new a.Color;
                B.setFromString(u.color);
                y.setFrame(x, u.time, B.r, B.g, B.b, B.a);
                this.readCurve(u, y, x);
                x++;
              }
              e.push(y);
              f = Math.max(f, y.frames[(y.getFrameCount() - 1) * a.ColorTimeline.ENTRIES]);
            } else {
              t = "attachment";
              y = new a.AttachmentTimeline(v.length);
              y.slotIndex = n;
              for (q = x = 0;q < v.length;q++) {
                u = v[q], y.setFrame(x++, u.time, u.name);
              }
              e.push(y);
              f = Math.max(f, y.frames[y.getFrameCount() - 1]);
            }
          }
        }
      }
      if (b.bones) {
        for (var C in b.bones) {
          l = b.bones[C];
          B = c.findBoneIndex(C);
          if (-1 == B) {
            throw Error("Bone not found: " + C);
          }
          for (t in l) {
            if (v = l[t], "rotate" === t) {
              y = new a.RotateTimeline(v.length);
              y.boneIndex = B;
              for (q = x = 0;q < v.length;q++) {
                u = v[q], y.setFrame(x, u.time, u.angle), this.readCurve(u, y, x), x++;
              }
              e.push(y);
              f = Math.max(f, y.frames[(y.getFrameCount() - 1) * a.RotateTimeline.ENTRIES]);
            } else {
              if ("translate" === t || "scale" === t || "shear" === t) {
                n = 1;
                "scale" === t ? y = new a.ScaleTimeline(v.length) : "shear" === t ? y = new a.ShearTimeline(v.length) : (y = new a.TranslateTimeline(v.length), n = g);
                y.boneIndex = B;
                for (q = x = 0;q < v.length;q++) {
                  var u = v[q], D = this.getValue(u, "x", 0), F = this.getValue(u, "y", 0);
                  y.setFrame(x, u.time, D * n, F * n);
                  this.readCurve(u, y, x);
                  x++;
                }
                e.push(y);
                f = Math.max(f, y.frames[(y.getFrameCount() - 1) * a.TranslateTimeline.ENTRIES]);
              } else {
                throw Error("Invalid timeline type for a bone: " + t + " (" + C + ")");
              }
            }
          }
        }
      }
      if (b.ik) {
        for (var E in b.ik) {
          l = b.ik[E];
          x = c.findIkConstraint(E);
          y = new a.IkConstraintTimeline(l.length);
          y.ikConstraintIndex = c.ikConstraints.indexOf(x);
          for (q = x = 0;q < l.length;q++) {
            u = l[q], y.setFrame(x, u.time, this.getValue(u, "mix", 1), this.getValue(u, "bendPositive", !0) ? 1 : -1), this.readCurve(u, y, x), x++;
          }
          e.push(y);
          f = Math.max(f, y.frames[(y.getFrameCount() - 1) * a.IkConstraintTimeline.ENTRIES]);
        }
      }
      if (b.transform) {
        for (E in b.transform) {
          l = b.transform[E];
          x = c.findTransformConstraint(E);
          y = new a.TransformConstraintTimeline(l.length);
          y.transformConstraintIndex = c.transformConstraints.indexOf(x);
          for (q = x = 0;q < l.length;q++) {
            u = l[q], y.setFrame(x, u.time, this.getValue(u, "rotateMix", 1), this.getValue(u, "translateMix", 1), this.getValue(u, "scaleMix", 1), this.getValue(u, "shearMix", 1)), this.readCurve(u, y, x), x++;
          }
          e.push(y);
          f = Math.max(f, y.frames[(y.getFrameCount() - 1) * a.TransformConstraintTimeline.ENTRIES]);
        }
      }
      if (b.paths) {
        for (E in b.paths) {
          l = b.paths[E];
          C = c.findPathConstraintIndex(E);
          if (-1 == C) {
            throw Error("Path constraint not found: " + E);
          }
          B = c.pathConstraints[C];
          for (t in l) {
            if (v = l[t], "position" === t || "spacing" === t) {
              n = 1;
              if ("spacing" === t) {
                if (y = new a.PathConstraintSpacingTimeline(v.length), B.spacingMode == a.SpacingMode.Length || B.spacingMode == a.SpacingMode.Fixed) {
                  n = g;
                }
              } else {
                y = new a.PathConstraintPositionTimeline(v.length), B.positionMode == a.PositionMode.Fixed && (n = g);
              }
              y.pathConstraintIndex = C;
              for (q = x = 0;q < v.length;q++) {
                u = v[q], y.setFrame(x, u.time, this.getValue(u, t, 0) * n), this.readCurve(u, y, x), x++;
              }
              e.push(y);
              f = Math.max(f, y.frames[(y.getFrameCount() - 1) * a.PathConstraintPositionTimeline.ENTRIES]);
            } else {
              if ("mix" === t) {
                y = new a.PathConstraintMixTimeline(v.length);
                y.pathConstraintIndex = C;
                for (q = x = 0;q < v.length;q++) {
                  u = v[q], y.setFrame(x, u.time, this.getValue(u, "rotateMix", 1), this.getValue(u, "translateMix", 1)), this.readCurve(u, y, x), x++;
                }
                e.push(y);
                f = Math.max(f, y.frames[(y.getFrameCount() - 1) * a.PathConstraintMixTimeline.ENTRIES]);
              }
            }
          }
        }
      }
      if (b.deform) {
        for (var z in b.deform) {
          C = b.deform[z];
          B = c.findSkin(z);
          if (null == B) {
            throw Error("Skin not found: " + z);
          }
          for (k in C) {
            l = C[k];
            n = c.findSlotIndex(k);
            if (-1 == n) {
              throw Error("Slot not found: " + l.name);
            }
            for (t in l) {
              v = l[t];
              x = B.getAttachment(n, t);
              if (null == x) {
                throw Error("Deform attachment not found: " + v.name);
              }
              var D = null != x.bones, F = x.vertices, I = D ? F.length / 3 * 2 : F.length, y = new a.DeformTimeline(v.length);
              y.slotIndex = n;
              y.attachment = x;
              for (E = x = 0;E < v.length;E++) {
                var u = v[E], J, R = this.getValue(u, "vertices", null);
                if (null == R) {
                  J = D ? a.Utils.newFloatArray(I) : F;
                } else {
                  J = a.Utils.newFloatArray(I);
                  q = this.getValue(u, "offset", 0);
                  a.Utils.arrayCopy(R, 0, J, q, R.length);
                  if (1 != g) {
                    for (R = q + R.length;q < R;q++) {
                      J[q] *= g;
                    }
                  }
                  if (!D) {
                    for (q = 0;q < I;q++) {
                      J[q] += F[q];
                    }
                  }
                }
                y.setFrame(x, u.time, J);
                this.readCurve(u, y, x);
                x++;
              }
              e.push(y);
              f = Math.max(f, y.frames[y.getFrameCount() - 1]);
            }
          }
        }
      }
      g = b.drawOrder;
      null == g && (g = b.draworder);
      if (null != g) {
        y = new a.DrawOrderTimeline(g.length);
        k = c.slots.length;
        for (E = x = 0;E < g.length;E++) {
          t = g[E];
          z = null;
          v = this.getValue(t, "offsets", null);
          if (null != v) {
            z = a.Utils.newArray(k, -1);
            u = a.Utils.newArray(k - v.length, 0);
            for (q = C = l = 0;q < v.length;q++) {
              B = v[q];
              n = c.findSlotIndex(B.slot);
              if (-1 == n) {
                throw Error("Slot not found: " + B.slot);
              }
              for (;l != n;) {
                u[C++] = l++;
              }
              z[l + B.offset] = l++;
            }
            for (;l < k;) {
              u[C++] = l++;
            }
            for (q = k - 1;0 <= q;q--) {
              -1 == z[q] && (z[q] = u[--C]);
            }
          }
          y.setFrame(x++, t.time, z);
        }
        e.push(y);
        f = Math.max(f, y.frames[y.getFrameCount() - 1]);
      }
      if (b.events) {
        y = new a.EventTimeline(b.events.length);
        for (q = x = 0;q < b.events.length;q++) {
          g = b.events[q];
          k = c.findEvent(g.name);
          if (null == k) {
            throw Error("Event not found: " + g.name);
          }
          n = new a.Event(g.time, k);
          n.intValue = this.getValue(g, "int", k.intValue);
          n.floatValue = this.getValue(g, "float", k.floatValue);
          n.stringValue = this.getValue(g, "string", k.stringValue);
          y.setFrame(x++, n);
        }
        e.push(y);
        f = Math.max(f, y.frames[y.getFrameCount() - 1]);
      }
      if (isNaN(f)) {
        throw Error("Error while parsing animation, duration is NaN");
      }
      c.animations.push(new a.Animation(h, e, f));
    };
    b.prototype.readCurve = function(a, b, c) {
      a.curve && ("stepped" === a.curve ? b.setStepped(c) : "[object Array]" === Object.prototype.toString.call(a.curve) && (a = a.curve, b.setCurve(c, a[0], a[1], a[2], a[3])));
    };
    b.prototype.getValue = function(a, b, c) {
      return void 0 !== a[b] ? a[b] : c;
    };
    b.blendModeFromString = function(b) {
      b = b.toLowerCase();
      if ("normal" == b) {
        return a.BlendMode.Normal;
      }
      if ("additive" == b) {
        return a.BlendMode.Additive;
      }
      if ("multiply" == b) {
        return a.BlendMode.Multiply;
      }
      if ("screen" == b) {
        return a.BlendMode.Screen;
      }
      throw Error("Unknown blend mode: " + b);
    };
    b.positionModeFromString = function(b) {
      b = b.toLowerCase();
      if ("fixed" == b) {
        return a.PositionMode.Fixed;
      }
      if ("percent" == b) {
        return a.PositionMode.Percent;
      }
      throw Error("Unknown position mode: " + b);
    };
    b.spacingModeFromString = function(b) {
      b = b.toLowerCase();
      if ("length" == b) {
        return a.SpacingMode.Length;
      }
      if ("fixed" == b) {
        return a.SpacingMode.Fixed;
      }
      if ("percent" == b) {
        return a.SpacingMode.Percent;
      }
      throw Error("Unknown position mode: " + b);
    };
    b.rotateModeFromString = function(b) {
      b = b.toLowerCase();
      if ("tangent" == b) {
        return a.RotateMode.Tangent;
      }
      if ("chain" == b) {
        return a.RotateMode.Chain;
      }
      if ("chainscale" == b) {
        return a.RotateMode.ChainScale;
      }
      throw Error("Unknown rotate mode: " + b);
    };
    b.transformModeFromString = function(b) {
      b = b.toLowerCase();
      if ("normal" == b) {
        return a.TransformMode.Normal;
      }
      if ("onlytranslation" == b) {
        return a.TransformMode.OnlyTranslation;
      }
      if ("norotationorreflection" == b) {
        return a.TransformMode.NoRotationOrReflection;
      }
      if ("noscale" == b) {
        return a.TransformMode.NoScale;
      }
      if ("noscaleorreflection" == b) {
        return a.TransformMode.NoScaleOrReflection;
      }
      throw Error("Unknown transform mode: " + b);
    };
    return b;
  }();
  a.SkeletonJson = h;
  var l = function() {
    return function(a, f, h, c) {
      this.mesh = a;
      this.skin = f;
      this.slotIndex = h;
      this.parent = c;
    };
  }();
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function a(a) {
      this.attachments = [];
      if (null == a) {
        throw Error("name cannot be null.");
      }
      this.name = a;
    }
    a.prototype.addAttachment = function(a, f, h) {
      if (null == h) {
        throw Error("attachment cannot be null.");
      }
      var b = this.attachments;
      a >= b.length && (b.length = a + 1);
      b[a] || (b[a] = {});
      b[a][f] = h;
    };
    a.prototype.getAttachment = function(a, f) {
      return (a = this.attachments[a]) ? a[f] : null;
    };
    a.prototype.attachAll = function(a, f) {
      for (var b = 0, c = 0;c < a.slots.length;c++) {
        var g = a.slots[c], e = g.getAttachment();
        if (e && b < f.attachments.length) {
          var h = f.attachments[b], l;
          for (l in h) {
            if (e == h[l]) {
              e = this.getAttachment(b, l);
              null != e && g.setAttachment(e);
              break;
            }
          }
        }
        b++;
      }
    };
    return a;
  }();
  a.Skin = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function h(b, f) {
      this.attachmentVertices = [];
      if (null == b) {
        throw Error("data cannot be null.");
      }
      if (null == f) {
        throw Error("bone cannot be null.");
      }
      this.data = b;
      this.bone = f;
      this.color = new a.Color;
      this.setToSetupPose();
    }
    h.prototype.getAttachment = function() {
      return this.attachment;
    };
    h.prototype.setAttachment = function(a) {
      this.attachment != a && (this.attachment = a, this.attachmentTime = this.bone.skeleton.time, this.attachmentVertices.length = 0);
    };
    h.prototype.setAttachmentTime = function(a) {
      this.attachmentTime = this.bone.skeleton.time - a;
    };
    h.prototype.getAttachmentTime = function() {
      return this.bone.skeleton.time - this.attachmentTime;
    };
    h.prototype.setToSetupPose = function() {
      this.color.setFromColor(this.data.color);
      null == this.data.attachmentName ? this.attachment = null : (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)));
    };
    return h;
  }();
  a.Slot = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    return function(h, b, f) {
      this.color = new a.Color(1, 1, 1, 1);
      if (0 > h) {
        throw Error("index must be >= 0.");
      }
      if (null == b) {
        throw Error("name cannot be null.");
      }
      if (null == f) {
        throw Error("boneData cannot be null.");
      }
      this.index = h;
      this.name = b;
      this.boneData = f;
    };
  }();
  a.SlotData = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function a(a) {
      this._image = a;
    }
    a.prototype.getImage = function() {
      return this._image;
    };
    a.filterFromString = function(a) {
      switch(a.toLowerCase()) {
        case "nearest":
          return l.Nearest;
        case "linear":
          return l.Linear;
        case "mipmap":
          return l.MipMap;
        case "mipmapnearestnearest":
          return l.MipMapNearestNearest;
        case "mipmaplinearnearest":
          return l.MipMapLinearNearest;
        case "mipmapnearestlinear":
          return l.MipMapNearestLinear;
        case "mipmaplinearlinear":
          return l.MipMapLinearLinear;
        default:
          throw Error("Unknown texture filter " + a);
      }
    };
    a.wrapFromString = function(a) {
      switch(a.toLowerCase()) {
        case "mirroredtepeat":
          return b.MirroredRepeat;
        case "clamptoedge":
          return b.ClampToEdge;
        case "repeat":
          return b.Repeat;
        default:
          throw Error("Unknown texture wrap " + a);
      }
    };
    return a;
  }();
  a.Texture = h;
  (function(a) {
    a[a.Nearest = 9728] = "Nearest";
    a[a.Linear = 9729] = "Linear";
    a[a.MipMap = 9987] = "MipMap";
    a[a.MipMapNearestNearest = 9984] = "MipMapNearestNearest";
    a[a.MipMapLinearNearest = 9985] = "MipMapLinearNearest";
    a[a.MipMapNearestLinear = 9986] = "MipMapNearestLinear";
    a[a.MipMapLinearLinear = 9987] = "MipMapLinearLinear";
  })(a.TextureFilter || (a.TextureFilter = {}));
  var l = a.TextureFilter;
  (function(a) {
    a[a.MirroredRepeat = 33648] = "MirroredRepeat";
    a[a.ClampToEdge = 33071] = "ClampToEdge";
    a[a.Repeat = 10497] = "Repeat";
  })(a.TextureWrap || (a.TextureWrap = {}));
  var b = a.TextureWrap, h = function() {
    return function() {
      this.height = this.width = this.v2 = this.u2 = this.v = this.u = 0;
      this.rotate = !1;
      this.originalHeight = this.originalWidth = this.offsetY = this.offsetX = 0;
    };
  }();
  a.TextureRegion = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function h(a, b) {
      this.pages = [];
      this.regions = [];
      this.load(a, b);
    }
    h.prototype.load = function(c, g) {
      if (null == g) {
        throw Error("textureLoader cannot be null.");
      }
      c = new l(c);
      for (var e = Array(4), h = null;;) {
        var k = c.readLine();
        if (null == k) {
          break;
        }
        k = k.trim();
        if (0 == k.length) {
          h = null;
        } else {
          if (h) {
            var w = new f;
            w.name = k;
            w.page = h;
            w.rotate = "true" == c.readValue();
            c.readTuple(e);
            var k = parseInt(e[0]), n = parseInt(e[1]);
            c.readTuple(e);
            var t = parseInt(e[0]), v = parseInt(e[1]);
            w.u = k / h.width;
            w.v = n / h.height;
            w.rotate ? (w.u2 = (k + v) / h.width, w.v2 = (n + t) / h.height) : (w.u2 = (k + t) / h.width, w.v2 = (n + v) / h.height);
            w.x = k;
            w.y = n;
            w.width = Math.abs(t);
            w.height = Math.abs(v);
            4 == c.readTuple(e) && 4 == c.readTuple(e) && c.readTuple(e);
            w.originalWidth = parseInt(e[0]);
            w.originalHeight = parseInt(e[1]);
            c.readTuple(e);
            w.offsetX = parseInt(e[0]);
            w.offsetY = parseInt(e[1]);
            w.index = parseInt(c.readValue());
            w.texture = h.texture;
            this.regions.push(w);
          } else {
            h = new b, h.name = k, 2 == c.readTuple(e) && (h.width = parseInt(e[0]), h.height = parseInt(e[1]), c.readTuple(e)), c.readTuple(e), h.minFilter = a.Texture.filterFromString(e[0]), h.magFilter = a.Texture.filterFromString(e[1]), w = c.readValue(), h.uWrap = a.TextureWrap.ClampToEdge, h.vWrap = a.TextureWrap.ClampToEdge, "x" == w ? h.uWrap = a.TextureWrap.Repeat : "y" == w ? h.vWrap = a.TextureWrap.Repeat : "xy" == w && (h.uWrap = h.vWrap = a.TextureWrap.Repeat), h.texture = g(k), h.texture.setFilters(h.minFilter, 
            h.magFilter), h.texture.setWraps(h.uWrap, h.vWrap), h.width = h.texture.getImage().width, h.height = h.texture.getImage().height, this.pages.push(h);
          }
        }
      }
    };
    h.prototype.findRegion = function(a) {
      for (var b = 0;b < this.regions.length;b++) {
        if (this.regions[b].name == a) {
          return this.regions[b];
        }
      }
      return null;
    };
    h.prototype.dispose = function() {
      for (var a = 0;a < this.pages.length;a++) {
        this.pages[a].texture.dispose();
      }
    };
    return h;
  }();
  a.TextureAtlas = h;
  var l = function() {
    function a(a) {
      this.index = 0;
      this.lines = a.split(/\r\n|\r|\n/);
    }
    a.prototype.readLine = function() {
      return this.index >= this.lines.length ? null : this.lines[this.index++];
    };
    a.prototype.readValue = function() {
      var a = this.readLine(), b = a.indexOf(":");
      if (-1 == b) {
        throw Error("Invalid line: " + a);
      }
      return a.substring(b + 1).trim();
    };
    a.prototype.readTuple = function(a) {
      var b = this.readLine(), c = b.indexOf(":");
      if (-1 == c) {
        throw Error("Invalid line: " + b);
      }
      for (var f = 0, c = c + 1;3 > f;f++) {
        var h = b.indexOf(",", c);
        if (-1 == h) {
          break;
        }
        a[f] = b.substr(c, h - c).trim();
        c = h + 1;
      }
      a[f] = b.substring(c).trim();
      return f + 1;
    };
    return a;
  }(), b = function() {
    return function() {
    };
  }();
  a.TextureAtlasPage = b;
  var f = function(a) {
    function b() {
      a.apply(this, arguments);
    }
    __extends(b, a);
    return b;
  }(a.TextureRegion);
  a.TextureAtlasRegion = f;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function h(b, f) {
      this.shearMix = this.scaleMix = this.translateMix = this.rotateMix = 0;
      this.temp = new a.Vector2;
      if (null == b) {
        throw Error("data cannot be null.");
      }
      if (null == f) {
        throw Error("skeleton cannot be null.");
      }
      this.data = b;
      this.rotateMix = b.rotateMix;
      this.translateMix = b.translateMix;
      this.scaleMix = b.scaleMix;
      this.shearMix = b.shearMix;
      this.bones = [];
      for (var h = 0;h < b.bones.length;h++) {
        this.bones.push(f.findBone(b.bones[h].name));
      }
      this.target = f.findBone(b.target.name);
    }
    h.prototype.apply = function() {
      this.update();
    };
    h.prototype.update = function() {
      for (var b = this.rotateMix, f = this.translateMix, h = this.scaleMix, c = this.shearMix, g = this.target, e = g.a, l = g.b, r = g.c, w = g.d, n = 0 < e * w - l * r ? a.MathUtils.degRad : -a.MathUtils.degRad, t = this.data.offsetRotation * n, n = this.data.offsetShearY * n, v = this.bones, y = 0, x = v.length;y < x;y++) {
        var q = v[y], u = !1;
        if (0 != b) {
          var B = q.a, u = q.b, C = q.c, D = q.d, F = Math.atan2(r, e) - Math.atan2(C, B) + t;
          F > a.MathUtils.PI ? F -= a.MathUtils.PI2 : F < -a.MathUtils.PI && (F += a.MathUtils.PI2);
          var F = F * b, E = Math.cos(F), F = Math.sin(F);
          q.a = E * B - F * C;
          q.b = E * u - F * D;
          q.c = F * B + E * C;
          q.d = F * u + E * D;
          u = !0;
        }
        0 != f && (u = this.temp, g.localToWorld(u.set(this.data.offsetX, this.data.offsetY)), q.worldX += (u.x - q.worldX) * f, q.worldY += (u.y - q.worldY) * f, u = !0);
        0 < h && (u = Math.sqrt(q.a * q.a + q.c * q.c), D = Math.sqrt(e * e + r * r), 1E-5 < u && (u = (u + (D - u + this.data.offsetScaleX) * h) / u), q.a *= u, q.c *= u, u = Math.sqrt(q.b * q.b + q.d * q.d), D = Math.sqrt(l * l + w * w), 1E-5 < u && (u = (u + (D - u + this.data.offsetScaleY) * h) / u), q.b *= u, q.d *= u, u = !0);
        0 < c && (u = q.b, D = q.d, B = Math.atan2(D, u), F = Math.atan2(w, l) - Math.atan2(r, e) - (B - Math.atan2(q.c, q.a)), F > a.MathUtils.PI ? F -= a.MathUtils.PI2 : F < -a.MathUtils.PI && (F += a.MathUtils.PI2), F = B + (F + n) * c, u = Math.sqrt(u * u + D * D), q.b = Math.cos(F) * u, q.d = Math.sin(F) * u, u = !0);
        u && (q.appliedValid = !1);
      }
    };
    h.prototype.getOrder = function() {
      return this.data.order;
    };
    return h;
  }();
  a.TransformConstraint = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    return function(a) {
      this.order = 0;
      this.bones = [];
      this.offsetShearY = this.offsetScaleY = this.offsetScaleX = this.offsetY = this.offsetX = this.offsetRotation = this.shearMix = this.scaleMix = this.translateMix = this.rotateMix = 0;
      if (null == a) {
        throw Error("name cannot be null.");
      }
      this.name = a;
    };
  }();
  a.TransformConstraintData = h;
})(spine || (spine = {}));
(function(a) {
  var h = function() {
    function a() {
      this.array = [];
    }
    a.prototype.add = function(a) {
      var b = this.contains(a);
      this.array[a | 0] = a | 0;
      return !b;
    };
    a.prototype.contains = function(a) {
      return void 0 != this.array[a | 0];
    };
    a.prototype.remove = function(a) {
      this.array[a | 0] = void 0;
    };
    a.prototype.clear = function() {
      this.array.length = 0;
    };
    return a;
  }();
  a.IntSet = h;
  h = function() {
    function a(a, f, h, c) {
      void 0 === a && (a = 0);
      void 0 === f && (f = 0);
      void 0 === h && (h = 0);
      void 0 === c && (c = 0);
      this.r = a;
      this.g = f;
      this.b = h;
      this.a = c;
    }
    a.prototype.set = function(a, f, h, c) {
      this.r = a;
      this.g = f;
      this.b = h;
      this.a = c;
      this.clamp();
      return this;
    };
    a.prototype.setFromColor = function(a) {
      this.r = a.r;
      this.g = a.g;
      this.b = a.b;
      this.a = a.a;
      return this;
    };
    a.prototype.setFromString = function(a) {
      a = "#" == a.charAt(0) ? a.substr(1) : a;
      this.r = parseInt(a.substr(0, 2), 16) / 255;
      this.g = parseInt(a.substr(2, 2), 16) / 255;
      this.b = parseInt(a.substr(4, 2), 16) / 255;
      this.a = (8 != a.length ? 255 : parseInt(a.substr(6, 2), 16)) / 255;
      return this;
    };
    a.prototype.add = function(a, f, h, c) {
      this.r += a;
      this.g += f;
      this.b += h;
      this.a += c;
      this.clamp();
      return this;
    };
    a.prototype.clamp = function() {
      0 > this.r ? this.r = 0 : 1 < this.r && (this.r = 1);
      0 > this.g ? this.g = 0 : 1 < this.g && (this.g = 1);
      0 > this.b ? this.b = 0 : 1 < this.b && (this.b = 1);
      0 > this.a ? this.a = 0 : 1 < this.a && (this.a = 1);
      return this;
    };
    a.WHITE = new a(1, 1, 1, 1);
    a.RED = new a(1, 0, 0, 1);
    a.GREEN = new a(0, 1, 0, 1);
    a.BLUE = new a(0, 0, 1, 1);
    a.MAGENTA = new a(1, 0, 1, 1);
    return a;
  }();
  a.Color = h;
  h = function() {
    function a() {
    }
    a.clamp = function(a, f, h) {
      return a < f ? f : a > h ? h : a;
    };
    a.cosDeg = function(b) {
      return Math.cos(b * a.degRad);
    };
    a.sinDeg = function(b) {
      return Math.sin(b * a.degRad);
    };
    a.signum = function(a) {
      return 0 < a ? 1 : 0 > a ? -1 : 0;
    };
    a.toInt = function(a) {
      return 0 < a ? Math.floor(a) : Math.ceil(a);
    };
    a.cbrt = function(a) {
      var b = Math.pow(Math.abs(a), 1 / 3);
      return 0 > a ? -b : b;
    };
    a.PI = 3.1415927;
    a.PI2 = 2 * a.PI;
    a.radiansToDegrees = 180 / a.PI;
    a.radDeg = a.radiansToDegrees;
    a.degreesToRadians = a.PI / 180;
    a.degRad = a.degreesToRadians;
    return a;
  }();
  a.MathUtils = h;
  h = function() {
    function a() {
    }
    a.arrayCopy = function(a, f, h, c, g) {
      for (var b = f;b < f + g;b++, c++) {
        h[c] = a[b];
      }
    };
    a.setArraySize = function(a, f, h) {
      void 0 === h && (h = 0);
      var b = a.length;
      if (b == f) {
        return a;
      }
      a.length = f;
      if (b < f) {
        for (;b < f;b++) {
          a[b] = h;
        }
      }
      return a;
    };
    a.ensureArrayCapacity = function(b, f, h) {
      void 0 === h && (h = 0);
      return b.length >= f ? b : a.setArraySize(b, f, h);
    };
    a.newArray = function(a, f) {
      for (var b = Array(a), c = 0;c < a;c++) {
        b[c] = f;
      }
      return b;
    };
    a.newFloatArray = function(b) {
      if (a.SUPPORTS_TYPED_ARRAYS) {
        return new Float32Array(b);
      }
      b = Array(b);
      for (var f = 0;f < b.length;f++) {
        b[f] = 0;
      }
      return b;
    };
    a.toFloatArray = function(b) {
      return a.SUPPORTS_TYPED_ARRAYS ? new Float32Array(b) : b;
    };
    a.SUPPORTS_TYPED_ARRAYS = "undefined" !== typeof Float32Array;
    return a;
  }();
  a.Utils = h;
  h = function() {
    function a() {
    }
    a.logBones = function(a) {
      for (var b = 0;b < a.bones.length;b++) {
        var h = a.bones[b];
        console.log(h.data.name + ", " + h.a + ", " + h.b + ", " + h.c + ", " + h.d + ", " + h.worldX + ", " + h.worldY);
      }
    };
    return a;
  }();
  a.DebugUtils = h;
  h = function() {
    function a(a) {
      this.items = [];
      this.instantiator = a;
    }
    a.prototype.obtain = function() {
      return 0 < this.items.length ? this.items.pop() : this.instantiator();
    };
    a.prototype.free = function(a) {
      a.reset && a.reset();
      this.items.push(a);
    };
    a.prototype.freeAll = function(a) {
      for (var b = 0;b < a.length;b++) {
        a[b].reset && a[b].reset(), this.items[b] = a[b];
      }
    };
    a.prototype.clear = function() {
      this.items.length = 0;
    };
    return a;
  }();
  a.Pool = h;
  h = function() {
    function a(a, f) {
      void 0 === a && (a = 0);
      void 0 === f && (f = 0);
      this.x = a;
      this.y = f;
    }
    a.prototype.set = function(a, f) {
      this.x = a;
      this.y = f;
      return this;
    };
    a.prototype.length = function() {
      var a = this.x, f = this.y;
      return Math.sqrt(a * a + f * f);
    };
    a.prototype.normalize = function() {
      var a = this.length();
      0 != a && (this.x /= a, this.y /= a);
      return this;
    };
    return a;
  }();
  a.Vector2 = h;
  h = function() {
    function a() {
      this.maxDelta = .064;
      this.totalTime = this.delta = this.framesPerSecond = 0;
      this.lastTime = Date.now() / 1E3;
      this.frameTime = this.frameCount = 0;
    }
    a.prototype.update = function() {
      var a = Date.now() / 1E3;
      this.delta = a - this.lastTime;
      this.frameTime += this.delta;
      this.totalTime += this.delta;
      this.delta > this.maxDelta && (this.delta = this.maxDelta);
      this.lastTime = a;
      this.frameCount++;
      1 < this.frameTime && (this.framesPerSecond = this.frameCount / this.frameTime, this.frameCount = this.frameTime = 0);
    };
    return a;
  }();
  a.TimeKeeper = h;
})(spine || (spine = {}));
(function(a) {
  (function(h) {
    var l = function(a) {
      function b(b) {
        void 0 === b && (b = "");
        a.call(this, function(a) {
          return new h.ThreeJsTexture(a);
        }, b);
      }
      __extends(b, a);
      return b;
    }(a.AssetManager);
    h.AssetManager = l;
  })(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
  (function(a) {
    var h = function() {
      function a(b, h) {
        void 0 === h && (h = 10920);
        this.indicesLength = this.verticesLength = 0;
        if (10920 < h) {
          throw Error("Can't have more than 10920 triangles per batch: " + h);
        }
        var c = this.vertices = new Float32Array(h * a.VERTEX_SIZE);
        h = this.indices = new Uint16Array(3 * h);
        this.mesh = b;
        var g = new THREE.BufferGeometry, c = this.vertexBuffer = new THREE.InterleavedBuffer(c, a.VERTEX_SIZE);
        c.dynamic = !0;
        g.addAttribute("position", new THREE.InterleavedBufferAttribute(c, 3, 0, !1));
        g.addAttribute("color", new THREE.InterleavedBufferAttribute(c, 4, 3, !1));
        g.addAttribute("uv", new THREE.InterleavedBufferAttribute(c, 2, 7, !1));
        g.setIndex(new THREE.BufferAttribute(h, 1));
        g.getIndex().dynamic = !0;
        g.drawRange.start = 0;
        g.drawRange.count = 0;
        b.geometry = g;
      }
      a.prototype.begin = function() {
        this.indicesLength = this.verticesLength = 0;
      };
      a.prototype.batch = function(b, h, c) {
        void 0 === c && (c = 0);
        for (var g = this.verticesLength / a.VERTEX_SIZE, e = this.vertices, f = this.verticesLength, k = 0;k < b.length;) {
          e[f++] = b[k++], e[f++] = b[k++], e[f++] = c, e[f++] = b[k++], e[f++] = b[k++], e[f++] = b[k++], e[f++] = b[k++], e[f++] = b[k++], e[f++] = b[k++];
        }
        this.verticesLength = f;
        b = this.indices;
        f = this.indicesLength;
        for (k = 0;k < h.length;f++, k++) {
          b[f] = h[k] + g;
        }
        this.indicesLength += h.length;
      };
      a.prototype.end = function() {
        this.vertexBuffer.needsUpdate = !0;
        this.vertexBuffer.updateRange.offset = 0;
        this.vertexBuffer.updateRange.count = this.verticesLength;
        var a = this.mesh.geometry;
        a.getIndex().needsUpdate = !0;
        a.getIndex().updateRange.offset = 0;
        a.getIndex().updateRange.count = this.indicesLength;
        a.drawRange.start = 0;
        a.drawRange.count = this.indicesLength;
      };
      a.VERTEX_SIZE = 9;
      return a;
    }();
    a.MeshBatcher = h;
  })(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
  (function(h) {
    var l = function(b) {
      function f(f) {
        b.call(this);
        this.zOffset = .1;
        this.skeleton = new a.Skeleton(f);
        f = new a.AnimationStateData(f);
        this.state = new a.AnimationState(f);
        f = this.material = new THREE.MeshBasicMaterial;
        f.side = THREE.DoubleSide;
        f.transparent = !0;
        f.alphaTest = .5;
        this.batcher = new h.MeshBatcher(this);
      }
      __extends(f, b);
      f.prototype.update = function(a) {
        var b = this.state, g = this.skeleton;
        b.update(a);
        b.apply(g);
        g.updateWorldTransform();
        this.updateGeometry();
      };
      f.prototype.updateGeometry = function() {
        var b, c, g = this.skeleton.drawOrder, e = this.batcher;
        e.begin();
        for (var h = 0, l = this.zOffset, w = 0, n = g.length;w < n;w++) {
          b = g[w];
          c = b.getAttachment();
          var t;
          if (c instanceof a.RegionAttachment) {
            t = c, b = t.updateWorldVertices(b, !1), c = f.QUAD_TRIANGLES, t = t.region.renderObject.texture;
          } else {
            if (c instanceof a.MeshAttachment) {
              t = c, b = t.updateWorldVertices(b, !1), c = t.triangles, t = t.region.renderObject.texture;
            } else {
              continue;
            }
          }
          if (null != t) {
            if (!this.material.map) {
              var v = this.material;
              v.map = t.texture;
              v.needsUpdate = !0;
            }
            this.batcher.batch(b, c, h);
            h += l;
          }
        }
        e.end();
      };
      f.createMesh = function(a) {
        var b = new THREE.BufferGeometry, g = new Float32Array(1024);
        g.set([-200, -200, 1, 0, 0, 1, 0, 0, 200, -200, 0, 1, 0, 1, 1, 0, 200, 200, 0, 0, 1, 1, 1, 1, -200, 200, 1, 1, 0, .1, 0, 1], 0);
        var g = new THREE.InterleavedBuffer(g, 8), e = new THREE.InterleavedBufferAttribute(g, 2, 0, !1);
        b.addAttribute("position", e);
        e = new THREE.InterleavedBufferAttribute(g, 4, 2, !1);
        b.addAttribute("color", e);
        new THREE.InterleavedBufferAttribute(g, 2, 6, !1);
        b.addAttribute("uv", e);
        g = new Uint16Array(1024);
        g.set([0, 1, 2, 2, 3, 0], 0);
        b.setIndex(new THREE.BufferAttribute(g, 1));
        b.drawRange.start = 0;
        b.drawRange.count = 6;
        g = new THREE.MeshBasicMaterial;
        g.vertexColors = THREE.VertexColors;
        g.transparent = !0;
        g.map = a;
        return new THREE.Mesh(b, g);
      };
      f.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
      return f;
    }(THREE.Mesh);
    h.SkeletonMesh = l;
  })(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
  (function(h) {
    var l = function(b) {
      function f(a) {
        b.call(this, a);
        this.texture = new THREE.Texture(a);
        this.texture.flipY = !1;
        this.texture.needsUpdate = !0;
      }
      __extends(f, b);
      f.prototype.setFilters = function(a, b) {
        this.texture.minFilter = f.toThreeJsTextureFilter(a);
        this.texture.magFilter = f.toThreeJsTextureFilter(b);
      };
      f.prototype.setWraps = function(a, b) {
        this.texture.wrapS = f.toThreeJsTextureWrap(a);
        this.texture.wrapT = f.toThreeJsTextureWrap(b);
      };
      f.prototype.dispose = function() {
        this.texture.dispose();
      };
      f.toThreeJsTextureFilter = function(b) {
        if (b === a.TextureFilter.Linear) {
          return THREE.LinearFilter;
        }
        if (b === a.TextureFilter.MipMap) {
          return THREE.LinearMipMapLinearFilter;
        }
        if (b === a.TextureFilter.MipMapLinearNearest) {
          return THREE.LinearMipMapNearestFilter;
        }
        if (b === a.TextureFilter.MipMapNearestLinear) {
          return THREE.NearestMipMapLinearFilter;
        }
        if (b === a.TextureFilter.MipMapNearestNearest) {
          return THREE.NearestMipMapNearestFilter;
        }
        if (b === a.TextureFilter.Nearest) {
          return THREE.NearestFilter;
        }
        throw Error("Unknown texture filter: " + b);
      };
      f.toThreeJsTextureWrap = function(b) {
        if (b === a.TextureWrap.ClampToEdge) {
          return THREE.ClampToEdgeWrapping;
        }
        if (b === a.TextureWrap.MirroredRepeat) {
          return THREE.MirroredRepeatWrapping;
        }
        if (b === a.TextureWrap.Repeat) {
          return THREE.RepeatWrapping;
        }
        throw Error("Unknown texture wrap: " + b);
      };
      return f;
    }(a.Texture);
    h.ThreeJsTexture = l;
  })(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
  "object" === typeof exports && "undefined" !== typeof module ? module.exports = a() : "function" === typeof define && define.amd ? define([], a) : ("undefined" !== typeof window ? window : "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : this).opentype = a();
})(function() {
  return function h(l, b, f) {
    function k(e, g) {
      if (!b[e]) {
        if (!l[e]) {
          var p = "function" == typeof require && require;
          if (!g && p) {
            return p(e, !0);
          }
          if (c) {
            return c(e, !0);
          }
          g = Error("Cannot find module '" + e + "'");
          throw g.code = "MODULE_NOT_FOUND", g;
        }
        g = b[e] = {exports:{}};
        l[e][0].call(g.exports, function(b) {
          var c = l[e][1][b];
          return k(c ? c : b);
        }, g, g.exports, h, l, b, f);
      }
      return b[e].exports;
    }
    for (var c = "function" == typeof require && require, g = 0;g < f.length;g++) {
      k(f[g]);
    }
    return k;
  }({1:[function(h, l, b) {
    function f() {
      this.table = new Uint16Array(16);
      this.trans = new Uint16Array(288);
    }
    function k(b, c) {
      this.source = b;
      this.bitcount = this.tag = this.sourceIndex = 0;
      this.dest = c;
      this.destLen = 0;
      this.ltree = new f;
      this.dtree = new f;
    }
    function c(b, c, e, g) {
      var f;
      for (f = 0;e > f;++f) {
        b[f] = 0;
      }
      for (f = 0;30 - e > f;++f) {
        b[f + e] = f / e | 0;
      }
      e = g;
      for (f = 0;30 > f;++f) {
        c[f] = e, e += 1 << b[f];
      }
    }
    function g(b, c, e, g) {
      var f, h;
      for (f = 0;16 > f;++f) {
        b.table[f] = 0;
      }
      for (f = 0;g > f;++f) {
        b.table[c[e + f]]++;
      }
      for (f = h = b.table[0] = 0;16 > f;++f) {
        D[f] = h, h += b.table[f];
      }
      for (f = 0;g > f;++f) {
        c[e + f] && (b.trans[D[c[e + f]]++] = f);
      }
    }
    function e(b, c, e) {
      if (!c) {
        return e;
      }
      for (;24 > b.bitcount;) {
        b.tag |= b.source[b.sourceIndex++] << b.bitcount, b.bitcount += 8;
      }
      var g = b.tag & 65535 >>> 16 - c;
      return b.tag >>>= c, b.bitcount -= c, g + e;
    }
    function p(b, c) {
      for (;24 > b.bitcount;) {
        b.tag |= b.source[b.sourceIndex++] << b.bitcount, b.bitcount += 8;
      }
      var e = 0, g = 0, f = 0, h = b.tag;
      do {
        g = 2 * g + (1 & h), h >>>= 1, ++f, e += c.table[f], g -= c.table[f];
      } while (0 <= g);
      return b.tag = h, b.bitcount -= f, c.trans[e + g];
    }
    function r(b, c, g) {
      for (;;) {
        var f = p(b, c);
        if (256 === f) {
          return w;
        }
        if (256 > f) {
          b.dest[b.destLen++] = f;
        } else {
          var h, k, f = f - 257, f = e(b, v[f], y[f]);
          h = p(b, g);
          for (k = h = b.destLen - e(b, x[h], q[h]);h + f > k;++k) {
            b.dest[b.destLen++] = b.dest[k];
          }
        }
      }
    }
    var w = 0, n = new f, t = new f, v = new Uint8Array(30), y = new Uint16Array(30), x = new Uint8Array(30), q = new Uint16Array(30), u = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), B = new f, C = new Uint8Array(320), D = new Uint16Array(16);
    (function(b, c) {
      var e;
      for (e = 0;7 > e;++e) {
        b.table[e] = 0;
      }
      b.table[7] = 24;
      b.table[8] = 152;
      b.table[9] = 112;
      for (e = 0;24 > e;++e) {
        b.trans[e] = 256 + e;
      }
      for (e = 0;144 > e;++e) {
        b.trans[24 + e] = e;
      }
      for (e = 0;8 > e;++e) {
        b.trans[168 + e] = 280 + e;
      }
      for (e = 0;112 > e;++e) {
        b.trans[176 + e] = 144 + e;
      }
      for (e = 0;5 > e;++e) {
        c.table[e] = 0;
      }
      c.table[5] = 32;
      for (e = 0;32 > e;++e) {
        c.trans[e] = e;
      }
    })(n, t);
    c(v, y, 4, 3);
    c(x, q, 2, 1);
    v[28] = 0;
    y[28] = 258;
    l.exports = function(b, c) {
      var f;
      b = new k(b, c);
      do {
        c = b;
        c.bitcount-- || (c.tag = c.source[c.sourceIndex++], c.bitcount = 7);
        f = 1 & c.tag;
        switch(c = (c.tag >>>= 1, f), e(b, 2, 0)) {
          case 0:
            var h, l = h = void 0;
            for (f = b;8 < f.bitcount;) {
              f.sourceIndex--, f.bitcount -= 8;
            }
            if (l = f.source[f.sourceIndex + 1], l = 256 * l + f.source[f.sourceIndex], h = f.source[f.sourceIndex + 3], h = 256 * h + f.source[f.sourceIndex + 2], l !== (65535 & ~h)) {
              f = -3;
            } else {
              f.sourceIndex += 4;
              for (h = l;h;--h) {
                f.dest[f.destLen++] = f.source[f.sourceIndex++];
              }
              f = (f.bitcount = 0, w);
            }
            break;
          case 1:
            f = r(b, n, t);
            break;
          case 2:
            var q, v, l = b, x = b.ltree, y = b.dtree;
            h = e(l, 5, 257);
            f = e(l, 5, 1);
            q = e(l, 4, 4);
            for (v = 0;19 > v;++v) {
              C[v] = 0;
            }
            for (v = 0;q > v;++v) {
              var D = e(l, 3, 0);
              C[u[v]] = D;
            }
            g(B, C, 0, 19);
            for (v = 0;h + f > v;) {
              switch(q = p(l, B), q) {
                case 16:
                  D = C[v - 1];
                  for (q = e(l, 2, 3);q;--q) {
                    C[v++] = D;
                  }
                  break;
                case 17:
                  for (q = e(l, 3, 3);q;--q) {
                    C[v++] = 0;
                  }
                  break;
                case 18:
                  for (q = e(l, 7, 11);q;--q) {
                    C[v++] = 0;
                  }
                  break;
                default:
                  C[v++] = q;
              }
            }
            g(x, C, 0, h);
            g(y, C, h, f);
            f = r(b, b.ltree, b.dtree);
            break;
          default:
            f = -3;
        }
        if (f !== w) {
          throw Error("Data error");
        }
      } while (!c);
      return b.destLen < b.dest.length ? "function" == typeof b.dest.slice ? b.dest.slice(0, b.destLen) : b.dest.subarray(0, b.destLen) : b.dest;
    };
  }, {}], 2:[function(h, l, b) {
    b.fail = function(b) {
      throw Error(b);
    };
    b.argument = function(f, h) {
      f || b.fail(h);
    };
    b.assert = b.argument;
  }, {}], 3:[function(h, l, b) {
    b.line = function(b, h, c, g, e) {
      b.beginPath();
      b.moveTo(h, c);
      b.lineTo(g, e);
      b.stroke();
    };
  }, {}], 4:[function(h, l, b) {
    function f(b) {
      this.font = b;
    }
    function k(b) {
      this.cmap = b;
    }
    function c(b, c) {
      this.encoding = b;
      this.charset = c;
    }
    function g(c) {
      var e;
      switch(c.version) {
        case 1:
          this.names = b.standardNames.slice();
          break;
        case 2:
          this.names = Array(c.numberOfGlyphs);
          for (e = 0;e < c.numberOfGlyphs;e++) {
            this.names[e] = c.glyphNameIndex[e] < b.standardNames.length ? b.standardNames[c.glyphNameIndex[e]] : c.names[c.glyphNameIndex[e] - b.standardNames.length];
          }
          break;
        case 2.5:
          this.names = Array(c.numberOfGlyphs);
          for (e = 0;e < c.numberOfGlyphs;e++) {
            this.names[e] = b.standardNames[e + c.glyphNameIndex[e]];
          }
          break;
        case 3:
          this.names = [];
      }
    }
    f.prototype.charToGlyphIndex = function(b) {
      b = b.charCodeAt(0);
      var c = this.font.glyphs;
      if (!c) {
        return null;
      }
      for (var e = 0;e < c.length;e += 1) {
        for (var g = c.get(e), f = 0;f < g.unicodes.length;f += 1) {
          if (g.unicodes[f] === b) {
            return e;
          }
        }
      }
    };
    k.prototype.charToGlyphIndex = function(b) {
      return this.cmap.glyphIndexMap[b.charCodeAt(0)] || 0;
    };
    c.prototype.charToGlyphIndex = function(b) {
      b = b.charCodeAt(0);
      return this.charset.indexOf(this.encoding[b]);
    };
    g.prototype.nameToGlyphIndex = function(b) {
      return this.names.indexOf(b);
    };
    g.prototype.glyphIndexToName = function(b) {
      return this.names[b];
    };
    b.cffStandardStrings = ".notdef;space;exclam;quotedbl;numbersign;dollar;percent;ampersand;quoteright;parenleft;parenright;asterisk;plus;comma;hyphen;period;slash;zero;one;two;three;four;five;six;seven;eight;nine;colon;semicolon;less;equal;greater;question;at;A;B;C;D;E;F;G;H;I;J;K;L;M;N;O;P;Q;R;S;T;U;V;W;X;Y;Z;bracketleft;backslash;bracketright;asciicircum;underscore;quoteleft;a;b;c;d;e;f;g;h;i;j;k;l;m;n;o;p;q;r;s;t;u;v;w;x;y;z;braceleft;bar;braceright;asciitilde;exclamdown;cent;sterling;fraction;yen;florin;section;currency;quotesingle;quotedblleft;guillemotleft;guilsinglleft;guilsinglright;fi;fl;endash;dagger;daggerdbl;periodcentered;paragraph;bullet;quotesinglbase;quotedblbase;quotedblright;guillemotright;ellipsis;perthousand;questiondown;grave;acute;circumflex;tilde;macron;breve;dotaccent;dieresis;ring;cedilla;hungarumlaut;ogonek;caron;emdash;AE;ordfeminine;Lslash;Oslash;OE;ordmasculine;ae;dotlessi;lslash;oslash;oe;germandbls;onesuperior;logicalnot;mu;trademark;Eth;onehalf;plusminus;Thorn;onequarter;divide;brokenbar;degree;thorn;threequarters;twosuperior;registered;minus;eth;multiply;threesuperior;copyright;Aacute;Acircumflex;Adieresis;Agrave;Aring;Atilde;Ccedilla;Eacute;Ecircumflex;Edieresis;Egrave;Iacute;Icircumflex;Idieresis;Igrave;Ntilde;Oacute;Ocircumflex;Odieresis;Ograve;Otilde;Scaron;Uacute;Ucircumflex;Udieresis;Ugrave;Yacute;Ydieresis;Zcaron;aacute;acircumflex;adieresis;agrave;aring;atilde;ccedilla;eacute;ecircumflex;edieresis;egrave;iacute;icircumflex;idieresis;igrave;ntilde;oacute;ocircumflex;odieresis;ograve;otilde;scaron;uacute;ucircumflex;udieresis;ugrave;yacute;ydieresis;zcaron;exclamsmall;Hungarumlautsmall;dollaroldstyle;dollarsuperior;ampersandsmall;Acutesmall;parenleftsuperior;parenrightsuperior;266 ff;onedotenleader;zerooldstyle;oneoldstyle;twooldstyle;threeoldstyle;fouroldstyle;fiveoldstyle;sixoldstyle;sevenoldstyle;eightoldstyle;nineoldstyle;commasuperior;threequartersemdash;periodsuperior;questionsmall;asuperior;bsuperior;centsuperior;dsuperior;esuperior;isuperior;lsuperior;msuperior;nsuperior;osuperior;rsuperior;ssuperior;tsuperior;ff;ffi;ffl;parenleftinferior;parenrightinferior;Circumflexsmall;hyphensuperior;Gravesmall;Asmall;Bsmall;Csmall;Dsmall;Esmall;Fsmall;Gsmall;Hsmall;Ismall;Jsmall;Ksmall;Lsmall;Msmall;Nsmall;Osmall;Psmall;Qsmall;Rsmall;Ssmall;Tsmall;Usmall;Vsmall;Wsmall;Xsmall;Ysmall;Zsmall;colonmonetary;onefitted;rupiah;Tildesmall;exclamdownsmall;centoldstyle;Lslashsmall;Scaronsmall;Zcaronsmall;Dieresissmall;Brevesmall;Caronsmall;Dotaccentsmall;Macronsmall;figuredash;hypheninferior;Ogoneksmall;Ringsmall;Cedillasmall;questiondownsmall;oneeighth;threeeighths;fiveeighths;seveneighths;onethird;twothirds;zerosuperior;foursuperior;fivesuperior;sixsuperior;sevensuperior;eightsuperior;ninesuperior;zeroinferior;oneinferior;twoinferior;threeinferior;fourinferior;fiveinferior;sixinferior;seveninferior;eightinferior;nineinferior;centinferior;dollarinferior;periodinferior;commainferior;Agravesmall;Aacutesmall;Acircumflexsmall;Atildesmall;Adieresissmall;Aringsmall;AEsmall;Ccedillasmall;Egravesmall;Eacutesmall;Ecircumflexsmall;Edieresissmall;Igravesmall;Iacutesmall;Icircumflexsmall;Idieresissmall;Ethsmall;Ntildesmall;Ogravesmall;Oacutesmall;Ocircumflexsmall;Otildesmall;Odieresissmall;OEsmall;Oslashsmall;Ugravesmall;Uacutesmall;Ucircumflexsmall;Udieresissmall;Yacutesmall;Thornsmall;Ydieresissmall;001.000;001.001;001.002;001.003;Black;Bold;Book;Light;Medium;Regular;Roman;Semibold".split(";");
    b.cffStandardEncoding = "                                space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk plus comma hyphen period slash zero one two three four five six seven eight nine colon semicolon less equal greater question at A B C D E F G H I J K L M N O P Q R S T U V W X Y Z bracketleft backslash bracketright asciicircum underscore quoteleft a b c d e f g h i j k l m n o p q r s t u v w x y z braceleft bar braceright asciitilde                                   exclamdown cent sterling fraction yen florin section currency quotesingle quotedblleft guillemotleft guilsinglleft guilsinglright fi fl  endash dagger daggerdbl periodcentered  paragraph bullet quotesinglbase quotedblbase quotedblright guillemotright ellipsis perthousand  questiondown  grave acute circumflex tilde macron breve dotaccent dieresis  ring cedilla  hungarumlaut ogonek caron emdash                 AE  ordfeminine     Lslash Oslash OE ordmasculine      ae    dotlessi   lslash oslash oe germandbls".split(" ");
    b.cffExpertEncoding = "                                space exclamsmall Hungarumlautsmall  dollaroldstyle dollarsuperior ampersandsmall Acutesmall parenleftsuperior parenrightsuperior twodotenleader onedotenleader comma hyphen period fraction zerooldstyle oneoldstyle twooldstyle threeoldstyle fouroldstyle fiveoldstyle sixoldstyle sevenoldstyle eightoldstyle nineoldstyle colon semicolon commasuperior threequartersemdash periodsuperior questionsmall  asuperior bsuperior centsuperior dsuperior esuperior   isuperior   lsuperior msuperior nsuperior osuperior   rsuperior ssuperior tsuperior  ff fi fl ffi ffl parenleftinferior  parenrightinferior Circumflexsmall hyphensuperior Gravesmall Asmall Bsmall Csmall Dsmall Esmall Fsmall Gsmall Hsmall Ismall Jsmall Ksmall Lsmall Msmall Nsmall Osmall Psmall Qsmall Rsmall Ssmall Tsmall Usmall Vsmall Wsmall Xsmall Ysmall Zsmall colonmonetary onefitted rupiah Tildesmall                                   exclamdownsmall centoldstyle Lslashsmall   Scaronsmall Zcaronsmall Dieresissmall Brevesmall Caronsmall  Dotaccentsmall   Macronsmall   figuredash hypheninferior   Ogoneksmall Ringsmall Cedillasmall    onequarter onehalf threequarters questiondownsmall oneeighth threeeighths fiveeighths seveneighths onethird twothirds   zerosuperior onesuperior twosuperior threesuperior foursuperior fivesuperior sixsuperior sevensuperior eightsuperior ninesuperior zeroinferior oneinferior twoinferior threeinferior fourinferior fiveinferior sixinferior seveninferior eightinferior nineinferior centinferior dollarinferior periodinferior commainferior Agravesmall Aacutesmall Acircumflexsmall Atildesmall Adieresissmall Aringsmall AEsmall Ccedillasmall Egravesmall Eacutesmall Ecircumflexsmall Edieresissmall Igravesmall Iacutesmall Icircumflexsmall Idieresissmall Ethsmall Ntildesmall Ogravesmall Oacutesmall Ocircumflexsmall Otildesmall Odieresissmall OEsmall Oslashsmall Ugravesmall Uacutesmall Ucircumflexsmall Udieresissmall Yacutesmall Thornsmall Ydieresissmall".split(" ");
    b.standardNames = ".notdef .null nonmarkingreturn space exclam quotedbl numbersign dollar percent ampersand quotesingle parenleft parenright asterisk plus comma hyphen period slash zero one two three four five six seven eight nine colon semicolon less equal greater question at A B C D E F G H I J K L M N O P Q R S T U V W X Y Z bracketleft backslash bracketright asciicircum underscore grave a b c d e f g h i j k l m n o p q r s t u v w x y z braceleft bar braceright asciitilde Adieresis Aring Ccedilla Eacute Ntilde Odieresis Udieresis aacute agrave acircumflex adieresis atilde aring ccedilla eacute egrave ecircumflex edieresis iacute igrave icircumflex idieresis ntilde oacute ograve ocircumflex odieresis otilde uacute ugrave ucircumflex udieresis dagger degree cent sterling section bullet paragraph germandbls registered copyright trademark acute dieresis notequal AE Oslash infinity plusminus lessequal greaterequal yen mu partialdiff summation product pi integral ordfeminine ordmasculine Omega ae oslash questiondown exclamdown logicalnot radical florin approxequal Delta guillemotleft guillemotright ellipsis nonbreakingspace Agrave Atilde Otilde OE oe endash emdash quotedblleft quotedblright quoteleft quoteright divide lozenge ydieresis Ydieresis fraction currency guilsinglleft guilsinglright fi fl daggerdbl periodcentered quotesinglbase quotedblbase perthousand Acircumflex Ecircumflex Aacute Edieresis Egrave Iacute Icircumflex Idieresis Igrave Oacute Ocircumflex apple Ograve Uacute Ucircumflex Ugrave dotlessi circumflex tilde macron breve dotaccent ring cedilla hungarumlaut ogonek caron Lslash lslash Scaron scaron Zcaron zcaron brokenbar Eth eth Yacute yacute Thorn thorn minus multiply onesuperior twosuperior threesuperior onehalf onequarter threequarters franc Gbreve gbreve Idotaccent Scedilla scedilla Cacute cacute Ccaron ccaron dcroat".split(" ");
    b.DefaultEncoding = f;
    b.CmapEncoding = k;
    b.CffEncoding = c;
    b.GlyphNames = g;
    b.addGlyphNames = function(b) {
      for (var c, e = b.tables.cmap.glyphIndexMap, g = Object.keys(e), f = 0;f < g.length;f += 1) {
        var h = g[f];
        c = b.glyphs.get(e[h]);
        c.addUnicode(parseInt(h));
      }
      for (f = 0;f < b.glyphs.length;f += 1) {
        c = b.glyphs.get(f), b.cffEncoding ? c.name = b.cffEncoding.charset[f] : b.glyphNames.names && (c.name = b.glyphNames.glyphIndexToName(f));
      }
    };
  }, {}], 5:[function(h, l, b) {
    function f(b) {
      b = b || {};
      b.empty || (r.checkArgument(b.familyName, "When creating a new Font object, familyName is required."), r.checkArgument(b.styleName, "When creating a new Font object, styleName is required."), r.checkArgument(b.unitsPerEm, "When creating a new Font object, unitsPerEm is required."), r.checkArgument(b.ascender, "When creating a new Font object, ascender is required."), r.checkArgument(b.descender, "When creating a new Font object, descender is required."), r.checkArgument(0 > b.descender, "Descender should be negative (e.g. -512)."), 
      this.names = {fontFamily:{en:b.familyName || " "}, fontSubfamily:{en:b.styleName || " "}, fullName:{en:b.fullName || b.familyName + " " + b.styleName}, postScriptName:{en:b.postScriptName || b.familyName + b.styleName}, designer:{en:b.designer || " "}, designerURL:{en:b.designerURL || " "}, manufacturer:{en:b.manufacturer || " "}, manufacturerURL:{en:b.manufacturerURL || " "}, license:{en:b.license || " "}, licenseURL:{en:b.licenseURL || " "}, version:{en:b.version || "Version 0.1"}, description:{en:b.description || 
      " "}, copyright:{en:b.copyright || " "}, trademark:{en:b.trademark || " "}}, this.unitsPerEm = b.unitsPerEm || 1E3, this.ascender = b.ascender, this.descender = b.descender, this.createdTimestamp = b.createdTimestamp, this.tables = {os2:{usWeightClass:b.weightClass || this.usWeightClasses.MEDIUM, usWidthClass:b.widthClass || this.usWidthClasses.MEDIUM, fsSelection:b.fsSelection || this.fsSelectionValues.REGULAR}});
      this.supported = !0;
      this.glyphs = new e.GlyphSet(this, b.glyphs || []);
      this.encoding = new g.DefaultEncoding(this);
      this.substitution = new p(this);
      this.tables = this.tables || {};
    }
    var k = h("./path"), c = h("./tables/sfnt"), g = h("./encoding"), e = h("./glyphset"), p = h("./substitution"), r = h("./util");
    f.prototype.hasChar = function(b) {
      return null !== this.encoding.charToGlyphIndex(b);
    };
    f.prototype.charToGlyphIndex = function(b) {
      return this.encoding.charToGlyphIndex(b);
    };
    f.prototype.charToGlyph = function(b) {
      b = this.charToGlyphIndex(b);
      b = this.glyphs.get(b);
      return b || (b = this.glyphs.get(0)), b;
    };
    f.prototype.stringToGlyphs = function(b) {
      for (var c = [], e = 0;e < b.length;e += 1) {
        c.push(this.charToGlyph(b[e]));
      }
      return c;
    };
    f.prototype.nameToGlyphIndex = function(b) {
      return this.glyphNames.nameToGlyphIndex(b);
    };
    f.prototype.nameToGlyph = function(b) {
      b = this.nametoGlyphIndex(b);
      b = this.glyphs.get(b);
      return b || (b = this.glyphs.get(0)), b;
    };
    f.prototype.glyphIndexToName = function(b) {
      return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(b) : "";
    };
    f.prototype.getKerningValue = function(b, c) {
      b = b.index || b;
      c = c.index || c;
      var e = this.getGposKerningValue;
      return e ? e(b, c) : this.kerningPairs[b + "," + c] || 0;
    };
    f.prototype.forEachGlyph = function(b, c, e, g, f, h) {
      c = void 0 !== c ? c : 0;
      e = void 0 !== e ? e : 0;
      g = void 0 !== g ? g : 72;
      f = f || {};
      var k = void 0 === f.kerning ? !0 : f.kerning, l = 1 / this.unitsPerEm * g;
      b = this.stringToGlyphs(b);
      for (var n = 0;n < b.length;n += 1) {
        var p = b[n];
        if (h(p, c, e, g, f), p.advanceWidth && (c += p.advanceWidth * l), k && n < b.length - 1) {
          p = this.getKerningValue(p, b[n + 1]), c += p * l;
        }
      }
    };
    f.prototype.getPath = function(b, c, e, g, f) {
      var h = new k.Path;
      return this.forEachGlyph(b, c, e, g, f, function(b, c, e, g) {
        b = b.getPath(c, e, g);
        h.extend(b);
      }), h;
    };
    f.prototype.getPaths = function(b, c, e, g, f) {
      var h = [];
      return this.forEachGlyph(b, c, e, g, f, function(b, c, e, g) {
        b = b.getPath(c, e, g);
        h.push(b);
      }), h;
    };
    f.prototype.draw = function(b, c, e, g, f, h) {
      this.getPath(c, e, g, f, h).draw(b);
    };
    f.prototype.drawPoints = function(b, c, e, g, f, h) {
      this.forEachGlyph(c, e, g, f, h, function(c, e, g, f) {
        c.drawPoints(b, e, g, f);
      });
    };
    f.prototype.drawMetrics = function(b, c, e, g, f, h) {
      this.forEachGlyph(c, e, g, f, h, function(c, e, g, f) {
        c.drawMetrics(b, e, g, f);
      });
    };
    f.prototype.getEnglishName = function(b) {
      return (b = this.names[b]) ? b.en : void 0;
    };
    f.prototype.validate = function() {
      function b(b) {
        var g = e.getEnglishName(b);
        g && 0 < g.trim().length || c.push("No English " + b + " specified.");
      }
      var c = [], e = this;
      b("fontFamily");
      b("weightName");
      b("manufacturer");
      b("copyright");
      b("version");
      0 < this.unitsPerEm || c.push("No unitsPerEm specified.");
    };
    f.prototype.toTables = function() {
      return c.fontToTable(this);
    };
    f.prototype.toBuffer = function() {
      return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."), this.toArrayBuffer();
    };
    f.prototype.toArrayBuffer = function() {
      for (var b = this.toTables().encode(), c = new ArrayBuffer(b.length), e = new Uint8Array(c), g = 0;g < b.length;g++) {
        e[g] = b[g];
      }
      return c;
    };
    f.prototype.download = function() {
      var b = this.getEnglishName("fontFamily"), c = this.getEnglishName("fontSubfamily"), e = b.replace(/\s/g, "") + "-" + c + ".otf", g = this.toArrayBuffer();
      r.isBrowser() ? (window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem, window.requestFileSystem(window.TEMPORARY, g.byteLength, function(b) {
        b.root.getFile(e, {create:!0}, function(b) {
          b.createWriter(function(c) {
            var e = new DataView(g), e = new Blob([e], {type:"font/opentype"});
            c.write(e);
            c.addEventListener("writeend", function() {
              location.href = b.toURL();
            }, !1);
          });
        });
      }, function(b) {
        throw Error(b.name + ": " + b.message);
      })) : (b = h("fs"), c = r.arrayBufferToNodeBuffer(g), b.writeFileSync(e, c));
    };
    f.prototype.fsSelectionValues = {ITALIC:1, UNDERSCORE:2, NEGATIVE:4, OUTLINED:8, STRIKEOUT:16, BOLD:32, REGULAR:64, USER_TYPO_METRICS:128, WWS:256, OBLIQUE:512};
    f.prototype.usWidthClasses = {ULTRA_CONDENSED:1, EXTRA_CONDENSED:2, CONDENSED:3, SEMI_CONDENSED:4, MEDIUM:5, SEMI_EXPANDED:6, EXPANDED:7, EXTRA_EXPANDED:8, ULTRA_EXPANDED:9};
    f.prototype.usWeightClasses = {THIN:100, EXTRA_LIGHT:200, LIGHT:300, NORMAL:400, MEDIUM:500, SEMI_BOLD:600, BOLD:700, EXTRA_BOLD:800, BLACK:900};
    b.Font = f;
  }, {"./encoding":4, "./glyphset":7, "./path":11, "./substitution":12, "./tables/sfnt":31, "./util":33, fs:void 0}], 6:[function(h, l, b) {
    function f(b, c) {
      var e = c || {commands:[]};
      return {configurable:!0, get:function() {
        return "function" == typeof e && (e = e()), e;
      }, set:function(b) {
        e = b;
      }};
    }
    function k(b) {
      this.bindConstructorValues(b);
    }
    var c = h("./check"), g = h("./draw"), e = h("./path");
    k.prototype.bindConstructorValues = function(b) {
      this.index = b.index || 0;
      this.name = b.name || null;
      this.unicode = b.unicode || void 0;
      this.unicodes = b.unicodes || void 0 !== b.unicode ? [b.unicode] : [];
      b.xMin && (this.xMin = b.xMin);
      b.yMin && (this.yMin = b.yMin);
      b.xMax && (this.xMax = b.xMax);
      b.yMax && (this.yMax = b.yMax);
      b.advanceWidth && (this.advanceWidth = b.advanceWidth);
      Object.defineProperty(this, "path", f(this, b.path));
    };
    k.prototype.addUnicode = function(b) {
      0 === this.unicodes.length && (this.unicode = b);
      this.unicodes.push(b);
    };
    k.prototype.getPath = function(b, c, g, f) {
      b = void 0 !== b ? b : 0;
      c = void 0 !== c ? c : 0;
      f = void 0 !== f ? f : {xScale:1, yScale:1};
      var h = 1 / this.path.unitsPerEm * (void 0 !== g ? g : 72);
      g = f.xScale * h;
      f = f.yScale * h;
      for (var h = new e.Path, k = this.path.commands, l = 0;l < k.length;l += 1) {
        var n = k[l];
        "M" === n.type ? h.moveTo(b + n.x * g, c + -n.y * f) : "L" === n.type ? h.lineTo(b + n.x * g, c + -n.y * f) : "Q" === n.type ? h.quadraticCurveTo(b + n.x1 * g, c + -n.y1 * f, b + n.x * g, c + -n.y * f) : "C" === n.type ? h.curveTo(b + n.x1 * g, c + -n.y1 * f, b + n.x2 * g, c + -n.y2 * f, b + n.x * g, c + -n.y * f) : "Z" === n.type && h.closePath();
      }
      return h;
    };
    k.prototype.getContours = function() {
      if (void 0 === this.points) {
        return [];
      }
      for (var b = [], e = [], g = 0;g < this.points.length;g += 1) {
        var f = this.points[g];
        e.push(f);
        f.lastPointOfContour && (b.push(e), e = []);
      }
      return c.argument(0 === e.length, "There are still points left in the current contour."), b;
    };
    k.prototype.getMetrics = function() {
      for (var b = this.path.commands, c = [], e = [], g = 0;g < b.length;g += 1) {
        var f = b[g];
        "Z" !== f.type && (c.push(f.x), e.push(f.y));
        "Q" !== f.type && "C" !== f.type || (c.push(f.x1), e.push(f.y1));
        "C" === f.type && (c.push(f.x2), e.push(f.y2));
      }
      b = {xMin:Math.min.apply(null, c), yMin:Math.min.apply(null, e), xMax:Math.max.apply(null, c), yMax:Math.max.apply(null, e), leftSideBearing:this.leftSideBearing};
      return isFinite(b.xMin) || (b.xMin = 0), isFinite(b.xMax) || (b.xMax = this.advanceWidth), isFinite(b.yMin) || (b.yMin = 0), isFinite(b.yMax) || (b.yMax = 0), b.rightSideBearing = this.advanceWidth - b.leftSideBearing - (b.xMax - b.xMin), b;
    };
    k.prototype.draw = function(b, c, e, g, f) {
      this.getPath(c, e, g, f).draw(b);
    };
    k.prototype.drawPoints = function(b, c, e, g) {
      function f(c, e, g, f) {
        var h = 2 * Math.PI;
        b.beginPath();
        for (var k = 0;k < c.length;k += 1) {
          b.moveTo(e + c[k].x * f, g + c[k].y * f), b.arc(e + c[k].x * f, g + c[k].y * f, 2, 0, h, !1);
        }
        b.closePath();
        b.fill();
      }
      c = void 0 !== c ? c : 0;
      e = void 0 !== e ? e : 0;
      g = 1 / this.path.unitsPerEm * (void 0 !== g ? g : 24);
      for (var h = [], k = [], l = this.path, n = 0;n < l.commands.length;n += 1) {
        var p = l.commands[n];
        void 0 !== p.x && h.push({x:p.x, y:-p.y});
        void 0 !== p.x1 && k.push({x:p.x1, y:-p.y1});
        void 0 !== p.x2 && k.push({x:p.x2, y:-p.y2});
      }
      b.fillStyle = "blue";
      f(h, c, e, g);
      b.fillStyle = "red";
      f(k, c, e, g);
    };
    k.prototype.drawMetrics = function(b, c, e, f) {
      c = void 0 !== c ? c : 0;
      e = void 0 !== e ? e : 0;
      f = 1 / this.path.unitsPerEm * (void 0 !== f ? f : 24);
      b.lineWidth = 1;
      b.strokeStyle = "black";
      g.line(b, c, -1E4, c, 1E4);
      g.line(b, -1E4, e, 1E4, e);
      var h = this.xMin || 0, k = this.yMin || 0, l = this.xMax || 0, n = this.yMax || 0, p = this.advanceWidth || 0;
      b.strokeStyle = "blue";
      g.line(b, c + h * f, -1E4, c + h * f, 1E4);
      g.line(b, c + l * f, -1E4, c + l * f, 1E4);
      g.line(b, -1E4, e + -k * f, 1E4, e + -k * f);
      g.line(b, -1E4, e + -n * f, 1E4, e + -n * f);
      b.strokeStyle = "green";
      g.line(b, c + p * f, -1E4, c + p * f, 1E4);
    };
    b.Glyph = k;
  }, {"./check":2, "./draw":3, "./path":11}], 7:[function(h, l, b) {
    function f(b, c, f) {
      Object.defineProperty(b, c, {get:function() {
        return b.path, b[f];
      }, set:function(c) {
        b[f] = c;
      }, enumerable:!0, configurable:!0});
    }
    function k(b, c) {
      if (this.font = b, this.glyphs = {}, Array.isArray(c)) {
        for (b = 0;b < c.length;b++) {
          this.glyphs[b] = c[b];
        }
      }
      this.length = c && c.length || 0;
    }
    var c = h("./glyph");
    k.prototype.get = function(b) {
      return "function" == typeof this.glyphs[b] && (this.glyphs[b] = this.glyphs[b]()), this.glyphs[b];
    };
    k.prototype.push = function(b, c) {
      this.glyphs[b] = c;
      this.length++;
    };
    b.GlyphSet = k;
    b.glyphLoader = function(b, e) {
      return new c.Glyph({index:e, font:b});
    };
    b.ttfGlyphLoader = function(b, e, h, k, l, n) {
      return function() {
        var g = new c.Glyph({index:e, font:b});
        return g.path = function() {
          h(g, k, l);
          var c = n(b.glyphs, g);
          return c.unitsPerEm = b.unitsPerEm, c;
        }, f(g, "xMin", "_xMin"), f(g, "xMax", "_xMax"), f(g, "yMin", "_yMin"), f(g, "yMax", "_yMax"), g;
      };
    };
    b.cffGlyphLoader = function(b, e, f, h) {
      return function() {
        var g = new c.Glyph({index:e, font:b});
        return g.path = function() {
          var c = f(b, g, h);
          return c.unitsPerEm = b.unitsPerEm, c;
        }, g;
      };
    };
  }, {"./glyph":6}], 8:[function(h, l, b) {
    function f(b, g) {
      for (var c = 0, f = b.length - 1;f >= c;) {
        var h = c + f >>> 1, k = b[h].tag;
        if (k === g) {
          return h;
        }
        g > k ? c = h + 1 : f = h - 1;
      }
      return -c - 1;
    }
    var k = h("./check");
    l.exports = {searchTag:f, binSearch:function(b, g) {
      for (var c = 0, f = b.length - 1;f >= c;) {
        var h = c + f >>> 1, k = b[h];
        if (k === g) {
          return h;
        }
        g > k ? c = h + 1 : f = h - 1;
      }
      return -c - 1;
    }, getScriptNames:function() {
      var b = this.getGsubTable();
      return b ? b.scripts.map(function(b) {
        return b.tag;
      }) : [];
    }, getScriptTable:function(b, g) {
      var c = this.getGsubTable(g);
      if (c) {
        g = c.scripts;
        c = f(c.scripts, b);
        if (0 <= c) {
          return g[c].script;
        }
        b = {tag:b, script:{defaultLangSys:{reserved:0, reqFeatureIndex:65535, featureIndexes:[]}, langSysRecords:[]}};
        return g.splice(-1 - c, 0, b.script), b;
      }
    }, getLangSysTable:function(b, g, e) {
      if (b = this.getScriptTable(b, e)) {
        if ("DFLT" === g) {
          return b.defaultLangSys;
        }
        var c = f(b.langSysRecords, g);
        if (0 <= c) {
          return b.langSysRecords[c].langSys;
        }
        if (e) {
          return g = {tag:g, langSys:{reserved:0, reqFeatureIndex:65535, featureIndexes:[]}}, b.langSysRecords.splice(-1 - c, 0, g), g.langSys;
        }
      }
    }, getFeatureTable:function(b, g, e, f) {
      if (b = this.getLangSysTable(b, g, f)) {
        var c;
        b = b.featureIndexes;
        g = this.font.tables.gsub.features;
        for (var h = 0;h < b.length;h++) {
          if (c = g[b[h]], c.tag === e) {
            return c.feature;
          }
        }
        if (f) {
          return f = g.length, k.assert(0 === f || e >= g[f - 1].tag, "Features must be added in alphabetical order."), c = {tag:e, feature:{params:0, lookupListIndexes:[]}}, g.push(c), b.push(f), c.feature;
        }
      }
    }, getLookupTable:function(b, g, e, f, h) {
      if (b = this.getFeatureTable(b, g, e, h)) {
        var c;
        b = b.lookupListIndexes;
        g = this.font.tables.gsub.lookups;
        for (e = 0;e < b.length;e++) {
          if (c = g[b[e]], c.lookupType === f) {
            return c;
          }
        }
        if (h) {
          return c = {lookupType:f, lookupFlag:0, subtables:[], markFilteringSet:void 0}, f = g.length, g.push(c), b.push(f), c;
        }
      }
    }, expandCoverage:function(b) {
      if (1 === b.format) {
        return b.glyphs;
      }
      var c = [];
      b = b.ranges;
      for (var e = 0;b > e;e++) {
        for (var f = b[e], h = f.end, f = f.start;h >= f;f++) {
          c.push(f);
        }
      }
      return c;
    }};
  }, {"./check":2}], 9:[function(h, l, b) {
    function f(b, c) {
      h("fs").readFile(b, function(b, e) {
        return b ? c(b.message) : void c(null, v.nodeBufferToArrayBuffer(e));
      });
    }
    function k(b, c) {
      var e = new XMLHttpRequest;
      e.open("get", b, !0);
      e.responseType = "arraybuffer";
      e.onload = function() {
        return 200 !== e.status ? c("Font could not be loaded: " + e.statusText) : c(null, e.response);
      };
      e.send();
    }
    function c(b, c) {
      for (var e = [], g = 12, f = 0;c > f;f += 1) {
        var h = n.getTag(b, g), k = n.getULong(b, g + 4), l = n.getULong(b, g + 8), p = n.getULong(b, g + 12);
        e.push({tag:h, checksum:k, offset:l, length:p, compression:!1});
        g += 16;
      }
      return e;
    }
    function g(b, c) {
      if ("WOFF" === c.compression) {
        b = new Uint8Array(b.buffer, c.offset + 2, c.compressedLength - 2);
        var e = new Uint8Array(c.originalLength);
        if (p(b, e), e.byteLength !== c.originalLength) {
          throw Error("Decompression error: " + c.tag + " decompressed length doesn't match recorded length");
        }
        return {data:new DataView(e.buffer, 0), offset:0};
      }
      return {data:b, offset:c.offset};
    }
    function e(b) {
      var e, f, h, k = new w.Font({empty:!0});
      b = new DataView(b, 0);
      var l;
      h = n.getTag(b, 0);
      if (h === String.fromCharCode(0, 1, 0, 0)) {
        k.outlinesFormat = "truetype", h = n.getUShort(b, 4), l = c(b, h);
      } else {
        if ("OTTO" === h) {
          k.outlinesFormat = "cff", h = n.getUShort(b, 4), l = c(b, h);
        } else {
          if ("wOFF" !== h) {
            throw Error("Unsupported OpenType signature " + h);
          }
          l = n.getTag(b, 4);
          if (l === String.fromCharCode(0, 1, 0, 0)) {
            k.outlinesFormat = "truetype";
          } else {
            if ("OTTO" !== l) {
              throw Error("Unsupported OpenType flavor " + h);
            }
            k.outlinesFormat = "cff";
          }
          l = h = n.getUShort(b, 12);
          for (var p = [], t = 44, v = 0;l > v;v += 1) {
            var ba = n.getTag(b, t), T = n.getULong(b, t + 4), ra = n.getULong(b, t + 8), qa = n.getULong(b, t + 12);
            p.push({tag:ba, offset:T, compression:qa > ra ? "WOFF" : !1, compressedLength:ra, originalLength:qa});
            t += 20;
          }
          l = p;
        }
      }
      for (var pa, fa, W, sa, xa, Aa, Ba, ya, Ea, Xa, p = 0;h > p;p += 1) {
        switch(t = l[p], t.tag) {
          case "cmap":
            t = g(b, t);
            k.tables.cmap = y.parse(t.data, t.offset);
            k.encoding = new r.CmapEncoding(k.tables.cmap);
            break;
          case "fvar":
            fa = t;
            break;
          case "head":
            t = g(b, t);
            k.tables.head = D.parse(t.data, t.offset);
            k.unitsPerEm = k.tables.head.unitsPerEm;
            e = k.tables.head.indexToLocFormat;
            break;
          case "hhea":
            t = g(b, t);
            k.tables.hhea = F.parse(t.data, t.offset);
            k.ascender = k.tables.hhea.ascender;
            k.descender = k.tables.hhea.descender;
            k.numberOfHMetrics = k.tables.hhea.numberOfHMetrics;
            break;
          case "hmtx":
            Aa = t;
            break;
          case "ltag":
            t = g(b, t);
            f = I.parse(t.data, t.offset);
            break;
          case "maxp":
            t = g(b, t);
            k.tables.maxp = R.parse(t.data, t.offset);
            k.numGlyphs = k.tables.maxp.numGlyphs;
            break;
          case "name":
            Ea = t;
            break;
          case "OS/2":
            t = g(b, t);
            k.tables.os2 = M.parse(t.data, t.offset);
            break;
          case "post":
            t = g(b, t);
            k.tables.post = P.parse(t.data, t.offset);
            k.glyphNames = new r.GlyphNames(k.tables.post);
            break;
          case "glyf":
            W = t;
            break;
          case "loca":
            ya = t;
            break;
          case "CFF ":
            pa = t;
            break;
          case "kern":
            Ba = t;
            break;
          case "GPOS":
            sa = t;
            break;
          case "GSUB":
            xa = t;
            break;
          case "meta":
            Xa = t;
        }
      }
      Ea = g(b, Ea);
      if (k.tables.name = L.parse(Ea.data, Ea.offset, f), k.names = k.tables.name, W && ya) {
        e = 0 === e, ya = g(b, ya), ya = J.parse(ya.data, ya.offset, k.numGlyphs, e), W = g(b, W), k.glyphs = u.parse(W.data, W.offset, ya, k);
      } else {
        if (!pa) {
          throw Error("Font doesn't contain TrueType or CFF outlines.");
        }
        W = g(b, pa);
        x.parse(W.data, W.offset, k);
      }
      Aa = g(b, Aa);
      (E.parse(Aa.data, Aa.offset, k.numberOfHMetrics, k.numGlyphs, k.glyphs), r.addGlyphNames(k), Ba) ? (Ba = g(b, Ba), k.kerningPairs = z.parse(Ba.data, Ba.offset)) : k.kerningPairs = {};
      sa && (sa = g(b, sa), B.parse(sa.data, sa.offset, k));
      xa && (xa = g(b, xa), k.tables.gsub = C.parse(xa.data, xa.offset));
      fa && (fa = g(b, fa), k.tables.fvar = q.parse(fa.data, fa.offset, k.names));
      Xa && (Xa = g(b, Xa), k.tables.meta = H.parse(Xa.data, Xa.offset), k.metas = k.tables.meta);
      return k;
    }
    var p = h("tiny-inflate"), r = h("./encoding"), w = h("./font");
    l = h("./glyph");
    var n = h("./parse"), t = h("./path"), v = h("./util"), y = h("./tables/cmap"), x = h("./tables/cff"), q = h("./tables/fvar"), u = h("./tables/glyf"), B = h("./tables/gpos"), C = h("./tables/gsub"), D = h("./tables/head"), F = h("./tables/hhea"), E = h("./tables/hmtx"), z = h("./tables/kern"), I = h("./tables/ltag"), J = h("./tables/loca"), R = h("./tables/maxp"), L = h("./tables/name"), M = h("./tables/os2"), P = h("./tables/post"), H = h("./tables/meta");
    b._parse = n;
    b.Font = w.Font;
    b.Glyph = l.Glyph;
    b.Path = t.Path;
    b.parse = e;
    b.load = function(b, c) {
      ("undefined" == typeof window ? f : k)(b, function(b, g) {
        if (b) {
          return c(b);
        }
        var f;
        try {
          f = e(g);
        } catch (V) {
          return c(V, null);
        }
        return c(null, f);
      });
    };
    b.loadSync = function(b) {
      b = h("fs").readFileSync(b);
      return e(v.nodeBufferToArrayBuffer(b));
    };
  }, {"./encoding":4, "./font":5, "./glyph":6, "./parse":10, "./path":11, "./tables/cff":14, "./tables/cmap":15, "./tables/fvar":16, "./tables/glyf":17, "./tables/gpos":18, "./tables/gsub":19, "./tables/head":20, "./tables/hhea":21, "./tables/hmtx":22, "./tables/kern":23, "./tables/loca":24, "./tables/ltag":25, "./tables/maxp":26, "./tables/meta":27, "./tables/name":28, "./tables/os2":29, "./tables/post":30, "./util":33, fs:void 0, "tiny-inflate":1}], 10:[function(h, l, b) {
    function f(b, c) {
      return b.getUint16(c, !1);
    }
    function k(b, c) {
      this.data = b;
      this.offset = c;
      this.relativeOffset = 0;
    }
    var c = h("./check");
    b.getByte = function(b, c) {
      return b.getUint8(c);
    };
    b.getCard8 = b.getByte;
    b.getUShort = b.getCard16 = f;
    b.getShort = function(b, c) {
      return b.getInt16(c, !1);
    };
    b.getULong = function(b, c) {
      return b.getUint32(c, !1);
    };
    b.getFixed = function(b, c) {
      var e = b.getInt16(c, !1);
      b = b.getUint16(c + 2, !1);
      return e + b / 65535;
    };
    b.getTag = function(b, c) {
      for (var e = "", g = c;c + 4 > g;g += 1) {
        e += String.fromCharCode(b.getInt8(g));
      }
      return e;
    };
    b.getOffset = function(b, c, e) {
      for (var g = 0, f = 0;e > f;f += 1) {
        g <<= 8, g += b.getUint8(c + f);
      }
      return g;
    };
    b.getBytes = function(b, c, e) {
      for (var g = [];e > c;c += 1) {
        g.push(b.getUint8(c));
      }
      return g;
    };
    b.bytesToString = function(b) {
      for (var c = "", e = 0;e < b.length;e += 1) {
        c += String.fromCharCode(b[e]);
      }
      return c;
    };
    var g = {"byte":1, uShort:2, "short":2, uLong:4, fixed:4, longDateTime:8, tag:4};
    k.prototype.parseByte = function() {
      var b = this.data.getUint8(this.offset + this.relativeOffset);
      return this.relativeOffset += 1, b;
    };
    k.prototype.parseChar = function() {
      var b = this.data.getInt8(this.offset + this.relativeOffset);
      return this.relativeOffset += 1, b;
    };
    k.prototype.parseCard8 = k.prototype.parseByte;
    k.prototype.parseUShort = function() {
      var b = this.data.getUint16(this.offset + this.relativeOffset);
      return this.relativeOffset += 2, b;
    };
    k.prototype.parseCard16 = k.prototype.parseUShort;
    k.prototype.parseSID = k.prototype.parseUShort;
    k.prototype.parseOffset16 = k.prototype.parseUShort;
    k.prototype.parseShort = function() {
      var b = this.data.getInt16(this.offset + this.relativeOffset);
      return this.relativeOffset += 2, b;
    };
    k.prototype.parseF2Dot14 = function() {
      var b = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
      return this.relativeOffset += 2, b;
    };
    k.prototype.parseULong = function() {
      var c = b.getULong(this.data, this.offset + this.relativeOffset);
      return this.relativeOffset += 4, c;
    };
    k.prototype.parseFixed = function() {
      var c = b.getFixed(this.data, this.offset + this.relativeOffset);
      return this.relativeOffset += 4, c;
    };
    k.prototype.parseString = function(b) {
      var c = this.data, e = this.offset + this.relativeOffset, g = "";
      this.relativeOffset += b;
      for (var f = 0;b > f;f++) {
        g += String.fromCharCode(c.getUint8(e + f));
      }
      return g;
    };
    k.prototype.parseTag = function() {
      return this.parseString(4);
    };
    k.prototype.parseLongDateTime = function() {
      var c = b.getULong(this.data, this.offset + this.relativeOffset + 4);
      return c -= 2082844800, this.relativeOffset += 8, c;
    };
    k.prototype.parseVersion = function() {
      var b = f(this.data, this.offset + this.relativeOffset), c = f(this.data, this.offset + this.relativeOffset + 2);
      return this.relativeOffset += 4, b + c / 4096 / 10;
    };
    k.prototype.skip = function(b, c) {
      void 0 === c && (c = 1);
      this.relativeOffset += g[b] * c;
    };
    k.prototype.parseOffset16List = k.prototype.parseUShortList = function(b) {
      void 0 === b && (b = this.parseUShort());
      for (var c = Array(b), e = this.data, g = this.offset + this.relativeOffset, f = 0;b > f;f++) {
        c[f] = e.getUint16(g), g += 2;
      }
      return this.relativeOffset += 2 * b, c;
    };
    k.prototype.parseList = function(b, c) {
      c || (c = b, b = this.parseUShort());
      for (var e = Array(b), g = 0;b > g;g++) {
        e[g] = c.call(this);
      }
      return e;
    };
    k.prototype.parseRecordList = function(b, c) {
      c || (c = b, b = this.parseUShort());
      for (var e = Array(b), g = Object.keys(c), f = 0;b > f;f++) {
        for (var h = {}, k = 0;k < g.length;k++) {
          var l = g[k];
          h[l] = c[l].call(this);
        }
        e[f] = h;
      }
      return e;
    };
    k.prototype.parseStruct = function(b) {
      if ("function" == typeof b) {
        return b.call(this);
      }
      for (var c = Object.keys(b), e = {}, g = 0;g < c.length;g++) {
        var f = c[g];
        e[f] = b[f].call(this);
      }
      return e;
    };
    k.prototype.parsePointer = function(b) {
      var c = this.parseOffset16();
      return 0 < c ? (new k(this.data, this.offset + c)).parseStruct(b) : void 0;
    };
    k.prototype.parseListOfLists = function(b) {
      for (var c = this.parseOffset16List(), e = c.length, g = this.relativeOffset, f = Array(e), h = 0;e > h;h++) {
        var k = c[h];
        if (0 !== k) {
          if (this.relativeOffset = k, b) {
            for (var l = this.parseOffset16List(), p = Array(l.length), u = 0;u < l.length;u++) {
              this.relativeOffset = k + l[u], p[u] = b.call(this);
            }
            f[h] = p;
          } else {
            f[h] = this.parseUShortList();
          }
        } else {
          f[h] = void 0;
        }
      }
      return this.relativeOffset = g, f;
    };
    k.prototype.parseCoverage = function() {
      var b = this.offset + this.relativeOffset, e = this.parseUShort(), g = this.parseUShort();
      if (1 === e) {
        return {format:1, glyphs:this.parseUShortList(g)};
      }
      if (2 === e) {
        b = Array(g);
        for (e = 0;g > e;e++) {
          b[e] = {start:this.parseUShort(), end:this.parseUShort(), index:this.parseUShort()};
        }
        return {format:2, ranges:b};
      }
      c.assert(!1, "0x" + b.toString(16) + ": Coverage format must be 1 or 2.");
    };
    k.prototype.parseClassDef = function() {
      var b = this.offset + this.relativeOffset, e = this.parseUShort();
      return 1 === e ? {format:1, startGlyph:this.parseUShort(), classes:this.parseUShortList()} : 2 === e ? {format:2, ranges:this.parseRecordList({start:k.uShort, end:k.uShort, classId:k.uShort})} : void c.assert(!1, "0x" + b.toString(16) + ": ClassDef format must be 1 or 2.");
    };
    k.list = function(b, c) {
      return function() {
        return this.parseList(b, c);
      };
    };
    k.recordList = function(b, c) {
      return function() {
        return this.parseRecordList(b, c);
      };
    };
    k.pointer = function(b) {
      return function() {
        return this.parsePointer(b);
      };
    };
    k.tag = k.prototype.parseTag;
    k.byte = k.prototype.parseByte;
    k.uShort = k.offset16 = k.prototype.parseUShort;
    k.uShortList = k.prototype.parseUShortList;
    k.struct = k.prototype.parseStruct;
    k.coverage = k.prototype.parseCoverage;
    k.classDef = k.prototype.parseClassDef;
    var e = {reserved:k.uShort, reqFeatureIndex:k.uShort, featureIndexes:k.uShortList};
    k.prototype.parseScriptList = function() {
      return this.parsePointer(k.recordList({tag:k.tag, script:k.pointer({defaultLangSys:k.pointer(e), langSysRecords:k.recordList({tag:k.tag, langSys:k.pointer(e)})})}));
    };
    k.prototype.parseFeatureList = function() {
      return this.parsePointer(k.recordList({tag:k.tag, feature:k.pointer({featureParams:k.offset16, lookupListIndexes:k.uShortList})}));
    };
    k.prototype.parseLookupList = function(b) {
      return this.parsePointer(k.list(k.pointer(function() {
        var e = this.parseUShort();
        c.argument(1 <= e && 8 >= e, "GSUB lookup type " + e + " unknown.");
        var g = this.parseUShort(), f = 16 & g;
        return {lookupType:e, lookupFlag:g, subtables:this.parseList(k.pointer(b[e])), markFilteringSet:f ? this.parseUShort() : void 0};
      })));
    };
    b.Parser = k;
  }, {"./check":2}], 11:[function(h, l, b) {
    function f() {
      this.commands = [];
      this.fill = "black";
      this.stroke = null;
      this.strokeWidth = 1;
    }
    f.prototype.moveTo = function(b, c) {
      this.commands.push({type:"M", x:b, y:c});
    };
    f.prototype.lineTo = function(b, c) {
      this.commands.push({type:"L", x:b, y:c});
    };
    f.prototype.curveTo = f.prototype.bezierCurveTo = function(b, c, g, e, f, h) {
      this.commands.push({type:"C", x1:b, y1:c, x2:g, y2:e, x:f, y:h});
    };
    f.prototype.quadTo = f.prototype.quadraticCurveTo = function(b, c, g, e) {
      this.commands.push({type:"Q", x1:b, y1:c, x:g, y:e});
    };
    f.prototype.close = f.prototype.closePath = function() {
      this.commands.push({type:"Z"});
    };
    f.prototype.extend = function(b) {
      b.commands && (b = b.commands);
      Array.prototype.push.apply(this.commands, b);
    };
    f.prototype.draw = function(b) {
      b.beginPath();
      for (var c = 0;c < this.commands.length;c += 1) {
        var g = this.commands[c];
        "M" === g.type ? b.moveTo(g.x, g.y) : "L" === g.type ? b.lineTo(g.x, g.y) : "C" === g.type ? b.bezierCurveTo(g.x1, g.y1, g.x2, g.y2, g.x, g.y) : "Q" === g.type ? b.quadraticCurveTo(g.x1, g.y1, g.x, g.y) : "Z" === g.type && b.closePath();
      }
      this.fill && (b.fillStyle = this.fill, b.fill());
      this.stroke && (b.strokeStyle = this.stroke, b.lineWidth = this.strokeWidth, b.stroke());
    };
    f.prototype.toPathData = function(b) {
      function c() {
        for (var c = "", e = 0;e < arguments.length;e += 1) {
          var g = arguments[e];
          0 <= g && 0 < e && (c += " ");
          c += Math.round(g) === g ? "" + Math.round(g) : g.toFixed(b);
        }
        return c;
      }
      b = void 0 !== b ? b : 2;
      for (var g = "", e = 0;e < this.commands.length;e += 1) {
        var f = this.commands[e];
        "M" === f.type ? g += "M" + c(f.x, f.y) : "L" === f.type ? g += "L" + c(f.x, f.y) : "C" === f.type ? g += "C" + c(f.x1, f.y1, f.x2, f.y2, f.x, f.y) : "Q" === f.type ? g += "Q" + c(f.x1, f.y1, f.x, f.y) : "Z" === f.type && (g += "Z");
      }
      return g;
    };
    f.prototype.toSVG = function(b) {
      var c = '<path d="';
      return c += this.toPathData(b), c += '"', this.fill && "black" !== this.fill && (c += null === this.fill ? ' fill="none"' : ' fill="' + this.fill + '"'), this.stroke && (c += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"'), c + "/>";
    };
    b.Path = f;
  }, {}], 12:[function(h, l, b) {
    function f(b, g, e) {
      b = b.subtables;
      for (var c = 0;c < b.length;c++) {
        var f = b[c];
        if (f.substFormat === g) {
          return f;
        }
      }
      return e ? (b.push(e), e) : void 0;
    }
    var k = h("./check");
    h = h("./layout");
    b = function(b) {
      this.font = b;
    };
    b.prototype = h;
    b.prototype.getGsubTable = function(b) {
      var c = this.font.tables.gsub;
      return !c && b && (this.font.tables.gsub = c = {version:1, scripts:[{tag:"DFLT", script:{defaultLangSys:{reserved:0, reqFeatureIndex:65535, featureIndexes:[]}, langSysRecords:[]}}], features:[], lookups:[]}), c;
    };
    b.prototype.getSingle = function(b, g, e) {
      var c = [];
      b = this.getLookupTable(g, e, b, 1);
      if (!b) {
        return c;
      }
      b = b.subtables;
      for (g = 0;g < b.length;g++) {
        var f;
        f = b[g];
        e = this.expandCoverage(f.coverage);
        if (1 === f.substFormat) {
          var h = f.deltaGlyphId;
          for (f = 0;f < e.length;f++) {
            var k = e[f];
            c.push({sub:k, by:k + h});
          }
        } else {
          for (h = f.substitute, f = 0;f < e.length;f++) {
            c.push({sub:e[f], by:h[f]});
          }
        }
      }
      return c;
    };
    b.prototype.getAlternates = function(b, g, e) {
      var c = [];
      b = this.getLookupTable(g, e, b, 3);
      if (!b) {
        return c;
      }
      b = b.subtables;
      for (g = 0;g < b.length;g++) {
        var f = b[g];
        e = this.expandCoverage(f.coverage);
        for (var f = f.alternateSets, h = 0;h < e.length;h++) {
          c.push({sub:e[h], by:f[h]});
        }
      }
      return c;
    };
    b.prototype.getLigatures = function(b, g, e) {
      var c = [];
      b = this.getLookupTable(g, e, b, 4);
      if (!b) {
        return [];
      }
      b = b.subtables;
      for (g = 0;g < b.length;g++) {
        var f = b[g];
        e = this.expandCoverage(f.coverage);
        for (var f = f.ligatureSets, h = 0;h < e.length;h++) {
          for (var k = e[h], l = f[h], v = 0;v < l.length;v++) {
            var y = l[v];
            c.push({sub:[k].concat(y.components), by:y.ligGlyph});
          }
        }
      }
      return c;
    };
    b.prototype.addSingle = function(b, g, e, h) {
      b = this.getLookupTable(e, h, b, 1, !0);
      b = f(b, 2, {substFormat:2, coverage:{format:1, glyphs:[]}, substitute:[]});
      k.assert(1 === b.coverage.format, "Ligature: unable to modify coverage table format " + b.coverage.format);
      e = g.sub;
      h = this.binSearch(b.coverage.glyphs, e);
      0 > h && (h = -1 - h, b.coverage.glyphs.splice(h, 0, e), b.substitute.splice(h, 0, 0));
      b.substitute[h] = g.by;
    };
    b.prototype.addAlternate = function(b, g, e, h) {
      b = this.getLookupTable(e, h, b, 3, !0);
      b = f(b, 1, {substFormat:1, coverage:{format:1, glyphs:[]}, alternateSets:[]});
      k.assert(1 === b.coverage.format, "Ligature: unable to modify coverage table format " + b.coverage.format);
      e = g.sub;
      h = this.binSearch(b.coverage.glyphs, e);
      0 > h && (h = -1 - h, b.coverage.glyphs.splice(h, 0, e), b.alternateSets.splice(h, 0, 0));
      b.alternateSets[h] = g.by;
    };
    b.prototype.addLigature = function(b, g, e, f) {
      b = this.getLookupTable(e || "DFLT", f || "DFLT", b, 4, !0);
      (e = b.subtables[0]) || (e = {substFormat:1, coverage:{format:1, glyphs:[]}, ligatureSets:[]}, b.subtables[0] = e);
      k.assert(1 === e.coverage.format, "Ligature: unable to modify coverage table format " + e.coverage.format);
      f = g.sub[0];
      b = g.sub.slice(1);
      g = {ligGlyph:g.by, components:b};
      var c = this.binSearch(e.coverage.glyphs, f);
      if (0 <= c) {
        e = e.ligatureSets[c];
        for (f = 0;f < e.length;f++) {
          a: {
            var c = e[f].components, h = c.length;
            if (h !== b.length) {
              c = !1;
            } else {
              for (var l = 0;h > l;l++) {
                if (c[l] !== b[l]) {
                  c = !1;
                  break a;
                }
              }
              c = !0;
            }
          }
          if (c) {
            return;
          }
        }
        e.push(g);
      } else {
        c = -1 - c, e.coverage.glyphs.splice(c, 0, f), e.ligatureSets.splice(c, 0, [g]);
      }
    };
    b.prototype.getFeature = function(b, g, e) {
      if (g = g || "DFLT", e = e || "DFLT", /ss\d\d/.test(b)) {
        return this.getSingle(b, g, e);
      }
      switch(b) {
        case "aalt":
        case "salt":
          return this.getSingle(b, g, e).concat(this.getAlternates(b, g, e));
        case "dlig":
        case "liga":
        case "rlig":
          return this.getLigatures(b, g, e);
      }
    };
    b.prototype.add = function(b, g, e, f) {
      if (e = e || "DFLT", f = f || "DFLT", /ss\d\d/.test(b)) {
        return this.addSingle(b, g, e, f);
      }
      switch(b) {
        case "aalt":
        case "salt":
          return "number" == typeof g.by ? this.addSingle(b, g, e, f) : this.addAlternate(b, g, e, f);
        case "dlig":
        case "liga":
        case "rlig":
          return this.addLigature(b, g, e, f);
      }
    };
    l.exports = b;
  }, {"./check":2, "./layout":8}], 13:[function(h, l, b) {
    function f(b, c, e) {
      var g;
      for (g = 0;g < c.length;g += 1) {
        var f = c[g];
        this[f.name] = f.value;
      }
      if (this.tableName = b, this.fields = c, e) {
        for (b = Object.keys(e), g = 0;g < b.length;g += 1) {
          c = b[g], f = e[c], void 0 !== this[c] && (this[c] = f);
        }
      }
    }
    function k(b, c, e) {
      void 0 === e && (e = c.length);
      var g = Array(c.length + 1);
      g[0] = {name:b + "Count", type:"USHORT", value:e};
      for (e = 0;e < c.length;e++) {
        g[e + 1] = {name:b + e, type:"USHORT", value:c[e]};
      }
      return g;
    }
    function c(b, c, e) {
      var g = c.length, f = Array(g + 1);
      f[0] = {name:b + "Count", type:"USHORT", value:g};
      for (var h = 0;g > h;h++) {
        f[h + 1] = {name:b + h, type:"TABLE", value:e(c[h], h)};
      }
      return f;
    }
    function g(b, c, e) {
      var g = c.length, f = [];
      f[0] = {name:b + "Count", type:"USHORT", value:g};
      for (b = 0;g > b;b++) {
        f = f.concat(e(c[b], b));
      }
      return f;
    }
    function e(b) {
      1 === b.format ? f.call(this, "coverageTable", [{name:"coverageFormat", type:"USHORT", value:1}].concat(k("glyph", b.glyphs))) : n.assert(!1, "Can't create coverage table format 2 yet.");
    }
    function p(b) {
      f.call(this, "scriptListTable", g("scriptRecord", b, function(b, c) {
        var e = b.script, h = e.defaultLangSys;
        return n.assert(!!h, "Unable to write GSUB: script " + b.tag + " has no default language system."), [{name:"scriptTag" + c, type:"TAG", value:b.tag}, {name:"script" + c, type:"TABLE", value:new f("scriptTable", [{name:"defaultLangSys", type:"TABLE", value:new f("defaultLangSys", [{name:"lookupOrder", type:"USHORT", value:0}, {name:"reqFeatureIndex", type:"USHORT", value:h.reqFeatureIndex}].concat(k("featureIndex", h.featureIndexes)))}].concat(g("langSys", e.langSysRecords, function(b, c) {
          var e = b.langSys;
          return [{name:"langSysTag" + c, type:"TAG", value:b.tag}, {name:"langSys" + c, type:"TABLE", value:new f("langSys", [{name:"lookupOrder", type:"USHORT", value:0}, {name:"reqFeatureIndex", type:"USHORT", value:e.reqFeatureIndex}].concat(k("featureIndex", e.featureIndexes)))}];
        })))}];
      }));
    }
    function r(b) {
      f.call(this, "featureListTable", g("featureRecord", b, function(b, c) {
        var e = b.feature;
        return [{name:"featureTag" + c, type:"TAG", value:b.tag}, {name:"feature" + c, type:"TABLE", value:new f("featureTable", [{name:"featureParams", type:"USHORT", value:e.featureParams}].concat(k("lookupListIndex", e.lookupListIndexes)))}];
      }));
    }
    function w(b, e) {
      f.call(this, "lookupListTable", c("lookup", b, function(b) {
        var g = e[b.lookupType];
        return n.assert(!!g, "Unable to write GSUB lookup type " + b.lookupType + " tables."), new f("lookupTable", [{name:"lookupType", type:"USHORT", value:b.lookupType}, {name:"lookupFlag", type:"USHORT", value:b.lookupFlag}].concat(c("subtable", b.subtables, g)));
      }));
    }
    var n = h("./check"), t = h("./types").encode, v = h("./types").sizeOf;
    f.prototype.encode = function() {
      return t.TABLE(this);
    };
    f.prototype.sizeOf = function() {
      return v.TABLE(this);
    };
    e.prototype = Object.create(f.prototype);
    e.prototype.constructor = e;
    p.prototype = Object.create(f.prototype);
    p.prototype.constructor = p;
    r.prototype = Object.create(f.prototype);
    r.prototype.constructor = r;
    w.prototype = Object.create(f.prototype);
    w.prototype.constructor = w;
    b.Record = b.Table = f;
    b.Coverage = e;
    b.ScriptList = p;
    b.FeatureList = r;
    b.LookupList = w;
    b.ushortList = k;
    b.tableList = c;
    b.recordList = g;
  }, {"./check":2, "./types":32}], 14:[function(h, l, b) {
    function f(b, c) {
      if (b === c) {
        return !0;
      }
      if (Array.isArray(b) && Array.isArray(c)) {
        if (b.length !== c.length) {
          return !1;
        }
        for (var e = 0;e < b.length;e += 1) {
          if (!f(b[e], c[e])) {
            return !1;
          }
        }
        return !0;
      }
      return !1;
    }
    function k(b, c, e) {
      var g, f, h, k = [], l = [];
      h = u.getCard16(b, c);
      if (0 !== h) {
        var n = u.getByte(b, c + 2);
        f = c + (h + 1) * n + 2;
        var p = c + 3;
        for (g = 0;h + 1 > g;g += 1) {
          k.push(u.getOffset(b, p, n)), p += n;
        }
        h = f + k[h];
      } else {
        h = c + 2;
      }
      for (g = 0;g < k.length - 1;g += 1) {
        n = u.getBytes(b, f + k[g], f + k[g + 1]), e && (n = e(n)), l.push(n);
      }
      return {objects:l, startOffset:c, endOffset:h};
    }
    function c(b, c) {
      var e, g, f, h;
      if (28 === c) {
        return e = b.parseByte(), g = b.parseByte(), e << 8 | g;
      }
      if (29 === c) {
        return e = b.parseByte(), g = b.parseByte(), f = b.parseByte(), h = b.parseByte(), e << 24 | g << 16 | f << 8 | h;
      }
      if (30 === c) {
        c = "";
        for (e = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];;) {
          f = b.parseByte();
          g = f >> 4;
          f &= 15;
          if (15 === g) {
            break;
          }
          if (c += e[g], 15 === f) {
            break;
          }
          c += e[f];
        }
        return parseFloat(c);
      }
      if (32 <= c && 246 >= c) {
        return c - 139;
      }
      if (247 <= c && 250 >= c) {
        return e = b.parseByte(), 256 * (c - 247) + e + 108;
      }
      if (251 <= c && 254 >= c) {
        return e = b.parseByte(), 256 * -(c - 251) - e - 108;
      }
      throw Error("Invalid b0 " + c);
    }
    function g(b, e, g) {
      var f = new u.Parser(b, void 0 !== e ? e : 0);
      e = [];
      var h = [];
      for (g = void 0 !== g ? g : b.length;f.relativeOffset < g;) {
        b = f.parseByte(), 21 >= b ? (12 === b && (b = 1200 + f.parseByte()), e.push([b, h]), h = []) : h.push(c(f, b));
      }
      g = {};
      for (b = 0;b < e.length;b += 1) {
        f = e[b][0];
        h = e[b][1];
        if (h = 1 === h.length ? h[0] : h, g.hasOwnProperty(f)) {
          throw Error("Object " + g + " already has key " + f);
        }
        g[f] = h;
      }
      return g;
    }
    function e(b, c) {
      return 390 >= c ? x.cffStandardStrings[c] : b[c - 391];
    }
    function p(b, c, g) {
      for (var f = {}, h = 0;h < c.length;h += 1) {
        var k = c[h], l = b[k.op];
        void 0 === l && (l = void 0 !== k.value ? k.value : null);
        "SID" === k.type && (l = e(g, l));
        f[k.name] = l;
      }
      return f;
    }
    function r(b, c, e) {
      function g(b, c) {
        w && q.closePath();
        q.moveTo(b, c);
        w = !0;
      }
      function f() {
        0 !== r.length % 2 && !v && (u = r.shift() + b.nominalWidthX);
        t += r.length >> 1;
        r.length = 0;
        v = !0;
      }
      function h(e) {
        for (var z, B, D, C, E, F, J, I, L, H, M = 0;M < e.length;) {
          switch(E = e[M], M += 1, E) {
            case 1:
              f();
              break;
            case 3:
              f();
              break;
            case 4:
              1 < r.length && !v && (u = r.shift() + b.nominalWidthX, v = !0);
              x += r.pop();
              g(y, x);
              break;
            case 5:
              for (;0 < r.length;) {
                y += r.shift(), x += r.shift(), q.lineTo(y, x);
              }
              break;
            case 6:
              for (;0 < r.length && (y += r.shift(), q.lineTo(y, x), 0 !== r.length);) {
                x += r.shift(), q.lineTo(y, x);
              }
              break;
            case 7:
              for (;0 < r.length && (x += r.shift(), q.lineTo(y, x), 0 !== r.length);) {
                y += r.shift(), q.lineTo(y, x);
              }
              break;
            case 8:
              for (;0 < r.length;) {
                k = y + r.shift(), l = x + r.shift(), n = k + r.shift(), p = l + r.shift(), y = n + r.shift(), x = p + r.shift(), q.curveTo(k, l, n, p, y, x);
              }
              break;
            case 10:
              E = r.pop() + b.subrsBias;
              (E = b.subrs[E]) && h(E);
              break;
            case 11:
              return;
            case 12:
              switch(E = e[M], M += 1, E) {
                case 35:
                  k = y + r.shift();
                  l = x + r.shift();
                  n = k + r.shift();
                  p = l + r.shift();
                  E = n + r.shift();
                  F = p + r.shift();
                  J = E + r.shift();
                  I = F + r.shift();
                  L = J + r.shift();
                  H = I + r.shift();
                  y = L + r.shift();
                  x = H + r.shift();
                  r.shift();
                  q.curveTo(k, l, n, p, E, F);
                  q.curveTo(J, I, L, H, y, x);
                  break;
                case 34:
                  k = y + r.shift();
                  l = x;
                  n = k + r.shift();
                  p = l + r.shift();
                  E = n + r.shift();
                  F = p;
                  J = E + r.shift();
                  I = p;
                  L = J + r.shift();
                  H = x;
                  y = L + r.shift();
                  q.curveTo(k, l, n, p, E, F);
                  q.curveTo(J, I, L, H, y, x);
                  break;
                case 36:
                  k = y + r.shift();
                  l = x + r.shift();
                  n = k + r.shift();
                  p = l + r.shift();
                  E = n + r.shift();
                  F = p;
                  J = E + r.shift();
                  I = p;
                  L = J + r.shift();
                  H = I + r.shift();
                  y = L + r.shift();
                  q.curveTo(k, l, n, p, E, F);
                  q.curveTo(J, I, L, H, y, x);
                  break;
                case 37:
                  k = y + r.shift();
                  l = x + r.shift();
                  n = k + r.shift();
                  p = l + r.shift();
                  E = n + r.shift();
                  F = p + r.shift();
                  J = E + r.shift();
                  I = F + r.shift();
                  L = J + r.shift();
                  H = I + r.shift();
                  Math.abs(L - y) > Math.abs(H - x) ? y = L + r.shift() : x = H + r.shift();
                  q.curveTo(k, l, n, p, E, F);
                  q.curveTo(J, I, L, H, y, x);
                  break;
                default:
                  console.log("Glyph " + c.index + ": unknown operator 1200" + E), r.length = 0;
              }break;
            case 14:
              0 < r.length && !v && (u = r.shift() + b.nominalWidthX, v = !0);
              w && (q.closePath(), w = !1);
              break;
            case 18:
              f();
              break;
            case 19:
            case 20:
              f();
              M += t + 7 >> 3;
              break;
            case 21:
              2 < r.length && !v && (u = r.shift() + b.nominalWidthX, v = !0);
              x += r.pop();
              y += r.pop();
              g(y, x);
              break;
            case 22:
              1 < r.length && !v && (u = r.shift() + b.nominalWidthX, v = !0);
              y += r.pop();
              g(y, x);
              break;
            case 23:
              f();
              break;
            case 24:
              for (;2 < r.length;) {
                k = y + r.shift(), l = x + r.shift(), n = k + r.shift(), p = l + r.shift(), y = n + r.shift(), x = p + r.shift(), q.curveTo(k, l, n, p, y, x);
              }
              y += r.shift();
              x += r.shift();
              q.lineTo(y, x);
              break;
            case 25:
              for (;6 < r.length;) {
                y += r.shift(), x += r.shift(), q.lineTo(y, x);
              }
              k = y + r.shift();
              l = x + r.shift();
              n = k + r.shift();
              p = l + r.shift();
              y = n + r.shift();
              x = p + r.shift();
              q.curveTo(k, l, n, p, y, x);
              break;
            case 26:
              for (r.length % 2 && (y += r.shift());0 < r.length;) {
                k = y, l = x + r.shift(), n = k + r.shift(), p = l + r.shift(), y = n, x = p + r.shift(), q.curveTo(k, l, n, p, y, x);
              }
              break;
            case 27:
              for (r.length % 2 && (x += r.shift());0 < r.length;) {
                k = y + r.shift(), l = x, n = k + r.shift(), p = l + r.shift(), y = n + r.shift(), x = p, q.curveTo(k, l, n, p, y, x);
              }
              break;
            case 28:
              z = e[M];
              B = e[M + 1];
              r.push((z << 24 | B << 16) >> 16);
              M += 2;
              break;
            case 29:
              E = r.pop() + b.gsubrsBias;
              (E = b.gsubrs[E]) && h(E);
              break;
            case 30:
              for (;0 < r.length && (k = y, l = x + r.shift(), n = k + r.shift(), p = l + r.shift(), y = n + r.shift(), x = p + (1 === r.length ? r.shift() : 0), q.curveTo(k, l, n, p, y, x), 0 !== r.length);) {
                k = y + r.shift(), l = x, n = k + r.shift(), p = l + r.shift(), x = p + r.shift(), y = n + (1 === r.length ? r.shift() : 0), q.curveTo(k, l, n, p, y, x);
              }
              break;
            case 31:
              for (;0 < r.length && (k = y + r.shift(), l = x, n = k + r.shift(), p = l + r.shift(), x = p + r.shift(), y = n + (1 === r.length ? r.shift() : 0), q.curveTo(k, l, n, p, y, x), 0 !== r.length);) {
                k = y, l = x + r.shift(), n = k + r.shift(), p = l + r.shift(), y = n + r.shift(), x = p + (1 === r.length ? r.shift() : 0), q.curveTo(k, l, n, p, y, x);
              }
              break;
            default:
              32 > E ? console.log("Glyph " + c.index + ": unknown operator " + E) : 247 > E ? r.push(E - 139) : 251 > E ? (z = e[M], M += 1, r.push(256 * (E - 247) + z + 108)) : 255 > E ? (z = e[M], M += 1, r.push(256 * -(E - 251) - z - 108)) : (z = e[M], B = e[M + 1], D = e[M + 2], C = e[M + 3], M += 4, r.push((z << 24 | B << 16 | D << 8 | C) / 65536));
          }
        }
      }
      var k, l, n, p, q = new B.Path, r = [], t = 0, v = !1, u = b.defaultWidthX, w = !1, y = 0, x = 0;
      return h(e), c.advanceWidth = u, q;
    }
    function w(b) {
      return 1240 > b.length ? 107 : 33900 > b.length ? 1131 : 32768;
    }
    function n(b, c) {
      var e, g = x.cffStandardStrings.indexOf(b);
      return g = c.indexOf(b), 0 <= g ? e = g + x.cffStandardStrings.length : (e = x.cffStandardStrings.length + c.length, c.push(b)), e;
    }
    function t(b, c, e) {
      for (var g = {}, h = 0;h < b.length;h += 1) {
        var k = b[h], l = c[k.name];
        void 0 === l || f(l, k.value) || ("SID" === k.type && (l = n(l, e)), g[k.op] = {name:k.name, type:k.type, value:l});
      }
      return g;
    }
    function v(b, c) {
      var e = new C.Record("Top DICT", [{name:"dict", type:"DICT", value:{}}]);
      return e.dict = t(D, b, c), e;
    }
    function y(b) {
      var c = new C.Record("Top DICT INDEX", [{name:"topDicts", type:"INDEX", value:[]}]);
      return c.topDicts = [{name:"topDict_0", type:"TABLE", value:b}], c;
    }
    var x = h("../encoding"), q = h("../glyphset"), u = h("../parse"), B = h("../path"), C = h("../table"), D = [{name:"version", op:0, type:"SID"}, {name:"notice", op:1, type:"SID"}, {name:"copyright", op:1200, type:"SID"}, {name:"fullName", op:2, type:"SID"}, {name:"familyName", op:3, type:"SID"}, {name:"weight", op:4, type:"SID"}, {name:"isFixedPitch", op:1201, type:"number", value:0}, {name:"italicAngle", op:1202, type:"number", value:0}, {name:"underlinePosition", op:1203, type:"number", value:-100}, 
    {name:"underlineThickness", op:1204, type:"number", value:50}, {name:"paintType", op:1205, type:"number", value:0}, {name:"charstringType", op:1206, type:"number", value:2}, {name:"fontMatrix", op:1207, type:"real real real real real real".split(" "), value:[.001, 0, 0, .001, 0, 0]}, {name:"uniqueId", op:13, type:"number"}, {name:"fontBBox", op:5, type:["number", "number", "number", "number"], value:[0, 0, 0, 0]}, {name:"strokeWidth", op:1208, type:"number", value:0}, {name:"xuid", op:14, type:[], 
    value:null}, {name:"charset", op:15, type:"offset", value:0}, {name:"encoding", op:16, type:"offset", value:0}, {name:"charStrings", op:17, type:"offset", value:0}, {name:"private", op:18, type:["number", "offset"], value:[0, 0]}], F = [{name:"subrs", op:19, type:"offset", value:0}, {name:"defaultWidthX", op:20, type:"number", value:0}, {name:"nominalWidthX", op:21, type:"number", value:0}];
    b.parse = function(b, c, f) {
      f.tables.cff = {};
      var h;
      h = {};
      h = (h.formatMajor = u.getCard8(b, c), h.formatMinor = u.getCard8(b, c + 1), h.size = u.getCard8(b, c + 2), h.offsetSize = u.getCard8(b, c + 3), h.startOffset = c, h.endOffset = c + 4, h);
      h = k(b, h.endOffset, u.bytesToString);
      h = k(b, h.endOffset);
      var l = k(b, h.endOffset, u.bytesToString), n = k(b, l.endOffset);
      f.gsubrs = n.objects;
      f.gsubrsBias = w(f.gsubrs);
      n = new DataView((new Uint8Array(h.objects[0])).buffer);
      h = l.objects;
      n = g(n, 0, n.byteLength);
      n = p(n, D, h);
      f.tables.cff.topDict = n;
      h = c + n["private"][1];
      var t;
      t = l.objects;
      var v = g(b, h, n["private"][0]);
      t = p(v, F, t);
      (f.defaultWidthX = t.defaultWidthX, f.nominalWidthX = t.nominalWidthX, 0 !== t.subrs) ? (h = k(b, h + t.subrs), f.subrs = h.objects, f.subrsBias = w(f.subrs)) : (f.subrs = [], f.subrsBias = 0);
      h = k(b, c + n.charStrings);
      f.nGlyphs = h.objects.length;
      t = f.nGlyphs;
      var v = l.objects, y, z, B, C = new u.Parser(b, c + n.charset);
      --t;
      l = [".notdef"];
      y = C.parseCard8();
      if (0 === y) {
        for (y = 0;t > y;y += 1) {
          z = C.parseSID(), l.push(e(v, z));
        }
      } else {
        if (1 === y) {
          for (;l.length <= t;) {
            for (z = C.parseSID(), B = C.parseCard8(), y = 0;B >= y;y += 1) {
              l.push(e(v, z)), z += 1;
            }
          }
        } else {
          if (2 !== y) {
            throw Error("Unknown charset format " + y);
          }
          for (;l.length <= t;) {
            for (z = C.parseSID(), B = C.parseCard16(), y = 0;B >= y;y += 1) {
              l.push(e(v, z)), z += 1;
            }
          }
        }
      }
      if (0 === n.encoding) {
        b = new x.CffEncoding(x.cffStandardEncoding, l);
      } else {
        if (1 === n.encoding) {
          b = new x.CffEncoding(x.cffExpertEncoding, l);
        } else {
          t = {};
          b = new u.Parser(b, c + n.encoding);
          c = b.parseCard8();
          if (0 === c) {
            for (v = b.parseCard8(), c = 0;v > c;c += 1) {
              n = b.parseCard8(), t[n] = c;
            }
          } else {
            if (1 !== c) {
              throw Error("Unknown encoding format " + c);
            }
            v = b.parseCard8();
            n = 1;
            for (c = 0;v > c;c += 1) {
              for (C = b.parseCard8(), y = b.parseCard8(), z = C;C + y >= z;z += 1) {
                t[z] = n, n += 1;
              }
            }
          }
          b = new x.CffEncoding(t, l);
        }
      }
      f.cffEncoding = b;
      f.encoding = f.encoding || f.cffEncoding;
      f.glyphs = new q.GlyphSet(f);
      for (b = 0;b < f.nGlyphs;b += 1) {
        f.glyphs.push(b, q.cffGlyphLoader(f, b, r, h.objects[b]));
      }
    };
    b.make = function(b, c) {
      for (var e, g = new C.Table("CFF ", [{name:"header", type:"RECORD"}, {name:"nameIndex", type:"RECORD"}, {name:"topDictIndex", type:"RECORD"}, {name:"stringIndex", type:"RECORD"}, {name:"globalSubrIndex", type:"RECORD"}, {name:"charsets", type:"RECORD"}, {name:"charStringsIndex", type:"RECORD"}, {name:"privateDict", type:"RECORD"}]), f = 1 / c.unitsPerEm, f = {version:c.version, fullName:c.fullName, familyName:c.familyName, weight:c.weightName, fontBBox:c.fontBBox || [0, 0, 0, 0], fontMatrix:[f, 
      0, 0, f, 0, 0], charset:999, encoding:0, charStrings:999, "private":[0, 999]}, h = [], k = 1;k < b.length;k += 1) {
        e = b.get(k), h.push(e.name);
      }
      e = [];
      g.header = new C.Record("Header", [{name:"major", type:"Card8", value:1}, {name:"minor", type:"Card8", value:0}, {name:"hdrSize", type:"Card8", value:4}, {name:"major", type:"Card8", value:1}]);
      c = [c.postScriptName];
      k = new C.Record("Name INDEX", [{name:"names", type:"INDEX", value:[]}]);
      k.names = [];
      for (var l = 0;l < c.length;l += 1) {
        k.names.push({name:"name_" + l, type:"NAME", value:c[l]});
      }
      g.nameIndex = k;
      c = v(f, e);
      g.topDictIndex = y(c);
      g.globalSubrIndex = new C.Record("Global Subr INDEX", [{name:"subrs", type:"INDEX", value:[]}]);
      k = new C.Record("Charsets", [{name:"format", type:"Card8", value:0}]);
      for (l = 0;l < h.length;l += 1) {
        var p = n(h[l], e);
        k.fields.push({name:"glyph_" + l, type:"SID", value:p});
      }
      g.charsets = k;
      h = new C.Record("CharStrings INDEX", [{name:"charStrings", type:"INDEX", value:[]}]);
      for (k = 0;k < b.length;k += 1) {
        var l = b.get(k), p = [], q = l.path;
        p.push({name:"width", type:"NUMBER", value:l.advanceWidth});
        for (var r = 0, u = 0, w = 0;w < q.commands.length;w += 1) {
          var x = q.commands[w];
          if ("Q" === x.type) {
            var z = 1 / 3, B = 2 / 3, x = {type:"C", x:x.x, y:x.y, x1:z * r + B * x.x1, y1:z * u + B * x.y1, x2:z * x.x + B * x.x1, y2:z * x.y + B * x.y1};
          }
          if ("M" === x.type) {
            r = Math.round(x.x - r), u = Math.round(x.y - u), p.push({name:"dx", type:"NUMBER", value:r}), p.push({name:"dy", type:"NUMBER", value:u}), p.push({name:"rmoveto", type:"OP", value:21}), r = Math.round(x.x), u = Math.round(x.y);
          } else {
            if ("L" === x.type) {
              r = Math.round(x.x - r), u = Math.round(x.y - u), p.push({name:"dx", type:"NUMBER", value:r}), p.push({name:"dy", type:"NUMBER", value:u}), p.push({name:"rlineto", type:"OP", value:5}), r = Math.round(x.x), u = Math.round(x.y);
            } else {
              if ("C" === x.type) {
                var z = Math.round(x.x1 - r), B = Math.round(x.y1 - u), D = Math.round(x.x2 - x.x1), E = Math.round(x.y2 - x.y1), r = Math.round(x.x - x.x2), u = Math.round(x.y - x.y2);
                p.push({name:"dx1", type:"NUMBER", value:z});
                p.push({name:"dy1", type:"NUMBER", value:B});
                p.push({name:"dx2", type:"NUMBER", value:D});
                p.push({name:"dy2", type:"NUMBER", value:E});
                p.push({name:"dx", type:"NUMBER", value:r});
                p.push({name:"dy", type:"NUMBER", value:u});
                p.push({name:"rrcurveto", type:"OP", value:8});
                r = Math.round(x.x);
                u = Math.round(x.y);
              }
            }
          }
        }
        p = (p.push({name:"endchar", type:"OP", value:14}), p);
        h.charStrings.push({name:l.name, type:"CHARSTRING", value:p});
      }
      g.charStringsIndex = h;
      b = new C.Record("Private DICT", [{name:"dict", type:"DICT", value:{}}]);
      b = (b.dict = t(F, {}, e), b);
      g.privateDict = b;
      b = new C.Record("String INDEX", [{name:"strings", type:"INDEX", value:[]}]);
      b.strings = [];
      for (h = 0;h < e.length;h += 1) {
        b.strings.push({name:"string_" + h, type:"STRING", value:e[h]});
      }
      g.stringIndex = b;
      b = g.header.sizeOf() + g.nameIndex.sizeOf() + g.topDictIndex.sizeOf() + g.stringIndex.sizeOf() + g.globalSubrIndex.sizeOf();
      return f.charset = b, f.encoding = 0, f.charStrings = f.charset + g.charsets.sizeOf(), f.private[1] = f.charStrings + g.charStringsIndex.sizeOf(), c = v(f, e), g.topDictIndex = y(c), g;
    };
  }, {"../encoding":4, "../glyphset":7, "../parse":10, "../path":11, "../table":13}], 15:[function(h, l, b) {
    function f(b, c, g) {
      b.segments.push({end:c, start:c, delta:-(c - g), offset:0});
    }
    var k = h("../check"), c = h("../parse"), g = h("../table");
    b.parse = function(b, g) {
      var e, f = {};
      f.version = c.getUShort(b, g);
      k.argument(0 === f.version, "cmap table version should be 0.");
      f.numTables = c.getUShort(b, g + 2);
      var h = -1;
      for (e = f.numTables - 1;0 <= e;--e) {
        var l = c.getUShort(b, g + 4 + 8 * e), p = c.getUShort(b, g + 4 + 8 * e + 2);
        if (3 === l && (0 === p || 1 === p || 10 === p)) {
          h = c.getULong(b, g + 4 + 8 * e + 4);
          break;
        }
      }
      if (-1 === h) {
        return null;
      }
      e = new c.Parser(b, g + h);
      if (f.format = e.parseUShort(), 12 === f.format) {
        e.parseUShort();
        f.length = e.parseULong();
        f.language = e.parseULong();
        var y;
        f.groupCount = y = e.parseULong();
        f.glyphIndexMap = {};
        for (b = 0;y > b;b += 1) {
          for (p = e.parseULong(), h = e.parseULong(), l = e.parseULong();h >= p;p += 1) {
            f.glyphIndexMap[p] = l, l++;
          }
        }
      } else {
        if (4 !== f.format) {
          throw Error("Only format 4 and 12 cmap tables are supported.");
        }
        var x = h;
        f.length = e.parseUShort();
        f.language = e.parseUShort();
        f.segCount = h = e.parseUShort() >> 1;
        e.skip("uShort", 3);
        f.glyphIndexMap = {};
        e = new c.Parser(b, g + x + 14);
        var l = new c.Parser(b, g + x + 16 + 2 * h), p = new c.Parser(b, g + x + 16 + 4 * h), q = new c.Parser(b, g + x + 16 + 6 * h), x = g + x + 16 + 8 * h;
        for (g = 0;h - 1 > g;g += 1) {
          for (var u = e.parseUShort(), B = l.parseUShort(), C = p.parseShort(), D = q.parseUShort(), F = B;u >= F;F += 1) {
            0 !== D ? (x = q.offset + q.relativeOffset - 2, x += D, x += 2 * (F - B), y = c.getUShort(b, x), 0 !== y && (y = y + C & 65535)) : y = F + C & 65535, f.glyphIndexMap[F] = y;
          }
        }
      }
      return f;
    };
    b.make = function(b) {
      var c, e = new g.Table("cmap", [{name:"version", type:"USHORT", value:0}, {name:"numTables", type:"USHORT", value:1}, {name:"platformID", type:"USHORT", value:3}, {name:"encodingID", type:"USHORT", value:1}, {name:"offset", type:"ULONG", value:12}, {name:"format", type:"USHORT", value:4}, {name:"length", type:"USHORT", value:0}, {name:"language", type:"USHORT", value:0}, {name:"segCountX2", type:"USHORT", value:0}, {name:"searchRange", type:"USHORT", value:0}, {name:"entrySelector", type:"USHORT", 
      value:0}, {name:"rangeShift", type:"USHORT", value:0}]);
      e.segments = [];
      for (c = 0;c < b.length;c += 1) {
        for (var h = b.get(c), k = 0;k < h.unicodes.length;k += 1) {
          f(e, h.unicodes[k], c);
        }
        e.segments = e.segments.sort(function(b, c) {
          return b.start - c.start;
        });
      }
      e.segments.push({end:65535, start:65535, delta:1, offset:0});
      b = e.segments.length;
      e.segCountX2 = 2 * b;
      e.searchRange = 2 * Math.pow(2, Math.floor(Math.log(b) / Math.log(2)));
      e.entrySelector = Math.log(e.searchRange / 2) / Math.log(2);
      e.rangeShift = e.segCountX2 - e.searchRange;
      var h = [], k = [], l = [], v = [], y = [];
      for (c = 0;b > c;c += 1) {
        var x = e.segments[c], h = h.concat({name:"end_" + c, type:"USHORT", value:x.end}), k = k.concat({name:"start_" + c, type:"USHORT", value:x.start}), l = l.concat({name:"idDelta_" + c, type:"SHORT", value:x.delta}), v = v.concat({name:"idRangeOffset_" + c, type:"USHORT", value:x.offset});
        void 0 !== x.glyphId && (y = y.concat({name:"glyph_" + c, type:"USHORT", value:x.glyphId}));
      }
      return e.fields = e.fields.concat(h), e.fields.push({name:"reservedPad", type:"USHORT", value:0}), e.fields = e.fields.concat(k), e.fields = e.fields.concat(l), e.fields = e.fields.concat(v), e.fields = e.fields.concat(y), e.length = 2 * h.length + 16 + 2 * k.length + 2 * l.length + 2 * v.length + 2 * y.length, e;
    };
  }, {"../check":2, "../parse":10, "../table":13}], 16:[function(h, l, b) {
    function f(b, c) {
      var e = JSON.stringify(b), g = 256, f;
      for (f in c) {
        var h = parseInt(f);
        if (h && !(256 > h)) {
          if (JSON.stringify(c[f]) === e) {
            return h;
          }
          h >= g && (g = h + 1);
        }
      }
      return c[g] = b, g;
    }
    function k(b, c, e) {
      e = f(c.name, e);
      return [{name:"tag_" + b, type:"TAG", value:c.tag}, {name:"minValue_" + b, type:"FIXED", value:c.minValue << 16}, {name:"defaultValue_" + b, type:"FIXED", value:c.defaultValue << 16}, {name:"maxValue_" + b, type:"FIXED", value:c.maxValue << 16}, {name:"flags_" + b, type:"USHORT", value:0}, {name:"nameID_" + b, type:"USHORT", value:e}];
    }
    function c(b, c, e) {
      var g = {};
      b = new r.Parser(b, c);
      return g.tag = b.parseTag(), g.minValue = b.parseFixed(), g.defaultValue = b.parseFixed(), g.maxValue = b.parseFixed(), b.skip("uShort", 1), g.name = e[b.parseUShort()] || {}, g;
    }
    function g(b, c, e, g) {
      g = f(c.name, g);
      g = [{name:"nameID_" + b, type:"USHORT", value:g}, {name:"flags_" + b, type:"USHORT", value:0}];
      for (var h = 0;h < e.length;++h) {
        var k = e[h].tag;
        g.push({name:"axis_" + b + " " + k, type:"FIXED", value:c.coordinates[k] << 16});
      }
      return g;
    }
    function e(b, c, e, g) {
      var f = {};
      b = new r.Parser(b, c);
      f.name = g[b.parseUShort()] || {};
      b.skip("uShort", 1);
      f.coordinates = {};
      for (g = 0;g < e.length;++g) {
        f.coordinates[e[g].tag] = b.parseFixed();
      }
      return f;
    }
    var p = h("../check"), r = h("../parse"), w = h("../table");
    b.make = function(b, c) {
      var e = new w.Table("fvar", [{name:"version", type:"ULONG", value:65536}, {name:"offsetToData", type:"USHORT", value:0}, {name:"countSizePairs", type:"USHORT", value:2}, {name:"axisCount", type:"USHORT", value:b.axes.length}, {name:"axisSize", type:"USHORT", value:20}, {name:"instanceCount", type:"USHORT", value:b.instances.length}, {name:"instanceSize", type:"USHORT", value:4 + 4 * b.axes.length}]);
      e.offsetToData = e.sizeOf();
      for (var f = 0;f < b.axes.length;f++) {
        e.fields = e.fields.concat(k(f, b.axes[f], c));
      }
      for (f = 0;f < b.instances.length;f++) {
        e.fields = e.fields.concat(g(f, b.instances[f], b.axes, c));
      }
      return e;
    };
    b.parse = function(b, g, f) {
      var h = new r.Parser(b, g), k = h.parseULong();
      p.argument(65536 === k, "Unsupported fvar table version.");
      var l = h.parseOffset16();
      h.skip("uShort", 1);
      for (var n = h.parseUShort(), t = h.parseUShort(), k = h.parseUShort(), h = h.parseUShort(), v = [], w = 0;n > w;w++) {
        v.push(c(b, g + l + w * t, f));
      }
      w = [];
      g = g + l + n * t;
      for (l = 0;k > l;l++) {
        w.push(e(b, g + l * h, v, f));
      }
      return {axes:v, instances:w};
    };
  }, {"../check":2, "../parse":10, "../table":13}], 17:[function(h, l, b) {
    function f(b, c, e, g, f) {
      var h;
      return 0 < (c & g) ? (h = b.parseByte(), 0 === (c & f) && (h = -h), h = e + h) : h = 0 < (c & f) ? e : e + b.parseShort(), h;
    }
    function k(b, c, g) {
      c = new r.Parser(c, g);
      b.numberOfContours = c.parseShort();
      b._xMin = c.parseShort();
      b._yMin = c.parseShort();
      b._xMax = c.parseShort();
      b._yMax = c.parseShort();
      var h;
      if (0 < b.numberOfContours) {
        var k, l = b.endPointIndices = [];
        for (k = 0;k < b.numberOfContours;k += 1) {
          l.push(c.parseUShort());
        }
        b.instructionLength = c.parseUShort();
        b.instructions = [];
        for (k = 0;k < b.instructionLength;k += 1) {
          b.instructions.push(c.parseByte());
        }
        var n = l[l.length - 1] + 1;
        g = [];
        for (k = 0;n > k;k += 1) {
          if (h = c.parseByte(), g.push(h), 0 < (8 & h)) {
            for (var p = c.parseByte(), t = 0;p > t;t += 1) {
              g.push(h), k += 1;
            }
          }
        }
        if (e.argument(g.length === n, "Bad flags."), 0 < l.length) {
          t = [];
          if (0 < n) {
            for (k = 0;n > k;k += 1) {
              h = g[k], p = {}, p.onCurve = !!(1 & h), p.lastPointOfContour = 0 <= l.indexOf(k), t.push(p);
            }
            for (k = l = 0;n > k;k += 1) {
              h = g[k], p = t[k], p.x = f(c, h, l, 2, 16), l = p.x;
            }
            for (k = l = 0;n > k;k += 1) {
              h = g[k], p = t[k], p.y = f(c, h, l, 4, 32), l = p.y;
            }
          }
          b.points = t;
        } else {
          b.points = [];
        }
      } else {
        if (0 === b.numberOfContours) {
          b.points = [];
        } else {
          for (b.isComposite = !0, b.points = [], b.components = [], h = !0;h;) {
            g = c.parseUShort(), h = {glyphIndex:c.parseUShort(), xScale:1, scale01:0, scale10:0, yScale:1, dx:0, dy:0}, 0 < (1 & g) ? 0 < (2 & g) ? (h.dx = c.parseShort(), h.dy = c.parseShort()) : h.matchedPoints = [c.parseUShort(), c.parseUShort()] : 0 < (2 & g) ? (h.dx = c.parseChar(), h.dy = c.parseChar()) : h.matchedPoints = [c.parseByte(), c.parseByte()], 0 < (8 & g) ? h.xScale = h.yScale = c.parseF2Dot14() : 0 < (64 & g) ? (h.xScale = c.parseF2Dot14(), h.yScale = c.parseF2Dot14()) : 0 < (128 & 
            g) && (h.xScale = c.parseF2Dot14(), h.scale01 = c.parseF2Dot14(), h.scale10 = c.parseF2Dot14(), h.yScale = c.parseF2Dot14()), b.components.push(h), h = !!(32 & g);
          }
        }
      }
    }
    function c(b, c) {
      for (var e = [], g = 0;g < b.length;g += 1) {
        var f = b[g];
        e.push({x:c.xScale * f.x + c.scale01 * f.y + c.dx, y:c.scale10 * f.x + c.yScale * f.y + c.dy, onCurve:f.onCurve, lastPointOfContour:f.lastPointOfContour});
      }
      return e;
    }
    function g(b, g) {
      if (g.isComposite) {
        for (var f = 0;f < g.components.length;f += 1) {
          var h = g.components[f], k = b.get(h.glyphIndex);
          if (k.getPath(), k.points) {
            if (void 0 !== h.matchedPoints) {
              if (h.matchedPoints[0] > g.points.length - 1 || h.matchedPoints[1] > k.points.length - 1) {
                throw Error("Matched points out of range in " + g.name);
              }
              var l = g.points[h.matchedPoints[0]], n = k.points[h.matchedPoints[1]], h = {xScale:h.xScale, scale01:h.scale01, scale10:h.scale10, yScale:h.yScale, dx:0, dy:0}, n = c([n], h)[0];
              h.dx = l.x - n.x;
              h.dy = l.y - n.y;
            }
            k = c(k.points, h);
            g.points = g.points.concat(k);
          }
        }
      }
      var p;
      g = g.points;
      b = new w.Path;
      if (g) {
        f = [];
        k = [];
        for (l = 0;l < g.length;l += 1) {
          n = g[l], k.push(n), n.lastPointOfContour && (f.push(k), k = []);
        }
        g = (e.argument(0 === k.length, "There are still points left in the current contour."), f);
        for (f = 0;f < g.length;f += 1) {
          var r, k = g[f], l = k[0], n = k[k.length - 1];
          l.onCurve ? (p = null, r = !0) : (l = n.onCurve ? n : {x:(l.x + n.x) / 2, y:(l.y + n.y) / 2}, p = l, r = !1);
          b.moveTo(l.x, l.y);
          for (h = r ? 1 : 0;h < k.length;h += 1) {
            var t = k[h], F = 0 === h ? l : k[h - 1];
            if (F.onCurve && t.onCurve) {
              b.lineTo(t.x, t.y);
            } else {
              if (F.onCurve && !t.onCurve) {
                p = t;
              } else {
                if (F.onCurve || t.onCurve) {
                  if (F.onCurve || !t.onCurve) {
                    throw Error("Invalid state.");
                  }
                  b.quadraticCurveTo(p.x, p.y, t.x, t.y);
                  p = null;
                } else {
                  b.quadraticCurveTo(F.x, F.y, (F.x + t.x) / 2, (F.y + t.y) / 2), p = t;
                }
              }
            }
          }
          l !== n && (p ? b.quadraticCurveTo(p.x, p.y, l.x, l.y) : b.lineTo(l.x, l.y));
        }
        p = (b.closePath(), b);
      } else {
        p = b;
      }
      return p;
    }
    var e = h("../check"), p = h("../glyphset"), r = h("../parse"), w = h("../path");
    b.parse = function(b, c, e, f) {
      var h, l = new p.GlyphSet(f);
      for (h = 0;h < e.length - 1;h += 1) {
        var n = e[h];
        n !== e[h + 1] ? l.push(h, p.ttfGlyphLoader(f, h, k, b, c + n, g)) : l.push(h, p.glyphLoader(f, h));
      }
      return l;
    };
  }, {"../check":2, "../glyphset":7, "../parse":10, "../path":11}], 18:[function(h, l, b) {
    function f(b, c) {
      b = new r.Parser(b, c);
      c = b.parseUShort();
      for (var e = [], g = 0;c > g;g++) {
        e[b.parseTag()] = {offset:b.parseUShort()};
      }
      return e;
    }
    function k(b, c) {
      b = new r.Parser(b, c);
      var e = b.parseUShort();
      c = b.parseUShort();
      if (1 === e) {
        return b.parseUShortList(c);
      }
      if (2 === e) {
        for (e = [];c--;) {
          for (var g = b.parseUShort(), f = b.parseUShort(), h = b.parseUShort();f >= g;g++) {
            e[h++] = g;
          }
        }
        return e;
      }
    }
    function c(b, c) {
      b = new r.Parser(b, c);
      c = b.parseUShort();
      if (1 === c) {
        var e = b.parseUShort();
        c = b.parseUShort();
        var g = b.parseUShortList(c);
        return function(b) {
          return g[b - e] || 0;
        };
      }
      if (2 === c) {
        c = b.parseUShort();
        for (var f = [], h = [], k = [], l = 0;c > l;l++) {
          f[l] = b.parseUShort(), h[l] = b.parseUShort(), k[l] = b.parseUShort();
        }
        return function(b) {
          for (var c = 0, e = f.length - 1;e > c;) {
            var g = c + e + 1 >> 1;
            b < f[g] ? e = g - 1 : c = g;
          }
          return f[c] <= b && b <= h[c] ? k[c] || 0 : 0;
        };
      }
    }
    function g(b, e) {
      var g, f = new r.Parser(b, e), h = f.parseUShort(), l = f.parseUShort(), l = k(b, e + l), n = f.parseUShort(), p = f.parseUShort();
      if (4 === n && 0 === p) {
        var w = {};
        if (1 === h) {
          b = f.parseUShort();
          var C = [];
          e = f.parseOffset16List(b);
          for (h = 0;b > h;h++) {
            var D = e[h], F = w[D];
            if (!F) {
              for (F = {}, f.relativeOffset = D, D = f.parseUShort();D--;) {
                var E = f.parseUShort();
                n && (g = f.parseShort());
                p && f.parseShort();
                F[E] = g;
              }
            }
            C[l[h]] = F;
          }
          return function(b, c) {
            return (b = C[b]) ? b[c] : void 0;
          };
        }
        if (2 === h) {
          var F = f.parseUShort(), D = f.parseUShort(), w = f.parseUShort(), h = f.parseUShort(), z = c(b, e + F), I = c(b, e + D), J = [];
          for (b = 0;w > b;b++) {
            for (e = J[b] = [], F = 0;h > F;F++) {
              n && (g = f.parseShort()), p && f.parseShort(), e[F] = g;
            }
          }
          var R = {};
          for (b = 0;b < l.length;b++) {
            R[l[b]] = 1;
          }
          return function(b, c) {
            if (R[b]) {
              return b = z(b), c = I(c), (b = J[b]) ? b[c] : void 0;
            }
          };
        }
      }
    }
    function e(b, c) {
      var e = new r.Parser(b, c), f = e.parseUShort(), h = e.parseUShort(), k = 16 & h, l = e.parseUShort(), n = e.parseOffset16List(l), e = {lookupType:f, lookupFlag:h, markFilteringSet:k ? e.parseUShort() : -1};
      if (2 === f) {
        for (var p = [], f = 0;l > f;f++) {
          p.push(g(b, c + n[f]));
        }
        e.getKerningValue = function(b, c) {
          for (var e = p.length;e--;) {
            var g = p[e](b, c);
            if (void 0 !== g) {
              return g;
            }
          }
          return 0;
        };
      }
      return e;
    }
    var p = h("../check"), r = h("../parse");
    b.parse = function(b, c, g) {
      var h = new r.Parser(b, c), k = h.parseFixed();
      p.argument(1 === k, "Unsupported GPOS table version.");
      f(b, c + h.parseUShort());
      f(b, c + h.parseUShort());
      var l = h.parseUShort();
      h.relativeOffset = l;
      k = h.parseUShort();
      h = h.parseOffset16List(k);
      c += l;
      for (l = 0;k > l;l++) {
        var n = e(b, c + h[l]);
        2 !== n.lookupType || g.getGposKerningValue || (g.getGposKerningValue = n.getKerningValue);
      }
    };
  }, {"../check":2, "../parse":10}], 19:[function(h, l, b) {
    var f = h("../check"), k = h("../parse").Parser, c = Array(9), g = h("../table");
    c[1] = function() {
      var b = this.offset + this.relativeOffset, c = this.parseUShort();
      return 1 === c ? {substFormat:1, coverage:this.parsePointer(k.coverage), deltaGlyphId:this.parseUShort()} : 2 === c ? {substFormat:2, coverage:this.parsePointer(k.coverage), substitute:this.parseOffset16List()} : void f.assert(!1, "0x" + b.toString(16) + ": lookup type 1 format must be 1 or 2.");
    };
    c[2] = function() {
      var b = this.parseUShort();
      return f.argument(1 === b, "GSUB Multiple Substitution Subtable identifier-format must be 1"), {substFormat:b, coverage:this.parsePointer(k.coverage), sequences:this.parseListOfLists()};
    };
    c[3] = function() {
      var b = this.parseUShort();
      return f.argument(1 === b, "GSUB Alternate Substitution Subtable identifier-format must be 1"), {substFormat:b, coverage:this.parsePointer(k.coverage), alternateSets:this.parseListOfLists()};
    };
    c[4] = function() {
      var b = this.parseUShort();
      return f.argument(1 === b, "GSUB ligature table identifier-format must be 1"), {substFormat:b, coverage:this.parsePointer(k.coverage), ligatureSets:this.parseListOfLists(function() {
        return {ligGlyph:this.parseUShort(), components:this.parseUShortList(this.parseUShort() - 1)};
      })};
    };
    var e = {sequenceIndex:k.uShort, lookupListIndex:k.uShort};
    c[5] = function() {
      var b = this.offset + this.relativeOffset, c = this.parseUShort();
      if (1 === c) {
        return {substFormat:c, coverage:this.parsePointer(k.coverage), ruleSets:this.parseListOfLists(function() {
          var b = this.parseUShort(), c = this.parseUShort();
          return {input:this.parseUShortList(b - 1), lookupRecords:this.parseRecordList(c, e)};
        })};
      }
      if (2 === c) {
        return {substFormat:c, coverage:this.parsePointer(k.coverage), classDef:this.parsePointer(k.classDef), classSets:this.parseListOfLists(function() {
          var b = this.parseUShort(), c = this.parseUShort();
          return {classes:this.parseUShortList(b - 1), lookupRecords:this.parseRecordList(c, e)};
        })};
      }
      if (3 === c) {
        var b = this.parseUShort(), g = this.parseUShort();
        return {substFormat:c, coverages:this.parseList(b, k.pointer(k.coverage)), lookupRecords:this.parseRecordList(g, e)};
      }
      f.assert(!1, "0x" + b.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
    };
    c[6] = function() {
      var b = this.offset + this.relativeOffset, c = this.parseUShort();
      return 1 === c ? {substFormat:1, coverage:this.parsePointer(k.coverage), chainRuleSets:this.parseListOfLists(function() {
        return {backtrack:this.parseUShortList(), input:this.parseUShortList(this.parseShort() - 1), lookahead:this.parseUShortList(), lookupRecords:this.parseRecordList(e)};
      })} : 2 === c ? {substFormat:2, coverage:this.parsePointer(k.coverage), backtrackClassDef:this.parsePointer(k.classDef), inputClassDef:this.parsePointer(k.classDef), lookaheadClassDef:this.parsePointer(k.classDef), chainClassSet:this.parseListOfLists(function() {
        return {backtrack:this.parseUShortList(), input:this.parseUShortList(this.parseShort() - 1), lookahead:this.parseUShortList(), lookupRecords:this.parseRecordList(e)};
      })} : 3 === c ? {substFormat:3, backtrackCoverage:this.parseList(k.pointer(k.coverage)), inputCoverage:this.parseList(k.pointer(k.coverage)), lookaheadCoverage:this.parseList(k.pointer(k.coverage)), lookupRecords:this.parseRecordList(e)} : void f.assert(!1, "0x" + b.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
    };
    c[7] = function() {
      var b = this.parseUShort();
      f.argument(1 === b, "GSUB Extension Substitution subtable identifier-format must be 1");
      var b = this.parseUShort(), e = new k(this.data, this.offset + this.parseULong());
      return {substFormat:1, lookupType:b, extension:c[b].call(e)};
    };
    c[8] = function() {
      var b = this.parseUShort();
      return f.argument(1 === b, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), {substFormat:b, coverage:this.parsePointer(k.coverage), backtrackCoverage:this.parseList(k.pointer(k.coverage)), lookaheadCoverage:this.parseList(k.pointer(k.coverage)), substitutes:this.parseUShortList()};
    };
    var p = Array(9);
    p[1] = function(b) {
      return 1 === b.substFormat ? new g.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:1}, {name:"coverage", type:"TABLE", value:new g.Coverage(b.coverage)}, {name:"deltaGlyphID", type:"USHORT", value:b.deltaGlyphId}]) : new g.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:2}, {name:"coverage", type:"TABLE", value:new g.Coverage(b.coverage)}].concat(g.ushortList("substitute", b.substitute)));
    };
    p[3] = function(b) {
      return f.assert(1 === b.substFormat, "Lookup type 3 substFormat must be 1."), new g.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:1}, {name:"coverage", type:"TABLE", value:new g.Coverage(b.coverage)}].concat(g.tableList("altSet", b.alternateSets, function(b) {
        return new g.Table("alternateSetTable", g.ushortList("alternate", b));
      })));
    };
    p[4] = function(b) {
      return f.assert(1 === b.substFormat, "Lookup type 4 substFormat must be 1."), new g.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:1}, {name:"coverage", type:"TABLE", value:new g.Coverage(b.coverage)}].concat(g.tableList("ligSet", b.ligatureSets, function(b) {
        return new g.Table("ligatureSetTable", g.tableList("ligature", b, function(b) {
          return new g.Table("ligatureTable", [{name:"ligGlyph", type:"USHORT", value:b.ligGlyph}].concat(g.ushortList("component", b.components, b.components.length + 1)));
        }));
      })));
    };
    b.parse = function(b, e) {
      b = new k(b, e || 0);
      e = b.parseVersion();
      return f.argument(1 === e, "Unsupported GSUB table version."), {version:e, scripts:b.parseScriptList(), features:b.parseFeatureList(), lookups:b.parseLookupList(c)};
    };
    b.make = function(b) {
      return new g.Table("GSUB", [{name:"version", type:"ULONG", value:65536}, {name:"scripts", type:"TABLE", value:new g.ScriptList(b.scripts)}, {name:"features", type:"TABLE", value:new g.FeatureList(b.features)}, {name:"lookups", type:"TABLE", value:new g.LookupList(b.lookups, p)}]);
    };
  }, {"../check":2, "../parse":10, "../table":13}], 20:[function(h, l, b) {
    var f = h("../check"), k = h("../parse"), c = h("../table");
    b.parse = function(b, c) {
      var e = {};
      b = new k.Parser(b, c);
      return e.version = b.parseVersion(), e.fontRevision = Math.round(1E3 * b.parseFixed()) / 1E3, e.checkSumAdjustment = b.parseULong(), e.magicNumber = b.parseULong(), f.argument(1594834165 === e.magicNumber, "Font header has wrong magic number."), e.flags = b.parseUShort(), e.unitsPerEm = b.parseUShort(), e.created = b.parseLongDateTime(), e.modified = b.parseLongDateTime(), e.xMin = b.parseShort(), e.yMin = b.parseShort(), e.xMax = b.parseShort(), e.yMax = b.parseShort(), e.macStyle = b.parseUShort(), 
      e.lowestRecPPEM = b.parseUShort(), e.fontDirectionHint = b.parseShort(), e.indexToLocFormat = b.parseShort(), e.glyphDataFormat = b.parseShort(), e;
    };
    b.make = function(b) {
      var e = Math.round((new Date).getTime() / 1E3) + 2082844800, g = e;
      return b.createdTimestamp && (g = b.createdTimestamp + 2082844800), new c.Table("head", [{name:"version", type:"FIXED", value:65536}, {name:"fontRevision", type:"FIXED", value:65536}, {name:"checkSumAdjustment", type:"ULONG", value:0}, {name:"magicNumber", type:"ULONG", value:1594834165}, {name:"flags", type:"USHORT", value:0}, {name:"unitsPerEm", type:"USHORT", value:1E3}, {name:"created", type:"LONGDATETIME", value:g}, {name:"modified", type:"LONGDATETIME", value:e}, {name:"xMin", type:"SHORT", 
      value:0}, {name:"yMin", type:"SHORT", value:0}, {name:"xMax", type:"SHORT", value:0}, {name:"yMax", type:"SHORT", value:0}, {name:"macStyle", type:"USHORT", value:0}, {name:"lowestRecPPEM", type:"USHORT", value:0}, {name:"fontDirectionHint", type:"SHORT", value:2}, {name:"indexToLocFormat", type:"SHORT", value:0}, {name:"glyphDataFormat", type:"SHORT", value:0}], b);
    };
  }, {"../check":2, "../parse":10, "../table":13}], 21:[function(h, l, b) {
    var f = h("../parse"), k = h("../table");
    b.parse = function(b, g) {
      var c = {};
      b = new f.Parser(b, g);
      return c.version = b.parseVersion(), c.ascender = b.parseShort(), c.descender = b.parseShort(), c.lineGap = b.parseShort(), c.advanceWidthMax = b.parseUShort(), c.minLeftSideBearing = b.parseShort(), c.minRightSideBearing = b.parseShort(), c.xMaxExtent = b.parseShort(), c.caretSlopeRise = b.parseShort(), c.caretSlopeRun = b.parseShort(), c.caretOffset = b.parseShort(), b.relativeOffset += 8, c.metricDataFormat = b.parseShort(), c.numberOfHMetrics = b.parseUShort(), c;
    };
    b.make = function(b) {
      return new k.Table("hhea", [{name:"version", type:"FIXED", value:65536}, {name:"ascender", type:"FWORD", value:0}, {name:"descender", type:"FWORD", value:0}, {name:"lineGap", type:"FWORD", value:0}, {name:"advanceWidthMax", type:"UFWORD", value:0}, {name:"minLeftSideBearing", type:"FWORD", value:0}, {name:"minRightSideBearing", type:"FWORD", value:0}, {name:"xMaxExtent", type:"FWORD", value:0}, {name:"caretSlopeRise", type:"SHORT", value:1}, {name:"caretSlopeRun", type:"SHORT", value:0}, {name:"caretOffset", 
      type:"SHORT", value:0}, {name:"reserved1", type:"SHORT", value:0}, {name:"reserved2", type:"SHORT", value:0}, {name:"reserved3", type:"SHORT", value:0}, {name:"reserved4", type:"SHORT", value:0}, {name:"metricDataFormat", type:"SHORT", value:0}, {name:"numberOfHMetrics", type:"USHORT", value:0}], b);
    };
  }, {"../parse":10, "../table":13}], 22:[function(h, l, b) {
    var f = h("../parse"), k = h("../table");
    b.parse = function(b, g, e, h, k) {
      var c, l;
      b = new f.Parser(b, g);
      for (g = 0;h > g;g += 1) {
        e > g && (c = b.parseUShort(), l = b.parseShort());
        var p = k.get(g);
        p.advanceWidth = c;
        p.leftSideBearing = l;
      }
    };
    b.make = function(b) {
      for (var c = new k.Table("hmtx", []), e = 0;e < b.length;e += 1) {
        var f = b.get(e), h = f.leftSideBearing || 0;
        c.fields.push({name:"advanceWidth_" + e, type:"USHORT", value:f.advanceWidth || 0});
        c.fields.push({name:"leftSideBearing_" + e, type:"SHORT", value:h});
      }
      return c;
    };
  }, {"../parse":10, "../table":13}], 23:[function(h, l, b) {
    var f = h("../check"), k = h("../parse");
    b.parse = function(b, g) {
      var c = {};
      b = new k.Parser(b, g);
      g = b.parseUShort();
      f.argument(0 === g, "Unsupported kern table version.");
      b.skip("uShort", 1);
      g = b.parseUShort();
      f.argument(0 === g, "Unsupported kern sub-table version.");
      b.skip("uShort", 2);
      g = b.parseUShort();
      b.skip("uShort", 3);
      for (var h = 0;g > h;h += 1) {
        var l = b.parseUShort(), w = b.parseUShort(), n = b.parseShort();
        c[l + "," + w] = n;
      }
      return c;
    };
  }, {"../check":2, "../parse":10}], 24:[function(h, l, b) {
    var f = h("../parse");
    b.parse = function(b, c, g, e) {
      b = new f.Parser(b, c);
      c = e ? b.parseUShort : b.parseULong;
      for (var h = [], k = 0;g + 1 > k;k += 1) {
        var l = c.call(b);
        e && (l *= 2);
        h.push(l);
      }
      return h;
    };
  }, {"../parse":10}], 25:[function(h, l, b) {
    var f = h("../check"), k = h("../parse"), c = h("../table");
    b.make = function(b) {
      for (var e = new c.Table("ltag", [{name:"version", type:"ULONG", value:1}, {name:"flags", type:"ULONG", value:0}, {name:"numTags", type:"ULONG", value:b.length}]), g = "", f = 12 + 4 * b.length, h = 0;h < b.length;++h) {
        var k = g.indexOf(b[h]);
        0 > k && (k = g.length, g += b[h]);
        e.fields.push({name:"offset " + h, type:"USHORT", value:f + k});
        e.fields.push({name:"length " + h, type:"USHORT", value:b[h].length});
      }
      return e.fields.push({name:"stringPool", type:"CHARARRAY", value:g}), e;
    };
    b.parse = function(b, c) {
      var e = new k.Parser(b, c), g = e.parseULong();
      f.argument(1 === g, "Unsupported ltag table version.");
      e.skip("uLong", 1);
      for (var g = e.parseULong(), h = [], l = 0;g > l;l++) {
        for (var t = "", v = c + e.parseUShort(), y = e.parseUShort(), x = v;v + y > x;++x) {
          t += String.fromCharCode(b.getInt8(x));
        }
        h.push(t);
      }
      return h;
    };
  }, {"../check":2, "../parse":10, "../table":13}], 26:[function(h, l, b) {
    var f = h("../parse"), k = h("../table");
    b.parse = function(b, g) {
      var c = {};
      b = new f.Parser(b, g);
      return c.version = b.parseVersion(), c.numGlyphs = b.parseUShort(), 1 === c.version && (c.maxPoints = b.parseUShort(), c.maxContours = b.parseUShort(), c.maxCompositePoints = b.parseUShort(), c.maxCompositeContours = b.parseUShort(), c.maxZones = b.parseUShort(), c.maxTwilightPoints = b.parseUShort(), c.maxStorage = b.parseUShort(), c.maxFunctionDefs = b.parseUShort(), c.maxInstructionDefs = b.parseUShort(), c.maxStackElements = b.parseUShort(), c.maxSizeOfInstructions = b.parseUShort(), c.maxComponentElements = 
      b.parseUShort(), c.maxComponentDepth = b.parseUShort()), c;
    };
    b.make = function(b) {
      return new k.Table("maxp", [{name:"version", type:"FIXED", value:20480}, {name:"numGlyphs", type:"USHORT", value:b}]);
    };
  }, {"../parse":10, "../table":13}], 27:[function(h, l, b) {
    var f = h("../types").decode, k = h("../check"), c = h("../parse"), g = h("../table");
    b.parse = function(b, g) {
      var e = new c.Parser(b, g), h = e.parseULong();
      k.argument(1 === h, "Unsupported META table version.");
      e.parseULong();
      e.parseULong();
      for (var h = e.parseULong(), l = {}, p = 0;h > p;p++) {
        var v = e.parseTag(), y = e.parseULong(), x = e.parseULong(), y = f.UTF8(b, g + y, x);
        l[v] = y;
      }
      return l;
    };
    b.make = function(b) {
      var c = Object.keys(b).length, e = "", f = 16 + 12 * c, c = new g.Table("meta", [{name:"version", type:"ULONG", value:1}, {name:"flags", type:"ULONG", value:0}, {name:"offset", type:"ULONG", value:f}, {name:"numTags", type:"ULONG", value:c}]), h;
      for (h in b) {
        var k = e.length, e = e + b[h];
        c.fields.push({name:"tag " + h, type:"TAG", value:h});
        c.fields.push({name:"offset " + h, type:"ULONG", value:f + k});
        c.fields.push({name:"length " + h, type:"ULONG", value:b[h].length});
      }
      return c.fields.push({name:"stringPool", type:"CHARARRAY", value:e}), c;
    };
  }, {"../check":2, "../parse":10, "../table":13, "../types":32}], 28:[function(h, l, b) {
    function f(b, c, e) {
      switch(b) {
        case 0:
          return x;
        case 1:
          return u[e] || q[c];
        case 3:
          if (1 === c || 10 === c) {
            return x;
          }
      }
    }
    function k(b) {
      var c = {}, e;
      for (e in b) {
        c[b[e]] = parseInt(e);
      }
      return c;
    }
    function c(b, c, e, g, f, h) {
      return new w.Record("NameRecord", [{name:"platformID", type:"USHORT", value:b}, {name:"encodingID", type:"USHORT", value:c}, {name:"languageID", type:"USHORT", value:e}, {name:"nameID", type:"USHORT", value:g}, {name:"length", type:"USHORT", value:f}, {name:"offset", type:"USHORT", value:h}]);
    }
    function g(b, c) {
      var e;
      a: {
        e = b.length;
        var g = c.length - e + 1, f = 0;
        b: for (;g > f;f++) {
          for (;g > f;) {
            for (var h = 0;e > h;h++) {
              if (c[f + h] !== b[h]) {
                continue b;
              }
            }
            e = f;
            break a;
          }
        }
        e = -1;
      }
      if (0 > e) {
        for (e = c.length, g = 0, f = b.length;f > g;++g) {
          c.push(b[g]);
        }
      }
      return e;
    }
    l = h("../types");
    var e = l.decode, p = l.encode, r = h("../parse"), w = h("../table"), n = "copyright fontFamily fontSubfamily uniqueID fullName version postScriptName trademark manufacturer designer description manufacturerURL designerURL license licenseURL reserved preferredFamily preferredSubfamily compatibleFullName sampleText postScriptFindFontName wwsFamily wwsSubfamily".split(" "), t = {0:"en", 1:"fr", 2:"de", 3:"it", 4:"nl", 5:"sv", 6:"es", 7:"da", 8:"pt", 9:"no", 10:"he", 11:"ja", 12:"ar", 13:"fi", 14:"el", 
    15:"is", 16:"mt", 17:"tr", 18:"hr", 19:"zh-Hant", 20:"ur", 21:"hi", 22:"th", 23:"ko", 24:"lt", 25:"pl", 26:"hu", 27:"es", 28:"lv", 29:"se", 30:"fo", 31:"fa", 32:"ru", 33:"zh", 34:"nl-BE", 35:"ga", 36:"sq", 37:"ro", 38:"cz", 39:"sk", 40:"si", 41:"yi", 42:"sr", 43:"mk", 44:"bg", 45:"uk", 46:"be", 47:"uz", 48:"kk", 49:"az-Cyrl", 50:"az-Arab", 51:"hy", 52:"ka", 53:"mo", 54:"ky", 55:"tg", 56:"tk", 57:"mn-CN", 58:"mn", 59:"ps", 60:"ks", 61:"ku", 62:"sd", 63:"bo", 64:"ne", 65:"sa", 66:"mr", 67:"bn", 
    68:"as", 69:"gu", 70:"pa", 71:"or", 72:"ml", 73:"kn", 74:"ta", 75:"te", 76:"si", 77:"my", 78:"km", 79:"lo", 80:"vi", 81:"id", 82:"tl", 83:"ms", 84:"ms-Arab", 85:"am", 86:"ti", 87:"om", 88:"so", 89:"sw", 90:"rw", 91:"rn", 92:"ny", 93:"mg", 94:"eo", 128:"cy", 129:"eu", 130:"ca", 131:"la", 132:"qu", 133:"gn", 134:"ay", 135:"tt", 136:"ug", 137:"dz", 138:"jv", 139:"su", 140:"gl", 141:"af", 142:"br", 143:"iu", 144:"gd", 145:"gv", 146:"ga", 147:"to", 148:"el-polyton", 149:"kl", 150:"az", 151:"nn"}, 
    v = {0:0, 1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0, 8:0, 9:0, 10:5, 11:1, 12:4, 13:0, 14:6, 15:0, 16:0, 17:0, 18:0, 19:2, 20:4, 21:9, 22:21, 23:3, 24:29, 25:29, 26:29, 27:29, 28:29, 29:0, 30:0, 31:4, 32:7, 33:25, 34:0, 35:0, 36:0, 37:0, 38:29, 39:29, 40:0, 41:5, 42:7, 43:7, 44:7, 45:7, 46:7, 47:7, 48:7, 49:7, 50:4, 51:24, 52:23, 53:7, 54:7, 55:7, 56:7, 57:27, 58:7, 59:4, 60:4, 61:4, 62:4, 63:26, 64:9, 65:9, 66:9, 67:13, 68:13, 69:11, 70:10, 71:12, 72:17, 73:16, 74:14, 75:15, 76:18, 77:19, 78:20, 79:22, 
    80:30, 81:0, 82:0, 83:0, 84:4, 85:28, 86:28, 87:28, 88:0, 89:0, 90:0, 91:0, 92:0, 93:0, 94:0, 128:0, 129:0, 130:0, 131:0, 132:0, 133:0, 134:0, 135:7, 136:4, 137:26, 138:0, 139:0, 140:0, 141:0, 142:0, 143:28, 144:0, 145:0, 146:0, 147:0, 148:6, 149:0, 150:0, 151:0}, y = {1078:"af", 1052:"sq", 1156:"gsw", 1118:"am", 5121:"ar-DZ", 15361:"ar-BH", 3073:"ar", 2049:"ar-IQ", 11265:"ar-JO", 13313:"ar-KW", 12289:"ar-LB", 4097:"ar-LY", 6145:"ary", 8193:"ar-OM", 16385:"ar-QA", 1025:"ar-SA", 10241:"ar-SY", 
    7169:"aeb", 14337:"ar-AE", 9217:"ar-YE", 1067:"hy", 1101:"as", 2092:"az-Cyrl", 1068:"az", 1133:"ba", 1069:"eu", 1059:"be", 2117:"bn", 1093:"bn-IN", 8218:"bs-Cyrl", 5146:"bs", 1150:"br", 1026:"bg", 1027:"ca", 3076:"zh-HK", 5124:"zh-MO", 2052:"zh", 4100:"zh-SG", 1028:"zh-TW", 1155:"co", 1050:"hr", 4122:"hr-BA", 1029:"cs", 1030:"da", 1164:"prs", 1125:"dv", 2067:"nl-BE", 1043:"nl", 3081:"en-AU", 10249:"en-BZ", 4105:"en-CA", 9225:"en-029", 16393:"en-IN", 6153:"en-IE", 8201:"en-JM", 17417:"en-MY", 
    5129:"en-NZ", 13321:"en-PH", 18441:"en-SG", 7177:"en-ZA", 11273:"en-TT", 2057:"en-GB", 1033:"en", 12297:"en-ZW", 1061:"et", 1080:"fo", 1124:"fil", 1035:"fi", 2060:"fr-BE", 3084:"fr-CA", 1036:"fr", 5132:"fr-LU", 6156:"fr-MC", 4108:"fr-CH", 1122:"fy", 1110:"gl", 1079:"ka", 3079:"de-AT", 1031:"de", 5127:"de-LI", 4103:"de-LU", 2055:"de-CH", 1032:"el", 1135:"kl", 1095:"gu", 1128:"ha", 1037:"he", 1081:"hi", 1038:"hu", 1039:"is", 1136:"ig", 1057:"id", 1117:"iu", 2141:"iu-Latn", 2108:"ga", 1076:"xh", 
    1077:"zu", 1040:"it", 2064:"it-CH", 1041:"ja", 1099:"kn", 1087:"kk", 1107:"km", 1158:"quc", 1159:"rw", 1089:"sw", 1111:"kok", 1042:"ko", 1088:"ky", 1108:"lo", 1062:"lv", 1063:"lt", 2094:"dsb", 1134:"lb", 1071:"mk", 2110:"ms-BN", 1086:"ms", 1100:"ml", 1082:"mt", 1153:"mi", 1146:"arn", 1102:"mr", 1148:"moh", 1104:"mn", 2128:"mn-CN", 1121:"ne", 1044:"nb", 2068:"nn", 1154:"oc", 1096:"or", 1123:"ps", 1045:"pl", 1046:"pt", 2070:"pt-PT", 1094:"pa", 1131:"qu-BO", 2155:"qu-EC", 3179:"qu", 1048:"ro", 1047:"rm", 
    1049:"ru", 9275:"smn", 4155:"smj-NO", 5179:"smj", 3131:"se-FI", 1083:"se", 2107:"se-SE", 8251:"sms", 6203:"sma-NO", 7227:"sms", 1103:"sa", 7194:"sr-Cyrl-BA", 3098:"sr", 6170:"sr-Latn-BA", 2074:"sr-Latn", 1132:"nso", 1074:"tn", 1115:"si", 1051:"sk", 1060:"sl", 11274:"es-AR", 16394:"es-BO", 13322:"es-CL", 9226:"es-CO", 5130:"es-CR", 7178:"es-DO", 12298:"es-EC", 17418:"es-SV", 4106:"es-GT", 18442:"es-HN", 2058:"es-MX", 19466:"es-NI", 6154:"es-PA", 15370:"es-PY", 10250:"es-PE", 20490:"es-PR", 3082:"es", 
    1034:"es", 21514:"es-US", 14346:"es-UY", 8202:"es-VE", 2077:"sv-FI", 1053:"sv", 1114:"syr", 1064:"tg", 2143:"tzm", 1097:"ta", 1092:"tt", 1098:"te", 1054:"th", 1105:"bo", 1055:"tr", 1090:"tk", 1152:"ug", 1058:"uk", 1070:"hsb", 1056:"ur", 2115:"uz-Cyrl", 1091:"uz", 1066:"vi", 1106:"cy", 1160:"wo", 1157:"sah", 1144:"ii", 1130:"yo"}, x = "utf-16", q = {0:"macintosh", 1:"x-mac-japanese", 2:"x-mac-chinesetrad", 3:"x-mac-korean", 6:"x-mac-greek", 7:"x-mac-cyrillic", 9:"x-mac-devanagai", 10:"x-mac-gurmukhi", 
    11:"x-mac-gujarati", 12:"x-mac-oriya", 13:"x-mac-bengali", 14:"x-mac-tamil", 15:"x-mac-telugu", 16:"x-mac-kannada", 17:"x-mac-malayalam", 18:"x-mac-sinhalese", 19:"x-mac-burmese", 20:"x-mac-khmer", 21:"x-mac-thai", 22:"x-mac-lao", 23:"x-mac-georgian", 24:"x-mac-armenian", 25:"x-mac-chinesesimp", 26:"x-mac-tibetan", 27:"x-mac-mongolian", 28:"x-mac-ethiopic", 29:"x-mac-ce", 30:"x-mac-vietnamese", 31:"x-mac-extarabic"}, u = {15:"x-mac-icelandic", 17:"x-mac-turkish", 18:"x-mac-croatian", 24:"x-mac-ce", 
    25:"x-mac-ce", 26:"x-mac-ce", 27:"x-mac-ce", 28:"x-mac-ce", 30:"x-mac-icelandic", 37:"x-mac-romanian", 38:"x-mac-ce", 39:"x-mac-ce", 40:"x-mac-ce", 143:"x-mac-inuit", 146:"x-mac-gaelic"};
    b.parse = function(b, c, g) {
      var h = {};
      c = new r.Parser(b, c);
      for (var k = c.parseUShort(), l = c.parseUShort(), p = c.offset + c.parseUShort(), q = 0;l > q;q++) {
        var u = c.parseUShort(), v = c.parseUShort(), w = c.parseUShort(), B = c.parseUShort(), B = n[B] || B, D = c.parseUShort(), C = c.parseUShort(), ha;
        a: {
          switch(u) {
            case 0:
              if (65535 === w) {
                ha = "und";
                break a;
              }
              if (g) {
                ha = g[w];
                break a;
              }
              break;
            case 1:
              ha = t[w];
              break a;
            case 3:
              ha = y[w];
              break a;
          }
          ha = void 0;
        }
        u = f(u, v, w);
        void 0 !== u && void 0 !== ha && (u = u === x ? e.UTF16(b, p + C, D) : e.MACSTRING(b, p + C, D, u)) && (v = h[B], void 0 === v && (v = h[B] = {}), v[ha] = u);
      }
      return 1 === k && c.parseUShort(), h;
    };
    b.make = function(b, e) {
      var h, l = [], q = {}, r = k(n), u;
      for (u in b) {
        var x = r[u];
        if (void 0 === x && (x = u), h = parseInt(x), isNaN(h)) {
          throw Error('Name table entry "' + u + '" does not exist, see nameTableNames for complete list.');
        }
        q[h] = b[u];
        l.push(h);
      }
      u = k(t);
      x = k(y);
      b = [];
      for (var r = [], B = 0;B < l.length;B++) {
        h = l[B];
        var C = q[h], M;
        for (M in C) {
          var P = C[M], H = 1, ba = u[M], ha = v[ba], Z = f(H, ha, ba), Z = p.MACSTRING(P, Z);
          void 0 === Z && (H = 0, ba = e.indexOf(M), 0 > ba && (ba = e.length, e.push(M)), ha = 4, Z = p.UTF16(P));
          var ea = g(Z, r);
          b.push(c(H, ha, ba, h, Z.length, ea));
          H = x[M];
          void 0 !== H && (P = p.UTF16(P), ba = g(P, r), b.push(c(3, 1, H, h, P.length, ba)));
        }
      }
      b.sort(function(b, c) {
        return b.platformID - c.platformID || b.encodingID - c.encodingID || b.languageID - c.languageID || b.nameID - c.nameID;
      });
      e = new w.Table("name", [{name:"format", type:"USHORT", value:0}, {name:"count", type:"USHORT", value:b.length}, {name:"stringOffset", type:"USHORT", value:6 + 12 * b.length}]);
      for (h = 0;h < b.length;h++) {
        e.fields.push({name:"record_" + h, type:"RECORD", value:b[h]});
      }
      return e.fields.push({name:"strings", type:"LITERAL", value:r}), e;
    };
  }, {"../parse":10, "../table":13, "../types":32}], 29:[function(h, l, b) {
    var f = h("../parse"), k = h("../table"), c = [{begin:0, end:127}, {begin:128, end:255}, {begin:256, end:383}, {begin:384, end:591}, {begin:592, end:687}, {begin:688, end:767}, {begin:768, end:879}, {begin:880, end:1023}, {begin:11392, end:11519}, {begin:1024, end:1279}, {begin:1328, end:1423}, {begin:1424, end:1535}, {begin:42240, end:42559}, {begin:1536, end:1791}, {begin:1984, end:2047}, {begin:2304, end:2431}, {begin:2432, end:2559}, {begin:2560, end:2687}, {begin:2688, end:2815}, {begin:2816, 
    end:2943}, {begin:2944, end:3071}, {begin:3072, end:3199}, {begin:3200, end:3327}, {begin:3328, end:3455}, {begin:3584, end:3711}, {begin:3712, end:3839}, {begin:4256, end:4351}, {begin:6912, end:7039}, {begin:4352, end:4607}, {begin:7680, end:7935}, {begin:7936, end:8191}, {begin:8192, end:8303}, {begin:8304, end:8351}, {begin:8352, end:8399}, {begin:8400, end:8447}, {begin:8448, end:8527}, {begin:8528, end:8591}, {begin:8592, end:8703}, {begin:8704, end:8959}, {begin:8960, end:9215}, {begin:9216, 
    end:9279}, {begin:9280, end:9311}, {begin:9312, end:9471}, {begin:9472, end:9599}, {begin:9600, end:9631}, {begin:9632, end:9727}, {begin:9728, end:9983}, {begin:9984, end:10175}, {begin:12288, end:12351}, {begin:12352, end:12447}, {begin:12448, end:12543}, {begin:12544, end:12591}, {begin:12592, end:12687}, {begin:43072, end:43135}, {begin:12800, end:13055}, {begin:13056, end:13311}, {begin:44032, end:55215}, {begin:55296, end:57343}, {begin:67840, end:67871}, {begin:19968, end:40959}, {begin:57344, 
    end:63743}, {begin:12736, end:12783}, {begin:64256, end:64335}, {begin:64336, end:65023}, {begin:65056, end:65071}, {begin:65040, end:65055}, {begin:65104, end:65135}, {begin:65136, end:65279}, {begin:65280, end:65519}, {begin:65520, end:65535}, {begin:3840, end:4095}, {begin:1792, end:1871}, {begin:1920, end:1983}, {begin:3456, end:3583}, {begin:4096, end:4255}, {begin:4608, end:4991}, {begin:5024, end:5119}, {begin:5120, end:5759}, {begin:5760, end:5791}, {begin:5792, end:5887}, {begin:6016, 
    end:6143}, {begin:6144, end:6319}, {begin:10240, end:10495}, {begin:40960, end:42127}, {begin:5888, end:5919}, {begin:66304, end:66351}, {begin:66352, end:66383}, {begin:66560, end:66639}, {begin:118784, end:119039}, {begin:119808, end:120831}, {begin:1044480, end:1048573}, {begin:65024, end:65039}, {begin:917504, end:917631}, {begin:6400, end:6479}, {begin:6480, end:6527}, {begin:6528, end:6623}, {begin:6656, end:6687}, {begin:11264, end:11359}, {begin:11568, end:11647}, {begin:19904, end:19967}, 
    {begin:43008, end:43055}, {begin:65536, end:65663}, {begin:65856, end:65935}, {begin:66432, end:66463}, {begin:66464, end:66527}, {begin:66640, end:66687}, {begin:66688, end:66735}, {begin:67584, end:67647}, {begin:68096, end:68191}, {begin:119552, end:119647}, {begin:73728, end:74751}, {begin:119648, end:119679}, {begin:7040, end:7103}, {begin:7168, end:7247}, {begin:7248, end:7295}, {begin:43136, end:43231}, {begin:43264, end:43311}, {begin:43312, end:43359}, {begin:43520, end:43615}, {begin:65936, 
    end:65999}, {begin:66E3, end:66047}, {begin:66208, end:66271}, {begin:127024, end:127135}];
    b.unicodeRanges = c;
    b.getUnicodeRange = function(b) {
      for (var e = 0;e < c.length;e += 1) {
        var g = c[e];
        if (b >= g.begin && b < g.end) {
          return e;
        }
      }
      return -1;
    };
    b.parse = function(b, c) {
      var e = {};
      b = new f.Parser(b, c);
      e.version = b.parseUShort();
      e.xAvgCharWidth = b.parseShort();
      e.usWeightClass = b.parseUShort();
      e.usWidthClass = b.parseUShort();
      e.fsType = b.parseUShort();
      e.ySubscriptXSize = b.parseShort();
      e.ySubscriptYSize = b.parseShort();
      e.ySubscriptXOffset = b.parseShort();
      e.ySubscriptYOffset = b.parseShort();
      e.ySuperscriptXSize = b.parseShort();
      e.ySuperscriptYSize = b.parseShort();
      e.ySuperscriptXOffset = b.parseShort();
      e.ySuperscriptYOffset = b.parseShort();
      e.yStrikeoutSize = b.parseShort();
      e.yStrikeoutPosition = b.parseShort();
      e.sFamilyClass = b.parseShort();
      e.panose = [];
      for (c = 0;10 > c;c++) {
        e.panose[c] = b.parseByte();
      }
      return e.ulUnicodeRange1 = b.parseULong(), e.ulUnicodeRange2 = b.parseULong(), e.ulUnicodeRange3 = b.parseULong(), e.ulUnicodeRange4 = b.parseULong(), e.achVendID = String.fromCharCode(b.parseByte(), b.parseByte(), b.parseByte(), b.parseByte()), e.fsSelection = b.parseUShort(), e.usFirstCharIndex = b.parseUShort(), e.usLastCharIndex = b.parseUShort(), e.sTypoAscender = b.parseShort(), e.sTypoDescender = b.parseShort(), e.sTypoLineGap = b.parseShort(), e.usWinAscent = b.parseUShort(), e.usWinDescent = 
      b.parseUShort(), 1 <= e.version && (e.ulCodePageRange1 = b.parseULong(), e.ulCodePageRange2 = b.parseULong()), 2 <= e.version && (e.sxHeight = b.parseShort(), e.sCapHeight = b.parseShort(), e.usDefaultChar = b.parseUShort(), e.usBreakChar = b.parseUShort(), e.usMaxContent = b.parseUShort()), e;
    };
    b.make = function(b) {
      return new k.Table("OS/2", [{name:"version", type:"USHORT", value:3}, {name:"xAvgCharWidth", type:"SHORT", value:0}, {name:"usWeightClass", type:"USHORT", value:0}, {name:"usWidthClass", type:"USHORT", value:0}, {name:"fsType", type:"USHORT", value:0}, {name:"ySubscriptXSize", type:"SHORT", value:650}, {name:"ySubscriptYSize", type:"SHORT", value:699}, {name:"ySubscriptXOffset", type:"SHORT", value:0}, {name:"ySubscriptYOffset", type:"SHORT", value:140}, {name:"ySuperscriptXSize", type:"SHORT", 
      value:650}, {name:"ySuperscriptYSize", type:"SHORT", value:699}, {name:"ySuperscriptXOffset", type:"SHORT", value:0}, {name:"ySuperscriptYOffset", type:"SHORT", value:479}, {name:"yStrikeoutSize", type:"SHORT", value:49}, {name:"yStrikeoutPosition", type:"SHORT", value:258}, {name:"sFamilyClass", type:"SHORT", value:0}, {name:"bFamilyType", type:"BYTE", value:0}, {name:"bSerifStyle", type:"BYTE", value:0}, {name:"bWeight", type:"BYTE", value:0}, {name:"bProportion", type:"BYTE", value:0}, {name:"bContrast", 
      type:"BYTE", value:0}, {name:"bStrokeVariation", type:"BYTE", value:0}, {name:"bArmStyle", type:"BYTE", value:0}, {name:"bLetterform", type:"BYTE", value:0}, {name:"bMidline", type:"BYTE", value:0}, {name:"bXHeight", type:"BYTE", value:0}, {name:"ulUnicodeRange1", type:"ULONG", value:0}, {name:"ulUnicodeRange2", type:"ULONG", value:0}, {name:"ulUnicodeRange3", type:"ULONG", value:0}, {name:"ulUnicodeRange4", type:"ULONG", value:0}, {name:"achVendID", type:"CHARARRAY", value:"XXXX"}, {name:"fsSelection", 
      type:"USHORT", value:0}, {name:"usFirstCharIndex", type:"USHORT", value:0}, {name:"usLastCharIndex", type:"USHORT", value:0}, {name:"sTypoAscender", type:"SHORT", value:0}, {name:"sTypoDescender", type:"SHORT", value:0}, {name:"sTypoLineGap", type:"SHORT", value:0}, {name:"usWinAscent", type:"USHORT", value:0}, {name:"usWinDescent", type:"USHORT", value:0}, {name:"ulCodePageRange1", type:"ULONG", value:0}, {name:"ulCodePageRange2", type:"ULONG", value:0}, {name:"sxHeight", type:"SHORT", value:0}, 
      {name:"sCapHeight", type:"SHORT", value:0}, {name:"usDefaultChar", type:"USHORT", value:0}, {name:"usBreakChar", type:"USHORT", value:0}, {name:"usMaxContext", type:"USHORT", value:0}], b);
    };
  }, {"../parse":10, "../table":13}], 30:[function(h, l, b) {
    var f = h("../encoding"), k = h("../parse"), c = h("../table");
    b.parse = function(b, c) {
      var e = {};
      c = new k.Parser(b, c);
      switch(e.version = c.parseVersion(), e.italicAngle = c.parseFixed(), e.underlinePosition = c.parseShort(), e.underlineThickness = c.parseShort(), e.isFixedPitch = c.parseULong(), e.minMemType42 = c.parseULong(), e.maxMemType42 = c.parseULong(), e.minMemType1 = c.parseULong(), e.maxMemType1 = c.parseULong(), e.version) {
        case 1:
          e.names = f.standardNames.slice();
          break;
        case 2:
          e.numberOfGlyphs = c.parseUShort();
          e.glyphNameIndex = Array(e.numberOfGlyphs);
          for (b = 0;b < e.numberOfGlyphs;b++) {
            e.glyphNameIndex[b] = c.parseUShort();
          }
          e.names = [];
          for (b = 0;b < e.numberOfGlyphs;b++) {
            if (e.glyphNameIndex[b] >= f.standardNames.length) {
              var g = c.parseChar();
              e.names.push(c.parseString(g));
            }
          }
          break;
        case 2.5:
          for (e.numberOfGlyphs = c.parseUShort(), e.offset = Array(e.numberOfGlyphs), b = 0;b < e.numberOfGlyphs;b++) {
            e.offset[b] = c.parseChar();
          }
      }
      return e;
    };
    b.make = function() {
      return new c.Table("post", [{name:"version", type:"FIXED", value:196608}, {name:"italicAngle", type:"FIXED", value:0}, {name:"underlinePosition", type:"FWORD", value:0}, {name:"underlineThickness", type:"FWORD", value:0}, {name:"isFixedPitch", type:"ULONG", value:0}, {name:"minMemType42", type:"ULONG", value:0}, {name:"maxMemType42", type:"ULONG", value:0}, {name:"minMemType1", type:"ULONG", value:0}, {name:"maxMemType1", type:"ULONG", value:0}]);
    };
  }, {"../encoding":4, "../parse":10, "../table":13}], 31:[function(h, l, b) {
    function f(b) {
      for (;0 !== b.length % 4;) {
        b.push(0);
      }
      for (var c = 0, e = 0;e < b.length;e += 4) {
        c += (b[e] << 24) + (b[e + 1] << 16) + (b[e + 2] << 8) + b[e + 3];
      }
      return c % Math.pow(2, 32);
    }
    function k(b, c, e, f) {
      return new p.Record("Table Record", [{name:"tag", type:"TAG", value:void 0 !== b ? b : ""}, {name:"checkSum", type:"ULONG", value:void 0 !== c ? c : 0}, {name:"offset", type:"ULONG", value:void 0 !== e ? e : 0}, {name:"length", type:"ULONG", value:void 0 !== f ? f : 0}]);
    }
    function c(b) {
      var c = new p.Table("sfnt", [{name:"version", type:"TAG", value:"OTTO"}, {name:"numTables", type:"USHORT", value:0}, {name:"searchRange", type:"USHORT", value:0}, {name:"entrySelector", type:"USHORT", value:0}, {name:"rangeShift", type:"USHORT", value:0}]);
      c.tables = b;
      c.numTables = b.length;
      var g = Math.pow(2, Math.log(c.numTables) / Math.log(2) | 0);
      c.searchRange = 16 * g;
      c.entrySelector = Math.log(g) / Math.log(2) | 0;
      c.rangeShift = 16 * c.numTables - c.searchRange;
      for (var g = [], h = [], l = c.sizeOf() + k().sizeOf() * c.numTables;0 !== l % 4;) {
        l += 1, h.push({name:"padding", type:"BYTE", value:0});
      }
      for (var n = 0;n < b.length;n += 1) {
        var q = b[n];
        e.argument(4 === q.tableName.length, "Table name" + q.tableName + " is invalid.");
        var r = q.sizeOf(), t = k(q.tableName, f(q.encode()), l, r);
        g.push({name:t.tag + " Table Record", type:"RECORD", value:t});
        h.push({name:q.tableName + " table", type:"RECORD", value:q});
        l += r;
        for (e.argument(!isNaN(l), "Something went wrong calculating the offset.");0 !== l % 4;) {
          l += 1, h.push({name:"padding", type:"BYTE", value:0});
        }
      }
      return g.sort(function(b, c) {
        return b.value.tag > c.value.tag ? 1 : -1;
      }), c.fields = c.fields.concat(g), c.fields = c.fields.concat(h), c;
    }
    function g(b, c, e) {
      for (var f = 0;f < c.length;f += 1) {
        var g = b.charToGlyphIndex(c[f]);
        if (0 < g) {
          return b.glyphs.get(g).getMetrics();
        }
      }
      return e;
    }
    var e = h("../check"), p = h("../table"), r = h("./cmap"), w = h("./cff"), n = h("./head"), t = h("./hhea"), v = h("./hmtx"), y = h("./ltag"), x = h("./maxp"), q = h("./name"), u = h("./os2"), B = h("./post"), C = h("./gsub"), D = h("./meta");
    b.computeCheckSum = f;
    b.make = c;
    b.fontToTable = function(b) {
      for (var e, h = [], k = [], l = [], p = [], F = [], M = [], P = [], H = 0, ba = 0, ha = 0, Z = 0, ea = 0, S = 0;S < b.glyphs.length;S += 1) {
        var V = b.glyphs.get(S), N = 0 | V.unicode;
        if (isNaN(V.advanceWidth)) {
          throw Error("Glyph " + V.name + " (" + S + "): advanceWidth is not a number.");
        }
        (e > N || void 0 === e) && 0 < N && (e = N);
        N > H && (H = N);
        N = u.getUnicodeRange(N);
        if (32 > N) {
          ba |= 1 << N;
        } else {
          if (64 > N) {
            ha |= 1 << N - 32;
          } else {
            if (96 > N) {
              Z |= 1 << N - 64;
            } else {
              if (!(123 > N)) {
                throw Error("Unicode ranges bits > 123 are reserved for internal usage");
              }
              ea |= 1 << N - 96;
            }
          }
        }
        ".notdef" !== V.name && (N = V.getMetrics(), h.push(N.xMin), k.push(N.yMin), l.push(N.xMax), p.push(N.yMax), M.push(N.leftSideBearing), P.push(N.rightSideBearing), F.push(V.advanceWidth));
      }
      S = Math.min.apply(null, h);
      k = Math.min.apply(null, k);
      l = Math.max.apply(null, l);
      p = Math.max.apply(null, p);
      h = Math.max.apply(null, F);
      for (N = V = 0;N < F.length;N += 1) {
        V += F[N];
      }
      S = {xMin:S, yMin:k, xMax:l, yMax:p, advanceWidthMax:h, advanceWidthAvg:V / F.length, minLeftSideBearing:Math.min.apply(null, M), maxLeftSideBearing:Math.max.apply(null, M), minRightSideBearing:Math.min.apply(null, P)};
      S.ascender = b.ascender;
      S.descender = b.descender;
      F = n.make({flags:3, unitsPerEm:b.unitsPerEm, xMin:S.xMin, yMin:S.yMin, xMax:S.xMax, yMax:S.yMax, lowestRecPPEM:3, createdTimestamp:b.createdTimestamp});
      M = t.make({ascender:S.ascender, descender:S.descender, advanceWidthMax:S.advanceWidthMax, minLeftSideBearing:S.minLeftSideBearing, minRightSideBearing:S.minRightSideBearing, xMaxExtent:S.maxLeftSideBearing + (S.xMax - S.xMin), numberOfHMetrics:b.glyphs.length});
      P = x.make(b.glyphs.length);
      e = u.make({xAvgCharWidth:Math.round(S.advanceWidthAvg), usWeightClass:b.tables.os2.usWeightClass, usWidthClass:b.tables.os2.usWidthClass, usFirstCharIndex:e, usLastCharIndex:H, ulUnicodeRange1:ba, ulUnicodeRange2:ha, ulUnicodeRange3:Z, ulUnicodeRange4:ea, fsSelection:b.tables.os2.fsSelection, sTypoAscender:S.ascender, sTypoDescender:S.descender, sTypoLineGap:0, usWinAscent:S.yMax, usWinDescent:Math.abs(S.yMin), ulCodePageRange1:1, sxHeight:g(b, "xyvw", {yMax:Math.round(S.ascender / 2)}).yMax, 
      sCapHeight:g(b, "HIKLEFJMNTZBDPRAGOQSUVWXY", S).yMax, usDefaultChar:b.hasChar(" ") ? 32 : 0, usBreakChar:b.hasChar(" ") ? 32 : 0});
      H = v.make(b.glyphs);
      ba = r.make(b.glyphs);
      ha = b.getEnglishName("fontFamily");
      Z = b.getEnglishName("fontSubfamily");
      ea = ha + " " + Z;
      (p = b.getEnglishName("postScriptName")) || (p = ha.replace(/\s/g, "") + "-" + Z);
      var l = {}, X;
      for (X in b.names) {
        l[X] = b.names[X];
      }
      l.uniqueID || (l.uniqueID = {en:b.getEnglishName("manufacturer") + ":" + ea});
      l.postScriptName || (l.postScriptName = {en:p});
      l.preferredFamily || (l.preferredFamily = b.names.fontFamily);
      l.preferredSubfamily || (l.preferredSubfamily = b.names.fontSubfamily);
      k = [];
      X = q.make(l, k);
      l = 0 < k.length ? y.make(k) : void 0;
      k = B.make();
      Z = w.make(b.glyphs, {version:b.getEnglishName("version"), fullName:ea, familyName:ha, weightName:Z, postScriptName:p, unitsPerEm:b.unitsPerEm, fontBBox:[0, S.yMin, S.ascender, S.advanceWidthMax]});
      ha = b.metas && 0 < Object.keys(b.metas).length ? D.make(b.metas) : void 0;
      X = [F, M, P, e, X, ba, k, Z, H];
      l && X.push(l);
      b.tables.gsub && X.push(C.make(b.tables.gsub));
      ha && X.push(ha);
      b = c(X);
      X = b.encode();
      X = f(X);
      e = b.fields;
      H = !1;
      for (S = 0;S < e.length;S += 1) {
        if ("head table" === e[S].name) {
          e[S].value.checkSumAdjustment = 2981146554 - X;
          H = !0;
          break;
        }
      }
      if (!H) {
        throw Error("Could not find head table with checkSum to adjust.");
      }
      return b;
    };
  }, {"../check":2, "../table":13, "./cff":14, "./cmap":15, "./gsub":19, "./head":20, "./hhea":21, "./hmtx":22, "./ltag":25, "./maxp":26, "./meta":27, "./name":28, "./os2":29, "./post":30}], 32:[function(h, l, b) {
    function f(b) {
      return function() {
        return b;
      };
    }
    var k = h("./check");
    h = {};
    var c = {}, g = {};
    c.BYTE = function(b) {
      return k.argument(0 <= b && 255 >= b, "Byte value should be between 0 and 255."), [b];
    };
    g.BYTE = f(1);
    c.CHAR = function(b) {
      return [b.charCodeAt(0)];
    };
    g.CHAR = f(1);
    c.CHARARRAY = function(b) {
      for (var c = [], e = 0;e < b.length;e += 1) {
        c[e] = b.charCodeAt(e);
      }
      return c;
    };
    g.CHARARRAY = function(b) {
      return b.length;
    };
    c.USHORT = function(b) {
      return [b >> 8 & 255, 255 & b];
    };
    g.USHORT = f(2);
    c.SHORT = function(b) {
      return 32768 <= b && (b = -(65536 - b)), [b >> 8 & 255, 255 & b];
    };
    g.SHORT = f(2);
    c.UINT24 = function(b) {
      return [b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    g.UINT24 = f(3);
    c.ULONG = function(b) {
      return [b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    g.ULONG = f(4);
    c.LONG = function(b) {
      return 2147483648 <= b && (b = -(4294967296 - b)), [b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    g.LONG = f(4);
    c.FIXED = c.ULONG;
    g.FIXED = g.ULONG;
    c.FWORD = c.SHORT;
    g.FWORD = g.SHORT;
    c.UFWORD = c.USHORT;
    g.UFWORD = g.USHORT;
    c.LONGDATETIME = function(b) {
      return [0, 0, 0, 0, b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    g.LONGDATETIME = f(8);
    c.TAG = function(b) {
      return k.argument(4 === b.length, "Tag should be exactly 4 ASCII characters."), [b.charCodeAt(0), b.charCodeAt(1), b.charCodeAt(2), b.charCodeAt(3)];
    };
    g.TAG = f(4);
    c.Card8 = c.BYTE;
    g.Card8 = g.BYTE;
    c.Card16 = c.USHORT;
    g.Card16 = g.USHORT;
    c.OffSize = c.BYTE;
    g.OffSize = g.BYTE;
    c.SID = c.USHORT;
    g.SID = g.USHORT;
    c.NUMBER = function(b) {
      return -107 <= b && 107 >= b ? [b + 139] : 108 <= b && 1131 >= b ? (b -= 108, [(b >> 8) + 247, 255 & b]) : -1131 <= b && -108 >= b ? (b = -b - 108, [(b >> 8) + 251, 255 & b]) : -32768 <= b && 32767 >= b ? c.NUMBER16(b) : c.NUMBER32(b);
    };
    g.NUMBER = function(b) {
      return c.NUMBER(b).length;
    };
    c.NUMBER16 = function(b) {
      return [28, b >> 8 & 255, 255 & b];
    };
    g.NUMBER16 = f(3);
    c.NUMBER32 = function(b) {
      return [29, b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    g.NUMBER32 = f(5);
    c.REAL = function(b) {
      var c = b.toString(), e = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(c);
      e && (c = parseFloat("1e" + ((e[2] ? +e[2] : 0) + e[1].length)), c = (Math.round(b * c) / c).toString());
      var f = "";
      b = 0;
      for (e = c.length;e > b;b += 1) {
        var g = c[b], f = f + ("e" === g ? "-" === c[++b] ? "c" : "b" : "." === g ? "a" : "-" === g ? "e" : g);
      }
      f += 1 & f.length ? "f" : "ff";
      c = [30];
      b = 0;
      for (e = f.length;e > b;b += 2) {
        c.push(parseInt(f.substr(b, 2), 16));
      }
      return c;
    };
    g.REAL = function(b) {
      return c.REAL(b).length;
    };
    c.NAME = c.CHARARRAY;
    g.NAME = g.CHARARRAY;
    c.STRING = c.CHARARRAY;
    g.STRING = g.CHARARRAY;
    h.UTF8 = function(b, c, e) {
      for (var f = [], g = 0;e > g;g++, c += 1) {
        f[g] = b.getUint8(c);
      }
      return String.fromCharCode.apply(null, f);
    };
    h.UTF16 = function(b, c, e) {
      var f = [];
      e /= 2;
      for (var g = 0;e > g;g++, c += 2) {
        f[g] = b.getUint16(c);
      }
      return String.fromCharCode.apply(null, f);
    };
    c.UTF16 = function(b) {
      for (var c = [], e = 0;e < b.length;e += 1) {
        var f = b.charCodeAt(e);
        c[c.length] = f >> 8 & 255;
        c[c.length] = 255 & f;
      }
      return c;
    };
    g.UTF16 = function(b) {
      return 2 * b.length;
    };
    var e = {"x-mac-croatian":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u0160\u2122\u00b4\u00a8\u2260\u017d\u00d8\u221e\u00b1\u2264\u2265\u2206\u00b5\u2202\u2211\u220f\u0161\u222b\u00aa\u00ba\u03a9\u017e\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u0106\u00ab\u010c\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u0110\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\uf8ff\u00a9\u2044\u20ac\u2039\u203a\u00c6\u00bb\u2013\u00b7\u201a\u201e\u2030\u00c2\u0107\u00c1\u010d\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\u0111\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u03c0\u00cb\u02da\u00b8\u00ca\u00e6\u02c7", 
    "x-mac-cyrillic":"\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\u2020\u00b0\u0490\u00a3\u00a7\u2022\u00b6\u0406\u00ae\u00a9\u2122\u0402\u0452\u2260\u0403\u0453\u221e\u00b1\u2264\u2265\u0456\u00b5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040a\u045a\u0458\u0405\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u040b\u045b\u040c\u045c\u0455\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u201e\u040e\u045e\u040f\u045f\u2116\u0401\u0451\u044f\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e", 
    "x-mac-gaelic":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u1e02\u00b1\u2264\u2265\u1e03\u010a\u010b\u1e0a\u1e0b\u1e1e\u1e1f\u0120\u0121\u1e40\u00e6\u00f8\u1e41\u1e56\u1e57\u027c\u0192\u017f\u1e60\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u1e61\u1e9b\u00ff\u0178\u1e6a\u20ac\u2039\u203a\u0176\u0177\u1e6b\u00b7\u1ef2\u1ef3\u204a\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\u2663\u00d2\u00da\u00db\u00d9\u0131\u00dd\u00fd\u0174\u0175\u1e84\u1e85\u1e80\u1e81\u1e82\u1e83", 
    "x-mac-greek":"\u00c4\u00b9\u00b2\u00c9\u00b3\u00d6\u00dc\u0385\u00e0\u00e2\u00e4\u0384\u00a8\u00e7\u00e9\u00e8\u00ea\u00eb\u00a3\u2122\u00ee\u00ef\u2022\u00bd\u2030\u00f4\u00f6\u00a6\u20ac\u00f9\u00fb\u00fc\u2020\u0393\u0394\u0398\u039b\u039e\u03a0\u00df\u00ae\u00a9\u03a3\u03aa\u00a7\u2260\u00b0\u00b7\u0391\u00b1\u2264\u2265\u00a5\u0392\u0395\u0396\u0397\u0399\u039a\u039c\u03a6\u03ab\u03a8\u03a9\u03ac\u039d\u00ac\u039f\u03a1\u2248\u03a4\u00ab\u00bb\u2026\u00a0\u03a5\u03a7\u0386\u0388\u0153\u2013\u2015\u201c\u201d\u2018\u2019\u00f7\u0389\u038a\u038c\u038e\u03ad\u03ae\u03af\u03cc\u038f\u03cd\u03b1\u03b2\u03c8\u03b4\u03b5\u03c6\u03b3\u03b7\u03b9\u03be\u03ba\u03bb\u03bc\u03bd\u03bf\u03c0\u03ce\u03c1\u03c3\u03c4\u03b8\u03c9\u03c2\u03c7\u03c5\u03b6\u03ca\u03cb\u0390\u03b0\u00ad", 
    "x-mac-icelandic":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u00dd\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u00e6\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u2044\u20ac\u00d0\u00f0\u00de\u00fe\u00fd\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7", 
    "x-mac-inuit":"\u1403\u1404\u1405\u1406\u140a\u140b\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144e\u144f\u1450\u1451\u1455\u1456\u1466\u146d\u146e\u146f\u1470\u1472\u1473\u1483\u148b\u148c\u148d\u148e\u1490\u1491\u00b0\u14a1\u14a5\u14a6\u2022\u00b6\u14a7\u00ae\u00a9\u2122\u14a8\u14aa\u14ab\u14bb\u14c2\u14c3\u14c4\u14c5\u14c7\u14c8\u14d0\u14ef\u14f0\u14f1\u14f2\u14f4\u14f5\u1505\u14d5\u14d6\u14d7\u14d8\u14da\u14db\u14ea\u1528\u1529\u152a\u152b\u152d\u2026\u00a0\u152e\u153e\u1555\u1556\u1557\u2013\u2014\u201c\u201d\u2018\u2019\u1558\u1559\u155a\u155d\u1546\u1547\u1548\u1549\u154b\u154c\u1550\u157f\u1580\u1581\u1582\u1583\u1584\u1585\u158f\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15a0\u15a1\u15a2\u15a3\u15a4\u15a5\u15a6\u157c\u0141\u0142", 
    "x-mac-ce":"\u00c4\u0100\u0101\u00c9\u0104\u00d6\u00dc\u00e1\u0105\u010c\u00e4\u010d\u0106\u0107\u00e9\u0179\u017a\u010e\u00ed\u010f\u0112\u0113\u0116\u00f3\u0117\u00f4\u00f6\u00f5\u00fa\u011a\u011b\u00fc\u2020\u00b0\u0118\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u0119\u00a8\u2260\u0123\u012e\u012f\u012a\u2264\u2265\u012b\u0136\u2202\u2211\u0142\u013b\u013c\u013d\u013e\u0139\u013a\u0145\u0146\u0143\u00ac\u221a\u0144\u0147\u2206\u00ab\u00bb\u2026\u00a0\u0148\u0150\u00d5\u0151\u014c\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u014d\u0154\u0155\u0158\u2039\u203a\u0159\u0156\u0157\u0160\u201a\u201e\u0161\u015a\u015b\u00c1\u0164\u0165\u00cd\u017d\u017e\u016a\u00d3\u00d4\u016b\u016e\u00da\u016f\u0170\u0171\u0172\u0173\u00dd\u00fd\u0137\u017b\u0141\u017c\u0122\u02c7", 
    macintosh:"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u00e6\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u2044\u20ac\u2039\u203a\ufb01\ufb02\u2021\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7", 
    "x-mac-romanian":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u0102\u0218\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u0103\u0219\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u2044\u20ac\u2039\u203a\u021a\u021b\u2021\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7", 
    "x-mac-turkish":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u00e6\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u011e\u011f\u0130\u0131\u015e\u015f\u2021\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\uf8a0\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7"};
    h.MACSTRING = function(b, c, f, g) {
      g = e[g];
      if (void 0 !== g) {
        for (var h = "", k = 0;f > k;k++) {
          var l = b.getUint8(c + k), h = h + (127 >= l ? String.fromCharCode(l) : g[127 & l]);
        }
        return h;
      }
    };
    var p = "function" == typeof WeakMap && new WeakMap, r;
    c.MACSTRING = function(b, c) {
      var f;
      a: {
        if (!r) {
          for (f in r = {}, e) {
            r[f] = new String(f);
          }
        }
        f = r[c];
        if (void 0 !== f) {
          if (p) {
            var g = p.get(f);
            if (void 0 !== g) {
              f = g;
              break a;
            }
          }
          c = e[c];
          if (void 0 !== c) {
            for (var g = {}, h = 0;h < c.length;h++) {
              g[c.charCodeAt(h)] = h + 128;
            }
            f = (p && p.set(f, g), g);
            break a;
          }
        }
        f = void 0;
      }
      if (void 0 !== f) {
        c = [];
        for (g = 0;g < b.length;g++) {
          h = b.charCodeAt(g);
          if (128 <= h && (h = f[h], void 0 === h)) {
            return;
          }
          c[g] = h;
        }
        return c;
      }
    };
    g.MACSTRING = function(b, e) {
      b = c.MACSTRING(b, e);
      return void 0 !== b ? b.length : 0;
    };
    c.INDEX = function(b) {
      var e, f = 1, g = [f], h = [];
      for (e = 0;e < b.length;e += 1) {
        var k = c.OBJECT(b[e]);
        Array.prototype.push.apply(h, k);
        f += k.length;
        g.push(f);
      }
      if (0 === h.length) {
        return [0, 0];
      }
      var k = [], f = 1 + Math.floor(Math.log(f) / Math.log(2)) / 8 | 0, l = [void 0, c.BYTE, c.USHORT, c.UINT24, c.ULONG][f];
      for (e = 0;e < g.length;e += 1) {
        var n = l(g[e]);
        Array.prototype.push.apply(k, n);
      }
      return Array.prototype.concat(c.Card16(b.length), c.OffSize(f), k, h);
    };
    g.INDEX = function(b) {
      return c.INDEX(b).length;
    };
    c.DICT = function(b) {
      for (var e = [], f = Object.keys(b), g = f.length, h = 0;g > h;h += 1) {
        var k = parseInt(f[h], 0), l = b[k], e = e.concat(c.OPERAND(l.value, l.type)), e = e.concat(c.OPERATOR(k));
      }
      return e;
    };
    g.DICT = function(b) {
      return c.DICT(b).length;
    };
    c.OPERATOR = function(b) {
      return 1200 > b ? [b] : [12, b - 1200];
    };
    c.OPERAND = function(b, e) {
      var f = [];
      if (Array.isArray(e)) {
        for (var g = 0;g < e.length;g += 1) {
          k.argument(b.length === e.length, "Not enough arguments given for type" + e), f = f.concat(c.OPERAND(b[g], e[g]));
        }
      } else {
        if ("SID" === e) {
          f = f.concat(c.NUMBER(b));
        } else {
          if ("offset" === e) {
            f = f.concat(c.NUMBER32(b));
          } else {
            if ("number" === e) {
              f = f.concat(c.NUMBER(b));
            } else {
              if ("real" !== e) {
                throw Error("Unknown operand type " + e);
              }
              f = f.concat(c.REAL(b));
            }
          }
        }
      }
      return f;
    };
    c.OP = c.BYTE;
    g.OP = g.BYTE;
    var w = "function" == typeof WeakMap && new WeakMap;
    c.CHARSTRING = function(b) {
      if (w) {
        var e = w.get(b);
        if (void 0 !== e) {
          return e;
        }
      }
      for (var e = [], f = b.length, g = 0;f > g;g += 1) {
        var h = b[g], e = e.concat(c[h.type](h.value));
      }
      return w && w.set(b, e), e;
    };
    g.CHARSTRING = function(b) {
      return c.CHARSTRING(b).length;
    };
    c.OBJECT = function(b) {
      var e = c[b.type];
      return k.argument(void 0 !== e, "No encoding function for type " + b.type), e(b.value);
    };
    g.OBJECT = function(b) {
      var c = g[b.type];
      return k.argument(void 0 !== c, "No sizeOf function for type " + b.type), c(b.value);
    };
    c.TABLE = function(b) {
      var e, f = [], g = b.fields.length, h = [], l = [];
      for (e = 0;g > e;e += 1) {
        var n = b.fields[e], p = c[n.type];
        k.argument(void 0 !== p, "No encoding function for field type " + n.type + " (" + n.name + ")");
        var r = b[n.name];
        void 0 === r && (r = n.value);
        p = p(r);
        "TABLE" === n.type ? (l.push(f.length), f = f.concat([0, 0]), h.push(p)) : f = f.concat(p);
      }
      for (e = 0;e < h.length;e += 1) {
        g = l[e], n = f.length, k.argument(65536 > n, "Table " + b.tableName + " too big."), f[g] = n >> 8, f[g + 1] = 255 & n, f = f.concat(h[e]);
      }
      return f;
    };
    g.TABLE = function(b) {
      for (var c = 0, e = b.fields.length, f = 0;e > f;f += 1) {
        var h = b.fields[f], l = g[h.type];
        k.argument(void 0 !== l, "No sizeOf function for field type " + h.type + " (" + h.name + ")");
        var n = b[h.name];
        void 0 === n && (n = h.value);
        c += l(n);
        "TABLE" === h.type && (c += 2);
      }
      return c;
    };
    c.RECORD = c.TABLE;
    g.RECORD = g.TABLE;
    c.LITERAL = function(b) {
      return b;
    };
    g.LITERAL = function(b) {
      return b.length;
    };
    b.decode = h;
    b.encode = c;
    b.sizeOf = g;
  }, {"./check":2}], 33:[function(h, l, b) {
    b.isBrowser = function() {
      return "undefined" != typeof window;
    };
    b.isNode = function() {
      return "undefined" == typeof window;
    };
    b.nodeBufferToArrayBuffer = function(b) {
      for (var f = new ArrayBuffer(b.length), c = new Uint8Array(f), g = 0;g < b.length;++g) {
        c[g] = b[g];
      }
      return f;
    };
    b.arrayBufferToNodeBuffer = function(b) {
      var f = new Buffer(b.byteLength);
      b = new Uint8Array(b);
      for (var c = 0;c < f.length;++c) {
        f[c] = b[c];
      }
      return f;
    };
    b.checkArgument = function(b, h) {
      if (!b) {
        throw h;
      }
    };
  }, {}]}, {}, [9])(9);
});
var BufferAttribute = THREE.BufferAttribute, BufferGeometry = THREE.BufferGeometry, Clock = THREE.Clock, Face3 = THREE.Face3, Geometry = THREE.Geometry, Object3D = THREE.Object3D, Raycaster = THREE.Raycaster, Material = THREE.Material, LineBasicMaterial = THREE.LineBasicMaterial, LineDashedMaterial = THREE.LineDashedMaterial, MeshBasicMaterial = THREE.MeshBasicMaterial, MeshDepthMaterial = THREE.MeshDepthMaterial, MeshLambertMaterial = THREE.MeshLambertMaterial, MeshNormalMaterial = THREE.MeshNormalMaterial, 
MeshPhongMaterial = THREE.MeshPhongMaterial, MeshPhysicalMaterial = THREE.MeshPhysicalMaterial, MeshStandardMaterial = THREE.MeshStandardMaterial, MultiMaterial = THREE.MultiMaterial, PointsMaterial = THREE.PointsMaterial, RawShaderMaterial = THREE.RawShaderMaterial, ShaderMaterial = THREE.ShaderMaterial, SpriteMaterial = THREE.SpriteMaterial, BoxBufferGeometry = THREE.BoxBufferGeometry, BoxGeometry = THREE.BoxGeometry, CircleBufferGeometry = THREE.CircleBufferGeometry, CircleGeometry = THREE.CircleGeometry, 
ConeBufferGeometry = THREE.ConeBufferGeometry, ConeGeometry = THREE.ConeGeometry, CylinderBufferGeometry = THREE.CylinderBufferGeometry, CylinderGeometry = THREE.CylinderGeometry, DodecahedronBufferGeometry = THREE.DodecahedronBufferGeometry, DodecahedronGeometry = THREE.DodecahedronGeometry, ExtrudeGeometry = THREE.ExtrudeGeometry, IcosahedronBufferGeometry = THREE.IcosahedronBufferGeometry, IcosahedronGeometry = THREE.IcosahedronGeometry, LatheBufferGeometry = THREE.LatheBufferGeometry, LatheGeometry = 
THREE.LatheGeometry, OctahedronBufferGeometry = THREE.OctahedronBufferGeometry, OctahedronGeometry = THREE.OctahedronGeometry, ParametricBufferGeometry = THREE.ParametricBufferGeometry, ParametricGeometry = THREE.ParametricGeometry, PlaneBufferGeometry = THREE.PlaneBufferGeometry, PlaneGeometry = THREE.PlaneGeometry, PolyhedronBufferGeometry = THREE.PolyhedronBufferGeometry, PolyhedronGeometry = THREE.PolyhedronGeometry, RingBufferGeometry = THREE.RingBufferGeometry, RingGeometry = THREE.RingGeometry, 
ShapeGeometry = THREE.ShapeGeometry, SphereBufferGeometry = THREE.SphereBufferGeometry, SphereGeometry = THREE.SphereGeometry, TetrahedronBufferGeometry = THREE.TetrahedronBufferGeometry, TetrahedronGeometry = THREE.TetrahedronGeometry, TextGeometry = THREE.TextGeometry, TorusBufferGeometry = THREE.TorusBufferGeometry, TorusGeometry = THREE.TorusGeometry, TorusKnotBufferGeometry = THREE.TorusKnotBufferGeometry, TorusKnotGeometry = THREE.TorusKnotGeometry, TubeGeometry = THREE.TubeGeometry, TubeBufferGeometry = 
THREE.TubeBufferGeometry, WireframeGeometry = THREE.WireframeGeometry, TrianglesDrawMode = THREE.TrianglesDrawMode, TriangleStripDrawMode = THREE.TriangleStripDrawMode, TriangleFanDrawMode = THREE.TriangleFanDrawMode, Box2 = THREE.Box2, Box3 = THREE.Box3, Color = THREE.Color, Euler = THREE.Euler, Line3 = THREE.Line3, Frustum = THREE.Frustum, Matrix3 = THREE.Matrix3, Matrix4 = THREE.Matrix4, Plane = THREE.Plane, Quarternion = THREE.Quarternion, Ray = THREE.Ray, Sphere = THREE.Sphere, Spline = THREE.Spline, 
Triangle = THREE.Triangle, Vector2 = THREE.Vector2, Vector3 = THREE.Vector3, Vector4 = THREE.Vector4, LOD = THREE.LOD, LensFlare = THREE.LensFlare, Line = THREE.Line, LineSegments = THREE.LineSegments, AABB = CANNON.AABB, ArrayCollisionMatrix = CANNON.ArrayCollisionMatrix, Body = CANNON.Body, Box = CANNON.Box, Broadphase = CANNON.Broadphase, ConeEquation = CANNON.ConeEquation, ConeTwistConstraint = CANNON.ConeTwistConstraint, Constraint = CANNON.Constraint, ContactEquation = CANNON.ContactEquation, 
ContactMaterial = CANNON.ContactMaterial, ConvexPolyhedron = CANNON.ConvexPolyhedron, Cylinder = CANNON.Cylinder, DistanceConstraint = CANNON.DistanceConstraint, Equation = CANNON.Equation, EventTarget = CANNON.EventTarget, FrictionEquation = CANNON.FrictionEquation, GridBroadphase = CANNON.GridBroadphase, GSSolver = CANNON.GSSolver, Heightfield = CANNON.Heightfield, HingeConstraint = CANNON.HingeConstraint, JacobianElement = CANNON.JacobianElement, LockConstraint = CANNON.LockConstraint, Mat3 = 
CANNON.Mat3, PhysicsMaterial = CANNON.Material, NaiveBroadphase = CANNON.NaiveBroadphase, Narrowphase = CANNON.Narrowphase, ObjectCollisionMatrix = CANNON.ObjectCollisionMatrix, Octree = CANNON.Octree, OctreeNode = CANNON.OctreeNode, Particle = CANNON.Particle, PointToPointConstraint = CANNON.PointToPointConstraint, Pool = CANNON.Pool, PhysicsRay = CANNON.Ray, RaycastResult = CANNON.RaycastResult, RaycastVehicle = CANNON.RaycastVehicle, RigidVehicle = CANNON.RigidVehicle, RotationalEquation = CANNON.RotationalEquation, 
RotationalMotorEquation = CANNON.RotationalMotorEquation, SAPBroadphase = CANNON.SAPBroadphase, Shape = CANNON.Shape, Solver = CANNON.Solver, SPHSystem = CANNON.SPHSystem, SplitSolver = CANNON.SplitSolver, Spring = CANNON.Spring, Transform = CANNON.Transform, Trimesh = CANNON.Trimesh, TupleDictionary = CANNON.TupleDictionary, Vec3 = CANNON.Vec3, Vec3Pool = CANNON.Vec3Pool, WheelInfo = CANNON.WheelInfo, World = CANNON.World;
function FileSystem() {
}
try {
  FileSystem.fs = require("fs");
} catch (a) {
}
FileSystem.readFile = function(a, h, l, b) {
  void 0 === h && (h = !0);
  if (void 0 !== FileSystem.fs) {
    a instanceof window.File && (a = a.path);
    if (h) {
      return a = FileSystem.fs.readFileSync(a, "utf8"), void 0 !== l && l(a), a;
    }
    FileSystem.fs.readFile(a, "utf8", function(a, b) {
      void 0 !== l && l(b);
    });
  } else {
    if (a instanceof window.File) {
      var f = new FileReader;
      f.onload = function() {
        void 0 !== l && l(f.result);
      };
      void 0 !== b && (f.onprogress = function(a) {
        b(a);
      });
      f.readAsText(a);
      return f.result;
    }
    var k = new XMLHttpRequest;
    k.overrideMimeType("text/plain");
    k.open("GET", a, !h);
    k.onload = function() {
      200 !== k.status && 0 !== k.status || void 0 === l || l(k.responseText);
    };
    void 0 !== b && (k.onprogress = function(a) {
      b(a);
    });
    k.send(null);
    return k.responseText;
  }
};
FileSystem.readFileArrayBuffer = function(a) {
  if (void 0 !== FileSystem.fs) {
    a = FileSystem.fs.readFileSync(a);
    for (var h = a.length, l = new ArrayBuffer(h), b = new Uint8Array(l), f = 0;f < h;f++) {
      b[f] = a[f];
    }
    return l;
  }
  h = new XMLHttpRequest;
  h.open("GET", a, !1);
  h.overrideMimeType("text/plain; charset=x-user-defined");
  h.send(null);
  return ArraybufferUtils.fromBinaryString(h.response);
};
FileSystem.readFileBase64 = function(a) {
  if (void 0 !== FileSystem.fs) {
    return a = FileSystem.fs.readFileSync(a), (new Buffer(a)).toString("base64");
  }
  var h = new XMLHttpRequest;
  h.open("GET", a, !1);
  h.overrideMimeType("text/plain; charset=x-user-defined");
  h.send(null);
  return Base64Utils.fromBinaryString(h.response);
};
FileSystem.writeFile = function(a, h) {
  if (void 0 !== FileSystem.fs) {
    a = FileSystem.fs.createWriteStream(a, "utf8"), a.write(h), a.end();
  } else {
    h = new Blob([h], {type:"octet/stream"});
    var l = document.createElement("a");
    l.download = a;
    l.href = window.URL.createObjectURL(h);
    l.onclick = function() {
      document.body.removeChild(this);
    };
    l.style.display = "none";
    document.body.appendChild(l);
    l.click();
  }
};
FileSystem.writeFileBase64 = function(a, h) {
  void 0 !== FileSystem.fs && (h = Buffer.from(Base64Utils.removeHeader(h), "base64"), a = FileSystem.fs.createWriteStream(a), a.write(h), a.end());
};
FileSystem.copyFile = function(a, h) {
  void 0 !== FileSystem.fs && FileSystem.fs.createReadStream(a).pipe(FileSystem.fs.createWriteStream(h));
};
FileSystem.makeDirectory = function(a) {
  if (void 0 !== FileSystem.fs) {
    try {
      FileSystem.fs.mkdirSync(a);
    } catch (h) {
    }
  }
};
FileSystem.getFilesDirectory = function(a) {
  if (void 0 !== FileSystem.fs) {
    try {
      return FileSystem.fs.readdirSync(a);
    } catch (h) {
    }
  }
  return [];
};
FileSystem.copyFolder = function(a, h) {
  if (void 0 !== FileSystem.fs) {
    FileSystem.makeDirectory(h);
    for (var l = FileSystem.fs.readdirSync(a), b = 0;b < l.length;b++) {
      var f = a + "\\" + l[b], k = h + "\\" + l[b], c = FileSystem.fs.statSync(f);
      c.isDirectory() ? FileSystem.copyFolder(f, k) : c.isSymbolicLink() ? FileSystem.fs.symlinkSync(FileSystem.fs.readlinkSync(f), k) : FileSystem.copyFile(f, k);
    }
  }
};
FileSystem.chooseFile = function(a, h, l) {
  var b = document.createElement("input");
  b.type = "file";
  void 0 !== h && (b.accept = h);
  b.onchange = function(f) {
    void 0 !== a && a(b.files);
  };
  void 0 !== l && (b.nwsaveas = !0 !== l ? l : "file");
  b.click();
};
FileSystem.chooseFileName = function(a, h) {
  var l = prompt("Save As", "file");
  null !== l && (void 0 === h || l.endsWith(h) || (l += h), void 0 !== a && a(l));
};
FileSystem.fileExists = function(a) {
  return void 0 !== FileSystem.fs ? FileSystem.fs.existsSync(a) : !1;
};
FileSystem.getFileName = function(a) {
  if (void 0 !== a) {
    var h = a.lastIndexOf("\\"), l = a.lastIndexOf("/");
    return a.substring(h > l ? h + 1 : l + 1, a.lastIndexOf("."));
  }
  return "";
};
FileSystem.getNameWithoutExtension = function(a) {
  return void 0 !== a ? a.substring(0, a.lastIndexOf(".")) : "";
};
FileSystem.getFilePath = function(a) {
  if (void 0 !== a) {
    var h = a.lastIndexOf("\\"), l = a.lastIndexOf("/");
    return a.substring(0, h > l ? h + 1 : l + 1);
  }
  return "";
};
FileSystem.getFileExtension = function(a) {
  return void 0 !== a ? a.substring(a.lastIndexOf(".") + 1, a.length).toLowerCase() : "";
};
THREE.Object3D.prototype.folded = !1;
THREE.Object3D.prototype.hidden = !1;
THREE.Object3D.prototype.initialize = function() {
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].initialize();
  }
};
THREE.Object3D.prototype.update = function() {
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].update();
  }
};
THREE.Object3D.prototype.dispose = function() {
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].dispose();
  }
};
THREE.Object3D.prototype.addAbove = function(a, h) {
  if (a === this) {
    return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this;
  }
  a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({type:"added"}), h = this.children.indexOf(h), this.children.splice(h, 0, a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a);
  return this;
};
THREE.Object3D.prototype.addBellow = function(a, h) {
  if (a === this) {
    return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this;
  }
  a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({type:"added"}), h = this.children.indexOf(h) + 1, this.children.splice(h, 0, a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a);
  return this;
};
THREE.Object3D.prototype.removeAll = function() {
  for (var a = this.children.length - 1;-1 < a;a--) {
    this.remove(this.children[a]);
  }
};
THREE.Object3D.prototype.isEmpty = function() {
  return 0 === this.children.length;
};
THREE.Object3D.prototype.destroy = function() {
  for (;0 < this.children.length;) {
    this.children[0].destroy();
  }
  null !== this.parent && (this.dispose && this.dispose(), this.parent.remove(this));
};
THREE.Object3D.prototype.toJSON = function(a, h, l) {
  function b(a) {
    var b = [], c;
    for (c in a) {
      var f = a[c];
      delete f.metadata;
      b.push(f);
    }
    return b;
  }
  var f = void 0 === a, k = {};
  f && (a = {fonts:{}, videos:{}, images:{}, audio:{}, geometries:{}, materials:{}, textures:{}}, k.metadata = {version:Nunu.VERSION, type:"NunuProgram"});
  var c = {};
  c.uuid = this.uuid;
  c.type = this.type;
  c.name = this.name;
  c.folded = this.folded;
  c.hidden = this.hidden;
  c.castShadow = this.castShadow;
  c.receiveShadow = this.receiveShadow;
  c.visible = this.visible;
  c.matrixAutoUpdate = this.matrixAutoUpdate;
  c.matrix = this.matrix.toArray();
  "{}" !== JSON.stringify(this.userData) && (c.userData = this.userData);
  void 0 !== this.geometry && (void 0 === a.geometries[this.geometry.uuid] && (a.geometries[this.geometry.uuid] = this.geometry.toJSON(a)), c.geometry = this.geometry.uuid);
  void 0 !== this.material && (void 0 === a.materials[this.material.uuid] && (a.materials[this.material.uuid] = this.material.toJSON(a)), c.material = this.material.uuid);
  void 0 !== h && h(a, c);
  if (!1 !== l && 0 < this.children.length) {
    for (c.children = [], h = 0;h < this.children.length;h++) {
      this.children[h].hidden || c.children.push(this.children[h].toJSON(a).object);
    }
  }
  f && (k.geometries = b(a.geometries), k.materials = b(a.materials), k.textures = b(a.textures), k.images = b(a.images), k.videos = b(a.videos), k.audio = b(a.audio), k.fonts = b(a.fonts));
  k.object = c;
  return k;
};
THREE.Vector3.fromJSON = function(a) {
  return new THREE.Vector3(a.x, a.y, a.z);
};
THREE.Vector3.prototype.toJSON = function() {
  return {x:this.x, y:this.y, z:this.z};
};
THREE.Vector2.fromJSON = function(a) {
  return new THREE.Vector2(a.x, a.y);
};
THREE.Vector2.prototype.toJSON = function() {
  return {x:this.x, y:this.y};
};
THREE.Texture.prototype.toJSON = function(a) {
  if (void 0 !== a.textures[this.uuid]) {
    return a.textures[this.uuid];
  }
  var h = {metadata:{version:Nunu.VERSION, type:"Texture"}, uuid:this.uuid, name:this.name, category:this.category, mapping:this.mapping, repeat:[this.repeat.x, this.repeat.y], offset:[this.offset.x, this.offset.y], wrap:[this.wrapS, this.wrapT], minFilter:this.minFilter, magFilter:this.magFilter, anisotropy:this.anisotropy, flipY:this.flipY};
  return a.textures[this.uuid] = h;
};
THREE.LightShadow.prototype.toJSON = function() {
  var a = {};
  a.bias = this.bias;
  a.radius = this.radius;
  a.mapSize = {};
  a.mapSize.x = this.mapSize.x;
  a.mapSize.y = this.mapSize.y;
  a.camera = {};
  a.camera.top = this.camera.top;
  a.camera.bottom = this.camera.bottom;
  a.camera.far = this.camera.far;
  a.camera.near = this.camera.near;
  a.camera.left = this.camera.left;
  a.camera.right = this.camera.right;
  return a;
};
THREE.LightShadow.prototype.fromJSON = function(a) {
  void 0 !== a.bias && (this.bias = a.bias);
  void 0 !== a.radius && (this.radius = a.radius);
  if (void 0 !== a.mapSize) {
    var h = a.mapSize;
    this.mapSize.set(h.x, h.y);
  }
  void 0 !== a.camera && (a = a.camera, this.camera.top = a.top, this.camera.bottom = a.bottom, this.camera.left = a.left, this.camera.right = a.right, this.camera.near = a.near, this.camera.far = a.far);
};
THREE.Fog.NONE = 0;
THREE.Fog.LINEAR = 1;
THREE.Fog.EXPONENTIAL = 2;
THREE.Material.prototype.dispose = function() {
  function a(a) {
    void 0 !== a && null !== a && a.dispose();
  }
  this.dispatchEvent({type:"dispose"});
  a(this.map);
  a(this.bumpMap);
  a(this.normalMap);
  a(this.displacementMap);
  a(this.specularMap);
  a(this.emissiveMap);
  a(this.alphaMap);
  a(this.roughnessMap);
  a(this.metalnessMap);
  a(this.envMap);
};
THREE.Material.prototype.toJSON = function(a) {
  function h(a) {
    var b = [], c;
    for (c in a) {
      var f = a[c];
      delete f.metadata;
      b.push(f);
    }
    return b;
  }
  void 0 === a && (a = {textures:{}, images:{}});
  var l = {};
  l.uuid = this.uuid;
  l.type = this.type;
  l.name = this.name;
  l.depthFunc = this.depthFunc;
  l.depthTest = this.depthTest;
  l.depthWrite = this.depthWrite;
  this.color && this.color.isColor && (l.color = this.color.getHex());
  void 0 !== this.roughness && (l.roughness = this.roughness);
  void 0 !== this.metalness && (l.metalness = this.metalness);
  this.specular && this.specular.isColor && (l.specular = this.specular.getHex());
  void 0 !== this.shininess && (l.shininess = this.shininess);
  void 0 !== this.clearCoat && (l.clearCoat = this.clearCoat);
  void 0 !== this.clearCoatRoughness && (l.clearCoatRoughness = this.clearCoatRoughness);
  this.map && this.map.isTexture && (l.map = this.map.toJSON(a).uuid);
  this.alphaMap && this.alphaMap.isTexture && (l.alphaMap = this.alphaMap.toJSON(a).uuid);
  this.lightMap && this.lightMap.isTexture && (l.lightMap = this.lightMap.toJSON(a).uuid);
  this.bumpMap && this.bumpMap.isTexture && (l.bumpMap = this.bumpMap.toJSON(a).uuid, l.bumpScale = this.bumpScale);
  this.normalMap && this.normalMap.isTexture && (l.normalMap = this.normalMap.toJSON(a).uuid, l.normalScale = this.normalScale.toArray());
  this.displacementMap && this.displacementMap.isTexture && (l.displacementMap = this.displacementMap.toJSON(a).uuid, l.displacementScale = this.displacementScale, l.displacementBias = this.displacementBias);
  this.roughnessMap && this.roughnessMap.isTexture && (l.roughnessMap = this.roughnessMap.toJSON(a).uuid);
  this.metalnessMap && this.metalnessMap.isTexture && (l.metalnessMap = this.metalnessMap.toJSON(a).uuid);
  this.emissive && this.emissive.isColor && (l.emissive = this.emissive.getHex());
  this.emissiveIntensity && this.emissiveIntensity.isColor && (l.emissiveIntensity = this.emissiveIntensity.getHex());
  this.emissiveMap && this.emissiveMap.isTexture && (l.emissiveMap = this.emissiveMap.toJSON(a).uuid);
  this.aoMap && this.aoMap.isTexture && (l.aoMap = this.aoMap.toJSON(a).uuid);
  this.aoMapIntensity && (l.aoMapIntensity = this.aoMapIntensity);
  this.specularMap && this.specularMap.isTexture && (l.specularMap = this.specularMap.toJSON(a).uuid);
  this.envMap && this.envMap.isTexture && (l.envMap = this.envMap.toJSON(a).uuid, l.reflectivity = this.reflectivity, this.combine && (l.combine = this.combine), this.envMapIntensity && (l.envMapIntensity = this.envMapIntensity), this.refractionRatio && (l.refractionRatio = this.refractionRatio));
  this.gradientMap && this.gradientMap.isTexture && (l.gradientMap = this.gradientMap.toJSON(a).uuid);
  void 0 !== this.size && (l.size = this.size);
  void 0 !== this.sizeAttenuation && (l.sizeAttenuation = this.sizeAttenuation);
  this.blending !== THREE.NormalBlending && (l.blending = this.blending);
  this.shading !== THREE.SmoothShading && (l.shading = this.shading);
  this.side !== THREE.FrontSide && (l.side = this.side);
  this.vertexColors !== THREE.NoColors && (l.vertexColors = this.vertexColors);
  1 > this.opacity && (l.opacity = this.opacity);
  !0 === this.transparent && (l.transparent = this.transparent);
  0 < this.alphaTest && (l.alphaTest = this.alphaTest);
  !0 === this.premultipliedAlpha && (l.premultipliedAlpha = this.premultipliedAlpha);
  !0 === this.wireframe && (l.wireframe = this.wireframe);
  1 < this.wireframeLinewidth && (l.wireframeLinewidth = this.wireframeLinewidth);
  "round" !== this.wireframeLinecap && (l.wireframeLinecap = this.wireframeLinecap);
  "round" !== this.wireframeLinejoin && (l.wireframeLinejoin = this.wireframeLinejoin);
  l.morphTargets = this.morphTargets;
  void 0 !== this.morphNormals && (l.morphNormals = this.morphNormals);
  if (void 0 === a) {
    var b = h(a.textures);
    a = h(a.images);
    0 < b.length && (l.textures = b);
    0 < a.length && (l.images = a);
  }
  return l;
};
THREE.MultiMaterial.prototype.name = "material";
THREE.MultiMaterial.prototype.dispose = function() {
  for (var a in this.materials) {
    this.materials[a].dispose();
  }
};
function Key() {
  this.justReleased = this.justPressed = this.pressed = !1;
}
Key.DOWN = -1;
Key.UP = 1;
Key.RESET = 0;
Key.prototype.update = function(a) {
  this.justReleased = this.justPressed = !1;
  a === Key.DOWN ? (!1 === this.pressed && (this.justPressed = !0), this.pressed = !0) : a === Key.UP ? (this.pressed && (this.justReleased = !0), this.pressed = !1) : a === Key.RESET && (this.justPressed = this.justReleased = !1);
};
Key.prototype.set = function(a, h, l) {
  this.justPressed = a;
  this.pressed = h;
  this.justReleased = l;
};
Key.prototype.reset = function() {
  this.justReleased = this.pressed = this.justPressed = !1;
};
function Keyboard() {
  this.keys = [];
  this.actions = [];
  for (var a = 0;256 > a;a++) {
    this.keys.push(new Key);
  }
  this.events = [];
  var h = this.actions;
  this.events.push([window, "keydown", function(a) {
    h.push(a.keyCode);
    h.push(Key.DOWN);
  }]);
  this.events.push([window, "keyup", function(a) {
    h.push(a.keyCode);
    h.push(Key.UP);
  }]);
  for (a = 0;a < this.events.length;a++) {
    var l = this.events[a];
    l[0].addEventListener(l[1], l[2]);
  }
}
Keyboard.prototype = Keyboard;
Keyboard.update = function() {
  for (var a = 0;this.actions.length > a;) {
    var h = this.actions.shift(), l = this.actions.shift();
    this.keys[h].update(l);
    if (this.keys[h].justReleased || this.keys[h].justPressed) {
      this.actions.push(h), this.actions.push(Key.RESET), a += 2;
    }
  }
};
Keyboard.reset = function() {
  this.actions = [];
  for (var a = 0;a < this.keys.length;a++) {
    this.keys[a].reset();
  }
};
Keyboard.keyPressed = function(a) {
  return this.keys[a].pressed;
};
Keyboard.keyJustPressed = function(a) {
  return this.keys[a].justPressed;
};
Keyboard.keyJustReleased = function(a) {
  return this.keys[a].justReleased;
};
Keyboard.dispose = function() {
  for (var a = 0;a < this.events.length;a++) {
    var h = this.events[a];
    h[0].removeEventListener(h[1], h[2]);
  }
};
Keyboard.TAB = 9;
Keyboard.ENTER = 13;
Keyboard.SHIFT = 16;
Keyboard.CTRL = 17;
Keyboard.ALT = 18;
Keyboard.CAPS_LOCK = 20;
Keyboard.ESC = 27;
Keyboard.SPACEBAR = 32;
Keyboard.PAGE_UP = 33;
Keyboard.PAGE_DOWN = 34;
Keyboard.END = 35;
Keyboard.HOME = 36;
Keyboard.INSERT = 45;
Keyboard.DEL = 46;
Keyboard.LEFT = 37;
Keyboard.RIGHT = 39;
Keyboard.UP = 38;
Keyboard.DOWN = 40;
Keyboard.NUM0 = 48;
Keyboard.NUM1 = 49;
Keyboard.NUM2 = 50;
Keyboard.NUM3 = 51;
Keyboard.NUM4 = 52;
Keyboard.NUM5 = 53;
Keyboard.NUM6 = 54;
Keyboard.NUM7 = 55;
Keyboard.NUM8 = 56;
Keyboard.NUM9 = 57;
Keyboard.A = 65;
Keyboard.B = 66;
Keyboard.C = 67;
Keyboard.D = 68;
Keyboard.E = 69;
Keyboard.F = 70;
Keyboard.G = 71;
Keyboard.H = 72;
Keyboard.I = 73;
Keyboard.J = 74;
Keyboard.K = 75;
Keyboard.L = 76;
Keyboard.M = 77;
Keyboard.N = 78;
Keyboard.O = 79;
Keyboard.P = 80;
Keyboard.Q = 81;
Keyboard.R = 82;
Keyboard.S = 83;
Keyboard.T = 84;
Keyboard.U = 85;
Keyboard.V = 86;
Keyboard.W = 87;
Keyboard.X = 88;
Keyboard.Y = 89;
Keyboard.Z = 90;
Keyboard.F1 = 112;
Keyboard.F2 = 113;
Keyboard.F3 = 114;
Keyboard.F4 = 115;
Keyboard.F5 = 116;
Keyboard.F6 = 117;
Keyboard.F7 = 118;
Keyboard.F8 = 119;
Keyboard.F9 = 120;
Keyboard.F10 = 121;
Keyboard.F11 = 122;
Keyboard.F12 = 123;
function Mouse() {
  this._keys = [];
  this._position = new Vector2(0, 0);
  this._positionUpdated = !1;
  this._delta = new Vector2(0, 0);
  this._wheel = 0;
  this._doubleClicked = this._wheelUpdated = !1;
  this.keys = [];
  this.position = new Vector2(0, 0);
  this.delta = new Vector2(0, 0);
  this.wheel = 0;
  this.doubleClicked = !1;
  this.canvas = null;
  this.events = [];
  for (var a = 0;3 > a;a++) {
    this._keys.push(new Key), this.keys.push(new Key);
  }
  var h = this;
  void 0 !== window.onmousewheel ? this.events.push([window, "mousewheel", function(a) {
    h._wheel = a.deltaY;
    h._wheelUpdated = !0;
  }]) : void 0 !== window.addEventListener ? this.events.push([window, "DOMMouseScroll", function(a) {
    h._wheel = 30 * a.detail;
    h._wheelUpdated = !0;
  }]) : this.events.push([window, "wheel", function(a) {
    h._wheel = a.deltaY;
    h._wheelUpdated = !0;
  }]);
  if ("ontouchstart" in window || 0 < navigator.msMaxTouchPoints) {
    var l = new Vector2(0, 0);
    this.events.push([window, "touchstart", function(a) {
      a = a.touches[0];
      l.set(a.clientX, a.clientY);
      h.updateKey(Mouse.LEFT, Key.DOWN);
    }]);
    this.events.push([window, "touchend", function(a) {
      h.updateKey(Mouse.LEFT, Key.UP);
    }]);
    this.events.push([window, "touchmove", function(a) {
      a = a.touches[0];
      if (null !== h.canvas) {
        var b = h.canvas.getBoundingClientRect();
        h.updatePosition(a.clientX - b.left, a.clientY - b.top, a.clientX - l.x, a.clientY - l.y);
      } else {
        h.updatePosition(a.clientX, a.clientY, a.clientX - l.x, a.clientY - l.y);
      }
      l.set(a.clientX, a.clientY);
    }]);
  } else {
    this.events.push([window, "mousemove", function(a) {
      if (null !== h.canvas) {
        var b = h.canvas.getBoundingClientRect();
        h.updatePosition(a.clientX - b.left, a.clientY - b.top, a.movementX, a.movementY);
      } else {
        h.updatePosition(a.clientX, a.clientY, a.movementX, a.movementY);
      }
    }]), this.events.push([window, "mousedown", function(a) {
      h.updateKey(a.which - 1, Key.DOWN);
    }]), this.events.push([window, "mouseup", function(a) {
      h.updateKey(a.which - 1, Key.UP);
    }]);
  }
  this.events.push([window, "dblclick", function(a) {
    h._doubleClicked = !0;
  }]);
  for (a = 0;a < this.events.length;a++) {
    var b = this.events[a];
    b[0].addEventListener(b[1], b[2]);
  }
}
Mouse.prototype = Mouse;
Mouse.LEFT = 0;
Mouse.MIDDLE = 1;
Mouse.RIGHT = 2;
Mouse.setCanvas = function(a) {
  this.canvas = a;
  a.mouseInside = !1;
  a.addEventListener("mouseenter", function() {
    this.mouseInside = !0;
  });
  a.addEventListener("mouseleave", function() {
    this.mouseInside = !1;
  });
};
Mouse.insideCanvas = function() {
  return null === this.canvas ? !1 : this.canvas.mouseInside;
};
Mouse.setLock = function(a) {
  null !== this.canvas && (a ? this.canvas.requestPointerLock ? this.canvas.requestPointerLock() : this.canvas.mozRequestPointerLock ? this.canvas.mozRequestPointerLock() : this.canvas.webkitRequestPointerLock && this.canvas.webkitRequestPointerLock() : document.exitPointerLock ? document.exitPointerLock() : document.mozExitPointerLock ? document.mozExitPointerLock() : document.webkitExitPointerLock && document.webkitExitPointerLock());
};
Mouse.buttonPressed = function(a) {
  return this.keys[a].pressed;
};
Mouse.buttonDoubleClicked = function() {
  return this.doubleClicked;
};
Mouse.buttonJustPressed = function(a) {
  return this.keys[a].justPressed;
};
Mouse.buttonJustReleased = function(a) {
  return this.keys[a].justReleased;
};
Mouse.updatePosition = function(a, h, l, b) {
  this._position.set(a, h);
  this._delta.x += l;
  this._delta.y += b;
  this._positionUpdated = !0;
};
Mouse.updateKey = function(a, h) {
  -1 < a && this._keys[a].update(h);
};
Mouse.update = function() {
  for (var a = 0;a < this._keys.length;a++) {
    this._keys[a].justPressed && this.keys[a].justPressed && (this._keys[a].justPressed = !1), this._keys[a].justReleased && this.keys[a].justReleased && (this._keys[a].justReleased = !1), this.keys[a].set(this._keys[a].justPressed, this._keys[a].pressed, this._keys[a].justReleased);
  }
  this._wheelUpdated ? (this.wheel = this._wheel, this._wheelUpdated = !1) : this.wheel = 0;
  this._doubleClicked ? (this.doubleClicked = !0, this._doubleClicked = !1) : this.doubleClicked = !1;
  this._positionUpdated ? (this.delta.x = this._delta.x, this.delta.y = this._delta.y, this._delta.set(0, 0), this.position.x = this._position.x, this.position.y = this._position.y, this._positionUpdated = !1) : (this.delta.x = 0, this.delta.y = 0);
};
Mouse.dispose = function() {
  for (var a = 0;a < this.events.length;a++) {
    var h = this.events[a];
    h[0].removeEventListener(h[1], h[2]);
  }
};
function VRControls(a, h) {
  function l(a) {
    for (var f = 0;f < a.length;f++) {
      if ("VRDisplay" in window && a[f] instanceof VRDisplay || "PositionSensorVRDevice" in window && a[f] instanceof PositionSensorVRDevice) {
        b.vrInput = a[f];
        break;
      }
    }
    b.vrInput || h && h("VR input not available");
  }
  this.vrInput = null;
  this.scale = 1;
  this.standing = !1;
  this.userHeight = 1.6;
  this.object = null;
  void 0 !== a && (this.object = a);
  this.position = new THREE.Vector3;
  this.quaternion = new THREE.Quaternion;
  var b = this;
  void 0 !== navigator.getVRDisplays && navigator.getVRDisplays().then(l);
}
VRControls.prototype.update = function() {
  if (null !== this.vrInput) {
    var a = this.vrInput.getPose();
    null !== a.orientation && this.quaternion.fromArray(a.orientation);
    null !== a.position ? this.position.fromArray(a.position) : this.position.set(0, 0, 0);
    this.standing && (this.position.y += this.userHeight);
    this.position.multiplyScalar(this.scale);
    null !== this.object && (this.object.position.copy(this.position), this.object.quaternion.copy(this.quaternion));
  }
};
VRControls.prototype.dispose = function() {
  this.vrInput = null;
};
VRControls.prototype.resetPose = function() {
  null !== this.vrInput && this.vrInput.resetPose();
};
VRControls.prototype.attachObject = function(a) {
  this.object = a;
};
function Resource() {
  this.name = "";
  this.uuid = THREE.Math.generateUUID();
  this.encoding = this.format = this.type = "";
  this.data = null;
}
Resource.prototype.toJSON = function(a) {
};
function Font(a) {
  this.name = "font";
  this.uuid = THREE.Math.generateUUID();
  this.type = "Font";
  this.encoding = this.format = "";
  this.font = this.data = null;
  if (void 0 !== a) {
    if ("object" === typeof a) {
      this.font = this.data = a, this.name = a.original_font_information.full_name || "font", this.encoding = this.format = "json";
    } else {
      if (this.encoding = a.split(".").pop().toLowerCase(), "json" === this.encoding) {
        this.font = this.data = JSON.parse(FileSystem.readFile(a)), this.name = this.data.original_font_information.full_name || FileSystem.getFileName(a), this.format = "json";
      } else {
        if ("ttf" === this.encoding || "otf" === this.encoding || "ttc" === this.encoding || "otc" === this.encoding) {
          this.data = FileSystem.readFileArrayBuffer(a), this.font = (new TTFLoader).parse(this.data), this.name = FileSystem.getFileName(a), this.format = "arraybuffer";
        }
      }
    }
  }
}
Font.prototype.isFont = !0;
Font.prototype.generateShapes = function(a, h, l) {
  void 0 === h && (h = 100);
  void 0 === l && (l = 10);
  var b = this.font;
  a = String(a).split("");
  var f = h / b.resolution, k = (b.boundingBox.yMax - b.boundingBox.yMin) * f, c = 0, g = 0;
  h = [];
  for (var e = 0;e < a.length;e++) {
    var p = a[e];
    if ("\n" === p) {
      g -= k, c = 0;
    } else {
      var r;
      var w, n, t, v, y, x, q, u;
      r = f;
      var B = c, C = g;
      if (p = b.glyphs[p] || b.glyphs["?"]) {
        var D = new THREE.ShapePath, F = [], E = THREE.ShapeUtils.b2, z = THREE.ShapeUtils.b3;
        if (p.o) {
          for (var I = p._cachedOutline || (p._cachedOutline = p.o.split(" ")), J = 0, R = I.length;J < R;) {
            if (v = I[J++], "m" === v && (t = I[J++] * r + B, n = I[J++] * r + C, D.moveTo(t, n)), "l" === v) {
              t = I[J++] * r + B, n = I[J++] * r + C, D.lineTo(t, n);
            } else {
              if ("q" === v) {
                if (u = I[J++] * r + B, q = I[J++] * r + C, y = I[J++] * r + B, v = I[J++] * r + C, D.quadraticCurveTo(y, v, u, q), w = F[F.length - 1]) {
                  x = w.x;
                  w = w.y;
                  for (var L = 1;L <= l;L++) {
                    var M = L / l;
                    E(M, x, y, u);
                    E(M, w, v, q);
                  }
                }
              } else {
                if ("b" === v && (u = I[J++] * r + B, q = I[J++] * r + C, y = I[J++] * r + B, v = I[J++] * r + C, t = I[J++] * r + B, n = I[J++] * r + C, D.bezierCurveTo(y, v, t, n, u, q), w = F[F.length - 1])) {
                  for (x = w.x, w = w.y, L = 1;L <= l;L++) {
                    M = L / l, z(M, x, y, t, u), z(M, w, v, n, q);
                  }
                }
              }
            }
          }
        }
        r = {width:p.ha * r, path:D};
      } else {
        r = void 0;
      }
      c += r.width;
      h.push(r.path);
    }
  }
  l = [];
  for (b = 0;b < h.length;b++) {
    Array.prototype.push.apply(l, h[b].toShapes());
  }
  return l;
};
Font.prototype.toJSON = function(a) {
  if (void 0 !== a.fonts[this.uuid]) {
    return a.fonts[this.uuid];
  }
  var h = {};
  h.name = this.name;
  h.uuid = this.uuid;
  h.type = this.type;
  h.encoding = this.encoding;
  "arraybuffer" === this.format ? (h.data = Base64Utils.fromArraybuffer(this.data), h.format = "base64") : "json" === this.format && (h.data = this.data, h.format = this.format);
  return a.fonts[this.uuid] = h;
};
function Video(a) {
  this.name = "video";
  this.uuid = THREE.Math.generateUUID();
  this.type = "Video";
  this.encoding = this.format = "";
  this.data = null;
  void 0 !== a && (this.encoding = a.split(".").pop().toLowerCase(), this.data = "data:video/" + this.encoding + ";base64," + FileSystem.readFileBase64(a), this.format = "base64");
}
Video.prototype.toJSON = function(a) {
  if (void 0 !== a.videos[this.uuid]) {
    return a.videos[this.uuid];
  }
  var h = {};
  h.name = this.name;
  h.uuid = this.uuid;
  h.type = this.type;
  h.encoding = this.encoding;
  h.format = this.format;
  h.data = this.data;
  return a.videos[this.uuid] = h;
};
function Audio(a) {
  this.name = "audio";
  this.uuid = THREE.Math.generateUUID();
  this.type = "Audio";
  this.encoding = this.format = "";
  this.data = null;
  void 0 !== a && (this.data = FileSystem.readFileArrayBuffer(a), this.encoding = a.split(".").pop().toLowerCase(), this.format = "arraybuffer");
}
Audio.prototype.toJSON = function(a) {
  if (void 0 !== a.audio[this.uuid]) {
    return a.audio[this.uuid];
  }
  var h = {};
  h.name = this.name;
  h.uuid = this.uuid;
  h.type = this.type;
  h.encoding = this.encoding;
  h.data = Base64Utils.fromArraybuffer(this.data);
  h.format = "base64";
  return a.audio[this.uuid] = h;
};
function Image(a) {
  this.name = "image";
  this.uuid = THREE.Math.generateUUID();
  this.type = "Image";
  this.encoding = this.format = "";
  this.data = null;
  void 0 !== a && (this.encoding = a.split(".").pop().toLowerCase(), "gif" === this.encoding ? (this.data = "data:image/" + this.encoding + ";base64," + FileSystem.readFileBase64(a), this.format = "base64") : "tga" === this.encoding ? (a = (new THREE.TGALoader).parse(FileSystem.readFileArrayBuffer(a)), this.encoding = "jpeg", this.format = "base64", this.data = a.toDataURL("image/jpeg", .9)) : (this.format = "url", this.data = a));
}
Image.prototype.encodeData = function() {
  if ("url" === this.format) {
    var a = document.createElement("img");
    a.src = this.data;
    var h = document.createElement("canvas");
    h.width = a.width;
    h.height = a.height;
    var l = h.getContext("2d");
    l.drawImage(a, 0, 0, a.width, a.height);
    for (var b = !1, a = l.getImageData(0, 0, a.width, a.height).data, l = 3;l < a.length;l += 4) {
      if (255 !== a[l]) {
        b = !0;
        break;
      }
    }
    b ? (this.format = "base64", this.encoding = "png", this.data = h.toDataURL("image/png")) : (this.format = "base64", this.encoding = "jpeg", this.data = h.toDataURL("image/jpeg", .9));
  }
};
Image.prototype.toJSON = function(a) {
  if (void 0 !== a.images[this.uuid]) {
    return a.images[this.uuid];
  }
  this.encodeData();
  var h = {};
  h.name = this.name;
  h.uuid = this.uuid;
  h.type = this.type;
  h.encoding = this.encoding;
  h.format = this.format;
  h.data = this.data;
  return a.images[this.uuid] = h;
};
function ResourceManager() {
  this.images = [];
  this.videos = [];
  this.audio = [];
  this.fonts = [];
  this.materials = [];
  this.textures = [];
  this.geometries = [];
}
ResourceManager.prototype.getMaterialByName = function(a) {
  for (var h in this.materials) {
    if (this.materials[h].name === a) {
      return this.materials[h];
    }
  }
  return null;
};
ResourceManager.prototype.addMaterial = function(a) {
  a instanceof THREE.Material && (this.materials[a.uuid] = a);
};
ResourceManager.prototype.removeMaterial = function(a, h, l) {
  void 0 === h && (h = new THREE.MeshBasicMaterial);
  void 0 === l && (l = new THREE.SpriteMaterial);
  a instanceof THREE.Material && (delete this.materials[a.uuid], this.traverse(function(b) {
    void 0 !== b.material && b.material.uuid === a.uuid && (b.material = b instanceof THREE.Sprite ? l : h);
  }));
};
ResourceManager.prototype.getTextureByName = function(a) {
  for (var h in this.textures) {
    if (this.textures[h].name === a) {
      return this.textures[h];
    }
  }
  return null;
};
ResourceManager.prototype.addTexture = function(a) {
  this.textures[a.uuid] = a;
};
ResourceManager.prototype.removeTexture = function(a, h) {
  void 0 === h && (h = new THREE.Texture);
  a instanceof THREE.Texture && (delete this.textures[a.uuid], this.traverse(function(l) {
    void 0 !== l.material ? (l = l.material, null != l.map && l.map.uuid === a.uuid ? (l.map = h, l.needsUpdate = !0) : null != l.bumpMap && l.bumpMap.uuid === a.uuid ? (l.bumpMap = h, l.needsUpdate = !0) : null != l.normalMap && l.normalMap.uuid === a.uuid ? (l.normalMap = h, l.needsUpdate = !0) : null != l.displacementMap && l.displacementMap.uuid === a.uuid ? (l.displacementMap = h, l.needsUpdate = !0) : null != l.specularMap && l.specularMap.uuid === a.uuid ? (l.specularMap = h, l.needsUpdate = 
    !0) : null != l.emissiveMap && l.emissiveMap.uuid === a.uuid ? (l.emissiveMap = h, l.needsUpdate = !0) : null != l.alphaMap && l.alphaMap.uuid === a.uuid ? (l.alphaMap = h, l.needsUpdate = !0) : null != l.roughnessMap && l.roughnessMap.uuid === a.uuid ? (l.roughnessMap = h, l.needsUpdate = !0) : null != l.metalnessMap && l.metalnessMap.uuid === a.uuid && (l.metalnessMap = h, l.needsUpdate = !0)) : l instanceof ParticleEmitter && l.group.texture.uuid === a.uuid && (l.group.texture = h);
  }));
};
ResourceManager.prototype.getFontByName = function(a) {
  for (var h in this.fonts) {
    if (this.fonts[h].name === a) {
      return this.fonts[h];
    }
  }
  return null;
};
ResourceManager.prototype.addFont = function(a) {
  a instanceof Font && (this.fonts[a.uuid] = a);
};
ResourceManager.prototype.removeFont = function(a, h) {
  void 0 === h && (h = new Font);
  a instanceof Font && (delete this.fonts[a.uuid], this.traverse(function(l) {
    void 0 !== l.font && l.font.uuid === a.uuid && l.setFont(h);
  }));
};
ResourceManager.prototype.getAudioByName = function(a) {
  for (var h in this.audio) {
    if (this.audio[h].name === a) {
      return this.audio[h];
    }
  }
  return null;
};
ResourceManager.prototype.addAudio = function(a) {
  a instanceof Audio && (this.audio[a.uuid] = a);
};
ResourceManager.prototype.removeAudio = function(a, h) {
  void 0 === h && (h = new Audio);
  a instanceof Audio && (delete this.audio[a.uuid], this.traverse(function(l) {
    void 0 !== l.audio && l.audio.uuid === a.uuid && l.setFont(h);
  }));
};
function Texture(a, h, l, b, f, k, c, g, e, p) {
  this.img = "string" === typeof a ? new Image(a) : void 0 === a ? new Image : a;
  THREE.Texture.call(this, document.createElement("img"), h, l, b, f, k, c, g, e, p);
  a = "png" === this.img.encoding || "gif" === this.img.encoding;
  var r = this;
  this.name = "texture";
  this.category = "Image";
  this.disposed = !1;
  this.format = a ? THREE.RGBAFormat : THREE.RGBFormat;
  this.image.src = this.img.data;
  this.image.onload = function() {
    r.needsUpdate = !0;
  };
  if ("gif" === this.img.encoding) {
    var w = function() {
      r.disposed || (r.needsUpdate = !0, requestAnimationFrame(w));
    };
    w();
  }
}
Texture.prototype = Object.create(THREE.Texture.prototype);
Texture.prototype.dispose = function() {
  THREE.Texture.prototype.dispose.call(this);
  this.disposed = !0;
};
Texture.prototype.toJSON = function(a) {
  var h = THREE.Texture.prototype.toJSON.call(this, a);
  a = this.img.toJSON(a);
  h.image = a.uuid;
  return h;
};
function CanvasTexture(a, h, l, b, f, k, c, g, e, p, r) {
  THREE.Texture.call(this, document.createElement("canvas"), l, b, f, k, c, g, e, p, r);
  this.name = "canvas";
  this.category = "Canvas";
  this.width = void 0 !== a ? a : 512;
  this.height = void 0 !== h ? h : 512;
  this.context = this.image.getContext("2d");
  this.updateSize();
  this.needsUpdate = !0;
}
CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
CanvasTexture.prototype.updateSize = function() {
  this.image.width = this.width;
  this.image.height = this.height;
  this.context.fillStyle = "#000000";
  this.context.fillRect(0, 0, this.width, this.height);
  this.context.font = "Normal 55px Arial";
  this.context.textAlign = "center";
  this.context.fillStyle = "#FF0000";
  this.context.fillText("Canvas Texture", this.width / 2, this.height / 2);
};
CanvasTexture.prototype.clear = function(a) {
  this.context.fillStyle = a;
  this.context.fillRect(0, 0, this.width, this.height);
};
CanvasTexture.prototype.toJSON = function(a) {
  a = THREE.Texture.prototype.toJSON.call(this, a);
  a.width = this.width;
  a.height = this.height;
  return a;
};
function VideoTexture(a, h, l, b, f, k) {
  function c() {
    a.readyState >= a.HAVE_CURRENT_DATA && (g.needsUpdate = !0);
    g.disposed || requestAnimationFrame(c);
  }
  "string" === typeof a ? this.video = new Video(a) : a instanceof Video && (this.video = a);
  THREE.Texture.call(this, document.createElement("video"), h, l, b, THREE.LinearFilter, THREE.LinearFilter, THREE.RGBFormat, f, k);
  this.disposed = this.generateMipmaps = !1;
  this.name = "video";
  this.category = "Video";
  this.loop = this.autoplay = !0;
  this.volume = this.playbackRate = 1;
  this.image.src = this.video.data;
  this.image.autoplay = this.autoplay;
  this.image.playbackRate = this.playbackRate;
  this.image.loop = this.loop;
  this.image.volume = this.volume;
  var g = this;
  a = this.image;
  c();
}
VideoTexture.prototype = Object.create(THREE.Texture.prototype);
VideoTexture.prototype.setTime = function(a) {
  this.image.currentTime = a;
};
VideoTexture.prototype.setLoop = function(a) {
  this.loop = a;
  this.image.loop = a;
};
VideoTexture.prototype.setVolume = function(a) {
  this.volume = 0 <= a && 1 >= a ? a : 0 <= a ? 1 : 0;
  this.image.volume = this.volume;
};
VideoTexture.prototype.setPlaybackRate = function(a) {
  this.playbackRate = a;
  this.image.playbackRate = a;
};
VideoTexture.prototype.pause = function() {
  this.image.paused || this.image.pause();
};
VideoTexture.prototype.play = function() {
  this.image.paused && this.image.play();
};
VideoTexture.prototype.dispose = function() {
  THREE.Texture.prototype.dispose.call(this);
  this.disposed = !0;
  this.image.paused || this.image.pause();
};
VideoTexture.prototype.toJSON = function(a) {
  var h = THREE.Texture.prototype.toJSON.call(this, a);
  a = this.video.toJSON(a);
  h.video = a.uuid;
  h.loop = this.loop;
  h.autoplay = this.autoplay;
  h.playbackRate = this.playbackRate;
  h.volume = this.volume;
  return h;
};
function WebcamTexture(a, h, l, b, f) {
  function k() {
    c.readyState >= c.HAVE_CURRENT_DATA && (g.needsUpdate = !0);
    g.disposed || requestAnimationFrame(k);
  }
  var c = document.createElement("video");
  c.autoplay = !0;
  c.loop = !0;
  navigator.webkitGetUserMedia ? navigator.webkitGetUserMedia({video:!0}, function(a) {
    c.src = URL.createObjectURL(a);
  }, function(a) {
    console.warn("nunuStudio: No webcam available");
  }) : navigator.mediaDevices.getUserMedia && navigator.mediaDevices.getUserMedia({video:!0}).then(function(a) {
    c.src = URL.createObjectURL(a);
  }).catch(function(a) {
    console.warn("nunuStudio: No webcam available");
  });
  THREE.Texture.call(this, c, a, h, l, THREE.LinearFilter, THREE.LinearFilter, THREE.RGBFormat, b, f);
  this.disposed = this.generateMipmaps = !1;
  this.name = "webcam";
  this.category = "Webcam";
  var g = this;
  k();
}
WebcamTexture.prototype = Object.create(THREE.Texture.prototype);
WebcamTexture.prototype.dispose = function() {
  THREE.Texture.prototype.dispose.call(this);
  this.disposed = !0;
  this.image.paused || this.image.pause();
};
function CubeTexture(a, h, l, b, f, k, c, g, e, p) {
  void 0 === h && (h = THREE.CubeReflectionMapping);
  for (var r = [], w = 0;6 > w;w++) {
    r.push(document.createElement("canvas"));
  }
  THREE.Texture.call(this, r, h, l, b, f, k, c, g, e, p);
  this.images = void 0 !== a ? a : [];
  this.size = 512;
  this.flipY = !1;
  this.updateImages();
  this.name = "cubetexture";
  this.category = "Cube";
}
CubeTexture.prototype = Object.create(THREE.Texture.prototype);
CubeTexture.prototype.isCubeTexture = !0;
CubeTexture.RIGHT = 0;
CubeTexture.LEFT = 1;
CubeTexture.TOP = 2;
CubeTexture.BOTTOM = 3;
CubeTexture.FRONT = 4;
CubeTexture.BACK = 5;
CubeTexture.prototype.updateImages = function() {
  for (var a = this, h = 0;h < this.images.length;h++) {
    "string" === typeof this.images[h] && (this.images[h] = new Image(images[h]));
    var l = document.createElement("img");
    l.index = h;
    l.src = this.images[h].data;
    l.onload = function() {
      a.image[this.index].width = a.size;
      a.image[this.index].height = a.size;
      a.image[this.index].getContext("2d").drawImage(this, 0, 0, a.size, a.size);
      a.needsUpdate = !0;
    };
  }
};
CubeTexture.prototype.toJSON = function(a) {
  var h = THREE.Texture.prototype.toJSON.call(this, a);
  h.images = [];
  for (var l = 0;l < this.images.length;l++) {
    var b = this.images[l].toJSON(a);
    h.images.push(b.uuid);
  }
  return h;
};
function FontLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}
FontLoader.fileIsFont = function(a) {
  return void 0 !== a ? (a = a.toLocaleLowerCase(), a.endsWith("ttf") || a.endsWith("otf") || a.endsWith("ttc") || a.endsWith("otc")) : !1;
};
FontLoader.prototype.load = function(a, h, l, b) {
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    h(new Font(JSON.parse(a)));
  }, l, b);
};
FontLoader.prototype.parse = function(a) {
  if (void 0 !== a.data) {
    var h = new Font;
    h.name = a.name;
    h.uuid = a.uuid;
    h.encoding = a.encoding;
    "base64" === a.format ? (h.format = "arraybuffer", h.data = ArraybufferUtils.fromBase64(a.data), h.font = (new TTFLoader).parse(h.data)) : (h.format = a.format, h.data = a.data, h.font = a.data);
    return h;
  }
  return new Font(a);
};
function ImageLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}
ImageLoader.prototype.loadJSON = function(a, h, l, b) {
  var f = this;
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    f.parse(JSON.parse(a), h);
  }, l, b);
};
ImageLoader.prototype.parse = function(a, h) {
  h = new Image;
  h.name = a.name;
  h.uuid = a.uuid;
  h.format = a.format;
  h.encoding = a.encoding;
  h.data = a.data;
  return h;
};
function VideoLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}
VideoLoader.prototype.load = function(a, h, l, b) {
  var f = this;
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    f.parse(JSON.parse(a), h);
  }, l, b);
};
VideoLoader.prototype.parse = function(a, h) {
  h = new Video;
  h.name = a.name;
  h.uuid = a.uuid;
  h.format = a.format;
  h.encoding = a.encoding;
  h.data = a.data;
  return h;
};
function AudioLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}
AudioLoader.prototype.load = function(a, h, l, b) {
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    self.parse(JSON.parse(a), h);
  }, l, b);
};
AudioLoader.prototype.parse = function(a) {
  var h = new Audio;
  h.name = a.name;
  h.uuid = a.uuid;
  h.encoding = a.encoding;
  h.format = "arraybuffer";
  h.data = ArraybufferUtils.fromBase64(a.data);
  return h;
};
function MaterialLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.textures = {};
}
MaterialLoader.prototype.load = function(a, h, l, b) {
  var f = this;
  (new FileLoader(f.manager)).load(a, function(a) {
    h(f.parse(JSON.parse(a)));
  }, l, b);
};
MaterialLoader.prototype.setTextures = function(a) {
  this.textures = a;
};
MaterialLoader.prototype.parse = function(a) {
  function h(a) {
    void 0 === l[a] && console.warn("THREE.MaterialLoader: Undefined texture", a);
    return l[a];
  }
  var l = this.textures, b = new window[a.type];
  void 0 !== a.uuid && (b.uuid = a.uuid);
  void 0 !== a.name && (b.name = a.name);
  void 0 !== a.color && b.color.setHex(a.color);
  void 0 !== a.roughness && (b.roughness = a.roughness);
  void 0 !== a.metalness && (b.metalness = a.metalness);
  void 0 !== a.emissive && b.emissive.setHex(a.emissive);
  void 0 !== a.specular && b.specular.setHex(a.specular);
  void 0 !== a.shininess && (b.shininess = a.shininess);
  void 0 !== a.clearCoat && (b.clearCoat = a.clearCoat);
  void 0 !== a.clearCoatRoughness && (b.clearCoatRoughness = a.clearCoatRoughness);
  void 0 !== a.uniforms && (b.uniforms = a.uniforms);
  void 0 !== a.vertexShader && (b.vertexShader = a.vertexShader);
  void 0 !== a.fragmentShader && (b.fragmentShader = a.fragmentShader);
  void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors);
  void 0 !== a.fog && (b.fog = a.fog);
  void 0 !== a.shading && (b.shading = a.shading);
  void 0 !== a.blending && (b.blending = a.blending);
  void 0 !== a.side && (b.side = a.side);
  void 0 !== a.opacity && (b.opacity = a.opacity);
  void 0 !== a.transparent && (b.transparent = a.transparent);
  void 0 !== a.alphaTest && (b.alphaTest = a.alphaTest);
  void 0 !== a.depthTest && (b.depthTest = a.depthTest);
  void 0 !== a.depthWrite && (b.depthWrite = a.depthWrite);
  void 0 !== a.colorWrite && (b.colorWrite = a.colorWrite);
  void 0 !== a.wireframe && (b.wireframe = a.wireframe);
  void 0 !== a.wireframeLinewidth && (b.wireframeLinewidth = a.wireframeLinewidth);
  void 0 !== a.wireframeLinecap && (b.wireframeLinecap = a.wireframeLinecap);
  void 0 !== a.wireframeLinejoin && (b.wireframeLinejoin = a.wireframeLinejoin);
  void 0 !== a.morphTargets && (b.morphTargets = a.morphTargets);
  void 0 !== a.morphNormals && (b.morphNormals = a.morphNormals);
  void 0 !== a.size && (b.size = a.size);
  void 0 !== a.sizeAttenuation && (b.sizeAttenuation = a.sizeAttenuation);
  void 0 !== a.map && (b.map = h(a.map));
  void 0 !== a.alphaMap && (b.alphaMap = h(a.alphaMap), b.transparent = !0);
  void 0 !== a.bumpMap && (b.bumpMap = h(a.bumpMap));
  void 0 !== a.bumpScale && (b.bumpScale = a.bumpScale);
  void 0 !== a.normalMap && (b.normalMap = h(a.normalMap));
  if (void 0 !== a.normalScale) {
    var f = a.normalScale;
    !1 === Array.isArray(f) && (f = [f, f]);
    b.normalScale = (new Vector2).fromArray(f);
  }
  void 0 !== a.displacementMap && (b.displacementMap = h(a.displacementMap));
  void 0 !== a.displacementScale && (b.displacementScale = a.displacementScale);
  void 0 !== a.displacementBias && (b.displacementBias = a.displacementBias);
  void 0 !== a.roughnessMap && (b.roughnessMap = h(a.roughnessMap));
  void 0 !== a.metalnessMap && (b.metalnessMap = h(a.metalnessMap));
  void 0 !== a.emissiveMap && (b.emissiveMap = h(a.emissiveMap));
  void 0 !== a.emissiveIntensity && (b.emissiveIntensity = a.emissiveIntensity);
  void 0 !== a.specularMap && (b.specularMap = h(a.specularMap));
  void 0 !== a.envMap && (b.envMap = h(a.envMap));
  void 0 !== a.reflectivity && (b.reflectivity = a.reflectivity);
  void 0 !== a.envMapIntensity && (b.envMapIntensity = a.envMapIntensity);
  void 0 !== a.combine && (b.combine = a.combine);
  void 0 !== a.refractionRatio && (b.refractionRatio = a.refractionRatio);
  void 0 !== a.lightMap && (b.lightMap = h(a.lightMap));
  void 0 !== a.lightMapIntensity && (b.lightMapIntensity = a.lightMapIntensity);
  void 0 !== a.aoMap && (b.aoMap = h(a.aoMap));
  void 0 !== a.aoMapIntensity && (b.aoMapIntensity = a.aoMapIntensity);
  void 0 !== a.gradientMap && (b.gradientMap = h(a.gradientMap));
  if (void 0 !== a.materials) {
    for (var f = 0, k = a.materials.length;f < k;f++) {
      b.materials.push(this.parse(a.materials[f]));
    }
  }
  return b;
};
function TextureLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.images = [];
  this.videos = [];
  this.fonts = [];
}
THREE.TextureLoader = TextureLoader;
TextureLoader.prototype.load = function(a, h, l, b) {
  a = new Texture(a);
  void 0 !== h && h(a);
  return a;
};
TextureLoader.prototype.loadJSON = function(a, h, l, b) {
  var f = this;
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    f.parse(JSON.parse(a), h);
  }, l, b);
};
TextureLoader.prototype.parse = function(a, h) {
  var l;
  l = a.category;
  if ("Video" === l) {
    void 0 === a.video && console.warn("TextureLoader: No video specified for", a.uuid), void 0 === this.videos[a.video] && console.warn("TextureLoader: Undefined video", a.video), l = new VideoTexture(this.videos[a.video]), l.loop = a.loop, l.autoplay = a.autoplay, l.playbackRate = a.playbackRate, l.volume = a.volume;
  } else {
    if ("Webcam" === l) {
      l = new WebcamTexture;
    } else {
      if ("Cube" === l) {
        l = [];
        for (var b = 0;b < a.images.length;b++) {
          void 0 === this.images[a.images[b]] && console.warn("nunuStudio: TextureLoader, undefined image", a.images[b]), l.push(this.images[a.images[b]]);
        }
        l = new CubeTexture(l);
      } else {
        "Canvas" === l ? l = new CanvasTexture(a.width, a.height) : (void 0 === a.image && console.warn("nunuStudio: TextureLoader, no image specified for", a.uuid), void 0 === this.images[a.image] && console.warn("nunuStudio: TextureLoader, undefined image", a.image), l = new Texture(this.images[a.image]));
      }
    }
  }
  l.uuid = a.uuid;
  l.name = a.name;
  l.mapping = a.mapping;
  l.offset = new THREE.Vector2(a.offset[0], a.offset[1]);
  l.repeat = new THREE.Vector2(a.repeat[0], a.repeat[1]);
  l.wrapS = a.wrap[0];
  l.wrapT = a.wrap[1];
  l.minFilter = a.minFilter;
  l.magFilter = a.magFilter;
  l.anisotropy = a.anisotropy;
  l.flipY = a.flipY;
  void 0 !== h && h(l);
  return l;
};
TextureLoader.prototype.setImages = function(a) {
  this.images = a;
  return this;
};
TextureLoader.prototype.setVideos = function(a) {
  this.videos = a;
  return this;
};
TextureLoader.prototype.setFonts = function(a) {
  this.fonts = a;
  return this;
};
function ObjectLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.texturePath = "";
}
ObjectLoader.prototype.load = function(a, h, l, b) {
  "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
  var f = this;
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    f.parse(JSON.parse(a), h);
  }, l, b);
};
ObjectLoader.prototype.parse = function(a, h) {
  var l = this.parseGeometries(a.geometries), b = this.parseImages(a.images), f = this.parseVideos(a.videos), k = this.parseAudio(a.audio), c = this.parseFonts(a.fonts), b = this.parseTextures(a.textures, b, f), f = this.parseMaterials(a.materials, b), l = this.parseObject(a.object, l, f, b, k, c);
  a.animations && (l.animations = this.parseAnimations(a.animations));
  void 0 !== a.images && 0 !== a.images.length || void 0 === h || h(l);
  return l;
};
ObjectLoader.prototype.setTexturePath = function(a) {
  this.texturePath = a;
};
ObjectLoader.prototype.setCrossOrigin = function(a) {
  this.crossOrigin = a;
};
ObjectLoader.prototype.parseGeometries = function(a) {
  var h = [];
  if (void 0 !== a) {
    for (var l = new THREE.JSONLoader, b = new THREE.BufferGeometryLoader, f = 0;f < a.length;f++) {
      var k, c = a[f];
      switch(c.type) {
        case "PlaneGeometry":
        case "PlaneBufferGeometry":
          k = new THREE[c.type](c.width, c.height, c.widthSegments, c.heightSegments);
          break;
        case "BoxGeometry":
        case "BoxBufferGeometry":
        case "CubeGeometry":
          k = new THREE[c.type](c.width, c.height, c.depth, c.widthSegments, c.heightSegments, c.depthSegments);
          break;
        case "CircleGeometry":
        case "CircleBufferGeometry":
          k = new THREE[c.type](c.radius, c.segments, c.thetaStart, c.thetaLength);
          break;
        case "CylinderGeometry":
        case "CylinderBufferGeometry":
          k = new THREE[c.type](c.radiusTop, c.radiusBottom, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
          break;
        case "ConeGeometry":
        case "ConeBufferGeometry":
          k = new THREE[c.type](c.radius, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
          break;
        case "SphereGeometry":
        case "SphereBufferGeometry":
          k = new THREE[c.type](c.radius, c.widthSegments, c.heightSegments, c.phiStart, c.phiLength, c.thetaStart, c.thetaLength);
          break;
        case "DodecahedronGeometry":
        case "IcosahedronGeometry":
        case "OctahedronGeometry":
        case "TetrahedronGeometry":
          k = new THREE[c.type](c.radius, c.detail);
          break;
        case "RingGeometry":
        case "RingBufferGeometry":
          k = new THREE[c.type](c.innerRadius, c.outerRadius, c.thetaSegments, c.phiSegments, c.thetaStart, c.thetaLength);
          break;
        case "TorusGeometry":
        case "TorusBufferGeometry":
          k = new THREE[c.type](c.radius, c.tube, c.radialSegments, c.tubularSegments, c.arc);
          break;
        case "TorusKnotGeometry":
        case "TorusKnotBufferGeometry":
          k = new THREE[c.type](c.radius, c.tube, c.tubularSegments, c.radialSegments, c.p, c.q);
          break;
        case "LatheGeometry":
        case "LatheBufferGeometry":
          k = new THREE[c.type](c.points, c.segments, c.phiStart, c.phiLength);
          break;
        case "BufferGeometry":
          k = b.parse(c);
          break;
        case "Geometry":
          k = l.parse(c.data, this.texturePath).geometry;
          break;
        default:
          console.warn("ObjectLoader: Unsupported geometry type " + c.type);
          continue;
      }
      k.uuid = c.uuid;
      k.name = void 0 !== c.name ? c.name : "geometry";
      h[c.uuid] = k;
    }
  }
  return h;
};
ObjectLoader.prototype.parseMaterials = function(a, h) {
  var l = [], b = new MaterialLoader;
  b.setTextures(h);
  if (void 0 !== a) {
    for (h = 0;h < a.length;h++) {
      var f = b.parse(a[h]);
      l[f.uuid] = f;
    }
  }
  return l;
};
ObjectLoader.prototype.parseAnimations = function(a) {
  for (var h = [], l = 0;l < a.length;l++) {
    var b = THREE.AnimationClip.parse(a[l]);
    h.push(b);
  }
  return h;
};
ObjectLoader.prototype.parseImages = function(a) {
  var h = new ImageLoader, l = [];
  if (void 0 !== a) {
    for (var b = 0;b < a.length;b++) {
      l[a[b].uuid] = h.parse(a[b]);
    }
  }
  return l;
};
ObjectLoader.prototype.parseVideos = function(a) {
  var h = new VideoLoader, l = [];
  if (void 0 !== a) {
    for (var b = 0;b < a.length;b++) {
      l[a[b].uuid] = h.parse(a[b]);
    }
  }
  return l;
};
ObjectLoader.prototype.parseAudio = function(a) {
  var h = new AudioLoader, l = [];
  if (void 0 !== a) {
    for (var b = 0;b < a.length;b++) {
      l[a[b].uuid] = h.parse(a[b]);
    }
  }
  return l;
};
ObjectLoader.prototype.parseFonts = function(a) {
  var h = new FontLoader, l = [];
  if (void 0 !== a) {
    for (var b = 0;b < a.length;b++) {
      l[a[b].uuid] = h.parse(a[b]);
    }
  }
  return l;
};
ObjectLoader.prototype.parseTextures = function(a, h, l) {
  var b = new TextureLoader;
  b.setImages(h);
  b.setVideos(l);
  h = [];
  if (void 0 !== a) {
    for (l = 0;l < a.length;l++) {
      var f = b.parse(a[l]);
      h[f.uuid] = f;
    }
  }
  return h;
};
ObjectLoader.prototype.parseObject = function(a, h, l, b, f, k) {
  function c(a) {
    void 0 === b[a] && console.warn("ObjectLoader: Undefined texture", a);
    return b[a];
  }
  function g(a) {
    void 0 === h[a] && console.warn("ObjectLoader: Undefined geometry", a);
    return h[a];
  }
  function e(a) {
    void 0 === l[a] && console.warn("ObjectLoader: Undefined material", a);
    return l[a];
  }
  function p(a) {
    void 0 === k[a] && console.warn("ObjectLoader: Undefined font", a);
    return k[a];
  }
  function r(a) {
    void 0 === f[a] && console.warn("ObjectLoader: Undefined audio", a);
    return f[a];
  }
  var w = new THREE.Matrix4, n;
  switch(a.type) {
    case "SpineAnimation":
      for (var t = 0;t < a.textures.length;t++) {
        a.textures[t].texture = c(a.textures[t].texture);
      }
      n = new SpineAnimation(a.json, a.atlas, "", a.textures);
      break;
    case "Audio":
      n = new AudioEmitter(r(a.audio));
      n.autoplay = a.autoplay;
      n.startTime = a.startTime;
      n.playbackRate = a.playbackRate;
      n.loop = void 0 !== a.source ? a.source.loop : a.loop;
      void 0 !== a.volume && (n.volume = a.volume);
      break;
    case "PositionalAudio":
      n = new PositionalAudio(r(a.audio));
      n.autoplay = a.autoplay;
      n.startTime = a.startTime;
      n.playbackRate = a.playbackRate;
      n.loop = void 0 !== a.source ? a.source.loop : a.loop;
      void 0 !== a.volume && (n.volume = a.volume);
      break;
    case "Physics":
      n = new PhysicsObject;
      n.body.type = a.body.type;
      n.body.mass = a.body.mass;
      n.body.linearDamping = a.body.linearDamping;
      n.body.angularDamping = a.body.angularDamping;
      n.body.allowSleep = a.body.allowSleep;
      n.body.sleepSpeedLimit = a.body.sleepSpeedLimit;
      n.body.sleepTimeLimit = a.body.sleepTimeLimit;
      n.body.collisionFilterGroup = a.body.collisionFilterGroup;
      n.body.collisionFilterMask = a.body.collisionFilterMask;
      n.body.fixedRotation = a.body.fixedRotation;
      for (var v = a.body.shapes, t = 0;t < v.length;t++) {
        var y = v[t];
        y.type === CANNON.Shape.types.SPHERE ? n.body.addShape(new CANNON.Sphere(y.radius)) : y.type === CANNON.Shape.types.BOX ? n.body.addShape(new CANNON.Box(new CANNON.Vec3(y.halfExtents.x, y.halfExtents.y, y.halfExtents.z))) : y.type === CANNON.Shape.types.PARTICLE ? n.body.addShape(new CANNON.Particle) : y.type === CANNON.Shape.types.PLANE ? n.body.addShape(new CANNON.Plane) : y.type === CANNON.Shape.types.CONVEXPOLYHEDRON && n.body.addShape(new CANNON.ConvexPolyhedron(y.vertices, y.faces));
      }
      break;
    case "ParticleEmiter":
      void 0 !== a.group && (n = a.group, n.texture.value = c(n.texture.value), n.textureFrames = THREE.Vector2(n.textureFrames));
      if (void 0 !== a.emitter) {
        for (n = a.emitter, n.position.value = THREE.Vector3.fromJSON(n.position.value), n.position.spread = THREE.Vector3.fromJSON(n.position.spread), n.velocity.value = THREE.Vector3.fromJSON(n.velocity.value), n.velocity.spread = THREE.Vector3.fromJSON(n.velocity.spread), n.acceleration.value = THREE.Vector3.fromJSON(n.acceleration.value), n.acceleration.spread = THREE.Vector3.fromJSON(n.acceleration.spread), t = 0;t < n.color.value.length;t++) {
          n.color.value[t] = new THREE.Color(n.color.value[t]), n.color.spread[t] = THREE.Vector3.fromJSON(n.color.spread[t]);
        }
      }
      n = new ParticleEmitter(a.group, a.emitter);
      break;
    case "Text3D":
      n = new Text3D(a.text, e(a.material), p(a.font), a.height, a.bevel, a.bevelThickness, a.bevelSize, a.size, a.curveSegments);
      break;
    case "Program":
      n = new Program(a.name);
      n.description = a.description;
      n.author = a.author;
      n.version = a.version;
      n.vr = a.vr;
      n.vrScale = a.vrScale;
      void 0 !== a.antialiasing && (n.antialiasing = a.antialiasing, n.shadows = a.shadows, n.shadowsType = a.shadowsType);
      void 0 !== a.lockPointer && (n.lockPointer = a.lockPointer);
      void 0 !== a.defaultScene && (n.defaultScene = a.defaultScene);
      break;
    case "LeapDevice":
      n = new LeapMotion;
      n.mode = a.mode;
      n.useArm = a.useArm;
      void 0 !== a.debugModel && (n.debugModel = a.debugModel);
      void 0 !== a.gesturesEnabled && (n.gesturesEnabled = a.gesturesEnabled);
      void 0 !== a.posesEnabled && (n.posesEnabled = a.posesEnabled);
      break;
    case "Kinect":
      n = new KinectDevice;
      void 0 !== a.debugModel && (n.debugModel = a.debugModel);
      break;
    case "Sky":
      n = new Sky(a.autoUpdate, a.dayTime, a.sunDistance, a.time);
      void 0 !== a.sun && n.sun.shadow.fromJSON(a.sun.shadow);
      if (void 0 !== a.colorTop) {
        for (n.colorTop = [], t = 0;t < a.colorTop.length;t++) {
          n.colorTop.push(new THREE.Color(a.colorTop[t]));
        }
      }
      if (void 0 !== a.colorBottom) {
        for (n.colorBottom = [], t = 0;t < a.colorBottom.length;t++) {
          n.colorBottom.push(new THREE.Color(a.colorBottom[t]));
        }
      }
      void 0 !== a.sunColor && (n.sunColor = a.sunColor);
      void 0 !== a.moonColor && (n.moonColor = a.moonColor);
      break;
    case "Scene":
      n = new Scene;
      void 0 !== a.background && Number.isInteger(a.background) && (n.background = new THREE.Color(a.background));
      void 0 !== a.fog && ("Fog" === a.fog.type ? n.fog = new THREE.Fog(a.fog.color, a.fog.near, a.fog.far) : "FogExp2" === a.fog.type && (n.fog = new THREE.FogExp2(a.fog.color, a.fog.density)));
      void 0 !== a.cameras && (n.cameras = a.cameras);
      void 0 !== a.world && n.world.gravity.set(a.world.gravity.x, a.world.gravity.y, a.world.gravity.z);
      break;
    case "PerspectiveCamera":
      n = new PerspectiveCamera(a.fov, a.aspect, a.near, a.far);
      void 0 !== a.focus && (n.focus = a.focus);
      void 0 !== a.zoom && (n.zoom = a.zoom);
      void 0 !== a.filmGauge && (n.filmGauge = a.filmGauge);
      void 0 !== a.filmOffset && (n.filmOffset = a.filmOffset);
      void 0 !== a.view && (n.view = Object.assign({}, a.view));
      void 0 !== a.viewport && n.viewport.fromArray(a.viewport);
      void 0 !== a.offset && n.offset.fromArray(a.offset);
      void 0 !== a.clearColor && (n.clearColor = a.clearColor);
      void 0 !== a.clearDepth && (n.clearDepth = a.clearDepth);
      void 0 !== a.order && (n.order = a.order);
      break;
    case "OrthographicCamera":
      n = new OrthographicCamera(a.size, a.aspect, a.mode, a.near, a.far);
      void 0 !== a.viewport && n.viewport.fromArray(a.viewport);
      void 0 !== a.offset && n.offset.fromArray(a.offset);
      void 0 !== a.clearColor && (n.clearColor = a.clearColor);
      void 0 !== a.clearDepth && (n.clearDepth = a.clearDepth);
      void 0 !== a.order && (n.order = a.order);
      break;
    case "Script":
      n = new Script(a.code);
      break;
    case "RectAreaLight":
      n = new RectAreaLight(a.color, a.intensity, a.width, a.height);
      break;
    case "AmbientLight":
      n = new AmbientLight(a.color, a.intensity);
      break;
    case "DirectionalLight":
      n = new DirectionalLight(a.color, a.intensity);
      break;
    case "PointLight":
      n = new PointLight(a.color, a.intensity, a.distance, a.decay);
      break;
    case "SpotLight":
      n = new SpotLight(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay);
      break;
    case "HemisphereLight":
      n = new HemisphereLight(a.color, a.groundColor, a.intensity);
      break;
    case "Mesh":
      n = new Mesh(g(a.geometry), e(a.material));
      break;
    case "SkinnedMesh":
      n = new SkinnedMesh(g(a.geometry), e(a.material));
      break;
    case "LOD":
      n = new THREE.LOD;
      break;
    case "Line":
      n = new THREE.Line(g(a.geometry), e(a.material), a.mode);
      break;
    case "PointCloud":
    case "Points":
      n = new THREE.Points(g(a.geometry), e(a.material));
      break;
    case "Sprite":
      n = new Sprite(e(a.material));
      break;
    case "Group":
      n = new Container;
      break;
    case "Bone":
      n = new Bone;
      break;
    default:
      n = new Container;
  }
  n.uuid = a.uuid;
  void 0 !== a.name && (n.name = a.name);
  void 0 !== a.hidden && (n.hidden = a.hidden);
  void 0 !== a.folded && (n.folded = a.folded);
  void 0 !== a.matrix ? (w.fromArray(a.matrix), w.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== a.position && n.position.fromArray(a.position), void 0 !== a.rotation && n.rotation.fromArray(a.rotation), void 0 !== a.scale && n.scale.fromArray(a.scale));
  void 0 !== a.castShadow && (n.castShadow = a.castShadow);
  void 0 !== a.receiveShadow && (n.receiveShadow = a.receiveShadow);
  void 0 !== a.shadow && n.shadow.fromJSON(a.shadow);
  void 0 !== a.visible && (n.visible = a.visible);
  void 0 !== a.userData && (n.userData = a.userData);
  if (void 0 !== a.children) {
    for (var x in a.children) {
      n.add(this.parseObject(a.children[x], h, l, b, f, k));
    }
  }
  void 0 !== a.matrixAutoUpdate && (n.matrixAutoUpdate = a.matrixAutoUpdate, n.matrixAutoUpdate || (n.updateMatrix(), n.updateMatrixWorld(!0)));
  if ("Program" === a.type) {
    n.materials = l, n.textures = b, n.fonts = k, n.audio = f;
  } else {
    if ("Scene" === a.type) {
      for (t = 0;t < n.cameras.length;t++) {
        x = n.getCamera(n.cameras[t]), null !== x ? n.cameras[t] = x : n.cameras.splice(t, 1);
      }
    } else {
      if ("LOD" === a.type) {
        for (a = a.levels, w = 0;w < a.length;w++) {
          t = a[w], x = n.getObjectByProperty("uuid", t.object), void 0 !== x && n.addLevel(x, t.distance);
        }
      }
    }
  }
  return n;
};
function TTFLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.reversed = !1;
}
TTFLoader.prototype.load = function(a, h, l, b) {
  var f = this, k = new THREE.FileLoader(this.manager);
  k.setResponseType("arraybuffer");
  k.load(a, function(a) {
    a = f.parse(a);
    void 0 !== h && h(a);
  }, l, b);
};
TTFLoader.prototype.parse = function(a) {
  a = opentype.parse(a);
  return TTFLoader.convert(a, this.reversed);
};
TTFLoader.convert = function(a, h) {
  for (var l = 1E5 / (72 * (a.unitsPerEm || 2048)), b = {glyphs:{}}, f = 0;f < a.glyphs.length;f++) {
    var k = a.glyphs.glyphs[f];
    if (void 0 !== k.unicode) {
      var c = {};
      c.ha = Math.round(k.advanceWidth * l);
      c.xMin = Math.round(k.xMin * l);
      c.xMax = Math.round(k.xMax * l);
      c.o = "";
      h && (k.path.commands = TTFLoader.reverseCommands(k.path.commands));
      k.path.commands.forEach(function(a, b) {
        "c" === a.type.toLowerCase() && (a.type = "b");
        c.o += a.type.toLowerCase();
        c.o += " ";
        void 0 !== a.x && void 0 !== a.y && (c.o += Math.round(a.x * l), c.o += " ", c.o += Math.round(a.y * l), c.o += " ");
        void 0 !== a.x1 && void 0 !== a.y1 && (c.o += Math.round(a.x1 * l), c.o += " ", c.o += Math.round(a.y1 * l), c.o += " ");
        void 0 !== a.x2 && void 0 !== a.y2 && (c.o += Math.round(a.x2 * l), c.o += " ", c.o += Math.round(a.y2 * l), c.o += " ");
      });
      b.glyphs[String.fromCharCode(k.unicode)] = c;
    }
  }
  b.resolution = 1E3;
  b.originalFontInformation = a.names;
  b.unitsPerEm = a.unitsPerEm;
  b.ascender = Math.round(a.ascender * l);
  b.descender = Math.round(a.descender * l);
  b.underlinePosition = a.tables.post.underlinePosition;
  b.underlineThickness = a.tables.post.underlineThickness;
  b.boundingBox = {yMin:a.tables.head.yMin, xMin:a.tables.head.xMin, yMax:a.tables.head.yMax, xMax:a.tables.head.xMax};
  return b;
};
TTFLoader.reverseCommands = function(a) {
  var h = [], l;
  a.forEach(function(a) {
    "m" === a.type.toLowerCase() ? (l = [a], h.push(l)) : "z" !== a.type.toLowerCase() && l.push(a);
  });
  var b = [];
  h.forEach(function(a) {
    var f = {type:"m", x:a[a.length - 1].x, y:a[a.length - 1].y};
    b.push(f);
    for (var c = a.length - 1;0 < c;c--) {
      var g = a[c], f = {type:g.type};
      void 0 !== g.x2 && void 0 !== g.y2 ? (f.x1 = g.x2, f.y1 = g.y2, f.x2 = g.x1, f.y2 = g.y1) : void 0 !== g.x1 && void 0 !== g.y1 && (f.x1 = g.x1, f.y1 = g.y1);
      f.x = a[c - 1].x;
      f.y = a[c - 1].y;
      b.push(f);
    }
  });
  return b;
};
function LeapMotion() {
  THREE.Object3D.call(this);
  this.type = "LeapDevice";
  this.name = "leap";
  this.posesEnabled = this.gesturesEnabled = this.debugModel = !0;
  this.mode = LeapMotion.DESK;
  this.useArm = !1;
  this.boneMeshes = [];
  this.armMeshes = [];
  this.material = new THREE.MeshPhongMaterial;
  this.geometry = new THREE.BoxBufferGeometry(1, 1, 1);
  this.physicsWorld = null;
  this.physicsBodys = [];
  this.gesture = [];
  for (var a = 0;10 > a;a++) {
    this.gesture[a] = !1;
  }
  this.pose = [];
  for (a = 0;3 > a;a++) {
    this.pose[a] = !1;
  }
  this.data = null;
}
LeapMotion.prototype = Object.create(THREE.Object3D.prototype);
LeapMotion.DESK = 0;
LeapMotion.HDM = 1;
LeapMotion.SWIPE = 0;
LeapMotion.SWIPE_LEFT = 1;
LeapMotion.SWIPE_RIGHT = 2;
LeapMotion.SWIPE_FRONT = 3;
LeapMotion.SWIPE_BACK = 4;
LeapMotion.SWIPE_UP = 5;
LeapMotion.SWIPE_DOWN = 6;
LeapMotion.CIRCLE = 7;
LeapMotion.SCREEN_TAP = 8;
LeapMotion.KEY_TAP = 9;
LeapMotion.CLOSED = 0;
LeapMotion.OPEN = 1;
LeapMotion.POINTING = 2;
LeapMotion.prototype.initialize = function() {
  var a = this;
  Leap.loop({background:!0}, function(h) {
    a.data = h;
  }).connect();
  for (var h = 0;h < this.children.length;h++) {
    this.children[h].initialize();
  }
};
LeapMotion.prototype.update = function() {
  null !== this.data && (this.gesturesEnabled && this.updateGestures(), this.posesEnabled && this.updatePoses(), this.debugModel && this.updateDebugModel());
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].update();
  }
};
LeapMotion.prototype.checkGesture = function(a) {
  return void 0 !== this.gesture[a] ? this.gesture[a] : !1;
};
LeapMotion.prototype.checkPose = function(a) {
  return void 0 !== this.pose[a] ? this.pose[a] : !1;
};
LeapMotion.prototype.setMode = function(a) {
  this.mode = a;
};
LeapMotion.prototype.updatePoses = function() {
  for (var a = 0;a < this.pose.length;a++) {
    this.pose[a] = !0;
  }
  for (var h = 0;h < this.data.hands.length;h++) {
    for (var l = this.data.hands[h], b = l.sphereCenter, b = new THREE.Vector3(b[0], b[1], b[2]), f = [], k = 0, c, a = 0;a < this.pose.length;a++) {
      this.pose[a] = !0;
    }
    for (var g = [], a = 0;a < l.fingers.length;a++) {
      c = l.fingers[a], g.push(c.direction), c = c.distal.nextJoint, c = new THREE.Vector3(c[0], c[1], c[2]), f.push(b.distanceTo(c) / l._scaleFactor), 0 !== a && (.3 > g[a][2] && (this.pose[LeapMotion.CLOSED] = !1), -.5 < g[a][2] && (this.pose[LeapMotion.OPEN] = !1), 1 === a ? k = f[1] : k < 2 * f[a] - 15 && (this.pose[LeapMotion.POINTING] = !1));
    }
    k < 2 * f[0] - 15 && (this.pose[LeapMotion.POINTING] = !1);
  }
};
LeapMotion.prototype.updateGestures = function() {
  for (var a = 0;a < this.gesture.length;a++) {
    this.gesture[a] = !1;
  }
  var h = this;
  this.data.valid && 0 < this.data.gestures.length && this.data.gestures.forEach(function(a) {
    "swipe" === a.type ? (h.gesture[LeapMotion.SWIPE] = !0, 0 < a.direction[0] ? h.gesture[LeapMotion.SWIPE_RIGHT] = !0 : h.gesture[LeapMotion.SWIPE_LEFT] = !0, 0 < a.direction[1] ? h.gesture[LeapMotion.SWIPE_UP] = !0 : h.gesture[LeapMotion.SWIPE_DOWN] = !0, 0 < a.direction[2] ? h.gesture[LeapMotion.SWIPE_FRONT] = !0 : h.gesture[LeapMotion.SWIPE_BACK] = !0) : "circle" === a.type ? h.gesture[LeapMotion.CIRCLE] = !0 : "keyTap" === a.type ? h.gesture[LeapMotion.KEY_TAP] = !0 : "screenTap" === a.type && 
    (h.gesture[LeapMotion.SCREEN_TAP] = !0);
  });
};
LeapMotion.prototype.updateDebugModel = function() {
  var a = this;
  this.armMeshes.forEach(function(b) {
    a.remove(b);
  });
  this.boneMeshes.forEach(function(b) {
    a.remove(b);
  });
  for (var h = 0, l = 0, b = 0;b < this.data.hands.length;b++) {
    for (var f = this.data.hands[b], k = 0;k < f.fingers.length;k++) {
      for (var c = f.fingers[k], g = 0;g < c.bones.length;g++) {
        var e = c.bones[g];
        if (0 !== h) {
          var p = this.boneMeshes[h] || this.addMesh(this.boneMeshes);
          this.updateMesh(e, p);
        }
        h++;
      }
    }
    this.showArm && (f = f.arm, k = this.armMeshes[l++] || this.addMesh(this.armMeshes), this.updateMesh(f, k), k.scale.set(f.width / 1200, f.width / 300, f.length / 150));
  }
  null !== this.physicsWorld && this.updatePhysics();
};
LeapMotion.prototype.updatePhysics = function() {
  for (var a = 0;a < this.physicsBodys.length;a++) {
    this.physicsWorld.removeBody(this.physicsBodys[a].pop());
  }
  this.children.forEach(function(a, l) {
    a = new THREE.BoundingBoxHelper(a);
    a.update();
    l = new THREE.Vector3(a.box.max.x - a.box.min.x, a.box.max.y - a.box.min.y, a.box.max.z - a.box.min.z);
    l.x *= this.scale.x;
    l.y *= this.scale.y;
    l.z *= this.scale.z;
    l.divideScalar(2);
    a = a.box.center();
    a.x *= this.scale.x;
    a.y *= this.scale.y;
    a.z *= this.scale.z;
    a.add(this.position);
    l = new CANNON.Box(new CANNON.Vec3(l.x, l.y, l.z));
    var b = new CANNON.Body({mass:0});
    b.addShape(l);
    b.position.set(a.x - this.position.x, a.y - this.position.y, a.z - this.position.z);
    b.updateMassProperties();
    this.physicsBodys.push(b);
    this.physicsWorld.addBody(b);
  });
};
LeapMotion.prototype.addMesh = function(a) {
  var h = new Mesh(this.geometry, this.material);
  h.castShadow = this.castShadow;
  h.receiveShadow = this.receiveShadow;
  a.push(h);
  return h;
};
LeapMotion.prototype.updateMesh = function(a, h) {
  h.position.fromArray(a.center());
  h.position.divideScalar(150);
  h.setRotationFromMatrix((new THREE.Matrix4).fromArray(a.matrix()));
  h.scale.set(a.width / 150, a.width / 150, a.length / 150);
  this.add(h);
};
LeapMotion.prototype.getMovement = function() {
  var a = this.data.gestures[0].position, h = this.data.gestures[0].startPosition, a = new THREE.Vector3(a[0] - h[0], a[1] - h[1], a[2] - h[2]);
  a.divideScalar(this.data.currentFrameRate);
  return a;
};
LeapMotion.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.type = this.type;
  a.object.debugModel = this.debugModel;
  a.object.gesturesEnabled = this.gesturesEnabled;
  a.object.posesEnabled = this.posesEnabled;
  a.object.mode = this.mode;
  a.object.useArm = this.useArm;
  return a;
};
function KinectDevice() {
  THREE.Object3D.call(this);
  this.type = "Kinect";
  this.name = "kinect";
  this.socket = new WebSocket("ws://127.0.0.1:8181");
  this.connected = !1;
  this.debugModel = !0;
  this.dataTimeout = 0;
  this.data = this.camera = null;
  this.dataReceived = !1;
  var a = this;
  this.socket.onopen = function() {
    a.connected = !0;
  };
  this.socket.onclose = function() {
    a.connected = !1;
  };
  this.socket.onmessage = function(h) {
    "string" === typeof h.data ? (a.data = JSON.parse(h.data), a.dataReceived = !0, a.dataTimeout = KinectDevice.DATA_TIMEOUT) : h.data instanceof Blob && (a.camera = h.data);
  };
}
KinectDevice.DATA_TIMEOUT = 20;
KinectDevice.DEPTH = 0;
KinectDevice.COLOR = 1;
KinectDevice.JOINTS_NAME = [["head", "shouldercenter"], ["shouldercenter", "shoulderright"], ["shouldercenter", "shoulderleft"], ["shoulderright", "elbowright"], ["shoulderleft", "elbowleft"], ["elbowright", "wristright"], ["elbowleft", "wristleft"], ["wristright", "handright"], ["wristleft", "handleft"], ["shouldercenter", "spine"], ["spine", "hipcenter"], ["hipcenter", "hipright"], ["hipcenter", "hipleft"], ["hipright", "kneeright"], ["hipleft", "kneeleft"], ["kneeright", "ankleright"], ["kneeleft", 
"ankleleft"], ["ankleright", "footright"], ["ankleleft", "footleft"]];
KinectDevice.prototype = Object.create(THREE.Object3D.prototype);
KinectDevice.prototype.update = function() {
  if (null !== this.data) {
    if (this.dataReceived) {
      for (this.dataReceived = !1;0 < this.children.length;) {
        this.children.pop();
      }
      if (this.debugModel) {
        for (var a = new THREE.SphereGeometry(.04, 6, 6), h = new THREE.MeshPhongMaterial(16711680), l = 0;l < this.data.skeletons.length;l++) {
          for (var b = this.data.skeletons[l].joints, f = 0;f < b.length;f++) {
            var k = new Mesh(a, h);
            k.position.set(b[f].x, b[f].y, b[f].z);
            k.castShadow = !0;
            this.add(k);
          }
        }
      }
    } else {
      if (0 < this.dataTimeout && (this.dataTimeout--, 0 === this.dataTimeout)) {
        for (;0 < this.children.length;) {
          this.children.pop();
        }
      }
    }
  }
  for (f = 0;f < this.children.length;f++) {
    this.children[f].update();
  }
};
KinectDevice.prototype.isConnected = function() {
  return this.connected;
};
KinectDevice.prototype.setCameraMode = function(a) {
  a === KinectDevice.COLOR ? socket.send("Color") : a === KinectDevice.DEPTH && socket.send("Depth");
};
KinectDevice.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.debugModel = this.debugModel;
  return a;
};
function Mesh(a, h) {
  THREE.Mesh.call(this, a, h);
  this.name = "model";
  this.castShadow = this.receiveShadow = !0;
}
Mesh.prototype = Object.create(THREE.Mesh.prototype);
Mesh.prototype.dispose = function() {
  null !== this.material && void 0 !== this.material.dispose && this.material.dispose();
  this.geometry.dispose();
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].dispose();
  }
};
function SkinnedMesh(a, h, l) {
  THREE.SkinnedMesh.call(this, a, h, l);
  this.name = "model";
  this.castShadow = this.receiveShadow = !0;
}
SkinnedMesh.prototype = Object.create(THREE.SkinnedMesh.prototype);
SkinnedMesh.prototype.dispose = function() {
  null !== this.material && void 0 !== this.material.dispose && this.material.dispose();
  this.geometry.dispose();
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].dispose();
  }
};
function Text3D(a, h, l, b, f, k, c, g, e) {
  THREE.Mesh.call(this, void 0, h);
  this.name = "text";
  this.type = "Text3D";
  this.font = l;
  this.text = void 0 !== a ? a : "text";
  this.size = void 0 !== g ? g : 1;
  this.height = void 0 !== b ? b : .5;
  this.curveSegments = void 0 !== e ? e : 15;
  this.bevel = void 0 !== f ? f : !1;
  this.bevelThickness = void 0 !== k ? k : .1;
  this.bevelSize = void 0 !== c ? c : .05;
  this.setText(this.text);
  this.castShadow = this.receiveShadow = !0;
}
Text3D.prototype = Object.create(THREE.Mesh.prototype);
Text3D.prototype.setFont = function(a) {
  this.font = a;
  this.setText();
};
Text3D.prototype.setText = function(a) {
  void 0 !== a && (this.text = a);
  void 0 !== this.geometry && this.geometry.dispose();
  this.updateText();
};
Text3D.prototype.updateText = function() {
  null !== this.font && (this.geometry = new THREE.TextGeometry(this.text, {size:this.size, curveSegments:this.curveSegments, font:this.font, height:this.height, bevelEnabled:this.bevel, bevelSize:this.bevelSize, bevelThickness:this.bevelThickness}));
};
Text3D.prototype.clone = function() {
  return new Text3D(this.text, this.material, this.font, this.height, this.bevel, this.bevelThickness, this.bevelSize, this.size, this.curveSegments);
};
Text3D.prototype.dispose = function() {
  void 0 !== this.material.dispose && this.material.dispose();
  void 0 !== this.geometry && this.geometry.dispose();
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].dispose();
  }
};
Text3D.prototype.toJSON = function(a) {
  var h = this.geometry;
  this.geometry = void 0;
  var l = this.font;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, f) {
    l = l.toJSON(a);
  });
  a.object.text = this.text;
  a.object.font = l.uuid;
  a.object.size = this.size;
  a.object.curveSegments = this.curveSegments;
  a.object.height = this.height;
  a.object.bevel = this.bevel;
  a.object.bevelThickness = this.bevelThickness;
  a.object.bevelSize = this.bevelSize;
  this.geometry = h;
  return a;
};
function Sprite(a) {
  THREE.Sprite.call(this, a);
  this.name = "sprite";
  this.type = "Sprite";
}
Sprite.prototype = Object.create(THREE.Sprite.prototype);
Sprite.prototype.dispose = function() {
  null !== this.material && void 0 !== this.material.dispose && this.material.dispose();
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].dispose();
  }
};
function PointLight(a, h, l, b) {
  THREE.PointLight.call(this, a, h, l, b);
  this.name = "point";
  this.castShadow = !0;
  this.shadow.camera.near = .05;
  this.shadow.camera.far = 5E3;
  this.shadow.bias = .01;
}
PointLight.prototype = Object.create(THREE.PointLight.prototype);
PointLight.prototype.updateShadowMap = function() {
  this.shadow.map.dispose();
  this.shadow.map = null;
  this.shadow.camera.updateProjectionMatrix();
};
function SpotLight(a, h, l, b, f, k) {
  THREE.SpotLight.call(this, a, h, l, b, f, k);
  this.name = "spotlight";
  this.castShadow = !0;
  this.shadow.camera.near = .05;
  this.shadow.camera.far = 5E3;
  this.shadow.mapSize.width = 512;
  this.shadow.mapSize.height = 512;
}
SpotLight.prototype = Object.create(THREE.SpotLight.prototype);
SpotLight.prototype.updateShadowMap = function() {
  this.shadow.map.dispose();
  this.shadow.map = null;
  this.shadow.camera.updateProjectionMatrix();
};
function AmbientLight(a) {
  THREE.AmbientLight.call(this, a);
  this.name = "ambient";
  this.matrixAutoUpdate = !1;
}
AmbientLight.prototype = Object.create(THREE.AmbientLight.prototype);
function DirectionalLight(a, h) {
  THREE.DirectionalLight.call(this, a, h);
  this.name = "directional";
  this.castShadow = !0;
  this.shadow.camera.near = .5;
  this.shadow.camera.far = 1E4;
}
DirectionalLight.prototype = Object.create(THREE.DirectionalLight.prototype);
DirectionalLight.prototype.updateShadowMap = function() {
  this.shadow.map.dispose();
  this.shadow.map = null;
  this.shadow.camera.updateProjectionMatrix();
};
function HemisphereLight(a, h, l) {
  THREE.HemisphereLight.call(this, a, h, l);
  this.name = "hemisphere";
}
HemisphereLight.prototype = Object.create(THREE.HemisphereLight.prototype);
function RectAreaLight(a, h, l, b) {
  THREE.RectAreaLight.call(this, a, h, l, b);
  this.name = "rectarea";
}
RectAreaLight.prototype = Object.create(THREE.RectAreaLight.prototype);
RectAreaLight.prototype.toJSON = function(a) {
  a = THREE.Light.prototype.toJSON.call(this, a);
  a.object.width = this.width;
  a.object.height = this.height;
  return a;
};
function Sky(a, h, l, b) {
  THREE.Object3D.call(this);
  this.name = "sky";
  this.type = "Sky";
  this.clock = new THREE.Clock;
  this.colorTop = [new THREE.Color(7844859), new THREE.Color(30463), new THREE.Color(220086), new THREE.Color(9273)];
  this.colorBottom = [new THREE.Color(15461606), new THREE.Color(16777215), new THREE.Color(16705495), new THREE.Color(26023)];
  this.sunColor = 16777130;
  this.moonColor = 5592507;
  this.hemisphere = new THREE.HemisphereLight(0, 0, .5);
  this.hemisphere.color.setHSL(.6, 1, .6);
  this.hemisphere.groundColor.setHSL(.1, 1, .75);
  this.hemisphere.hidden = !0;
  this.hemisphere.matrixAutoUpdate = !1;
  this.add(this.hemisphere);
  this.sun = new DirectionalLight(this.sunColor, .3);
  this.sun.castShadow = !0;
  this.sun.hidden = !0;
  this.add(this.sun);
  var f = {topColor:{type:"c", value:new THREE.Color(0, .46, 1)}, bottomColor:{type:"c", value:new THREE.Color(1, 1, 1)}, offset:{type:"f", value:20}, exponent:{type:"f", value:.4}};
  f.topColor.value.copy(this.hemisphere.color);
  var k = new THREE.SphereBufferGeometry(1E3, 16, 16), f = new THREE.ShaderMaterial({vertexShader:"varying vec3 vWorldPosition; \r\tvoid main() \r\t{ \r\t\tvec4 worldPosition = modelMatrix * vec4(position, 1.0); \r\t\tvWorldPosition = worldPosition.xyz; \r\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); \r\t}", fragmentShader:"uniform vec3 topColor; \r\tuniform vec3 bottomColor; \r\tuniform float offset; \r\tuniform float exponent; \r\tvarying vec3 vWorldPosition; \r\tvoid main() \r\t{ \r\t\tfloat h = normalize(vWorldPosition + offset).y; \r\t\tgl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h , 0.0), exponent), 0.0)), 1.0); \r\t}", 
  uniforms:f, side:THREE.BackSide});
  this.sky = new THREE.Mesh(k, f);
  this.sky.hidden = !0;
  this.sky.matrixAutoUpdate = !1;
  this.add(this.sky);
  this.sky.raycast = function() {
    return null;
  };
  this.autoUpdate = void 0 !== a ? a : !0;
  this.sunDistance = void 0 !== l ? l : 100;
  this.dayTime = void 0 !== h ? h : 120;
  this.time = void 0 !== b ? b : 75;
  this.updateSky();
}
Sky.prototype = Object.create(THREE.Object3D.prototype);
Sky.prototype.initialize = function() {
  this.updateSky();
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].initialize();
  }
};
Sky.prototype.update = function() {
  this.autoUpdate && (this.time += this.clock.getDelta(), this.time > this.dayTime && (this.time -= this.dayTime), this.updateSky());
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].update();
  }
};
Sky.prototype.isEmpty = function() {
  return 3 >= this.children.length;
};
Sky.prototype.updateSky = function() {
  var a = this.time / this.dayTime;
  if (.25 > a) {
    this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[3].r, this.colorTop[3].g, this.colorTop[3].b), this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[3].r, this.colorBottom[3].g, this.colorBottom[3].b);
  } else {
    if (.292 > a) {
      var h = 23.81 * (a - .25), l = 1 - h;
      this.sky.material.uniforms.topColor.value.setRGB(l * this.colorTop[3].r + h * this.colorTop[0].r, l * this.colorTop[3].g + h * this.colorTop[0].g, l * this.colorTop[3].b + h * this.colorTop[0].b);
      this.sky.material.uniforms.bottomColor.value.setRGB(l * this.colorBottom[3].r + h * this.colorBottom[0].r, l * this.colorBottom[3].g + h * this.colorBottom[0].g, l * this.colorBottom[3].b + h * this.colorBottom[0].b);
    } else {
      .4167 > a ? (this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[0].r, this.colorTop[0].g, this.colorTop[0].b), this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[0].r, this.colorBottom[0].g, this.colorBottom[0].b)) : .5 > a ? (h = 12 * (a - .4167), l = 1 - h, this.sky.material.uniforms.topColor.value.setRGB(l * this.colorTop[0].r + h * this.colorTop[1].r, l * this.colorTop[0].g + h * this.colorTop[1].g, l * this.colorTop[0].b + h * this.colorTop[1].b), this.sky.material.uniforms.bottomColor.value.setRGB(l * 
      this.colorBottom[0].r + h * this.colorBottom[1].r, l * this.colorBottom[0].g + h * this.colorBottom[1].g, l * this.colorBottom[0].b + h * this.colorBottom[1].b)) : .708 > a ? (this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[1].r, this.colorTop[1].g, this.colorTop[1].b), this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[1].r, this.colorBottom[1].g, this.colorBottom[1].b)) : .75 > a ? (h = 23.81 * (a - .708), l = 1 - h, this.sky.material.uniforms.topColor.value.setRGB(l * 
      this.colorTop[1].r + h * this.colorTop[2].r, l * this.colorTop[1].g + h * this.colorTop[2].g, l * this.colorTop[1].b + h * this.colorTop[2].b), this.sky.material.uniforms.bottomColor.value.setRGB(l * this.colorBottom[1].r + h * this.colorBottom[2].r, l * this.colorBottom[1].g + h * this.colorBottom[2].g, l * this.colorBottom[1].b + h * this.colorBottom[2].b)) : .8333 > a ? (h = 12.048 * (a - .75), l = 1 - h, this.sky.material.uniforms.topColor.value.setRGB(l * this.colorTop[2].r + h * this.colorTop[3].r, 
      l * this.colorTop[2].g + h * this.colorTop[3].g, l * this.colorTop[2].b + h * this.colorTop[3].b), this.sky.material.uniforms.bottomColor.value.setRGB(l * this.colorBottom[2].r + h * this.colorBottom[3].r, l * this.colorBottom[2].g + h * this.colorBottom[3].g, l * this.colorBottom[2].b + h * this.colorBottom[3].b)) : (this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[3].r, this.colorTop[3].g, this.colorTop[3].b), this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[3].r, 
      this.colorBottom[3].g, this.colorBottom[3].b));
    }
  }
  .2 > a ? this.sun.color.setHex(this.moonColor) : .3 > a ? (h = 10 * (a - .2), .5 > h ? (this.sun.intensity = .3 * (2 - 2 * h), this.sun.color.setHex(this.moonColor)) : (this.sun.intensity = .6 * h, this.sun.color.setHex(this.sunColor))) : .7 > a ? this.sun.color.setHex(this.sunColor) : .8 > a ? (h = 10 * (a - .7), .5 > h ? (this.sun.intensity = .3 * (2 - 2 * h), this.sun.color.setHex(this.sunColor)) : (this.sun.intensity = .6 * h, this.sun.color.setHex(this.moonColor))) : this.sun.color.setHex(this.moonColor);
  h = MathUtils.pi2 * a - MathUtils.pid2;
  .25 < a && .75 > a ? (this.sun.position.x = this.sunDistance * Math.cos(h), this.sun.position.y = this.sunDistance * Math.sin(h)) : (this.sun.position.x = this.sunDistance * Math.cos(h + Math.PI), this.sun.position.y = this.sunDistance * Math.sin(h + Math.PI));
};
Sky.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.colorTop = [];
  for (var h = 0;h < this.colorTop.length;h++) {
    a.object.colorTop.push(this.colorTop[h].toJSON());
  }
  a.object.colorBottom = [];
  for (h = 0;h < this.colorBottom.length;h++) {
    a.object.colorBottom.push(this.colorBottom[h].toJSON());
  }
  a.object.sunColor = this.sunColor;
  a.object.moonColor = this.moonColor;
  a.object.autoUpdate = this.autoUpdate;
  a.object.sunDistance = this.sunDistance;
  a.object.dayTime = this.dayTime;
  a.object.time = this.time;
  a.object.sun = {};
  a.object.sun.shadow = this.sun.shadow.toJSON();
  return a;
};
function PerspectiveCamera(a, h, l, b) {
  THREE.PerspectiveCamera.call(this, a, h, l, b);
  this.name = "camera";
  this.offset = new THREE.Vector2(0, 0);
  this.viewport = new THREE.Vector2(1, 1);
  this.clearDepth = this.clearColor = !1;
  this.order = 0;
}
PerspectiveCamera.prototype = Object.create(THREE.PerspectiveCamera.prototype);
PerspectiveCamera.prototype.destroy = function() {
  var a = ObjectUtils.getScene(this);
  null !== a && a.removeCamera(this);
  THREE.Object3D.prototype.destroy.call(this);
};
PerspectiveCamera.prototype.updateMatrixWorld = function(a) {
  !0 === this.matrixAutoUpdate && this.updateMatrix();
  if (!0 === this.matrixWorldNeedsUpdate || !0 === a) {
    null !== this.parent ? this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix) : this.matrixWorld = this.matrix, this.matrixWorldNeedsUpdate = !1, a = !0;
  }
  for (var h = this.children, l = 0;l < h.length;l++) {
    h[l].updateMatrixWorld(a);
  }
};
PerspectiveCamera.prototype.updateProjectionMatrix = function() {
  var a = this.near * Math.tan(.5 * THREE.Math.DEG2RAD * this.fov) / this.zoom, h = 2 * a, l = this.aspect * h * (void 0 !== this.viewport ? this.viewport.x / this.viewport.y : 1), b = -.5 * l;
  0 !== this.filmOffset && (b += this.near * this.filmOffset / this.getFilmWidth());
  this.projectionMatrix.makePerspective(b, b + l, a, a - h, this.near, this.far);
};
PerspectiveCamera.prototype.toJSON = function(a) {
  a = THREE.PerspectiveCamera.prototype.toJSON.call(this, a);
  a.object.clearColor = this.clearColor;
  a.object.clearDepth = this.clearDepth;
  a.object.viewport = this.viewport.toArray();
  a.object.offset = this.offset.toArray();
  a.object.order = this.order;
  return a;
};
function OrthographicCamera(a, h, l, b, f) {
  THREE.OrthographicCamera.call(this, -1, 1, 1, -1, b, f);
  this.name = "camera";
  this.size = void 0 != a ? a : 10;
  this.aspect = void 0 != h ? h : 1;
  this.mode = void 0 !== l ? l : OrthographicCamera.RESIZE_HORIZONTAL;
  this.offset = new THREE.Vector2(0, 0);
  this.viewport = new THREE.Vector2(1, 1);
  this.clearDepth = this.clearColor = !1;
  this.order = 0;
  this.updateProjectionMatrix();
}
OrthographicCamera.prototype = Object.create(THREE.OrthographicCamera.prototype);
OrthographicCamera.RESIZE_HORIZONTAL = 0;
OrthographicCamera.RESIZE_VERTICAL = 1;
OrthographicCamera.prototype.destroy = function() {
  var a = ObjectUtils.getScene(this);
  null !== a && a.removeCamera(this);
  THREE.Object3D.prototype.destroy.call(this);
};
OrthographicCamera.prototype.updateProjectionMatrix = function() {
  this.mode === OrthographicCamera.RESIZE_HORIZONTAL ? (this.top = this.size / 2, this.bottom = -this.top, this.right = this.viewport.x / this.viewport.y * this.aspect * this.top, this.left = -this.right) : this.mode === OrthographicCamera.RESIZE_VERTICAL && (this.right = this.size / 2, this.left = -this.right, this.top = this.right / this.aspect * (this.viewport.x / this.viewport.y), this.bottom = -this.top);
  THREE.OrthographicCamera.prototype.updateProjectionMatrix.call(this);
};
OrthographicCamera.prototype.toJSON = function(a) {
  a = THREE.OrthographicCamera.prototype.toJSON.call(this, a);
  a.object.size = this.size;
  a.object.aspect = this.aspect;
  a.object.mode = this.mode;
  a.object.clearColor = this.clearColor;
  a.object.clearDepth = this.clearDepth;
  a.object.viewport = this.viewport.toArray();
  a.object.offset = this.offset.toArray();
  a.object.order = this.order;
  return a;
};
function AudioEmitter(a) {
  THREE.Audio.call(this, AudioEmitter.listener);
  this.name = "audio";
  this.type = "Audio";
  this.matrixAutoUpdate = !1;
  this.audio = void 0 !== a ? a : null;
  this.volume = 1;
  this.autoplay = !0;
  this.playbackRate = 1;
  this.startTime = 0;
  this.loop = !0;
  this.isPlaying = !1;
  this.hasPlaybackControl = !0;
}
AudioEmitter.listener = new THREE.AudioListener;
AudioEmitter.prototype = Object.create(THREE.Audio.prototype);
AudioEmitter.prototype.initialize = function() {
  var a = this;
  null !== this.audio && THREE.AudioContext.getContext().decodeAudioData(this.audio.data, function(h) {
    a.setBuffer(h);
  });
  this.setVolume(this.volume);
  this.setPlaybackRate(this.playbackRate);
  for (var h = 0;h < this.children.length;h++) {
    this.children[h].initialize();
  }
};
AudioEmitter.prototype.dispose = function() {
  this.isPlaying && (this.stop(), this.disconnect());
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].dispose();
  }
};
AudioEmitter.prototype.setVolume = function(a) {
  this.volume = a;
  this.gain.gain.value = a;
  return this;
};
AudioEmitter.prototype.toJSON = function(a) {
  var h = this.audio;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, b) {
    h = h.toJSON(a);
  });
  a.object.audio = h.uuid;
  a.object.volume = this.volume;
  a.object.autoplay = this.autoplay;
  a.object.startTime = this.startTime;
  a.object.playbackRate = this.playbackRate;
  a.object.loop = this.loop;
  return a;
};
function PositionalAudio(a) {
  THREE.PositionalAudio.call(this, AudioEmitter.listener);
  this.name = "audio";
  this.type = "PositionalAudio";
  this.audio = void 0 !== a ? a : null;
  this.volume = 1;
  this.autoplay = !0;
  this.playbackRate = 1;
  this.startTime = 0;
  this.loop = !0;
  this.isPlaying = !1;
  this.hasPlaybackControl = !0;
  this.cameras = null;
  this.tempA = new THREE.Vector3;
  this.tempB = new THREE.Vector3;
}
PositionalAudio.prototype = Object.create(THREE.PositionalAudio.prototype);
PositionalAudio.prototype.initialize = function() {
  var a = this;
  null !== this.audio && THREE.AudioContext.getContext().decodeAudioData(this.audio.data, function(h) {
    a.setBuffer(h);
  });
  this.setVolume(this.volume);
  this.setPlaybackRate(this.playbackRate);
  for (var h = this;null !== h.parent;) {
    h = h.parent, h instanceof Scene && (this.cameras = h.cameras);
  }
  for (h = 0;h < this.children.length;h++) {
    this.children[h].initialize();
  }
};
PositionalAudio.prototype.update = function() {
  this.tempA.setFromMatrixPosition(this.matrixWorld);
  0 < this.cameras.length && (this.tempB.setFromMatrixPosition(this.cameras[0].matrixWorld), this.tempA.sub(this.tempB));
  this.panner.setPosition(this.tempA.x, this.tempA.y, this.tempA.z);
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].update();
  }
};
PositionalAudio.prototype.dispose = function() {
  this.isPlaying && (this.stop(), this.disconnect());
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].dispose();
  }
};
PositionalAudio.prototype.setVolume = function(a) {
  this.volume = a;
  this.gain.gain.value = a;
  return this;
};
PositionalAudio.prototype.toJSON = function(a) {
  var h = this.audio;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, b) {
    h = h.toJSON(a);
  });
  a.object.audio = h.uuid;
  a.object.volume = this.volume;
  a.object.autoplay = this.autoplay;
  a.object.startTime = this.startTime;
  a.object.playbackRate = this.playbackRate;
  a.object.loop = this.loop;
  return a;
};
function Script(a) {
  THREE.Object3D.call(this);
  this.type = "Script";
  this.name = "script";
  this.script = null;
  this.code = void 0 !== a ? a : Script.default;
  this.scene = this.program = null;
}
Script.prototype = Object.create(THREE.Object3D.prototype);
Script.default = "this.initialize = function()\n{\n\t//TODO <INITIALIZATION CODE>\n};\n\nthis.update = function()\n{\n\t//TODO <UPDATE CODE>\n};\n\nthis.onMouseOver = function()\n{\n\t//TODO <MOUSE OVER CHILDREN CODE>\n};\n\nthis.onResize = function()\n{\n\t//TODO <RESIZE CODE>\n};";
Script.prototype.initialize = function() {
  for (var a = this;null !== a.parent;) {
    a = a.parent, a instanceof Scene ? this.scene = a : a instanceof Program && (this.program = a);
  }
  this.setCode(this.code);
  for (a = 0;a < this.children.length;a++) {
    this.children[a].initialize();
  }
  void 0 !== this.script.initialize && this.script.initialize.call(this);
};
Script.prototype.update = function() {
  if (void 0 !== this.script.onMouseOver) {
    var a = this.scene.raycaster.intersectObjects(this.children, !0);
    0 < a.length && this.script.onMouseOver.call(this, a);
  }
  void 0 !== this.script.update && this.script.update.call(this);
  for (a = 0;a < this.children.length;a++) {
    this.children[a].update();
  }
};
Script.prototype.resize = function() {
  void 0 !== this.script.onResize && this.script.onResize.call(this);
};
Script.prototype.appData = function(a) {
  void 0 !== this.script.onAppData && this.script.onAppData.call(this);
};
Script.prototype.setCode = function(a) {
  void 0 !== a && (this.code = a);
  try {
    var h = new Function("Keyboard, Mouse, self, program, scene", this.code);
    null !== this.program && (this.script = new h(this.program.keyboard, this.program.mouse, this, this.program, this.scene));
  } catch (l) {
    console.warn("nunuStudio: Error compiling script code", l), this.script = new function() {
    };
  }
};
Script.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.code = this.code;
  return a;
};
function PhysicsObject() {
  THREE.Object3D.call(this);
  this.name = "physics";
  this.type = "Physics";
  this.body = new CANNON.Body;
  this.body.type = CANNON.Body.DYNAMIC;
  this.body.mass = 1;
  this.world = null;
}
PhysicsObject.prototype = Object.create(THREE.Object3D.prototype);
PhysicsObject.prototype.initialize = function() {
  this.body.position.copy(this.position);
  this.body.quaternion.copy(this.quaternion);
  for (var a = this;null !== a.parent;) {
    a = a.parent, a instanceof Scene && (this.world = a.world, this.world.addBody(this.body));
  }
  for (a = 0;a < this.children.length;a++) {
    this.children[a].initialize();
  }
};
PhysicsObject.prototype.update = function() {
  this.position.copy(this.body.position);
  this.body.fixedRotation || this.quaternion.copy(this.body.quaternion);
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].update();
  }
};
PhysicsObject.prototype.addShape = function(a) {
  a instanceof CANNON.Shape && this.body.addShape(a);
};
PhysicsObject.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.body = {};
  a.object.body.type = this.body.type;
  a.object.body.mass = this.body.mass;
  a.object.body.linearDamping = this.body.linearDamping;
  a.object.body.angularDamping = this.body.angularDamping;
  a.object.body.allowSleep = this.body.allowSleep;
  a.object.body.sleepSpeedLimit = this.body.sleepSpeedLimit;
  a.object.body.sleepTimeLimit = this.body.sleepTimeLimit;
  a.object.body.collisionFilterGroup = this.body.collisionFilterGroup;
  a.object.body.collisionFilterMask = this.body.collisionFilterMask;
  a.object.body.fixedRotation = this.body.fixedRotation;
  a.object.body.shapes = [];
  for (var h = this.body.shapes, l = 0;l < h.length;l++) {
    var b = h[l], f = {};
    f.type = b.type;
    b.type === CANNON.Shape.types.SPHERE ? f.radius = b.radius : b.type === CANNON.Shape.types.BOX ? (f.halfExtents = {}, f.halfExtents.x = b.halfExtents.x, f.halfExtents.y = b.halfExtents.y, f.halfExtents.z = b.halfExtents.z) : b.type === CANNON.Shape.types.CONVEXPOLYHEDRON && (f.vertices = b.vertices, f.faces = b.faces);
    a.object.body.shapes[l] = f;
  }
  return a;
};
function SpineAnimation(a, h, l, b) {
  if (void 0 !== b) {
    var f = new spine.TextureAtlas(h, function(a) {
      for (var c = 0;c < b.length;c++) {
        if (b[c].name === a) {
          return a = new SpineTexture(b[c].texture), c = a.texture.image, c.width = 1024, c.height = 1024, a;
        }
      }
    });
  } else {
    b = [], f = new spine.TextureAtlas(h, function(a) {
      var c = new SpineTexture(new Texture(new Image(l + "\\" + a))), f = c.texture.image;
      f.width = 1024;
      f.height = 1024;
      b.push({name:a, texture:c.texture});
      return c;
    });
  }
  f = new spine.AtlasAttachmentLoader(f);
  f = (new spine.SkeletonJson(f)).readSkeletonData(a);
  THREE.Mesh.call(this);
  this.zOffset = .1;
  this.skeleton = new spine.Skeleton(f);
  f = new spine.AnimationStateData(f);
  this.state = new spine.AnimationState(f);
  this.batcher = new spine.threejs.MeshBatcher(this);
  f = new THREE.MeshBasicMaterial;
  f.side = THREE.DoubleSide;
  f.transparent = !0;
  f.name = "spine";
  f.alphaTest = .5;
  this.material = f;
  this.json = a;
  this.atlas = h;
  this.textures = b;
  this.name = "spine";
  this.type = "SpineAnimation";
  this.scale.set(.01, .01, .01);
  this.frustumCulled = !1;
  this.castShadow = this.receiveShadow = !0;
  this.clock = new THREE.Clock;
}
SpineAnimation.prototype = Object.create(THREE.Mesh.prototype);
SpineAnimation.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
SpineAnimation.prototype.update = function() {
  var a = this.state, h = this.skeleton;
  a.update(this.clock.getDelta());
  a.apply(h);
  h.updateWorldTransform();
  this.updateGeometry();
  for (a = 0;a < this.children.length;a++) {
    this.children[a].update();
  }
};
SpineAnimation.prototype.getAnimations = function() {
  return this.state.data.skeletonData.animations;
};
SpineAnimation.prototype.setAnimation = function(a, h) {
  try {
    this.state.setAnimation(a, h, !0);
  } catch (l) {
  }
};
SpineAnimation.prototype.getSkins = function() {
  return this.state.data.skeletonData.skins;
};
SpineAnimation.prototype.updateGeometry = function() {
  var a, h, l = this.skeleton.drawOrder, b = 0, f = this.batcher;
  f.begin();
  for (var k = 0, c = l.length;k < c;k++) {
    a = l[k];
    h = a.getAttachment();
    var g;
    if (h instanceof spine.RegionAttachment) {
      g = h, a = g.updateWorldVertices(a, !1), h = SpineAnimation.QUAD_TRIANGLES, g = g.region.renderObject.texture;
    } else {
      if (h instanceof spine.MeshAttachment) {
        g = h, a = g.updateWorldVertices(a, !1), h = g.triangles, g = g.region.renderObject.texture;
      } else {
        continue;
      }
    }
    if (null !== g) {
      if (!this.material.map) {
        var e = this.material;
        e.map = g.texture;
        e.needsUpdate = !0;
      }
      f.batch(a, h, b);
      b += this.zOffset;
    }
  }
  f.end();
};
SpineAnimation.prototype.toJSON = function(a) {
  var h = this.geometry, l = this.material;
  this.material = this.geometry = void 0;
  var b = [], f = this;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, c) {
    for (c = 0;c < f.textures.length;c++) {
      var g = f.textures[c].texture.toJSON(a);
      b.push({name:f.textures[c].name, texture:g.uuid});
    }
  });
  a.object.json = this.json;
  a.object.atlas = this.atlas;
  a.object.textures = b;
  this.geometry = h;
  this.material = l;
  return a;
};
function SpineTexture(a) {
  spine.Texture.call(this, a.image);
  this.texture = a;
  this.texture.flipY = !1;
}
SpineTexture.prototype = Object.create(spine.Texture.prototype);
SpineTexture.prototype.setFilters = function(a, h) {
  this.texture.minFilter = SpineTexture.getTextureFilter(a);
  this.texture.magFilter = SpineTexture.getTextureFilter(h);
};
SpineTexture.prototype.setWraps = function(a, h) {
  this.texture.wrapS = SpineTexture.getTextureWrap(a);
  this.texture.wrapT = SpineTexture.getTextureWrap(h);
};
SpineTexture.prototype.dispose = function() {
  this.texture.dispose();
};
SpineTexture.getTextureFilter = function(a) {
  return a === spine.TextureFilter.Linear ? THREE.LinearFilter : a === spine.TextureFilter.MipMap || a === spine.TextureFilter.MipMapLinearLinear ? THREE.LinearMipMapLinearFilter : a === spine.TextureFilter.MipMapLinearNearest ? THREE.LinearMipMapNearestFilter : a === spine.TextureFilter.MipMapNearestLinear ? THREE.NearestMipMapLinearFilter : a === spine.TextureFilter.MipMapNearestNearest ? THREE.NearestMipMapNearestFilter : a === spine.TextureFilter.Nearest ? THREE.NearestFilter : null;
};
SpineTexture.getTextureWrap = function(a) {
  if (a === spine.TextureWrap.ClampToEdge) {
    return THREE.ClampToEdgeWrapping;
  }
  if (a === spine.TextureWrap.MirroredRepeat) {
    return THREE.MirroredRepeatWrapping;
  }
  if (a === spine.TextureWrap.Repeat) {
    return THREE.RepeatWrapping;
  }
};
function ParticleEmitter(a, h) {
  this.clock = new THREE.Clock;
  this.group = void 0 !== a ? new SPE.Group(a) : new SPE.Group({texture:{value:null}, maxParticleCount:2E3, blending:THREE.AdditiveBlending, fog:!1, depthWrite:!1, depthTest:!0, transparent:!1, hasPerspective:!0});
  THREE.Points.call(this, this.group.geometry, this.group.material);
  this.type = "ParticleEmiter";
  this.name = "particle";
  this.frustumCulled = !1;
  a = this.group;
  Object.defineProperties(this, {texture:{get:function() {
    return a.texture;
  }, set:function(h) {
    a.texture = h;
  }}});
  this.emitter = void 0 !== h ? new SPE.Emitter(h) : new SPE.Emitter({particleCount:2E3, type:SPE.distributions.BOX, maxAge:{value:3, spread:0}, velocity:{value:new THREE.Vector3(0, 25, 0), spread:new THREE.Vector3(10, 10, 10)}, acceleration:{value:new THREE.Vector3(0, -10, 0), spread:new THREE.Vector3(10, 0, 10)}, color:{value:[new THREE.Color(1, 1, 1)], spread:[new THREE.Vector3(0, 0, 0)]}});
  this.group.addEmitter(this.emitter);
  this.raycast = function() {
    return null;
  };
}
ParticleEmitter.prototype = Object.create(THREE.Points.prototype);
ParticleEmitter.prototype.initialize = function() {
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].initialize();
  }
  this.clock.start();
};
ParticleEmitter.prototype.update = function() {
  this.group.tick(this.clock.getDelta());
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].update();
  }
};
ParticleEmitter.prototype.dispose = function() {
  this.group.texture.dispose();
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].dispose();
  }
};
ParticleEmitter.prototype.updateMatrix = function() {
  this.matrix.makeRotationFromQuaternion(this.quaternion);
  this.matrix.scale(this.scale);
  this.matrix.setPosition(this.position);
  this.matrixWorldNeedsUpdate = !0;
};
ParticleEmitter.prototype.toJSON = function(a) {
  var h = this.material, l = this.geometry;
  this.geometry = this.material = void 0;
  var b = this.group.texture;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, h) {
    b = b.toJSON(a);
  });
  this.material = h;
  this.geometry = l;
  a.object.group = {};
  a.object.group.texture = {};
  a.object.group.texture.value = b.uuid;
  a.object.group.textureFrames = this.group.textureFrames;
  a.object.group.textureFrameCount = this.group.textureFrameCount;
  a.object.group.textureLoop = this.group.textureLoop;
  a.object.group.hasPerspective = this.group.hasPerspective;
  a.object.group.colorize = this.group.colorize;
  a.object.group.maxParticleCount = this.group.maxParticleCount;
  a.object.group.blending = this.group.blending;
  a.object.group.scale = this.group.scale;
  a.object.group.depthWrite = this.group.depthWrite;
  a.object.group.depthTest = this.group.depthTest;
  a.object.group.fog = this.group.fog;
  a.object.emitter = {};
  a.object.emitter.uuid = this.emitter.uuid;
  a.object.emitter.direction = this.emitter.direction;
  a.object.emitter.particleCount = this.emitter.particleCount;
  a.object.emitter.duration = this.emitter.duration;
  a.object.emitter.type = this.emitter.type;
  a.object.emitter.maxAge = {};
  a.object.emitter.maxAge.value = this.emitter.maxAge.value;
  a.object.emitter.maxAge.spread = this.emitter.maxAge.spread;
  a.object.emitter.position = {};
  a.object.emitter.position.value = this.emitter.position.value;
  a.object.emitter.position.spread = this.emitter.position.spread;
  a.object.emitter.velocity = {};
  a.object.emitter.velocity.value = this.emitter.velocity.value;
  a.object.emitter.velocity.spread = this.emitter.velocity.spread;
  a.object.emitter.acceleration = {};
  a.object.emitter.acceleration.value = this.emitter.acceleration.value;
  a.object.emitter.acceleration.spread = this.emitter.acceleration.spread;
  a.object.emitter.wiggle = {};
  a.object.emitter.wiggle.value = this.emitter.wiggle.value;
  a.object.emitter.wiggle.spread = this.emitter.wiggle.spread;
  a.object.emitter.opacity = {};
  a.object.emitter.opacity.value = this.emitter.opacity.value;
  a.object.emitter.opacity.spread = this.emitter.opacity.spread;
  a.object.emitter.size = {};
  a.object.emitter.size.value = this.emitter.size.value;
  a.object.emitter.size.spread = this.emitter.size.spread;
  a.object.emitter.angle = {};
  a.object.emitter.angle.value = this.emitter.angle.value;
  a.object.emitter.angle.spread = this.emitter.angle.spread;
  a.object.emitter.color = {};
  a.object.emitter.color.value = this.emitter.color.value;
  a.object.emitter.color.spread = this.emitter.color.spread;
  return a;
};
function Bone() {
  THREE.Bone.call(this);
  this.name = "bone";
}
Bone.prototype = Object.create(THREE.Bone.prototype);
function Container() {
  THREE.Object3D.call(this);
  this.name = "container";
  this.type = "Group";
}
Container.prototype = Object.create(THREE.Object3D.prototype);
function Program(a) {
  THREE.Object3D.call(this);
  ResourceManager.call(this);
  this.type = "Program";
  this.matrixAutoUpdate = !1;
  this.app = null;
  this.name = void 0 !== a ? a : "program";
  this.author = this.description = "";
  this.version = "0";
  this.vr = this.lockPointer = !1;
  this.vrScale = 1;
  this.antialiasing = !1;
  this.shadows = !0;
  this.shadowsType = THREE.PCFSoftShadowMap;
  this.scene = this.canvas = this.renderer = this.mouse = this.keyboard = this.defaultCamera = this.defaultScene = null;
  this.useVr = !1;
  this.vrControls = this.vrEffect = null;
}
Program.prototype = Object.create(THREE.Object3D.prototype);
Program.prototype.getMaterialByName = ResourceManager.prototype.getMaterialByName;
Program.prototype.addMaterial = ResourceManager.prototype.addMaterial;
Program.prototype.removeMaterial = ResourceManager.prototype.removeMaterial;
Program.prototype.getTextureByName = ResourceManager.prototype.getTextureByName;
Program.prototype.addTexture = ResourceManager.prototype.addTexture;
Program.prototype.removeTexture = ResourceManager.prototype.removeTexture;
Program.prototype.getFontByName = ResourceManager.prototype.getFontByName;
Program.prototype.addFont = ResourceManager.prototype.addFont;
Program.prototype.removeFont = ResourceManager.prototype.removeFont;
Program.prototype.getAudioByName = ResourceManager.prototype.getAudioByName;
Program.prototype.addAudio = ResourceManager.prototype.addAudio;
Program.prototype.removeAudio = ResourceManager.prototype.removeAudio;
Program.prototype.initialize = function() {
  null === this.mouse && (this.mouse = new Mouse);
  null === this.keyboard && (this.keyboard = new keyboard);
  if (null !== this.defaultScene) {
    for (var a = 0;a < this.children.length;a++) {
      if (this.children[a].uuid === this.defaultScene) {
        this.setScene(this.children[a]);
        break;
      }
    }
  } else {
    0 < this.children.length && this.setScene(this.children[0]);
  }
};
Program.prototype.setMouseKeyboard = function(a, h) {
  this.mouse = a;
  this.keyboard = h;
};
Program.prototype.setRenderer = function(a) {
  this.renderer = a;
  this.canvas = a.domElement;
};
Program.prototype.displayVR = function() {
  if (this.vr) {
    try {
      this.useVr = !0, this.vrEffect = new THREE.VREffect(this.renderer), this.vrEffect.setFullScreen(!0);
    } catch (a) {
      this.useVr = !1, this.vrEffect = null, console.warn("nunuStudio: Failed to enter in VR mode", a);
    }
  }
};
Program.prototype.exitVR = function() {
  this.vr && (this.useVr = !1, null != this.vrEffect && (this.vrEffect.setFullScreen(!1), this.vrEffect.dispose(), this.vrEffect = null));
};
Program.prototype.update = function() {
  this.scene.update();
};
Program.prototype.render = function(a) {
  if (this.useVr) {
    for (var h = 0;h < this.scene.cameras.length;h++) {
      var l = this.scene.cameras[h];
      this.vrEffect.render(this.scene, l);
    }
  } else {
    var b = a.domElement.width, f = a.domElement.height;
    a.setScissorTest(!0);
    for (h = 0;h < this.scene.cameras.length;h++) {
      l = this.scene.cameras[h], l.clearColor && a.clearColor(), l.clearDepth && a.clearDepth(), a.setViewport(b * l.offset.x, f * l.offset.y, b * l.viewport.x, f * l.viewport.y), a.setScissor(b * l.offset.x, f * l.offset.y, b * l.viewport.x, f * l.viewport.y), a.render(this.scene, l);
    }
    a.setScissorTest(!1);
  }
};
Program.prototype.resize = function(a, h) {
  for (var l = 0;l < this.scene.cameras.length;l++) {
    this.scene.cameras[l].aspect = a / h, this.scene.cameras[l].updateProjectionMatrix();
  }
  this.traverse(function(a) {
    a instanceof Script && a.resize();
  });
};
Program.prototype.setScene = function(a) {
  a instanceof Scene ? this.scene = a : "string" === typeof a && (this.scene = this.getObjectByName(a));
  null !== this.scene && (this.scene.initialize(), 0 === this.scene.cameras.length && this.scene.cameras.push(this.defaultCamera));
};
Program.prototype.remove = function(a) {
  var h = this.children.indexOf(a);
  -1 < h && (this.children.splice(h, 1), a.parent = null);
  0 === this.children.length && (this.scene = null);
};
Program.prototype.add = function(a) {
  a instanceof Scene && (this.children.push(a), a.parent = this, 1 === this.children.length && (this.scene = this.children[0]));
};
Program.prototype.clone = function() {
  return (new ObjectLoader).parse(this.toJSON());
};
Program.prototype.setInitialScene = function(a) {
  this.defaultScene = a.uuid;
};
Program.prototype.addDefaultScene = function(a) {
  void 0 === a && (a = new THREE.MeshStandardMaterial({roughness:.6, metalness:.2}), a.name = "default");
  var h = new Scene, l = new Sky;
  l.autoUpdate = !1;
  h.add(l);
  var l = new THREE.BoxBufferGeometry(1, 1, 1), b = new Mesh(l, a);
  b.receiveShadow = !0;
  b.castShadow = !0;
  b.name = "box";
  h.add(b);
  b = new Mesh(l, a);
  b.scale.set(20, 1, 20);
  b.position.set(0, -1, 0);
  b.receiveShadow = !0;
  b.castShadow = !0;
  b.name = "ground";
  h.add(b);
  this.add(h);
};
Program.prototype.dispose = function() {
  for (var a in this.geometries) {
    this.geometries[a].dispose();
  }
  for (a in this.textures) {
    this.textures[a].dispose();
  }
  for (a in this.materials) {
    this.materials[a].dispose();
  }
  for (a = 0;a < this.children.length;a++) {
    this.children[a].dispose();
  }
};
Program.prototype.receiveDataApp = function(a) {
  var h = !1;
  this.traverse(function(l) {
    l instanceof Script && null !== l.script && void 0 !== l.script.onAppData && (l.appData(a), h = !0);
  });
  h || ("object" === typeof a ? console.warn("nunuStudio: No script with onAppData found", JSON.stringify(a)) : console.warn("nunuStudio: No script with onAppData found", a));
};
Program.prototype.sendDataApp = function(a) {
  if (null !== this.app) {
    if (void 0 !== this.app.onDataReceived) {
      this.app.onDataReceived(a);
    } else {
      console.warn("nunuStudio: App data communication", a);
    }
  } else {
    "object" === typeof a ? console.warn("nunuStudio: No app available", JSON.stringify(a)) : console.warn("nunuStudio: No app available", a);
  }
};
Program.prototype.toJSON = function(a, h) {
  var l = this;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, f) {
    if (!1 !== h) {
      f = l.textures;
      for (var b in f) {
        var c = f[b];
        void 0 === a.textures[c.uuid] && (a.textures[c.uuid] = c.toJSON(a));
      }
      f = l.materials;
      for (b in f) {
        c = f[b], void 0 === a.materials[c.uuid] && (a.materials[c.uuid] = c.toJSON(a));
      }
      f = l.fonts;
      for (b in f) {
        c = f[b], void 0 === a.fonts[c.uuid] && (a.fonts[c.uuid] = c.toJSON(a));
      }
      f = l.audio;
      for (b in f) {
        c = f[b], void 0 === a.audio[c.uuid] && (a.audio[c.uuid] = c.toJSON(a));
      }
    }
  });
  null !== this.defaultScene && (a.object.defaultScene = this.defaultScene);
  a.object.author = this.author;
  a.object.description = this.description;
  a.object.version = this.version;
  a.object.lockPointer = this.lockPointer;
  a.object.vr = this.vr;
  a.object.vrScale = this.vrScale;
  a.object.antialiasing = this.antialiasing;
  a.object.shadows = this.shadows;
  a.object.shadowsType = this.shadowsType;
  return a;
};
function Scene() {
  THREE.Scene.call(this);
  this.name = "scene";
  this.matrixAutoUpdate = !1;
  this.world = new CANNON.World;
  this.world.defaultContactMaterial.contactEquationStiffness = 1E9;
  this.world.defaultContactMaterial.contactEquationRelaxation = 4;
  this.world.quatNormalizeSkip = 0;
  this.world.quatNormalizeFast = !1;
  this.world.gravity.set(0, -9.8, 0);
  this.world.broadphase = new CANNON.NaiveBroadphase;
  this.world.solver = new CANNON.SplitSolver(new CANNON.GSSolver);
  this.world.solver.tolerance = .05;
  this.world.solver.iterations = 7;
  this.cameras = [];
  this.clock = new THREE.Clock;
  this.raycaster = new THREE.Raycaster;
  this.canvas = this.program = null;
  this.mouse = new THREE.Vector2(0, 0);
}
Scene.prototype = Object.create(THREE.Scene.prototype);
Scene.prototype.initialize = function() {
  this.program = this.parent;
  this.canvas = this.parent.canvas;
  this.clock.start();
  for (var a = 0;a < this.children.length;a++) {
    this.children[a].initialize();
  }
};
Scene.prototype.update = function() {
  this.mouse.set(this.program.mouse.position.x / this.canvas.width * 2 - 1, -2 * this.program.mouse.position.y / this.canvas.height + 1);
  0 < this.cameras.length && this.raycaster.setFromCamera(this.mouse, this.cameras[0]);
  var a = this.clock.getDelta();
  this.world.step(.05 > a ? a : .05);
  for (a = 0;a < this.children.length;a++) {
    this.children[a].update();
  }
};
Scene.prototype.getCamera = function(a, h) {
  void 0 === h && (h = this);
  if (a === h.uuid) {
    return h;
  }
  h = h.children;
  for (var l = 0;l < h.length;l++) {
    var b = this.getCamera(a, h[l]);
    if (null !== b) {
      return b;
    }
  }
  return null;
};
Scene.prototype.addCamera = function(a) {
  this.cameras.push(a);
  this.updateCameraOrder();
};
Scene.prototype.updateCameraOrder = function() {
  this.cameras.sort(function(a, h) {
    return a.order < h.order;
  });
};
Scene.prototype.removeCamera = function(a) {
  a = this.cameras.indexOf(a);
  -1 < a && this.cameras.splice(a, 1);
};
Scene.prototype.setFogMode = function(a) {
  var h = null !== this.fog ? this.fog.color.getHex() : "#FFFFFF";
  a === THREE.Fog.LINEAR ? this.fog = new THREE.Fog(h, 5, 20) : a === THREE.Fog.EXPONENTIAL ? this.fog = new THREE.FogExp2(h, .01) : a === THREE.Fog.NONE && (this.fog = null);
};
Scene.prototype.toJSON = function(a) {
  a = THREE.Scene.prototype.toJSON.call(this, a);
  a.object.cameras = [];
  for (var h = 0;h < this.cameras.length;h++) {
    a.object.cameras.push(this.cameras[h].uuid);
  }
  a.object.world = {};
  a.object.world.gravity = this.world.gravity;
  a.object.world.quatNormalizeSkip = this.world.quatNormalizeSkip;
  a.object.world.quatNormalizeFast = this.world.quatNormalizeFast;
  a.object.world.solver = {};
  a.object.world.solver.tolerance = this.world.solver.tolerance;
  a.object.world.solver.iterations = this.world.solver.iterations;
  return a;
};
function Base64Utils() {
}
Base64Utils.removeHeader = function(a) {
  return a.slice(a.search(";base64,") + 8);
};
Base64Utils.fromArraybuffer = function(a) {
  var h = "";
  a = new Uint8Array(a);
  for (var l = a.byteLength % 3, b = a.byteLength - l, f, k, c, g, e = 0;e < b;e += 3) {
    g = a[e] << 16 | a[e + 1] << 8 | a[e + 2], f = (g & 16515072) >> 18, k = (g & 258048) >> 12, c = (g & 4032) >> 6, g &= 63, h += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[f] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[k] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[c] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[g];
  }
  1 === l ? (g = a[b], h += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(g & 252) >> 2] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(g & 3) << 4] + "==") : 2 === l && (g = a[b] << 8 | a[b + 1], h += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(g & 64512) >> 10] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(g & 1008) >> 4] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(g & 15) << 2] + 
  "=");
  return h;
};
Base64Utils.fromBinaryString = function(a) {
  for (var h = "", l = a.length % 3, b = a.length - l, f, k, c, g = 0;g < b;g += 3) {
    f = a.charCodeAt(g) & 255, k = a.charCodeAt(g + 1), c = a.charCodeAt(g + 2), h += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(f >> 2), h += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((f & 3) << 4 | (k & 240) >> 4), h += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((k & 15) << 2 | (c & 192) >> 6), h += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(c & 63);
  }
  1 === l ? (f = a.charCodeAt(g) & 255, h += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(f >> 2), h += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((f & 3) << 4), h += "==") : 2 === l && (f = a.charCodeAt(g) & 255, k = a.charCodeAt(g + 1), h += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(f >> 2), h += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((f & 3) << 4 | (k & 240) >> 4), h += 
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((k & 15) << 2), h += "=");
  return h;
};
function ArraybufferUtils() {
}
ArraybufferUtils.fromBinaryString = function(a) {
  for (var h = a.length, l = new ArrayBuffer(h), b = new Uint8Array(l), f = 0;f < h;f++) {
    b[f] = a.charCodeAt(f);
  }
  return l;
};
ArraybufferUtils.fromBase64 = function(a) {
  for (var h = a.length / 4 * 3, l = new ArrayBuffer(h), b = new Uint8Array(l), f, k, c, g, e = 0, p = 0;e < h;e += 3) {
    f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(p++)), k = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(p++)), c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(p++)), g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(p++)), b[e] = f << 2 | k >> 4, 64 !== c && (b[e + 1] = (k & 15) << 4 | c >> 2), 64 !== g && (b[e + 2] = (c & 3) << 6 | g);
  }
  return l;
};
ArraybufferUtils.fromBuffer = function(a) {
  for (var h = new ArrayBuffer(a.length), l = new Uint8Array(h), b = 0;b < a.length;b++) {
    l[b] = a[b];
  }
  return h;
};
function MathUtils() {
}
MathUtils.pi2 = 2 * Math.PI;
MathUtils.pid3 = Math.PI / 3;
MathUtils.pid2 = Math.PI / 2;
function ObjectUtils() {
}
ObjectUtils.getFonts = function(a, h) {
  void 0 === h && (h = []);
  a.traverse(function(a) {
    a.font instanceof Font && void 0 === h[a.font.uuid] && (h[a.font.uuid] = a.font);
  });
  return h;
};
ObjectUtils.getAudio = function(a, h) {
  void 0 === h && (h = []);
  a.traverse(function(a) {
    a.audio instanceof Audio && void 0 === h[a.audio.uuid] && (h[a.audio.uuid] = a.audio);
  });
  return h;
};
ObjectUtils.getMaterials = function(a, h) {
  function l(a) {
    void 0 === h[a.uuid] && (h[a.uuid] = a);
  }
  void 0 === h && (h = []);
  a.traverse(function(a) {
    if (!(void 0 === a.material || a.hidden || a instanceof ParticleEmitter || a instanceof Sky || a instanceof SpineAnimation)) {
      if (a.material instanceof THREE.Material) {
        l(a.material);
      } else {
        if (a.material instanceof THREE.MultiMaterial) {
          for (var b = a.material.materials, h = 0;h < b.length;h++) {
            l(b[h]);
          }
        }
      }
      if (void 0 !== a.materials) {
        for (h = 0;h < a.materials.length;h++) {
          l(a.materials[h]);
        }
      }
    }
  });
  return h;
};
ObjectUtils.getTextures = function(a, h) {
  function l(a) {
    b(a.map);
    b(a.bumpMap);
    b(a.normalMap);
    b(a.displacementMap);
    b(a.specularMap);
    b(a.emissiveMap);
    b(a.alphaMap);
    b(a.roughnessMap);
    b(a.metalnessMap);
  }
  function b(a) {
    null != a && void 0 === h[a.uuid] && (h[a.uuid] = a);
  }
  void 0 === h && (h = []);
  a.traverse(function(a) {
    if (void 0 !== a.material) {
      if (a.material instanceof THREE.Material) {
        l(a.material);
      } else {
        if (a.material instanceof THREE.MultiMaterial) {
          for (var f = a.material.materials, c = 0;c < f.length;c++) {
            l(f[c]);
          }
        }
      }
    }
    void 0 !== a.texture && b(a.texture);
  });
  return h;
};
ObjectUtils.getScene = function(a) {
  for (;null !== a.parent;) {
    if (a = a.parent, a instanceof Scene) {
      return a;
    }
  }
  return null;
};
ObjectUtils.getRoot = function(a) {
  for (;null !== a.parent;) {
    a = a.parent;
  }
  return a;
};
ObjectUtils.setMatrixAutoUpdate = function(a, h) {
  a.matrixAutoUpdate = h;
  a.traverse(function(a) {
    a.matrixAutoUpdate = h;
  });
};
ObjectUtils.setShadowReceiving = function(a, h) {
  a.receiveShadow = h;
  a.traverse(function(a) {
    a.receiveShadow = h;
  });
};
ObjectUtils.setShadowCasting = function(a, h) {
  a.castShadow = h;
  a.traverse(function(a) {
    a.castShadow = h;
  });
};
ObjectUtils.isChildOf = function(a, h) {
  for (var l = 0;l < a.children.length;l++) {
    if (a.children[l] === h || ObjectUtils.isChildOf(a.children[l], h)) {
      return !0;
    }
  }
  return !1;
};
function BufferUtils() {
}
BufferUtils.fromArrayBuffer = function(a) {
  var h = new Buffer(a.byteLength);
  a = new Uint8Array(a);
  for (var l = 0;l < h.length;l++) {
    h[l] = a[l];
  }
  return h;
};
function NunuApp(a) {
  this.renderer = this.program = null;
  this.vr = this.fullscreen = !1;
  void 0 === a ? (this.canvas = document.createElement("canvas"), this.canvas.style.position = "absolute", this.canvas.style.left = "0px", this.canvas.style.top = "0px", this.canvas.style.width = window.innerWidth + "px", this.canvas.style.height = window.innerHeight + "px", this.canvas.width = window.innerWidth, this.canvas.height = window.innerHeight, document.body.appendChild(this.canvas), this.canvasResize = !0) : (this.canvas = a, this.canvasResize = !1);
  a = this.canvas;
  this.lockMouse = function() {
    a.requestPointerLock ? a.requestPointerLock() : a.mozRequestPointerLock ? a.mozRequestPointerLock() : a.webkitRequestPointerLock && a.webkitRequestPointerLock();
  };
}
NunuApp.prototype.loadRunProgram = function(a, h, l) {
  var b = new ObjectLoader, f = this;
  FileSystem.readFile(a, !1, function(a) {
    f.program = b.parse(JSON.parse(a));
    f.run();
    void 0 !== h && h();
  }, l);
};
NunuApp.prototype.loadProgram = function(a) {
  var h = new ObjectLoader;
  a = FileSystem.readFile(a);
  this.program = h.parse(JSON.parse(a));
};
NunuApp.prototype.run = function() {
  if (null === this.program) {
    console.warn("nunuStudio: no program is loaded [app.loadPogram(fname)]");
  } else {
    this.renderer = new THREE.WebGLRenderer({canvas:this.canvas, antialias:!0});
    this.renderer.autoClear = !1;
    this.renderer.shadowMap.enabled = !0;
    this.renderer.shadowMap.type = THREE.PCFShadowMap;
    this.renderer.setSize(this.canvas.width, this.canvas.height);
    this.keyboard = new Keyboard;
    this.mouse = new Mouse;
    this.mouse.setCanvas(this.canvas);
    this.program.app = this;
    this.program.defaultCamera = new PerspectiveCamera(60, this.canvas.width / this.canvas.height, .1, 1E6);
    this.program.defaultCamera.position.set(0, 5, -5);
    this.program.setRenderer(this.renderer);
    this.program.setMouseKeyboard(this.mouse, this.keyboard);
    this.program.initialize();
    this.program.resize(this.canvas.width, this.canvas.height);
    this.program.lockPointer && this.canvas.addEventListener("click", this.lockMouse, !1);
    var a = this, h = function() {
      null !== a.program && (requestAnimationFrame(h), a.update());
    };
    h();
  }
};
NunuApp.prototype.update = function() {
  this.mouse.update();
  this.keyboard.update();
  this.program.update();
  this.program.render(this.renderer);
};
NunuApp.prototype.exit = function() {
  this.program.lockPointer && this.canvas.removeEventListener("click", this.lockMouse, !1);
  null !== this.program && (this.program.dispose(), this.program = null);
  this.mouse.dispose();
  this.keyboard.dispose();
  if (void 0 !== this.onExit) {
    this.onExit();
  }
};
NunuApp.prototype.resize = function() {
  null !== this.canvas && this.canvasResize && (this.canvas.style.width = window.innerWidth + "px", this.canvas.style.height = window.innerHeight + "px", this.canvas.width = window.innerWidth, this.canvas.height = window.innerHeight);
  null !== this.program && null !== this.renderer && (this.renderer.setSize(this.canvas.width, this.canvas.height), this.program.resize(this.canvas.width, this.canvas.height));
};
NunuApp.prototype.sendData = function(a) {
  null !== this.program && this.program.receiveDataApp(a);
};
NunuApp.prototype.setOnDataReceived = function(a) {
  this.onDataReceived = a;
};
NunuApp.prototype.setOnExit = function(a) {
  this.onExit = a;
};
NunuApp.prototype.vrAvailable = function() {
  return this.program.vr && Nunu.webvrAvailable();
};
NunuApp.prototype.toggleVR = function() {
  this.vrAvailable() ? this.vr ? (this.program.exitVR(), this.vr = !1) : (this.program.displayVR(), this.vr = !0) : console.warn("nunuStudio: loaded program is not VR enabled");
};
NunuApp.prototype.setFullscreen = function(a, h) {
  (this.fullscreen = void 0 !== a ? a : !this.fullscreen) ? (void 0 === h && (h = this.canvas), h.requestFullscreen = h.requestFullscreen || h.mozRequestFullScreen || h.webkitRequestFullscreen || h.msRequestFullscreen, h.requestFullscreen && h.requestFullscreen()) : (document.exitFullscreen = document.exitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen, document.exitFullscreen && document.exitFullscreen());
};

