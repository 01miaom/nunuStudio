/*


 opentype.js:
   license: MIT (http://opensource.org/licenses/MIT)
   author: Frederik De Bleser <frederik@debleser.be>
   version: 0.6.5

 tiny-inflate:
   license: MIT (http://opensource.org/licenses/MIT)
   author: Devon Govett <devongovett@gmail.com>
   maintainers: devongovett <devongovett@gmail.com>
   homepage: https://github.com/devongovett/tiny-inflate
   version: 1.0.2

 This header is generated by licensify (https://github.com/twada/licensify)
 Determine if an object is a Buffer

 @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 @license  MIT
 LeapJS v0.6.4                                                  
 http://github.com/leapmotion/leapjs/                                        

 Copyright 2013 LeapMotion, Inc. and other contributors                      
 Released under the Apache-2.0 license                                     
 http://github.com/leapmotion/leapjs/blob/master/LICENSE.txt                 
 chevrotain - v4.6.0 */
var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.arrayIteratorImpl = function(a) {
  var d = 0;
  return function() {
    return d < a.length ? {done:!1, value:a[d++]} : {done:!0};
  };
};
$jscomp.arrayIterator = function(a) {
  return {next:$jscomp.arrayIteratorImpl(a)};
};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.SIMPLE_FROUND_POLYFILL = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, d, g) {
  a != Array.prototype && a != Object.prototype && (a[d] = g.value);
};
$jscomp.getGlobal = function(a) {
  return "undefined" != typeof window && window === a ? a : "undefined" != typeof global && null != global ? global : a;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
};
$jscomp.SymbolClass = function(a, d) {
  this.$jscomp$symbol$id_ = a;
  $jscomp.defineProperty(this, "description", {configurable:!0, writable:!0, value:d});
};
$jscomp.SymbolClass.prototype.toString = function() {
  return this.$jscomp$symbol$id_;
};
$jscomp.Symbol = function() {
  function a(g) {
    if (this instanceof a) {
      throw new TypeError("Symbol is not a constructor");
    }
    return new $jscomp.SymbolClass($jscomp.SYMBOL_PREFIX + (g || "") + "_" + d++, g);
  }
  var d = 0;
  return a;
}();
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var a = $jscomp.global.Symbol.iterator;
  a || (a = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("Symbol.iterator"));
  "function" != typeof Array.prototype[a] && $jscomp.defineProperty(Array.prototype, a, {configurable:!0, writable:!0, value:function() {
    return $jscomp.iteratorPrototype($jscomp.arrayIteratorImpl(this));
  }});
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.initSymbolAsyncIterator = function() {
  $jscomp.initSymbol();
  var a = $jscomp.global.Symbol.asyncIterator;
  a || (a = $jscomp.global.Symbol.asyncIterator = $jscomp.global.Symbol("Symbol.asyncIterator"));
  $jscomp.initSymbolAsyncIterator = function() {
  };
};
$jscomp.iteratorPrototype = function(a) {
  $jscomp.initSymbolIterator();
  a = {next:a};
  a[$jscomp.global.Symbol.iterator] = function() {
    return this;
  };
  return a;
};
$jscomp.checkStringArgs = function(a, d, g) {
  if (null == a) {
    throw new TypeError("The 'this' value for String.prototype." + g + " must not be null or undefined");
  }
  if (d instanceof RegExp) {
    throw new TypeError("First argument to String.prototype." + g + " must not be a regular expression");
  }
  return a + "";
};
$jscomp.polyfill = function(a, d, g, h) {
  if (d) {
    g = $jscomp.global;
    a = a.split(".");
    for (h = 0; h < a.length - 1; h++) {
      var e = a[h];
      e in g || (g[e] = {});
      g = g[e];
    }
    a = a[a.length - 1];
    h = g[a];
    d = d(h);
    d != h && null != d && $jscomp.defineProperty(g, a, {configurable:!0, writable:!0, value:d});
  }
};
$jscomp.polyfill("String.prototype.endsWith", function(a) {
  return a ? a : function(a, g) {
    var d = $jscomp.checkStringArgs(this, a, "endsWith");
    a += "";
    void 0 === g && (g = d.length);
    g = Math.max(0, Math.min(g | 0, d.length));
    for (var e = a.length; 0 < e && 0 < g;) {
      if (d[--g] != a[--e]) {
        return !1;
      }
    }
    return 0 >= e;
  };
}, "es6", "es3");
$jscomp.owns = function(a, d) {
  return Object.prototype.hasOwnProperty.call(a, d);
};
$jscomp.assign = "function" == typeof Object.assign ? Object.assign : function(a, d) {
  for (var g = 1; g < arguments.length; g++) {
    var h = arguments[g];
    if (h) {
      for (var e in h) {
        $jscomp.owns(h, e) && (a[e] = h[e]);
      }
    }
  }
  return a;
};
$jscomp.polyfill("Object.assign", function(a) {
  return a || $jscomp.assign;
}, "es6", "es3");
$jscomp.polyfill("String.prototype.repeat", function(a) {
  return a ? a : function(a) {
    var d = $jscomp.checkStringArgs(this, null, "repeat");
    if (0 > a || 1342177279 < a) {
      throw new RangeError("Invalid count value");
    }
    a |= 0;
    for (var h = ""; a;) {
      if (a & 1 && (h += d), a >>>= 1) {
        d += d;
      }
    }
    return h;
  };
}, "es6", "es3");
$jscomp.polyfill("Number.EPSILON", function(a) {
  return Math.pow(2, -52);
}, "es6", "es3");
$jscomp.iteratorFromArray = function(a, d) {
  $jscomp.initSymbolIterator();
  a instanceof String && (a += "");
  var g = 0, h = {next:function() {
    if (g < a.length) {
      var e = g++;
      return {value:d(e, a[e]), done:!1};
    }
    h.next = function() {
      return {done:!0, value:void 0};
    };
    return h.next();
  }};
  h[Symbol.iterator] = function() {
    return h;
  };
  return h;
};
$jscomp.polyfill("Array.prototype.keys", function(a) {
  return a ? a : function() {
    return $jscomp.iteratorFromArray(this, function(a) {
      return a;
    });
  };
}, "es6", "es3");
$jscomp.polyfill("Number.isFinite", function(a) {
  return a ? a : function(a) {
    return "number" !== typeof a ? !1 : !isNaN(a) && Infinity !== a && -Infinity !== a;
  };
}, "es6", "es3");
$jscomp.polyfill("Number.isInteger", function(a) {
  return a ? a : function(a) {
    return Number.isFinite(a) ? a === Math.floor(a) : !1;
  };
}, "es6", "es3");
$jscomp.checkEs6ConformanceViaProxy = function() {
  try {
    var a = {}, d = Object.create(new $jscomp.global.Proxy(a, {get:function(g, h, e) {
      return g == a && "q" == h && e == d;
    }}));
    return !0 === d.q;
  } catch (g) {
    return !1;
  }
};
$jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS = !1;
$jscomp.ES6_CONFORMANCE = $jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS && $jscomp.checkEs6ConformanceViaProxy();
$jscomp.makeIterator = function(a) {
  var d = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
  return d ? d.call(a) : $jscomp.arrayIterator(a);
};
$jscomp.polyfill("WeakMap", function(a) {
  function d() {
    if (!a || !Object.seal) {
      return !1;
    }
    try {
      var c = Object.seal({}), e = Object.seal({}), d = new a([[c, 2], [e, 3]]);
      if (2 != d.get(c) || 3 != d.get(e)) {
        return !1;
      }
      d.delete(c);
      d.set(e, 4);
      return !d.has(c) && 4 == d.get(e);
    } catch (b) {
      return !1;
    }
  }
  function g() {
  }
  function h(a) {
    if (!$jscomp.owns(a, k)) {
      var c = new g;
      $jscomp.defineProperty(a, k, {value:c});
    }
  }
  function e(a) {
    var c = Object[a];
    c && (Object[a] = function(a) {
      if (a instanceof g) {
        return a;
      }
      h(a);
      return c(a);
    });
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (a && $jscomp.ES6_CONFORMANCE) {
      return a;
    }
  } else {
    if (d()) {
      return a;
    }
  }
  var k = "$jscomp_hidden_" + Math.random();
  e("freeze");
  e("preventExtensions");
  e("seal");
  var c = 0, p = function(a) {
    this.id_ = (c += Math.random() + 1).toString();
    if (a) {
      a = $jscomp.makeIterator(a);
      for (var e; !(e = a.next()).done;) {
        e = e.value, this.set(e[0], e[1]);
      }
    }
  };
  p.prototype.set = function(a, c) {
    h(a);
    if (!$jscomp.owns(a, k)) {
      throw Error("WeakMap key fail: " + a);
    }
    a[k][this.id_] = c;
    return this;
  };
  p.prototype.get = function(a) {
    return $jscomp.owns(a, k) ? a[k][this.id_] : void 0;
  };
  p.prototype.has = function(a) {
    return $jscomp.owns(a, k) && $jscomp.owns(a[k], this.id_);
  };
  p.prototype.delete = function(a) {
    return $jscomp.owns(a, k) && $jscomp.owns(a[k], this.id_) ? delete a[k][this.id_] : !1;
  };
  return p;
}, "es6", "es3");
$jscomp.MapEntry = function() {
};
$jscomp.polyfill("Map", function(a) {
  function d() {
    if ($jscomp.ASSUME_NO_NATIVE_MAP || !a || "function" != typeof a || !a.prototype.entries || "function" != typeof Object.seal) {
      return !1;
    }
    try {
      var c = Object.seal({x:4}), e = new a($jscomp.makeIterator([[c, "s"]]));
      if ("s" != e.get(c) || 1 != e.size || e.get({x:4}) || e.set({x:4}, "t") != e || 2 != e.size) {
        return !1;
      }
      var d = e.entries(), b = d.next();
      if (b.done || b.value[0] != c || "s" != b.value[1]) {
        return !1;
      }
      b = d.next();
      return b.done || 4 != b.value[0].x || "t" != b.value[1] || !d.next().done ? !1 : !0;
    } catch (m) {
      return !1;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (a && $jscomp.ES6_CONFORMANCE) {
      return a;
    }
  } else {
    if (d()) {
      return a;
    }
  }
  $jscomp.initSymbolIterator();
  var g = new WeakMap, h = function(a) {
    this.data_ = {};
    this.head_ = c();
    this.size = 0;
    if (a) {
      a = $jscomp.makeIterator(a);
      for (var e; !(e = a.next()).done;) {
        e = e.value, this.set(e[0], e[1]);
      }
    }
  };
  h.prototype.set = function(a, c) {
    a = 0 === a ? 0 : a;
    var d = e(this, a);
    d.list || (d.list = this.data_[d.id] = []);
    d.entry ? d.entry.value = c : (d.entry = {next:this.head_, previous:this.head_.previous, head:this.head_, key:a, value:c}, d.list.push(d.entry), this.head_.previous.next = d.entry, this.head_.previous = d.entry, this.size++);
    return this;
  };
  h.prototype.delete = function(a) {
    a = e(this, a);
    return a.entry && a.list ? (a.list.splice(a.index, 1), a.list.length || delete this.data_[a.id], a.entry.previous.next = a.entry.next, a.entry.next.previous = a.entry.previous, a.entry.head = null, this.size--, !0) : !1;
  };
  h.prototype.clear = function() {
    this.data_ = {};
    this.head_ = this.head_.previous = c();
    this.size = 0;
  };
  h.prototype.has = function(a) {
    return !!e(this, a).entry;
  };
  h.prototype.get = function(a) {
    return (a = e(this, a).entry) && a.value;
  };
  h.prototype.entries = function() {
    return k(this, function(a) {
      return [a.key, a.value];
    });
  };
  h.prototype.keys = function() {
    return k(this, function(a) {
      return a.key;
    });
  };
  h.prototype.values = function() {
    return k(this, function(a) {
      return a.value;
    });
  };
  h.prototype.forEach = function(a, c) {
    for (var e = this.entries(), b; !(b = e.next()).done;) {
      b = b.value, a.call(c, b[1], b[0], this);
    }
  };
  h.prototype[Symbol.iterator] = h.prototype.entries;
  var e = function(a, c) {
    var e = c && typeof c;
    "object" == e || "function" == e ? g.has(c) ? e = g.get(c) : (e = "" + ++p, g.set(c, e)) : e = "p_" + c;
    var b = a.data_[e];
    if (b && $jscomp.owns(a.data_, e)) {
      for (a = 0; a < b.length; a++) {
        var d = b[a];
        if (c !== c && d.key !== d.key || c === d.key) {
          return {id:e, list:b, index:a, entry:d};
        }
      }
    }
    return {id:e, list:b, index:-1, entry:void 0};
  }, k = function(a, c) {
    var e = a.head_;
    return $jscomp.iteratorPrototype(function() {
      if (e) {
        for (; e.head != a.head_;) {
          e = e.previous;
        }
        for (; e.next != e.head;) {
          return e = e.next, {done:!1, value:c(e)};
        }
        e = null;
      }
      return {done:!0, value:void 0};
    });
  }, c = function() {
    var a = {};
    return a.previous = a.next = a.head = a;
  }, p = 0;
  return h;
}, "es6", "es3");
$jscomp.polyfill("Math.sign", function(a) {
  return a ? a : function(a) {
    a = Number(a);
    return 0 === a || isNaN(a) ? a : 0 < a ? 1 : -1;
  };
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.values", function(a) {
  return a ? a : function() {
    return $jscomp.iteratorFromArray(this, function(a, g) {
      return g;
    });
  };
}, "es8", "es3");
$jscomp.findInternal = function(a, d, g) {
  a instanceof String && (a = String(a));
  for (var h = a.length, e = 0; e < h; e++) {
    var k = a[e];
    if (d.call(g, k, e, a)) {
      return {i:e, v:k};
    }
  }
  return {i:-1, v:void 0};
};
$jscomp.polyfill("Array.prototype.find", function(a) {
  return a ? a : function(a, g) {
    return $jscomp.findInternal(this, a, g).v;
  };
}, "es6", "es3");
$jscomp.FORCE_POLYFILL_PROMISE = !1;
$jscomp.polyfill("Promise", function(a) {
  function d() {
    this.batch_ = null;
  }
  function g(a) {
    return a instanceof e ? a : new e(function(c, e) {
      c(a);
    });
  }
  if (a && !$jscomp.FORCE_POLYFILL_PROMISE) {
    return a;
  }
  d.prototype.asyncExecute = function(a) {
    if (null == this.batch_) {
      this.batch_ = [];
      var c = this;
      this.asyncExecuteFunction(function() {
        c.executeBatch_();
      });
    }
    this.batch_.push(a);
  };
  var h = $jscomp.global.setTimeout;
  d.prototype.asyncExecuteFunction = function(a) {
    h(a, 0);
  };
  d.prototype.executeBatch_ = function() {
    for (; this.batch_ && this.batch_.length;) {
      var a = this.batch_;
      this.batch_ = [];
      for (var e = 0; e < a.length; ++e) {
        var d = a[e];
        a[e] = null;
        try {
          d();
        } catch (f) {
          this.asyncThrow_(f);
        }
      }
    }
    this.batch_ = null;
  };
  d.prototype.asyncThrow_ = function(a) {
    this.asyncExecuteFunction(function() {
      throw a;
    });
  };
  var e = function(a) {
    this.state_ = 0;
    this.result_ = void 0;
    this.onSettledCallbacks_ = [];
    var c = this.createResolveAndReject_();
    try {
      a(c.resolve, c.reject);
    } catch (t) {
      c.reject(t);
    }
  };
  e.prototype.createResolveAndReject_ = function() {
    function a(a) {
      return function(c) {
        d || (d = !0, a.call(e, c));
      };
    }
    var e = this, d = !1;
    return {resolve:a(this.resolveTo_), reject:a(this.reject_)};
  };
  e.prototype.resolveTo_ = function(a) {
    if (a === this) {
      this.reject_(new TypeError("A Promise cannot resolve to itself"));
    } else {
      if (a instanceof e) {
        this.settleSameAsPromise_(a);
      } else {
        a: {
          switch(typeof a) {
            case "object":
              var c = null != a;
              break a;
            case "function":
              c = !0;
              break a;
            default:
              c = !1;
          }
        }
        c ? this.resolveToNonPromiseObj_(a) : this.fulfill_(a);
      }
    }
  };
  e.prototype.resolveToNonPromiseObj_ = function(a) {
    var c = void 0;
    try {
      c = a.then;
    } catch (t) {
      this.reject_(t);
      return;
    }
    "function" == typeof c ? this.settleSameAsThenable_(c, a) : this.fulfill_(a);
  };
  e.prototype.reject_ = function(a) {
    this.settle_(2, a);
  };
  e.prototype.fulfill_ = function(a) {
    this.settle_(1, a);
  };
  e.prototype.settle_ = function(a, e) {
    if (0 != this.state_) {
      throw Error("Cannot settle(" + a + ", " + e + "): Promise already settled in state" + this.state_);
    }
    this.state_ = a;
    this.result_ = e;
    this.executeOnSettledCallbacks_();
  };
  e.prototype.executeOnSettledCallbacks_ = function() {
    if (null != this.onSettledCallbacks_) {
      for (var a = 0; a < this.onSettledCallbacks_.length; ++a) {
        k.asyncExecute(this.onSettledCallbacks_[a]);
      }
      this.onSettledCallbacks_ = null;
    }
  };
  var k = new d;
  e.prototype.settleSameAsPromise_ = function(a) {
    var c = this.createResolveAndReject_();
    a.callWhenSettled_(c.resolve, c.reject);
  };
  e.prototype.settleSameAsThenable_ = function(a, e) {
    var c = this.createResolveAndReject_();
    try {
      a.call(e, c.resolve, c.reject);
    } catch (f) {
      c.reject(f);
    }
  };
  e.prototype.then = function(a, d) {
    function c(a, b) {
      return "function" == typeof a ? function(b) {
        try {
          f(a(b));
        } catch (x) {
          k(x);
        }
      } : b;
    }
    var f, k, b = new e(function(a, b) {
      f = a;
      k = b;
    });
    this.callWhenSettled_(c(a, f), c(d, k));
    return b;
  };
  e.prototype.catch = function(a) {
    return this.then(void 0, a);
  };
  e.prototype.callWhenSettled_ = function(a, e) {
    function c() {
      switch(d.state_) {
        case 1:
          a(d.result_);
          break;
        case 2:
          e(d.result_);
          break;
        default:
          throw Error("Unexpected state: " + d.state_);
      }
    }
    var d = this;
    null == this.onSettledCallbacks_ ? k.asyncExecute(c) : this.onSettledCallbacks_.push(c);
  };
  e.resolve = g;
  e.reject = function(a) {
    return new e(function(c, e) {
      e(a);
    });
  };
  e.race = function(a) {
    return new e(function(c, e) {
      for (var d = $jscomp.makeIterator(a), k = d.next(); !k.done; k = d.next()) {
        g(k.value).callWhenSettled_(c, e);
      }
    });
  };
  e.all = function(a) {
    var c = $jscomp.makeIterator(a), d = c.next();
    return d.done ? g([]) : new e(function(a, e) {
      function b(b) {
        return function(c) {
          m[b] = c;
          f--;
          0 == f && a(m);
        };
      }
      var m = [], f = 0;
      do {
        m.push(void 0), f++, g(d.value).callWhenSettled_(b(m.length - 1), e), d = c.next();
      } while (!d.done);
    });
  };
  return e;
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.fill", function(a) {
  return a ? a : function(a, g, h) {
    var e = this.length || 0;
    0 > g && (g = Math.max(0, e + g));
    if (null == h || h > e) {
      h = e;
    }
    h = Number(h);
    0 > h && (h = Math.max(0, e + h));
    for (g = Number(g || 0); g < h; g++) {
      this[g] = a;
    }
    return this;
  };
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.copyWithin", function(a) {
  function d(a) {
    a = Number(a);
    return Infinity === a || -Infinity === a ? a : a | 0;
  }
  return a ? a : function(a, h, e) {
    var k = this.length;
    a = d(a);
    h = d(h);
    e = void 0 === e ? k : d(e);
    a = 0 > a ? Math.max(k + a, 0) : Math.min(a, k);
    h = 0 > h ? Math.max(k + h, 0) : Math.min(h, k);
    e = 0 > e ? Math.max(k + e, 0) : Math.min(e, k);
    if (a < h) {
      for (; h < e;) {
        h in this ? this[a++] = this[h++] : (delete this[a++], h++);
      }
    } else {
      for (e = Math.min(e, k + h - a), a += e - h; e > h;) {
        --e in this ? this[--a] = this[e] : delete this[--a];
      }
    }
    return this;
  };
}, "es6", "es3");
$jscomp.polyfill("Math.log2", function(a) {
  return a ? a : function(a) {
    return Math.log(a) / Math.LN2;
  };
}, "es6", "es3");
$jscomp.polyfill("String.fromCodePoint", function(a) {
  return a ? a : function(a) {
    for (var d = "", h = 0; h < arguments.length; h++) {
      var e = Number(arguments[h]);
      if (0 > e || 1114111 < e || e !== Math.floor(e)) {
        throw new RangeError("invalid_code_point " + e);
      }
      65535 >= e ? d += String.fromCharCode(e) : (e -= 65536, d += String.fromCharCode(e >>> 10 & 1023 | 55296), d += String.fromCharCode(e & 1023 | 56320));
    }
    return d;
  };
}, "es6", "es3");
$jscomp.underscoreProtoCanBeSet = function() {
  var a = {a:!0}, d = {};
  try {
    return d.__proto__ = a, d.a;
  } catch (g) {
  }
  return !1;
};
$jscomp.setPrototypeOf = "function" == typeof Object.setPrototypeOf ? Object.setPrototypeOf : $jscomp.underscoreProtoCanBeSet() ? function(a, d) {
  a.__proto__ = d;
  if (a.__proto__ !== d) {
    throw new TypeError(a + " is not extensible");
  }
  return a;
} : null;
$jscomp.polyfill("Object.setPrototypeOf", function(a) {
  return a || $jscomp.setPrototypeOf;
}, "es6", "es5");
$jscomp.polyfill("Array.from", function(a) {
  return a ? a : function(a, g, h) {
    g = null != g ? g : function(a) {
      return a;
    };
    var e = [], d = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
    if ("function" == typeof d) {
      a = d.call(a);
      for (var c = 0; !(d = a.next()).done;) {
        e.push(g.call(h, d.value, c++));
      }
    } else {
      for (d = a.length, c = 0; c < d; c++) {
        e.push(g.call(h, a[c], c));
      }
    }
    return e;
  };
}, "es6", "es3");
$jscomp.polyfill("Math.fround", function(a) {
  if (a) {
    return a;
  }
  if ($jscomp.SIMPLE_FROUND_POLYFILL || "function" !== typeof Float32Array) {
    return function(a) {
      return a;
    };
  }
  var d = new Float32Array(1);
  return function(a) {
    d[0] = a;
    return d[0];
  };
}, "es6", "es3");
$jscomp.polyfill("String.prototype.startsWith", function(a) {
  return a ? a : function(a, g) {
    var d = $jscomp.checkStringArgs(this, a, "startsWith");
    a += "";
    var e = d.length, k = a.length;
    g = Math.max(0, Math.min(g | 0, d.length));
    for (var c = 0; c < k && g < e;) {
      if (d[g++] != a[c++]) {
        return !1;
      }
    }
    return c >= k;
  };
}, "es6", "es3");
$jscomp.polyfill("Object.is", function(a) {
  return a ? a : function(a, g) {
    return a === g ? 0 !== a || 1 / a === 1 / g : a !== a && g !== g;
  };
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.includes", function(a) {
  return a ? a : function(a, g) {
    var d = this;
    d instanceof String && (d = String(d));
    var e = d.length;
    g = g || 0;
    for (0 > g && (g = Math.max(g + e, 0)); g < e; g++) {
      var k = d[g];
      if (k === a || Object.is(k, a)) {
        return !0;
      }
    }
    return !1;
  };
}, "es7", "es3");
$jscomp.polyfill("String.prototype.includes", function(a) {
  return a ? a : function(a, g) {
    return -1 !== $jscomp.checkStringArgs(this, a, "includes").indexOf(a, g || 0);
  };
}, "es6", "es3");
function NunuApp(a) {
  this.renderer = this.program = null;
  this.canvasFitWindow = this.running = !1;
  this.canvas = a;
  this.events = new EventManager;
  void 0 === a && (this.canvas = document.createElement("canvas"), this.canvas.style.position = "absolute", this.canvas.style.left = "0px", this.canvas.style.top = "0px", this.canvasFitWindow = !0, document.body.appendChild(this.canvas));
}
NunuApp.loadApp = function(a, d) {
  "string" === typeof d && (d = document.getElementById(d));
  var g = new NunuApp(d);
  g.loadRunProgram(a);
  window.addEventListener("resize", function() {
    Nunu.isFullscreen() ? (g.canvas.width = window.innerWidth, g.canvas.height = window.innerHeight) : (g.canvas.width = nunuApps[i].canvas.parentElement.offsetWidth, g.canvas.height = nunuApps[i].canvas.parentElement.offsetWidth);
    g.resize();
  });
};
NunuApp.prototype.run = function() {
  if (null === this.program) {
    console.warn("nunuStudio: no program is loaded [app.loadPogram(fname)]");
  } else {
    this.renderer = this.program.rendererConfig.createRenderer(this.canvas);
    this.keyboard = new Keyboard;
    this.mouse = new Mouse;
    this.mouse.setCanvas(this.canvas);
    this.program.app = this;
    this.program.defaultCamera = new PerspectiveCamera(60, 1, .1, 1E5);
    this.program.defaultCamera.position.set(0, 5, -5);
    this.program.setRenderer(this.renderer);
    this.program.setMouseKeyboard(this.mouse, this.keyboard);
    this.program.initialize();
    if (this.program.lockPointer) {
      var a = this.canvas;
      a.requestPointerLock = a.requestPointerLock || a.mozRequestPointerLock || a.webkitRequestPointerLock;
      this.events.add(a, "click", function() {
        a.requestPointerLock && a.requestPointerLock();
      });
    }
    var d = this;
    this.events.add(window, "beforeunload", function() {
      d.exit();
    });
    this.events.create();
    this.resize();
    this.resume();
  }
};
NunuApp.prototype.loadRunProgram = function(a, d, g) {
  this.loadProgramAsync(a, function(a) {
    a.run();
    void 0 !== d && d(a);
  }, g);
};
NunuApp.prototype.loadProgram = function(a) {
  if (a.endsWith(".isp")) {
    var d = new ObjectLoader;
    a = FileSystem.readFile(a);
    this.program = d.parse(JSON.parse(a));
  } else {
    if (a.endsWith(".nsp")) {
      d = new ObjectLoader;
      a = FileSystem.readFileArrayBuffer(a);
      var g = new dcodeIO.PSON.StaticPair;
      this.program = d.parse(g.decode(a));
    }
  }
};
NunuApp.prototype.loadProgramAsync = function(a, d, g) {
  var h = this;
  a.endsWith(".isp") ? FileSystem.readFile(a, !1, function(a) {
    var e = new ObjectLoader;
    h.program = e.parse(JSON.parse(a));
    void 0 !== d && d(h);
  }, g) : a.endsWith(".nsp") && FileSystem.readFileArrayBuffer(a, !1, function(a) {
    var e = new ObjectLoader, c = new dcodeIO.PSON.StaticPair;
    h.program = e.parse(c.decode(a));
    void 0 !== d && d(h);
  }, g);
};
NunuApp.prototype.update = function() {
  this.mouse.update();
  this.keyboard.update();
  this.program.update();
  this.program.render(this.renderer);
};
NunuApp.prototype.exit = function() {
  this.events.destroy();
  null !== this.program && (this.program.dispose(), this.program = null);
  null !== this.renderer && (this.renderer.dispose(), this.renderer = null);
  null !== this.mouse && (this.mouse.dispose(), this.mouse = null);
  null !== this.keyboard && (this.keyboard.dispose(), this.keyboard = null);
  if (void 0 !== this.onExit) {
    this.onExit();
  }
};
NunuApp.prototype.resume = function() {
  if (null !== this.program && !this.running) {
    var a = this, d = function() {
      a.running && (a.update(), requestAnimationFrame(d));
    };
    this.running = !0;
    d();
  }
};
NunuApp.prototype.pause = function() {
  this.running = !1;
};
NunuApp.prototype.setCanvas = function(a) {
  this.canvas = a;
  this.canvasFitWindow = !1;
};
NunuApp.prototype.resize = function() {
  if (null !== this.canvas && null !== this.program && null !== this.renderer) {
    if (this.canvasFitWindow) {
      this.canvas.style.width = window.innerWidth + "px";
      this.canvas.style.height = window.innerHeight + "px";
      var a = window.innerWidth;
      var d = window.innerHeight;
    } else {
      a = this.canvas.offsetWidth, d = this.canvas.offsetHeight;
    }
    this.program.handlePixelRatio && (a *= window.devicePixelRatio, d *= window.devicePixelRatio);
    this.renderer.setSize(a, d, !1);
    this.program.resize(a, d);
  }
};
NunuApp.prototype.sendData = function(a) {
  null !== this.program && this.program.receiveDataApp(a);
};
NunuApp.prototype.setOnDataReceived = function(a) {
  this.onDataReceived = a;
};
NunuApp.prototype.setOnExit = function(a) {
  this.onExit = a;
};
NunuApp.prototype.vrAvailable = function() {
  return null !== this.program && this.program.vrAvailable();
};
NunuApp.prototype.toggleVR = function() {
  this.vrAvailable() ? this.program.vrRunning ? this.program.exitVR() : this.program.enterVR() : console.warn("nunuStudio: Loaded program is not VR enabled.");
};
NunuApp.prototype.toggleFullscreen = function(a) {
  var d = Nunu.isFullscreen();
  void 0 === a && (a = this.canvas);
  Nunu.setFullscreen(!d, a);
};
(function(a, d) {
  "object" === typeof exports && "undefined" !== typeof module ? d(exports) : "function" === typeof define && define.amd ? define(["exports"], d) : (a = a || self, d(a.THREE = {}));
})(this, function(a) {
  function d() {
  }
  function g(l, a) {
    this.x = l || 0;
    this.y = a || 0;
  }
  function h() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }
  function e(l, a, b, c, d, m, f, k, r, n) {
    Object.defineProperty(this, "id", {value:jj++});
    this.uuid = na.generateUUID();
    this.name = "";
    this.image = void 0 !== l ? l : e.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = void 0 !== a ? a : e.DEFAULT_MAPPING;
    this.wrapS = void 0 !== b ? b : 1001;
    this.wrapT = void 0 !== c ? c : 1001;
    this.magFilter = void 0 !== d ? d : 1006;
    this.minFilter = void 0 !== m ? m : 1008;
    this.anisotropy = void 0 !== r ? r : 1;
    this.format = void 0 !== f ? f : 1023;
    this.internalFormat = null;
    this.type = void 0 !== k ? k : 1009;
    this.offset = new g(0, 0);
    this.repeat = new g(1, 1);
    this.center = new g(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = !0;
    this.matrix = new h;
    this.generateMipmaps = !0;
    this.premultiplyAlpha = !1;
    this.flipY = !0;
    this.unpackAlignment = 4;
    this.encoding = void 0 !== n ? n : 3E3;
    this.version = 0;
    this.onUpdate = null;
  }
  function k(l, a, b, c) {
    this.x = l || 0;
    this.y = a || 0;
    this.z = b || 0;
    this.w = void 0 !== c ? c : 1;
  }
  function c(l, a, b) {
    this.width = l;
    this.height = a;
    this.scissor = new k(0, 0, l, a);
    this.scissorTest = !1;
    this.viewport = new k(0, 0, l, a);
    b = b || {};
    this.texture = new e(void 0, b.mapping, b.wrapS, b.wrapT, b.magFilter, b.minFilter, b.format, b.type, b.anisotropy, b.encoding);
    this.texture.image = {};
    this.texture.image.width = l;
    this.texture.image.height = a;
    this.texture.generateMipmaps = void 0 !== b.generateMipmaps ? b.generateMipmaps : !1;
    this.texture.minFilter = void 0 !== b.minFilter ? b.minFilter : 1006;
    this.depthBuffer = void 0 !== b.depthBuffer ? b.depthBuffer : !0;
    this.stencilBuffer = void 0 !== b.stencilBuffer ? b.stencilBuffer : !0;
    this.depthTexture = void 0 !== b.depthTexture ? b.depthTexture : null;
  }
  function p(l, a, b) {
    c.call(this, l, a, b);
    this.samples = 4;
  }
  function t(l, a, b, c) {
    this._x = l || 0;
    this._y = a || 0;
    this._z = b || 0;
    this._w = void 0 !== c ? c : 1;
  }
  function f(l, a, b) {
    this.x = l || 0;
    this.y = a || 0;
    this.z = b || 0;
  }
  function n() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }
  function b(l, a, c, e) {
    this._x = l || 0;
    this._y = a || 0;
    this._z = c || 0;
    this._order = e || b.DefaultOrder;
  }
  function m() {
    this.mask = 1;
  }
  function q() {
    Object.defineProperty(this, "id", {value:kj++});
    this.uuid = na.generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = q.DefaultUp.clone();
    var l = new f, a = new b, c = new t, e = new f(1, 1, 1);
    a._onChange(function() {
      c.setFromEuler(a, !1);
    });
    c._onChange(function() {
      a.setFromQuaternion(c, void 0, !1);
    });
    Object.defineProperties(this, {position:{configurable:!0, enumerable:!0, value:l}, rotation:{configurable:!0, enumerable:!0, value:a}, quaternion:{configurable:!0, enumerable:!0, value:c}, scale:{configurable:!0, enumerable:!0, value:e}, modelViewMatrix:{value:new n}, normalMatrix:{value:new h}});
    this.matrix = new n;
    this.matrixWorld = new n;
    this.matrixAutoUpdate = q.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = !1;
    this.layers = new m;
    this.visible = !0;
    this.receiveShadow = this.castShadow = !1;
    this.frustumCulled = !0;
    this.renderOrder = 0;
    this.userData = {};
  }
  function y() {
    q.call(this);
    this.type = "Scene";
    this.overrideMaterial = this.fog = this.environment = this.background = null;
    this.autoUpdate = !0;
    "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail:this}));
  }
  function x(l, a) {
    this.min = void 0 !== l ? l : new f(Infinity, Infinity, Infinity);
    this.max = void 0 !== a ? a : new f(-Infinity, -Infinity, -Infinity);
  }
  function z(l, a, b, c, e) {
    var w;
    var d = 0;
    for (w = l.length - 3; d <= w; d += 3) {
      xc.fromArray(l, d);
      var m = e.x * Math.abs(xc.x) + e.y * Math.abs(xc.y) + e.z * Math.abs(xc.z), G = a.dot(xc), f = b.dot(xc), k = c.dot(xc);
      if (Math.max(-Math.max(G, f, k), Math.min(G, f, k)) > m) {
        return !1;
      }
    }
    return !0;
  }
  function r(l, a) {
    this.center = void 0 !== l ? l : new f;
    this.radius = void 0 !== a ? a : -1;
  }
  function u(l, a) {
    this.origin = void 0 !== l ? l : new f;
    this.direction = void 0 !== a ? a : new f(0, 0, -1);
  }
  function v(l, a) {
    this.normal = void 0 !== l ? l : new f(1, 0, 0);
    this.constant = void 0 !== a ? a : 0;
  }
  function C(l, a, b) {
    this.a = void 0 !== l ? l : new f;
    this.b = void 0 !== a ? a : new f;
    this.c = void 0 !== b ? b : new f;
  }
  function A(l, a, b) {
    return void 0 === a && void 0 === b ? this.set(l) : this.setRGB(l, a, b);
  }
  function D(l, a, b) {
    0 > b && (b += 1);
    1 < b && --b;
    return b < 1 / 6 ? l + 6 * (a - l) * b : .5 > b ? a : b < 2 / 3 ? l + 6 * (a - l) * (2 / 3 - b) : l;
  }
  function F(l) {
    return .04045 > l ? .0773993808 * l : Math.pow(.9478672986 * l + .0521327014, 2.4);
  }
  function B(l) {
    return .0031308 > l ? 12.92 * l : 1.055 * Math.pow(l, .41666) - .055;
  }
  function E(l, a, b, c, e, d) {
    this.a = l;
    this.b = a;
    this.c = b;
    this.normal = c && c.isVector3 ? c : new f;
    this.vertexNormals = Array.isArray(c) ? c : [];
    this.color = e && e.isColor ? e : new A;
    this.vertexColors = Array.isArray(e) ? e : [];
    this.materialIndex = void 0 !== d ? d : 0;
  }
  function H() {
    Object.defineProperty(this, "id", {value:lj++});
    this.uuid = na.generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = !0;
    this.blending = 1;
    this.side = 0;
    this.vertexColors = this.flatShading = !1;
    this.opacity = 1;
    this.transparent = !1;
    this.blendSrc = 204;
    this.blendDst = 205;
    this.blendEquation = 100;
    this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
    this.depthFunc = 3;
    this.depthWrite = this.depthTest = !0;
    this.stencilWriteMask = 255;
    this.stencilFunc = 519;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilZPass = this.stencilZFail = this.stencilFail = 7680;
    this.stencilWrite = !1;
    this.clippingPlanes = null;
    this.clipShadows = this.clipIntersection = !1;
    this.shadowSide = null;
    this.colorWrite = !0;
    this.precision = null;
    this.polygonOffset = !1;
    this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
    this.dithering = !1;
    this.alphaTest = 0;
    this.premultipliedAlpha = !1;
    this.toneMapped = this.visible = !0;
    this.userData = {};
    this.version = 0;
  }
  function L(l) {
    H.call(this);
    this.type = "MeshBasicMaterial";
    this.color = new A(16777215);
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.envMap = this.alphaMap = this.specularMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphTargets = this.skinning = !1;
    this.setValues(l);
  }
  function K(l, a, b) {
    if (Array.isArray(l)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.name = "";
    this.array = l;
    this.itemSize = a;
    this.count = void 0 !== l ? l.length / a : 0;
    this.normalized = !0 === b;
    this.usage = 35044;
    this.updateRange = {offset:0, count:-1};
    this.version = 0;
  }
  function P(l, a, b) {
    K.call(this, new Int8Array(l), a, b);
  }
  function J(l, a, b) {
    K.call(this, new Uint8Array(l), a, b);
  }
  function I(l, a, b) {
    K.call(this, new Uint8ClampedArray(l), a, b);
  }
  function N(l, a, b) {
    K.call(this, new Int16Array(l), a, b);
  }
  function S(l, a, b) {
    K.call(this, new Uint16Array(l), a, b);
  }
  function Q(l, a, b) {
    K.call(this, new Int32Array(l), a, b);
  }
  function Z(l, a, b) {
    K.call(this, new Uint32Array(l), a, b);
  }
  function R(l, a, b) {
    K.call(this, new Float32Array(l), a, b);
  }
  function W(l, a, b) {
    K.call(this, new Float64Array(l), a, b);
  }
  function O() {
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    this.boundingSphere = this.boundingBox = null;
    this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1;
  }
  function ca(l) {
    if (0 === l.length) {
      return -Infinity;
    }
    for (var a = l[0], b = 1, c = l.length; b < c; ++b) {
      l[b] > a && (a = l[b]);
    }
    return a;
  }
  function M() {
    Object.defineProperty(this, "id", {value:mj += 2});
    this.uuid = na.generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = !1;
    this.groups = [];
    this.boundingSphere = this.boundingBox = null;
    this.drawRange = {start:0, count:Infinity};
    this.userData = {};
  }
  function V(l, a) {
    q.call(this);
    this.type = "Mesh";
    this.geometry = void 0 !== l ? l : new M;
    this.material = void 0 !== a ? a : new L;
    this.updateMorphTargets();
  }
  function fa(l, a, b, c, e, d, m, f) {
    if (null === (1 === a.side ? c.intersectTriangle(m, d, e, !0, f) : c.intersectTriangle(e, d, m, 2 !== a.side, f))) {
      return null;
    }
    Ve.copy(f);
    Ve.applyMatrix4(l.matrixWorld);
    a = b.ray.origin.distanceTo(Ve);
    return a < b.near || a > b.far ? null : {distance:a, point:Ve.clone(), object:l};
  }
  function ja(l, a, b, c, e, d, m, f, k, h, r, n) {
    dc.fromBufferAttribute(e, h);
    ec.fromBufferAttribute(e, r);
    fc.fromBufferAttribute(e, n);
    e = l.morphTargetInfluences;
    if (a.morphTargets && d && e) {
      We.set(0, 0, 0);
      Xe.set(0, 0, 0);
      Ye.set(0, 0, 0);
      for (var w = 0, G = d.length; w < G; w++) {
        var q = e[w], p = d[w];
        0 !== q && (ng.fromBufferAttribute(p, h), og.fromBufferAttribute(p, r), pg.fromBufferAttribute(p, n), m ? (We.addScaledVector(ng, q), Xe.addScaledVector(og, q), Ye.addScaledVector(pg, q)) : (We.addScaledVector(ng.sub(dc), q), Xe.addScaledVector(og.sub(ec), q), Ye.addScaledVector(pg.sub(fc), q)));
      }
      dc.add(We);
      ec.add(Xe);
      fc.add(Ye);
    }
    l.isSkinnedMesh && (l.boneTransform(h, dc), l.boneTransform(r, ec), l.boneTransform(n, fc));
    if (l = fa(l, a, b, c, dc, ec, fc, Vd)) {
      f && (ad.fromBufferAttribute(f, h), bd.fromBufferAttribute(f, r), cd.fromBufferAttribute(f, n), l.uv = C.getUV(Vd, dc, ec, fc, ad, bd, cd, new g)), k && (ad.fromBufferAttribute(k, h), bd.fromBufferAttribute(k, r), cd.fromBufferAttribute(k, n), l.uv2 = C.getUV(Vd, dc, ec, fc, ad, bd, cd, new g)), f = new E(h, r, n), C.getNormal(dc, ec, fc, f.normal), l.face = f;
    }
    return l;
  }
  function X() {
    Object.defineProperty(this, "id", {value:oj += 2});
    this.uuid = na.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingSphere = this.boundingBox = null;
    this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1;
  }
  function ea(l) {
    var a = {}, b;
    for (b in l) {
      a[b] = {};
      for (var c in l[b]) {
        var e = l[b][c];
        e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? a[b][c] = e.clone() : Array.isArray(e) ? a[b][c] = e.slice() : a[b][c] = e;
      }
    }
    return a;
  }
  function Y(l) {
    for (var a = {}, b = 0; b < l.length; b++) {
      var c = ea(l[b]), e;
      for (e in c) {
        a[e] = c[e];
      }
    }
    return a;
  }
  function T(l) {
    H.call(this);
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    this.linewidth = 1;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1;
    this.extensions = {derivatives:!1, fragDepth:!1, drawBuffers:!1, shaderTextureLOD:!1};
    this.defaultAttributeValues = {color:[1, 1, 1], uv:[0, 0], uv2:[0, 0]};
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = !1;
    void 0 !== l && (void 0 !== l.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(l));
  }
  function ma() {
    q.call(this);
    this.type = "Camera";
    this.matrixWorldInverse = new n;
    this.projectionMatrix = new n;
    this.projectionMatrixInverse = new n;
  }
  function ka(l, a, b, c) {
    ma.call(this);
    this.type = "PerspectiveCamera";
    this.fov = void 0 !== l ? l : 50;
    this.zoom = 1;
    this.near = void 0 !== b ? b : .1;
    this.far = void 0 !== c ? c : 2E3;
    this.focus = 10;
    this.aspect = void 0 !== a ? a : 1;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  function ua(l, a, b, c) {
    q.call(this);
    this.type = "CubeCamera";
    var w = new ka(90, 1, l, a);
    w.up.set(0, -1, 0);
    w.lookAt(new f(1, 0, 0));
    this.add(w);
    var e = new ka(90, 1, l, a);
    e.up.set(0, -1, 0);
    e.lookAt(new f(-1, 0, 0));
    this.add(e);
    var d = new ka(90, 1, l, a);
    d.up.set(0, 0, 1);
    d.lookAt(new f(0, 1, 0));
    this.add(d);
    var m = new ka(90, 1, l, a);
    m.up.set(0, 0, -1);
    m.lookAt(new f(0, -1, 0));
    this.add(m);
    var G = new ka(90, 1, l, a);
    G.up.set(0, -1, 0);
    G.lookAt(new f(0, 0, 1));
    this.add(G);
    var k = new ka(90, 1, l, a);
    k.up.set(0, -1, 0);
    k.lookAt(new f(0, 0, -1));
    this.add(k);
    c = c || {format:1022, magFilter:1006, minFilter:1006};
    this.renderTarget = new Aa(b, c);
    this.renderTarget.texture.name = "CubeCamera";
    this.update = function(l, a) {
      null === this.parent && this.updateMatrixWorld();
      var b = l.getRenderTarget(), c = this.renderTarget, f = c.texture.generateMipmaps;
      c.texture.generateMipmaps = !1;
      l.setRenderTarget(c, 0);
      l.render(a, w);
      l.setRenderTarget(c, 1);
      l.render(a, e);
      l.setRenderTarget(c, 2);
      l.render(a, d);
      l.setRenderTarget(c, 3);
      l.render(a, m);
      l.setRenderTarget(c, 4);
      l.render(a, G);
      c.texture.generateMipmaps = f;
      l.setRenderTarget(c, 5);
      l.render(a, k);
      l.setRenderTarget(b);
    };
    this.clear = function(l, a, w, b) {
      for (var c = l.getRenderTarget(), e = this.renderTarget, d = 0; 6 > d; d++) {
        l.setRenderTarget(e, d), l.clear(a, w, b);
      }
      l.setRenderTarget(c);
    };
  }
  function Aa(l, a, b) {
    Number.isInteger(a) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), a = b);
    c.call(this, l, l, a);
  }
  function Ia(l, a, b, c, d, m, f, k, h, g, r, n) {
    e.call(this, null, m, f, k, h, g, c, d, r, n);
    this.image = {data:l || null, width:a || 1, height:b || 1};
    this.magFilter = void 0 !== h ? h : 1003;
    this.minFilter = void 0 !== g ? g : 1003;
    this.flipY = this.generateMipmaps = !1;
    this.unpackAlignment = 1;
    this.needsUpdate = !0;
  }
  function Ga(l, a, b, c, e, d) {
    this.planes = [void 0 !== l ? l : new v, void 0 !== a ? a : new v, void 0 !== b ? b : new v, void 0 !== c ? c : new v, void 0 !== e ? e : new v, void 0 !== d ? d : new v];
  }
  function sa() {
    function l(w, e) {
      !1 !== b && (c(w, e), a.requestAnimationFrame(l));
    }
    var a = null, b = !1, c = null;
    return {start:function() {
      !0 !== b && null !== c && (a.requestAnimationFrame(l), b = !0);
    }, stop:function() {
      b = !1;
    }, setAnimationLoop:function(l) {
      c = l;
    }, setContext:function(l) {
      a = l;
    }};
  }
  function Qb(l, a) {
    function w(a, w) {
      var b = a.array, c = a.usage, e = l.createBuffer();
      l.bindBuffer(w, e);
      l.bufferData(w, b, c);
      a.onUploadCallback();
      w = 5126;
      b instanceof Float32Array ? w = 5126 : b instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : b instanceof Uint16Array ? w = 5123 : b instanceof Int16Array ? w = 5122 : b instanceof Uint32Array ? w = 5125 : b instanceof Int32Array ? w = 5124 : b instanceof Int8Array ? w = 5120 : b instanceof Uint8Array && (w = 5121);
      return {buffer:e, type:w, bytesPerElement:b.BYTES_PER_ELEMENT, version:a.version};
    }
    var b = a.isWebGL2, c = new WeakMap;
    return {get:function(l) {
      l.isInterleavedBufferAttribute && (l = l.data);
      return c.get(l);
    }, remove:function(a) {
      a.isInterleavedBufferAttribute && (a = a.data);
      var w = c.get(a);
      w && (l.deleteBuffer(w.buffer), c.delete(a));
    }, update:function(a, e) {
      a.isInterleavedBufferAttribute && (a = a.data);
      var d = c.get(a);
      if (void 0 === d) {
        c.set(a, w(a, e));
      } else {
        if (d.version < a.version) {
          var m = a.array, G = a.updateRange;
          l.bindBuffer(e, d.buffer);
          -1 === G.count ? l.bufferSubData(e, 0, m) : (b ? l.bufferSubData(e, G.offset * m.BYTES_PER_ELEMENT, m, G.offset, G.count) : l.bufferSubData(e, G.offset * m.BYTES_PER_ELEMENT, m.subarray(G.offset, G.offset + G.count)), G.count = -1);
          d.version = a.version;
        }
      }
    }};
  }
  function va(l, a, b, c) {
    X.call(this);
    this.type = "PlaneGeometry";
    this.parameters = {width:l, height:a, widthSegments:b, heightSegments:c};
    this.fromBufferGeometry(new xa(l, a, b, c));
    this.mergeVertices();
  }
  function xa(l, a, b, c) {
    M.call(this);
    this.type = "PlaneBufferGeometry";
    this.parameters = {width:l, height:a, widthSegments:b, heightSegments:c};
    l = l || 1;
    a = a || 1;
    var w = l / 2, e = a / 2;
    b = Math.floor(b) || 1;
    c = Math.floor(c) || 1;
    var d = b + 1, m = c + 1, G = l / b, f = a / c, k = [], h = [], g = [], r = [];
    for (l = 0; l < m; l++) {
      var n = l * f - e;
      for (a = 0; a < d; a++) {
        h.push(a * G - w, -n, 0), g.push(0, 0, 1), r.push(a / b), r.push(1 - l / c);
      }
    }
    for (l = 0; l < c; l++) {
      for (a = 0; a < b; a++) {
        w = a + d * (l + 1), e = a + 1 + d * (l + 1), m = a + 1 + d * l, k.push(a + d * l, w, m), k.push(w, e, m);
      }
    }
    this.setIndex(k);
    this.setAttribute("position", new R(h, 3));
    this.setAttribute("normal", new R(g, 3));
    this.setAttribute("uv", new R(r, 2));
  }
  function gc(l, a, b, c) {
    function w(l, w) {
      a.buffers.color.setClear(l.r, l.g, l.b, w, c);
    }
    var e = new A(0), d = 0, m, G, f = null, k = 0, h = null;
    return {getClearColor:function() {
      return e;
    }, setClearColor:function(l, a) {
      e.set(l);
      d = void 0 !== a ? a : 1;
      w(e, d);
    }, getClearAlpha:function() {
      return d;
    }, setClearAlpha:function(l) {
      d = l;
      w(e, d);
    }, render:function(a, c, g, r) {
      c = c.background;
      g = l.xr;
      (g = g.getSession && g.getSession()) && "additive" === g.environmentBlendMode && (c = null);
      null === c ? w(e, d) : c && c.isColor && (w(c, 1), r = !0);
      (l.autoClear || r) && l.clear(l.autoClearColor, l.autoClearDepth, l.autoClearStencil);
      if (c && (c.isCubeTexture || c.isWebGLCubeRenderTarget || 306 === c.mapping)) {
        void 0 === G && (G = new V(new Wd(1, 1, 1), new T({type:"BackgroundCubeMaterial", uniforms:ea(Ab.cube.uniforms), vertexShader:Ab.cube.vertexShader, fragmentShader:Ab.cube.fragmentShader, side:1, depthTest:!1, depthWrite:!1, fog:!1})), G.geometry.deleteAttribute("normal"), G.geometry.deleteAttribute("uv"), G.onBeforeRender = function(l, a, w) {
          this.matrixWorld.copyPosition(w.matrixWorld);
        }, Object.defineProperty(G.material, "envMap", {get:function() {
          return this.uniforms.envMap.value;
        }}), b.update(G));
        r = c.isWebGLCubeRenderTarget ? c.texture : c;
        G.material.uniforms.envMap.value = r;
        G.material.uniforms.flipEnvMap.value = r.isCubeTexture ? -1 : 1;
        if (f !== c || k !== r.version || h !== l.toneMapping) {
          G.material.needsUpdate = !0, f = c, k = r.version, h = l.toneMapping;
        }
        a.unshift(G, G.geometry, G.material, 0, 0, null);
      } else {
        if (c && c.isTexture) {
          void 0 === m && (m = new V(new xa(2, 2), new T({type:"BackgroundMaterial", uniforms:ea(Ab.background.uniforms), vertexShader:Ab.background.vertexShader, fragmentShader:Ab.background.fragmentShader, side:0, depthTest:!1, depthWrite:!1, fog:!1})), m.geometry.deleteAttribute("normal"), Object.defineProperty(m.material, "map", {get:function() {
            return this.uniforms.t2D.value;
          }}), b.update(m));
          m.material.uniforms.t2D.value = c;
          !0 === c.matrixAutoUpdate && c.updateMatrix();
          m.material.uniforms.uvTransform.value.copy(c.matrix);
          if (f !== c || k !== c.version || h !== l.toneMapping) {
            m.material.needsUpdate = !0, f = c, k = c.version, h = l.toneMapping;
          }
          a.unshift(m, m.geometry, m.material, 0, 0, null);
        }
      }
    }};
  }
  function Xd(l, a, b, c) {
    var w = c.isWebGL2, e;
    this.setMode = function(l) {
      e = l;
    };
    this.render = function(a, w) {
      l.drawArrays(e, a, w);
      b.update(w, e);
    };
    this.renderInstances = function(c, d, m, G) {
      if (0 !== G) {
        if (w) {
          c = l;
          var f = "drawArraysInstanced";
        } else {
          if (c = a.get("ANGLE_instanced_arrays"), f = "drawArraysInstancedANGLE", null === c) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return;
          }
        }
        c[f](e, d, m, G);
        b.update(m, e, G);
      }
    };
  }
  function yc(l, a, b) {
    function w(a) {
      if ("highp" === a) {
        if (0 < l.getShaderPrecisionFormat(35633, 36338).precision && 0 < l.getShaderPrecisionFormat(35632, 36338).precision) {
          return "highp";
        }
        a = "mediump";
      }
      return "mediump" === a && 0 < l.getShaderPrecisionFormat(35633, 36337).precision && 0 < l.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp";
    }
    var c, e = "undefined" !== typeof WebGL2RenderingContext && l instanceof WebGL2RenderingContext || "undefined" !== typeof WebGL2ComputeRenderingContext && l instanceof WebGL2ComputeRenderingContext, d = void 0 !== b.precision ? b.precision : "highp", m = w(d);
    m !== d && (console.warn("THREE.WebGLRenderer:", d, "not supported, using", m, "instead."), d = m);
    b = !0 === b.logarithmicDepthBuffer;
    m = l.getParameter(34930);
    var G = l.getParameter(35660), f = l.getParameter(3379), k = l.getParameter(34076), h = l.getParameter(34921), g = l.getParameter(36347), r = l.getParameter(36348), n = l.getParameter(36349), q = 0 < G, p = e || !!a.get("OES_texture_float"), u = q && p, t = e ? l.getParameter(36183) : 0;
    return {isWebGL2:e, getMaxAnisotropy:function() {
      if (void 0 !== c) {
        return c;
      }
      var w = a.get("EXT_texture_filter_anisotropic");
      return c = null !== w ? l.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
    }, getMaxPrecision:w, precision:d, logarithmicDepthBuffer:b, maxTextures:m, maxVertexTextures:G, maxTextureSize:f, maxCubemapSize:k, maxAttributes:h, maxVertexUniforms:g, maxVaryings:r, maxFragmentUniforms:n, vertexTextures:q, floatFragmentTextures:p, floatVertexTextures:u, maxSamples:t};
  }
  function Va() {
    function l() {
      g.value !== c && (g.value = c, g.needsUpdate = 0 < e);
      b.numPlanes = e;
      b.numIntersection = 0;
    }
    function a(l, a, w, c) {
      var e = null !== l ? l.length : 0, d = null;
      if (0 !== e) {
        d = g.value;
        if (!0 !== c || null === d) {
          c = w + 4 * e;
          a = a.matrixWorldInverse;
          k.getNormalMatrix(a);
          if (null === d || d.length < c) {
            d = new Float32Array(c);
          }
          for (c = 0; c !== e; ++c, w += 4) {
            f.copy(l[c]).applyMatrix4(a, k), f.normal.toArray(d, w), d[w + 3] = f.constant;
          }
        }
        g.value = d;
        g.needsUpdate = !0;
      }
      b.numPlanes = e;
      b.numIntersection = 0;
      return d;
    }
    var b = this, c = null, e = 0, d = !1, m = !1, f = new v, k = new h, g = {value:null, needsUpdate:!1};
    this.uniform = g;
    this.numIntersection = this.numPlanes = 0;
    this.init = function(l, w, b) {
      var m = 0 !== l.length || w || 0 !== e || d;
      d = w;
      c = a(l, b, 0);
      e = l.length;
      return m;
    };
    this.beginShadows = function() {
      m = !0;
      a(null);
    };
    this.endShadows = function() {
      m = !1;
      l();
    };
    this.setState = function(w, b, G, f, k, h) {
      if (!d || null === w || 0 === w.length || m && !G) {
        m ? a(null) : l();
      } else {
        G = m ? 0 : e;
        var r = 4 * G, n = k.clippingState || null;
        g.value = n;
        n = a(w, f, r, h);
        for (w = 0; w !== r; ++w) {
          n[w] = c[w];
        }
        k.clippingState = n;
        this.numIntersection = b ? this.numPlanes : 0;
        this.numPlanes += G;
      }
    };
  }
  function nb(l) {
    var a = {};
    return {get:function(w) {
      if (void 0 !== a[w]) {
        return a[w];
      }
      switch(w) {
        case "WEBGL_depth_texture":
          var b = l.getExtension("WEBGL_depth_texture") || l.getExtension("MOZ_WEBGL_depth_texture") || l.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          b = l.getExtension("EXT_texture_filter_anisotropic") || l.getExtension("MOZ_EXT_texture_filter_anisotropic") || l.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          b = l.getExtension("WEBGL_compressed_texture_s3tc") || l.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || l.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          b = l.getExtension("WEBGL_compressed_texture_pvrtc") || l.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          b = l.getExtension(w);
      }
      null === b && console.warn("THREE.WebGLRenderer: " + w + " extension not supported.");
      return a[w] = b;
    }};
  }
  function zc(l, a, b) {
    function w(l) {
      var c = l.target;
      l = e.get(c);
      null !== l.index && a.remove(l.index);
      for (var m in l.attributes) {
        a.remove(l.attributes[m]);
      }
      c.removeEventListener("dispose", w);
      e.delete(c);
      if (m = d.get(l)) {
        a.remove(m), d.delete(l);
      }
      b.memory.geometries--;
    }
    function c(l) {
      var w = [], b = l.index, c = l.attributes.position;
      if (null !== b) {
        var e = b.array;
        b = b.version;
        c = 0;
        for (var m = e.length; c < m; c += 3) {
          var G = e[c + 0], f = e[c + 1], k = e[c + 2];
          w.push(G, f, f, k, k, G);
        }
      } else {
        for (e = c.array, b = c.version, c = 0, m = e.length / 3 - 1; c < m; c += 3) {
          G = c + 0, f = c + 1, k = c + 2, w.push(G, f, f, k, k, G);
        }
      }
      w = new (65535 < ca(w) ? Z : S)(w, 1);
      w.version = b;
      a.update(w, 34963);
      (e = d.get(l)) && a.remove(e);
      d.set(l, w);
    }
    var e = new WeakMap, d = new WeakMap;
    return {get:function(l, a) {
      var c = e.get(a);
      if (c) {
        return c;
      }
      a.addEventListener("dispose", w);
      a.isBufferGeometry ? c = a : a.isGeometry && (void 0 === a._bufferGeometry && (a._bufferGeometry = (new M).setFromObject(l)), c = a._bufferGeometry);
      e.set(a, c);
      b.memory.geometries++;
      return c;
    }, update:function(l) {
      var w = l.index, b = l.attributes;
      null !== w && a.update(w, 34963);
      for (var c in b) {
        a.update(b[c], 34962);
      }
      l = l.morphAttributes;
      for (c in l) {
        w = l[c];
        b = 0;
        for (var e = w.length; b < e; b++) {
          a.update(w[b], 34962);
        }
      }
    }, getWireframeAttribute:function(l) {
      var a = d.get(l);
      if (a) {
        var w = l.index;
        null !== w && a.version < w.version && c(l);
      } else {
        c(l);
      }
      return d.get(l);
    }};
  }
  function Bb(l, a, b, c) {
    var w = c.isWebGL2, e, d, m;
    this.setMode = function(l) {
      e = l;
    };
    this.setIndex = function(l) {
      d = l.type;
      m = l.bytesPerElement;
    };
    this.render = function(a, w) {
      l.drawElements(e, w, d, a * m);
      b.update(w, e);
    };
    this.renderInstances = function(c, G, f, k) {
      if (0 !== k) {
        if (w) {
          c = l;
          var h = "drawElementsInstanced";
        } else {
          if (c = a.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === c) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return;
          }
        }
        c[h](e, f, d, G * m, k);
        b.update(f, e, k);
      }
    };
  }
  function Rb(l) {
    var a = {frame:0, calls:0, triangles:0, points:0, lines:0};
    return {memory:{geometries:0, textures:0}, render:a, programs:null, autoReset:!0, reset:function() {
      a.frame++;
      a.calls = 0;
      a.triangles = 0;
      a.points = 0;
      a.lines = 0;
    }, update:function(l, w, b) {
      b = b || 1;
      a.calls++;
      switch(w) {
        case 4:
          a.triangles += l / 3 * b;
          break;
        case 1:
          a.lines += l / 2 * b;
          break;
        case 3:
          a.lines += b * (l - 1);
          break;
        case 2:
          a.lines += b * l;
          break;
        case 0:
          a.points += b * l;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", w);
      }
    }};
  }
  function Cb(l, a) {
    return Math.abs(a[1]) - Math.abs(l[1]);
  }
  function gb(l) {
    var a = {}, b = new Float32Array(8);
    return {update:function(w, c, e, d) {
      var m = w.morphTargetInfluences, G = void 0 === m ? 0 : m.length;
      w = a[c.id];
      if (void 0 === w) {
        w = [];
        for (var f = 0; f < G; f++) {
          w[f] = [f, 0];
        }
        a[c.id] = w;
      }
      var k = e.morphTargets && c.morphAttributes.position;
      e = e.morphNormals && c.morphAttributes.normal;
      for (f = 0; f < G; f++) {
        var h = w[f];
        0 !== h[1] && (k && c.deleteAttribute("morphTarget" + f), e && c.deleteAttribute("morphNormal" + f));
      }
      for (f = 0; f < G; f++) {
        h = w[f], h[0] = f, h[1] = m[f];
      }
      w.sort(Cb);
      for (f = m = 0; 8 > f; f++) {
        if (h = w[f]) {
          if (G = h[0], h = h[1]) {
            k && c.setAttribute("morphTarget" + f, k[G]);
            e && c.setAttribute("morphNormal" + f, e[G]);
            b[f] = h;
            m += h;
            continue;
          }
        }
        b[f] = 0;
      }
      c = c.morphTargetsRelative ? 1 : 1 - m;
      d.getUniforms().setValue(l, "morphTargetBaseInfluence", c);
      d.getUniforms().setValue(l, "morphTargetInfluences", b);
    }};
  }
  function Ac(l, a, b, c) {
    var w = new WeakMap;
    return {update:function(l) {
      var e = c.render.frame, d = l.geometry, m = a.get(l, d);
      w.get(m) !== e && (d.isGeometry && m.updateFromObject(l), a.update(m), w.set(m, e));
      l.isInstancedMesh && b.update(l.instanceMatrix, 34962);
      return m;
    }, dispose:function() {
      w = new WeakMap;
    }};
  }
  function Sa(l, a, b, c, d, m, f, k, h, g) {
    l = void 0 !== l ? l : [];
    e.call(this, l, void 0 !== a ? a : 301, b, c, d, m, void 0 !== f ? f : 1022, k, h, g);
    this.flipY = !1;
  }
  function za(l, a, b, c) {
    e.call(this, null);
    this.image = {data:l || null, width:a || 1, height:b || 1, depth:c || 1};
    this.minFilter = this.magFilter = 1003;
    this.wrapR = 1001;
    this.flipY = this.generateMipmaps = !1;
    this.needsUpdate = !0;
  }
  function hb(l, a, b, c) {
    e.call(this, null);
    this.image = {data:l || null, width:a || 1, height:b || 1, depth:c || 1};
    this.minFilter = this.magFilter = 1003;
    this.wrapR = 1001;
    this.flipY = this.generateMipmaps = !1;
    this.needsUpdate = !0;
  }
  function Oa(l, a, b) {
    var w = l[0];
    if (0 >= w || 0 < w) {
      return l;
    }
    var c = a * b, e = Ch[c];
    void 0 === e && (e = new Float32Array(c), Ch[c] = e);
    if (0 !== a) {
      for (w.toArray(e, 0), w = 1, c = 0; w !== a; ++w) {
        c += b, l[w].toArray(e, c);
      }
    }
    return e;
  }
  function La(l, a) {
    if (l.length !== a.length) {
      return !1;
    }
    for (var w = 0, b = l.length; w < b; w++) {
      if (l[w] !== a[w]) {
        return !1;
      }
    }
    return !0;
  }
  function Ma(l, a) {
    for (var w = 0, b = a.length; w < b; w++) {
      l[w] = a[w];
    }
  }
  function ib(l, a) {
    var w = Dh[a];
    void 0 === w && (w = new Int32Array(a), Dh[a] = w);
    for (var b = 0; b !== a; ++b) {
      w[b] = l.allocateTextureUnit();
    }
    return w;
  }
  function ob(l, a) {
    var w = this.cache;
    w[0] !== a && (l.uniform1f(this.addr, a), w[0] = a);
  }
  function ab(l, a) {
    var w = this.cache;
    if (void 0 !== a.x) {
      if (w[0] !== a.x || w[1] !== a.y) {
        l.uniform2f(this.addr, a.x, a.y), w[0] = a.x, w[1] = a.y;
      }
    } else {
      La(w, a) || (l.uniform2fv(this.addr, a), Ma(w, a));
    }
  }
  function Bc(l, a) {
    var w = this.cache;
    if (void 0 !== a.x) {
      if (w[0] !== a.x || w[1] !== a.y || w[2] !== a.z) {
        l.uniform3f(this.addr, a.x, a.y, a.z), w[0] = a.x, w[1] = a.y, w[2] = a.z;
      }
    } else {
      if (void 0 !== a.r) {
        if (w[0] !== a.r || w[1] !== a.g || w[2] !== a.b) {
          l.uniform3f(this.addr, a.r, a.g, a.b), w[0] = a.r, w[1] = a.g, w[2] = a.b;
        }
      } else {
        La(w, a) || (l.uniform3fv(this.addr, a), Ma(w, a));
      }
    }
  }
  function pb(l, a) {
    var w = this.cache;
    if (void 0 !== a.x) {
      if (w[0] !== a.x || w[1] !== a.y || w[2] !== a.z || w[3] !== a.w) {
        l.uniform4f(this.addr, a.x, a.y, a.z, a.w), w[0] = a.x, w[1] = a.y, w[2] = a.z, w[3] = a.w;
      }
    } else {
      La(w, a) || (l.uniform4fv(this.addr, a), Ma(w, a));
    }
  }
  function Db(l, a) {
    var w = this.cache, b = a.elements;
    void 0 === b ? La(w, a) || (l.uniformMatrix2fv(this.addr, !1, a), Ma(w, a)) : La(w, b) || (Eh.set(b), l.uniformMatrix2fv(this.addr, !1, Eh), Ma(w, b));
  }
  function Cc(l, a) {
    var w = this.cache, b = a.elements;
    void 0 === b ? La(w, a) || (l.uniformMatrix3fv(this.addr, !1, a), Ma(w, a)) : La(w, b) || (Fh.set(b), l.uniformMatrix3fv(this.addr, !1, Fh), Ma(w, b));
  }
  function U(l, a) {
    var w = this.cache, b = a.elements;
    void 0 === b ? La(w, a) || (l.uniformMatrix4fv(this.addr, !1, a), Ma(w, a)) : La(w, b) || (Gh.set(b), l.uniformMatrix4fv(this.addr, !1, Gh), Ma(w, b));
  }
  function qa(l, a, b) {
    var w = this.cache, c = b.allocateTextureUnit();
    w[0] !== c && (l.uniform1i(this.addr, c), w[0] = c);
    b.safeSetTexture2D(a || Hh, c);
  }
  function ra(l, a, b) {
    var w = this.cache, c = b.allocateTextureUnit();
    w[0] !== c && (l.uniform1i(this.addr, c), w[0] = c);
    b.setTexture2DArray(a || pj, c);
  }
  function Ca(l, a, b) {
    var w = this.cache, c = b.allocateTextureUnit();
    w[0] !== c && (l.uniform1i(this.addr, c), w[0] = c);
    b.setTexture3D(a || qj, c);
  }
  function dd(l, a, b) {
    var w = this.cache, c = b.allocateTextureUnit();
    w[0] !== c && (l.uniform1i(this.addr, c), w[0] = c);
    b.safeSetTextureCube(a || Ih, c);
  }
  function Yd(l, a) {
    var w = this.cache;
    w[0] !== a && (l.uniform1i(this.addr, a), w[0] = a);
  }
  function Eb(l, a) {
    var w = this.cache;
    La(w, a) || (l.uniform2iv(this.addr, a), Ma(w, a));
  }
  function hc(l, a) {
    var w = this.cache;
    La(w, a) || (l.uniform3iv(this.addr, a), Ma(w, a));
  }
  function ic(l, a) {
    var w = this.cache;
    La(w, a) || (l.uniform4iv(this.addr, a), Ma(w, a));
  }
  function Ze(l, a) {
    var w = this.cache;
    w[0] !== a && (l.uniform1ui(this.addr, a), w[0] = a);
  }
  function ed(l) {
    switch(l) {
      case 5126:
        return ob;
      case 35664:
        return ab;
      case 35665:
        return Bc;
      case 35666:
        return pb;
      case 35674:
        return Db;
      case 35675:
        return Cc;
      case 35676:
        return U;
      case 5124:
      case 35670:
        return Yd;
      case 35667:
      case 35671:
        return Eb;
      case 35668:
      case 35672:
        return hc;
      case 35669:
      case 35673:
        return ic;
      case 5125:
        return Ze;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return qa;
      case 35679:
      case 36299:
      case 36307:
        return Ca;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return dd;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return ra;
    }
  }
  function Zd(l, a) {
    l.uniform1fv(this.addr, a);
  }
  function la(l, a) {
    l.uniform1iv(this.addr, a);
  }
  function jb(l, a) {
    l.uniform2iv(this.addr, a);
  }
  function bb(l, a) {
    l.uniform3iv(this.addr, a);
  }
  function fd(l, a) {
    l.uniform4iv(this.addr, a);
  }
  function jc(l, a) {
    a = Oa(a, this.size, 2);
    l.uniform2fv(this.addr, a);
  }
  function Pa(l, a) {
    a = Oa(a, this.size, 3);
    l.uniform3fv(this.addr, a);
  }
  function Fb(l, a) {
    a = Oa(a, this.size, 4);
    l.uniform4fv(this.addr, a);
  }
  function $e(l, a) {
    a = Oa(a, this.size, 4);
    l.uniformMatrix2fv(this.addr, !1, a);
  }
  function qb(l, a) {
    a = Oa(a, this.size, 9);
    l.uniformMatrix3fv(this.addr, !1, a);
  }
  function rj(l, a) {
    a = Oa(a, this.size, 16);
    l.uniformMatrix4fv(this.addr, !1, a);
  }
  function sj(l, a, b) {
    var w = a.length, c = ib(b, w);
    l.uniform1iv(this.addr, c);
    for (l = 0; l !== w; ++l) {
      b.safeSetTexture2D(a[l] || Hh, c[l]);
    }
  }
  function tj(l, a, b) {
    var w = a.length, c = ib(b, w);
    l.uniform1iv(this.addr, c);
    for (l = 0; l !== w; ++l) {
      b.safeSetTextureCube(a[l] || Ih, c[l]);
    }
  }
  function uj(l) {
    switch(l) {
      case 5126:
        return Zd;
      case 35664:
        return jc;
      case 35665:
        return Pa;
      case 35666:
        return Fb;
      case 35674:
        return $e;
      case 35675:
        return qb;
      case 35676:
        return rj;
      case 5124:
      case 35670:
        return la;
      case 35667:
      case 35671:
        return jb;
      case 35668:
      case 35672:
        return bb;
      case 35669:
      case 35673:
        return fd;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return sj;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return tj;
    }
  }
  function vj(l, a, b) {
    this.id = l;
    this.addr = b;
    this.cache = [];
    this.setValue = ed(a.type);
  }
  function Jh(l, a, b) {
    this.id = l;
    this.addr = b;
    this.cache = [];
    this.size = a.size;
    this.setValue = uj(a.type);
  }
  function Kh(l) {
    this.id = l;
    this.seq = [];
    this.map = {};
  }
  function kc(l, a) {
    this.seq = [];
    this.map = {};
    for (var b = l.getProgramParameter(a, 35718), w = 0; w < b; ++w) {
      var c = l.getActiveUniform(a, w), e = l.getUniformLocation(a, c.name), d = this, m = c.name, f = m.length;
      for (qg.lastIndex = 0;;) {
        var k = qg.exec(m), h = qg.lastIndex, g = k[1], r = k[3];
        "]" === k[2] && (g |= 0);
        if (void 0 === r || "[" === r && h + 2 === f) {
          m = d;
          c = void 0 === r ? new vj(g, c, e) : new Jh(g, c, e);
          m.seq.push(c);
          m.map[c.id] = c;
          break;
        } else {
          r = d.map[g], void 0 === r && (r = new Kh(g), g = d, d = r, g.seq.push(d), g.map[d.id] = d), d = r;
        }
      }
    }
  }
  function Lh(l, a, b) {
    a = l.createShader(a);
    l.shaderSource(a, b);
    l.compileShader(a);
    return a;
  }
  function Mh(l) {
    switch(l) {
      case 3E3:
        return ["Linear", "( value )"];
      case 3001:
        return ["sRGB", "( value )"];
      case 3002:
        return ["RGBE", "( value )"];
      case 3004:
        return ["RGBM", "( value, 7.0 )"];
      case 3005:
        return ["RGBM", "( value, 16.0 )"];
      case 3006:
        return ["RGBD", "( value, 256.0 )"];
      case 3007:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      case 3003:
        return ["LogLuv", "( value )"];
      default:
        throw Error("unsupported encoding: " + l);
    }
  }
  function Nh(l, a, b) {
    var w = l.getShaderParameter(a, 35713), c = l.getShaderInfoLog(a).trim();
    if (w && "" === c) {
      return "";
    }
    l = l.getShaderSource(a).split("\n");
    for (a = 0; a < l.length; a++) {
      l[a] = a + 1 + ": " + l[a];
    }
    l = l.join("\n");
    return "THREE.WebGLShader: gl.getShaderInfoLog() " + b + "\n" + c + l;
  }
  function $d(l, a) {
    a = Mh(a);
    return "vec4 " + l + "( vec4 value ) { return " + a[0] + "ToLinear" + a[1] + "; }";
  }
  function wj(l, a) {
    a = Mh(a);
    return "vec4 " + l + "( vec4 value ) { return LinearTo" + a[0] + a[1] + "; }";
  }
  function xj(l, a) {
    switch(a) {
      case 1:
        a = "Linear";
        break;
      case 2:
        a = "Reinhard";
        break;
      case 3:
        a = "Uncharted2";
        break;
      case 4:
        a = "OptimizedCineon";
        break;
      case 5:
        a = "ACESFilmic";
        break;
      default:
        throw Error("unsupported toneMapping: " + a);
    }
    return "vec3 " + l + "( vec3 color ) { return " + a + "ToneMapping( color ); }";
  }
  function yj(l) {
    var a = [], b;
    for (b in l) {
      var c = l[b];
      !1 !== c && a.push("#define " + b + " " + c);
    }
    return a.join("\n");
  }
  function ae(l) {
    return "" !== l;
  }
  function Oh(l, a) {
    return l.replace(/NUM_DIR_LIGHTS/g, a.numDirLights).replace(/NUM_SPOT_LIGHTS/g, a.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, a.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, a.numPointLights).replace(/NUM_HEMI_LIGHTS/g, a.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, a.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, a.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, a.numPointLightShadows);
  }
  function Ph(l, a) {
    return l.replace(/NUM_CLIPPING_PLANES/g, a.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, a.numClippingPlanes - a.numClipIntersection);
  }
  function rg(l, a) {
    l = oa[a];
    if (void 0 === l) {
      throw Error("Can not resolve #include <" + a + ">");
    }
    return l.replace(sg, rg);
  }
  function Qh(l, a, b, c) {
    console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
    return tg(l, a, b, c);
  }
  function tg(l, a, b, c) {
    l = "";
    for (a = parseInt(a); a < parseInt(b); a++) {
      l += c.replace(/\[ i \]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
    }
    return l;
  }
  function Rh(l) {
    var a = "precision " + l.precision + " float;\nprecision " + l.precision + " int;";
    "highp" === l.precision ? a += "\n#define HIGH_PRECISION" : "mediump" === l.precision ? a += "\n#define MEDIUM_PRECISION" : "lowp" === l.precision && (a += "\n#define LOW_PRECISION");
    return a;
  }
  function zj(l) {
    var a = "SHADOWMAP_TYPE_BASIC";
    1 === l.shadowMapType ? a = "SHADOWMAP_TYPE_PCF" : 2 === l.shadowMapType ? a = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === l.shadowMapType && (a = "SHADOWMAP_TYPE_VSM");
    return a;
  }
  function Aj(l) {
    var a = "ENVMAP_TYPE_CUBE";
    if (l.envMap) {
      switch(l.envMapMode) {
        case 301:
        case 302:
          a = "ENVMAP_TYPE_CUBE";
          break;
        case 306:
        case 307:
          a = "ENVMAP_TYPE_CUBE_UV";
          break;
        case 303:
        case 304:
          a = "ENVMAP_TYPE_EQUIREC";
          break;
        case 305:
          a = "ENVMAP_TYPE_SPHERE";
      }
    }
    return a;
  }
  function Bj(l) {
    var a = "ENVMAP_MODE_REFLECTION";
    if (l.envMap) {
      switch(l.envMapMode) {
        case 302:
        case 304:
          a = "ENVMAP_MODE_REFRACTION";
      }
    }
    return a;
  }
  function Cj(l) {
    var a = "ENVMAP_BLENDING_NONE";
    if (l.envMap) {
      switch(l.combine) {
        case 0:
          a = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case 1:
          a = "ENVMAP_BLENDING_MIX";
          break;
        case 2:
          a = "ENVMAP_BLENDING_ADD";
      }
    }
    return a;
  }
  function Dj(l, a, b) {
    var w = l.getContext(), c = b.defines, e = b.vertexShader, d = b.fragmentShader, m = zj(b), f = Aj(b), k = Bj(b), h = Cj(b), g = 0 < l.gammaFactor ? l.gammaFactor : 1, G = b.isWebGL2 ? "" : [b.extensionDerivatives || b.envMapCubeUV || b.bumpMap || b.tangentSpaceNormalMap || b.clearcoatNormalMap || b.flatShading || "physical" === b.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (b.extensionFragDepth || b.logarithmicDepthBuffer) && b.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : 
    "", b.extensionDrawBuffers && b.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (b.extensionShaderTextureLOD || b.envMap) && b.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ae).join("\n"), r = yj(c), n = w.createProgram();
    b.isRawShaderMaterial ? (c = [r].filter(ae).join("\n"), 0 < c.length && (c += "\n"), m = [G, r].filter(ae).join("\n"), 0 < m.length && (m += "\n")) : (c = [Rh(b), "#define SHADER_NAME " + b.shaderName, r, b.instancing ? "#define USE_INSTANCING" : "", b.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + g, "#define MAX_BONES " + b.maxBones, b.useFog && b.fog ? "#define USE_FOG" : "", b.useFog && b.fogExp2 ? "#define FOG_EXP2" : "", b.map ? "#define USE_MAP" : "", 
    b.envMap ? "#define USE_ENVMAP" : "", b.envMap ? "#define " + k : "", b.lightMap ? "#define USE_LIGHTMAP" : "", b.aoMap ? "#define USE_AOMAP" : "", b.emissiveMap ? "#define USE_EMISSIVEMAP" : "", b.bumpMap ? "#define USE_BUMPMAP" : "", b.normalMap ? "#define USE_NORMALMAP" : "", b.normalMap && b.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", b.normalMap && b.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", b.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", b.clearcoatRoughnessMap ? 
    "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", b.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", b.displacementMap && b.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", b.specularMap ? "#define USE_SPECULARMAP" : "", b.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", b.metalnessMap ? "#define USE_METALNESSMAP" : "", b.alphaMap ? "#define USE_ALPHAMAP" : "", b.vertexTangents ? "#define USE_TANGENT" : "", b.vertexColors ? "#define USE_COLOR" : "", b.vertexUvs ? "#define USE_UV" : 
    "", b.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", b.flatShading ? "#define FLAT_SHADED" : "", b.skinning ? "#define USE_SKINNING" : "", b.useVertexTexture ? "#define BONE_TEXTURE" : "", b.morphTargets ? "#define USE_MORPHTARGETS" : "", b.morphNormals && !1 === b.flatShading ? "#define USE_MORPHNORMALS" : "", b.doubleSided ? "#define DOUBLE_SIDED" : "", b.flipSided ? "#define FLIP_SIDED" : "", b.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", b.shadowMapEnabled ? "#define " + m : "", b.sizeAttenuation ? 
    "#define USE_SIZEATTENUATION" : "", b.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", b.logarithmicDepthBuffer && b.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", 
    "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", 
    "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ae).join("\n"), m = [G, Rh(b), "#define SHADER_NAME " + b.shaderName, r, b.alphaTest ? "#define ALPHATEST " + b.alphaTest + (b.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + g, b.useFog && b.fog ? "#define USE_FOG" : 
    "", b.useFog && b.fogExp2 ? "#define FOG_EXP2" : "", b.map ? "#define USE_MAP" : "", b.matcap ? "#define USE_MATCAP" : "", b.envMap ? "#define USE_ENVMAP" : "", b.envMap ? "#define " + f : "", b.envMap ? "#define " + k : "", b.envMap ? "#define " + h : "", b.lightMap ? "#define USE_LIGHTMAP" : "", b.aoMap ? "#define USE_AOMAP" : "", b.emissiveMap ? "#define USE_EMISSIVEMAP" : "", b.bumpMap ? "#define USE_BUMPMAP" : "", b.normalMap ? "#define USE_NORMALMAP" : "", b.normalMap && b.objectSpaceNormalMap ? 
    "#define OBJECTSPACE_NORMALMAP" : "", b.normalMap && b.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", b.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", b.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", b.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", b.specularMap ? "#define USE_SPECULARMAP" : "", b.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", b.metalnessMap ? "#define USE_METALNESSMAP" : "", b.alphaMap ? "#define USE_ALPHAMAP" : "", b.sheen ? 
    "#define USE_SHEEN" : "", b.vertexTangents ? "#define USE_TANGENT" : "", b.vertexColors ? "#define USE_COLOR" : "", b.vertexUvs ? "#define USE_UV" : "", b.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", b.gradientMap ? "#define USE_GRADIENTMAP" : "", b.flatShading ? "#define FLAT_SHADED" : "", b.doubleSided ? "#define DOUBLE_SIDED" : "", b.flipSided ? "#define FLIP_SIDED" : "", b.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", b.shadowMapEnabled ? "#define " + m : "", b.premultipliedAlpha ? 
    "#define PREMULTIPLIED_ALPHA" : "", b.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", b.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", b.logarithmicDepthBuffer && b.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (b.extensionShaderTextureLOD || b.envMap) && b.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== b.toneMapping ? "#define TONE_MAPPING" : 
    "", 0 !== b.toneMapping ? oa.tonemapping_pars_fragment : "", 0 !== b.toneMapping ? xj("toneMapping", b.toneMapping) : "", b.dithering ? "#define DITHERING" : "", b.outputEncoding || b.mapEncoding || b.matcapEncoding || b.envMapEncoding || b.emissiveMapEncoding || b.lightMapEncoding ? oa.encodings_pars_fragment : "", b.mapEncoding ? $d("mapTexelToLinear", b.mapEncoding) : "", b.matcapEncoding ? $d("matcapTexelToLinear", b.matcapEncoding) : "", b.envMapEncoding ? $d("envMapTexelToLinear", b.envMapEncoding) : 
    "", b.emissiveMapEncoding ? $d("emissiveMapTexelToLinear", b.emissiveMapEncoding) : "", b.lightMapEncoding ? $d("lightMapTexelToLinear", b.lightMapEncoding) : "", b.outputEncoding ? wj("linearToOutputTexel", b.outputEncoding) : "", b.depthPacking ? "#define DEPTH_PACKING " + b.depthPacking : "", "\n"].filter(ae).join("\n"));
    e = e.replace(sg, rg);
    e = Oh(e, b);
    e = Ph(e, b);
    d = d.replace(sg, rg);
    d = Oh(d, b);
    d = Ph(d, b);
    e = e.replace(Sh, tg).replace(Th, Qh);
    d = d.replace(Sh, tg).replace(Th, Qh);
    b.isWebGL2 && !b.isRawShaderMaterial && (f = !1, k = /^\s*#version\s+300\s+es\s*\n/, b.isShaderMaterial && null !== e.match(k) && null !== d.match(k) && (f = !0, e = e.replace(k, ""), d = d.replace(k, "")), c = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + c, m = ["#version 300 es\n\n#define varying in", f ? "" : "out highp vec4 pc_fragColor;", f ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + 
    "\n" + m);
    d = m + d;
    e = Lh(w, 35633, c + e);
    d = Lh(w, 35632, d);
    w.attachShader(n, e);
    w.attachShader(n, d);
    void 0 !== b.index0AttributeName ? w.bindAttribLocation(n, 0, b.index0AttributeName) : !0 === b.morphTargets && w.bindAttribLocation(n, 0, "position");
    w.linkProgram(n);
    if (l.debug.checkShaderErrors) {
      l = w.getProgramInfoLog(n).trim();
      f = w.getShaderInfoLog(e).trim();
      k = w.getShaderInfoLog(d).trim();
      g = h = !0;
      if (!1 === w.getProgramParameter(n, 35714)) {
        h = !1, G = Nh(w, e, "vertex"), r = Nh(w, d, "fragment"), console.error("THREE.WebGLProgram: shader error: ", w.getError(), "35715", w.getProgramParameter(n, 35715), "gl.getProgramInfoLog", l, G, r);
      } else {
        if ("" !== l) {
          console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", l);
        } else {
          if ("" === f || "" === k) {
            g = !1;
          }
        }
      }
      g && (this.diagnostics = {runnable:h, programLog:l, vertexShader:{log:f, prefix:c}, fragmentShader:{log:k, prefix:m}});
    }
    w.detachShader(n, e);
    w.detachShader(n, d);
    w.deleteShader(e);
    w.deleteShader(d);
    var q;
    this.getUniforms = function() {
      void 0 === q && (q = new kc(w, n));
      return q;
    };
    var p;
    this.getAttributes = function() {
      if (void 0 === p) {
        for (var l = {}, a = w.getProgramParameter(n, 35721), b = 0; b < a; b++) {
          var c = w.getActiveAttrib(n, b).name;
          l[c] = w.getAttribLocation(n, c);
        }
        p = l;
      }
      return p;
    };
    this.destroy = function() {
      w.deleteProgram(n);
      this.program = void 0;
    };
    this.name = b.shaderName;
    this.id = Ej++;
    this.cacheKey = a;
    this.usedTimes = 1;
    this.program = n;
    this.vertexShader = e;
    this.fragmentShader = d;
    return this;
  }
  function Fj(l, a, b) {
    function w(l) {
      if (l) {
        l.isTexture ? a = l.encoding : l.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), a = l.texture.encoding);
      } else {
        var a = 3E3;
      }
      return a;
    }
    var c = [], e = b.isWebGL2, d = b.logarithmicDepthBuffer, m = b.floatVertexTextures, f = b.precision, k = b.maxVertexUniforms, h = b.vertexTextures, g = {MeshDepthMaterial:"depth", MeshDistanceMaterial:"distanceRGBA", MeshNormalMaterial:"normal", MeshBasicMaterial:"basic", MeshLambertMaterial:"lambert", MeshPhongMaterial:"phong", MeshToonMaterial:"toon", MeshStandardMaterial:"physical", MeshPhysicalMaterial:"physical", MeshMatcapMaterial:"matcap", LineBasicMaterial:"basic", LineDashedMaterial:"dashed", 
    PointsMaterial:"points", ShadowMaterial:"shadow", SpriteMaterial:"sprite"}, G = "precision isWebGL2 supportsVertexTextures outputEncoding instancing map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding envMapCubeUV lightMap lightMapEncoding aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap tangentSpaceNormalMap clearcoatMap clearcoatRoughnessMap clearcoatNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents vertexUvs uvsVertexOnly fog useFog fogExp2 flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights numDirLightShadows numPointLightShadows numSpotLightShadows shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering sheen".split(" ");
    this.getParameters = function(c, G, r, n, q, p, u) {
      var t = n.fog;
      n = c.isMeshStandardMaterial ? n.environment : null;
      n = c.envMap || n;
      var ba = g[c.type];
      if (u.isSkinnedMesh) {
        var y = u.skeleton.bones;
        if (m) {
          y = 1024;
        } else {
          var v = Math.min(Math.floor((k - 20) / 4), y.length);
          v < y.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + y.length + " bones. This GPU supports " + v + "."), y = 0) : y = v;
        }
      } else {
        y = 0;
      }
      null !== c.precision && (f = b.getMaxPrecision(c.precision), f !== c.precision && console.warn("THREE.WebGLProgram.getParameters:", c.precision, "not supported, using", f, "instead."));
      ba ? (v = Ab[ba], v = {name:c.type, uniforms:Uh.clone(v.uniforms), vertexShader:v.vertexShader, fragmentShader:v.fragmentShader}) : v = {name:c.type, uniforms:c.uniforms, vertexShader:c.vertexShader, fragmentShader:c.fragmentShader};
      c.onBeforeCompile(v, l);
      var x = l.getRenderTarget();
      return {isWebGL2:e, shaderID:ba, shaderName:v.name, uniforms:v.uniforms, vertexShader:v.vertexShader, fragmentShader:v.fragmentShader, defines:c.defines, isRawShaderMaterial:c.isRawShaderMaterial, isShaderMaterial:c.isShaderMaterial, precision:f, instancing:!0 === u.isInstancedMesh, supportsVertexTextures:h, outputEncoding:null !== x ? w(x.texture) : l.outputEncoding, map:!!c.map, mapEncoding:w(c.map), matcap:!!c.matcap, matcapEncoding:w(c.matcap), envMap:!!n, envMapMode:n && n.mapping, envMapEncoding:w(n), 
      envMapCubeUV:!!n && (306 === n.mapping || 307 === n.mapping), lightMap:!!c.lightMap, lightMapEncoding:w(c.lightMap), aoMap:!!c.aoMap, emissiveMap:!!c.emissiveMap, emissiveMapEncoding:w(c.emissiveMap), bumpMap:!!c.bumpMap, normalMap:!!c.normalMap, objectSpaceNormalMap:1 === c.normalMapType, tangentSpaceNormalMap:0 === c.normalMapType, clearcoatMap:!!c.clearcoatMap, clearcoatRoughnessMap:!!c.clearcoatRoughnessMap, clearcoatNormalMap:!!c.clearcoatNormalMap, displacementMap:!!c.displacementMap, 
      roughnessMap:!!c.roughnessMap, metalnessMap:!!c.metalnessMap, specularMap:!!c.specularMap, alphaMap:!!c.alphaMap, gradientMap:!!c.gradientMap, sheen:!!c.sheen, combine:c.combine, vertexTangents:c.normalMap && c.vertexTangents, vertexColors:c.vertexColors, vertexUvs:!!c.map || !!c.bumpMap || !!c.normalMap || !!c.specularMap || !!c.alphaMap || !!c.emissiveMap || !!c.roughnessMap || !!c.metalnessMap || !!c.clearcoatMap || !!c.clearcoatRoughnessMap || !!c.clearcoatNormalMap || !!c.displacementMap, 
      uvsVertexOnly:!(c.map || c.bumpMap || c.normalMap || c.specularMap || c.alphaMap || c.emissiveMap || c.roughnessMap || c.metalnessMap || c.clearcoatNormalMap) && !!c.displacementMap, fog:!!t, useFog:c.fog, fogExp2:t && t.isFogExp2, flatShading:c.flatShading, sizeAttenuation:c.sizeAttenuation, logarithmicDepthBuffer:d, skinning:c.skinning && 0 < y, maxBones:y, useVertexTexture:m, morphTargets:c.morphTargets, morphNormals:c.morphNormals, maxMorphTargets:l.maxMorphTargets, maxMorphNormals:l.maxMorphNormals, 
      numDirLights:G.directional.length, numPointLights:G.point.length, numSpotLights:G.spot.length, numRectAreaLights:G.rectArea.length, numHemiLights:G.hemi.length, numDirLightShadows:G.directionalShadowMap.length, numPointLightShadows:G.pointShadowMap.length, numSpotLightShadows:G.spotShadowMap.length, numClippingPlanes:q, numClipIntersection:p, dithering:c.dithering, shadowMapEnabled:l.shadowMap.enabled && 0 < r.length, shadowMapType:l.shadowMap.type, toneMapping:c.toneMapped ? l.toneMapping : 
      0, physicallyCorrectLights:l.physicallyCorrectLights, premultipliedAlpha:c.premultipliedAlpha, alphaTest:c.alphaTest, doubleSided:2 === c.side, flipSided:1 === c.side, depthPacking:void 0 !== c.depthPacking ? c.depthPacking : !1, index0AttributeName:c.index0AttributeName, extensionDerivatives:c.extensions && c.extensions.derivatives, extensionFragDepth:c.extensions && c.extensions.fragDepth, extensionDrawBuffers:c.extensions && c.extensions.drawBuffers, extensionShaderTextureLOD:c.extensions && 
      c.extensions.shaderTextureLOD, rendererExtensionFragDepth:e || null !== a.get("EXT_frag_depth"), rendererExtensionDrawBuffers:e || null !== a.get("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod:e || null !== a.get("EXT_shader_texture_lod"), onBeforeCompile:c.onBeforeCompile};
    };
    this.getProgramCacheKey = function(a) {
      var b = [];
      a.shaderID ? b.push(a.shaderID) : (b.push(a.fragmentShader), b.push(a.vertexShader));
      if (void 0 !== a.defines) {
        for (var c in a.defines) {
          b.push(c), b.push(a.defines[c]);
        }
      }
      if (void 0 === a.isRawShaderMaterial) {
        for (c = 0; c < G.length; c++) {
          b.push(a[G[c]]);
        }
        b.push(l.outputEncoding);
        b.push(l.gammaFactor);
      }
      b.push(a.onBeforeCompile.toString());
      return b.join();
    };
    this.acquireProgram = function(a, b) {
      for (var w, e = 0, d = c.length; e < d; e++) {
        var m = c[e];
        if (m.cacheKey === b) {
          w = m;
          ++w.usedTimes;
          break;
        }
      }
      void 0 === w && (w = new Dj(l, b, a), c.push(w));
      return w;
    };
    this.releaseProgram = function(l) {
      if (0 === --l.usedTimes) {
        var a = c.indexOf(l);
        c[a] = c[c.length - 1];
        c.pop();
        l.destroy();
      }
    };
    this.programs = c;
  }
  function Gj() {
    var l = new WeakMap;
    return {get:function(a) {
      var b = l.get(a);
      void 0 === b && (b = {}, l.set(a, b));
      return b;
    }, remove:function(a) {
      l.delete(a);
    }, update:function(a, b, c) {
      l.get(a)[b] = c;
    }, dispose:function() {
      l = new WeakMap;
    }};
  }
  function Hj(l, a) {
    return l.groupOrder !== a.groupOrder ? l.groupOrder - a.groupOrder : l.renderOrder !== a.renderOrder ? l.renderOrder - a.renderOrder : l.program !== a.program ? l.program.id - a.program.id : l.material.id !== a.material.id ? l.material.id - a.material.id : l.z !== a.z ? l.z - a.z : l.id - a.id;
  }
  function Ij(l, a) {
    return l.groupOrder !== a.groupOrder ? l.groupOrder - a.groupOrder : l.renderOrder !== a.renderOrder ? l.renderOrder - a.renderOrder : l.z !== a.z ? a.z - l.z : l.id - a.id;
  }
  function Vh() {
    function l(l, c, w, e, m, f) {
      var k = a[b];
      void 0 === k ? (k = {id:l.id, object:l, geometry:c, material:w, program:w.program || d, groupOrder:e, renderOrder:l.renderOrder, z:m, group:f}, a[b] = k) : (k.id = l.id, k.object = l, k.geometry = c, k.material = w, k.program = w.program || d, k.groupOrder = e, k.renderOrder = l.renderOrder, k.z = m, k.group = f);
      b++;
      return k;
    }
    var a = [], b = 0, c = [], e = [], d = {id:-1};
    return {opaque:c, transparent:e, init:function() {
      b = 0;
      c.length = 0;
      e.length = 0;
    }, push:function(a, b, w, d, m, f) {
      a = l(a, b, w, d, m, f);
      (!0 === w.transparent ? e : c).push(a);
    }, unshift:function(a, b, w, d, m, f) {
      a = l(a, b, w, d, m, f);
      (!0 === w.transparent ? e : c).unshift(a);
    }, finish:function() {
      for (var l = b, c = a.length; l < c; l++) {
        var w = a[l];
        if (null === w.id) {
          break;
        }
        w.id = null;
        w.object = null;
        w.geometry = null;
        w.material = null;
        w.program = null;
        w.group = null;
      }
    }, sort:function(l, a) {
      1 < c.length && c.sort(l || Hj);
      1 < e.length && e.sort(a || Ij);
    }};
  }
  function Jj() {
    function l(b) {
      b = b.target;
      b.removeEventListener("dispose", l);
      a.delete(b);
    }
    var a = new WeakMap;
    return {get:function(b, c) {
      var w = a.get(b);
      if (void 0 === w) {
        var e = new Vh;
        a.set(b, new WeakMap);
        a.get(b).set(c, e);
        b.addEventListener("dispose", l);
      } else {
        e = w.get(c), void 0 === e && (e = new Vh, w.set(c, e));
      }
      return e;
    }, dispose:function() {
      a = new WeakMap;
    }};
  }
  function Kj() {
    var l = {};
    return {get:function(a) {
      if (void 0 !== l[a.id]) {
        return l[a.id];
      }
      switch(a.type) {
        case "DirectionalLight":
          var b = {direction:new f, color:new A};
          break;
        case "SpotLight":
          b = {position:new f, direction:new f, color:new A, distance:0, coneCos:0, penumbraCos:0, decay:0};
          break;
        case "PointLight":
          b = {position:new f, color:new A, distance:0, decay:0};
          break;
        case "HemisphereLight":
          b = {direction:new f, skyColor:new A, groundColor:new A};
          break;
        case "RectAreaLight":
          b = {color:new A, position:new f, halfWidth:new f, halfHeight:new f};
      }
      return l[a.id] = b;
    }};
  }
  function Lj() {
    var l = {};
    return {get:function(a) {
      if (void 0 !== l[a.id]) {
        return l[a.id];
      }
      switch(a.type) {
        case "DirectionalLight":
          var b = {shadowBias:0, shadowRadius:1, shadowMapSize:new g};
          break;
        case "SpotLight":
          b = {shadowBias:0, shadowRadius:1, shadowMapSize:new g};
          break;
        case "PointLight":
          b = {shadowBias:0, shadowRadius:1, shadowMapSize:new g, shadowCameraNear:1, shadowCameraFar:1E3};
      }
      return l[a.id] = b;
    }};
  }
  function Mj(l, a) {
    return (a.castShadow ? 1 : 0) - (l.castShadow ? 1 : 0);
  }
  function Nj() {
    for (var l = new Kj, a = Lj(), b = {version:0, hash:{directionalLength:-1, pointLength:-1, spotLength:-1, rectAreaLength:-1, hemiLength:-1, numDirectionalShadows:-1, numPointShadows:-1, numSpotShadows:-1}, ambient:[0, 0, 0], probe:[], directional:[], directionalShadow:[], directionalShadowMap:[], directionalShadowMatrix:[], spot:[], spotShadow:[], spotShadowMap:[], spotShadowMatrix:[], rectArea:[], point:[], pointShadow:[], pointShadowMap:[], pointShadowMatrix:[], hemi:[]}, c = 0; 9 > c; c++) {
      b.probe.push(new f);
    }
    var e = new f, d = new n, m = new n;
    return {setup:function(c, w, f) {
      for (var k = 0, h = 0, g = 0, G = 0; 9 > G; G++) {
        b.probe[G].set(0, 0, 0);
      }
      var r = w = 0, n = 0, q = 0, p = 0, u = 0, t = 0, ba = 0;
      f = f.matrixWorldInverse;
      c.sort(Mj);
      G = 0;
      for (var y = c.length; G < y; G++) {
        var v = c[G], x = v.color, da = v.intensity, U = v.distance, z = v.shadow && v.shadow.map ? v.shadow.map.texture : null;
        if (v.isAmbientLight) {
          k += x.r * da, h += x.g * da, g += x.b * da;
        } else {
          if (v.isLightProbe) {
            for (z = 0; 9 > z; z++) {
              b.probe[z].addScaledVector(v.sh.coefficients[z], da);
            }
          } else {
            if (v.isDirectionalLight) {
              var ia = l.get(v);
              ia.color.copy(v.color).multiplyScalar(v.intensity);
              ia.direction.setFromMatrixPosition(v.matrixWorld);
              e.setFromMatrixPosition(v.target.matrixWorld);
              ia.direction.sub(e);
              ia.direction.transformDirection(f);
              v.castShadow && (da = v.shadow, x = a.get(v), x.shadowBias = da.bias, x.shadowRadius = da.radius, x.shadowMapSize = da.mapSize, b.directionalShadow[w] = x, b.directionalShadowMap[w] = z, b.directionalShadowMatrix[w] = v.shadow.matrix, u++);
              b.directional[w] = ia;
              w++;
            } else {
              v.isSpotLight ? (ia = l.get(v), ia.position.setFromMatrixPosition(v.matrixWorld), ia.position.applyMatrix4(f), ia.color.copy(x).multiplyScalar(da), ia.distance = U, ia.direction.setFromMatrixPosition(v.matrixWorld), e.setFromMatrixPosition(v.target.matrixWorld), ia.direction.sub(e), ia.direction.transformDirection(f), ia.coneCos = Math.cos(v.angle), ia.penumbraCos = Math.cos(v.angle * (1 - v.penumbra)), ia.decay = v.decay, v.castShadow && (da = v.shadow, x = a.get(v), x.shadowBias = 
              da.bias, x.shadowRadius = da.radius, x.shadowMapSize = da.mapSize, b.spotShadow[n] = x, b.spotShadowMap[n] = z, b.spotShadowMatrix[n] = v.shadow.matrix, ba++), b.spot[n] = ia, n++) : v.isRectAreaLight ? (ia = l.get(v), ia.color.copy(x).multiplyScalar(da), ia.position.setFromMatrixPosition(v.matrixWorld), ia.position.applyMatrix4(f), m.identity(), d.copy(v.matrixWorld), d.premultiply(f), m.extractRotation(d), ia.halfWidth.set(.5 * v.width, 0, 0), ia.halfHeight.set(0, .5 * v.height, 0), 
              ia.halfWidth.applyMatrix4(m), ia.halfHeight.applyMatrix4(m), b.rectArea[q] = ia, q++) : v.isPointLight ? (ia = l.get(v), ia.position.setFromMatrixPosition(v.matrixWorld), ia.position.applyMatrix4(f), ia.color.copy(v.color).multiplyScalar(v.intensity), ia.distance = v.distance, ia.decay = v.decay, v.castShadow && (da = v.shadow, x = a.get(v), x.shadowBias = da.bias, x.shadowRadius = da.radius, x.shadowMapSize = da.mapSize, x.shadowCameraNear = da.camera.near, x.shadowCameraFar = da.camera.far, 
              b.pointShadow[r] = x, b.pointShadowMap[r] = z, b.pointShadowMatrix[r] = v.shadow.matrix, t++), b.point[r] = ia, r++) : v.isHemisphereLight && (ia = l.get(v), ia.direction.setFromMatrixPosition(v.matrixWorld), ia.direction.transformDirection(f), ia.direction.normalize(), ia.skyColor.copy(v.color).multiplyScalar(da), ia.groundColor.copy(v.groundColor).multiplyScalar(da), b.hemi[p] = ia, p++);
            }
          }
        }
      }
      b.ambient[0] = k;
      b.ambient[1] = h;
      b.ambient[2] = g;
      c = b.hash;
      if (c.directionalLength !== w || c.pointLength !== r || c.spotLength !== n || c.rectAreaLength !== q || c.hemiLength !== p || c.numDirectionalShadows !== u || c.numPointShadows !== t || c.numSpotShadows !== ba) {
        b.directional.length = w, b.spot.length = n, b.rectArea.length = q, b.point.length = r, b.hemi.length = p, b.directionalShadow.length = u, b.directionalShadowMap.length = u, b.pointShadow.length = t, b.pointShadowMap.length = t, b.spotShadow.length = ba, b.spotShadowMap.length = ba, b.directionalShadowMatrix.length = u, b.pointShadowMatrix.length = t, b.spotShadowMatrix.length = ba, c.directionalLength = w, c.pointLength = r, c.spotLength = n, c.rectAreaLength = q, c.hemiLength = p, c.numDirectionalShadows = 
        u, c.numPointShadows = t, c.numSpotShadows = ba, b.version = Oj++;
      }
    }, state:b};
  }
  function Wh() {
    var l = new Nj, a = [], b = [];
    return {init:function() {
      a.length = 0;
      b.length = 0;
    }, state:{lightsArray:a, shadowsArray:b, lights:l}, setupLights:function(c) {
      l.setup(a, b, c);
    }, pushLight:function(l) {
      a.push(l);
    }, pushShadow:function(l) {
      b.push(l);
    }};
  }
  function Pj() {
    function l(b) {
      b = b.target;
      b.removeEventListener("dispose", l);
      a.delete(b);
    }
    var a = new WeakMap;
    return {get:function(b, c) {
      if (!1 === a.has(b)) {
        var w = new Wh;
        a.set(b, new WeakMap);
        a.get(b).set(c, w);
        b.addEventListener("dispose", l);
      } else {
        !1 === a.get(b).has(c) ? (w = new Wh, a.get(b).set(c, w)) : w = a.get(b).get(c);
      }
      return w;
    }, dispose:function() {
      a = new WeakMap;
    }};
  }
  function lc(l) {
    H.call(this);
    this.type = "MeshDepthMaterial";
    this.depthPacking = 3200;
    this.morphTargets = this.skinning = !1;
    this.displacementMap = this.alphaMap = this.map = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.fog = !1;
    this.setValues(l);
  }
  function mc(l) {
    H.call(this);
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new f;
    this.nearDistance = 1;
    this.farDistance = 1E3;
    this.morphTargets = this.skinning = !1;
    this.displacementMap = this.alphaMap = this.map = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = !1;
    this.setValues(l);
  }
  function Xh(l, a, b) {
    function w(l, a, b) {
      b = l << 0 | a << 1 | b << 2;
      var c = n[b];
      void 0 === c && (c = new lc({depthPacking:3201, morphTargets:l, skinning:a}), n[b] = c);
      return c;
    }
    function e(l, a, b) {
      b = l << 0 | a << 1 | b << 2;
      var c = q[b];
      void 0 === c && (c = new mc({morphTargets:l, skinning:a}), q[b] = c);
      return c;
    }
    function d(a, b, c, d, m, f, k) {
      var h = w, g = a.customDepthMaterial;
      !0 === d.isPointLight && (h = e, g = a.customDistanceMaterial);
      void 0 === g ? (g = !1, !0 === c.morphTargets && (g = b.morphAttributes && b.morphAttributes.position && 0 < b.morphAttributes.position.length), b = !1, !0 === a.isSkinnedMesh && (!0 === c.skinning ? b = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", a)), a = h(g, b, !0 === a.isInstancedMesh)) : a = g;
      l.localClippingEnabled && !0 === c.clipShadows && 0 !== c.clippingPlanes.length && (g = a.uuid, h = c.uuid, b = p[g], void 0 === b && (b = {}, p[g] = b), g = b[h], void 0 === g && (g = a.clone(), b[h] = g), a = g);
      a.visible = c.visible;
      a.wireframe = c.wireframe;
      a.side = 3 === k ? null !== c.shadowSide ? c.shadowSide : c.side : null !== c.shadowSide ? c.shadowSide : u[c.side];
      a.clipShadows = c.clipShadows;
      a.clippingPlanes = c.clippingPlanes;
      a.clipIntersection = c.clipIntersection;
      a.wireframeLinewidth = c.wireframeLinewidth;
      a.linewidth = c.linewidth;
      !0 === d.isPointLight && !0 === a.isMeshDistanceMaterial && (a.referencePosition.setFromMatrixPosition(d.matrixWorld), a.nearDistance = m, a.farDistance = f);
      return a;
    }
    function m(b, c, w, e, k) {
      if (!1 !== b.visible) {
        if (b.layers.test(c.layers) && (b.isMesh || b.isLine || b.isPoints) && (b.castShadow || b.receiveShadow && 3 === k) && (!b.frustumCulled || f.intersectsObject(b))) {
          b.modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, b.matrixWorld);
          var h = a.update(b), g = b.material;
          if (Array.isArray(g)) {
            for (var r = h.groups, G = 0, n = r.length; G < n; G++) {
              var q = r[G], p = g[q.materialIndex];
              p && p.visible && (p = d(b, h, p, e, w.near, w.far, k), l.renderBufferDirect(w, null, h, p, b, q));
            }
          } else {
            g.visible && (p = d(b, h, g, e, w.near, w.far, k), l.renderBufferDirect(w, null, h, p, b, null));
          }
        }
        b = b.children;
        h = 0;
        for (g = b.length; h < g; h++) {
          m(b[h], c, w, e, k);
        }
      }
    }
    var f = new Ga, h = new g, r = new g, G = new k, n = [], q = [], p = {}, u = {0:1, 1:0, 2:2}, t = new T({defines:{SAMPLE_RATE:.25, HALF_SAMPLE_RATE:.125}, uniforms:{shadow_pass:{value:null}, resolution:{value:new g}, radius:{value:4}}, vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}), 
    y = t.clone();
    y.defines.HORIZONAL_PASS = 1;
    var v = new M;
    v.setAttribute("position", new K(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
    var x = new V(v, t), U = this;
    this.enabled = !1;
    this.autoUpdate = !0;
    this.needsUpdate = !1;
    this.type = 1;
    this.render = function(w, e, d) {
      if (!1 !== U.enabled && (!1 !== U.autoUpdate || !1 !== U.needsUpdate) && 0 !== w.length) {
        var k = l.getRenderTarget(), g = l.getActiveCubeFace(), n = l.getActiveMipmapLevel(), q = l.state;
        q.setBlending(0);
        q.buffers.color.setClear(1, 1, 1, 1);
        q.buffers.depth.setTest(!0);
        q.setScissorTest(!1);
        for (var p = 0, u = w.length; p < u; p++) {
          var ba = w[p], v = ba.shadow;
          if (void 0 === v) {
            console.warn("THREE.WebGLShadowMap:", ba, "has no shadow.");
          } else {
            h.copy(v.mapSize);
            var da = v.getFrameExtents();
            h.multiply(da);
            r.copy(v.mapSize);
            if (h.x > b || h.y > b) {
              h.x > b && (r.x = Math.floor(b / da.x), h.x = r.x * da.x, v.mapSize.x = r.x), h.y > b && (r.y = Math.floor(b / da.y), h.y = r.y * da.y, v.mapSize.y = r.y);
            }
            null !== v.map || v.isPointLightShadow || 3 !== this.type || (da = {minFilter:1006, magFilter:1006, format:1023}, v.map = new c(h.x, h.y, da), v.map.texture.name = ba.name + ".shadowMap", v.mapPass = new c(h.x, h.y, da), v.camera.updateProjectionMatrix());
            null === v.map && (da = {minFilter:1003, magFilter:1003, format:1023}, v.map = new c(h.x, h.y, da), v.map.texture.name = ba.name + ".shadowMap", v.camera.updateProjectionMatrix());
            l.setRenderTarget(v.map);
            l.clear();
            da = v.getViewportCount();
            for (var z = 0; z < da; z++) {
              var ia = v.getViewport(z);
              G.set(r.x * ia.x, r.y * ia.y, r.x * ia.z, r.y * ia.w);
              q.viewport(G);
              v.updateMatrices(ba, z);
              f = v.getFrustum();
              m(e, d, v.camera, ba, this.type);
            }
            v.isPointLightShadow || 3 !== this.type || (ba = v, v = d, da = a.update(x), t.uniforms.shadow_pass.value = ba.map.texture, t.uniforms.resolution.value = ba.mapSize, t.uniforms.radius.value = ba.radius, l.setRenderTarget(ba.mapPass), l.clear(), l.renderBufferDirect(v, null, da, t, x, null), y.uniforms.shadow_pass.value = ba.mapPass.texture, y.uniforms.resolution.value = ba.mapSize, y.uniforms.radius.value = ba.radius, l.setRenderTarget(ba.map), l.clear(), l.renderBufferDirect(v, null, 
            da, y, x, null));
          }
        }
        U.needsUpdate = !1;
        l.setRenderTarget(k, g, n);
      }
    };
  }
  function Qj(l, a, b) {
    function c(a, b, c) {
      var w = new Uint8Array(4), e = l.createTexture();
      l.bindTexture(a, e);
      l.texParameteri(a, 10241, 9728);
      l.texParameteri(a, 10240, 9728);
      for (a = 0; a < c; a++) {
        l.texImage2D(b + a, 0, 6408, 1, 1, 0, 6408, 5121, w);
      }
      return e;
    }
    function w(b, c) {
      t[b] = 1;
      0 === u[b] && (l.enableVertexAttribArray(b), u[b] = 1);
      y[b] !== c && ((G ? l : a.get("ANGLE_instanced_arrays"))[G ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](b, c), y[b] = c);
    }
    function e(a) {
      !0 !== v[a] && (l.enable(a), v[a] = !0);
    }
    function d(a) {
      !1 !== v[a] && (l.disable(a), v[a] = !1);
    }
    function m(a, b, c, w, m, f, k, h) {
      if (0 === a) {
        U && (d(3042), U = !1);
      } else {
        if (U || (e(3042), U = !0), 5 !== a) {
          if (a !== z || h !== ra) {
            if (100 !== C || 100 !== D) {
              l.blendEquation(32774), D = C = 100;
            }
            if (h) {
              switch(a) {
                case 1:
                  l.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case 2:
                  l.blendFunc(1, 1);
                  break;
                case 3:
                  l.blendFuncSeparate(0, 0, 769, 771);
                  break;
                case 4:
                  l.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", a);
              }
            } else {
              switch(a) {
                case 1:
                  l.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case 2:
                  l.blendFunc(770, 1);
                  break;
                case 3:
                  l.blendFunc(0, 769);
                  break;
                case 4:
                  l.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", a);
              }
            }
            F = B = qa = A = null;
            z = a;
            ra = h;
          }
        } else {
          m = m || b;
          f = f || c;
          k = k || w;
          if (b !== C || m !== D) {
            l.blendEquationSeparate(R[b], R[m]), C = b, D = m;
          }
          if (c !== A || w !== qa || f !== B || k !== F) {
            l.blendFuncSeparate(S[c], S[w], S[f], S[k]), A = c, qa = w, B = f, F = k;
          }
          z = a;
          ra = null;
        }
      }
    }
    function f(a) {
      Ca !== a && (a ? l.frontFace(2304) : l.frontFace(2305), Ca = a);
    }
    function h(a) {
      0 !== a ? (e(2884), a !== E && (1 === a ? l.cullFace(1029) : 2 === a ? l.cullFace(1028) : l.cullFace(1032))) : d(2884);
      E = a;
    }
    function g(a, b, c) {
      if (a) {
        if (e(32823), J !== b || N !== c) {
          l.polygonOffset(b, c), J = b, N = c;
        }
      } else {
        d(32823);
      }
    }
    function r(a) {
      void 0 === a && (a = 33984 + I - 1);
      Q !== a && (l.activeTexture(a), Q = a);
    }
    var G = b.isWebGL2, n = new function() {
      var a = !1, b = new k, c = null, w = new k(0, 0, 0, 0);
      return {setMask:function(b) {
        c === b || a || (l.colorMask(b, b, b, b), c = b);
      }, setLocked:function(l) {
        a = l;
      }, setClear:function(a, c, e, d, m) {
        !0 === m && (a *= d, c *= d, e *= d);
        b.set(a, c, e, d);
        !1 === w.equals(b) && (l.clearColor(a, c, e, d), w.copy(b));
      }, reset:function() {
        a = !1;
        c = null;
        w.set(-1, 0, 0, 0);
      }};
    }, q = new function() {
      var a = !1, b = null, c = null, w = null;
      return {setTest:function(l) {
        l ? e(2929) : d(2929);
      }, setMask:function(c) {
        b === c || a || (l.depthMask(c), b = c);
      }, setFunc:function(a) {
        if (c !== a) {
          if (a) {
            switch(a) {
              case 0:
                l.depthFunc(512);
                break;
              case 1:
                l.depthFunc(519);
                break;
              case 2:
                l.depthFunc(513);
                break;
              case 3:
                l.depthFunc(515);
                break;
              case 4:
                l.depthFunc(514);
                break;
              case 5:
                l.depthFunc(518);
                break;
              case 6:
                l.depthFunc(516);
                break;
              case 7:
                l.depthFunc(517);
                break;
              default:
                l.depthFunc(515);
            }
          } else {
            l.depthFunc(515);
          }
          c = a;
        }
      }, setLocked:function(l) {
        a = l;
      }, setClear:function(a) {
        w !== a && (l.clearDepth(a), w = a);
      }, reset:function() {
        a = !1;
        w = c = b = null;
      }};
    }, p = new function() {
      var a = !1, b = null, c = null, w = null, m = null, f = null, k = null, h = null, g = null;
      return {setTest:function(l) {
        a || (l ? e(2960) : d(2960));
      }, setMask:function(c) {
        b === c || a || (l.stencilMask(c), b = c);
      }, setFunc:function(a, b, e) {
        if (c !== a || w !== b || m !== e) {
          l.stencilFunc(a, b, e), c = a, w = b, m = e;
        }
      }, setOp:function(a, b, c) {
        if (f !== a || k !== b || h !== c) {
          l.stencilOp(a, b, c), f = a, k = b, h = c;
        }
      }, setLocked:function(l) {
        a = l;
      }, setClear:function(a) {
        g !== a && (l.clearStencil(a), g = a);
      }, reset:function() {
        a = !1;
        g = h = k = f = m = w = c = b = null;
      }};
    };
    b = l.getParameter(34921);
    var t = new Uint8Array(b), u = new Uint8Array(b), y = new Uint8Array(b), v = {}, x = null, U = null, z = null, C = null, A = null, qa = null, D = null, B = null, F = null, ra = !1, Ca = null, E = null, H = null, J = null, N = null, I = l.getParameter(35661), O = !1;
    b = 0;
    b = l.getParameter(7938);
    -1 !== b.indexOf("WebGL") ? (b = parseFloat(/^WebGL ([0-9])/.exec(b)[1]), O = 1 <= b) : -1 !== b.indexOf("OpenGL ES") && (b = parseFloat(/^OpenGL ES ([0-9])/.exec(b)[1]), O = 2 <= b);
    var Q = null, K = {}, L = new k, M = new k, ca = {};
    ca[3553] = c(3553, 3553, 1);
    ca[34067] = c(34067, 34069, 6);
    n.setClear(0, 0, 0, 1);
    q.setClear(1);
    p.setClear(0);
    e(2929);
    q.setFunc(3);
    f(!1);
    h(1);
    e(2884);
    m(0);
    var R = {100:32774, 101:32778, 102:32779};
    G ? (R[103] = 32775, R[104] = 32776) : (b = a.get("EXT_blend_minmax"), null !== b && (R[103] = b.MIN_EXT, R[104] = b.MAX_EXT));
    var S = {200:0, 201:1, 202:768, 204:770, 210:776, 208:774, 206:772, 203:769, 205:771, 209:775, 207:773};
    return {buffers:{color:n, depth:q, stencil:p}, initAttributes:function() {
      for (var l = 0, a = t.length; l < a; l++) {
        t[l] = 0;
      }
    }, enableAttribute:function(l) {
      w(l, 0);
    }, enableAttributeAndDivisor:w, disableUnusedAttributes:function() {
      for (var a = 0, b = u.length; a !== b; ++a) {
        u[a] !== t[a] && (l.disableVertexAttribArray(a), u[a] = 0);
      }
    }, vertexAttribPointer:function(a, b, c, w, e, d) {
      !0 !== G || 5124 !== c && 5125 !== c ? l.vertexAttribPointer(a, b, c, w, e, d) : l.vertexAttribIPointer(a, b, c, w, e, d);
    }, enable:e, disable:d, useProgram:function(a) {
      return x !== a ? (l.useProgram(a), x = a, !0) : !1;
    }, setBlending:m, setMaterial:function(l, a) {
      2 === l.side ? d(2884) : e(2884);
      var b = 1 === l.side;
      a && (b = !b);
      f(b);
      1 === l.blending && !1 === l.transparent ? m(0) : m(l.blending, l.blendEquation, l.blendSrc, l.blendDst, l.blendEquationAlpha, l.blendSrcAlpha, l.blendDstAlpha, l.premultipliedAlpha);
      q.setFunc(l.depthFunc);
      q.setTest(l.depthTest);
      q.setMask(l.depthWrite);
      n.setMask(l.colorWrite);
      a = l.stencilWrite;
      p.setTest(a);
      a && (p.setMask(l.stencilWriteMask), p.setFunc(l.stencilFunc, l.stencilRef, l.stencilFuncMask), p.setOp(l.stencilFail, l.stencilZFail, l.stencilZPass));
      g(l.polygonOffset, l.polygonOffsetFactor, l.polygonOffsetUnits);
    }, setFlipSided:f, setCullFace:h, setLineWidth:function(a) {
      a !== H && (O && l.lineWidth(a), H = a);
    }, setPolygonOffset:g, setScissorTest:function(l) {
      l ? e(3089) : d(3089);
    }, activeTexture:r, bindTexture:function(a, b) {
      null === Q && r();
      var c = K[Q];
      void 0 === c && (c = {type:void 0, texture:void 0}, K[Q] = c);
      if (c.type !== a || c.texture !== b) {
        l.bindTexture(a, b || ca[a]), c.type = a, c.texture = b;
      }
    }, unbindTexture:function() {
      var a = K[Q];
      void 0 !== a && void 0 !== a.type && (l.bindTexture(a.type, null), a.type = void 0, a.texture = void 0);
    }, compressedTexImage2D:function() {
      try {
        l.compressedTexImage2D.apply(l, arguments);
      } catch (be) {
        console.error("THREE.WebGLState:", be);
      }
    }, texImage2D:function() {
      try {
        l.texImage2D.apply(l, arguments);
      } catch (be) {
        console.error("THREE.WebGLState:", be);
      }
    }, texImage3D:function() {
      try {
        l.texImage3D.apply(l, arguments);
      } catch (be) {
        console.error("THREE.WebGLState:", be);
      }
    }, scissor:function(a) {
      !1 === L.equals(a) && (l.scissor(a.x, a.y, a.z, a.w), L.copy(a));
    }, viewport:function(a) {
      !1 === M.equals(a) && (l.viewport(a.x, a.y, a.z, a.w), M.copy(a));
    }, reset:function() {
      for (var a = 0; a < u.length; a++) {
        1 === u[a] && (l.disableVertexAttribArray(a), u[a] = 0);
      }
      v = {};
      Q = null;
      K = {};
      E = Ca = z = x = null;
      n.reset();
      q.reset();
      p.reset();
    }};
  }
  function Rj(l, a, b, c, e, d, m) {
    function w(l, a) {
      return B ? new OffscreenCanvas(l, a) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    }
    function f(l, a, b, c) {
      var e = 1;
      if (l.width > c || l.height > c) {
        e = c / Math.max(l.width, l.height);
      }
      if (1 > e || !0 === a) {
        if ("undefined" !== typeof HTMLImageElement && l instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && l instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && l instanceof ImageBitmap) {
          return c = a ? na.floorPowerOfTwo : Math.floor, a = c(e * l.width), e = c(e * l.height), void 0 === Na && (Na = w(a, e)), b = b ? w(a, e) : Na, b.width = a, b.height = e, b.getContext("2d").drawImage(l, 0, 0, a, e), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + l.width + "x" + l.height + ") to (" + a + "x" + e + ")."), b;
        }
        "data" in l && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + l.width + "x" + l.height + ").");
      }
      return l;
    }
    function k(l) {
      return na.isPowerOfTwo(l.width) && na.isPowerOfTwo(l.height);
    }
    function h(l, a) {
      return l.generateMipmaps && a && 1003 !== l.minFilter && 1006 !== l.minFilter;
    }
    function g(a, b, w, e) {
      l.generateMipmap(a);
      c.get(b).__maxMipLevel = Math.log(Math.max(w, e)) * Math.LOG2E;
    }
    function r(b, c, w) {
      if (!1 === z) {
        return c;
      }
      if (null !== b) {
        if (void 0 !== l[b]) {
          return l[b];
        }
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + b + "'");
      }
      b = c;
      6403 === c && (5126 === w && (b = 33326), 5131 === w && (b = 33325), 5121 === w && (b = 33321));
      6407 === c && (5126 === w && (b = 34837), 5131 === w && (b = 34843), 5121 === w && (b = 32849));
      6408 === c && (5126 === w && (b = 34836), 5131 === w && (b = 34842), 5121 === w && (b = 32856));
      33325 !== b && 33326 !== b && 34842 !== b && 34836 !== b || a.get("EXT_color_buffer_float");
      return b;
    }
    function n(l) {
      return 1003 === l || 1004 === l || 1005 === l ? 9728 : 9729;
    }
    function G(a) {
      a = a.target;
      a.removeEventListener("dispose", G);
      var b = c.get(a);
      void 0 !== b.__webglInit && (l.deleteTexture(b.__webglTexture), c.remove(a));
      a.isVideoTexture && D.delete(a);
      m.memory.textures--;
    }
    function q(a) {
      a = a.target;
      a.removeEventListener("dispose", q);
      var b = c.get(a), w = c.get(a.texture);
      if (a) {
        void 0 !== w.__webglTexture && l.deleteTexture(w.__webglTexture);
        a.depthTexture && a.depthTexture.dispose();
        if (a.isWebGLCubeRenderTarget) {
          for (w = 0; 6 > w; w++) {
            l.deleteFramebuffer(b.__webglFramebuffer[w]), b.__webglDepthbuffer && l.deleteRenderbuffer(b.__webglDepthbuffer[w]);
          }
        } else {
          l.deleteFramebuffer(b.__webglFramebuffer), b.__webglDepthbuffer && l.deleteRenderbuffer(b.__webglDepthbuffer), b.__webglMultisampledFramebuffer && l.deleteFramebuffer(b.__webglMultisampledFramebuffer), b.__webglColorRenderbuffer && l.deleteRenderbuffer(b.__webglColorRenderbuffer), b.__webglDepthRenderbuffer && l.deleteRenderbuffer(b.__webglDepthRenderbuffer);
        }
        c.remove(a.texture);
        c.remove(a);
      }
      m.memory.textures--;
    }
    function p(l, a) {
      var w = c.get(l);
      if (l.isVideoTexture) {
        var e = m.render.frame;
        D.get(l) !== e && (D.set(l, e), l.update());
      }
      if (0 < l.version && w.__version !== l.version) {
        if (e = l.image, void 0 === e) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
        } else {
          if (!1 === e.complete) {
            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
          } else {
            v(w, l, a);
            return;
          }
        }
      }
      b.activeTexture(33984 + a);
      b.bindTexture(3553, w.__webglTexture);
    }
    function u(a, w) {
      if (6 === a.image.length) {
        var e = c.get(a);
        if (0 < a.version && e.__version !== a.version) {
          y(e, a);
          b.activeTexture(33984 + w);
          b.bindTexture(34067, e.__webglTexture);
          l.pixelStorei(37440, a.flipY);
          var m = a && (a.isCompressedTexture || a.image[0].isCompressedTexture);
          w = a.image[0] && a.image[0].isDataTexture;
          for (var n = [], G = 0; 6 > G; G++) {
            n[G] = m || w ? w ? a.image[G].image : a.image[G] : f(a.image[G], !1, !0, C);
          }
          var q = n[0], p = k(q) || z, u = d.convert(a.format), t = d.convert(a.type), v = r(a.internalFormat, u, t);
          ba(34067, a, p);
          if (m) {
            for (G = 0; 6 > G; G++) {
              var x = n[G].mipmaps;
              for (m = 0; m < x.length; m++) {
                var da = x[m];
                1023 !== a.format && 1022 !== a.format ? null !== u ? b.compressedTexImage2D(34069 + G, m, v, da.width, da.height, 0, da.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : b.texImage2D(34069 + G, m, v, da.width, da.height, 0, u, t, da.data);
              }
            }
            e.__maxMipLevel = x.length - 1;
          } else {
            x = a.mipmaps;
            for (G = 0; 6 > G; G++) {
              if (w) {
                for (b.texImage2D(34069 + G, 0, v, n[G].width, n[G].height, 0, u, t, n[G].data), m = 0; m < x.length; m++) {
                  da = x[m], da = da.image[G].image, b.texImage2D(34069 + G, m + 1, v, da.width, da.height, 0, u, t, da.data);
                }
              } else {
                for (b.texImage2D(34069 + G, 0, v, u, t, n[G]), m = 0; m < x.length; m++) {
                  da = x[m], b.texImage2D(34069 + G, m + 1, v, u, t, da.image[G]);
                }
              }
            }
            e.__maxMipLevel = x.length;
          }
          h(a, p) && g(34067, a, q.width, q.height);
          e.__version = a.version;
          if (a.onUpdate) {
            a.onUpdate(a);
          }
        } else {
          b.activeTexture(33984 + w), b.bindTexture(34067, e.__webglTexture);
        }
      }
    }
    function t(l, a) {
      b.activeTexture(33984 + a);
      b.bindTexture(34067, c.get(l).__webglTexture);
    }
    function ba(b, w, d) {
      d ? (l.texParameteri(b, 10242, ra[w.wrapS]), l.texParameteri(b, 10243, ra[w.wrapT]), 32879 !== b && 35866 !== b || l.texParameteri(b, 32882, ra[w.wrapR]), l.texParameteri(b, 10240, Ca[w.magFilter]), l.texParameteri(b, 10241, Ca[w.minFilter])) : (l.texParameteri(b, 10242, 33071), l.texParameteri(b, 10243, 33071), 32879 !== b && 35866 !== b || l.texParameteri(b, 32882, 33071), 1001 === w.wrapS && 1001 === w.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), 
      l.texParameteri(b, 10240, n(w.magFilter)), l.texParameteri(b, 10241, n(w.minFilter)), 1003 !== w.minFilter && 1006 !== w.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
      !(d = a.get("EXT_texture_filter_anisotropic")) || 1015 === w.type && null === a.get("OES_texture_float_linear") || 1016 === w.type && null === (z || a.get("OES_texture_half_float_linear")) || !(1 < w.anisotropy || c.get(w).__currentAnisotropy) || (l.texParameterf(b, d.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(w.anisotropy, e.getMaxAnisotropy())), c.get(w).__currentAnisotropy = w.anisotropy);
    }
    function y(a, b) {
      void 0 === a.__webglInit && (a.__webglInit = !0, b.addEventListener("dispose", G), a.__webglTexture = l.createTexture(), m.memory.textures++);
    }
    function v(a, c, w) {
      var e = 3553;
      c.isDataTexture2DArray && (e = 35866);
      c.isDataTexture3D && (e = 32879);
      y(a, c);
      b.activeTexture(33984 + w);
      b.bindTexture(e, a.__webglTexture);
      l.pixelStorei(37440, c.flipY);
      l.pixelStorei(37441, c.premultiplyAlpha);
      l.pixelStorei(3317, c.unpackAlignment);
      w = z ? !1 : 1001 !== c.wrapS || 1001 !== c.wrapT || 1003 !== c.minFilter && 1006 !== c.minFilter;
      w = w && !1 === k(c.image);
      w = f(c.image, w, !1, A);
      var m = k(w) || z, G = d.convert(c.format), n = d.convert(c.type), q = r(c.internalFormat, G, n);
      ba(e, c, m);
      var p = c.mipmaps;
      if (c.isDepthTexture) {
        q = 6402, z ? q = 1015 === c.type ? 36012 : 1014 === c.type ? 33190 : 1020 === c.type ? 35056 : 33189 : 1015 === c.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === c.format && 6402 === q && 1012 !== c.type && 1014 !== c.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), c.type = 1012, n = d.convert(c.type)), 1027 === c.format && 6402 === q && (q = 34041, 1020 !== c.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), 
        c.type = 1020, n = d.convert(c.type))), b.texImage2D(3553, 0, q, w.width, w.height, 0, G, n, null);
      } else {
        if (c.isDataTexture) {
          if (0 < p.length && m) {
            for (var u = 0, t = p.length; u < t; u++) {
              var v = p[u];
              b.texImage2D(3553, u, q, v.width, v.height, 0, G, n, v.data);
            }
            c.generateMipmaps = !1;
            a.__maxMipLevel = p.length - 1;
          } else {
            b.texImage2D(3553, 0, q, w.width, w.height, 0, G, n, w.data), a.__maxMipLevel = 0;
          }
        } else {
          if (c.isCompressedTexture) {
            u = 0;
            for (t = p.length; u < t; u++) {
              v = p[u], 1023 !== c.format && 1022 !== c.format ? null !== G ? b.compressedTexImage2D(3553, u, q, v.width, v.height, 0, v.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : b.texImage2D(3553, u, q, v.width, v.height, 0, G, n, v.data);
            }
            a.__maxMipLevel = p.length - 1;
          } else {
            if (c.isDataTexture2DArray) {
              b.texImage3D(35866, 0, q, w.width, w.height, w.depth, 0, G, n, w.data), a.__maxMipLevel = 0;
            } else {
              if (c.isDataTexture3D) {
                b.texImage3D(32879, 0, q, w.width, w.height, w.depth, 0, G, n, w.data), a.__maxMipLevel = 0;
              } else {
                if (0 < p.length && m) {
                  u = 0;
                  for (t = p.length; u < t; u++) {
                    v = p[u], b.texImage2D(3553, u, q, G, n, v);
                  }
                  c.generateMipmaps = !1;
                  a.__maxMipLevel = p.length - 1;
                } else {
                  b.texImage2D(3553, 0, q, G, n, w), a.__maxMipLevel = 0;
                }
              }
            }
          }
        }
      }
      h(c, m) && g(e, c, w.width, w.height);
      a.__version = c.version;
      if (c.onUpdate) {
        c.onUpdate(c);
      }
    }
    function x(a, w, e, m) {
      var f = d.convert(w.texture.format), k = d.convert(w.texture.type), h = r(w.texture.internalFormat, f, k);
      b.texImage2D(m, 0, h, w.width, w.height, 0, f, k, null);
      l.bindFramebuffer(36160, a);
      l.framebufferTexture2D(36160, e, m, c.get(w.texture).__webglTexture, 0);
      l.bindFramebuffer(36160, null);
    }
    function da(a, b, c) {
      l.bindRenderbuffer(36161, a);
      if (b.depthBuffer && !b.stencilBuffer) {
        var w = 33189;
        c ? ((c = b.depthTexture) && c.isDepthTexture && (1015 === c.type ? w = 36012 : 1014 === c.type && (w = 33190)), c = U(b), l.renderbufferStorageMultisample(36161, c, w, b.width, b.height)) : l.renderbufferStorage(36161, w, b.width, b.height);
        l.framebufferRenderbuffer(36160, 36096, 36161, a);
      } else {
        b.depthBuffer && b.stencilBuffer ? (c ? (c = U(b), l.renderbufferStorageMultisample(36161, c, 35056, b.width, b.height)) : l.renderbufferStorage(36161, 34041, b.width, b.height), l.framebufferRenderbuffer(36160, 33306, 36161, a)) : (a = d.convert(b.texture.format), w = d.convert(b.texture.type), w = r(b.texture.internalFormat, a, w), c ? (c = U(b), l.renderbufferStorageMultisample(36161, c, w, b.width, b.height)) : l.renderbufferStorage(36161, w, b.width, b.height));
      }
      l.bindRenderbuffer(36161, null);
    }
    function U(l) {
      return z && l.isWebGLMultisampleRenderTarget ? Math.min(qa, l.samples) : 0;
    }
    var z = e.isWebGL2, ia = e.maxTextures, C = e.maxCubemapSize, A = e.maxTextureSize, qa = e.maxSamples, D = new WeakMap, Na, B = !1;
    try {
      B = "undefined" !== typeof OffscreenCanvas && null !== (new OffscreenCanvas(1, 1)).getContext("2d");
    } catch (xk) {
    }
    var F = 0, ra = {1E3:10497, 1001:33071, 1002:33648}, Ca = {1003:9728, 1004:9984, 1005:9986, 1006:9729, 1007:9985, 1008:9987}, E = !1, H = !1;
    this.allocateTextureUnit = function() {
      var l = F;
      l >= ia && console.warn("THREE.WebGLTextures: Trying to use " + l + " texture units while this GPU supports only " + ia);
      F += 1;
      return l;
    };
    this.resetTextureUnits = function() {
      F = 0;
    };
    this.setTexture2D = p;
    this.setTexture2DArray = function(l, a) {
      var w = c.get(l);
      0 < l.version && w.__version !== l.version ? v(w, l, a) : (b.activeTexture(33984 + a), b.bindTexture(35866, w.__webglTexture));
    };
    this.setTexture3D = function(l, a) {
      var w = c.get(l);
      0 < l.version && w.__version !== l.version ? v(w, l, a) : (b.activeTexture(33984 + a), b.bindTexture(32879, w.__webglTexture));
    };
    this.setTextureCube = u;
    this.setTextureCubeDynamic = t;
    this.setupRenderTarget = function(a) {
      var w = c.get(a), e = c.get(a.texture);
      a.addEventListener("dispose", q);
      e.__webglTexture = l.createTexture();
      m.memory.textures++;
      var f = !0 === a.isWebGLCubeRenderTarget, G = !0 === a.isWebGLMultisampleRenderTarget, n = k(a) || z;
      !z || 1022 !== a.texture.format || 1015 !== a.texture.type && 1016 !== a.texture.type || (a.texture.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."));
      if (f) {
        for (w.__webglFramebuffer = [], G = 0; 6 > G; G++) {
          w.__webglFramebuffer[G] = l.createFramebuffer();
        }
      } else {
        if (w.__webglFramebuffer = l.createFramebuffer(), G) {
          if (z) {
            w.__webglMultisampledFramebuffer = l.createFramebuffer();
            w.__webglColorRenderbuffer = l.createRenderbuffer();
            l.bindRenderbuffer(36161, w.__webglColorRenderbuffer);
            G = d.convert(a.texture.format);
            var u = d.convert(a.texture.type);
            G = r(a.texture.internalFormat, G, u);
            u = U(a);
            l.renderbufferStorageMultisample(36161, u, G, a.width, a.height);
            l.bindFramebuffer(36160, w.__webglMultisampledFramebuffer);
            l.framebufferRenderbuffer(36160, 36064, 36161, w.__webglColorRenderbuffer);
            l.bindRenderbuffer(36161, null);
            a.depthBuffer && (w.__webglDepthRenderbuffer = l.createRenderbuffer(), da(w.__webglDepthRenderbuffer, a, !0));
            l.bindFramebuffer(36160, null);
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
          }
        }
      }
      if (f) {
        b.bindTexture(34067, e.__webglTexture);
        ba(34067, a.texture, n);
        for (G = 0; 6 > G; G++) {
          x(w.__webglFramebuffer[G], a, 36064, 34069 + G);
        }
        h(a.texture, n) && g(34067, a.texture, a.width, a.height);
        b.bindTexture(34067, null);
      } else {
        b.bindTexture(3553, e.__webglTexture), ba(3553, a.texture, n), x(w.__webglFramebuffer, a, 36064, 3553), h(a.texture, n) && g(3553, a.texture, a.width, a.height), b.bindTexture(3553, null);
      }
      if (a.depthBuffer) {
        w = c.get(a);
        e = !0 === a.isWebGLCubeRenderTarget;
        if (a.depthTexture) {
          if (e) {
            throw Error("target.depthTexture not supported in Cube render targets");
          }
          if (a && a.isWebGLCubeRenderTarget) {
            throw Error("Depth Texture with cube render targets is not supported");
          }
          l.bindFramebuffer(36160, w.__webglFramebuffer);
          if (!a.depthTexture || !a.depthTexture.isDepthTexture) {
            throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          }
          c.get(a.depthTexture).__webglTexture && a.depthTexture.image.width === a.width && a.depthTexture.image.height === a.height || (a.depthTexture.image.width = a.width, a.depthTexture.image.height = a.height, a.depthTexture.needsUpdate = !0);
          p(a.depthTexture, 0);
          w = c.get(a.depthTexture).__webglTexture;
          if (1026 === a.depthTexture.format) {
            l.framebufferTexture2D(36160, 36096, 3553, w, 0);
          } else {
            if (1027 === a.depthTexture.format) {
              l.framebufferTexture2D(36160, 33306, 3553, w, 0);
            } else {
              throw Error("Unknown depthTexture format");
            }
          }
        } else {
          if (e) {
            for (w.__webglDepthbuffer = [], e = 0; 6 > e; e++) {
              l.bindFramebuffer(36160, w.__webglFramebuffer[e]), w.__webglDepthbuffer[e] = l.createRenderbuffer(), da(w.__webglDepthbuffer[e], a, !1);
            }
          } else {
            l.bindFramebuffer(36160, w.__webglFramebuffer), w.__webglDepthbuffer = l.createRenderbuffer(), da(w.__webglDepthbuffer, a, !1);
          }
        }
        l.bindFramebuffer(36160, null);
      }
    };
    this.updateRenderTargetMipmap = function(l) {
      var a = l.texture, w = k(l) || z;
      if (h(a, w)) {
        w = l.isWebGLCubeRenderTarget ? 34067 : 3553;
        var e = c.get(a).__webglTexture;
        b.bindTexture(w, e);
        g(w, a, l.width, l.height);
        b.bindTexture(w, null);
      }
    };
    this.updateMultisampleRenderTarget = function(a) {
      if (a.isWebGLMultisampleRenderTarget) {
        if (z) {
          var b = c.get(a);
          l.bindFramebuffer(36008, b.__webglMultisampledFramebuffer);
          l.bindFramebuffer(36009, b.__webglFramebuffer);
          var w = a.width, e = a.height, d = 16384;
          a.depthBuffer && (d |= 256);
          a.stencilBuffer && (d |= 1024);
          l.blitFramebuffer(0, 0, w, e, 0, 0, w, e, d, 9728);
          l.bindFramebuffer(36160, b.__webglMultisampledFramebuffer);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    };
    this.safeSetTexture2D = function(l, a) {
      l && l.isWebGLRenderTarget && (!1 === E && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), E = !0), l = l.texture);
      p(l, a);
    };
    this.safeSetTextureCube = function(l, a) {
      l && l.isWebGLCubeRenderTarget && (!1 === H && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), H = !0), l = l.texture);
      l && l.isCubeTexture || Array.isArray(l.image) && 6 === l.image.length ? u(l, a) : t(l, a);
    };
  }
  function Yh(l, a, b) {
    var c = b.isWebGL2;
    return {convert:function(l) {
      if (1009 === l) {
        return 5121;
      }
      if (1017 === l) {
        return 32819;
      }
      if (1018 === l) {
        return 32820;
      }
      if (1019 === l) {
        return 33635;
      }
      if (1010 === l) {
        return 5120;
      }
      if (1011 === l) {
        return 5122;
      }
      if (1012 === l) {
        return 5123;
      }
      if (1013 === l) {
        return 5124;
      }
      if (1014 === l) {
        return 5125;
      }
      if (1015 === l) {
        return 5126;
      }
      if (1016 === l) {
        if (c) {
          return 5131;
        }
        var b = a.get("OES_texture_half_float");
        return null !== b ? b.HALF_FLOAT_OES : null;
      }
      if (1021 === l) {
        return 6406;
      }
      if (1022 === l) {
        return 6407;
      }
      if (1023 === l) {
        return 6408;
      }
      if (1024 === l) {
        return 6409;
      }
      if (1025 === l) {
        return 6410;
      }
      if (1026 === l) {
        return 6402;
      }
      if (1027 === l) {
        return 34041;
      }
      if (1028 === l) {
        return 6403;
      }
      if (1029 === l) {
        return 36244;
      }
      if (1030 === l) {
        return 33319;
      }
      if (1031 === l) {
        return 33320;
      }
      if (1032 === l) {
        return 36248;
      }
      if (1033 === l) {
        return 36249;
      }
      if (33776 === l || 33777 === l || 33778 === l || 33779 === l) {
        if (b = a.get("WEBGL_compressed_texture_s3tc"), null !== b) {
          if (33776 === l) {
            return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
          }
          if (33777 === l) {
            return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          }
          if (33778 === l) {
            return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          }
          if (33779 === l) {
            return b.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
        } else {
          return null;
        }
      }
      if (35840 === l || 35841 === l || 35842 === l || 35843 === l) {
        if (b = a.get("WEBGL_compressed_texture_pvrtc"), null !== b) {
          if (35840 === l) {
            return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          }
          if (35841 === l) {
            return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          }
          if (35842 === l) {
            return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          }
          if (35843 === l) {
            return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
        } else {
          return null;
        }
      }
      if (36196 === l) {
        return b = a.get("WEBGL_compressed_texture_etc1"), null !== b ? b.COMPRESSED_RGB_ETC1_WEBGL : null;
      }
      if (37492 === l || 37496 === l) {
        if (b = a.get("WEBGL_compressed_texture_etc"), null !== b) {
          if (37492 === l) {
            return b.COMPRESSED_RGB8_ETC2;
          }
          if (37496 === l) {
            return b.COMPRESSED_RGBA8_ETC2_EAC;
          }
        }
      }
      if (37808 === l || 37809 === l || 37810 === l || 37811 === l || 37812 === l || 37813 === l || 37814 === l || 37815 === l || 37816 === l || 37817 === l || 37818 === l || 37819 === l || 37820 === l || 37821 === l || 37840 === l || 37841 === l || 37842 === l || 37843 === l || 37844 === l || 37845 === l || 37846 === l || 37847 === l || 37848 === l || 37849 === l || 37850 === l || 37851 === l || 37852 === l || 37853 === l) {
        return b = a.get("WEBGL_compressed_texture_astc"), null !== b ? l : null;
      }
      if (36492 === l) {
        return b = a.get("EXT_texture_compression_bptc"), null !== b ? l : null;
      }
      if (1020 === l) {
        if (c) {
          return 34042;
        }
        b = a.get("WEBGL_depth_texture");
        return null !== b ? b.UNSIGNED_INT_24_8_WEBGL : null;
      }
    }};
  }
  function af(l) {
    ka.call(this);
    this.cameras = l || [];
  }
  function gd() {
    q.call(this);
    this.type = "Group";
  }
  function bf() {
    this._grip = this._targetRay = null;
  }
  function Zh(l, a) {
    function b(l) {
      var a = u.get(l.inputSource);
      a && a.dispatchEvent({type:l.type});
    }
    function c() {
      u.forEach(function(l, a) {
        l.disconnect(a);
      });
      u.clear();
      l.setFramebuffer(null);
      l.setRenderTarget(l.getRenderTarget());
      D.stop();
      m.isPresenting = !1;
      m.dispatchEvent({type:"sessionend"});
    }
    function w(l) {
      r = l;
      D.setContext(h);
      D.start();
      m.isPresenting = !0;
      m.dispatchEvent({type:"sessionstart"});
    }
    function e(l) {
      for (var a = h.inputSources, b = 0; b < p.length; b++) {
        u.set(a[b], p[b]);
      }
      for (b = 0; b < l.removed.length; b++) {
        a = l.removed[b];
        var c = u.get(a);
        c && (c.dispatchEvent({type:"disconnected", data:a}), u.delete(a));
      }
      for (b = 0; b < l.added.length; b++) {
        a = l.added[b], (c = u.get(a)) && c.dispatchEvent({type:"connected", data:a});
      }
    }
    function d(l, a) {
      null === a ? l.matrixWorld.copy(l.matrix) : l.matrixWorld.multiplyMatrices(a.matrixWorld, l.matrix);
      l.matrixWorldInverse.getInverse(l.matrixWorld);
    }
    var m = this, h = null, g = 1, r = null, n = "local-floor", q = null, p = [], u = new Map, t = new ka;
    t.layers.enable(1);
    t.viewport = new k;
    var y = new ka;
    y.layers.enable(2);
    y.viewport = new k;
    var v = [t, y], x = new af;
    x.layers.enable(1);
    x.layers.enable(2);
    var U = null, z = null;
    this.isPresenting = this.enabled = !1;
    this.getController = function(l) {
      var a = p[l];
      void 0 === a && (a = new bf, p[l] = a);
      return a.getTargetRaySpace();
    };
    this.getControllerGrip = function(l) {
      var a = p[l];
      void 0 === a && (a = new bf, p[l] = a);
      return a.getGripSpace();
    };
    this.setFramebufferScaleFactor = function(l) {
      g = l;
      !0 === m.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    };
    this.setReferenceSpaceType = function(l) {
      n = l;
      !0 === m.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    };
    this.getReferenceSpace = function() {
      return r;
    };
    this.getSession = function() {
      return h;
    };
    this.setSession = function(l) {
      h = l;
      null !== h && (h.addEventListener("select", b), h.addEventListener("selectstart", b), h.addEventListener("selectend", b), h.addEventListener("squeeze", b), h.addEventListener("squeezestart", b), h.addEventListener("squeezeend", b), h.addEventListener("end", c), l = a.getContextAttributes(), l = new XRWebGLLayer(h, a, {antialias:l.antialias, alpha:l.alpha, depth:l.depth, stencil:l.stencil, framebufferScaleFactor:g}), h.updateRenderState({baseLayer:l}), h.requestReferenceSpace(n).then(w), h.addEventListener("inputsourceschange", 
      e));
    };
    var C = new f, A = new f;
    this.getCamera = function(l) {
      x.near = y.near = t.near = l.near;
      x.far = y.far = t.far = l.far;
      if (U !== x.near || z !== x.far) {
        h.updateRenderState({depthNear:x.near, depthFar:x.far}), U = x.near, z = x.far;
      }
      var a = l.parent, b = x.cameras;
      d(x, a);
      for (var c = 0; c < b.length; c++) {
        d(b[c], a);
      }
      l.matrixWorld.copy(x.matrixWorld);
      l = l.children;
      c = 0;
      for (a = l.length; c < a; c++) {
        l[c].updateMatrixWorld(!0);
      }
      if (2 === b.length) {
        C.setFromMatrixPosition(t.matrixWorld);
        A.setFromMatrixPosition(y.matrixWorld);
        b = C.distanceTo(A);
        var w = t.projectionMatrix.elements, e = y.projectionMatrix.elements, m = w[14] / (w[10] - 1);
        c = w[14] / (w[10] + 1);
        l = (w[9] + 1) / w[5];
        a = (w[9] - 1) / w[5];
        var f = (w[8] - 1) / w[0], k = (e[8] + 1) / e[0];
        e = m * f;
        w = m * k;
        k = b / (-f + k);
        f = k * -f;
        t.matrixWorld.decompose(x.position, x.quaternion, x.scale);
        x.translateX(f);
        x.translateZ(k);
        x.matrixWorld.compose(x.position, x.quaternion, x.scale);
        x.matrixWorldInverse.getInverse(x.matrixWorld);
        m += k;
        k = c + k;
        x.projectionMatrix.makePerspective(e - f, w + (b - f), l * c / k * m, a * c / k * m, m, k);
      } else {
        x.projectionMatrix.copy(t.projectionMatrix);
      }
      return x;
    };
    var qa = null, D = new sa;
    D.setAnimationLoop(function(a, b) {
      q = b.getViewerPose(r);
      if (null !== q) {
        var c = q.views, w = h.renderState.baseLayer;
        l.setFramebuffer(w.framebuffer);
        var e = !1;
        c.length !== x.cameras.length && (x.cameras.length = 0, e = !0);
        for (var d = 0; d < c.length; d++) {
          var m = c[d], f = w.getViewport(m), k = v[d];
          k.matrix.fromArray(m.transform.matrix);
          k.projectionMatrix.fromArray(m.projectionMatrix);
          k.viewport.set(f.x, f.y, f.width, f.height);
          0 === d && x.matrix.copy(k.matrix);
          !0 === e && x.cameras.push(k);
        }
      }
      c = h.inputSources;
      for (d = 0; d < p.length; d++) {
        p[d].update(c[d], b, r);
      }
      qa && qa(a, b);
    });
    this.setAnimationLoop = function(l) {
      qa = l;
    };
    this.dispose = function() {
    };
  }
  function ug(l) {
    var a;
    function b() {
      ea = new nb(T);
      ka = new yc(T, ea, l);
      !1 === ka.isWebGL2 && (ea.get("WEBGL_depth_texture"), ea.get("OES_texture_float"), ea.get("OES_texture_half_float"), ea.get("OES_texture_half_float_linear"), ea.get("OES_standard_derivatives"), ea.get("OES_element_index_uint"), ea.get("ANGLE_instanced_arrays"));
      ea.get("OES_texture_float_linear");
      qb = new Yh(T, ea, ka);
      la = new Qj(T, ea, ka);
      la.scissor(Cc.copy(ic).multiplyScalar(V).floor());
      la.viewport(P.copy(hc).multiplyScalar(V).floor());
      jb = new Rb(T);
      Pa = new Gj;
      bb = new Rj(T, ea, la, Pa, ka, qb, jb);
      jc = new Qb(T, ka);
      Aa = new zc(T, jc, jb);
      ua = new Ac(T, Aa, jc, jb);
      ha = new gb(T);
      va = new Fj(J, ea, ka);
      fd = new Jj;
      xa = new Pj;
      Fb = new gc(J, la, ua, B);
      oa = new Xd(T, ea, jb, ka);
      $e = new Bb(T, ea, jb, ka);
      jb.programs = va.programs;
      J.capabilities = ka;
      J.extensions = ea;
      J.properties = Pa;
      J.renderLists = fd;
      J.state = la;
      J.info = jb;
    }
    function c(l) {
      l.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      N = !0;
    }
    function e() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      N = !1;
      b();
    }
    function d(l) {
      l = l.target;
      l.removeEventListener("dispose", d);
      m(l);
      Pa.remove(l);
    }
    function m(l) {
      var a = Pa.get(l).program;
      l.program = void 0;
      void 0 !== a && va.releaseProgram(a);
    }
    function h(l, a) {
      l.render(function(l) {
        J.renderBufferImmediate(l, a);
      });
    }
    function r(l, a, b, c) {
      if (!1 !== l.visible) {
        if (l.layers.test(a.layers)) {
          if (l.isGroup) {
            b = l.renderOrder;
          } else {
            if (l.isLOD) {
              !0 === l.autoUpdate && l.update(a);
            } else {
              if (l.isLight) {
                H.pushLight(l), l.castShadow && H.pushShadow(l);
              } else {
                if (l.isSprite) {
                  if (!l.frustumCulled || fa.intersectsSprite(l)) {
                    c && ma.setFromMatrixPosition(l.matrixWorld).applyMatrix4(Y);
                    var w = ua.update(l), e = l.material;
                    e.visible && E.push(l, w, e, b, ma.z, null);
                  }
                } else {
                  if (l.isImmediateRenderObject) {
                    c && ma.setFromMatrixPosition(l.matrixWorld).applyMatrix4(Y), E.push(l, null, l.material, b, ma.z, null);
                  } else {
                    if (l.isMesh || l.isLine || l.isPoints) {
                      if (l.isSkinnedMesh && l.skeleton.frame !== jb.render.frame && (l.skeleton.update(), l.skeleton.frame = jb.render.frame), !l.frustumCulled || fa.intersectsObject(l)) {
                        if (c && ma.setFromMatrixPosition(l.matrixWorld).applyMatrix4(Y), w = ua.update(l), e = l.material, Array.isArray(e)) {
                          for (var d = w.groups, m = 0, f = d.length; m < f; m++) {
                            var k = d[m], h = e[k.materialIndex];
                            h && h.visible && E.push(l, w, h, b, ma.z, k);
                          }
                        } else {
                          e.visible && E.push(l, w, e, b, ma.z, null);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        l = l.children;
        m = 0;
        for (f = l.length; m < f; m++) {
          r(l[m], a, b, c);
        }
      }
    }
    function q(l, a, b, c) {
      for (var w = 0, e = l.length; w < e; w++) {
        var d = l[w], m = d.object, f = d.geometry, k = void 0 === c ? d.material : c;
        d = d.group;
        if (b.isArrayCamera) {
          dd = b;
          for (var h = b.cameras, g = 0, r = h.length; g < r; g++) {
            var G = h[g];
            m.layers.test(G.layers) && (la.viewport(P.copy(G.viewport)), H.setupLights(G), p(m, a, G, f, k, d));
          }
        } else {
          dd = null, p(m, a, b, f, k, d);
        }
      }
    }
    function p(l, b, c, w, e, d) {
      l.onBeforeRender(J, b, c, w, e, d);
      H = xa.get(b, dd || c);
      l.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, l.matrixWorld);
      l.normalMatrix.getNormalMatrix(l.modelViewMatrix);
      if (l.isImmediateRenderObject) {
        var m = t(c, b, e, l);
        la.setMaterial(e);
        ca = a = null;
        R = !1;
        h(l, m);
      } else {
        J.renderBufferDirect(c, b, w, e, l, d);
      }
      l.onAfterRender(J, b, c, w, e, d);
      H = xa.get(b, dd || c);
    }
    function u(l, a, b) {
      var c = Pa.get(l), w = H.state.lights, e = w.state.version;
      b = va.getParameters(l, w.state, H.state.shadowsArray, a, ja.numPlanes, ja.numIntersection, b);
      var f = va.getProgramCacheKey(b), k = c.program, h = !0;
      if (void 0 === k) {
        l.addEventListener("dispose", d);
      } else {
        if (k.cacheKey !== f) {
          m(l);
        } else {
          if (c.lightsStateVersion !== e) {
            c.lightsStateVersion = e;
          } else {
            if (void 0 !== b.shaderID) {
              return;
            }
          }
          h = !1;
        }
      }
      h && (k = va.acquireProgram(b, f), c.program = k, c.uniforms = b.uniforms, c.outputEncoding = b.outputEncoding, l.program = k);
      b = k.getAttributes();
      if (l.morphTargets) {
        for (f = l.numSupportedMorphTargets = 0; f < J.maxMorphTargets; f++) {
          0 <= b["morphTarget" + f] && l.numSupportedMorphTargets++;
        }
      }
      if (l.morphNormals) {
        for (f = l.numSupportedMorphNormals = 0; f < J.maxMorphNormals; f++) {
          0 <= b["morphNormal" + f] && l.numSupportedMorphNormals++;
        }
      }
      b = c.uniforms;
      if (!l.isShaderMaterial && !l.isRawShaderMaterial || !0 === l.clipping) {
        c.numClippingPlanes = ja.numPlanes, c.numIntersection = ja.numIntersection, b.clippingPlanes = ja.uniform;
      }
      c.environment = l.isMeshStandardMaterial ? a.environment : null;
      c.fog = a.fog;
      c.needsLights = l.isMeshLambertMaterial || l.isMeshToonMaterial || l.isMeshPhongMaterial || l.isMeshStandardMaterial || l.isShadowMaterial || l.isShaderMaterial && !0 === l.lights;
      c.lightsStateVersion = e;
      c.needsLights && (b.ambientLightColor.value = w.state.ambient, b.lightProbe.value = w.state.probe, b.directionalLights.value = w.state.directional, b.directionalLightShadows.value = w.state.directionalShadow, b.spotLights.value = w.state.spot, b.spotLightShadows.value = w.state.spotShadow, b.rectAreaLights.value = w.state.rectArea, b.pointLights.value = w.state.point, b.pointLightShadows.value = w.state.pointShadow, b.hemisphereLights.value = w.state.hemi, b.directionalShadowMap.value = w.state.directionalShadowMap, 
      b.directionalShadowMatrix.value = w.state.directionalShadowMatrix, b.spotShadowMap.value = w.state.spotShadowMap, b.spotShadowMatrix.value = w.state.spotShadowMatrix, b.pointShadowMap.value = w.state.pointShadowMap, b.pointShadowMatrix.value = w.state.pointShadowMatrix);
      l = c.program.getUniforms();
      l = kc.seqWithValue(l.seq, b);
      c.uniformsList = l;
    }
    function t(l, a, b, c) {
      bb.resetTextureUnits();
      var w = a.fog, e = b.isMeshStandardMaterial ? a.environment : null, d = null === K ? J.outputEncoding : K.texture.encoding, m = Pa.get(b), f = H.state.lights;
      ed && (Zd || l !== S) && ja.setState(b.clippingPlanes, b.clipIntersection, b.clipShadows, l, m, l === S && b.id === M);
      b.version === m.__version ? void 0 === m.program ? u(b, a, c) : b.fog && m.fog !== w ? u(b, a, c) : m.environment !== e ? u(b, a, c) : m.needsLights && m.lightsStateVersion !== f.state.version ? u(b, a, c) : void 0 === m.numClippingPlanes || m.numClippingPlanes === ja.numPlanes && m.numIntersection === ja.numIntersection ? m.outputEncoding !== d && u(b, a, c) : u(b, a, c) : (u(b, a, c), m.__version = b.version);
      var k = !1, h = !1, g = !1;
      a = m.program;
      d = a.getUniforms();
      f = m.uniforms;
      la.useProgram(a.program) && (g = h = k = !0);
      b.id !== M && (M = b.id, h = !0);
      if (k || S !== l) {
        d.setValue(T, "projectionMatrix", l.projectionMatrix);
        ka.logarithmicDepthBuffer && d.setValue(T, "logDepthBufFC", 2 / (Math.log(l.far + 1) / Math.LN2));
        S !== l && (S = l, g = h = !0);
        if (b.isShaderMaterial || b.isMeshPhongMaterial || b.isMeshToonMaterial || b.isMeshStandardMaterial || b.envMap) {
          k = d.map.cameraPosition, void 0 !== k && k.setValue(T, ma.setFromMatrixPosition(l.matrixWorld));
        }
        (b.isMeshPhongMaterial || b.isMeshToonMaterial || b.isMeshLambertMaterial || b.isMeshBasicMaterial || b.isMeshStandardMaterial || b.isShaderMaterial) && d.setValue(T, "isOrthographic", !0 === l.isOrthographicCamera);
        (b.isMeshPhongMaterial || b.isMeshToonMaterial || b.isMeshLambertMaterial || b.isMeshBasicMaterial || b.isMeshStandardMaterial || b.isShaderMaterial || b.skinning) && d.setValue(T, "viewMatrix", l.matrixWorldInverse);
      }
      if (b.skinning && (d.setOptional(T, c, "bindMatrix"), d.setOptional(T, c, "bindMatrixInverse"), l = c.skeleton)) {
        if (k = l.bones, ka.floatVertexTextures) {
          if (void 0 === l.boneTexture) {
            k = Math.sqrt(4 * k.length);
            k = na.ceilPowerOfTwo(k);
            k = Math.max(k, 4);
            var r = new Float32Array(k * k * 4);
            r.set(l.boneMatrices);
            var G = new Ia(r, k, k, 1023, 1015);
            l.boneMatrices = r;
            l.boneTexture = G;
            l.boneTextureSize = k;
          }
          d.setValue(T, "boneTexture", l.boneTexture, bb);
          d.setValue(T, "boneTextureSize", l.boneTextureSize);
        } else {
          d.setOptional(T, l, "boneMatrices");
        }
      }
      if (h || m.receiveShadow !== c.receiveShadow) {
        m.receiveShadow = c.receiveShadow, d.setValue(T, "receiveShadow", c.receiveShadow);
      }
      if (h) {
        d.setValue(T, "toneMappingExposure", J.toneMappingExposure);
        d.setValue(T, "toneMappingWhitePoint", J.toneMappingWhitePoint);
        m.needsLights && (h = g, f.ambientLightColor.needsUpdate = h, f.lightProbe.needsUpdate = h, f.directionalLights.needsUpdate = h, f.directionalLightShadows.needsUpdate = h, f.pointLights.needsUpdate = h, f.pointLightShadows.needsUpdate = h, f.spotLights.needsUpdate = h, f.spotLightShadows.needsUpdate = h, f.rectAreaLights.needsUpdate = h, f.hemisphereLights.needsUpdate = h);
        w && b.fog && (f.fogColor.value.copy(w.color), w.isFog ? (f.fogNear.value = w.near, f.fogFar.value = w.far) : w.isFogExp2 && (f.fogDensity.value = w.density));
        if (b.isMeshBasicMaterial) {
          v(f, b);
        } else {
          if (b.isMeshLambertMaterial) {
            v(f, b), b.emissiveMap && (f.emissiveMap.value = b.emissiveMap);
          } else {
            if (b.isMeshToonMaterial) {
              v(f, b), f.specular.value.copy(b.specular), f.shininess.value = Math.max(b.shininess, 1E-4), b.gradientMap && (f.gradientMap.value = b.gradientMap), b.emissiveMap && (f.emissiveMap.value = b.emissiveMap), b.bumpMap && (f.bumpMap.value = b.bumpMap, f.bumpScale.value = b.bumpScale, 1 === b.side && (f.bumpScale.value *= -1)), b.normalMap && (f.normalMap.value = b.normalMap, f.normalScale.value.copy(b.normalScale), 1 === b.side && f.normalScale.value.negate()), b.displacementMap && (f.displacementMap.value = 
              b.displacementMap, f.displacementScale.value = b.displacementScale, f.displacementBias.value = b.displacementBias);
            } else {
              if (b.isMeshPhongMaterial) {
                v(f, b), f.specular.value.copy(b.specular), f.shininess.value = Math.max(b.shininess, 1E-4), b.emissiveMap && (f.emissiveMap.value = b.emissiveMap), b.bumpMap && (f.bumpMap.value = b.bumpMap, f.bumpScale.value = b.bumpScale, 1 === b.side && (f.bumpScale.value *= -1)), b.normalMap && (f.normalMap.value = b.normalMap, f.normalScale.value.copy(b.normalScale), 1 === b.side && f.normalScale.value.negate()), b.displacementMap && (f.displacementMap.value = b.displacementMap, f.displacementScale.value = 
                b.displacementScale, f.displacementBias.value = b.displacementBias);
              } else {
                if (b.isMeshStandardMaterial) {
                  v(f, b, e), b.isMeshPhysicalMaterial ? (x(f, b, e), f.reflectivity.value = b.reflectivity, f.clearcoat.value = b.clearcoat, f.clearcoatRoughness.value = b.clearcoatRoughness, b.sheen && f.sheen.value.copy(b.sheen), b.clearcoatMap && (f.clearcoatMap.value = b.clearcoatMap), b.clearcoatRoughnessMap && (f.clearcoatRoughnessMap.value = b.clearcoatRoughnessMap), b.clearcoatNormalMap && (f.clearcoatNormalScale.value.copy(b.clearcoatNormalScale), f.clearcoatNormalMap.value = b.clearcoatNormalMap, 
                  1 === b.side && f.clearcoatNormalScale.value.negate()), f.transparency.value = b.transparency) : x(f, b, e);
                } else {
                  if (b.isMeshMatcapMaterial) {
                    v(f, b), b.matcap && (f.matcap.value = b.matcap), b.bumpMap && (f.bumpMap.value = b.bumpMap, f.bumpScale.value = b.bumpScale, 1 === b.side && (f.bumpScale.value *= -1)), b.normalMap && (f.normalMap.value = b.normalMap, f.normalScale.value.copy(b.normalScale), 1 === b.side && f.normalScale.value.negate()), b.displacementMap && (f.displacementMap.value = b.displacementMap, f.displacementScale.value = b.displacementScale, f.displacementBias.value = b.displacementBias);
                  } else {
                    if (b.isMeshDepthMaterial) {
                      v(f, b), b.displacementMap && (f.displacementMap.value = b.displacementMap, f.displacementScale.value = b.displacementScale, f.displacementBias.value = b.displacementBias);
                    } else {
                      if (b.isMeshDistanceMaterial) {
                        v(f, b), b.displacementMap && (f.displacementMap.value = b.displacementMap, f.displacementScale.value = b.displacementScale, f.displacementBias.value = b.displacementBias), f.referencePosition.value.copy(b.referencePosition), f.nearDistance.value = b.nearDistance, f.farDistance.value = b.farDistance;
                      } else {
                        if (b.isMeshNormalMaterial) {
                          v(f, b), b.bumpMap && (f.bumpMap.value = b.bumpMap, f.bumpScale.value = b.bumpScale, 1 === b.side && (f.bumpScale.value *= -1)), b.normalMap && (f.normalMap.value = b.normalMap, f.normalScale.value.copy(b.normalScale), 1 === b.side && f.normalScale.value.negate()), b.displacementMap && (f.displacementMap.value = b.displacementMap, f.displacementScale.value = b.displacementScale, f.displacementBias.value = b.displacementBias);
                        } else {
                          if (b.isLineBasicMaterial) {
                            f.diffuse.value.copy(b.color), f.opacity.value = b.opacity, b.isLineDashedMaterial && (f.dashSize.value = b.dashSize, f.totalSize.value = b.dashSize + b.gapSize, f.scale.value = b.scale);
                          } else {
                            if (b.isPointsMaterial) {
                              f.diffuse.value.copy(b.color);
                              f.opacity.value = b.opacity;
                              f.size.value = b.size * V;
                              f.scale.value = .5 * Eb;
                              b.map && (f.map.value = b.map);
                              b.alphaMap && (f.alphaMap.value = b.alphaMap);
                              if (b.map) {
                                var n = b.map;
                              } else {
                                b.alphaMap && (n = b.alphaMap);
                              }
                              void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), f.uvTransform.value.copy(n.matrix));
                            } else {
                              if (b.isSpriteMaterial) {
                                f.diffuse.value.copy(b.color);
                                f.opacity.value = b.opacity;
                                f.rotation.value = b.rotation;
                                b.map && (f.map.value = b.map);
                                b.alphaMap && (f.alphaMap.value = b.alphaMap);
                                if (b.map) {
                                  var q = b.map;
                                } else {
                                  b.alphaMap && (q = b.alphaMap);
                                }
                                void 0 !== q && (!0 === q.matrixAutoUpdate && q.updateMatrix(), f.uvTransform.value.copy(q.matrix));
                              } else {
                                b.isShadowMaterial && (f.color.value.copy(b.color), f.opacity.value = b.opacity);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        void 0 !== f.ltc_1 && (f.ltc_1.value = aa.LTC_1);
        void 0 !== f.ltc_2 && (f.ltc_2.value = aa.LTC_2);
        kc.upload(T, m.uniformsList, f, bb);
        b.isShaderMaterial && (b.uniformsNeedUpdate = !1);
      }
      b.isShaderMaterial && !0 === b.uniformsNeedUpdate && (kc.upload(T, m.uniformsList, f, bb), b.uniformsNeedUpdate = !1);
      b.isSpriteMaterial && d.setValue(T, "center", c.center);
      d.setValue(T, "modelViewMatrix", c.modelViewMatrix);
      d.setValue(T, "normalMatrix", c.normalMatrix);
      d.setValue(T, "modelMatrix", c.matrixWorld);
      return a;
    }
    function v(l, a, b) {
      l.opacity.value = a.opacity;
      a.color && l.diffuse.value.copy(a.color);
      a.emissive && l.emissive.value.copy(a.emissive).multiplyScalar(a.emissiveIntensity);
      a.map && (l.map.value = a.map);
      a.alphaMap && (l.alphaMap.value = a.alphaMap);
      a.specularMap && (l.specularMap.value = a.specularMap);
      if (b = a.envMap || b) {
        l.envMap.value = b, l.flipEnvMap.value = b.isCubeTexture ? -1 : 1, l.reflectivity.value = a.reflectivity, l.refractionRatio.value = a.refractionRatio, l.maxMipLevel.value = Pa.get(b).__maxMipLevel;
      }
      a.lightMap && (l.lightMap.value = a.lightMap, l.lightMapIntensity.value = a.lightMapIntensity);
      a.aoMap && (l.aoMap.value = a.aoMap, l.aoMapIntensity.value = a.aoMapIntensity);
      if (a.map) {
        var c = a.map;
      } else {
        a.specularMap ? c = a.specularMap : a.displacementMap ? c = a.displacementMap : a.normalMap ? c = a.normalMap : a.bumpMap ? c = a.bumpMap : a.roughnessMap ? c = a.roughnessMap : a.metalnessMap ? c = a.metalnessMap : a.alphaMap ? c = a.alphaMap : a.emissiveMap && (c = a.emissiveMap);
      }
      void 0 !== c && (c.isWebGLRenderTarget && (c = c.texture), !0 === c.matrixAutoUpdate && c.updateMatrix(), l.uvTransform.value.copy(c.matrix));
      if (a.aoMap) {
        var w = a.aoMap;
      } else {
        a.lightMap && (w = a.lightMap);
      }
      void 0 !== w && (w.isWebGLRenderTarget && (w = w.texture), !0 === w.matrixAutoUpdate && w.updateMatrix(), l.uv2Transform.value.copy(w.matrix));
    }
    function x(l, a, b) {
      l.roughness.value = a.roughness;
      l.metalness.value = a.metalness;
      a.roughnessMap && (l.roughnessMap.value = a.roughnessMap);
      a.metalnessMap && (l.metalnessMap.value = a.metalnessMap);
      a.emissiveMap && (l.emissiveMap.value = a.emissiveMap);
      a.bumpMap && (l.bumpMap.value = a.bumpMap, l.bumpScale.value = a.bumpScale, 1 === a.side && (l.bumpScale.value *= -1));
      a.normalMap && (l.normalMap.value = a.normalMap, l.normalScale.value.copy(a.normalScale), 1 === a.side && l.normalScale.value.negate());
      a.displacementMap && (l.displacementMap.value = a.displacementMap, l.displacementScale.value = a.displacementScale, l.displacementBias.value = a.displacementBias);
      if (a.envMap || b) {
        l.envMapIntensity.value = a.envMapIntensity;
      }
    }
    l = l || {};
    var U = void 0 !== l.canvas ? l.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), z = void 0 !== l.context ? l.context : null, C = void 0 !== l.alpha ? l.alpha : !1, A = void 0 !== l.depth ? l.depth : !0, qa = void 0 !== l.stencil ? l.stencil : !0, D = void 0 !== l.antialias ? l.antialias : !1, B = void 0 !== l.premultipliedAlpha ? l.premultipliedAlpha : !0, F = void 0 !== l.preserveDrawingBuffer ? l.preserveDrawingBuffer : !1, ra = void 0 !== l.powerPreference ? l.powerPreference : 
    "default", Ca = void 0 !== l.failIfMajorPerformanceCaveat ? l.failIfMajorPerformanceCaveat : !1, E = null, H = null;
    this.domElement = U;
    this.debug = {checkShaderErrors:!0};
    this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
    this.clippingPlanes = [];
    this.localClippingEnabled = !1;
    this.gammaFactor = 2;
    this.outputEncoding = 3E3;
    this.physicallyCorrectLights = !1;
    this.toneMapping = 0;
    this.toneMappingWhitePoint = this.toneMappingExposure = 1;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    var J = this, N = !1, O = null, I = 0, Q = 0, K = null, L = null, M = -1;
    var ca = a = null;
    var R = !1;
    var S = null, dd = null, P = new k, Cc = new k, Yd = null, Z = U.width, Eb = U.height, V = 1, W = null, Ze = null, hc = new k(0, 0, Z, Eb), ic = new k(0, 0, Z, Eb), X = !1, fa = new Ga, ja = new Va, ed = !1, Zd = !1, Y = new n, ma = new f;
    try {
      C = {alpha:C, depth:A, stencil:qa, antialias:D, premultipliedAlpha:B, preserveDrawingBuffer:F, powerPreference:ra, failIfMajorPerformanceCaveat:Ca, xrCompatible:!0};
      U.addEventListener("webglcontextlost", c, !1);
      U.addEventListener("webglcontextrestored", e, !1);
      var T = z || U.getContext("webgl", C) || U.getContext("experimental-webgl", C);
      if (null === T) {
        if (null !== U.getContext("webgl")) {
          throw Error("Error creating WebGL context with your selected attributes.");
        }
        throw Error("Error creating WebGL context.");
      }
      void 0 === T.getShaderPrecisionFormat && (T.getShaderPrecisionFormat = function() {
        return {rangeMin:1, rangeMax:1, precision:1};
      });
    } catch ($h) {
      throw console.error("THREE.WebGLRenderer: " + $h.message), $h;
    }
    var ea, ka, la, jb, Pa, bb, jc, Aa, ua, va, fd, xa, Fb, ha, oa, $e, qb;
    b();
    var pa = new Zh(J, T);
    this.xr = pa;
    var ta = new Xh(J, ua, ka.maxTextureSize);
    this.shadowMap = ta;
    this.getContext = function() {
      return T;
    };
    this.getContextAttributes = function() {
      return T.getContextAttributes();
    };
    this.forceContextLoss = function() {
      var l = ea.get("WEBGL_lose_context");
      l && l.loseContext();
    };
    this.forceContextRestore = function() {
      var l = ea.get("WEBGL_lose_context");
      l && l.restoreContext();
    };
    this.getPixelRatio = function() {
      return V;
    };
    this.setPixelRatio = function(l) {
      void 0 !== l && (V = l, this.setSize(Z, Eb, !1));
    };
    this.getSize = function(l) {
      void 0 === l && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), l = new g);
      return l.set(Z, Eb);
    };
    this.setSize = function(l, a, b) {
      pa.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Z = l, Eb = a, U.width = Math.floor(l * V), U.height = Math.floor(a * V), !1 !== b && (U.style.width = l + "px", U.style.height = a + "px"), this.setViewport(0, 0, l, a));
    };
    this.getDrawingBufferSize = function(l) {
      void 0 === l && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), l = new g);
      return l.set(Z * V, Eb * V).floor();
    };
    this.setDrawingBufferSize = function(l, a, b) {
      Z = l;
      Eb = a;
      V = b;
      U.width = Math.floor(l * b);
      U.height = Math.floor(a * b);
      this.setViewport(0, 0, l, a);
    };
    this.getCurrentViewport = function(l) {
      void 0 === l && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), l = new k);
      return l.copy(P);
    };
    this.getViewport = function(l) {
      return l.copy(hc);
    };
    this.setViewport = function(l, a, b, c) {
      l.isVector4 ? hc.set(l.x, l.y, l.z, l.w) : hc.set(l, a, b, c);
      la.viewport(P.copy(hc).multiplyScalar(V).floor());
    };
    this.getScissor = function(l) {
      return l.copy(ic);
    };
    this.setScissor = function(l, a, b, c) {
      l.isVector4 ? ic.set(l.x, l.y, l.z, l.w) : ic.set(l, a, b, c);
      la.scissor(Cc.copy(ic).multiplyScalar(V).floor());
    };
    this.getScissorTest = function() {
      return X;
    };
    this.setScissorTest = function(l) {
      la.setScissorTest(X = l);
    };
    this.setOpaqueSort = function(l) {
      W = l;
    };
    this.setTransparentSort = function(l) {
      Ze = l;
    };
    this.getClearColor = function() {
      return Fb.getClearColor();
    };
    this.setClearColor = function() {
      Fb.setClearColor.apply(Fb, arguments);
    };
    this.getClearAlpha = function() {
      return Fb.getClearAlpha();
    };
    this.setClearAlpha = function() {
      Fb.setClearAlpha.apply(Fb, arguments);
    };
    this.clear = function(l, a, b) {
      var c = 0;
      if (void 0 === l || l) {
        c |= 16384;
      }
      if (void 0 === a || a) {
        c |= 256;
      }
      if (void 0 === b || b) {
        c |= 1024;
      }
      T.clear(c);
    };
    this.clearColor = function() {
      this.clear(!0, !1, !1);
    };
    this.clearDepth = function() {
      this.clear(!1, !0, !1);
    };
    this.clearStencil = function() {
      this.clear(!1, !1, !0);
    };
    this.dispose = function() {
      U.removeEventListener("webglcontextlost", c, !1);
      U.removeEventListener("webglcontextrestored", e, !1);
      fd.dispose();
      xa.dispose();
      Pa.dispose();
      ua.dispose();
      pa.dispose();
      ya.stop();
    };
    this.renderBufferImmediate = function(l, a) {
      la.initAttributes();
      var b = Pa.get(l);
      l.hasPositions && !b.position && (b.position = T.createBuffer());
      l.hasNormals && !b.normal && (b.normal = T.createBuffer());
      l.hasUvs && !b.uv && (b.uv = T.createBuffer());
      l.hasColors && !b.color && (b.color = T.createBuffer());
      a = a.getAttributes();
      l.hasPositions && (T.bindBuffer(34962, b.position), T.bufferData(34962, l.positionArray, 35048), la.enableAttribute(a.position), T.vertexAttribPointer(a.position, 3, 5126, !1, 0, 0));
      l.hasNormals && (T.bindBuffer(34962, b.normal), T.bufferData(34962, l.normalArray, 35048), la.enableAttribute(a.normal), T.vertexAttribPointer(a.normal, 3, 5126, !1, 0, 0));
      l.hasUvs && (T.bindBuffer(34962, b.uv), T.bufferData(34962, l.uvArray, 35048), la.enableAttribute(a.uv), T.vertexAttribPointer(a.uv, 2, 5126, !1, 0, 0));
      l.hasColors && (T.bindBuffer(34962, b.color), T.bufferData(34962, l.colorArray, 35048), la.enableAttribute(a.color), T.vertexAttribPointer(a.color, 3, 5126, !1, 0, 0));
      la.disableUnusedAttributes();
      T.drawArrays(4, 0, l.count);
      l.count = 0;
    };
    var za = new y;
    this.renderBufferDirect = function(l, b, c, w, e, d) {
      null === b && (b = za);
      var m = e.isMesh && 0 > e.matrixWorld.determinant(), f = t(l, b, w, e);
      la.setMaterial(w, m);
      var k = !1;
      if (a !== c.id || ca !== f.id || R !== (!0 === w.wireframe)) {
        a = c.id, ca = f.id, R = !0 === w.wireframe, k = !0;
      }
      if (w.morphTargets || w.morphNormals) {
        ha.update(e, c, w, f), k = !0;
      }
      !0 === e.isInstancedMesh && (k = !0);
      l = c.index;
      b = c.attributes.position;
      if (null === l) {
        if (void 0 === b || 0 === b.count) {
          return;
        }
      } else {
        if (0 === l.count) {
          return;
        }
      }
      var h = 1;
      !0 === w.wireframe && (l = Aa.getWireframeAttribute(c), h = 2);
      m = oa;
      if (null !== l) {
        var g = jc.get(l);
        m = $e;
        m.setIndex(g);
      }
      if (k) {
        if (!1 !== ka.isWebGL2 || !e.isInstancedMesh && !c.isInstancedBufferGeometry || null !== ea.get("ANGLE_instanced_arrays")) {
          la.initAttributes();
          k = c.attributes;
          f = f.getAttributes();
          var r = w.defaultAttributeValues;
          for (U in f) {
            var G = f[U];
            if (0 <= G) {
              var n = k[U];
              if (void 0 !== n) {
                var q = n.normalized, p = n.itemSize, u = jc.get(n);
                if (void 0 !== u) {
                  var ba = u.buffer, y = u.type;
                  u = u.bytesPerElement;
                  if (n.isInterleavedBufferAttribute) {
                    var v = n.data, x = v.stride;
                    n = n.offset;
                    v && v.isInstancedInterleavedBuffer ? (la.enableAttributeAndDivisor(G, v.meshPerAttribute), void 0 === c.maxInstancedCount && (c.maxInstancedCount = v.meshPerAttribute * v.count)) : la.enableAttribute(G);
                    T.bindBuffer(34962, ba);
                    la.vertexAttribPointer(G, p, y, q, x * u, n * u);
                  } else {
                    n.isInstancedBufferAttribute ? (la.enableAttributeAndDivisor(G, n.meshPerAttribute), void 0 === c.maxInstancedCount && (c.maxInstancedCount = n.meshPerAttribute * n.count)) : la.enableAttribute(G), T.bindBuffer(34962, ba), la.vertexAttribPointer(G, p, y, q, 0, 0);
                  }
                }
              } else {
                if ("instanceMatrix" === U) {
                  u = jc.get(e.instanceMatrix), void 0 !== u && (ba = u.buffer, y = u.type, la.enableAttributeAndDivisor(G + 0, 1), la.enableAttributeAndDivisor(G + 1, 1), la.enableAttributeAndDivisor(G + 2, 1), la.enableAttributeAndDivisor(G + 3, 1), T.bindBuffer(34962, ba), T.vertexAttribPointer(G + 0, 4, y, !1, 64, 0), T.vertexAttribPointer(G + 1, 4, y, !1, 64, 16), T.vertexAttribPointer(G + 2, 4, y, !1, 64, 32), T.vertexAttribPointer(G + 3, 4, y, !1, 64, 48));
                } else {
                  if (void 0 !== r && (q = r[U], void 0 !== q)) {
                    switch(q.length) {
                      case 2:
                        T.vertexAttrib2fv(G, q);
                        break;
                      case 3:
                        T.vertexAttrib3fv(G, q);
                        break;
                      case 4:
                        T.vertexAttrib4fv(G, q);
                        break;
                      default:
                        T.vertexAttrib1fv(G, q);
                    }
                  }
                }
              }
            }
          }
          la.disableUnusedAttributes();
        }
        null !== l && T.bindBuffer(34963, g.buffer);
      }
      var U = c.drawRange.start * h;
      k = null !== d ? d.start * h : 0;
      g = Math.max(U, k);
      d = Math.max(0, Math.min(null !== l ? l.count : b.count, U + c.drawRange.count * h, k + (null !== d ? d.count * h : Infinity)) - 1 - g + 1);
      0 !== d && (e.isMesh ? !0 === w.wireframe ? (la.setLineWidth(w.wireframeLinewidth * (null === K ? V : 1)), m.setMode(1)) : m.setMode(4) : e.isLine ? (w = w.linewidth, void 0 === w && (w = 1), la.setLineWidth(w * (null === K ? V : 1)), e.isLineSegments ? m.setMode(1) : e.isLineLoop ? m.setMode(2) : m.setMode(3)) : e.isPoints ? m.setMode(0) : e.isSprite && m.setMode(4), e.isInstancedMesh ? m.renderInstances(c, g, d, e.count) : c.isInstancedBufferGeometry ? m.renderInstances(c, g, d, c.maxInstancedCount) : 
      m.render(g, d));
    };
    this.compile = function(l, a) {
      H = xa.get(l, a);
      H.init();
      l.traverse(function(l) {
        l.isLight && (H.pushLight(l), l.castShadow && H.pushShadow(l));
      });
      H.setupLights(a);
      var b = {};
      l.traverse(function(a) {
        if (a.material) {
          if (Array.isArray(a.material)) {
            for (var c = 0; c < a.material.length; c++) {
              !1 === a.material[c].uuid in b && (u(a.material[c], l, a), b[a.material[c].uuid] = !0);
            }
          } else {
            !1 === a.material.uuid in b && (u(a.material, l, a), b[a.material.uuid] = !0);
          }
        }
      });
    };
    var wa = null, ya = new sa;
    ya.setAnimationLoop(function(l) {
      pa.isPresenting || wa && wa(l);
    });
    "undefined" !== typeof window && ya.setContext(window);
    this.setAnimationLoop = function(l) {
      wa = l;
      pa.setAnimationLoop(l);
      ya.start();
    };
    this.render = function(l, b, c, w) {
      if (void 0 !== c) {
        console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
        var e = c;
      }
      if (void 0 !== w) {
        console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
        var d = w;
      }
      b && b.isCamera ? N || (ca = a = null, R = !1, M = -1, S = null, !0 === l.autoUpdate && l.updateMatrixWorld(), null === b.parent && b.updateMatrixWorld(), pa.enabled && pa.isPresenting && (b = pa.getCamera(b)), l.onBeforeRender(J, l, b, e || K), H = xa.get(l, b), H.init(), Y.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), fa.setFromProjectionMatrix(Y), Zd = this.localClippingEnabled, ed = ja.init(this.clippingPlanes, Zd, b), E = fd.get(l, b), E.init(), r(l, b, 0, J.sortObjects), 
      E.finish(), !0 === J.sortObjects && E.sort(W, Ze), ed && ja.beginShadows(), ta.render(H.state.shadowsArray, l, b), H.setupLights(b), ed && ja.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== e && this.setRenderTarget(e), Fb.render(E, l, b, d), c = E.opaque, w = E.transparent, l.overrideMaterial ? (e = l.overrideMaterial, c.length && q(c, l, b, e), w.length && q(w, l, b, e)) : (c.length && q(c, l, b), w.length && q(w, l, b)), l.onAfterRender(J, l, b), null !== K && (bb.updateRenderTargetMipmap(K), 
      bb.updateMultisampleRenderTarget(K)), la.buffers.depth.setTest(!0), la.buffers.depth.setMask(!0), la.buffers.color.setMask(!0), la.setPolygonOffset(!1), H = E = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
    };
    this.setFramebuffer = function(l) {
      O !== l && null === K && T.bindFramebuffer(36160, l);
      O = l;
    };
    this.getActiveCubeFace = function() {
      return I;
    };
    this.getActiveMipmapLevel = function() {
      return Q;
    };
    this.getRenderTarget = function() {
      return K;
    };
    this.setRenderTarget = function(l, a, b) {
      K = l;
      I = a;
      Q = b;
      l && void 0 === Pa.get(l).__webglFramebuffer && bb.setupRenderTarget(l);
      var c = O, w = !1;
      l ? (c = Pa.get(l).__webglFramebuffer, l.isWebGLCubeRenderTarget ? (c = c[a || 0], w = !0) : c = l.isWebGLMultisampleRenderTarget ? Pa.get(l).__webglMultisampledFramebuffer : c, P.copy(l.viewport), Cc.copy(l.scissor), Yd = l.scissorTest) : (P.copy(hc).multiplyScalar(V).floor(), Cc.copy(ic).multiplyScalar(V).floor(), Yd = X);
      L !== c && (T.bindFramebuffer(36160, c), L = c);
      la.viewport(P);
      la.scissor(Cc);
      la.setScissorTest(Yd);
      w && (l = Pa.get(l.texture), T.framebufferTexture2D(36160, 36064, 34069 + (a || 0), l.__webglTexture, b || 0));
    };
    this.readRenderTargetPixels = function(l, a, b, c, w, e, d) {
      if (l && l.isWebGLRenderTarget) {
        var m = Pa.get(l).__webglFramebuffer;
        l.isWebGLCubeRenderTarget && void 0 !== d && (m = m[d]);
        if (m) {
          d = !1;
          m !== L && (T.bindFramebuffer(36160, m), d = !0);
          try {
            var f = l.texture, k = f.format, h = f.type;
            1023 !== k && qb.convert(k) !== T.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === h || qb.convert(h) === T.getParameter(35738) || 1015 === h && (ka.isWebGL2 || ea.get("OES_texture_float") || ea.get("WEBGL_color_buffer_float")) || 1016 === h && (ka.isWebGL2 ? ea.get("EXT_color_buffer_float") : ea.get("EXT_color_buffer_half_float")) ? 36053 === T.checkFramebufferStatus(36160) ? 0 <= 
            a && a <= l.width - c && 0 <= b && b <= l.height - w && T.readPixels(a, b, c, w, qb.convert(k), qb.convert(h), e) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          } finally {
            d && T.bindFramebuffer(36160, L);
          }
        }
      } else {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      }
    };
    this.copyFramebufferToTexture = function(l, a, b) {
      void 0 === b && (b = 0);
      var c = Math.pow(2, -b), w = Math.floor(a.image.width * c);
      c = Math.floor(a.image.height * c);
      var e = qb.convert(a.format);
      bb.setTexture2D(a, 0);
      T.copyTexImage2D(3553, b, e, l.x, l.y, w, c, 0);
      la.unbindTexture();
    };
    this.copyTextureToTexture = function(l, a, b, c) {
      void 0 === c && (c = 0);
      var w = a.image.width, e = a.image.height, d = qb.convert(b.format), m = qb.convert(b.type);
      bb.setTexture2D(b, 0);
      a.isDataTexture ? T.texSubImage2D(3553, c, l.x, l.y, w, e, d, m, a.image.data) : a.isCompressedTexture ? T.compressedTexSubImage2D(3553, c, l.x, l.y, a.mipmaps[0].width, a.mipmaps[0].height, d, a.mipmaps[0].data) : T.texSubImage2D(3553, c, l.x, l.y, d, m, a.image);
      0 === c && b.generateMipmaps && T.generateMipmap(3553);
      la.unbindTexture();
    };
    this.initTexture = function(l) {
      bb.setTexture2D(l, 0);
      la.unbindTexture();
    };
    "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail:this}));
  }
  function cf(l, a) {
    this.name = "";
    this.color = new A(l);
    this.density = void 0 !== a ? a : 2.5E-4;
  }
  function df(l, a, b) {
    this.name = "";
    this.color = new A(l);
    this.near = void 0 !== a ? a : 1;
    this.far = void 0 !== b ? b : 1E3;
  }
  function Sb(l, a) {
    this.array = l;
    this.stride = a;
    this.count = void 0 !== l ? l.length / a : 0;
    this.usage = 35044;
    this.updateRange = {offset:0, count:-1};
    this.version = 0;
  }
  function ce(l, a, b, c) {
    this.data = l;
    this.itemSize = a;
    this.offset = b;
    this.normalized = !0 === c;
  }
  function nc(l) {
    H.call(this);
    this.type = "SpriteMaterial";
    this.color = new A(16777215);
    this.alphaMap = this.map = null;
    this.rotation = 0;
    this.transparent = this.sizeAttenuation = !0;
    this.setValues(l);
  }
  function de(l) {
    q.call(this);
    this.type = "Sprite";
    if (void 0 === hd) {
      hd = new M;
      var a = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
      a = new Sb(a, 5);
      hd.setIndex([0, 1, 2, 0, 2, 3]);
      hd.setAttribute("position", new ce(a, 3, 0, !1));
      hd.setAttribute("uv", new ce(a, 2, 3, !1));
    }
    this.geometry = hd;
    this.material = void 0 !== l ? l : new nc;
    this.center = new g(.5, .5);
  }
  function ef(l, a, b, c, e, d) {
    id.subVectors(l, b).addScalar(.5).multiply(c);
    void 0 !== e ? (ee.x = d * id.x - e * id.y, ee.y = e * id.x + d * id.y) : ee.copy(id);
    l.copy(a);
    l.x += ee.x;
    l.y += ee.y;
    l.applyMatrix4(ai);
  }
  function fe() {
    q.call(this);
    this._currentLevel = 0;
    this.type = "LOD";
    Object.defineProperties(this, {levels:{enumerable:!0, value:[]}});
    this.autoUpdate = !0;
  }
  function ff(l, a) {
    l && l.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    V.call(this, l, a);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new n;
    this.bindMatrixInverse = new n;
  }
  function gf(l, a) {
    l = l || [];
    this.bones = l.slice(0);
    this.boneMatrices = new Float32Array(16 * this.bones.length);
    this.frame = -1;
    if (void 0 === a) {
      this.calculateInverses();
    } else {
      if (this.bones.length === a.length) {
        this.boneInverses = a.slice(0);
      } else {
        for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], l = 0, a = this.bones.length; l < a; l++) {
          this.boneInverses.push(new n);
        }
      }
    }
  }
  function vg() {
    q.call(this);
    this.type = "Bone";
  }
  function hf(l, a, b) {
    V.call(this, l, a);
    this.instanceMatrix = new K(new Float32Array(16 * b), 16);
    this.count = b;
    this.frustumCulled = !1;
  }
  function ya(l) {
    H.call(this);
    this.type = "LineBasicMaterial";
    this.color = new A(16777215);
    this.linewidth = 1;
    this.linejoin = this.linecap = "round";
    this.setValues(l);
  }
  function cb(l, a, b) {
    1 === b && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
    q.call(this);
    this.type = "Line";
    this.geometry = void 0 !== l ? l : new M;
    this.material = void 0 !== a ? a : new ya;
  }
  function Da(l, a) {
    cb.call(this, l, a);
    this.type = "LineSegments";
  }
  function jf(l, a) {
    cb.call(this, l, a);
    this.type = "LineLoop";
  }
  function rb(l) {
    H.call(this);
    this.type = "PointsMaterial";
    this.color = new A(16777215);
    this.alphaMap = this.map = null;
    this.size = 1;
    this.sizeAttenuation = !0;
    this.morphTargets = !1;
    this.setValues(l);
  }
  function jd(l, a) {
    q.call(this);
    this.type = "Points";
    this.geometry = void 0 !== l ? l : new M;
    this.material = void 0 !== a ? a : new rb;
    this.updateMorphTargets();
  }
  function wg(l, a, b, c, e, d, m) {
    var w = xg.distanceSqToPoint(l);
    w < b && (b = new f, xg.closestPointToPoint(l, b), b.applyMatrix4(c), l = e.ray.origin.distanceTo(b), l < e.near || l > e.far || d.push({distance:l, distanceToRay:Math.sqrt(w), point:b, index:a, face:null, object:m}));
  }
  function yg(l, a, b, c, d, m, f, k, h) {
    e.call(this, l, a, b, c, d, m, f, k, h);
    this.format = void 0 !== f ? f : 1022;
    this.minFilter = void 0 !== m ? m : 1006;
    this.magFilter = void 0 !== d ? d : 1006;
    this.generateMipmaps = !1;
  }
  function kd(l, a, b, c, d, m, f, k, h, g, r, n) {
    e.call(this, null, m, f, k, h, g, c, d, r, n);
    this.image = {width:a, height:b};
    this.mipmaps = l;
    this.generateMipmaps = this.flipY = !1;
  }
  function ge(l, a, b, c, d, m, f, k, h) {
    e.call(this, l, a, b, c, d, m, f, k, h);
    this.needsUpdate = !0;
  }
  function he(l, a, b, c, d, m, f, k, h, g) {
    g = void 0 !== g ? g : 1026;
    if (1026 !== g && 1027 !== g) {
      throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    void 0 === b && 1026 === g && (b = 1012);
    void 0 === b && 1027 === g && (b = 1020);
    e.call(this, null, c, d, m, f, k, g, b, h);
    this.image = {width:l, height:a};
    this.magFilter = void 0 !== f ? f : 1003;
    this.minFilter = void 0 !== k ? k : 1003;
    this.generateMipmaps = this.flipY = !1;
  }
  function ld(l) {
    M.call(this);
    this.type = "WireframeGeometry";
    var a = [], b, c, e, d = [0, 0], m = {}, k = ["a", "b", "c"];
    if (l && l.isGeometry) {
      var h = l.faces;
      var g = 0;
      for (c = h.length; g < c; g++) {
        var r = h[g];
        for (b = 0; 3 > b; b++) {
          var n = r[k[b]];
          var q = r[k[(b + 1) % 3]];
          d[0] = Math.min(n, q);
          d[1] = Math.max(n, q);
          n = d[0] + "," + d[1];
          void 0 === m[n] && (m[n] = {index1:d[0], index2:d[1]});
        }
      }
      for (n in m) {
        g = m[n], k = l.vertices[g.index1], a.push(k.x, k.y, k.z), k = l.vertices[g.index2], a.push(k.x, k.y, k.z);
      }
    } else {
      if (l && l.isBufferGeometry) {
        if (k = new f, null !== l.index) {
          h = l.attributes.position;
          r = l.index;
          var p = l.groups;
          0 === p.length && (p = [{start:0, count:r.count, materialIndex:0}]);
          l = 0;
          for (e = p.length; l < e; ++l) {
            for (g = p[l], b = g.start, c = g.count, g = b, c = b + c; g < c; g += 3) {
              for (b = 0; 3 > b; b++) {
                n = r.getX(g + b), q = r.getX(g + (b + 1) % 3), d[0] = Math.min(n, q), d[1] = Math.max(n, q), n = d[0] + "," + d[1], void 0 === m[n] && (m[n] = {index1:d[0], index2:d[1]});
              }
            }
          }
          for (n in m) {
            g = m[n], k.fromBufferAttribute(h, g.index1), a.push(k.x, k.y, k.z), k.fromBufferAttribute(h, g.index2), a.push(k.x, k.y, k.z);
          }
        } else {
          for (h = l.attributes.position, g = 0, c = h.count / 3; g < c; g++) {
            for (b = 0; 3 > b; b++) {
              m = 3 * g + b, k.fromBufferAttribute(h, m), a.push(k.x, k.y, k.z), m = 3 * g + (b + 1) % 3, k.fromBufferAttribute(h, m), a.push(k.x, k.y, k.z);
            }
          }
        }
      }
    }
    this.setAttribute("position", new R(a, 3));
  }
  function ie(l, a, b) {
    X.call(this);
    this.type = "ParametricGeometry";
    this.parameters = {func:l, slices:a, stacks:b};
    this.fromBufferGeometry(new md(l, a, b));
    this.mergeVertices();
  }
  function md(l, a, b) {
    M.call(this);
    this.type = "ParametricBufferGeometry";
    this.parameters = {func:l, slices:a, stacks:b};
    var c = [], w = [], e = [], d = [], m = new f, k = new f, h = new f, g = new f, r = new f, n, G;
    3 > l.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
    var q = a + 1;
    for (n = 0; n <= b; n++) {
      var p = n / b;
      for (G = 0; G <= a; G++) {
        var u = G / a;
        l(u, p, k);
        w.push(k.x, k.y, k.z);
        0 <= u - 1E-5 ? (l(u - 1E-5, p, h), g.subVectors(k, h)) : (l(u + 1E-5, p, h), g.subVectors(h, k));
        0 <= p - 1E-5 ? (l(u, p - 1E-5, h), r.subVectors(k, h)) : (l(u, p + 1E-5, h), r.subVectors(h, k));
        m.crossVectors(g, r).normalize();
        e.push(m.x, m.y, m.z);
        d.push(u, p);
      }
    }
    for (n = 0; n < b; n++) {
      for (G = 0; G < a; G++) {
        l = n * q + G + 1, m = (n + 1) * q + G + 1, k = (n + 1) * q + G, c.push(n * q + G, l, k), c.push(l, m, k);
      }
    }
    this.setIndex(c);
    this.setAttribute("position", new R(w, 3));
    this.setAttribute("normal", new R(e, 3));
    this.setAttribute("uv", new R(d, 2));
  }
  function je(l, a, b, c) {
    X.call(this);
    this.type = "PolyhedronGeometry";
    this.parameters = {vertices:l, indices:a, radius:b, detail:c};
    this.fromBufferGeometry(new Ya(l, a, b, c));
    this.mergeVertices();
  }
  function Ya(l, a, b, c) {
    function w(l) {
      m.push(l.x, l.y, l.z);
    }
    function e(a, b) {
      a *= 3;
      b.x = l[a + 0];
      b.y = l[a + 1];
      b.z = l[a + 2];
    }
    function d(l, a, b, c) {
      0 > c && 1 === l.x && (k[a] = l.x - 1);
      0 === b.x && 0 === b.z && (k[a] = c / 2 / Math.PI + .5);
    }
    M.call(this);
    this.type = "PolyhedronBufferGeometry";
    this.parameters = {vertices:l, indices:a, radius:b, detail:c};
    b = b || 1;
    c = c || 0;
    var m = [], k = [];
    (function(l) {
      for (var b = new f, c = new f, d = new f, m = 0; m < a.length; m += 3) {
        e(a[m + 0], b);
        e(a[m + 1], c);
        e(a[m + 2], d);
        var k, h, g = b, r = c, n = d, G = Math.pow(2, l), q = [];
        for (h = 0; h <= G; h++) {
          q[h] = [];
          var p = g.clone().lerp(n, h / G), u = r.clone().lerp(n, h / G), t = G - h;
          for (k = 0; k <= t; k++) {
            q[h][k] = 0 === k && h === G ? p : p.clone().lerp(u, k / t);
          }
        }
        for (h = 0; h < G; h++) {
          for (k = 0; k < 2 * (G - h) - 1; k++) {
            g = Math.floor(k / 2), 0 === k % 2 ? (w(q[h][g + 1]), w(q[h + 1][g]), w(q[h][g])) : (w(q[h][g + 1]), w(q[h + 1][g + 1]), w(q[h + 1][g]));
          }
        }
      }
    })(c);
    (function(l) {
      for (var a = new f, b = 0; b < m.length; b += 3) {
        a.x = m[b + 0], a.y = m[b + 1], a.z = m[b + 2], a.normalize().multiplyScalar(l), m[b + 0] = a.x, m[b + 1] = a.y, m[b + 2] = a.z;
      }
    })(b);
    (function() {
      for (var l = new f, a = 0; a < m.length; a += 3) {
        l.x = m[a + 0], l.y = m[a + 1], l.z = m[a + 2], k.push(Math.atan2(l.z, -l.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-l.y, Math.sqrt(l.x * l.x + l.z * l.z)) / Math.PI + .5));
      }
      l = new f;
      a = new f;
      for (var b = new f, c = new f, w = new g, e = new g, h = new g, r = 0, n = 0; r < m.length; r += 9, n += 6) {
        l.set(m[r + 0], m[r + 1], m[r + 2]);
        a.set(m[r + 3], m[r + 4], m[r + 5]);
        b.set(m[r + 6], m[r + 7], m[r + 8]);
        w.set(k[n + 0], k[n + 1]);
        e.set(k[n + 2], k[n + 3]);
        h.set(k[n + 4], k[n + 5]);
        c.copy(l).add(a).add(b).divideScalar(3);
        var G = Math.atan2(c.z, -c.x);
        d(w, n + 0, l, G);
        d(e, n + 2, a, G);
        d(h, n + 4, b, G);
      }
      for (l = 0; l < k.length; l += 6) {
        a = k[l + 0], b = k[l + 2], c = k[l + 4], w = Math.min(a, b, c), .9 < Math.max(a, b, c) && .1 > w && (.2 > a && (k[l + 0] += 1), .2 > b && (k[l + 2] += 1), .2 > c && (k[l + 4] += 1));
      }
    })();
    this.setAttribute("position", new R(m, 3));
    this.setAttribute("normal", new R(m.slice(), 3));
    this.setAttribute("uv", new R(k, 2));
    0 === c ? this.computeVertexNormals() : this.normalizeNormals();
  }
  function ke(l, a) {
    X.call(this);
    this.type = "TetrahedronGeometry";
    this.parameters = {radius:l, detail:a};
    this.fromBufferGeometry(new nd(l, a));
    this.mergeVertices();
  }
  function nd(l, a) {
    Ya.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], l, a);
    this.type = "TetrahedronBufferGeometry";
    this.parameters = {radius:l, detail:a};
  }
  function le(l, a) {
    X.call(this);
    this.type = "OctahedronGeometry";
    this.parameters = {radius:l, detail:a};
    this.fromBufferGeometry(new Dc(l, a));
    this.mergeVertices();
  }
  function Dc(l, a) {
    Ya.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], l, a);
    this.type = "OctahedronBufferGeometry";
    this.parameters = {radius:l, detail:a};
  }
  function me(l, a) {
    X.call(this);
    this.type = "IcosahedronGeometry";
    this.parameters = {radius:l, detail:a};
    this.fromBufferGeometry(new od(l, a));
    this.mergeVertices();
  }
  function od(l, a) {
    var b = (1 + Math.sqrt(5)) / 2;
    Ya.call(this, [-1, b, 0, 1, b, 0, -1, -b, 0, 1, -b, 0, 0, -1, b, 0, 1, b, 0, -1, -b, 0, 1, -b, b, 0, -1, b, 0, 1, -b, 0, -1, -b, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], l, a);
    this.type = "IcosahedronBufferGeometry";
    this.parameters = {radius:l, detail:a};
  }
  function ne(l, a) {
    X.call(this);
    this.type = "DodecahedronGeometry";
    this.parameters = {radius:l, detail:a};
    this.fromBufferGeometry(new pd(l, a));
    this.mergeVertices();
  }
  function pd(l, a) {
    var b = (1 + Math.sqrt(5)) / 2, c = 1 / b;
    Ya.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -c, -b, 0, -c, b, 0, c, -b, 0, c, b, -c, -b, 0, -c, b, 0, c, -b, 0, c, b, 0, -b, 0, -c, b, 0, -c, -b, 0, c, b, 0, c], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 
    8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], l, a);
    this.type = "DodecahedronBufferGeometry";
    this.parameters = {radius:l, detail:a};
  }
  function oe(l, a, b, c, e, d) {
    X.call(this);
    this.type = "TubeGeometry";
    this.parameters = {path:l, tubularSegments:a, radius:b, radialSegments:c, closed:e};
    void 0 !== d && console.warn("THREE.TubeGeometry: taper has been removed.");
    l = new Ec(l, a, b, c, e);
    this.tangents = l.tangents;
    this.normals = l.normals;
    this.binormals = l.binormals;
    this.fromBufferGeometry(l);
    this.mergeVertices();
  }
  function Ec(l, a, b, c, e) {
    function w(w) {
      r = l.getPointAt(w / a, r);
      var e = d.normals[w];
      w = d.binormals[w];
      for (G = 0; G <= c; G++) {
        var f = G / c * Math.PI * 2, h = Math.sin(f);
        f = -Math.cos(f);
        k.x = f * e.x + h * w.x;
        k.y = f * e.y + h * w.y;
        k.z = f * e.z + h * w.z;
        k.normalize();
        p.push(k.x, k.y, k.z);
        m.x = r.x + b * k.x;
        m.y = r.y + b * k.y;
        m.z = r.z + b * k.z;
        q.push(m.x, m.y, m.z);
      }
    }
    M.call(this);
    this.type = "TubeBufferGeometry";
    this.parameters = {path:l, tubularSegments:a, radius:b, radialSegments:c, closed:e};
    a = a || 64;
    b = b || 1;
    c = c || 8;
    e = e || !1;
    var d = l.computeFrenetFrames(a, e);
    this.tangents = d.tangents;
    this.normals = d.normals;
    this.binormals = d.binormals;
    var m = new f, k = new f, h = new g, r = new f, n, G, q = [], p = [], u = [], t = [];
    for (n = 0; n < a; n++) {
      w(n);
    }
    w(!1 === e ? a : 0);
    for (n = 0; n <= a; n++) {
      for (G = 0; G <= c; G++) {
        h.x = n / a, h.y = G / c, u.push(h.x, h.y);
      }
    }
    (function() {
      for (G = 1; G <= a; G++) {
        for (n = 1; n <= c; n++) {
          var l = (c + 1) * G + (n - 1), b = (c + 1) * G + n, w = (c + 1) * (G - 1) + n;
          t.push((c + 1) * (G - 1) + (n - 1), l, w);
          t.push(l, b, w);
        }
      }
    })();
    this.setIndex(t);
    this.setAttribute("position", new R(q, 3));
    this.setAttribute("normal", new R(p, 3));
    this.setAttribute("uv", new R(u, 2));
  }
  function pe(l, a, b, c, e, d, m) {
    X.call(this);
    this.type = "TorusKnotGeometry";
    this.parameters = {radius:l, tube:a, tubularSegments:b, radialSegments:c, p:e, q:d};
    void 0 !== m && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
    this.fromBufferGeometry(new qd(l, a, b, c, e, d));
    this.mergeVertices();
  }
  function qd(l, a, b, c, e, d) {
    function w(l, a, b, c, w) {
      var e = Math.sin(l);
      a = b / a * l;
      b = Math.cos(a);
      w.x = c * (2 + b) * .5 * Math.cos(l);
      w.y = c * (2 + b) * e * .5;
      w.z = c * Math.sin(a) * .5;
    }
    M.call(this);
    this.type = "TorusKnotBufferGeometry";
    this.parameters = {radius:l, tube:a, tubularSegments:b, radialSegments:c, p:e, q:d};
    l = l || 1;
    a = a || .4;
    b = Math.floor(b) || 64;
    c = Math.floor(c) || 8;
    e = e || 2;
    d = d || 3;
    var m = [], k = [], h = [], g = [], r, n = new f, G = new f, q = new f, p = new f, u = new f, t = new f, y = new f;
    for (r = 0; r <= b; ++r) {
      var ba = r / b * e * Math.PI * 2;
      w(ba, e, d, l, q);
      w(ba + .01, e, d, l, p);
      t.subVectors(p, q);
      y.addVectors(p, q);
      u.crossVectors(t, y);
      y.crossVectors(u, t);
      u.normalize();
      y.normalize();
      for (ba = 0; ba <= c; ++ba) {
        var v = ba / c * Math.PI * 2, x = -a * Math.cos(v);
        v = a * Math.sin(v);
        n.x = q.x + (x * y.x + v * u.x);
        n.y = q.y + (x * y.y + v * u.y);
        n.z = q.z + (x * y.z + v * u.z);
        k.push(n.x, n.y, n.z);
        G.subVectors(n, q).normalize();
        h.push(G.x, G.y, G.z);
        g.push(r / b);
        g.push(ba / c);
      }
    }
    for (ba = 1; ba <= b; ba++) {
      for (r = 1; r <= c; r++) {
        l = (c + 1) * ba + (r - 1), a = (c + 1) * ba + r, e = (c + 1) * (ba - 1) + r, m.push((c + 1) * (ba - 1) + (r - 1), l, e), m.push(l, a, e);
      }
    }
    this.setIndex(m);
    this.setAttribute("position", new R(k, 3));
    this.setAttribute("normal", new R(h, 3));
    this.setAttribute("uv", new R(g, 2));
  }
  function qe(l, a, b, c, e) {
    X.call(this);
    this.type = "TorusGeometry";
    this.parameters = {radius:l, tube:a, radialSegments:b, tubularSegments:c, arc:e};
    this.fromBufferGeometry(new rd(l, a, b, c, e));
    this.mergeVertices();
  }
  function rd(l, a, b, c, e) {
    M.call(this);
    this.type = "TorusBufferGeometry";
    this.parameters = {radius:l, tube:a, radialSegments:b, tubularSegments:c, arc:e};
    l = l || 1;
    a = a || .4;
    b = Math.floor(b) || 8;
    c = Math.floor(c) || 6;
    e = e || 2 * Math.PI;
    var w = [], d = [], m = [], k = [], h = new f, g = new f, r = new f, n, G;
    for (n = 0; n <= b; n++) {
      for (G = 0; G <= c; G++) {
        var q = G / c * e, p = n / b * Math.PI * 2;
        g.x = (l + a * Math.cos(p)) * Math.cos(q);
        g.y = (l + a * Math.cos(p)) * Math.sin(q);
        g.z = a * Math.sin(p);
        d.push(g.x, g.y, g.z);
        h.x = l * Math.cos(q);
        h.y = l * Math.sin(q);
        r.subVectors(g, h).normalize();
        m.push(r.x, r.y, r.z);
        k.push(G / c);
        k.push(n / b);
      }
    }
    for (n = 1; n <= b; n++) {
      for (G = 1; G <= c; G++) {
        l = (c + 1) * (n - 1) + G - 1, a = (c + 1) * (n - 1) + G, e = (c + 1) * n + G, w.push((c + 1) * n + G - 1, l, e), w.push(l, a, e);
      }
    }
    this.setIndex(w);
    this.setAttribute("position", new R(d, 3));
    this.setAttribute("normal", new R(m, 3));
    this.setAttribute("uv", new R(k, 2));
  }
  function bi(l, a, b, c, e) {
    for (var w, d = 0, m = a, f = b - c; m < b; m += c) {
      d += (l[f] - l[m]) * (l[m + 1] + l[f + 1]), f = m;
    }
    if (e === 0 < d) {
      for (e = a; e < b; e += c) {
        w = ci(e, l[e], l[e + 1], w);
      }
    } else {
      for (e = b - c; e >= a; e -= c) {
        w = ci(e, l[e], l[e + 1], w);
      }
    }
    w && kf(w, w.next) && (re(w), w = w.next);
    return w;
  }
  function oc(l, a) {
    if (!l) {
      return l;
    }
    a || (a = l);
    do {
      var b = !1;
      if (l.steiner || !kf(l, l.next) && 0 !== Ea(l.prev, l, l.next)) {
        l = l.next;
      } else {
        re(l);
        l = a = l.prev;
        if (l === l.next) {
          break;
        }
        b = !0;
      }
    } while (b || l !== a);
    return a;
  }
  function se(l, a, b, c, e, d, m) {
    if (l) {
      if (!m && d) {
        var w = l, f = w;
        do {
          null === f.z && (f.z = zg(f.x, f.y, c, e, d)), f.prevZ = f.prev, f = f.nextZ = f.next;
        } while (f !== w);
        f.prevZ.nextZ = null;
        f.prevZ = null;
        w = f;
        var k, h, g, r, n = 1;
        do {
          f = w;
          var G = w = null;
          for (h = 0; f;) {
            h++;
            var q = f;
            for (k = g = 0; k < n && (g++, q = q.nextZ, q); k++) {
            }
            for (r = n; 0 < g || 0 < r && q;) {
              0 !== g && (0 === r || !q || f.z <= q.z) ? (k = f, f = f.nextZ, g--) : (k = q, q = q.nextZ, r--), G ? G.nextZ = k : w = k, k.prevZ = G, G = k;
            }
            f = q;
          }
          G.nextZ = null;
          n *= 2;
        } while (1 < h);
      }
      for (w = l; l.prev !== l.next;) {
        f = l.prev;
        q = l.next;
        if (d) {
          G = Sj(l, c, e, d);
        } else {
          a: {
            if (G = l, h = G.prev, g = G, n = G.next, 0 <= Ea(h, g, n)) {
              G = !1;
            } else {
              for (k = G.next.next; k !== G.prev;) {
                if (sd(h.x, h.y, g.x, g.y, n.x, n.y, k.x, k.y) && 0 <= Ea(k.prev, k, k.next)) {
                  G = !1;
                  break a;
                }
                k = k.next;
              }
              G = !0;
            }
          }
        }
        if (G) {
          a.push(f.i / b), a.push(l.i / b), a.push(q.i / b), re(l), w = l = q.next;
        } else {
          if (l = q, l === w) {
            if (!m) {
              se(oc(l), a, b, c, e, d, 1);
            } else {
              if (1 === m) {
                l = oc(l);
                m = a;
                w = b;
                f = l;
                do {
                  q = f.prev, G = f.next.next, !kf(q, G) && di(q, f, f.next, G) && te(q, G) && te(G, q) && (m.push(q.i / w), m.push(f.i / w), m.push(G.i / w), re(f), re(f.next), f = l = G), f = f.next;
                } while (f !== l);
                l = oc(f);
                se(l, a, b, c, e, d, 2);
              } else {
                if (2 === m) {
                  a: {
                    m = l;
                    do {
                      for (w = m.next.next; w !== m.prev;) {
                        if (f = m.i !== w.i) {
                          f = m;
                          q = w;
                          if (G = f.next.i !== q.i && f.prev.i !== q.i) {
                            b: {
                              G = f;
                              do {
                                if (G.i !== f.i && G.next.i !== f.i && G.i !== q.i && G.next.i !== q.i && di(G, G.next, f, q)) {
                                  G = !0;
                                  break b;
                                }
                                G = G.next;
                              } while (G !== f);
                              G = !1;
                            }
                            G = !G;
                          }
                          if (G) {
                            if (G = te(f, q) && te(q, f)) {
                              G = f;
                              h = !1;
                              g = (f.x + q.x) / 2;
                              n = (f.y + q.y) / 2;
                              do {
                                G.y > n !== G.next.y > n && G.next.y !== G.y && g < (G.next.x - G.x) * (n - G.y) / (G.next.y - G.y) + G.x && (h = !h), G = G.next;
                              } while (G !== f);
                              G = h;
                            }
                            G = G && (Ea(f.prev, f, q.prev) || Ea(f, q.prev, q)) || kf(f, q) && 0 < Ea(f.prev, f, f.next) && 0 < Ea(q.prev, q, q.next);
                          }
                          f = G;
                        }
                        if (f) {
                          l = ei(m, w);
                          m = oc(m, m.next);
                          l = oc(l, l.next);
                          se(m, a, b, c, e, d);
                          se(l, a, b, c, e, d);
                          break a;
                        }
                        w = w.next;
                      }
                      m = m.next;
                    } while (m !== l);
                  }
                }
              }
            }
            break;
          }
        }
      }
    }
  }
  function Sj(l, a, b, c) {
    var w = l.prev, e = l.next;
    if (0 <= Ea(w, l, e)) {
      return !1;
    }
    var d = w.x > l.x ? w.x > e.x ? w.x : e.x : l.x > e.x ? l.x : e.x, m = w.y > l.y ? w.y > e.y ? w.y : e.y : l.y > e.y ? l.y : e.y, f = zg(w.x < l.x ? w.x < e.x ? w.x : e.x : l.x < e.x ? l.x : e.x, w.y < l.y ? w.y < e.y ? w.y : e.y : l.y < e.y ? l.y : e.y, a, b, c);
    a = zg(d, m, a, b, c);
    b = l.prevZ;
    for (c = l.nextZ; b && b.z >= f && c && c.z <= a;) {
      if (b !== l.prev && b !== l.next && sd(w.x, w.y, l.x, l.y, e.x, e.y, b.x, b.y) && 0 <= Ea(b.prev, b, b.next)) {
        return !1;
      }
      b = b.prevZ;
      if (c !== l.prev && c !== l.next && sd(w.x, w.y, l.x, l.y, e.x, e.y, c.x, c.y) && 0 <= Ea(c.prev, c, c.next)) {
        return !1;
      }
      c = c.nextZ;
    }
    for (; b && b.z >= f;) {
      if (b !== l.prev && b !== l.next && sd(w.x, w.y, l.x, l.y, e.x, e.y, b.x, b.y) && 0 <= Ea(b.prev, b, b.next)) {
        return !1;
      }
      b = b.prevZ;
    }
    for (; c && c.z <= a;) {
      if (c !== l.prev && c !== l.next && sd(w.x, w.y, l.x, l.y, e.x, e.y, c.x, c.y) && 0 <= Ea(c.prev, c, c.next)) {
        return !1;
      }
      c = c.nextZ;
    }
    return !0;
  }
  function Tj(l, a) {
    return l.x - a.x;
  }
  function Uj(l, a) {
    var b = a, c = l.x, w = l.y, e = -Infinity;
    do {
      if (w <= b.y && w >= b.next.y && b.next.y !== b.y) {
        var d = b.x + (w - b.y) * (b.next.x - b.x) / (b.next.y - b.y);
        if (d <= c && d > e) {
          e = d;
          if (d === c) {
            if (w === b.y) {
              return b;
            }
            if (w === b.next.y) {
              return b.next;
            }
          }
          var m = b.x < b.next.x ? b : b.next;
        }
      }
      b = b.next;
    } while (b !== a);
    if (!m) {
      return null;
    }
    if (c === e) {
      return m;
    }
    a = m;
    d = m.x;
    var f = m.y, k = Infinity;
    b = m;
    do {
      if (c >= b.x && b.x >= d && c !== b.x && sd(w < f ? c : e, w, d, f, w < f ? e : c, w, b.x, b.y)) {
        var h = Math.abs(w - b.y) / (c - b.x);
        var g;
        if ((g = te(b, l)) && !(g = h < k) && (g = h === k) && !(g = b.x > m.x) && (g = b.x === m.x)) {
          g = m;
          var n = b;
          g = 0 > Ea(g.prev, g, n.prev) && 0 > Ea(n.next, g, g.next);
        }
        g && (m = b, k = h);
      }
      b = b.next;
    } while (b !== a);
    return m;
  }
  function zg(l, a, b, c, e) {
    l = 32767 * (l - b) * e;
    a = 32767 * (a - c) * e;
    l = (l | l << 8) & 16711935;
    l = (l | l << 4) & 252645135;
    l = (l | l << 2) & 858993459;
    a = (a | a << 8) & 16711935;
    a = (a | a << 4) & 252645135;
    a = (a | a << 2) & 858993459;
    return (l | l << 1) & 1431655765 | ((a | a << 1) & 1431655765) << 1;
  }
  function Vj(l) {
    var a = l, b = l;
    do {
      if (a.x < b.x || a.x === b.x && a.y < b.y) {
        b = a;
      }
      a = a.next;
    } while (a !== l);
    return b;
  }
  function sd(l, a, b, c, e, d, m, f) {
    return 0 <= (e - m) * (a - f) - (l - m) * (d - f) && 0 <= (l - m) * (c - f) - (b - m) * (a - f) && 0 <= (b - m) * (d - f) - (e - m) * (c - f);
  }
  function Ea(l, a, b) {
    return (a.y - l.y) * (b.x - a.x) - (a.x - l.x) * (b.y - a.y);
  }
  function kf(l, a) {
    return l.x === a.x && l.y === a.y;
  }
  function di(l, a, b, c) {
    var w = lf(Ea(l, a, b)), e = lf(Ea(l, a, c)), d = lf(Ea(b, c, l)), m = lf(Ea(b, c, a));
    return w !== e && d !== m || 0 === w && mf(l, b, a) || 0 === e && mf(l, c, a) || 0 === d && mf(b, l, c) || 0 === m && mf(b, a, c) ? !0 : !1;
  }
  function mf(l, a, b) {
    return a.x <= Math.max(l.x, b.x) && a.x >= Math.min(l.x, b.x) && a.y <= Math.max(l.y, b.y) && a.y >= Math.min(l.y, b.y);
  }
  function lf(l) {
    return 0 < l ? 1 : 0 > l ? -1 : 0;
  }
  function te(l, a) {
    return 0 > Ea(l.prev, l, l.next) ? 0 <= Ea(l, a, l.next) && 0 <= Ea(l, l.prev, a) : 0 > Ea(l, a, l.prev) || 0 > Ea(l, l.next, a);
  }
  function ei(l, a) {
    var b = new Ag(l.i, l.x, l.y), c = new Ag(a.i, a.x, a.y), w = l.next, e = a.prev;
    l.next = a;
    a.prev = l;
    b.next = w;
    w.prev = b;
    c.next = b;
    b.prev = c;
    e.next = c;
    c.prev = e;
    return c;
  }
  function ci(l, a, b, c) {
    l = new Ag(l, a, b);
    c ? (l.next = c.next, l.prev = c, c.next.prev = l, c.next = l) : (l.prev = l, l.next = l);
    return l;
  }
  function re(l) {
    l.next.prev = l.prev;
    l.prev.next = l.next;
    l.prevZ && (l.prevZ.nextZ = l.nextZ);
    l.nextZ && (l.nextZ.prevZ = l.prevZ);
  }
  function Ag(l, a, b) {
    this.i = l;
    this.x = a;
    this.y = b;
    this.nextZ = this.prevZ = this.z = this.next = this.prev = null;
    this.steiner = !1;
  }
  function fi(l) {
    var a = l.length;
    2 < a && l[a - 1].equals(l[0]) && l.pop();
  }
  function gi(l, a) {
    for (var b = 0; b < a.length; b++) {
      l.push(a[b].x), l.push(a[b].y);
    }
  }
  function Fc(l, a) {
    X.call(this);
    this.type = "ExtrudeGeometry";
    this.parameters = {shapes:l, options:a};
    this.fromBufferGeometry(new Gb(l, a));
    this.mergeVertices();
  }
  function Gb(l, a) {
    function b(l) {
      function b(l, a, b) {
        a || console.error("THREE.ExtrudeGeometry: vec does not exist");
        return a.clone().multiplyScalar(b).add(l);
      }
      function d(l, a, b) {
        var c = l.x - a.x;
        var w = l.y - a.y;
        var e = b.x - l.x;
        var d = b.y - l.y, m = c * c + w * w;
        if (Math.abs(c * d - w * e) > Number.EPSILON) {
          var f = Math.sqrt(m), k = Math.sqrt(e * e + d * d);
          m = a.x - w / f;
          a = a.y + c / f;
          d = ((b.x - d / k - m) * d - (b.y + e / k - a) * e) / (c * d - w * e);
          e = m + c * d - l.x;
          c = a + w * d - l.y;
          w = e * e + c * c;
          if (2 >= w) {
            return new g(e, c);
          }
          w = Math.sqrt(w / 2);
        } else {
          l = !1, c > Number.EPSILON ? e > Number.EPSILON && (l = !0) : c < -Number.EPSILON ? e < -Number.EPSILON && (l = !0) : Math.sign(w) === Math.sign(d) && (l = !0), l ? (e = -w, w = Math.sqrt(m)) : (e = c, c = w, w = Math.sqrt(m / 2));
        }
        return new g(e / w, c / w);
      }
      function m(l, a) {
        for (O = l.length; 0 <= --O;) {
          var b = O;
          var e = O - 1;
          0 > e && (e = l.length - 1);
          var d, m = p + 2 * x;
          for (d = 0; d < m; d++) {
            var f = Pb * d, k = Pb * (d + 1), h = a + e + f, g = a + e + k;
            k = a + b + k;
            n(a + b + f);
            n(h);
            n(k);
            n(h);
            n(g);
            n(k);
            f = w.length / 3;
            f = z.generateSideWallUV(c, w, f - 6, f - 3, f - 2, f - 1);
            r(f[0]);
            r(f[1]);
            r(f[3]);
            r(f[1]);
            r(f[2]);
            r(f[3]);
          }
        }
      }
      function k(l, a, b) {
        q.push(l);
        q.push(a);
        q.push(b);
      }
      function h(l, a, b) {
        n(l);
        n(a);
        n(b);
        l = w.length / 3;
        l = z.generateTopUV(c, w, l - 3, l - 2, l - 1);
        r(l[0]);
        r(l[1]);
        r(l[2]);
      }
      function n(l) {
        w.push(q[3 * l]);
        w.push(q[3 * l + 1]);
        w.push(q[3 * l + 2]);
      }
      function r(l) {
        e.push(l.x);
        e.push(l.y);
      }
      var q = [], G = void 0 !== a.curveSegments ? a.curveSegments : 12, p = void 0 !== a.steps ? a.steps : 1, u = void 0 !== a.depth ? a.depth : 100, t = void 0 !== a.bevelEnabled ? a.bevelEnabled : !0, y = void 0 !== a.bevelThickness ? a.bevelThickness : 6, v = void 0 !== a.bevelSize ? a.bevelSize : y - 2, ba = void 0 !== a.bevelOffset ? a.bevelOffset : 0, x = void 0 !== a.bevelSegments ? a.bevelSegments : 3, U = a.extrudePath, z = void 0 !== a.UVGenerator ? a.UVGenerator : Wj;
      void 0 !== a.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), u = a.amount);
      var da = !1;
      if (U) {
        var C = U.getSpacedPoints(p);
        da = !0;
        t = !1;
        var ia = U.computeFrenetFrames(p, !1);
        var A = new f;
        var qa = new f;
        var D = new f;
      }
      t || (ba = v = y = x = 0);
      var B;
      G = l.extractPoints(G);
      l = G.shape;
      var Na = G.holes;
      if (!Tb.isClockWise(l)) {
        l = l.reverse();
        var F = 0;
        for (B = Na.length; F < B; F++) {
          var ra = Na[F];
          Tb.isClockWise(ra) && (Na[F] = ra.reverse());
        }
      }
      var Ca = Tb.triangulateShape(l, Na), E = l;
      F = 0;
      for (B = Na.length; F < B; F++) {
        ra = Na[F], l = l.concat(ra);
      }
      var H, Pb = l.length, J, N = Ca.length;
      G = [];
      var O = 0;
      var I = E.length;
      var Q = I - 1;
      for (H = O + 1; O < I; O++, Q++, H++) {
        Q === I && (Q = 0), H === I && (H = 0), G[O] = d(E[O], E[Q], E[H]);
      }
      U = [];
      var K = G.concat();
      F = 0;
      for (B = Na.length; F < B; F++) {
        ra = Na[F];
        var L = [];
        O = 0;
        I = ra.length;
        Q = I - 1;
        for (H = O + 1; O < I; O++, Q++, H++) {
          Q === I && (Q = 0), H === I && (H = 0), L[O] = d(ra[O], ra[Q], ra[H]);
        }
        U.push(L);
        K = K.concat(L);
      }
      for (Q = 0; Q < x; Q++) {
        I = Q / x;
        var zb = y * Math.cos(I * Math.PI / 2);
        H = v * Math.sin(I * Math.PI / 2) + ba;
        O = 0;
        for (I = E.length; O < I; O++) {
          var M = b(E[O], G[O], H);
          k(M.x, M.y, -zb);
        }
        F = 0;
        for (B = Na.length; F < B; F++) {
          for (ra = Na[F], L = U[F], O = 0, I = ra.length; O < I; O++) {
            M = b(ra[O], L[O], H), k(M.x, M.y, -zb);
          }
        }
      }
      H = v + ba;
      for (O = 0; O < Pb; O++) {
        M = t ? b(l[O], K[O], H) : l[O], da ? (qa.copy(ia.normals[0]).multiplyScalar(M.x), A.copy(ia.binormals[0]).multiplyScalar(M.y), D.copy(C[0]).add(qa).add(A), k(D.x, D.y, D.z)) : k(M.x, M.y, 0);
      }
      for (I = 1; I <= p; I++) {
        for (O = 0; O < Pb; O++) {
          M = t ? b(l[O], K[O], H) : l[O], da ? (qa.copy(ia.normals[I]).multiplyScalar(M.x), A.copy(ia.binormals[I]).multiplyScalar(M.y), D.copy(C[I]).add(qa).add(A), k(D.x, D.y, D.z)) : k(M.x, M.y, u / p * I);
        }
      }
      for (Q = x - 1; 0 <= Q; Q--) {
        I = Q / x;
        zb = y * Math.cos(I * Math.PI / 2);
        H = v * Math.sin(I * Math.PI / 2) + ba;
        O = 0;
        for (I = E.length; O < I; O++) {
          M = b(E[O], G[O], H), k(M.x, M.y, u + zb);
        }
        F = 0;
        for (B = Na.length; F < B; F++) {
          for (ra = Na[F], L = U[F], O = 0, I = ra.length; O < I; O++) {
            M = b(ra[O], L[O], H), da ? k(M.x, M.y + C[p - 1].y, C[p - 1].x + zb) : k(M.x, M.y, u + zb);
          }
        }
      }
      (function() {
        var l = w.length / 3;
        if (t) {
          var a = 0 * Pb;
          for (O = 0; O < N; O++) {
            J = Ca[O], h(J[2] + a, J[1] + a, J[0] + a);
          }
          a = Pb * (p + 2 * x);
          for (O = 0; O < N; O++) {
            J = Ca[O], h(J[0] + a, J[1] + a, J[2] + a);
          }
        } else {
          for (O = 0; O < N; O++) {
            J = Ca[O], h(J[2], J[1], J[0]);
          }
          for (O = 0; O < N; O++) {
            J = Ca[O], h(J[0] + Pb * p, J[1] + Pb * p, J[2] + Pb * p);
          }
        }
        c.addGroup(l, w.length / 3 - l, 0);
      })();
      (function() {
        var l = w.length / 3, a = 0;
        m(E, a);
        a += E.length;
        F = 0;
        for (B = Na.length; F < B; F++) {
          ra = Na[F], m(ra, a), a += ra.length;
        }
        c.addGroup(l, w.length / 3 - l, 1);
      })();
    }
    M.call(this);
    this.type = "ExtrudeBufferGeometry";
    this.parameters = {shapes:l, options:a};
    l = Array.isArray(l) ? l : [l];
    for (var c = this, w = [], e = [], d = 0, m = l.length; d < m; d++) {
      b(l[d]);
    }
    this.setAttribute("position", new R(w, 3));
    this.setAttribute("uv", new R(e, 2));
    this.computeVertexNormals();
  }
  function hi(l, a, b) {
    b.shapes = [];
    if (Array.isArray(l)) {
      for (var c = 0, w = l.length; c < w; c++) {
        b.shapes.push(l[c].uuid);
      }
    } else {
      b.shapes.push(l.uuid);
    }
    void 0 !== a.extrudePath && (b.options.extrudePath = a.extrudePath.toJSON());
    return b;
  }
  function ue(l, a) {
    X.call(this);
    this.type = "TextGeometry";
    this.parameters = {text:l, parameters:a};
    this.fromBufferGeometry(new td(l, a));
    this.mergeVertices();
  }
  function td(l, a) {
    a = a || {};
    var b = a.font;
    if (!b || !b.isFont) {
      return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new X;
    }
    l = b.generateShapes(l, a.size);
    a.depth = void 0 !== a.height ? a.height : 50;
    void 0 === a.bevelThickness && (a.bevelThickness = 10);
    void 0 === a.bevelSize && (a.bevelSize = 8);
    void 0 === a.bevelEnabled && (a.bevelEnabled = !1);
    Gb.call(this, l, a);
    this.type = "TextBufferGeometry";
  }
  function ve(l, a, b, c, e, d, m) {
    X.call(this);
    this.type = "SphereGeometry";
    this.parameters = {radius:l, widthSegments:a, heightSegments:b, phiStart:c, phiLength:e, thetaStart:d, thetaLength:m};
    this.fromBufferGeometry(new Gc(l, a, b, c, e, d, m));
    this.mergeVertices();
  }
  function Gc(l, a, b, c, e, d, m) {
    M.call(this);
    this.type = "SphereBufferGeometry";
    this.parameters = {radius:l, widthSegments:a, heightSegments:b, phiStart:c, phiLength:e, thetaStart:d, thetaLength:m};
    l = l || 1;
    a = Math.max(3, Math.floor(a) || 8);
    b = Math.max(2, Math.floor(b) || 6);
    c = void 0 !== c ? c : 0;
    e = void 0 !== e ? e : 2 * Math.PI;
    d = void 0 !== d ? d : 0;
    m = void 0 !== m ? m : Math.PI;
    var w = Math.min(d + m, Math.PI), k, h, g = 0, n = [], r = new f, q = new f, G = [], p = [], u = [], t = [];
    for (h = 0; h <= b; h++) {
      var y = [], v = h / b, ba = 0;
      0 == h && 0 == d ? ba = .5 / a : h == b && w == Math.PI && (ba = -.5 / a);
      for (k = 0; k <= a; k++) {
        var x = k / a;
        r.x = -l * Math.cos(c + x * e) * Math.sin(d + v * m);
        r.y = l * Math.cos(d + v * m);
        r.z = l * Math.sin(c + x * e) * Math.sin(d + v * m);
        p.push(r.x, r.y, r.z);
        q.copy(r).normalize();
        u.push(q.x, q.y, q.z);
        t.push(x + ba, 1 - v);
        y.push(g++);
      }
      n.push(y);
    }
    for (h = 0; h < b; h++) {
      for (k = 0; k < a; k++) {
        l = n[h][k + 1], c = n[h][k], e = n[h + 1][k], m = n[h + 1][k + 1], (0 !== h || 0 < d) && G.push(l, c, m), (h !== b - 1 || w < Math.PI) && G.push(c, e, m);
      }
    }
    this.setIndex(G);
    this.setAttribute("position", new R(p, 3));
    this.setAttribute("normal", new R(u, 3));
    this.setAttribute("uv", new R(t, 2));
  }
  function we(l, a, b, c, e, d) {
    X.call(this);
    this.type = "RingGeometry";
    this.parameters = {innerRadius:l, outerRadius:a, thetaSegments:b, phiSegments:c, thetaStart:e, thetaLength:d};
    this.fromBufferGeometry(new ud(l, a, b, c, e, d));
    this.mergeVertices();
  }
  function ud(l, a, b, c, e, d) {
    M.call(this);
    this.type = "RingBufferGeometry";
    this.parameters = {innerRadius:l, outerRadius:a, thetaSegments:b, phiSegments:c, thetaStart:e, thetaLength:d};
    l = l || .5;
    a = a || 1;
    e = void 0 !== e ? e : 0;
    d = void 0 !== d ? d : 2 * Math.PI;
    b = void 0 !== b ? Math.max(3, b) : 8;
    c = void 0 !== c ? Math.max(1, c) : 1;
    var w = [], m = [], k = [], h = [], n = l, r = (a - l) / c, q = new f, G = new g, p, u;
    for (p = 0; p <= c; p++) {
      for (u = 0; u <= b; u++) {
        l = e + u / b * d, q.x = n * Math.cos(l), q.y = n * Math.sin(l), m.push(q.x, q.y, q.z), k.push(0, 0, 1), G.x = (q.x / a + 1) / 2, G.y = (q.y / a + 1) / 2, h.push(G.x, G.y);
      }
      n += r;
    }
    for (p = 0; p < c; p++) {
      for (a = p * (b + 1), u = 0; u < b; u++) {
        l = u + a, e = l + b + 1, d = l + b + 2, n = l + 1, w.push(l, e, n), w.push(e, d, n);
      }
    }
    this.setIndex(w);
    this.setAttribute("position", new R(m, 3));
    this.setAttribute("normal", new R(k, 3));
    this.setAttribute("uv", new R(h, 2));
  }
  function xe(l, a, b, c) {
    X.call(this);
    this.type = "LatheGeometry";
    this.parameters = {points:l, segments:a, phiStart:b, phiLength:c};
    this.fromBufferGeometry(new vd(l, a, b, c));
    this.mergeVertices();
  }
  function vd(l, a, b, c) {
    M.call(this);
    this.type = "LatheBufferGeometry";
    this.parameters = {points:l, segments:a, phiStart:b, phiLength:c};
    a = Math.floor(a) || 12;
    b = b || 0;
    c = c || 2 * Math.PI;
    c = na.clamp(c, 0, 2 * Math.PI);
    var w = [], e = [], d = [], m = 1 / a, k = new f, h = new g, n;
    for (n = 0; n <= a; n++) {
      var r = b + n * m * c;
      var q = Math.sin(r), G = Math.cos(r);
      for (r = 0; r <= l.length - 1; r++) {
        k.x = l[r].x * q, k.y = l[r].y, k.z = l[r].x * G, e.push(k.x, k.y, k.z), h.x = n / a, h.y = r / (l.length - 1), d.push(h.x, h.y);
      }
    }
    for (n = 0; n < a; n++) {
      for (r = 0; r < l.length - 1; r++) {
        b = r + n * l.length, m = b + l.length, k = b + l.length + 1, h = b + 1, w.push(b, m, h), w.push(m, k, h);
      }
    }
    this.setIndex(w);
    this.setAttribute("position", new R(e, 3));
    this.setAttribute("uv", new R(d, 2));
    this.computeVertexNormals();
    if (c === 2 * Math.PI) {
      for (c = this.attributes.normal.array, w = new f, e = new f, d = new f, b = a * l.length * 3, r = n = 0; n < l.length; n++, r += 3) {
        w.x = c[r + 0], w.y = c[r + 1], w.z = c[r + 2], e.x = c[b + r + 0], e.y = c[b + r + 1], e.z = c[b + r + 2], d.addVectors(w, e).normalize(), c[r + 0] = c[b + r + 0] = d.x, c[r + 1] = c[b + r + 1] = d.y, c[r + 2] = c[b + r + 2] = d.z;
      }
    }
  }
  function Hc(l, a) {
    X.call(this);
    this.type = "ShapeGeometry";
    "object" === typeof a && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), a = a.curveSegments);
    this.parameters = {shapes:l, curveSegments:a};
    this.fromBufferGeometry(new Ic(l, a));
    this.mergeVertices();
  }
  function Ic(l, a) {
    function b(l) {
      var b, m = w.length / 3;
      l = l.extractPoints(a);
      var k = l.shape, h = l.holes;
      !1 === Tb.isClockWise(k) && (k = k.reverse());
      l = 0;
      for (b = h.length; l < b; l++) {
        var g = h[l];
        !0 === Tb.isClockWise(g) && (h[l] = g.reverse());
      }
      var r = Tb.triangulateShape(k, h);
      l = 0;
      for (b = h.length; l < b; l++) {
        g = h[l], k = k.concat(g);
      }
      l = 0;
      for (b = k.length; l < b; l++) {
        g = k[l], w.push(g.x, g.y, 0), e.push(0, 0, 1), d.push(g.x, g.y);
      }
      l = 0;
      for (b = r.length; l < b; l++) {
        k = r[l], c.push(k[0] + m, k[1] + m, k[2] + m), f += 3;
      }
    }
    M.call(this);
    this.type = "ShapeBufferGeometry";
    this.parameters = {shapes:l, curveSegments:a};
    a = a || 12;
    var c = [], w = [], e = [], d = [], m = 0, f = 0;
    if (!1 === Array.isArray(l)) {
      b(l);
    } else {
      for (var k = 0; k < l.length; k++) {
        b(l[k]), this.addGroup(m, f, k), m += f, f = 0;
      }
    }
    this.setIndex(c);
    this.setAttribute("position", new R(w, 3));
    this.setAttribute("normal", new R(e, 3));
    this.setAttribute("uv", new R(d, 2));
  }
  function ii(l, a) {
    a.shapes = [];
    if (Array.isArray(l)) {
      for (var b = 0, c = l.length; b < c; b++) {
        a.shapes.push(l[b].uuid);
      }
    } else {
      a.shapes.push(l.uuid);
    }
    return a;
  }
  function wd(l, a) {
    M.call(this);
    this.type = "EdgesGeometry";
    this.parameters = {thresholdAngle:a};
    var b = [];
    a = Math.cos(na.DEG2RAD * (void 0 !== a ? a : 1));
    var c = [0, 0], w = {}, e = ["a", "b", "c"];
    if (l.isBufferGeometry) {
      var d = new X;
      d.fromBufferGeometry(l);
    } else {
      d = l.clone();
    }
    d.mergeVertices();
    d.computeFaceNormals();
    l = d.vertices;
    d = d.faces;
    for (var m = 0, f = d.length; m < f; m++) {
      for (var k = d[m], h = 0; 3 > h; h++) {
        var g = k[e[h]];
        var r = k[e[(h + 1) % 3]];
        c[0] = Math.min(g, r);
        c[1] = Math.max(g, r);
        g = c[0] + "," + c[1];
        void 0 === w[g] ? w[g] = {index1:c[0], index2:c[1], face1:m, face2:void 0} : w[g].face2 = m;
      }
    }
    for (g in w) {
      if (c = w[g], void 0 === c.face2 || d[c.face1].normal.dot(d[c.face2].normal) <= a) {
        e = l[c.index1], b.push(e.x, e.y, e.z), e = l[c.index2], b.push(e.x, e.y, e.z);
      }
    }
    this.setAttribute("position", new R(b, 3));
  }
  function Jc(l, a, b, c, e, d, m, f) {
    X.call(this);
    this.type = "CylinderGeometry";
    this.parameters = {radiusTop:l, radiusBottom:a, height:b, radialSegments:c, heightSegments:e, openEnded:d, thetaStart:m, thetaLength:f};
    this.fromBufferGeometry(new Ub(l, a, b, c, e, d, m, f));
    this.mergeVertices();
  }
  function Ub(l, a, b, c, e, d, m, k) {
    function w(b) {
      var e, w = new g, d = new f, u = 0, v = !0 === b ? l : a, ba = !0 === b ? 1 : -1;
      var x = p;
      for (e = 1; e <= c; e++) {
        n.push(0, t * ba, 0), q.push(0, ba, 0), G.push(.5, .5), p++;
      }
      var U = p;
      for (e = 0; e <= c; e++) {
        var z = e / c * k + m, da = Math.cos(z);
        z = Math.sin(z);
        d.x = v * z;
        d.y = t * ba;
        d.z = v * da;
        n.push(d.x, d.y, d.z);
        q.push(0, ba, 0);
        w.x = .5 * da + .5;
        w.y = .5 * z * ba + .5;
        G.push(w.x, w.y);
        p++;
      }
      for (e = 0; e < c; e++) {
        w = x + e, d = U + e, !0 === b ? r.push(d, d + 1, w) : r.push(d + 1, d, w), u += 3;
      }
      h.addGroup(y, u, !0 === b ? 1 : 2);
      y += u;
    }
    M.call(this);
    this.type = "CylinderBufferGeometry";
    this.parameters = {radiusTop:l, radiusBottom:a, height:b, radialSegments:c, heightSegments:e, openEnded:d, thetaStart:m, thetaLength:k};
    var h = this;
    l = void 0 !== l ? l : 1;
    a = void 0 !== a ? a : 1;
    b = b || 1;
    c = Math.floor(c) || 8;
    e = Math.floor(e) || 1;
    d = void 0 !== d ? d : !1;
    m = void 0 !== m ? m : 0;
    k = void 0 !== k ? k : 2 * Math.PI;
    var r = [], n = [], q = [], G = [], p = 0, u = [], t = b / 2, y = 0;
    (function() {
      var w, d, g = new f, v = new f, ba = 0, x = (a - l) / b;
      for (d = 0; d <= e; d++) {
        var U = [], z = d / e, da = z * (a - l) + l;
        for (w = 0; w <= c; w++) {
          var C = w / c, A = C * k + m, ia = Math.sin(A);
          A = Math.cos(A);
          v.x = da * ia;
          v.y = -z * b + t;
          v.z = da * A;
          n.push(v.x, v.y, v.z);
          g.set(ia, x, A).normalize();
          q.push(g.x, g.y, g.z);
          G.push(C, 1 - z);
          U.push(p++);
        }
        u.push(U);
      }
      for (w = 0; w < c; w++) {
        for (d = 0; d < e; d++) {
          g = u[d + 1][w], v = u[d + 1][w + 1], x = u[d][w + 1], r.push(u[d][w], g, x), r.push(g, v, x), ba += 6;
        }
      }
      h.addGroup(y, ba, 0);
      y += ba;
    })();
    !1 === d && (0 < l && w(!0), 0 < a && w(!1));
    this.setIndex(r);
    this.setAttribute("position", new R(n, 3));
    this.setAttribute("normal", new R(q, 3));
    this.setAttribute("uv", new R(G, 2));
  }
  function ye(l, a, b, c, e, d, m) {
    Jc.call(this, 0, l, a, b, c, e, d, m);
    this.type = "ConeGeometry";
    this.parameters = {radius:l, height:a, radialSegments:b, heightSegments:c, openEnded:e, thetaStart:d, thetaLength:m};
  }
  function ze(l, a, b, c, e, d, m) {
    Ub.call(this, 0, l, a, b, c, e, d, m);
    this.type = "ConeBufferGeometry";
    this.parameters = {radius:l, height:a, radialSegments:b, heightSegments:c, openEnded:e, thetaStart:d, thetaLength:m};
  }
  function Ae(l, a, b, c) {
    X.call(this);
    this.type = "CircleGeometry";
    this.parameters = {radius:l, segments:a, thetaStart:b, thetaLength:c};
    this.fromBufferGeometry(new xd(l, a, b, c));
    this.mergeVertices();
  }
  function xd(l, a, b, c) {
    M.call(this);
    this.type = "CircleBufferGeometry";
    this.parameters = {radius:l, segments:a, thetaStart:b, thetaLength:c};
    l = l || 1;
    a = void 0 !== a ? Math.max(3, a) : 8;
    b = void 0 !== b ? b : 0;
    c = void 0 !== c ? c : 2 * Math.PI;
    var e = [], w = [], d = [], m = [], k, h = new f, r = new g;
    w.push(0, 0, 0);
    d.push(0, 0, 1);
    m.push(.5, .5);
    var n = 0;
    for (k = 3; n <= a; n++, k += 3) {
      var q = b + n / a * c;
      h.x = l * Math.cos(q);
      h.y = l * Math.sin(q);
      w.push(h.x, h.y, h.z);
      d.push(0, 0, 1);
      r.x = (w[k] / l + 1) / 2;
      r.y = (w[k + 1] / l + 1) / 2;
      m.push(r.x, r.y);
    }
    for (k = 1; k <= a; k++) {
      e.push(k, k + 1, 0);
    }
    this.setIndex(e);
    this.setAttribute("position", new R(w, 3));
    this.setAttribute("normal", new R(d, 3));
    this.setAttribute("uv", new R(m, 2));
  }
  function Kc(l) {
    H.call(this);
    this.type = "ShadowMaterial";
    this.color = new A(0);
    this.transparent = !0;
    this.setValues(l);
  }
  function Vb(l) {
    T.call(this, l);
    this.type = "RawShaderMaterial";
  }
  function Hb(l) {
    H.call(this);
    this.defines = {STANDARD:""};
    this.type = "MeshStandardMaterial";
    this.color = new A(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new A(0);
    this.emissiveIntensity = 1;
    this.bumpMap = this.emissiveMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new g(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.vertexTangents = this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(l);
  }
  function Lc(l) {
    Hb.call(this);
    this.defines = {STANDARD:"", PHYSICAL:""};
    this.type = "MeshPhysicalMaterial";
    this.clearcoat = 0;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new g(1, 1);
    this.clearcoatNormalMap = null;
    this.reflectivity = .5;
    this.sheen = null;
    this.transparency = 0;
    this.setValues(l);
  }
  function pc(l) {
    H.call(this);
    this.type = "MeshPhongMaterial";
    this.color = new A(16777215);
    this.specular = new A(1118481);
    this.shininess = 30;
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new A(0);
    this.emissiveIntensity = 1;
    this.bumpMap = this.emissiveMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new g(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.envMap = this.alphaMap = this.specularMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(l);
  }
  function Mc(l) {
    H.call(this);
    this.defines = {TOON:""};
    this.type = "MeshToonMaterial";
    this.color = new A(16777215);
    this.specular = new A(1118481);
    this.shininess = 30;
    this.lightMap = this.gradientMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new A(0);
    this.emissiveIntensity = 1;
    this.bumpMap = this.emissiveMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new g(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = this.specularMap = null;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(l);
  }
  function Nc(l) {
    H.call(this);
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new g(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.morphNormals = this.morphTargets = this.skinning = this.fog = !1;
    this.setValues(l);
  }
  function Oc(l) {
    H.call(this);
    this.type = "MeshLambertMaterial";
    this.color = new A(16777215);
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new A(0);
    this.emissiveIntensity = 1;
    this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(l);
  }
  function Pc(l) {
    H.call(this);
    this.defines = {MATCAP:""};
    this.type = "MeshMatcapMaterial";
    this.color = new A(16777215);
    this.bumpMap = this.map = this.matcap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new g(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(l);
  }
  function Qc(l) {
    ya.call(this);
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(l);
  }
  function db(l, a, b, c) {
    this.parameterPositions = l;
    this._cachedIndex = 0;
    this.resultBuffer = void 0 !== c ? c : new a.constructor(b);
    this.sampleValues = a;
    this.valueSize = b;
  }
  function nf(l, a, b, c) {
    db.call(this, l, a, b, c);
    this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0;
  }
  function Be(l, a, b, c) {
    db.call(this, l, a, b, c);
  }
  function of(l, a, b, c) {
    db.call(this, l, a, b, c);
  }
  function Qa(l, a, b, c) {
    if (void 0 === l) {
      throw Error("THREE.KeyframeTrack: track name is undefined");
    }
    if (void 0 === a || 0 === a.length) {
      throw Error("THREE.KeyframeTrack: no keyframes in track named " + l);
    }
    this.name = l;
    this.times = Ba.convertArray(a, this.TimeBufferType);
    this.values = Ba.convertArray(b, this.ValueBufferType);
    this.setInterpolation(c || this.DefaultInterpolation);
  }
  function pf(l, a, b) {
    Qa.call(this, l, a, b);
  }
  function qf(l, a, b, c) {
    Qa.call(this, l, a, b, c);
  }
  function yd(l, a, b, c) {
    Qa.call(this, l, a, b, c);
  }
  function rf(l, a, b, c) {
    db.call(this, l, a, b, c);
  }
  function Ce(l, a, b, c) {
    Qa.call(this, l, a, b, c);
  }
  function sf(l, a, b, c) {
    Qa.call(this, l, a, b, c);
  }
  function zd(l, a, b, c) {
    Qa.call(this, l, a, b, c);
  }
  function kb(l, a, b, c) {
    this.name = l;
    this.tracks = b;
    this.duration = void 0 !== a ? a : -1;
    this.blendMode = void 0 !== c ? c : 2500;
    this.uuid = na.generateUUID();
    0 > this.duration && this.resetDuration();
  }
  function Xj(l) {
    switch(l.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return yd;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return zd;
      case "color":
        return qf;
      case "quaternion":
        return Ce;
      case "bool":
      case "boolean":
        return pf;
      case "string":
        return sf;
    }
    throw Error("THREE.KeyframeTrack: Unsupported typeName: " + l);
  }
  function Yj(l) {
    if (void 0 === l.type) {
      throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
    }
    var a = Xj(l.type);
    if (void 0 === l.times) {
      var b = [], c = [];
      Ba.flattenJSON(l.keys, b, c, "value");
      l.times = b;
      l.values = c;
    }
    return void 0 !== a.parse ? a.parse(l) : new a(l.name, l.times, l.values, l.interpolation);
  }
  function Bg(l, a, b) {
    var c = this, e = !1, w = 0, d = 0, m = void 0, f = [];
    this.onStart = void 0;
    this.onLoad = l;
    this.onProgress = a;
    this.onError = b;
    this.itemStart = function(l) {
      d++;
      if (!1 === e && void 0 !== c.onStart) {
        c.onStart(l, w, d);
      }
      e = !0;
    };
    this.itemEnd = function(l) {
      w++;
      if (void 0 !== c.onProgress) {
        c.onProgress(l, w, d);
      }
      if (w === d && (e = !1, void 0 !== c.onLoad)) {
        c.onLoad();
      }
    };
    this.itemError = function(l) {
      if (void 0 !== c.onError) {
        c.onError(l);
      }
    };
    this.resolveURL = function(l) {
      return m ? m(l) : l;
    };
    this.setURLModifier = function(l) {
      m = l;
      return this;
    };
    this.addHandler = function(l, a) {
      f.push(l, a);
      return this;
    };
    this.removeHandler = function(l) {
      l = f.indexOf(l);
      -1 !== l && f.splice(l, 2);
      return this;
    };
    this.getHandler = function(l) {
      for (var a = 0, b = f.length; a < b; a += 2) {
        var c = f[a], e = f[a + 1];
        c.global && (c.lastIndex = 0);
        if (c.test(l)) {
          return e;
        }
      }
      return null;
    };
  }
  function pa(l) {
    this.manager = void 0 !== l ? l : ji;
    this.crossOrigin = "anonymous";
    this.resourcePath = this.path = "";
  }
  function lb(l) {
    pa.call(this, l);
  }
  function Cg(l) {
    pa.call(this, l);
  }
  function Dg(l) {
    pa.call(this, l);
  }
  function tf(l) {
    pa.call(this, l);
  }
  function Ad(l) {
    pa.call(this, l);
  }
  function uf(l) {
    pa.call(this, l);
  }
  function vf(l) {
    pa.call(this, l);
  }
  function ha() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  function eb(l, a, b, c, e, d, m, f) {
    ha.call(this);
    this.type = "EllipseCurve";
    this.aX = l || 0;
    this.aY = a || 0;
    this.xRadius = b || 1;
    this.yRadius = c || 1;
    this.aStartAngle = e || 0;
    this.aEndAngle = d || 2 * Math.PI;
    this.aClockwise = m || !1;
    this.aRotation = f || 0;
  }
  function Bd(l, a, b, c, e, d) {
    eb.call(this, l, a, b, b, c, e, d);
    this.type = "ArcCurve";
  }
  function Eg() {
    var l = 0, a = 0, b = 0, c = 0;
    return {initCatmullRom:function(e, w, d, m, f) {
      e = f * (d - e);
      m = f * (m - w);
      l = w;
      a = e;
      b = -3 * w + 3 * d - 2 * e - m;
      c = 2 * w - 2 * d + e + m;
    }, initNonuniformCatmullRom:function(e, w, d, m, f, k, h) {
      e = ((w - e) / f - (d - e) / (f + k) + (d - w) / k) * k;
      m = ((d - w) / k - (m - w) / (k + h) + (m - d) / h) * k;
      l = w;
      a = e;
      b = -3 * w + 3 * d - 2 * e - m;
      c = 2 * w - 2 * d + e + m;
    }, calc:function(e) {
      var w = e * e;
      return l + a * e + b * w + c * w * e;
    }};
  }
  function Ta(l, a, b, c) {
    ha.call(this);
    this.type = "CatmullRomCurve3";
    this.points = l || [];
    this.closed = a || !1;
    this.curveType = b || "centripetal";
    this.tension = c || .5;
  }
  function ki(l, a, b, c, e) {
    a = .5 * (c - a);
    e = .5 * (e - b);
    var w = l * l;
    return (2 * b - 2 * c + a + e) * l * w + (-3 * b + 3 * c - 2 * a - e) * w + a * l + b;
  }
  function De(l, a, b, c) {
    var e = 1 - l;
    return e * e * a + 2 * (1 - l) * l * b + l * l * c;
  }
  function Ee(l, a, b, c, e) {
    var w = 1 - l, d = 1 - l;
    return w * w * w * a + 3 * d * d * l * b + 3 * (1 - l) * l * l * c + l * l * l * e;
  }
  function sb(l, a, b, c) {
    ha.call(this);
    this.type = "CubicBezierCurve";
    this.v0 = l || new g;
    this.v1 = a || new g;
    this.v2 = b || new g;
    this.v3 = c || new g;
  }
  function Ib(l, a, b, c) {
    ha.call(this);
    this.type = "CubicBezierCurve3";
    this.v0 = l || new f;
    this.v1 = a || new f;
    this.v2 = b || new f;
    this.v3 = c || new f;
  }
  function Za(l, a) {
    ha.call(this);
    this.type = "LineCurve";
    this.v1 = l || new g;
    this.v2 = a || new g;
  }
  function tb(l, a) {
    ha.call(this);
    this.type = "LineCurve3";
    this.v1 = l || new f;
    this.v2 = a || new f;
  }
  function ub(l, a, b) {
    ha.call(this);
    this.type = "QuadraticBezierCurve";
    this.v0 = l || new g;
    this.v1 = a || new g;
    this.v2 = b || new g;
  }
  function Jb(l, a, b) {
    ha.call(this);
    this.type = "QuadraticBezierCurve3";
    this.v0 = l || new f;
    this.v1 = a || new f;
    this.v2 = b || new f;
  }
  function vb(l) {
    ha.call(this);
    this.type = "SplineCurve";
    this.points = l || [];
  }
  function Wb() {
    ha.call(this);
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = !1;
  }
  function wb(l) {
    Wb.call(this);
    this.type = "Path";
    this.currentPoint = new g;
    l && this.setFromPoints(l);
  }
  function qc(l) {
    wb.call(this, l);
    this.uuid = na.generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  function wa(l, a) {
    q.call(this);
    this.type = "Light";
    this.color = new A(l);
    this.intensity = void 0 !== a ? a : 1;
    this.receiveShadow = void 0;
  }
  function wf(l, a, b) {
    wa.call(this, l, b);
    this.type = "HemisphereLight";
    this.castShadow = void 0;
    this.position.copy(q.DefaultUp);
    this.updateMatrix();
    this.groundColor = new A(a);
  }
  function Kb(l) {
    this.camera = l;
    this.bias = 0;
    this.radius = 1;
    this.mapSize = new g(512, 512);
    this.mapPass = this.map = null;
    this.matrix = new n;
    this._frustum = new Ga;
    this._frameExtents = new g(1, 1);
    this._viewportCount = 1;
    this._viewports = [new k(0, 0, 1, 1)];
  }
  function xf() {
    Kb.call(this, new ka(50, 1, .5, 500));
  }
  function yf(l, a, b, c, e, d) {
    wa.call(this, l, a);
    this.type = "SpotLight";
    this.position.copy(q.DefaultUp);
    this.updateMatrix();
    this.target = new q;
    Object.defineProperty(this, "power", {get:function() {
      return this.intensity * Math.PI;
    }, set:function(l) {
      this.intensity = l / Math.PI;
    }});
    this.distance = void 0 !== b ? b : 0;
    this.angle = void 0 !== c ? c : Math.PI / 3;
    this.penumbra = void 0 !== e ? e : 0;
    this.decay = void 0 !== d ? d : 1;
    this.shadow = new xf;
  }
  function Fg() {
    Kb.call(this, new ka(90, 1, .5, 500));
    this._frameExtents = new g(4, 2);
    this._viewportCount = 6;
    this._viewports = [new k(2, 1, 1, 1), new k(0, 1, 1, 1), new k(3, 1, 1, 1), new k(1, 1, 1, 1), new k(3, 0, 1, 1), new k(1, 0, 1, 1)];
    this._cubeDirections = [new f(1, 0, 0), new f(-1, 0, 0), new f(0, 0, 1), new f(0, 0, -1), new f(0, 1, 0), new f(0, -1, 0)];
    this._cubeUps = [new f(0, 1, 0), new f(0, 1, 0), new f(0, 1, 0), new f(0, 1, 0), new f(0, 0, 1), new f(0, 0, -1)];
  }
  function zf(l, a, b, c) {
    wa.call(this, l, a);
    this.type = "PointLight";
    Object.defineProperty(this, "power", {get:function() {
      return 4 * this.intensity * Math.PI;
    }, set:function(l) {
      this.intensity = l / (4 * Math.PI);
    }});
    this.distance = void 0 !== b ? b : 0;
    this.decay = void 0 !== c ? c : 1;
    this.shadow = new Fg;
  }
  function Cd(l, a, b, c, e, d) {
    ma.call(this);
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = void 0 !== l ? l : -1;
    this.right = void 0 !== a ? a : 1;
    this.top = void 0 !== b ? b : 1;
    this.bottom = void 0 !== c ? c : -1;
    this.near = void 0 !== e ? e : .1;
    this.far = void 0 !== d ? d : 2E3;
    this.updateProjectionMatrix();
  }
  function Af() {
    Kb.call(this, new Cd(-5, 5, 5, -5, .5, 500));
  }
  function Bf(l, a) {
    wa.call(this, l, a);
    this.type = "DirectionalLight";
    this.position.copy(q.DefaultUp);
    this.updateMatrix();
    this.target = new q;
    this.shadow = new Af;
  }
  function Cf(l, a) {
    wa.call(this, l, a);
    this.type = "AmbientLight";
    this.castShadow = void 0;
  }
  function Df(l, a, b, c) {
    wa.call(this, l, a);
    this.type = "RectAreaLight";
    this.width = void 0 !== b ? b : 10;
    this.height = void 0 !== c ? c : 10;
  }
  function Ef() {
    this.coefficients = [];
    for (var l = 0; 9 > l; l++) {
      this.coefficients.push(new f);
    }
  }
  function mb(l, a) {
    wa.call(this, void 0, a);
    this.type = "LightProbe";
    this.sh = void 0 !== l ? l : new Ef;
  }
  function Ff(l) {
    pa.call(this, l);
    this.textures = {};
  }
  function Gf() {
    M.call(this);
    this.type = "InstancedBufferGeometry";
    this.maxInstancedCount = void 0;
  }
  function Hf(l, a, b, c) {
    "number" === typeof b && (c = b, b = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));
    K.call(this, l, a, b);
    this.meshPerAttribute = c || 1;
  }
  function If(l) {
    pa.call(this, l);
  }
  function Jf(l) {
    pa.call(this, l);
  }
  function Gg(l) {
    "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    pa.call(this, l);
    this.options = void 0;
  }
  function Hg() {
    this.type = "ShapePath";
    this.color = new A;
    this.subPaths = [];
    this.currentPath = null;
  }
  function Ig(l) {
    this.type = "Font";
    this.data = l;
  }
  function Jg(l) {
    pa.call(this, l);
  }
  function Kf(l) {
    pa.call(this, l);
  }
  function Kg(l, a, b) {
    mb.call(this, void 0, b);
    l = (new A).set(l);
    b = (new A).set(a);
    a = new f(l.r, l.g, l.b);
    l = new f(b.r, b.g, b.b);
    b = Math.sqrt(Math.PI);
    var c = b * Math.sqrt(.75);
    this.sh.coefficients[0].copy(a).add(l).multiplyScalar(b);
    this.sh.coefficients[1].copy(a).sub(l).multiplyScalar(c);
  }
  function Lg(l, a) {
    mb.call(this, void 0, a);
    l = (new A).set(l);
    this.sh.coefficients[0].set(l.r, l.g, l.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
  function li() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = .064;
    this.cameraL = new ka;
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = !1;
    this.cameraR = new ka;
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = !1;
    this._cache = {focus:null, fov:null, aspect:null, near:null, far:null, zoom:null, eyeSep:null};
  }
  function Mg(l) {
    this.autoStart = void 0 !== l ? l : !0;
    this.elapsedTime = this.oldTime = this.startTime = 0;
    this.running = !1;
  }
  function Ng() {
    q.call(this);
    this.type = "AudioListener";
    this.context = Og.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
    this._clock = new Mg;
  }
  function Dd(l) {
    q.call(this);
    this.type = "Audio";
    this.listener = l;
    this.context = l.context;
    this.gain = this.context.createGain();
    this.gain.connect(l.getInput());
    this.autoplay = !1;
    this.buffer = null;
    this.detune = 0;
    this.loop = !1;
    this.offset = this.loopEnd = this.loopStart = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = !1;
    this.hasPlaybackControl = !0;
    this.sourceType = "empty";
    this._progress = this._startedAt = 0;
    this.filters = [];
  }
  function Pg(l) {
    Dd.call(this, l);
    this.panner = this.context.createPanner();
    this.panner.panningModel = "HRTF";
    this.panner.connect(this.gain);
  }
  function Qg(l, a) {
    this.analyser = l.context.createAnalyser();
    this.analyser.fftSize = void 0 !== a ? a : 2048;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    l.getOutput().connect(this.analyser);
  }
  function Rg(l, a, b) {
    this.binding = l;
    this.valueSize = b;
    switch(a) {
      case "quaternion":
        l = this._slerp;
        a = this._slerpAdditive;
        var c = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(6 * b);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        a = l = this._select;
        c = this._setAdditiveIdentityOther;
        this.buffer = Array(5 * b);
        break;
      default:
        l = this._lerp, a = this._lerpAdditive, c = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * b);
    }
    this._mixBufferRegion = l;
    this._mixBufferRegionAdditive = a;
    this._setIdentity = c;
    this._origIndex = 3;
    this._addIndex = 4;
    this.referenceCount = this.useCount = this.cumulativeWeightAdditive = this.cumulativeWeight = 0;
  }
  function mi(l, a, b) {
    b = b || Ua.parseTrackName(a);
    this._targetGroup = l;
    this._bindings = l.subscribe_(a, b);
  }
  function Ua(l, a, b) {
    this.path = a;
    this.parsedPath = b || Ua.parseTrackName(a);
    this.node = Ua.findNode(l, this.parsedPath.nodeName) || l;
    this.rootNode = l;
  }
  function ni() {
    this.uuid = na.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    var l = {};
    this._indicesByUUID = l;
    for (var a = 0, b = arguments.length; a !== b; ++a) {
      l[arguments[a].uuid] = a;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    var c = this;
    this.stats = {objects:{get total() {
      return c._objects.length;
    }, get inUse() {
      return this.total - c.nCachedObjects_;
    }}, get bindingsPerObject() {
      return c._bindings.length;
    }};
  }
  function oi(l, a, b, c) {
    this._mixer = l;
    this._clip = a;
    this._localRoot = b || null;
    this.blendMode = c || a.blendMode;
    l = a.tracks;
    a = l.length;
    b = Array(a);
    c = {endingStart:2400, endingEnd:2400};
    for (var e = 0; e !== a; ++e) {
      var w = l[e].createInterpolant(null);
      b[e] = w;
      w.settings = c;
    }
    this._interpolantSettings = c;
    this._interpolants = b;
    this._propertyBindings = Array(a);
    this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null;
    this.loop = 2201;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1;
    this.repetitions = Infinity;
    this.paused = !1;
    this.enabled = !0;
    this.clampWhenFinished = !1;
    this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
  }
  function Sg(l) {
    this._root = l;
    this._initMemoryManager();
    this.time = this._accuIndex = 0;
    this.timeScale = 1;
  }
  function Lf(l, a) {
    "string" === typeof l && (console.warn("THREE.Uniform: Type parameter is no longer needed."), l = a);
    this.value = l;
  }
  function Tg(l, a, b) {
    Sb.call(this, l, a);
    this.meshPerAttribute = b || 1;
  }
  function Ug(l, a, b, c) {
    this.ray = new u(l, a);
    this.near = b || 0;
    this.far = c || Infinity;
    this.camera = null;
    this.layers = new m;
    this.params = {Mesh:{}, Line:{threshold:1}, LOD:{}, Points:{threshold:1}, Sprite:{}};
    Object.defineProperties(this.params, {PointCloud:{get:function() {
      console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
      return this.Points;
    }}});
  }
  function pi(l, a) {
    return l.distance - a.distance;
  }
  function Vg(l, a, b, c) {
    l.layers.test(a.layers) && l.raycast(a, b);
    if (!0 === c) {
      l = l.children;
      c = 0;
      for (var e = l.length; c < e; c++) {
        Vg(l[c], a, b, !0);
      }
    }
  }
  function qi(l, a, b) {
    this.radius = void 0 !== l ? l : 1;
    this.phi = void 0 !== a ? a : 0;
    this.theta = void 0 !== b ? b : 0;
    return this;
  }
  function ri(l, a, b) {
    this.radius = void 0 !== l ? l : 1;
    this.theta = void 0 !== a ? a : 0;
    this.y = void 0 !== b ? b : 0;
    return this;
  }
  function Wg(l, a) {
    this.min = void 0 !== l ? l : new g(Infinity, Infinity);
    this.max = void 0 !== a ? a : new g(-Infinity, -Infinity);
  }
  function Xg(l, a) {
    this.start = void 0 !== l ? l : new f;
    this.end = void 0 !== a ? a : new f;
  }
  function Fe(l) {
    q.call(this);
    this.material = l;
    this.render = function() {
    };
  }
  function Ed(l, a) {
    q.call(this);
    this.light = l;
    this.light.updateMatrixWorld();
    this.matrix = l.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.color = a;
    l = new M;
    a = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (var b = 0, c = 1; 32 > b; b++, c++) {
      var e = b / 32 * Math.PI * 2, w = c / 32 * Math.PI * 2;
      a.push(Math.cos(e), Math.sin(e), 1, Math.cos(w), Math.sin(w), 1);
    }
    l.setAttribute("position", new R(a, 3));
    a = new ya({fog:!1, toneMapped:!1});
    this.cone = new Da(l, a);
    this.add(this.cone);
    this.update();
  }
  function si(l) {
    var a = [];
    l && l.isBone && a.push(l);
    for (var b = 0; b < l.children.length; b++) {
      a.push.apply(a, si(l.children[b]));
    }
    return a;
  }
  function Rc(l) {
    for (var a = si(l), b = new M, c = [], e = [], d = new A(0, 0, 1), m = new A(0, 1, 0), f = 0; f < a.length; f++) {
      var k = a[f];
      k.parent && k.parent.isBone && (c.push(0, 0, 0), c.push(0, 0, 0), e.push(d.r, d.g, d.b), e.push(m.r, m.g, m.b));
    }
    b.setAttribute("position", new R(c, 3));
    b.setAttribute("color", new R(e, 3));
    c = new ya({vertexColors:!0, depthTest:!1, depthWrite:!1, toneMapped:!1, transparent:!0});
    Da.call(this, b, c);
    this.type = "SkeletonHelper";
    this.root = l;
    this.bones = a;
    this.matrix = l.matrixWorld;
    this.matrixAutoUpdate = !1;
  }
  function Fd(l, a, b) {
    this.light = l;
    this.light.updateMatrixWorld();
    this.color = b;
    l = new Gc(a, 4, 2);
    a = new L({wireframe:!0, fog:!1, toneMapped:!1});
    V.call(this, l, a);
    this.type = "PointLightHelper";
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.update();
  }
  function Gd(l, a, b) {
    q.call(this);
    this.light = l;
    this.light.updateMatrixWorld();
    this.matrix = l.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.color = b;
    l = new Dc(a);
    l.rotateY(.5 * Math.PI);
    this.material = new L({wireframe:!0, fog:!1, toneMapped:!1});
    void 0 === this.color && (this.material.vertexColors = !0);
    a = l.getAttribute("position");
    a = new Float32Array(3 * a.count);
    l.setAttribute("color", new K(a, 3));
    this.add(new V(l, this.material));
    this.update();
  }
  function Mf(l, a, b, c) {
    l = l || 10;
    a = a || 10;
    b = new A(void 0 !== b ? b : 4473924);
    c = new A(void 0 !== c ? c : 8947848);
    var e = a / 2, d = l / a, w = l / 2;
    l = [];
    for (var m = [], f = 0, k = 0, h = -w; f <= a; f++, h += d) {
      l.push(-w, 0, h, w, 0, h);
      l.push(h, 0, -w, h, 0, w);
      var g = f === e ? b : c;
      g.toArray(m, k);
      k += 3;
      g.toArray(m, k);
      k += 3;
      g.toArray(m, k);
      k += 3;
      g.toArray(m, k);
      k += 3;
    }
    a = new M;
    a.setAttribute("position", new R(l, 3));
    a.setAttribute("color", new R(m, 3));
    b = new ya({vertexColors:!0, toneMapped:!1});
    Da.call(this, a, b);
    this.type = "GridHelper";
  }
  function Nf(l, a, b, c, e, d) {
    l = l || 10;
    a = a || 16;
    b = b || 8;
    c = c || 64;
    e = new A(void 0 !== e ? e : 4473924);
    d = new A(void 0 !== d ? d : 8947848);
    var w = [], m = [], f;
    for (f = 0; f <= a; f++) {
      var k = f / a * 2 * Math.PI;
      var h = Math.sin(k) * l;
      k = Math.cos(k) * l;
      w.push(0, 0, 0);
      w.push(h, 0, k);
      var g = f & 1 ? e : d;
      m.push(g.r, g.g, g.b);
      m.push(g.r, g.g, g.b);
    }
    for (f = 0; f <= b; f++) {
      g = f & 1 ? e : d;
      var r = l - l / b * f;
      for (a = 0; a < c; a++) {
        k = a / c * 2 * Math.PI, h = Math.sin(k) * r, k = Math.cos(k) * r, w.push(h, 0, k), m.push(g.r, g.g, g.b), k = (a + 1) / c * 2 * Math.PI, h = Math.sin(k) * r, k = Math.cos(k) * r, w.push(h, 0, k), m.push(g.r, g.g, g.b);
      }
    }
    l = new M;
    l.setAttribute("position", new R(w, 3));
    l.setAttribute("color", new R(m, 3));
    w = new ya({vertexColors:!0, toneMapped:!1});
    Da.call(this, l, w);
    this.type = "PolarGridHelper";
  }
  function Hd(l, a, b) {
    q.call(this);
    this.light = l;
    this.light.updateMatrixWorld();
    this.matrix = l.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.color = b;
    void 0 === a && (a = 1);
    l = new M;
    l.setAttribute("position", new R([-a, a, 0, a, a, 0, a, -a, 0, -a, -a, 0, -a, a, 0], 3));
    a = new ya({fog:!1, toneMapped:!1});
    this.lightPlane = new cb(l, a);
    this.add(this.lightPlane);
    l = new M;
    l.setAttribute("position", new R([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new cb(l, a);
    this.add(this.targetLine);
    this.update();
  }
  function Ge(l) {
    function a(l, a, c) {
      b(l, c);
      b(a, c);
    }
    function b(l, a) {
      d.push(0, 0, 0);
      m.push(a.r, a.g, a.b);
      void 0 === f[l] && (f[l] = []);
      f[l].push(d.length / 3 - 1);
    }
    var c = new M, e = new ya({color:16777215, vertexColors:!0, toneMapped:!1}), d = [], m = [], f = {}, k = new A(16755200), h = new A(16711680), g = new A(43775), r = new A(16777215), n = new A(3355443);
    a("n1", "n2", k);
    a("n2", "n4", k);
    a("n4", "n3", k);
    a("n3", "n1", k);
    a("f1", "f2", k);
    a("f2", "f4", k);
    a("f4", "f3", k);
    a("f3", "f1", k);
    a("n1", "f1", k);
    a("n2", "f2", k);
    a("n3", "f3", k);
    a("n4", "f4", k);
    a("p", "n1", h);
    a("p", "n2", h);
    a("p", "n3", h);
    a("p", "n4", h);
    a("u1", "u2", g);
    a("u2", "u3", g);
    a("u3", "u1", g);
    a("c", "t", r);
    a("p", "c", n);
    a("cn1", "cn2", n);
    a("cn3", "cn4", n);
    a("cf1", "cf2", n);
    a("cf3", "cf4", n);
    c.setAttribute("position", new R(d, 3));
    c.setAttribute("color", new R(m, 3));
    Da.call(this, c, e);
    this.type = "CameraHelper";
    this.camera = l;
    this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix();
    this.matrix = l.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.pointMap = f;
    this.update();
  }
  function Ha(l, a, b, c, e, d, m) {
    Of.set(e, d, m).unproject(c);
    l = a[l];
    if (void 0 !== l) {
      for (b = b.getAttribute("position"), a = 0, c = l.length; a < c; a++) {
        b.setXYZ(l[a], Of.x, Of.y, Of.z);
      }
    }
  }
  function Xb(l, a) {
    this.object = l;
    void 0 === a && (a = 16776960);
    l = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var b = new Float32Array(24), c = new M;
    c.setIndex(new K(l, 1));
    c.setAttribute("position", new K(b, 3));
    Da.call(this, c, new ya({color:a, toneMapped:!1}));
    this.type = "BoxHelper";
    this.matrixAutoUpdate = !1;
    this.update();
  }
  function He(l, a) {
    this.type = "Box3Helper";
    this.box = l;
    a = a || 16776960;
    l = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var b = new M;
    b.setIndex(new K(l, 1));
    b.setAttribute("position", new R([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3));
    Da.call(this, b, new ya({color:a, toneMapped:!1}));
    this.type = "Box3Helper";
    this.geometry.computeBoundingSphere();
  }
  function Ie(l, a, b) {
    this.plane = l;
    this.size = void 0 === a ? 1 : a;
    l = void 0 !== b ? b : 16776960;
    a = new M;
    a.setAttribute("position", new R([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3));
    a.computeBoundingSphere();
    cb.call(this, a, new ya({color:l, toneMapped:!1}));
    this.type = "PlaneHelper";
    a = new M;
    a.setAttribute("position", new R([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3));
    a.computeBoundingSphere();
    this.add(new V(a, new L({color:l, opacity:.2, transparent:!0, depthWrite:!1, toneMapped:!1})));
  }
  function Yb(a, b, c, e, d, m) {
    q.call(this);
    this.type = "ArrowHelper";
    void 0 === a && (a = new f(0, 0, 1));
    void 0 === b && (b = new f(0, 0, 0));
    void 0 === c && (c = 1);
    void 0 === e && (e = 16776960);
    void 0 === d && (d = .2 * c);
    void 0 === m && (m = .2 * d);
    void 0 === Pf && (Pf = new M, Pf.setAttribute("position", new R([0, 0, 0, 0, 1, 0], 3)), Yg = new Ub(0, .5, 1, 5, 1), Yg.translate(0, -.5, 0));
    this.position.copy(b);
    this.line = new cb(Pf, new ya({color:e, toneMapped:!1}));
    this.line.matrixAutoUpdate = !1;
    this.add(this.line);
    this.cone = new V(Yg, new L({color:e, toneMapped:!1}));
    this.cone.matrixAutoUpdate = !1;
    this.add(this.cone);
    this.setDirection(a);
    this.setLength(c, d, m);
  }
  function Je(a) {
    a = a || 1;
    var l = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a];
    a = new M;
    a.setAttribute("position", new R(l, 3));
    a.setAttribute("color", new R([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
    l = new ya({vertexColors:!0, toneMapped:!1});
    Da.call(this, a, l);
    this.type = "AxesHelper";
  }
  function Zg(a) {
    this._renderer = a;
    this._pingPongRenderTarget = null;
    a = new Float32Array(20);
    var l = new f(0, 1, 0);
    a = new Vb({defines:{n:20}, uniforms:{envMap:{value:null}, samples:{value:1}, weights:{value:a}, latitudinal:{value:!1}, dTheta:{value:0}, mipInt:{value:0}, poleAxis:{value:l}, inputEncoding:{value:Lb[3E3]}, outputEncoding:{value:Lb[3E3]}}, vertexShader:$g(), fragmentShader:"\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n" + 
    ah() + "\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t", 
    blending:0, depthTest:!1, depthWrite:!1});
    a.type = "SphericalGaussianBlur";
    this._blurMaterial = a;
    this._cubemapShader = this._equirectShader = null;
    this._compileMaterial(this._blurMaterial);
  }
  function ti(a) {
    a = new c(3 * Mb, 3 * Mb, a);
    a.texture.mapping = 306;
    a.texture.name = "PMREM.cubeUv";
    a.scissorTest = !0;
    return a;
  }
  function bh(a, b, c, e, d) {
    a.viewport.set(b, c, e, d);
    a.scissor.set(b, c, e, d);
  }
  function ui() {
    var a = new g(1, 1);
    a = new Vb({uniforms:{envMap:{value:null}, texelSize:{value:a}, inputEncoding:{value:Lb[3E3]}, outputEncoding:{value:Lb[3E3]}}, vertexShader:$g(), fragmentShader:"\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n" + ah() + "\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv;\n\tuv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n\tuv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t", 
    blending:0, depthTest:!1, depthWrite:!1});
    a.type = "EquirectangularToCubeUV";
    return a;
  }
  function vi() {
    var a = new Vb({uniforms:{envMap:{value:null}, inputEncoding:{value:Lb[3E3]}, outputEncoding:{value:Lb[3E3]}}, vertexShader:$g(), fragmentShader:"\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n" + ah() + "\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t", 
    blending:0, depthTest:!1, depthWrite:!1});
    a.type = "CubemapToCubeUV";
    return a;
  }
  function $g() {
    return "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t";
  }
  function ah() {
    return "\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t";
  }
  function wi(a) {
    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    Ta.call(this, a);
    this.type = "catmullrom";
    this.closed = !0;
  }
  function xi(a) {
    console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    Ta.call(this, a);
    this.type = "catmullrom";
  }
  function ch(a) {
    console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
    Ta.call(this, a);
    this.type = "catmullrom";
  }
  void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52));
  void 0 === Number.isInteger && (Number.isInteger = function(a) {
    return "number" === typeof a && isFinite(a) && Math.floor(a) === a;
  });
  void 0 === Math.sign && (Math.sign = function(a) {
    return 0 > a ? -1 : 0 < a ? 1 : +a;
  });
  !1 === "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {get:function() {
    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
  }});
  void 0 === Object.assign && (Object.assign = function(a) {
    if (void 0 === a || null === a) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    for (var l = Object(a), b = 1; b < arguments.length; b++) {
      var c = arguments[b];
      if (void 0 !== c && null !== c) {
        for (var e in c) {
          Object.prototype.hasOwnProperty.call(c, e) && (l[e] = c[e]);
        }
      }
    }
    return l;
  });
  Object.assign(d.prototype, {addEventListener:function(a, b) {
    void 0 === this._listeners && (this._listeners = {});
    var l = this._listeners;
    void 0 === l[a] && (l[a] = []);
    -1 === l[a].indexOf(b) && l[a].push(b);
  }, hasEventListener:function(a, b) {
    if (void 0 === this._listeners) {
      return !1;
    }
    var l = this._listeners;
    return void 0 !== l[a] && -1 !== l[a].indexOf(b);
  }, removeEventListener:function(a, b) {
    void 0 !== this._listeners && (a = this._listeners[a], void 0 !== a && (b = a.indexOf(b), -1 !== b && a.splice(b, 1)));
  }, dispatchEvent:function(a) {
    if (void 0 !== this._listeners) {
      var l = this._listeners[a.type];
      if (void 0 !== l) {
        a.target = this;
        l = l.slice(0);
        for (var b = 0, c = l.length; b < c; b++) {
          l[b].call(this, a);
        }
      }
    }
  }});
  for (var Ra = [], Ke = 0; 256 > Ke; Ke++) {
    Ra[Ke] = (16 > Ke ? "0" : "") + Ke.toString(16);
  }
  var na = {DEG2RAD:Math.PI / 180, RAD2DEG:180 / Math.PI, generateUUID:function() {
    var a = 4294967295 * Math.random() | 0, b = 4294967295 * Math.random() | 0, c = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0;
    return (Ra[a & 255] + Ra[a >> 8 & 255] + Ra[a >> 16 & 255] + Ra[a >> 24 & 255] + "-" + Ra[b & 255] + Ra[b >> 8 & 255] + "-" + Ra[b >> 16 & 15 | 64] + Ra[b >> 24 & 255] + "-" + Ra[c & 63 | 128] + Ra[c >> 8 & 255] + "-" + Ra[c >> 16 & 255] + Ra[c >> 24 & 255] + Ra[e & 255] + Ra[e >> 8 & 255] + Ra[e >> 16 & 255] + Ra[e >> 24 & 255]).toUpperCase();
  }, clamp:function(a, b, c) {
    return Math.max(b, Math.min(c, a));
  }, euclideanModulo:function(a, b) {
    return (a % b + b) % b;
  }, mapLinear:function(a, b, c, e, d) {
    return e + (a - b) * (d - e) / (c - b);
  }, lerp:function(a, b, c) {
    return (1 - c) * a + c * b;
  }, smoothstep:function(a, b, c) {
    if (a <= b) {
      return 0;
    }
    if (a >= c) {
      return 1;
    }
    a = (a - b) / (c - b);
    return a * a * (3 - 2 * a);
  }, smootherstep:function(a, b, c) {
    if (a <= b) {
      return 0;
    }
    if (a >= c) {
      return 1;
    }
    a = (a - b) / (c - b);
    return a * a * a * (a * (6 * a - 15) + 10);
  }, randInt:function(a, b) {
    return a + Math.floor(Math.random() * (b - a + 1));
  }, randFloat:function(a, b) {
    return a + Math.random() * (b - a);
  }, randFloatSpread:function(a) {
    return a * (.5 - Math.random());
  }, degToRad:function(a) {
    return a * na.DEG2RAD;
  }, radToDeg:function(a) {
    return a * na.RAD2DEG;
  }, isPowerOfTwo:function(a) {
    return 0 === (a & a - 1) && 0 !== a;
  }, ceilPowerOfTwo:function(a) {
    return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));
  }, floorPowerOfTwo:function(a) {
    return Math.pow(2, Math.floor(Math.log(a) / Math.LN2));
  }, setQuaternionFromProperEuler:function(a, b, c, e, d) {
    var l = Math.cos, m = Math.sin, w = l(c / 2);
    c = m(c / 2);
    var f = l((b + e) / 2), k = m((b + e) / 2), h = l((b - e) / 2), g = m((b - e) / 2);
    l = l((e - b) / 2);
    b = m((e - b) / 2);
    switch(d) {
      case "XYX":
        a.set(w * k, c * h, c * g, w * f);
        break;
      case "YZY":
        a.set(c * g, w * k, c * h, w * f);
        break;
      case "ZXZ":
        a.set(c * h, c * g, w * k, w * f);
        break;
      case "XZX":
        a.set(w * k, c * b, c * l, w * f);
        break;
      case "YXY":
        a.set(c * l, w * k, c * b, w * f);
        break;
      case "ZYZ":
        a.set(c * b, c * l, w * k, w * f);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + d);
    }
  }};
  Object.defineProperties(g.prototype, {width:{get:function() {
    return this.x;
  }, set:function(a) {
    this.x = a;
  }}, height:{get:function() {
    return this.y;
  }, set:function(a) {
    this.y = a;
  }}});
  Object.assign(g.prototype, {isVector2:!0, set:function(a, b) {
    this.x = a;
    this.y = b;
    return this;
  }, setScalar:function(a) {
    this.y = this.x = a;
    return this;
  }, setX:function(a) {
    this.x = a;
    return this;
  }, setY:function(a) {
    this.y = a;
    return this;
  }, setComponent:function(a, b) {
    switch(a) {
      case 0:
        this.x = b;
        break;
      case 1:
        this.y = b;
        break;
      default:
        throw Error("index is out of range: " + a);
    }
    return this;
  }, getComponent:function(a) {
    switch(a) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw Error("index is out of range: " + a);
    }
  }, clone:function() {
    return new this.constructor(this.x, this.y);
  }, copy:function(a) {
    this.x = a.x;
    this.y = a.y;
    return this;
  }, add:function(a, b) {
    if (void 0 !== b) {
      return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
    }
    this.x += a.x;
    this.y += a.y;
    return this;
  }, addScalar:function(a) {
    this.x += a;
    this.y += a;
    return this;
  }, addVectors:function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }, addScaledVector:function(a, b) {
    this.x += a.x * b;
    this.y += a.y * b;
    return this;
  }, sub:function(a, b) {
    if (void 0 !== b) {
      return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
    }
    this.x -= a.x;
    this.y -= a.y;
    return this;
  }, subScalar:function(a) {
    this.x -= a;
    this.y -= a;
    return this;
  }, subVectors:function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }, multiply:function(a) {
    this.x *= a.x;
    this.y *= a.y;
    return this;
  }, multiplyScalar:function(a) {
    this.x *= a;
    this.y *= a;
    return this;
  }, divide:function(a) {
    this.x /= a.x;
    this.y /= a.y;
    return this;
  }, divideScalar:function(a) {
    return this.multiplyScalar(1 / a);
  }, applyMatrix3:function(a) {
    var l = this.x, b = this.y;
    a = a.elements;
    this.x = a[0] * l + a[3] * b + a[6];
    this.y = a[1] * l + a[4] * b + a[7];
    return this;
  }, min:function(a) {
    this.x = Math.min(this.x, a.x);
    this.y = Math.min(this.y, a.y);
    return this;
  }, max:function(a) {
    this.x = Math.max(this.x, a.x);
    this.y = Math.max(this.y, a.y);
    return this;
  }, clamp:function(a, b) {
    this.x = Math.max(a.x, Math.min(b.x, this.x));
    this.y = Math.max(a.y, Math.min(b.y, this.y));
    return this;
  }, clampScalar:function(a, b) {
    this.x = Math.max(a, Math.min(b, this.x));
    this.y = Math.max(a, Math.min(b, this.y));
    return this;
  }, clampLength:function(a, b) {
    var l = this.length();
    return this.divideScalar(l || 1).multiplyScalar(Math.max(a, Math.min(b, l)));
  }, floor:function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }, ceil:function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }, round:function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }, roundToZero:function() {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }, negate:function() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }, dot:function(a) {
    return this.x * a.x + this.y * a.y;
  }, cross:function(a) {
    return this.x * a.y - this.y * a.x;
  }, lengthSq:function() {
    return this.x * this.x + this.y * this.y;
  }, length:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, manhattanLength:function() {
    return Math.abs(this.x) + Math.abs(this.y);
  }, normalize:function() {
    return this.divideScalar(this.length() || 1);
  }, angle:function() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }, distanceTo:function(a) {
    return Math.sqrt(this.distanceToSquared(a));
  }, distanceToSquared:function(a) {
    var l = this.x - a.x;
    a = this.y - a.y;
    return l * l + a * a;
  }, manhattanDistanceTo:function(a) {
    return Math.abs(this.x - a.x) + Math.abs(this.y - a.y);
  }, setLength:function(a) {
    return this.normalize().multiplyScalar(a);
  }, lerp:function(a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    return this;
  }, lerpVectors:function(a, b, c) {
    return this.subVectors(b, a).multiplyScalar(c).add(a);
  }, equals:function(a) {
    return a.x === this.x && a.y === this.y;
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    this.x = a[b];
    this.y = a[b + 1];
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this.x;
    a[b + 1] = this.y;
    return a;
  }, fromBufferAttribute:function(a, b, c) {
    void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    this.x = a.getX(b);
    this.y = a.getY(b);
    return this;
  }, rotateAround:function(a, b) {
    var l = Math.cos(b);
    b = Math.sin(b);
    var c = this.x - a.x, e = this.y - a.y;
    this.x = c * l - e * b + a.x;
    this.y = c * b + e * l + a.y;
    return this;
  }, random:function() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }});
  Object.assign(h.prototype, {isMatrix3:!0, set:function(a, b, c, e, d, m, f, k, h) {
    var l = this.elements;
    l[0] = a;
    l[1] = e;
    l[2] = f;
    l[3] = b;
    l[4] = d;
    l[5] = k;
    l[6] = c;
    l[7] = m;
    l[8] = h;
    return this;
  }, identity:function() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }, clone:function() {
    return (new this.constructor).fromArray(this.elements);
  }, copy:function(a) {
    var l = this.elements;
    a = a.elements;
    l[0] = a[0];
    l[1] = a[1];
    l[2] = a[2];
    l[3] = a[3];
    l[4] = a[4];
    l[5] = a[5];
    l[6] = a[6];
    l[7] = a[7];
    l[8] = a[8];
    return this;
  }, extractBasis:function(a, b, c) {
    a.setFromMatrix3Column(this, 0);
    b.setFromMatrix3Column(this, 1);
    c.setFromMatrix3Column(this, 2);
    return this;
  }, setFromMatrix4:function(a) {
    a = a.elements;
    this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]);
    return this;
  }, multiply:function(a) {
    return this.multiplyMatrices(this, a);
  }, premultiply:function(a) {
    return this.multiplyMatrices(a, this);
  }, multiplyMatrices:function(a, b) {
    var l = a.elements, c = b.elements;
    b = this.elements;
    a = l[0];
    var e = l[3], d = l[6], m = l[1], w = l[4], f = l[7], k = l[2], h = l[5];
    l = l[8];
    var g = c[0], r = c[3], n = c[6], q = c[1], p = c[4], u = c[7], t = c[2], y = c[5];
    c = c[8];
    b[0] = a * g + e * q + d * t;
    b[3] = a * r + e * p + d * y;
    b[6] = a * n + e * u + d * c;
    b[1] = m * g + w * q + f * t;
    b[4] = m * r + w * p + f * y;
    b[7] = m * n + w * u + f * c;
    b[2] = k * g + h * q + l * t;
    b[5] = k * r + h * p + l * y;
    b[8] = k * n + h * u + l * c;
    return this;
  }, multiplyScalar:function(a) {
    var l = this.elements;
    l[0] *= a;
    l[3] *= a;
    l[6] *= a;
    l[1] *= a;
    l[4] *= a;
    l[7] *= a;
    l[2] *= a;
    l[5] *= a;
    l[8] *= a;
    return this;
  }, determinant:function() {
    var a = this.elements, b = a[0], c = a[1], e = a[2], d = a[3], m = a[4], f = a[5], k = a[6], h = a[7];
    a = a[8];
    return b * m * a - b * f * h - c * d * a + c * f * k + e * d * h - e * m * k;
  }, getInverse:function(a, b) {
    void 0 !== b && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
    var l = a.elements;
    a = this.elements;
    b = l[0];
    var c = l[1], e = l[2], d = l[3], m = l[4], w = l[5], f = l[6], k = l[7];
    l = l[8];
    var h = l * m - w * k, g = w * f - l * d, r = k * d - m * f, n = b * h + c * g + e * r;
    if (0 === n) {
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    n = 1 / n;
    a[0] = h * n;
    a[1] = (e * k - l * c) * n;
    a[2] = (w * c - e * m) * n;
    a[3] = g * n;
    a[4] = (l * b - e * f) * n;
    a[5] = (e * d - w * b) * n;
    a[6] = r * n;
    a[7] = (c * f - k * b) * n;
    a[8] = (m * b - c * d) * n;
    return this;
  }, transpose:function() {
    var a = this.elements;
    var b = a[1];
    a[1] = a[3];
    a[3] = b;
    b = a[2];
    a[2] = a[6];
    a[6] = b;
    b = a[5];
    a[5] = a[7];
    a[7] = b;
    return this;
  }, getNormalMatrix:function(a) {
    return this.setFromMatrix4(a).getInverse(this).transpose();
  }, transposeIntoArray:function(a) {
    var l = this.elements;
    a[0] = l[0];
    a[1] = l[3];
    a[2] = l[6];
    a[3] = l[1];
    a[4] = l[4];
    a[5] = l[7];
    a[6] = l[2];
    a[7] = l[5];
    a[8] = l[8];
    return this;
  }, setUvTransform:function(a, b, c, e, d, m, f) {
    var l = Math.cos(d);
    d = Math.sin(d);
    this.set(c * l, c * d, -c * (l * m + d * f) + m + a, -e * d, e * l, -e * (-d * m + l * f) + f + b, 0, 0, 1);
  }, scale:function(a, b) {
    var l = this.elements;
    l[0] *= a;
    l[3] *= a;
    l[6] *= a;
    l[1] *= b;
    l[4] *= b;
    l[7] *= b;
    return this;
  }, rotate:function(a) {
    var l = Math.cos(a);
    a = Math.sin(a);
    var b = this.elements, c = b[0], e = b[3], d = b[6], m = b[1], f = b[4], k = b[7];
    b[0] = l * c + a * m;
    b[3] = l * e + a * f;
    b[6] = l * d + a * k;
    b[1] = -a * c + l * m;
    b[4] = -a * e + l * f;
    b[7] = -a * d + l * k;
    return this;
  }, translate:function(a, b) {
    var l = this.elements;
    l[0] += a * l[2];
    l[3] += a * l[5];
    l[6] += a * l[8];
    l[1] += b * l[2];
    l[4] += b * l[5];
    l[7] += b * l[8];
    return this;
  }, equals:function(a) {
    var l = this.elements;
    a = a.elements;
    for (var b = 0; 9 > b; b++) {
      if (l[b] !== a[b]) {
        return !1;
      }
    }
    return !0;
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    for (var l = 0; 9 > l; l++) {
      this.elements[l] = a[l + b];
    }
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    var l = this.elements;
    a[b] = l[0];
    a[b + 1] = l[1];
    a[b + 2] = l[2];
    a[b + 3] = l[3];
    a[b + 4] = l[4];
    a[b + 5] = l[5];
    a[b + 6] = l[6];
    a[b + 7] = l[7];
    a[b + 8] = l[8];
    return a;
  }});
  var Id, rc = {getDataURL:function(a) {
    if ("undefined" == typeof HTMLCanvasElement) {
      return a.src;
    }
    if (!(a instanceof HTMLCanvasElement)) {
      void 0 === Id && (Id = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"));
      Id.width = a.width;
      Id.height = a.height;
      var l = Id.getContext("2d");
      a instanceof ImageData ? l.putImageData(a, 0, 0) : l.drawImage(a, 0, 0, a.width, a.height);
      a = Id;
    }
    return 2048 < a.width || 2048 < a.height ? a.toDataURL("image/jpeg", .6) : a.toDataURL("image/png");
  }}, jj = 0;
  e.DEFAULT_IMAGE = void 0;
  e.DEFAULT_MAPPING = 300;
  e.prototype = Object.assign(Object.create(d.prototype), {constructor:e, isTexture:!0, updateMatrix:function() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.name = a.name;
    this.image = a.image;
    this.mipmaps = a.mipmaps.slice(0);
    this.mapping = a.mapping;
    this.wrapS = a.wrapS;
    this.wrapT = a.wrapT;
    this.magFilter = a.magFilter;
    this.minFilter = a.minFilter;
    this.anisotropy = a.anisotropy;
    this.format = a.format;
    this.internalFormat = a.internalFormat;
    this.type = a.type;
    this.offset.copy(a.offset);
    this.repeat.copy(a.repeat);
    this.center.copy(a.center);
    this.rotation = a.rotation;
    this.matrixAutoUpdate = a.matrixAutoUpdate;
    this.matrix.copy(a.matrix);
    this.generateMipmaps = a.generateMipmaps;
    this.premultiplyAlpha = a.premultiplyAlpha;
    this.flipY = a.flipY;
    this.unpackAlignment = a.unpackAlignment;
    this.encoding = a.encoding;
    return this;
  }, toJSON:function(a) {
    var l = void 0 === a || "string" === typeof a;
    if (!l && void 0 !== a.textures[this.uuid]) {
      return a.textures[this.uuid];
    }
    var b = {metadata:{version:4.5, type:"Texture", generator:"Texture.toJSON"}, uuid:this.uuid, name:this.name, mapping:this.mapping, repeat:[this.repeat.x, this.repeat.y], offset:[this.offset.x, this.offset.y], center:[this.center.x, this.center.y], rotation:this.rotation, wrap:[this.wrapS, this.wrapT], format:this.format, type:this.type, encoding:this.encoding, minFilter:this.minFilter, magFilter:this.magFilter, anisotropy:this.anisotropy, flipY:this.flipY, premultiplyAlpha:this.premultiplyAlpha, 
    unpackAlignment:this.unpackAlignment};
    if (void 0 !== this.image) {
      var c = this.image;
      void 0 === c.uuid && (c.uuid = na.generateUUID());
      if (!l && void 0 === a.images[c.uuid]) {
        if (Array.isArray(c)) {
          var e = [];
          for (var d = 0, m = c.length; d < m; d++) {
            e.push(rc.getDataURL(c[d]));
          }
        } else {
          e = rc.getDataURL(c);
        }
        a.images[c.uuid] = {uuid:c.uuid, url:e};
      }
      b.image = c.uuid;
    }
    l || (a.textures[this.uuid] = b);
    return b;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }, transformUv:function(a) {
    if (300 !== this.mapping) {
      return a;
    }
    a.applyMatrix3(this.matrix);
    if (0 > a.x || 1 < a.x) {
      switch(this.wrapS) {
        case 1E3:
          a.x -= Math.floor(a.x);
          break;
        case 1001:
          a.x = 0 > a.x ? 0 : 1;
          break;
        case 1002:
          a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x);
      }
    }
    if (0 > a.y || 1 < a.y) {
      switch(this.wrapT) {
        case 1E3:
          a.y -= Math.floor(a.y);
          break;
        case 1001:
          a.y = 0 > a.y ? 0 : 1;
          break;
        case 1002:
          a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y);
      }
    }
    this.flipY && (a.y = 1 - a.y);
    return a;
  }});
  Object.defineProperty(e.prototype, "needsUpdate", {set:function(a) {
    !0 === a && this.version++;
  }});
  Object.defineProperties(k.prototype, {width:{get:function() {
    return this.z;
  }, set:function(a) {
    this.z = a;
  }}, height:{get:function() {
    return this.w;
  }, set:function(a) {
    this.w = a;
  }}});
  Object.assign(k.prototype, {isVector4:!0, set:function(a, b, c, e) {
    this.x = a;
    this.y = b;
    this.z = c;
    this.w = e;
    return this;
  }, setScalar:function(a) {
    this.w = this.z = this.y = this.x = a;
    return this;
  }, setX:function(a) {
    this.x = a;
    return this;
  }, setY:function(a) {
    this.y = a;
    return this;
  }, setZ:function(a) {
    this.z = a;
    return this;
  }, setW:function(a) {
    this.w = a;
    return this;
  }, setComponent:function(a, b) {
    switch(a) {
      case 0:
        this.x = b;
        break;
      case 1:
        this.y = b;
        break;
      case 2:
        this.z = b;
        break;
      case 3:
        this.w = b;
        break;
      default:
        throw Error("index is out of range: " + a);
    }
    return this;
  }, getComponent:function(a) {
    switch(a) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw Error("index is out of range: " + a);
    }
  }, clone:function() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }, copy:function(a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    this.w = void 0 !== a.w ? a.w : 1;
    return this;
  }, add:function(a, b) {
    if (void 0 !== b) {
      return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
    }
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    this.w += a.w;
    return this;
  }, addScalar:function(a) {
    this.x += a;
    this.y += a;
    this.z += a;
    this.w += a;
    return this;
  }, addVectors:function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }, addScaledVector:function(a, b) {
    this.x += a.x * b;
    this.y += a.y * b;
    this.z += a.z * b;
    this.w += a.w * b;
    return this;
  }, sub:function(a, b) {
    if (void 0 !== b) {
      return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
    }
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    this.w -= a.w;
    return this;
  }, subScalar:function(a) {
    this.x -= a;
    this.y -= a;
    this.z -= a;
    this.w -= a;
    return this;
  }, subVectors:function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }, multiplyScalar:function(a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    this.w *= a;
    return this;
  }, applyMatrix4:function(a) {
    var l = this.x, b = this.y, c = this.z, e = this.w;
    a = a.elements;
    this.x = a[0] * l + a[4] * b + a[8] * c + a[12] * e;
    this.y = a[1] * l + a[5] * b + a[9] * c + a[13] * e;
    this.z = a[2] * l + a[6] * b + a[10] * c + a[14] * e;
    this.w = a[3] * l + a[7] * b + a[11] * c + a[15] * e;
    return this;
  }, divideScalar:function(a) {
    return this.multiplyScalar(1 / a);
  }, setAxisAngleFromQuaternion:function(a) {
    this.w = 2 * Math.acos(a.w);
    var l = Math.sqrt(1 - a.w * a.w);
    1E-4 > l ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / l, this.y = a.y / l, this.z = a.z / l);
    return this;
  }, setAxisAngleFromRotationMatrix:function(a) {
    a = a.elements;
    var l = a[0];
    var b = a[4];
    var c = a[8], e = a[1], d = a[5], m = a[9];
    var f = a[2];
    var k = a[6];
    var h = a[10];
    if (.01 > Math.abs(b - e) && .01 > Math.abs(c - f) && .01 > Math.abs(m - k)) {
      if (.1 > Math.abs(b + e) && .1 > Math.abs(c + f) && .1 > Math.abs(m + k) && .1 > Math.abs(l + d + h - 3)) {
        return this.set(1, 0, 0, 0), this;
      }
      a = Math.PI;
      l = (l + 1) / 2;
      d = (d + 1) / 2;
      h = (h + 1) / 2;
      b = (b + e) / 4;
      c = (c + f) / 4;
      m = (m + k) / 4;
      l > d && l > h ? .01 > l ? (k = 0, b = f = .707106781) : (k = Math.sqrt(l), f = b / k, b = c / k) : d > h ? .01 > d ? (k = .707106781, f = 0, b = .707106781) : (f = Math.sqrt(d), k = b / f, b = m / f) : .01 > h ? (f = k = .707106781, b = 0) : (b = Math.sqrt(h), k = c / b, f = m / b);
      this.set(k, f, b, a);
      return this;
    }
    a = Math.sqrt((k - m) * (k - m) + (c - f) * (c - f) + (e - b) * (e - b));
    .001 > Math.abs(a) && (a = 1);
    this.x = (k - m) / a;
    this.y = (c - f) / a;
    this.z = (e - b) / a;
    this.w = Math.acos((l + d + h - 1) / 2);
    return this;
  }, min:function(a) {
    this.x = Math.min(this.x, a.x);
    this.y = Math.min(this.y, a.y);
    this.z = Math.min(this.z, a.z);
    this.w = Math.min(this.w, a.w);
    return this;
  }, max:function(a) {
    this.x = Math.max(this.x, a.x);
    this.y = Math.max(this.y, a.y);
    this.z = Math.max(this.z, a.z);
    this.w = Math.max(this.w, a.w);
    return this;
  }, clamp:function(a, b) {
    this.x = Math.max(a.x, Math.min(b.x, this.x));
    this.y = Math.max(a.y, Math.min(b.y, this.y));
    this.z = Math.max(a.z, Math.min(b.z, this.z));
    this.w = Math.max(a.w, Math.min(b.w, this.w));
    return this;
  }, clampScalar:function(a, b) {
    this.x = Math.max(a, Math.min(b, this.x));
    this.y = Math.max(a, Math.min(b, this.y));
    this.z = Math.max(a, Math.min(b, this.z));
    this.w = Math.max(a, Math.min(b, this.w));
    return this;
  }, clampLength:function(a, b) {
    var l = this.length();
    return this.divideScalar(l || 1).multiplyScalar(Math.max(a, Math.min(b, l)));
  }, floor:function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }, ceil:function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }, round:function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }, roundToZero:function() {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }, negate:function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }, dot:function(a) {
    return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
  }, lengthSq:function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }, length:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }, manhattanLength:function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }, normalize:function() {
    return this.divideScalar(this.length() || 1);
  }, setLength:function(a) {
    return this.normalize().multiplyScalar(a);
  }, lerp:function(a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    this.z += (a.z - this.z) * b;
    this.w += (a.w - this.w) * b;
    return this;
  }, lerpVectors:function(a, b, c) {
    return this.subVectors(b, a).multiplyScalar(c).add(a);
  }, equals:function(a) {
    return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    this.x = a[b];
    this.y = a[b + 1];
    this.z = a[b + 2];
    this.w = a[b + 3];
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this.x;
    a[b + 1] = this.y;
    a[b + 2] = this.z;
    a[b + 3] = this.w;
    return a;
  }, fromBufferAttribute:function(a, b, c) {
    void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    this.x = a.getX(b);
    this.y = a.getY(b);
    this.z = a.getZ(b);
    this.w = a.getW(b);
    return this;
  }, random:function() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }});
  c.prototype = Object.assign(Object.create(d.prototype), {constructor:c, isWebGLRenderTarget:!0, setSize:function(a, b) {
    if (this.width !== a || this.height !== b) {
      this.width = a, this.height = b, this.texture.image.width = a, this.texture.image.height = b, this.dispose();
    }
    this.viewport.set(0, 0, a, b);
    this.scissor.set(0, 0, a, b);
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.width = a.width;
    this.height = a.height;
    this.viewport.copy(a.viewport);
    this.texture = a.texture.clone();
    this.depthBuffer = a.depthBuffer;
    this.stencilBuffer = a.stencilBuffer;
    this.depthTexture = a.depthTexture;
    return this;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }});
  p.prototype = Object.assign(Object.create(c.prototype), {constructor:p, isWebGLMultisampleRenderTarget:!0, copy:function(a) {
    c.prototype.copy.call(this, a);
    this.samples = a.samples;
    return this;
  }});
  Object.assign(t, {slerp:function(a, b, c, e) {
    return c.copy(a).slerp(b, e);
  }, slerpFlat:function(a, b, c, e, d, m, f) {
    var l = c[e + 0], w = c[e + 1], k = c[e + 2];
    c = c[e + 3];
    e = d[m + 0];
    var h = d[m + 1], g = d[m + 2];
    d = d[m + 3];
    if (c !== d || l !== e || w !== h || k !== g) {
      m = 1 - f;
      var r = l * e + w * h + k * g + c * d, n = 0 <= r ? 1 : -1, q = 1 - r * r;
      q > Number.EPSILON && (q = Math.sqrt(q), r = Math.atan2(q, r * n), m = Math.sin(m * r) / q, f = Math.sin(f * r) / q);
      n *= f;
      l = l * m + e * n;
      w = w * m + h * n;
      k = k * m + g * n;
      c = c * m + d * n;
      m === 1 - f && (f = 1 / Math.sqrt(l * l + w * w + k * k + c * c), l *= f, w *= f, k *= f, c *= f);
    }
    a[b] = l;
    a[b + 1] = w;
    a[b + 2] = k;
    a[b + 3] = c;
  }, multiplyQuaternionsFlat:function(a, b, c, e, d, m) {
    var l = c[e], f = c[e + 1], w = c[e + 2];
    c = c[e + 3];
    e = d[m];
    var k = d[m + 1], h = d[m + 2];
    d = d[m + 3];
    a[b] = l * d + c * e + f * h - w * k;
    a[b + 1] = f * d + c * k + w * e - l * h;
    a[b + 2] = w * d + c * h + l * k - f * e;
    a[b + 3] = c * d - l * e - f * k - w * h;
    return a;
  }});
  Object.defineProperties(t.prototype, {x:{get:function() {
    return this._x;
  }, set:function(a) {
    this._x = a;
    this._onChangeCallback();
  }}, y:{get:function() {
    return this._y;
  }, set:function(a) {
    this._y = a;
    this._onChangeCallback();
  }}, z:{get:function() {
    return this._z;
  }, set:function(a) {
    this._z = a;
    this._onChangeCallback();
  }}, w:{get:function() {
    return this._w;
  }, set:function(a) {
    this._w = a;
    this._onChangeCallback();
  }}});
  Object.assign(t.prototype, {isQuaternion:!0, set:function(a, b, c, e) {
    this._x = a;
    this._y = b;
    this._z = c;
    this._w = e;
    this._onChangeCallback();
    return this;
  }, clone:function() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }, copy:function(a) {
    this._x = a.x;
    this._y = a.y;
    this._z = a.z;
    this._w = a.w;
    this._onChangeCallback();
    return this;
  }, setFromEuler:function(a, b) {
    if (!a || !a.isEuler) {
      throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    var l = a._x, c = a._y, e = a._z;
    a = a.order;
    var d = Math.cos, m = Math.sin, f = d(l / 2), w = d(c / 2);
    d = d(e / 2);
    l = m(l / 2);
    c = m(c / 2);
    e = m(e / 2);
    switch(a) {
      case "XYZ":
        this._x = l * w * d + f * c * e;
        this._y = f * c * d - l * w * e;
        this._z = f * w * e + l * c * d;
        this._w = f * w * d - l * c * e;
        break;
      case "YXZ":
        this._x = l * w * d + f * c * e;
        this._y = f * c * d - l * w * e;
        this._z = f * w * e - l * c * d;
        this._w = f * w * d + l * c * e;
        break;
      case "ZXY":
        this._x = l * w * d - f * c * e;
        this._y = f * c * d + l * w * e;
        this._z = f * w * e + l * c * d;
        this._w = f * w * d - l * c * e;
        break;
      case "ZYX":
        this._x = l * w * d - f * c * e;
        this._y = f * c * d + l * w * e;
        this._z = f * w * e - l * c * d;
        this._w = f * w * d + l * c * e;
        break;
      case "YZX":
        this._x = l * w * d + f * c * e;
        this._y = f * c * d + l * w * e;
        this._z = f * w * e - l * c * d;
        this._w = f * w * d - l * c * e;
        break;
      case "XZY":
        this._x = l * w * d - f * c * e;
        this._y = f * c * d - l * w * e;
        this._z = f * w * e + l * c * d;
        this._w = f * w * d + l * c * e;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    !1 !== b && this._onChangeCallback();
    return this;
  }, setFromAxisAngle:function(a, b) {
    b /= 2;
    var l = Math.sin(b);
    this._x = a.x * l;
    this._y = a.y * l;
    this._z = a.z * l;
    this._w = Math.cos(b);
    this._onChangeCallback();
    return this;
  }, setFromRotationMatrix:function(a) {
    var l = a.elements, b = l[0];
    a = l[4];
    var c = l[8], e = l[1], d = l[5], m = l[9], f = l[2], k = l[6];
    l = l[10];
    var h = b + d + l;
    0 < h ? (b = .5 / Math.sqrt(h + 1), this._w = .25 / b, this._x = (k - m) * b, this._y = (c - f) * b, this._z = (e - a) * b) : b > d && b > l ? (b = 2 * Math.sqrt(1 + b - d - l), this._w = (k - m) / b, this._x = .25 * b, this._y = (a + e) / b, this._z = (c + f) / b) : d > l ? (b = 2 * Math.sqrt(1 + d - b - l), this._w = (c - f) / b, this._x = (a + e) / b, this._y = .25 * b, this._z = (m + k) / b) : (b = 2 * Math.sqrt(1 + l - b - d), this._w = (e - a) / b, this._x = (c + f) / b, this._y = (m + 
    k) / b, this._z = .25 * b);
    this._onChangeCallback();
    return this;
  }, setFromUnitVectors:function(a, b) {
    var l = a.dot(b) + 1;
    1E-6 > l ? (l = 0, Math.abs(a.x) > Math.abs(a.z) ? (this._x = -a.y, this._y = a.x, this._z = 0) : (this._x = 0, this._y = -a.z, this._z = a.y)) : (this._x = a.y * b.z - a.z * b.y, this._y = a.z * b.x - a.x * b.z, this._z = a.x * b.y - a.y * b.x);
    this._w = l;
    return this.normalize();
  }, angleTo:function(a) {
    return 2 * Math.acos(Math.abs(na.clamp(this.dot(a), -1, 1)));
  }, rotateTowards:function(a, b) {
    var l = this.angleTo(a);
    if (0 === l) {
      return this;
    }
    this.slerp(a, Math.min(1, b / l));
    return this;
  }, inverse:function() {
    return this.conjugate();
  }, conjugate:function() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }, dot:function(a) {
    return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w;
  }, lengthSq:function() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }, length:function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }, normalize:function() {
    var a = this.length();
    0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
    this._onChangeCallback();
    return this;
  }, multiply:function(a, b) {
    return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a);
  }, premultiply:function(a) {
    return this.multiplyQuaternions(a, this);
  }, multiplyQuaternions:function(a, b) {
    var l = a._x, c = a._y, e = a._z;
    a = a._w;
    var d = b._x, m = b._y, f = b._z;
    b = b._w;
    this._x = l * b + a * d + c * f - e * m;
    this._y = c * b + a * m + e * d - l * f;
    this._z = e * b + a * f + l * m - c * d;
    this._w = a * b - l * d - c * m - e * f;
    this._onChangeCallback();
    return this;
  }, slerp:function(a, b) {
    if (0 === b) {
      return this;
    }
    if (1 === b) {
      return this.copy(a);
    }
    var l = this._x, c = this._y, e = this._z, d = this._w, m = d * a._w + l * a._x + c * a._y + e * a._z;
    0 > m ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, m = -m) : this.copy(a);
    if (1 <= m) {
      return this._w = d, this._x = l, this._y = c, this._z = e, this;
    }
    a = 1 - m * m;
    if (a <= Number.EPSILON) {
      return m = 1 - b, this._w = m * d + b * this._w, this._x = m * l + b * this._x, this._y = m * c + b * this._y, this._z = m * e + b * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    a = Math.sqrt(a);
    var f = Math.atan2(a, m);
    m = Math.sin((1 - b) * f) / a;
    b = Math.sin(b * f) / a;
    this._w = d * m + this._w * b;
    this._x = l * m + this._x * b;
    this._y = c * m + this._y * b;
    this._z = e * m + this._z * b;
    this._onChangeCallback();
    return this;
  }, equals:function(a) {
    return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w;
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    this._x = a[b];
    this._y = a[b + 1];
    this._z = a[b + 2];
    this._w = a[b + 3];
    this._onChangeCallback();
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this._x;
    a[b + 1] = this._y;
    a[b + 2] = this._z;
    a[b + 3] = this._w;
    return a;
  }, fromBufferAttribute:function(a, b) {
    this._x = a.getX(b);
    this._y = a.getY(b);
    this._z = a.getZ(b);
    this._w = a.getW(b);
    return this;
  }, _onChange:function(a) {
    this._onChangeCallback = a;
    return this;
  }, _onChangeCallback:function() {
  }});
  var dh = new f, yi = new t;
  Object.assign(f.prototype, {isVector3:!0, set:function(a, b, c) {
    this.x = a;
    this.y = b;
    this.z = c;
    return this;
  }, setScalar:function(a) {
    this.z = this.y = this.x = a;
    return this;
  }, setX:function(a) {
    this.x = a;
    return this;
  }, setY:function(a) {
    this.y = a;
    return this;
  }, setZ:function(a) {
    this.z = a;
    return this;
  }, setComponent:function(a, b) {
    switch(a) {
      case 0:
        this.x = b;
        break;
      case 1:
        this.y = b;
        break;
      case 2:
        this.z = b;
        break;
      default:
        throw Error("index is out of range: " + a);
    }
    return this;
  }, getComponent:function(a) {
    switch(a) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw Error("index is out of range: " + a);
    }
  }, clone:function() {
    return new this.constructor(this.x, this.y, this.z);
  }, copy:function(a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    return this;
  }, add:function(a, b) {
    if (void 0 !== b) {
      return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
    }
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    return this;
  }, addScalar:function(a) {
    this.x += a;
    this.y += a;
    this.z += a;
    return this;
  }, addVectors:function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }, addScaledVector:function(a, b) {
    this.x += a.x * b;
    this.y += a.y * b;
    this.z += a.z * b;
    return this;
  }, sub:function(a, b) {
    if (void 0 !== b) {
      return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
    }
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    return this;
  }, subScalar:function(a) {
    this.x -= a;
    this.y -= a;
    this.z -= a;
    return this;
  }, subVectors:function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }, multiply:function(a, b) {
    if (void 0 !== b) {
      return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b);
    }
    this.x *= a.x;
    this.y *= a.y;
    this.z *= a.z;
    return this;
  }, multiplyScalar:function(a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    return this;
  }, multiplyVectors:function(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }, applyEuler:function(a) {
    a && a.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
    return this.applyQuaternion(yi.setFromEuler(a));
  }, applyAxisAngle:function(a, b) {
    return this.applyQuaternion(yi.setFromAxisAngle(a, b));
  }, applyMatrix3:function(a) {
    var l = this.x, b = this.y, c = this.z;
    a = a.elements;
    this.x = a[0] * l + a[3] * b + a[6] * c;
    this.y = a[1] * l + a[4] * b + a[7] * c;
    this.z = a[2] * l + a[5] * b + a[8] * c;
    return this;
  }, applyNormalMatrix:function(a) {
    return this.applyMatrix3(a).normalize();
  }, applyMatrix4:function(a) {
    var l = this.x, b = this.y, c = this.z;
    a = a.elements;
    var e = 1 / (a[3] * l + a[7] * b + a[11] * c + a[15]);
    this.x = (a[0] * l + a[4] * b + a[8] * c + a[12]) * e;
    this.y = (a[1] * l + a[5] * b + a[9] * c + a[13]) * e;
    this.z = (a[2] * l + a[6] * b + a[10] * c + a[14]) * e;
    return this;
  }, applyQuaternion:function(a) {
    var l = this.x, b = this.y, c = this.z, e = a.x, d = a.y, m = a.z;
    a = a.w;
    var f = a * l + d * c - m * b, k = a * b + m * l - e * c, h = a * c + e * b - d * l;
    l = -e * l - d * b - m * c;
    this.x = f * a + l * -e + k * -m - h * -d;
    this.y = k * a + l * -d + h * -e - f * -m;
    this.z = h * a + l * -m + f * -d - k * -e;
    return this;
  }, project:function(a) {
    return this.applyMatrix4(a.matrixWorldInverse).applyMatrix4(a.projectionMatrix);
  }, unproject:function(a) {
    return this.applyMatrix4(a.projectionMatrixInverse).applyMatrix4(a.matrixWorld);
  }, transformDirection:function(a) {
    var l = this.x, b = this.y, c = this.z;
    a = a.elements;
    this.x = a[0] * l + a[4] * b + a[8] * c;
    this.y = a[1] * l + a[5] * b + a[9] * c;
    this.z = a[2] * l + a[6] * b + a[10] * c;
    return this.normalize();
  }, divide:function(a) {
    this.x /= a.x;
    this.y /= a.y;
    this.z /= a.z;
    return this;
  }, divideScalar:function(a) {
    return this.multiplyScalar(1 / a);
  }, min:function(a) {
    this.x = Math.min(this.x, a.x);
    this.y = Math.min(this.y, a.y);
    this.z = Math.min(this.z, a.z);
    return this;
  }, max:function(a) {
    this.x = Math.max(this.x, a.x);
    this.y = Math.max(this.y, a.y);
    this.z = Math.max(this.z, a.z);
    return this;
  }, clamp:function(a, b) {
    this.x = Math.max(a.x, Math.min(b.x, this.x));
    this.y = Math.max(a.y, Math.min(b.y, this.y));
    this.z = Math.max(a.z, Math.min(b.z, this.z));
    return this;
  }, clampScalar:function(a, b) {
    this.x = Math.max(a, Math.min(b, this.x));
    this.y = Math.max(a, Math.min(b, this.y));
    this.z = Math.max(a, Math.min(b, this.z));
    return this;
  }, clampLength:function(a, b) {
    var l = this.length();
    return this.divideScalar(l || 1).multiplyScalar(Math.max(a, Math.min(b, l)));
  }, floor:function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }, ceil:function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }, round:function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }, roundToZero:function() {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }, negate:function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }, dot:function(a) {
    return this.x * a.x + this.y * a.y + this.z * a.z;
  }, lengthSq:function() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }, length:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }, manhattanLength:function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }, normalize:function() {
    return this.divideScalar(this.length() || 1);
  }, setLength:function(a) {
    return this.normalize().multiplyScalar(a);
  }, lerp:function(a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    this.z += (a.z - this.z) * b;
    return this;
  }, lerpVectors:function(a, b, c) {
    return this.subVectors(b, a).multiplyScalar(c).add(a);
  }, cross:function(a, b) {
    return void 0 !== b ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b)) : this.crossVectors(this, a);
  }, crossVectors:function(a, b) {
    var l = a.x, c = a.y;
    a = a.z;
    var e = b.x, d = b.y;
    b = b.z;
    this.x = c * b - a * d;
    this.y = a * e - l * b;
    this.z = l * d - c * e;
    return this;
  }, projectOnVector:function(a) {
    var l = a.lengthSq();
    if (0 === l) {
      return this.set(0, 0, 0);
    }
    l = a.dot(this) / l;
    return this.copy(a).multiplyScalar(l);
  }, projectOnPlane:function(a) {
    dh.copy(this).projectOnVector(a);
    return this.sub(dh);
  }, reflect:function(a) {
    return this.sub(dh.copy(a).multiplyScalar(2 * this.dot(a)));
  }, angleTo:function(a) {
    var l = Math.sqrt(this.lengthSq() * a.lengthSq());
    if (0 === l) {
      return Math.PI / 2;
    }
    a = this.dot(a) / l;
    return Math.acos(na.clamp(a, -1, 1));
  }, distanceTo:function(a) {
    return Math.sqrt(this.distanceToSquared(a));
  }, distanceToSquared:function(a) {
    var l = this.x - a.x, b = this.y - a.y;
    a = this.z - a.z;
    return l * l + b * b + a * a;
  }, manhattanDistanceTo:function(a) {
    return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z);
  }, setFromSpherical:function(a) {
    return this.setFromSphericalCoords(a.radius, a.phi, a.theta);
  }, setFromSphericalCoords:function(a, b, c) {
    var l = Math.sin(b) * a;
    this.x = l * Math.sin(c);
    this.y = Math.cos(b) * a;
    this.z = l * Math.cos(c);
    return this;
  }, setFromCylindrical:function(a) {
    return this.setFromCylindricalCoords(a.radius, a.theta, a.y);
  }, setFromCylindricalCoords:function(a, b, c) {
    this.x = a * Math.sin(b);
    this.y = c;
    this.z = a * Math.cos(b);
    return this;
  }, setFromMatrixPosition:function(a) {
    a = a.elements;
    this.x = a[12];
    this.y = a[13];
    this.z = a[14];
    return this;
  }, setFromMatrixScale:function(a) {
    var l = this.setFromMatrixColumn(a, 0).length(), b = this.setFromMatrixColumn(a, 1).length();
    a = this.setFromMatrixColumn(a, 2).length();
    this.x = l;
    this.y = b;
    this.z = a;
    return this;
  }, setFromMatrixColumn:function(a, b) {
    return this.fromArray(a.elements, 4 * b);
  }, setFromMatrix3Column:function(a, b) {
    return this.fromArray(a.elements, 3 * b);
  }, equals:function(a) {
    return a.x === this.x && a.y === this.y && a.z === this.z;
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    this.x = a[b];
    this.y = a[b + 1];
    this.z = a[b + 2];
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this.x;
    a[b + 1] = this.y;
    a[b + 2] = this.z;
    return a;
  }, fromBufferAttribute:function(a, b, c) {
    void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    this.x = a.getX(b);
    this.y = a.getY(b);
    this.z = a.getZ(b);
    return this;
  }, random:function() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }});
  var Jd = new f, Ja = new n, Zj = new f(0, 0, 0), ak = new f(1, 1, 1), sc = new f, Qf = new f, Wa = new f;
  Object.assign(n.prototype, {isMatrix4:!0, set:function(a, b, c, e, d, m, f, k, h, g, r, n, q, p, u, t) {
    var l = this.elements;
    l[0] = a;
    l[4] = b;
    l[8] = c;
    l[12] = e;
    l[1] = d;
    l[5] = m;
    l[9] = f;
    l[13] = k;
    l[2] = h;
    l[6] = g;
    l[10] = r;
    l[14] = n;
    l[3] = q;
    l[7] = p;
    l[11] = u;
    l[15] = t;
    return this;
  }, identity:function() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }, clone:function() {
    return (new n).fromArray(this.elements);
  }, copy:function(a) {
    var l = this.elements;
    a = a.elements;
    l[0] = a[0];
    l[1] = a[1];
    l[2] = a[2];
    l[3] = a[3];
    l[4] = a[4];
    l[5] = a[5];
    l[6] = a[6];
    l[7] = a[7];
    l[8] = a[8];
    l[9] = a[9];
    l[10] = a[10];
    l[11] = a[11];
    l[12] = a[12];
    l[13] = a[13];
    l[14] = a[14];
    l[15] = a[15];
    return this;
  }, copyPosition:function(a) {
    var l = this.elements;
    a = a.elements;
    l[12] = a[12];
    l[13] = a[13];
    l[14] = a[14];
    return this;
  }, extractBasis:function(a, b, c) {
    a.setFromMatrixColumn(this, 0);
    b.setFromMatrixColumn(this, 1);
    c.setFromMatrixColumn(this, 2);
    return this;
  }, makeBasis:function(a, b, c) {
    this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1);
    return this;
  }, extractRotation:function(a) {
    var l = this.elements, b = a.elements, c = 1 / Jd.setFromMatrixColumn(a, 0).length(), e = 1 / Jd.setFromMatrixColumn(a, 1).length();
    a = 1 / Jd.setFromMatrixColumn(a, 2).length();
    l[0] = b[0] * c;
    l[1] = b[1] * c;
    l[2] = b[2] * c;
    l[3] = 0;
    l[4] = b[4] * e;
    l[5] = b[5] * e;
    l[6] = b[6] * e;
    l[7] = 0;
    l[8] = b[8] * a;
    l[9] = b[9] * a;
    l[10] = b[10] * a;
    l[11] = 0;
    l[12] = 0;
    l[13] = 0;
    l[14] = 0;
    l[15] = 1;
    return this;
  }, makeRotationFromEuler:function(a) {
    a && a.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    var l = this.elements, b = a.x, c = a.y, e = a.z, d = Math.cos(b);
    b = Math.sin(b);
    var m = Math.cos(c);
    c = Math.sin(c);
    var f = Math.cos(e);
    e = Math.sin(e);
    if ("XYZ" === a.order) {
      a = d * f;
      var k = d * e, h = b * f, g = b * e;
      l[0] = m * f;
      l[4] = -m * e;
      l[8] = c;
      l[1] = k + h * c;
      l[5] = a - g * c;
      l[9] = -b * m;
      l[2] = g - a * c;
      l[6] = h + k * c;
      l[10] = d * m;
    } else {
      "YXZ" === a.order ? (a = m * f, k = m * e, h = c * f, g = c * e, l[0] = a + g * b, l[4] = h * b - k, l[8] = d * c, l[1] = d * e, l[5] = d * f, l[9] = -b, l[2] = k * b - h, l[6] = g + a * b, l[10] = d * m) : "ZXY" === a.order ? (a = m * f, k = m * e, h = c * f, g = c * e, l[0] = a - g * b, l[4] = -d * e, l[8] = h + k * b, l[1] = k + h * b, l[5] = d * f, l[9] = g - a * b, l[2] = -d * c, l[6] = b, l[10] = d * m) : "ZYX" === a.order ? (a = d * f, k = d * e, h = b * f, g = b * e, l[0] = m * f, l[4] = 
      h * c - k, l[8] = a * c + g, l[1] = m * e, l[5] = g * c + a, l[9] = k * c - h, l[2] = -c, l[6] = b * m, l[10] = d * m) : "YZX" === a.order ? (a = d * m, k = d * c, h = b * m, g = b * c, l[0] = m * f, l[4] = g - a * e, l[8] = h * e + k, l[1] = e, l[5] = d * f, l[9] = -b * f, l[2] = -c * f, l[6] = k * e + h, l[10] = a - g * e) : "XZY" === a.order && (a = d * m, k = d * c, h = b * m, g = b * c, l[0] = m * f, l[4] = -e, l[8] = c * f, l[1] = a * e + g, l[5] = d * f, l[9] = k * e - h, l[2] = h * 
      e - k, l[6] = b * f, l[10] = g * e + a);
    }
    l[3] = 0;
    l[7] = 0;
    l[11] = 0;
    l[12] = 0;
    l[13] = 0;
    l[14] = 0;
    l[15] = 1;
    return this;
  }, makeRotationFromQuaternion:function(a) {
    return this.compose(Zj, a, ak);
  }, lookAt:function(a, b, c) {
    var l = this.elements;
    Wa.subVectors(a, b);
    0 === Wa.lengthSq() && (Wa.z = 1);
    Wa.normalize();
    sc.crossVectors(c, Wa);
    0 === sc.lengthSq() && (1 === Math.abs(c.z) ? Wa.x += 1E-4 : Wa.z += 1E-4, Wa.normalize(), sc.crossVectors(c, Wa));
    sc.normalize();
    Qf.crossVectors(Wa, sc);
    l[0] = sc.x;
    l[4] = Qf.x;
    l[8] = Wa.x;
    l[1] = sc.y;
    l[5] = Qf.y;
    l[9] = Wa.y;
    l[2] = sc.z;
    l[6] = Qf.z;
    l[10] = Wa.z;
    return this;
  }, multiply:function(a, b) {
    return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a);
  }, premultiply:function(a) {
    return this.multiplyMatrices(a, this);
  }, multiplyMatrices:function(a, b) {
    var l = a.elements, c = b.elements;
    b = this.elements;
    a = l[0];
    var e = l[4], d = l[8], m = l[12], f = l[1], k = l[5], h = l[9], w = l[13], g = l[2], r = l[6], n = l[10], q = l[14], p = l[3], u = l[7], t = l[11];
    l = l[15];
    var y = c[0], v = c[4], x = c[8], U = c[12], z = c[1], C = c[5], A = c[9], qa = c[13], D = c[2], B = c[6], F = c[10], ra = c[14], E = c[3], Ca = c[7], H = c[11];
    c = c[15];
    b[0] = a * y + e * z + d * D + m * E;
    b[4] = a * v + e * C + d * B + m * Ca;
    b[8] = a * x + e * A + d * F + m * H;
    b[12] = a * U + e * qa + d * ra + m * c;
    b[1] = f * y + k * z + h * D + w * E;
    b[5] = f * v + k * C + h * B + w * Ca;
    b[9] = f * x + k * A + h * F + w * H;
    b[13] = f * U + k * qa + h * ra + w * c;
    b[2] = g * y + r * z + n * D + q * E;
    b[6] = g * v + r * C + n * B + q * Ca;
    b[10] = g * x + r * A + n * F + q * H;
    b[14] = g * U + r * qa + n * ra + q * c;
    b[3] = p * y + u * z + t * D + l * E;
    b[7] = p * v + u * C + t * B + l * Ca;
    b[11] = p * x + u * A + t * F + l * H;
    b[15] = p * U + u * qa + t * ra + l * c;
    return this;
  }, multiplyScalar:function(a) {
    var l = this.elements;
    l[0] *= a;
    l[4] *= a;
    l[8] *= a;
    l[12] *= a;
    l[1] *= a;
    l[5] *= a;
    l[9] *= a;
    l[13] *= a;
    l[2] *= a;
    l[6] *= a;
    l[10] *= a;
    l[14] *= a;
    l[3] *= a;
    l[7] *= a;
    l[11] *= a;
    l[15] *= a;
    return this;
  }, determinant:function() {
    var a = this.elements, b = a[0], c = a[4], e = a[8], d = a[12], m = a[1], f = a[5], k = a[9], h = a[13], g = a[2], r = a[6], n = a[10], q = a[14];
    return a[3] * (+d * k * r - e * h * r - d * f * n + c * h * n + e * f * q - c * k * q) + a[7] * (+b * k * q - b * h * n + d * m * n - e * m * q + e * h * g - d * k * g) + a[11] * (+b * h * r - b * f * q - d * m * r + c * m * q + d * f * g - c * h * g) + a[15] * (-e * f * g - b * k * r + b * f * n + e * m * r - c * m * n + c * k * g);
  }, transpose:function() {
    var a = this.elements;
    var b = a[1];
    a[1] = a[4];
    a[4] = b;
    b = a[2];
    a[2] = a[8];
    a[8] = b;
    b = a[6];
    a[6] = a[9];
    a[9] = b;
    b = a[3];
    a[3] = a[12];
    a[12] = b;
    b = a[7];
    a[7] = a[13];
    a[13] = b;
    b = a[11];
    a[11] = a[14];
    a[14] = b;
    return this;
  }, setPosition:function(a, b, c) {
    var l = this.elements;
    a.isVector3 ? (l[12] = a.x, l[13] = a.y, l[14] = a.z) : (l[12] = a, l[13] = b, l[14] = c);
    return this;
  }, getInverse:function(a, b) {
    void 0 !== b && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
    b = this.elements;
    var l = a.elements;
    a = l[0];
    var c = l[1], e = l[2], d = l[3], m = l[4], f = l[5], k = l[6], h = l[7], g = l[8], w = l[9], r = l[10], n = l[11], q = l[12], p = l[13], u = l[14];
    l = l[15];
    var t = w * u * h - p * r * h + p * k * n - f * u * n - w * k * l + f * r * l, y = q * r * h - g * u * h - q * k * n + m * u * n + g * k * l - m * r * l, v = g * p * h - q * w * h + q * f * n - m * p * n - g * f * l + m * w * l, x = q * w * k - g * p * k - q * f * r + m * p * r + g * f * u - m * w * u, U = a * t + c * y + e * v + d * x;
    if (0 === U) {
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    U = 1 / U;
    b[0] = t * U;
    b[1] = (p * r * d - w * u * d - p * e * n + c * u * n + w * e * l - c * r * l) * U;
    b[2] = (f * u * d - p * k * d + p * e * h - c * u * h - f * e * l + c * k * l) * U;
    b[3] = (w * k * d - f * r * d - w * e * h + c * r * h + f * e * n - c * k * n) * U;
    b[4] = y * U;
    b[5] = (g * u * d - q * r * d + q * e * n - a * u * n - g * e * l + a * r * l) * U;
    b[6] = (q * k * d - m * u * d - q * e * h + a * u * h + m * e * l - a * k * l) * U;
    b[7] = (m * r * d - g * k * d + g * e * h - a * r * h - m * e * n + a * k * n) * U;
    b[8] = v * U;
    b[9] = (q * w * d - g * p * d - q * c * n + a * p * n + g * c * l - a * w * l) * U;
    b[10] = (m * p * d - q * f * d + q * c * h - a * p * h - m * c * l + a * f * l) * U;
    b[11] = (g * f * d - m * w * d - g * c * h + a * w * h + m * c * n - a * f * n) * U;
    b[12] = x * U;
    b[13] = (g * p * e - q * w * e + q * c * r - a * p * r - g * c * u + a * w * u) * U;
    b[14] = (q * f * e - m * p * e - q * c * k + a * p * k + m * c * u - a * f * u) * U;
    b[15] = (m * w * e - g * f * e + g * c * k - a * w * k - m * c * r + a * f * r) * U;
    return this;
  }, scale:function(a) {
    var l = this.elements, b = a.x, c = a.y;
    a = a.z;
    l[0] *= b;
    l[4] *= c;
    l[8] *= a;
    l[1] *= b;
    l[5] *= c;
    l[9] *= a;
    l[2] *= b;
    l[6] *= c;
    l[10] *= a;
    l[3] *= b;
    l[7] *= c;
    l[11] *= a;
    return this;
  }, getMaxScaleOnAxis:function() {
    var a = this.elements;
    return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]));
  }, makeTranslation:function(a, b, c) {
    this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
    return this;
  }, makeRotationX:function(a) {
    var l = Math.cos(a);
    a = Math.sin(a);
    this.set(1, 0, 0, 0, 0, l, -a, 0, 0, a, l, 0, 0, 0, 0, 1);
    return this;
  }, makeRotationY:function(a) {
    var l = Math.cos(a);
    a = Math.sin(a);
    this.set(l, 0, a, 0, 0, 1, 0, 0, -a, 0, l, 0, 0, 0, 0, 1);
    return this;
  }, makeRotationZ:function(a) {
    var l = Math.cos(a);
    a = Math.sin(a);
    this.set(l, -a, 0, 0, a, l, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }, makeRotationAxis:function(a, b) {
    var l = Math.cos(b);
    b = Math.sin(b);
    var c = 1 - l, e = a.x, d = a.y;
    a = a.z;
    var m = c * e, f = c * d;
    this.set(m * e + l, m * d - b * a, m * a + b * d, 0, m * d + b * a, f * d + l, f * a - b * e, 0, m * a - b * d, f * a + b * e, c * a * a + l, 0, 0, 0, 0, 1);
    return this;
  }, makeScale:function(a, b, c) {
    this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
    return this;
  }, makeShear:function(a, b, c) {
    this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1);
    return this;
  }, compose:function(a, b, c) {
    var l = this.elements, e = b._x, d = b._y, m = b._z, f = b._w, k = e + e, h = d + d, g = m + m;
    b = e * k;
    var w = e * h;
    e *= g;
    var r = d * h;
    d *= g;
    m *= g;
    k *= f;
    h *= f;
    f *= g;
    g = c.x;
    var n = c.y;
    c = c.z;
    l[0] = (1 - (r + m)) * g;
    l[1] = (w + f) * g;
    l[2] = (e - h) * g;
    l[3] = 0;
    l[4] = (w - f) * n;
    l[5] = (1 - (b + m)) * n;
    l[6] = (d + k) * n;
    l[7] = 0;
    l[8] = (e + h) * c;
    l[9] = (d - k) * c;
    l[10] = (1 - (b + r)) * c;
    l[11] = 0;
    l[12] = a.x;
    l[13] = a.y;
    l[14] = a.z;
    l[15] = 1;
    return this;
  }, decompose:function(a, b, c) {
    var l = this.elements, e = Jd.set(l[0], l[1], l[2]).length(), d = Jd.set(l[4], l[5], l[6]).length(), m = Jd.set(l[8], l[9], l[10]).length();
    0 > this.determinant() && (e = -e);
    a.x = l[12];
    a.y = l[13];
    a.z = l[14];
    Ja.copy(this);
    a = 1 / e;
    l = 1 / d;
    var f = 1 / m;
    Ja.elements[0] *= a;
    Ja.elements[1] *= a;
    Ja.elements[2] *= a;
    Ja.elements[4] *= l;
    Ja.elements[5] *= l;
    Ja.elements[6] *= l;
    Ja.elements[8] *= f;
    Ja.elements[9] *= f;
    Ja.elements[10] *= f;
    b.setFromRotationMatrix(Ja);
    c.x = e;
    c.y = d;
    c.z = m;
    return this;
  }, makePerspective:function(a, b, c, e, d, m) {
    void 0 === m && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    var l = this.elements;
    l[0] = 2 * d / (b - a);
    l[4] = 0;
    l[8] = (b + a) / (b - a);
    l[12] = 0;
    l[1] = 0;
    l[5] = 2 * d / (c - e);
    l[9] = (c + e) / (c - e);
    l[13] = 0;
    l[2] = 0;
    l[6] = 0;
    l[10] = -(m + d) / (m - d);
    l[14] = -2 * m * d / (m - d);
    l[3] = 0;
    l[7] = 0;
    l[11] = -1;
    l[15] = 0;
    return this;
  }, makeOrthographic:function(a, b, c, e, d, m) {
    var l = this.elements, f = 1 / (b - a), k = 1 / (c - e), h = 1 / (m - d);
    l[0] = 2 * f;
    l[4] = 0;
    l[8] = 0;
    l[12] = -((b + a) * f);
    l[1] = 0;
    l[5] = 2 * k;
    l[9] = 0;
    l[13] = -((c + e) * k);
    l[2] = 0;
    l[6] = 0;
    l[10] = -2 * h;
    l[14] = -((m + d) * h);
    l[3] = 0;
    l[7] = 0;
    l[11] = 0;
    l[15] = 1;
    return this;
  }, equals:function(a) {
    var l = this.elements;
    a = a.elements;
    for (var b = 0; 16 > b; b++) {
      if (l[b] !== a[b]) {
        return !1;
      }
    }
    return !0;
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    for (var l = 0; 16 > l; l++) {
      this.elements[l] = a[l + b];
    }
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    var l = this.elements;
    a[b] = l[0];
    a[b + 1] = l[1];
    a[b + 2] = l[2];
    a[b + 3] = l[3];
    a[b + 4] = l[4];
    a[b + 5] = l[5];
    a[b + 6] = l[6];
    a[b + 7] = l[7];
    a[b + 8] = l[8];
    a[b + 9] = l[9];
    a[b + 10] = l[10];
    a[b + 11] = l[11];
    a[b + 12] = l[12];
    a[b + 13] = l[13];
    a[b + 14] = l[14];
    a[b + 15] = l[15];
    return a;
  }});
  var zi = new n, Ai = new t;
  b.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
  b.DefaultOrder = "XYZ";
  Object.defineProperties(b.prototype, {x:{get:function() {
    return this._x;
  }, set:function(a) {
    this._x = a;
    this._onChangeCallback();
  }}, y:{get:function() {
    return this._y;
  }, set:function(a) {
    this._y = a;
    this._onChangeCallback();
  }}, z:{get:function() {
    return this._z;
  }, set:function(a) {
    this._z = a;
    this._onChangeCallback();
  }}, order:{get:function() {
    return this._order;
  }, set:function(a) {
    this._order = a;
    this._onChangeCallback();
  }}});
  Object.assign(b.prototype, {isEuler:!0, set:function(a, b, c, e) {
    this._x = a;
    this._y = b;
    this._z = c;
    this._order = e || this._order;
    this._onChangeCallback();
    return this;
  }, clone:function() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }, copy:function(a) {
    this._x = a._x;
    this._y = a._y;
    this._z = a._z;
    this._order = a._order;
    this._onChangeCallback();
    return this;
  }, setFromRotationMatrix:function(a, b, c) {
    var l = na.clamp, e = a.elements;
    a = e[0];
    var d = e[4], m = e[8], f = e[1], k = e[5], h = e[9], g = e[2], w = e[6];
    e = e[10];
    b = b || this._order;
    switch(b) {
      case "XYZ":
        this._y = Math.asin(l(m, -1, 1));
        .9999999 > Math.abs(m) ? (this._x = Math.atan2(-h, e), this._z = Math.atan2(-d, a)) : (this._x = Math.atan2(w, k), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-l(h, -1, 1));
        .9999999 > Math.abs(h) ? (this._y = Math.atan2(m, e), this._z = Math.atan2(f, k)) : (this._y = Math.atan2(-g, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(l(w, -1, 1));
        .9999999 > Math.abs(w) ? (this._y = Math.atan2(-g, e), this._z = Math.atan2(-d, k)) : (this._y = 0, this._z = Math.atan2(f, a));
        break;
      case "ZYX":
        this._y = Math.asin(-l(g, -1, 1));
        .9999999 > Math.abs(g) ? (this._x = Math.atan2(w, e), this._z = Math.atan2(f, a)) : (this._x = 0, this._z = Math.atan2(-d, k));
        break;
      case "YZX":
        this._z = Math.asin(l(f, -1, 1));
        .9999999 > Math.abs(f) ? (this._x = Math.atan2(-h, k), this._y = Math.atan2(-g, a)) : (this._x = 0, this._y = Math.atan2(m, e));
        break;
      case "XZY":
        this._z = Math.asin(-l(d, -1, 1));
        .9999999 > Math.abs(d) ? (this._x = Math.atan2(w, k), this._y = Math.atan2(m, a)) : (this._x = Math.atan2(-h, e), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + b);
    }
    this._order = b;
    !1 !== c && this._onChangeCallback();
    return this;
  }, setFromQuaternion:function(a, b, c) {
    zi.makeRotationFromQuaternion(a);
    return this.setFromRotationMatrix(zi, b, c);
  }, setFromVector3:function(a, b) {
    return this.set(a.x, a.y, a.z, b || this._order);
  }, reorder:function(a) {
    Ai.setFromEuler(this);
    return this.setFromQuaternion(Ai, a);
  }, equals:function(a) {
    return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order;
  }, fromArray:function(a) {
    this._x = a[0];
    this._y = a[1];
    this._z = a[2];
    void 0 !== a[3] && (this._order = a[3]);
    this._onChangeCallback();
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this._x;
    a[b + 1] = this._y;
    a[b + 2] = this._z;
    a[b + 3] = this._order;
    return a;
  }, toVector3:function(a) {
    return a ? a.set(this._x, this._y, this._z) : new f(this._x, this._y, this._z);
  }, _onChange:function(a) {
    this._onChangeCallback = a;
    return this;
  }, _onChangeCallback:function() {
  }});
  Object.assign(m.prototype, {set:function(a) {
    this.mask = 1 << a | 0;
  }, enable:function(a) {
    this.mask = this.mask | 1 << a | 0;
  }, enableAll:function() {
    this.mask = -1;
  }, toggle:function(a) {
    this.mask ^= 1 << a | 0;
  }, disable:function(a) {
    this.mask &= ~(1 << a | 0);
  }, disableAll:function() {
    this.mask = 0;
  }, test:function(a) {
    return 0 !== (this.mask & a.mask);
  }});
  var kj = 0, Bi = new f, Kd = new t, Zb = new n, Rf = new f, Le = new f, bk = new f, ck = new t, Ci = new f(1, 0, 0), Di = new f(0, 1, 0), Ei = new f(0, 0, 1), dk = {type:"added"}, ek = {type:"removed"};
  q.DefaultUp = new f(0, 1, 0);
  q.DefaultMatrixAutoUpdate = !0;
  q.prototype = Object.assign(Object.create(d.prototype), {constructor:q, isObject3D:!0, onBeforeRender:function() {
  }, onAfterRender:function() {
  }, applyMatrix4:function(a) {
    this.matrixAutoUpdate && this.updateMatrix();
    this.matrix.premultiply(a);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }, applyQuaternion:function(a) {
    this.quaternion.premultiply(a);
    return this;
  }, setRotationFromAxisAngle:function(a, b) {
    this.quaternion.setFromAxisAngle(a, b);
  }, setRotationFromEuler:function(a) {
    this.quaternion.setFromEuler(a, !0);
  }, setRotationFromMatrix:function(a) {
    this.quaternion.setFromRotationMatrix(a);
  }, setRotationFromQuaternion:function(a) {
    this.quaternion.copy(a);
  }, rotateOnAxis:function(a, b) {
    Kd.setFromAxisAngle(a, b);
    this.quaternion.multiply(Kd);
    return this;
  }, rotateOnWorldAxis:function(a, b) {
    Kd.setFromAxisAngle(a, b);
    this.quaternion.premultiply(Kd);
    return this;
  }, rotateX:function(a) {
    return this.rotateOnAxis(Ci, a);
  }, rotateY:function(a) {
    return this.rotateOnAxis(Di, a);
  }, rotateZ:function(a) {
    return this.rotateOnAxis(Ei, a);
  }, translateOnAxis:function(a, b) {
    Bi.copy(a).applyQuaternion(this.quaternion);
    this.position.add(Bi.multiplyScalar(b));
    return this;
  }, translateX:function(a) {
    return this.translateOnAxis(Ci, a);
  }, translateY:function(a) {
    return this.translateOnAxis(Di, a);
  }, translateZ:function(a) {
    return this.translateOnAxis(Ei, a);
  }, localToWorld:function(a) {
    return a.applyMatrix4(this.matrixWorld);
  }, worldToLocal:function(a) {
    return a.applyMatrix4(Zb.getInverse(this.matrixWorld));
  }, lookAt:function(a, b, c) {
    a.isVector3 ? Rf.copy(a) : Rf.set(a, b, c);
    a = this.parent;
    this.updateWorldMatrix(!0, !1);
    Le.setFromMatrixPosition(this.matrixWorld);
    this.isCamera || this.isLight ? Zb.lookAt(Le, Rf, this.up) : Zb.lookAt(Rf, Le, this.up);
    this.quaternion.setFromRotationMatrix(Zb);
    a && (Zb.extractRotation(a.matrixWorld), Kd.setFromRotationMatrix(Zb), this.quaternion.premultiply(Kd.inverse()));
  }, add:function(a) {
    if (1 < arguments.length) {
      for (var l = 0; l < arguments.length; l++) {
        this.add(arguments[l]);
      }
      return this;
    }
    if (a === this) {
      return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this;
    }
    a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, this.children.push(a), a.dispatchEvent(dk)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a);
    return this;
  }, remove:function(a) {
    if (1 < arguments.length) {
      for (var l = 0; l < arguments.length; l++) {
        this.remove(arguments[l]);
      }
      return this;
    }
    l = this.children.indexOf(a);
    -1 !== l && (a.parent = null, this.children.splice(l, 1), a.dispatchEvent(ek));
    return this;
  }, attach:function(a) {
    this.updateWorldMatrix(!0, !1);
    Zb.getInverse(this.matrixWorld);
    null !== a.parent && (a.parent.updateWorldMatrix(!0, !1), Zb.multiply(a.parent.matrixWorld));
    a.applyMatrix4(Zb);
    a.updateWorldMatrix(!1, !1);
    this.add(a);
    return this;
  }, getObjectById:function(a) {
    return this.getObjectByProperty("id", a);
  }, getObjectByName:function(a) {
    return this.getObjectByProperty("name", a);
  }, getObjectByProperty:function(a, b) {
    if (this[a] === b) {
      return this;
    }
    for (var l = 0, c = this.children.length; l < c; l++) {
      var e = this.children[l].getObjectByProperty(a, b);
      if (void 0 !== e) {
        return e;
      }
    }
  }, getWorldPosition:function(a) {
    void 0 === a && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), a = new f);
    this.updateMatrixWorld(!0);
    return a.setFromMatrixPosition(this.matrixWorld);
  }, getWorldQuaternion:function(a) {
    void 0 === a && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), a = new t);
    this.updateMatrixWorld(!0);
    this.matrixWorld.decompose(Le, a, bk);
    return a;
  }, getWorldScale:function(a) {
    void 0 === a && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), a = new f);
    this.updateMatrixWorld(!0);
    this.matrixWorld.decompose(Le, ck, a);
    return a;
  }, getWorldDirection:function(a) {
    void 0 === a && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), a = new f);
    this.updateMatrixWorld(!0);
    var l = this.matrixWorld.elements;
    return a.set(l[8], l[9], l[10]).normalize();
  }, raycast:function() {
  }, traverse:function(a) {
    a(this);
    for (var l = this.children, b = 0, c = l.length; b < c; b++) {
      l[b].traverse(a);
    }
  }, traverseVisible:function(a) {
    if (!1 !== this.visible) {
      a(this);
      for (var l = this.children, b = 0, c = l.length; b < c; b++) {
        l[b].traverseVisible(a);
      }
    }
  }, traverseAncestors:function(a) {
    var l = this.parent;
    null !== l && (a(l), l.traverseAncestors(a));
  }, updateMatrix:function() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = !0;
  }, updateMatrixWorld:function(a) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || a) {
      null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
    }
    for (var l = this.children, b = 0, c = l.length; b < c; b++) {
      l[b].updateMatrixWorld(a);
    }
  }, updateWorldMatrix:function(a, b) {
    var l = this.parent;
    !0 === a && null !== l && l.updateWorldMatrix(!0, !1);
    this.matrixAutoUpdate && this.updateMatrix();
    null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    if (!0 === b) {
      for (a = this.children, b = 0, l = a.length; b < l; b++) {
        a[b].updateWorldMatrix(!1, !0);
      }
    }
  }, toJSON:function(a) {
    function l(l, b) {
      void 0 === l[b.uuid] && (l[b.uuid] = b.toJSON(a));
      return b.uuid;
    }
    function b(a) {
      var l = [], b;
      for (b in a) {
        var c = a[b];
        delete c.metadata;
        l.push(c);
      }
      return l;
    }
    var c = void 0 === a || "string" === typeof a, e = {};
    c && (a = {geometries:{}, materials:{}, textures:{}, images:{}, shapes:{}}, e.metadata = {version:4.5, type:"Object", generator:"Object3D.toJSON"});
    var d = {};
    d.uuid = this.uuid;
    d.type = this.type;
    "" !== this.name && (d.name = this.name);
    !0 === this.castShadow && (d.castShadow = !0);
    !0 === this.receiveShadow && (d.receiveShadow = !0);
    !1 === this.visible && (d.visible = !1);
    !1 === this.frustumCulled && (d.frustumCulled = !1);
    0 !== this.renderOrder && (d.renderOrder = this.renderOrder);
    "{}" !== JSON.stringify(this.userData) && (d.userData = this.userData);
    d.layers = this.layers.mask;
    d.matrix = this.matrix.toArray();
    !1 === this.matrixAutoUpdate && (d.matrixAutoUpdate = !1);
    this.isInstancedMesh && (d.type = "InstancedMesh", d.count = this.count, d.instanceMatrix = this.instanceMatrix.toJSON());
    if (this.isMesh || this.isLine || this.isPoints) {
      d.geometry = l(a.geometries, this.geometry);
      var m = this.geometry.parameters;
      if (void 0 !== m && void 0 !== m.shapes) {
        if (m = m.shapes, Array.isArray(m)) {
          for (var f = 0, k = m.length; f < k; f++) {
            l(a.shapes, m[f]);
          }
        } else {
          l(a.shapes, m);
        }
      }
    }
    if (void 0 !== this.material) {
      if (Array.isArray(this.material)) {
        m = [];
        f = 0;
        for (k = this.material.length; f < k; f++) {
          m.push(l(a.materials, this.material[f]));
        }
        d.material = m;
      } else {
        d.material = l(a.materials, this.material);
      }
    }
    if (0 < this.children.length) {
      for (d.children = [], f = 0; f < this.children.length; f++) {
        d.children.push(this.children[f].toJSON(a).object);
      }
    }
    if (c) {
      c = b(a.geometries);
      f = b(a.materials);
      k = b(a.textures);
      var h = b(a.images);
      m = b(a.shapes);
      0 < c.length && (e.geometries = c);
      0 < f.length && (e.materials = f);
      0 < k.length && (e.textures = k);
      0 < h.length && (e.images = h);
      0 < m.length && (e.shapes = m);
    }
    e.object = d;
    return e;
  }, clone:function(a) {
    return (new this.constructor).copy(this, a);
  }, copy:function(a, b) {
    void 0 === b && (b = !0);
    this.name = a.name;
    this.up.copy(a.up);
    this.position.copy(a.position);
    this.quaternion.copy(a.quaternion);
    this.scale.copy(a.scale);
    this.matrix.copy(a.matrix);
    this.matrixWorld.copy(a.matrixWorld);
    this.matrixAutoUpdate = a.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
    this.layers.mask = a.layers.mask;
    this.visible = a.visible;
    this.castShadow = a.castShadow;
    this.receiveShadow = a.receiveShadow;
    this.frustumCulled = a.frustumCulled;
    this.renderOrder = a.renderOrder;
    this.userData = JSON.parse(JSON.stringify(a.userData));
    if (!0 === b) {
      for (b = 0; b < a.children.length; b++) {
        this.add(a.children[b].clone());
      }
    }
    return this;
  }});
  y.prototype = Object.assign(Object.create(q.prototype), {constructor:y, isScene:!0, copy:function(a, b) {
    q.prototype.copy.call(this, a, b);
    null !== a.background && (this.background = a.background.clone());
    null !== a.environment && (this.environment = a.environment.clone());
    null !== a.fog && (this.fog = a.fog.clone());
    null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone());
    this.autoUpdate = a.autoUpdate;
    this.matrixAutoUpdate = a.matrixAutoUpdate;
    return this;
  }, toJSON:function(a) {
    var l = q.prototype.toJSON.call(this, a);
    null !== this.background && (l.object.background = this.background.toJSON(a));
    null !== this.environment && (l.object.environment = this.environment.toJSON(a));
    null !== this.fog && (l.object.fog = this.fog.toJSON());
    return l;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }});
  var $b = [new f, new f, new f, new f, new f, new f, new f, new f], Me = new f, eh = new x, Ld = new f, Md = new f, Nd = new f, tc = new f, uc = new f, Sc = new f, Ne = new f, Sf = new f, Tf = new f, xc = new f;
  Object.assign(x.prototype, {isBox3:!0, set:function(a, b) {
    this.min.copy(a);
    this.max.copy(b);
    return this;
  }, setFromArray:function(a) {
    for (var l = Infinity, b = Infinity, c = Infinity, e = -Infinity, d = -Infinity, m = -Infinity, f = 0, k = a.length; f < k; f += 3) {
      var h = a[f], g = a[f + 1], r = a[f + 2];
      h < l && (l = h);
      g < b && (b = g);
      r < c && (c = r);
      h > e && (e = h);
      g > d && (d = g);
      r > m && (m = r);
    }
    this.min.set(l, b, c);
    this.max.set(e, d, m);
    return this;
  }, setFromBufferAttribute:function(a) {
    for (var l = Infinity, b = Infinity, c = Infinity, e = -Infinity, d = -Infinity, m = -Infinity, f = 0, k = a.count; f < k; f++) {
      var h = a.getX(f), g = a.getY(f), r = a.getZ(f);
      h < l && (l = h);
      g < b && (b = g);
      r < c && (c = r);
      h > e && (e = h);
      g > d && (d = g);
      r > m && (m = r);
    }
    this.min.set(l, b, c);
    this.max.set(e, d, m);
    return this;
  }, setFromPoints:function(a) {
    this.makeEmpty();
    for (var l = 0, b = a.length; l < b; l++) {
      this.expandByPoint(a[l]);
    }
    return this;
  }, setFromCenterAndSize:function(a, b) {
    b = Me.copy(b).multiplyScalar(.5);
    this.min.copy(a).sub(b);
    this.max.copy(a).add(b);
    return this;
  }, setFromObject:function(a) {
    this.makeEmpty();
    return this.expandByObject(a);
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.min.copy(a.min);
    this.max.copy(a.max);
    return this;
  }, makeEmpty:function() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }, isEmpty:function() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }, getCenter:function(a) {
    void 0 === a && (console.warn("THREE.Box3: .getCenter() target is now required"), a = new f);
    return this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5);
  }, getSize:function(a) {
    void 0 === a && (console.warn("THREE.Box3: .getSize() target is now required"), a = new f);
    return this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min);
  }, expandByPoint:function(a) {
    this.min.min(a);
    this.max.max(a);
    return this;
  }, expandByVector:function(a) {
    this.min.sub(a);
    this.max.add(a);
    return this;
  }, expandByScalar:function(a) {
    this.min.addScalar(-a);
    this.max.addScalar(a);
    return this;
  }, expandByObject:function(a) {
    a.updateWorldMatrix(!1, !1);
    var l = a.geometry;
    void 0 !== l && (null === l.boundingBox && l.computeBoundingBox(), eh.copy(l.boundingBox), eh.applyMatrix4(a.matrixWorld), this.union(eh));
    a = a.children;
    l = 0;
    for (var b = a.length; l < b; l++) {
      this.expandByObject(a[l]);
    }
    return this;
  }, containsPoint:function(a) {
    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0;
  }, containsBox:function(a) {
    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z;
  }, getParameter:function(a, b) {
    void 0 === b && (console.warn("THREE.Box3: .getParameter() target is now required"), b = new f);
    return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));
  }, intersectsBox:function(a) {
    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0;
  }, intersectsSphere:function(a) {
    this.clampPoint(a.center, Me);
    return Me.distanceToSquared(a.center) <= a.radius * a.radius;
  }, intersectsPlane:function(a) {
    if (0 < a.normal.x) {
      var l = a.normal.x * this.min.x;
      var b = a.normal.x * this.max.x;
    } else {
      l = a.normal.x * this.max.x, b = a.normal.x * this.min.x;
    }
    0 < a.normal.y ? (l += a.normal.y * this.min.y, b += a.normal.y * this.max.y) : (l += a.normal.y * this.max.y, b += a.normal.y * this.min.y);
    0 < a.normal.z ? (l += a.normal.z * this.min.z, b += a.normal.z * this.max.z) : (l += a.normal.z * this.max.z, b += a.normal.z * this.min.z);
    return l <= -a.constant && b >= -a.constant;
  }, intersectsTriangle:function(a) {
    if (this.isEmpty()) {
      return !1;
    }
    this.getCenter(Ne);
    Sf.subVectors(this.max, Ne);
    Ld.subVectors(a.a, Ne);
    Md.subVectors(a.b, Ne);
    Nd.subVectors(a.c, Ne);
    tc.subVectors(Md, Ld);
    uc.subVectors(Nd, Md);
    Sc.subVectors(Ld, Nd);
    a = [0, -tc.z, tc.y, 0, -uc.z, uc.y, 0, -Sc.z, Sc.y, tc.z, 0, -tc.x, uc.z, 0, -uc.x, Sc.z, 0, -Sc.x, -tc.y, tc.x, 0, -uc.y, uc.x, 0, -Sc.y, Sc.x, 0];
    if (!z(a, Ld, Md, Nd, Sf)) {
      return !1;
    }
    a = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!z(a, Ld, Md, Nd, Sf)) {
      return !1;
    }
    Tf.crossVectors(tc, uc);
    a = [Tf.x, Tf.y, Tf.z];
    return z(a, Ld, Md, Nd, Sf);
  }, clampPoint:function(a, b) {
    void 0 === b && (console.warn("THREE.Box3: .clampPoint() target is now required"), b = new f);
    return b.copy(a).clamp(this.min, this.max);
  }, distanceToPoint:function(a) {
    return Me.copy(a).clamp(this.min, this.max).sub(a).length();
  }, getBoundingSphere:function(a) {
    void 0 === a && console.error("THREE.Box3: .getBoundingSphere() target is now required");
    this.getCenter(a.center);
    a.radius = .5 * this.getSize(Me).length();
    return a;
  }, intersect:function(a) {
    this.min.max(a.min);
    this.max.min(a.max);
    this.isEmpty() && this.makeEmpty();
    return this;
  }, union:function(a) {
    this.min.min(a.min);
    this.max.max(a.max);
    return this;
  }, applyMatrix4:function(a) {
    if (this.isEmpty()) {
      return this;
    }
    $b[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(a);
    $b[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(a);
    $b[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(a);
    $b[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(a);
    $b[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(a);
    $b[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(a);
    $b[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(a);
    $b[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(a);
    this.setFromPoints($b);
    return this;
  }, translate:function(a) {
    this.min.add(a);
    this.max.add(a);
    return this;
  }, equals:function(a) {
    return a.min.equals(this.min) && a.max.equals(this.max);
  }});
  var fk = new x;
  Object.assign(r.prototype, {set:function(a, b) {
    this.center.copy(a);
    this.radius = b;
    return this;
  }, setFromPoints:function(a, b) {
    var l = this.center;
    void 0 !== b ? l.copy(b) : fk.setFromPoints(a).getCenter(l);
    for (var c = b = 0, e = a.length; c < e; c++) {
      b = Math.max(b, l.distanceToSquared(a[c]));
    }
    this.radius = Math.sqrt(b);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.center.copy(a.center);
    this.radius = a.radius;
    return this;
  }, isEmpty:function() {
    return 0 > this.radius;
  }, makeEmpty:function() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }, containsPoint:function(a) {
    return a.distanceToSquared(this.center) <= this.radius * this.radius;
  }, distanceToPoint:function(a) {
    return a.distanceTo(this.center) - this.radius;
  }, intersectsSphere:function(a) {
    var l = this.radius + a.radius;
    return a.center.distanceToSquared(this.center) <= l * l;
  }, intersectsBox:function(a) {
    return a.intersectsSphere(this);
  }, intersectsPlane:function(a) {
    return Math.abs(a.distanceToPoint(this.center)) <= this.radius;
  }, clampPoint:function(a, b) {
    var l = this.center.distanceToSquared(a);
    void 0 === b && (console.warn("THREE.Sphere: .clampPoint() target is now required"), b = new f);
    b.copy(a);
    l > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center));
    return b;
  }, getBoundingBox:function(a) {
    void 0 === a && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), a = new x);
    if (this.isEmpty()) {
      return a.makeEmpty(), a;
    }
    a.set(this.center, this.center);
    a.expandByScalar(this.radius);
    return a;
  }, applyMatrix4:function(a) {
    this.center.applyMatrix4(a);
    this.radius *= a.getMaxScaleOnAxis();
    return this;
  }, translate:function(a) {
    this.center.add(a);
    return this;
  }, equals:function(a) {
    return a.center.equals(this.center) && a.radius === this.radius;
  }});
  var ac = new f, fh = new f, Uf = new f, vc = new f, gh = new f, Vf = new f, hh = new f;
  Object.assign(u.prototype, {set:function(a, b) {
    this.origin.copy(a);
    this.direction.copy(b);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.origin.copy(a.origin);
    this.direction.copy(a.direction);
    return this;
  }, at:function(a, b) {
    void 0 === b && (console.warn("THREE.Ray: .at() target is now required"), b = new f);
    return b.copy(this.direction).multiplyScalar(a).add(this.origin);
  }, lookAt:function(a) {
    this.direction.copy(a).sub(this.origin).normalize();
    return this;
  }, recast:function(a) {
    this.origin.copy(this.at(a, ac));
    return this;
  }, closestPointToPoint:function(a, b) {
    void 0 === b && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), b = new f);
    b.subVectors(a, this.origin);
    a = b.dot(this.direction);
    return 0 > a ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin);
  }, distanceToPoint:function(a) {
    return Math.sqrt(this.distanceSqToPoint(a));
  }, distanceSqToPoint:function(a) {
    var l = ac.subVectors(a, this.origin).dot(this.direction);
    if (0 > l) {
      return this.origin.distanceToSquared(a);
    }
    ac.copy(this.direction).multiplyScalar(l).add(this.origin);
    return ac.distanceToSquared(a);
  }, distanceSqToSegment:function(a, b, c, e) {
    fh.copy(a).add(b).multiplyScalar(.5);
    Uf.copy(b).sub(a).normalize();
    vc.copy(this.origin).sub(fh);
    var l = .5 * a.distanceTo(b), d = -this.direction.dot(Uf), m = vc.dot(this.direction), f = -vc.dot(Uf), k = vc.lengthSq(), h = Math.abs(1 - d * d);
    if (0 < h) {
      a = d * f - m;
      b = d * m - f;
      var g = l * h;
      0 <= a ? b >= -g ? b <= g ? (l = 1 / h, a *= l, b *= l, d = a * (a + d * b + 2 * m) + b * (d * a + b + 2 * f) + k) : (b = l, a = Math.max(0, -(d * b + m)), d = -a * a + b * (b + 2 * f) + k) : (b = -l, a = Math.max(0, -(d * b + m)), d = -a * a + b * (b + 2 * f) + k) : b <= -g ? (a = Math.max(0, -(-d * l + m)), b = 0 < a ? -l : Math.min(Math.max(-l, -f), l), d = -a * a + b * (b + 2 * f) + k) : b <= g ? (a = 0, b = Math.min(Math.max(-l, -f), l), d = b * (b + 2 * f) + k) : (a = Math.max(0, -(d * 
      l + m)), b = 0 < a ? l : Math.min(Math.max(-l, -f), l), d = -a * a + b * (b + 2 * f) + k);
    } else {
      b = 0 < d ? -l : l, a = Math.max(0, -(d * b + m)), d = -a * a + b * (b + 2 * f) + k;
    }
    c && c.copy(this.direction).multiplyScalar(a).add(this.origin);
    e && e.copy(Uf).multiplyScalar(b).add(fh);
    return d;
  }, intersectSphere:function(a, b) {
    ac.subVectors(a.center, this.origin);
    var l = ac.dot(this.direction), c = ac.dot(ac) - l * l;
    a = a.radius * a.radius;
    if (c > a) {
      return null;
    }
    a = Math.sqrt(a - c);
    c = l - a;
    l += a;
    return 0 > c && 0 > l ? null : 0 > c ? this.at(l, b) : this.at(c, b);
  }, intersectsSphere:function(a) {
    return this.distanceSqToPoint(a.center) <= a.radius * a.radius;
  }, distanceToPlane:function(a) {
    var l = a.normal.dot(this.direction);
    if (0 === l) {
      return 0 === a.distanceToPoint(this.origin) ? 0 : null;
    }
    a = -(this.origin.dot(a.normal) + a.constant) / l;
    return 0 <= a ? a : null;
  }, intersectPlane:function(a, b) {
    a = this.distanceToPlane(a);
    return null === a ? null : this.at(a, b);
  }, intersectsPlane:function(a) {
    var l = a.distanceToPoint(this.origin);
    return 0 === l || 0 > a.normal.dot(this.direction) * l ? !0 : !1;
  }, intersectBox:function(a, b) {
    var l = 1 / this.direction.x;
    var c = 1 / this.direction.y;
    var e = 1 / this.direction.z, d = this.origin;
    if (0 <= l) {
      var m = (a.min.x - d.x) * l;
      l *= a.max.x - d.x;
    } else {
      m = (a.max.x - d.x) * l, l *= a.min.x - d.x;
    }
    if (0 <= c) {
      var f = (a.min.y - d.y) * c;
      c *= a.max.y - d.y;
    } else {
      f = (a.max.y - d.y) * c, c *= a.min.y - d.y;
    }
    if (m > c || f > l) {
      return null;
    }
    if (f > m || m !== m) {
      m = f;
    }
    if (c < l || l !== l) {
      l = c;
    }
    0 <= e ? (f = (a.min.z - d.z) * e, a = (a.max.z - d.z) * e) : (f = (a.max.z - d.z) * e, a = (a.min.z - d.z) * e);
    if (m > a || f > l) {
      return null;
    }
    if (f > m || m !== m) {
      m = f;
    }
    if (a < l || l !== l) {
      l = a;
    }
    return 0 > l ? null : this.at(0 <= m ? m : l, b);
  }, intersectsBox:function(a) {
    return null !== this.intersectBox(a, ac);
  }, intersectTriangle:function(a, b, c, e, d) {
    gh.subVectors(b, a);
    Vf.subVectors(c, a);
    hh.crossVectors(gh, Vf);
    b = this.direction.dot(hh);
    if (0 < b) {
      if (e) {
        return null;
      }
      e = 1;
    } else {
      if (0 > b) {
        e = -1, b = -b;
      } else {
        return null;
      }
    }
    vc.subVectors(this.origin, a);
    a = e * this.direction.dot(Vf.crossVectors(vc, Vf));
    if (0 > a) {
      return null;
    }
    c = e * this.direction.dot(gh.cross(vc));
    if (0 > c || a + c > b) {
      return null;
    }
    a = -e * vc.dot(hh);
    return 0 > a ? null : this.at(a / b, d);
  }, applyMatrix4:function(a) {
    this.origin.applyMatrix4(a);
    this.direction.transformDirection(a);
    return this;
  }, equals:function(a) {
    return a.origin.equals(this.origin) && a.direction.equals(this.direction);
  }});
  var ih = new f, gk = new f, hk = new h;
  Object.assign(v.prototype, {isPlane:!0, set:function(a, b) {
    this.normal.copy(a);
    this.constant = b;
    return this;
  }, setComponents:function(a, b, c, e) {
    this.normal.set(a, b, c);
    this.constant = e;
    return this;
  }, setFromNormalAndCoplanarPoint:function(a, b) {
    this.normal.copy(a);
    this.constant = -b.dot(this.normal);
    return this;
  }, setFromCoplanarPoints:function(a, b, c) {
    b = ih.subVectors(c, b).cross(gk.subVectors(a, b)).normalize();
    this.setFromNormalAndCoplanarPoint(b, a);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.normal.copy(a.normal);
    this.constant = a.constant;
    return this;
  }, normalize:function() {
    var a = 1 / this.normal.length();
    this.normal.multiplyScalar(a);
    this.constant *= a;
    return this;
  }, negate:function() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }, distanceToPoint:function(a) {
    return this.normal.dot(a) + this.constant;
  }, distanceToSphere:function(a) {
    return this.distanceToPoint(a.center) - a.radius;
  }, projectPoint:function(a, b) {
    void 0 === b && (console.warn("THREE.Plane: .projectPoint() target is now required"), b = new f);
    return b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a);
  }, intersectLine:function(a, b) {
    void 0 === b && (console.warn("THREE.Plane: .intersectLine() target is now required"), b = new f);
    var l = a.delta(ih), c = this.normal.dot(l);
    if (0 === c) {
      if (0 === this.distanceToPoint(a.start)) {
        return b.copy(a.start);
      }
    } else {
      if (c = -(a.start.dot(this.normal) + this.constant) / c, !(0 > c || 1 < c)) {
        return b.copy(l).multiplyScalar(c).add(a.start);
      }
    }
  }, intersectsLine:function(a) {
    var l = this.distanceToPoint(a.start);
    a = this.distanceToPoint(a.end);
    return 0 > l && 0 < a || 0 > a && 0 < l;
  }, intersectsBox:function(a) {
    return a.intersectsPlane(this);
  }, intersectsSphere:function(a) {
    return a.intersectsPlane(this);
  }, coplanarPoint:function(a) {
    void 0 === a && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), a = new f);
    return a.copy(this.normal).multiplyScalar(-this.constant);
  }, applyMatrix4:function(a, b) {
    b = b || hk.getNormalMatrix(a);
    a = this.coplanarPoint(ih).applyMatrix4(a);
    b = this.normal.applyMatrix3(b).normalize();
    this.constant = -a.dot(b);
    return this;
  }, translate:function(a) {
    this.constant -= a.dot(this.normal);
    return this;
  }, equals:function(a) {
    return a.normal.equals(this.normal) && a.constant === this.constant;
  }});
  var xb = new f, bc = new f, jh = new f, cc = new f, Od = new f, Pd = new f, Fi = new f, kh = new f, lh = new f, mh = new f;
  Object.assign(C, {getNormal:function(a, b, c, e) {
    void 0 === e && (console.warn("THREE.Triangle: .getNormal() target is now required"), e = new f);
    e.subVectors(c, b);
    xb.subVectors(a, b);
    e.cross(xb);
    a = e.lengthSq();
    return 0 < a ? e.multiplyScalar(1 / Math.sqrt(a)) : e.set(0, 0, 0);
  }, getBarycoord:function(a, b, c, e, d) {
    xb.subVectors(e, b);
    bc.subVectors(c, b);
    jh.subVectors(a, b);
    a = xb.dot(xb);
    b = xb.dot(bc);
    c = xb.dot(jh);
    var l = bc.dot(bc);
    e = bc.dot(jh);
    var m = a * l - b * b;
    void 0 === d && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), d = new f);
    if (0 === m) {
      return d.set(-2, -1, -1);
    }
    m = 1 / m;
    l = (l * c - b * e) * m;
    a = (a * e - b * c) * m;
    return d.set(1 - l - a, a, l);
  }, containsPoint:function(a, b, c, e) {
    C.getBarycoord(a, b, c, e, cc);
    return 0 <= cc.x && 0 <= cc.y && 1 >= cc.x + cc.y;
  }, getUV:function(a, b, c, e, d, m, f, k) {
    this.getBarycoord(a, b, c, e, cc);
    k.set(0, 0);
    k.addScaledVector(d, cc.x);
    k.addScaledVector(m, cc.y);
    k.addScaledVector(f, cc.z);
    return k;
  }, isFrontFacing:function(a, b, c, e) {
    xb.subVectors(c, b);
    bc.subVectors(a, b);
    return 0 > xb.cross(bc).dot(e) ? !0 : !1;
  }});
  Object.assign(C.prototype, {set:function(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }, setFromPointsAndIndices:function(a, b, c, e) {
    this.a.copy(a[b]);
    this.b.copy(a[c]);
    this.c.copy(a[e]);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.a.copy(a.a);
    this.b.copy(a.b);
    this.c.copy(a.c);
    return this;
  }, getArea:function() {
    xb.subVectors(this.c, this.b);
    bc.subVectors(this.a, this.b);
    return .5 * xb.cross(bc).length();
  }, getMidpoint:function(a) {
    void 0 === a && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), a = new f);
    return a.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }, getNormal:function(a) {
    return C.getNormal(this.a, this.b, this.c, a);
  }, getPlane:function(a) {
    void 0 === a && (console.warn("THREE.Triangle: .getPlane() target is now required"), a = new v);
    return a.setFromCoplanarPoints(this.a, this.b, this.c);
  }, getBarycoord:function(a, b) {
    return C.getBarycoord(a, this.a, this.b, this.c, b);
  }, getUV:function(a, b, c, e, d) {
    return C.getUV(a, this.a, this.b, this.c, b, c, e, d);
  }, containsPoint:function(a) {
    return C.containsPoint(a, this.a, this.b, this.c);
  }, isFrontFacing:function(a) {
    return C.isFrontFacing(this.a, this.b, this.c, a);
  }, intersectsBox:function(a) {
    return a.intersectsTriangle(this);
  }, closestPointToPoint:function(a, b) {
    void 0 === b && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), b = new f);
    var l = this.a, c = this.b, e = this.c;
    Od.subVectors(c, l);
    Pd.subVectors(e, l);
    kh.subVectors(a, l);
    var d = Od.dot(kh), m = Pd.dot(kh);
    if (0 >= d && 0 >= m) {
      return b.copy(l);
    }
    lh.subVectors(a, c);
    var k = Od.dot(lh), h = Pd.dot(lh);
    if (0 <= k && h <= k) {
      return b.copy(c);
    }
    var g = d * h - k * m;
    if (0 >= g && 0 <= d && 0 >= k) {
      return c = d / (d - k), b.copy(l).addScaledVector(Od, c);
    }
    mh.subVectors(a, e);
    a = Od.dot(mh);
    var r = Pd.dot(mh);
    if (0 <= r && a <= r) {
      return b.copy(e);
    }
    d = a * m - d * r;
    if (0 >= d && 0 <= m && 0 >= r) {
      return g = m / (m - r), b.copy(l).addScaledVector(Pd, g);
    }
    m = k * r - a * h;
    if (0 >= m && 0 <= h - k && 0 <= a - r) {
      return Fi.subVectors(e, c), g = (h - k) / (h - k + (a - r)), b.copy(c).addScaledVector(Fi, g);
    }
    e = 1 / (m + d + g);
    c = d * e;
    g *= e;
    return b.copy(l).addScaledVector(Od, c).addScaledVector(Pd, g);
  }, equals:function(a) {
    return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);
  }});
  var Gi = {aliceblue:15792383, antiquewhite:16444375, aqua:65535, aquamarine:8388564, azure:15794175, beige:16119260, bisque:16770244, black:0, blanchedalmond:16772045, blue:255, blueviolet:9055202, brown:10824234, burlywood:14596231, cadetblue:6266528, chartreuse:8388352, chocolate:13789470, coral:16744272, cornflowerblue:6591981, cornsilk:16775388, crimson:14423100, cyan:65535, darkblue:139, darkcyan:35723, darkgoldenrod:12092939, darkgray:11119017, darkgreen:25600, darkgrey:11119017, darkkhaki:12433259, 
  darkmagenta:9109643, darkolivegreen:5597999, darkorange:16747520, darkorchid:10040012, darkred:9109504, darksalmon:15308410, darkseagreen:9419919, darkslateblue:4734347, darkslategray:3100495, darkslategrey:3100495, darkturquoise:52945, darkviolet:9699539, deeppink:16716947, deepskyblue:49151, dimgray:6908265, dimgrey:6908265, dodgerblue:2003199, firebrick:11674146, floralwhite:16775920, forestgreen:2263842, fuchsia:16711935, gainsboro:14474460, ghostwhite:16316671, gold:16766720, goldenrod:14329120, 
  gray:8421504, green:32768, greenyellow:11403055, grey:8421504, honeydew:15794160, hotpink:16738740, indianred:13458524, indigo:4915330, ivory:16777200, khaki:15787660, lavender:15132410, lavenderblush:16773365, lawngreen:8190976, lemonchiffon:16775885, lightblue:11393254, lightcoral:15761536, lightcyan:14745599, lightgoldenrodyellow:16448210, lightgray:13882323, lightgreen:9498256, lightgrey:13882323, lightpink:16758465, lightsalmon:16752762, lightseagreen:2142890, lightskyblue:8900346, lightslategray:7833753, 
  lightslategrey:7833753, lightsteelblue:11584734, lightyellow:16777184, lime:65280, limegreen:3329330, linen:16445670, magenta:16711935, maroon:8388608, mediumaquamarine:6737322, mediumblue:205, mediumorchid:12211667, mediumpurple:9662683, mediumseagreen:3978097, mediumslateblue:8087790, mediumspringgreen:64154, mediumturquoise:4772300, mediumvioletred:13047173, midnightblue:1644912, mintcream:16121850, mistyrose:16770273, moccasin:16770229, navajowhite:16768685, navy:128, oldlace:16643558, olive:8421376, 
  olivedrab:7048739, orange:16753920, orangered:16729344, orchid:14315734, palegoldenrod:15657130, palegreen:10025880, paleturquoise:11529966, palevioletred:14381203, papayawhip:16773077, peachpuff:16767673, peru:13468991, pink:16761035, plum:14524637, powderblue:11591910, purple:8388736, rebeccapurple:6697881, red:16711680, rosybrown:12357519, royalblue:4286945, saddlebrown:9127187, salmon:16416882, sandybrown:16032864, seagreen:3050327, seashell:16774638, sienna:10506797, silver:12632256, skyblue:8900331, 
  slateblue:6970061, slategray:7372944, slategrey:7372944, snow:16775930, springgreen:65407, steelblue:4620980, tan:13808780, teal:32896, thistle:14204888, tomato:16737095, turquoise:4251856, violet:15631086, wheat:16113331, white:16777215, whitesmoke:16119285, yellow:16776960, yellowgreen:10145074}, $a = {h:0, s:0, l:0}, Wf = {h:0, s:0, l:0};
  Object.assign(A.prototype, {isColor:!0, r:1, g:1, b:1, set:function(a) {
    a && a.isColor ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
    return this;
  }, setScalar:function(a) {
    this.b = this.g = this.r = a;
    return this;
  }, setHex:function(a) {
    a = Math.floor(a);
    this.r = (a >> 16 & 255) / 255;
    this.g = (a >> 8 & 255) / 255;
    this.b = (a & 255) / 255;
    return this;
  }, setRGB:function(a, b, c) {
    this.r = a;
    this.g = b;
    this.b = c;
    return this;
  }, setHSL:function(a, b, c) {
    a = na.euclideanModulo(a, 1);
    b = na.clamp(b, 0, 1);
    c = na.clamp(c, 0, 1);
    0 === b ? this.r = this.g = this.b = c : (b = .5 >= c ? c * (1 + b) : c + b - c * b, c = 2 * c - b, this.r = D(c, b, a + 1 / 3), this.g = D(c, b, a), this.b = D(c, b, a - 1 / 3));
    return this;
  }, setStyle:function(a) {
    function l(l) {
      void 0 !== l && 1 > parseFloat(l) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.");
    }
    var b;
    if (b = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
      var c = b[2];
      switch(b[1]) {
        case "rgb":
        case "rgba":
          if (b = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(c)) {
            return this.r = Math.min(255, parseInt(b[1], 10)) / 255, this.g = Math.min(255, parseInt(b[2], 10)) / 255, this.b = Math.min(255, parseInt(b[3], 10)) / 255, l(b[5]), this;
          }
          if (b = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(c)) {
            return this.r = Math.min(100, parseInt(b[1], 10)) / 100, this.g = Math.min(100, parseInt(b[2], 10)) / 100, this.b = Math.min(100, parseInt(b[3], 10)) / 100, l(b[5]), this;
          }
          break;
        case "hsl":
        case "hsla":
          if (b = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(c)) {
            c = parseFloat(b[1]) / 360;
            var e = parseInt(b[2], 10) / 100, d = parseInt(b[3], 10) / 100;
            l(b[5]);
            return this.setHSL(c, e, d);
          }
      }
    } else {
      if (b = /^#([A-Fa-f0-9]+)$/.exec(a)) {
        b = b[1];
        c = b.length;
        if (3 === c) {
          return this.r = parseInt(b.charAt(0) + b.charAt(0), 16) / 255, this.g = parseInt(b.charAt(1) + b.charAt(1), 16) / 255, this.b = parseInt(b.charAt(2) + b.charAt(2), 16) / 255, this;
        }
        if (6 === c) {
          return this.r = parseInt(b.charAt(0) + b.charAt(1), 16) / 255, this.g = parseInt(b.charAt(2) + b.charAt(3), 16) / 255, this.b = parseInt(b.charAt(4) + b.charAt(5), 16) / 255, this;
        }
      }
    }
    return a && 0 < a.length ? this.setColorName(a) : this;
  }, setColorName:function(a) {
    var l = Gi[a];
    void 0 !== l ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + a);
    return this;
  }, clone:function() {
    return new this.constructor(this.r, this.g, this.b);
  }, copy:function(a) {
    this.r = a.r;
    this.g = a.g;
    this.b = a.b;
    return this;
  }, copyGammaToLinear:function(a, b) {
    void 0 === b && (b = 2);
    this.r = Math.pow(a.r, b);
    this.g = Math.pow(a.g, b);
    this.b = Math.pow(a.b, b);
    return this;
  }, copyLinearToGamma:function(a, b) {
    void 0 === b && (b = 2);
    b = 0 < b ? 1 / b : 1;
    this.r = Math.pow(a.r, b);
    this.g = Math.pow(a.g, b);
    this.b = Math.pow(a.b, b);
    return this;
  }, convertGammaToLinear:function(a) {
    this.copyGammaToLinear(this, a);
    return this;
  }, convertLinearToGamma:function(a) {
    this.copyLinearToGamma(this, a);
    return this;
  }, copySRGBToLinear:function(a) {
    this.r = F(a.r);
    this.g = F(a.g);
    this.b = F(a.b);
    return this;
  }, copyLinearToSRGB:function(a) {
    this.r = B(a.r);
    this.g = B(a.g);
    this.b = B(a.b);
    return this;
  }, convertSRGBToLinear:function() {
    this.copySRGBToLinear(this);
    return this;
  }, convertLinearToSRGB:function() {
    this.copyLinearToSRGB(this);
    return this;
  }, getHex:function() {
    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
  }, getHexString:function() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }, getHSL:function(a) {
    void 0 === a && (console.warn("THREE.Color: .getHSL() target is now required"), a = {h:0, s:0, l:0});
    var l = this.r, b = this.g, c = this.b, e = Math.max(l, b, c), d = Math.min(l, b, c), m, f = (d + e) / 2;
    if (d === e) {
      d = m = 0;
    } else {
      var k = e - d;
      d = .5 >= f ? k / (e + d) : k / (2 - e - d);
      switch(e) {
        case l:
          m = (b - c) / k + (b < c ? 6 : 0);
          break;
        case b:
          m = (c - l) / k + 2;
          break;
        case c:
          m = (l - b) / k + 4;
      }
      m /= 6;
    }
    a.h = m;
    a.s = d;
    a.l = f;
    return a;
  }, getStyle:function() {
    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
  }, offsetHSL:function(a, b, c) {
    this.getHSL($a);
    $a.h += a;
    $a.s += b;
    $a.l += c;
    this.setHSL($a.h, $a.s, $a.l);
    return this;
  }, add:function(a) {
    this.r += a.r;
    this.g += a.g;
    this.b += a.b;
    return this;
  }, addColors:function(a, b) {
    this.r = a.r + b.r;
    this.g = a.g + b.g;
    this.b = a.b + b.b;
    return this;
  }, addScalar:function(a) {
    this.r += a;
    this.g += a;
    this.b += a;
    return this;
  }, sub:function(a) {
    this.r = Math.max(0, this.r - a.r);
    this.g = Math.max(0, this.g - a.g);
    this.b = Math.max(0, this.b - a.b);
    return this;
  }, multiply:function(a) {
    this.r *= a.r;
    this.g *= a.g;
    this.b *= a.b;
    return this;
  }, multiplyScalar:function(a) {
    this.r *= a;
    this.g *= a;
    this.b *= a;
    return this;
  }, lerp:function(a, b) {
    this.r += (a.r - this.r) * b;
    this.g += (a.g - this.g) * b;
    this.b += (a.b - this.b) * b;
    return this;
  }, lerpHSL:function(a, b) {
    this.getHSL($a);
    a.getHSL(Wf);
    a = na.lerp($a.h, Wf.h, b);
    var l = na.lerp($a.s, Wf.s, b);
    b = na.lerp($a.l, Wf.l, b);
    this.setHSL(a, l, b);
    return this;
  }, equals:function(a) {
    return a.r === this.r && a.g === this.g && a.b === this.b;
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    this.r = a[b];
    this.g = a[b + 1];
    this.b = a[b + 2];
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this.r;
    a[b + 1] = this.g;
    a[b + 2] = this.b;
    return a;
  }, toJSON:function() {
    return this.getHex();
  }});
  A.NAMES = Gi;
  Object.assign(E.prototype, {clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.a = a.a;
    this.b = a.b;
    this.c = a.c;
    this.normal.copy(a.normal);
    this.color.copy(a.color);
    this.materialIndex = a.materialIndex;
    for (var b = 0, l = a.vertexNormals.length; b < l; b++) {
      this.vertexNormals[b] = a.vertexNormals[b].clone();
    }
    b = 0;
    for (l = a.vertexColors.length; b < l; b++) {
      this.vertexColors[b] = a.vertexColors[b].clone();
    }
    return this;
  }});
  var lj = 0;
  H.prototype = Object.assign(Object.create(d.prototype), {constructor:H, isMaterial:!0, onBeforeCompile:function() {
  }, setValues:function(a) {
    if (void 0 !== a) {
      for (var b in a) {
        var l = a[b];
        if (void 0 === l) {
          console.warn("THREE.Material: '" + b + "' parameter is undefined.");
        } else {
          if ("shading" === b) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === l ? !0 : !1;
          } else {
            var c = this[b];
            void 0 === c ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : c && c.isColor ? c.set(l) : c && c.isVector3 && l && l.isVector3 ? c.copy(l) : this[b] = l;
          }
        }
      }
    }
  }, toJSON:function(a) {
    function b(a) {
      var b = [], l;
      for (l in a) {
        var c = a[l];
        delete c.metadata;
        b.push(c);
      }
      return b;
    }
    var l = void 0 === a || "string" === typeof a;
    l && (a = {textures:{}, images:{}});
    var c = {metadata:{version:4.5, type:"Material", generator:"Material.toJSON"}};
    c.uuid = this.uuid;
    c.type = this.type;
    "" !== this.name && (c.name = this.name);
    this.color && this.color.isColor && (c.color = this.color.getHex());
    void 0 !== this.roughness && (c.roughness = this.roughness);
    void 0 !== this.metalness && (c.metalness = this.metalness);
    this.sheen && this.sheen.isColor && (c.sheen = this.sheen.getHex());
    this.emissive && this.emissive.isColor && (c.emissive = this.emissive.getHex());
    this.emissiveIntensity && 1 !== this.emissiveIntensity && (c.emissiveIntensity = this.emissiveIntensity);
    this.specular && this.specular.isColor && (c.specular = this.specular.getHex());
    void 0 !== this.shininess && (c.shininess = this.shininess);
    void 0 !== this.clearcoat && (c.clearcoat = this.clearcoat);
    void 0 !== this.clearcoatRoughness && (c.clearcoatRoughness = this.clearcoatRoughness);
    this.clearcoatMap && this.clearcoatMap.isTexture && (c.clearcoatMap = this.clearcoatMap.toJSON(a).uuid);
    this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (c.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(a).uuid);
    this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (c.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(a).uuid, c.clearcoatNormalScale = this.clearcoatNormalScale.toArray());
    this.map && this.map.isTexture && (c.map = this.map.toJSON(a).uuid);
    this.matcap && this.matcap.isTexture && (c.matcap = this.matcap.toJSON(a).uuid);
    this.alphaMap && this.alphaMap.isTexture && (c.alphaMap = this.alphaMap.toJSON(a).uuid);
    this.lightMap && this.lightMap.isTexture && (c.lightMap = this.lightMap.toJSON(a).uuid);
    this.aoMap && this.aoMap.isTexture && (c.aoMap = this.aoMap.toJSON(a).uuid, c.aoMapIntensity = this.aoMapIntensity);
    this.bumpMap && this.bumpMap.isTexture && (c.bumpMap = this.bumpMap.toJSON(a).uuid, c.bumpScale = this.bumpScale);
    this.normalMap && this.normalMap.isTexture && (c.normalMap = this.normalMap.toJSON(a).uuid, c.normalMapType = this.normalMapType, c.normalScale = this.normalScale.toArray());
    this.displacementMap && this.displacementMap.isTexture && (c.displacementMap = this.displacementMap.toJSON(a).uuid, c.displacementScale = this.displacementScale, c.displacementBias = this.displacementBias);
    this.roughnessMap && this.roughnessMap.isTexture && (c.roughnessMap = this.roughnessMap.toJSON(a).uuid);
    this.metalnessMap && this.metalnessMap.isTexture && (c.metalnessMap = this.metalnessMap.toJSON(a).uuid);
    this.emissiveMap && this.emissiveMap.isTexture && (c.emissiveMap = this.emissiveMap.toJSON(a).uuid);
    this.specularMap && this.specularMap.isTexture && (c.specularMap = this.specularMap.toJSON(a).uuid);
    this.envMap && this.envMap.isTexture && (c.envMap = this.envMap.toJSON(a).uuid, c.reflectivity = this.reflectivity, c.refractionRatio = this.refractionRatio, void 0 !== this.combine && (c.combine = this.combine), void 0 !== this.envMapIntensity && (c.envMapIntensity = this.envMapIntensity));
    this.gradientMap && this.gradientMap.isTexture && (c.gradientMap = this.gradientMap.toJSON(a).uuid);
    void 0 !== this.size && (c.size = this.size);
    void 0 !== this.sizeAttenuation && (c.sizeAttenuation = this.sizeAttenuation);
    1 !== this.blending && (c.blending = this.blending);
    !0 === this.flatShading && (c.flatShading = this.flatShading);
    0 !== this.side && (c.side = this.side);
    this.vertexColors && (c.vertexColors = !0);
    1 > this.opacity && (c.opacity = this.opacity);
    !0 === this.transparent && (c.transparent = this.transparent);
    c.depthFunc = this.depthFunc;
    c.depthTest = this.depthTest;
    c.depthWrite = this.depthWrite;
    c.stencilWrite = this.stencilWrite;
    c.stencilWriteMask = this.stencilWriteMask;
    c.stencilFunc = this.stencilFunc;
    c.stencilRef = this.stencilRef;
    c.stencilFuncMask = this.stencilFuncMask;
    c.stencilFail = this.stencilFail;
    c.stencilZFail = this.stencilZFail;
    c.stencilZPass = this.stencilZPass;
    this.rotation && 0 !== this.rotation && (c.rotation = this.rotation);
    !0 === this.polygonOffset && (c.polygonOffset = !0);
    0 !== this.polygonOffsetFactor && (c.polygonOffsetFactor = this.polygonOffsetFactor);
    0 !== this.polygonOffsetUnits && (c.polygonOffsetUnits = this.polygonOffsetUnits);
    this.linewidth && 1 !== this.linewidth && (c.linewidth = this.linewidth);
    void 0 !== this.dashSize && (c.dashSize = this.dashSize);
    void 0 !== this.gapSize && (c.gapSize = this.gapSize);
    void 0 !== this.scale && (c.scale = this.scale);
    !0 === this.dithering && (c.dithering = !0);
    0 < this.alphaTest && (c.alphaTest = this.alphaTest);
    !0 === this.premultipliedAlpha && (c.premultipliedAlpha = this.premultipliedAlpha);
    !0 === this.wireframe && (c.wireframe = this.wireframe);
    1 < this.wireframeLinewidth && (c.wireframeLinewidth = this.wireframeLinewidth);
    "round" !== this.wireframeLinecap && (c.wireframeLinecap = this.wireframeLinecap);
    "round" !== this.wireframeLinejoin && (c.wireframeLinejoin = this.wireframeLinejoin);
    !0 === this.morphTargets && (c.morphTargets = !0);
    !0 === this.morphNormals && (c.morphNormals = !0);
    !0 === this.skinning && (c.skinning = !0);
    !1 === this.visible && (c.visible = !1);
    !1 === this.toneMapped && (c.toneMapped = !1);
    "{}" !== JSON.stringify(this.userData) && (c.userData = this.userData);
    l && (l = b(a.textures), a = b(a.images), 0 < l.length && (c.textures = l), 0 < a.length && (c.images = a));
    return c;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.name = a.name;
    this.fog = a.fog;
    this.blending = a.blending;
    this.side = a.side;
    this.flatShading = a.flatShading;
    this.vertexColors = a.vertexColors;
    this.opacity = a.opacity;
    this.transparent = a.transparent;
    this.blendSrc = a.blendSrc;
    this.blendDst = a.blendDst;
    this.blendEquation = a.blendEquation;
    this.blendSrcAlpha = a.blendSrcAlpha;
    this.blendDstAlpha = a.blendDstAlpha;
    this.blendEquationAlpha = a.blendEquationAlpha;
    this.depthFunc = a.depthFunc;
    this.depthTest = a.depthTest;
    this.depthWrite = a.depthWrite;
    this.stencilWriteMask = a.stencilWriteMask;
    this.stencilFunc = a.stencilFunc;
    this.stencilRef = a.stencilRef;
    this.stencilFuncMask = a.stencilFuncMask;
    this.stencilFail = a.stencilFail;
    this.stencilZFail = a.stencilZFail;
    this.stencilZPass = a.stencilZPass;
    this.stencilWrite = a.stencilWrite;
    var b = a.clippingPlanes, l = null;
    if (null !== b) {
      var c = b.length;
      l = Array(c);
      for (var e = 0; e !== c; ++e) {
        l[e] = b[e].clone();
      }
    }
    this.clippingPlanes = l;
    this.clipIntersection = a.clipIntersection;
    this.clipShadows = a.clipShadows;
    this.shadowSide = a.shadowSide;
    this.colorWrite = a.colorWrite;
    this.precision = a.precision;
    this.polygonOffset = a.polygonOffset;
    this.polygonOffsetFactor = a.polygonOffsetFactor;
    this.polygonOffsetUnits = a.polygonOffsetUnits;
    this.dithering = a.dithering;
    this.alphaTest = a.alphaTest;
    this.premultipliedAlpha = a.premultipliedAlpha;
    this.visible = a.visible;
    this.toneMapped = a.toneMapped;
    this.userData = JSON.parse(JSON.stringify(a.userData));
    return this;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }});
  Object.defineProperty(H.prototype, "needsUpdate", {set:function(a) {
    !0 === a && this.version++;
  }});
  L.prototype = Object.create(H.prototype);
  L.prototype.constructor = L;
  L.prototype.isMeshBasicMaterial = !0;
  L.prototype.copy = function(a) {
    H.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    return this;
  };
  var ta = new f;
  Object.defineProperty(K.prototype, "needsUpdate", {set:function(a) {
    !0 === a && this.version++;
  }});
  Object.assign(K.prototype, {isBufferAttribute:!0, onUploadCallback:function() {
  }, setUsage:function(a) {
    this.usage = a;
    return this;
  }, copy:function(a) {
    this.name = a.name;
    this.array = new a.array.constructor(a.array);
    this.itemSize = a.itemSize;
    this.count = a.count;
    this.normalized = a.normalized;
    this.usage = a.usage;
    return this;
  }, copyAt:function(a, b, c) {
    a *= this.itemSize;
    c *= b.itemSize;
    for (var l = 0, e = this.itemSize; l < e; l++) {
      this.array[a + l] = b.array[c + l];
    }
    return this;
  }, copyArray:function(a) {
    this.array.set(a);
    return this;
  }, copyColorsArray:function(a) {
    for (var b = this.array, l = 0, c = 0, e = a.length; c < e; c++) {
      var d = a[c];
      void 0 === d && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", c), d = new A);
      b[l++] = d.r;
      b[l++] = d.g;
      b[l++] = d.b;
    }
    return this;
  }, copyVector2sArray:function(a) {
    for (var b = this.array, l = 0, c = 0, e = a.length; c < e; c++) {
      var d = a[c];
      void 0 === d && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", c), d = new g);
      b[l++] = d.x;
      b[l++] = d.y;
    }
    return this;
  }, copyVector3sArray:function(a) {
    for (var b = this.array, l = 0, c = 0, e = a.length; c < e; c++) {
      var d = a[c];
      void 0 === d && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", c), d = new f);
      b[l++] = d.x;
      b[l++] = d.y;
      b[l++] = d.z;
    }
    return this;
  }, copyVector4sArray:function(a) {
    for (var b = this.array, l = 0, c = 0, e = a.length; c < e; c++) {
      var d = a[c];
      void 0 === d && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", c), d = new k);
      b[l++] = d.x;
      b[l++] = d.y;
      b[l++] = d.z;
      b[l++] = d.w;
    }
    return this;
  }, applyMatrix3:function(a) {
    for (var b = 0, l = this.count; b < l; b++) {
      ta.x = this.getX(b), ta.y = this.getY(b), ta.z = this.getZ(b), ta.applyMatrix3(a), this.setXYZ(b, ta.x, ta.y, ta.z);
    }
    return this;
  }, applyMatrix4:function(a) {
    for (var b = 0, l = this.count; b < l; b++) {
      ta.x = this.getX(b), ta.y = this.getY(b), ta.z = this.getZ(b), ta.applyMatrix4(a), this.setXYZ(b, ta.x, ta.y, ta.z);
    }
    return this;
  }, applyNormalMatrix:function(a) {
    for (var b = 0, l = this.count; b < l; b++) {
      ta.x = this.getX(b), ta.y = this.getY(b), ta.z = this.getZ(b), ta.applyNormalMatrix(a), this.setXYZ(b, ta.x, ta.y, ta.z);
    }
    return this;
  }, transformDirection:function(a) {
    for (var b = 0, l = this.count; b < l; b++) {
      ta.x = this.getX(b), ta.y = this.getY(b), ta.z = this.getZ(b), ta.transformDirection(a), this.setXYZ(b, ta.x, ta.y, ta.z);
    }
    return this;
  }, set:function(a, b) {
    void 0 === b && (b = 0);
    this.array.set(a, b);
    return this;
  }, getX:function(a) {
    return this.array[a * this.itemSize];
  }, setX:function(a, b) {
    this.array[a * this.itemSize] = b;
    return this;
  }, getY:function(a) {
    return this.array[a * this.itemSize + 1];
  }, setY:function(a, b) {
    this.array[a * this.itemSize + 1] = b;
    return this;
  }, getZ:function(a) {
    return this.array[a * this.itemSize + 2];
  }, setZ:function(a, b) {
    this.array[a * this.itemSize + 2] = b;
    return this;
  }, getW:function(a) {
    return this.array[a * this.itemSize + 3];
  }, setW:function(a, b) {
    this.array[a * this.itemSize + 3] = b;
    return this;
  }, setXY:function(a, b, c) {
    a *= this.itemSize;
    this.array[a + 0] = b;
    this.array[a + 1] = c;
    return this;
  }, setXYZ:function(a, b, c, e) {
    a *= this.itemSize;
    this.array[a + 0] = b;
    this.array[a + 1] = c;
    this.array[a + 2] = e;
    return this;
  }, setXYZW:function(a, b, c, e, d) {
    a *= this.itemSize;
    this.array[a + 0] = b;
    this.array[a + 1] = c;
    this.array[a + 2] = e;
    this.array[a + 3] = d;
    return this;
  }, onUpload:function(a) {
    this.onUploadCallback = a;
    return this;
  }, clone:function() {
    return (new this.constructor(this.array, this.itemSize)).copy(this);
  }, toJSON:function() {
    return {itemSize:this.itemSize, type:this.array.constructor.name, array:Array.prototype.slice.call(this.array), normalized:this.normalized};
  }});
  P.prototype = Object.create(K.prototype);
  P.prototype.constructor = P;
  J.prototype = Object.create(K.prototype);
  J.prototype.constructor = J;
  I.prototype = Object.create(K.prototype);
  I.prototype.constructor = I;
  N.prototype = Object.create(K.prototype);
  N.prototype.constructor = N;
  S.prototype = Object.create(K.prototype);
  S.prototype.constructor = S;
  Q.prototype = Object.create(K.prototype);
  Q.prototype.constructor = Q;
  Z.prototype = Object.create(K.prototype);
  Z.prototype.constructor = Z;
  R.prototype = Object.create(K.prototype);
  R.prototype.constructor = R;
  W.prototype = Object.create(K.prototype);
  W.prototype.constructor = W;
  Object.assign(O.prototype, {computeGroups:function(a) {
    var b = [], l = void 0;
    a = a.faces;
    for (var c = 0; c < a.length; c++) {
      var e = a[c];
      if (e.materialIndex !== l) {
        l = e.materialIndex;
        void 0 !== d && (d.count = 3 * c - d.start, b.push(d));
        var d = {start:3 * c, materialIndex:l};
      }
    }
    void 0 !== d && (d.count = 3 * c - d.start, b.push(d));
    this.groups = b;
  }, fromGeometry:function(a) {
    var b = a.faces, l = a.vertices, c = a.faceVertexUvs, e = c[0] && 0 < c[0].length, d = c[1] && 0 < c[1].length, m = a.morphTargets, f = m.length;
    if (0 < f) {
      var k = [];
      for (var h = 0; h < f; h++) {
        k[h] = {name:m[h].name, data:[]};
      }
      this.morphTargets.position = k;
    }
    var r = a.morphNormals, n = r.length;
    if (0 < n) {
      var q = [];
      for (h = 0; h < n; h++) {
        q[h] = {name:r[h].name, data:[]};
      }
      this.morphTargets.normal = q;
    }
    var p = a.skinIndices, u = a.skinWeights, t = p.length === l.length, y = u.length === l.length;
    0 < l.length && 0 === b.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    for (h = 0; h < b.length; h++) {
      var v = b[h];
      this.vertices.push(l[v.a], l[v.b], l[v.c]);
      var x = v.vertexNormals;
      3 === x.length ? this.normals.push(x[0], x[1], x[2]) : (x = v.normal, this.normals.push(x, x, x));
      x = v.vertexColors;
      3 === x.length ? this.colors.push(x[0], x[1], x[2]) : (x = v.color, this.colors.push(x, x, x));
      !0 === e && (x = c[0][h], void 0 !== x ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new g, new g, new g)));
      !0 === d && (x = c[1][h], void 0 !== x ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new g, new g, new g)));
      for (x = 0; x < f; x++) {
        var U = m[x].vertices;
        k[x].data.push(U[v.a], U[v.b], U[v.c]);
      }
      for (x = 0; x < n; x++) {
        U = r[x].vertexNormals[h], q[x].data.push(U.a, U.b, U.c);
      }
      t && this.skinIndices.push(p[v.a], p[v.b], p[v.c]);
      y && this.skinWeights.push(u[v.a], u[v.b], u[v.c]);
    }
    this.computeGroups(a);
    this.verticesNeedUpdate = a.verticesNeedUpdate;
    this.normalsNeedUpdate = a.normalsNeedUpdate;
    this.colorsNeedUpdate = a.colorsNeedUpdate;
    this.uvsNeedUpdate = a.uvsNeedUpdate;
    this.groupsNeedUpdate = a.groupsNeedUpdate;
    null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
    null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
    return this;
  }});
  var mj = 1, Nb = new n, nh = new q, Qd = new f, fb = new x, Oe = new x, Ka = new f;
  M.prototype = Object.assign(Object.create(d.prototype), {constructor:M, isBufferGeometry:!0, getIndex:function() {
    return this.index;
  }, setIndex:function(a) {
    Array.isArray(a) ? this.index = new (65535 < ca(a) ? Z : S)(a, 1) : this.index = a;
  }, getAttribute:function(a) {
    return this.attributes[a];
  }, setAttribute:function(a, b) {
    this.attributes[a] = b;
    return this;
  }, deleteAttribute:function(a) {
    delete this.attributes[a];
    return this;
  }, addGroup:function(a, b, c) {
    this.groups.push({start:a, count:b, materialIndex:void 0 !== c ? c : 0});
  }, clearGroups:function() {
    this.groups = [];
  }, setDrawRange:function(a, b) {
    this.drawRange.start = a;
    this.drawRange.count = b;
  }, applyMatrix4:function(a) {
    var b = this.attributes.position;
    void 0 !== b && (b.applyMatrix4(a), b.needsUpdate = !0);
    b = this.attributes.normal;
    if (void 0 !== b) {
      var l = (new h).getNormalMatrix(a);
      b.applyNormalMatrix(l);
      b.needsUpdate = !0;
    }
    b = this.attributes.tangent;
    void 0 !== b && (b.transformDirection(a), b.needsUpdate = !0);
    null !== this.boundingBox && this.computeBoundingBox();
    null !== this.boundingSphere && this.computeBoundingSphere();
    return this;
  }, rotateX:function(a) {
    Nb.makeRotationX(a);
    this.applyMatrix4(Nb);
    return this;
  }, rotateY:function(a) {
    Nb.makeRotationY(a);
    this.applyMatrix4(Nb);
    return this;
  }, rotateZ:function(a) {
    Nb.makeRotationZ(a);
    this.applyMatrix4(Nb);
    return this;
  }, translate:function(a, b, c) {
    Nb.makeTranslation(a, b, c);
    this.applyMatrix4(Nb);
    return this;
  }, scale:function(a, b, c) {
    Nb.makeScale(a, b, c);
    this.applyMatrix4(Nb);
    return this;
  }, lookAt:function(a) {
    nh.lookAt(a);
    nh.updateMatrix();
    this.applyMatrix4(nh.matrix);
    return this;
  }, center:function() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(Qd).negate();
    this.translate(Qd.x, Qd.y, Qd.z);
    return this;
  }, setFromObject:function(a) {
    var b = a.geometry;
    if (a.isPoints || a.isLine) {
      a = new R(3 * b.vertices.length, 3);
      var l = new R(3 * b.colors.length, 3);
      this.setAttribute("position", a.copyVector3sArray(b.vertices));
      this.setAttribute("color", l.copyColorsArray(b.colors));
      b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new R(b.lineDistances.length, 1), this.setAttribute("lineDistance", a.copyArray(b.lineDistances)));
      null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone());
      null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone());
    } else {
      a.isMesh && b && b.isGeometry && this.fromGeometry(b);
    }
    return this;
  }, setFromPoints:function(a) {
    for (var b = [], l = 0, c = a.length; l < c; l++) {
      var e = a[l];
      b.push(e.x, e.y, e.z || 0);
    }
    this.setAttribute("position", new R(b, 3));
    return this;
  }, updateFromObject:function(a) {
    var b = a.geometry;
    if (a.isMesh) {
      var l = b.__directGeometry;
      !0 === b.elementsNeedUpdate && (l = void 0, b.elementsNeedUpdate = !1);
      if (void 0 === l) {
        return this.fromGeometry(b);
      }
      l.verticesNeedUpdate = b.verticesNeedUpdate;
      l.normalsNeedUpdate = b.normalsNeedUpdate;
      l.colorsNeedUpdate = b.colorsNeedUpdate;
      l.uvsNeedUpdate = b.uvsNeedUpdate;
      l.groupsNeedUpdate = b.groupsNeedUpdate;
      b.verticesNeedUpdate = !1;
      b.normalsNeedUpdate = !1;
      b.colorsNeedUpdate = !1;
      b.uvsNeedUpdate = !1;
      b.groupsNeedUpdate = !1;
      b = l;
    }
    !0 === b.verticesNeedUpdate && (l = this.attributes.position, void 0 !== l && (l.copyVector3sArray(b.vertices), l.needsUpdate = !0), b.verticesNeedUpdate = !1);
    !0 === b.normalsNeedUpdate && (l = this.attributes.normal, void 0 !== l && (l.copyVector3sArray(b.normals), l.needsUpdate = !0), b.normalsNeedUpdate = !1);
    !0 === b.colorsNeedUpdate && (l = this.attributes.color, void 0 !== l && (l.copyColorsArray(b.colors), l.needsUpdate = !0), b.colorsNeedUpdate = !1);
    b.uvsNeedUpdate && (l = this.attributes.uv, void 0 !== l && (l.copyVector2sArray(b.uvs), l.needsUpdate = !0), b.uvsNeedUpdate = !1);
    b.lineDistancesNeedUpdate && (l = this.attributes.lineDistance, void 0 !== l && (l.copyArray(b.lineDistances), l.needsUpdate = !0), b.lineDistancesNeedUpdate = !1);
    b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1);
    return this;
  }, fromGeometry:function(a) {
    a.__directGeometry = (new O).fromGeometry(a);
    return this.fromDirectGeometry(a.__directGeometry);
  }, fromDirectGeometry:function(a) {
    var b = new Float32Array(3 * a.vertices.length);
    this.setAttribute("position", (new K(b, 3)).copyVector3sArray(a.vertices));
    0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.setAttribute("normal", (new K(b, 3)).copyVector3sArray(a.normals)));
    0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.setAttribute("color", (new K(b, 3)).copyColorsArray(a.colors)));
    0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.setAttribute("uv", (new K(b, 2)).copyVector2sArray(a.uvs)));
    0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.setAttribute("uv2", (new K(b, 2)).copyVector2sArray(a.uvs2)));
    this.groups = a.groups;
    for (var l in a.morphTargets) {
      b = [];
      for (var c = a.morphTargets[l], e = 0, d = c.length; e < d; e++) {
        var m = c[e], f = new R(3 * m.data.length, 3);
        f.name = m.name;
        b.push(f.copyVector3sArray(m.data));
      }
      this.morphAttributes[l] = b;
    }
    0 < a.skinIndices.length && (l = new R(4 * a.skinIndices.length, 4), this.setAttribute("skinIndex", l.copyVector4sArray(a.skinIndices)));
    0 < a.skinWeights.length && (l = new R(4 * a.skinWeights.length, 4), this.setAttribute("skinWeight", l.copyVector4sArray(a.skinWeights)));
    null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
    null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
    return this;
  }, computeBoundingBox:function() {
    null === this.boundingBox && (this.boundingBox = new x);
    var a = this.attributes.position, b = this.morphAttributes.position;
    if (void 0 !== a) {
      if (this.boundingBox.setFromBufferAttribute(a), b) {
        a = 0;
        for (var c = b.length; a < c; a++) {
          fb.setFromBufferAttribute(b[a]), this.morphTargetsRelative ? (Ka.addVectors(this.boundingBox.min, fb.min), this.boundingBox.expandByPoint(Ka), Ka.addVectors(this.boundingBox.max, fb.max), this.boundingBox.expandByPoint(Ka)) : (this.boundingBox.expandByPoint(fb.min), this.boundingBox.expandByPoint(fb.max));
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }, computeBoundingSphere:function() {
    null === this.boundingSphere && (this.boundingSphere = new r);
    var a = this.attributes.position, b = this.morphAttributes.position;
    if (a) {
      var c = this.boundingSphere.center;
      fb.setFromBufferAttribute(a);
      if (b) {
        for (var e = 0, d = b.length; e < d; e++) {
          var m = b[e];
          Oe.setFromBufferAttribute(m);
          this.morphTargetsRelative ? (Ka.addVectors(fb.min, Oe.min), fb.expandByPoint(Ka), Ka.addVectors(fb.max, Oe.max), fb.expandByPoint(Ka)) : (fb.expandByPoint(Oe.min), fb.expandByPoint(Oe.max));
        }
      }
      fb.getCenter(c);
      var f = 0;
      e = 0;
      for (d = a.count; e < d; e++) {
        Ka.fromBufferAttribute(a, e), f = Math.max(f, c.distanceToSquared(Ka));
      }
      if (b) {
        for (e = 0, d = b.length; e < d; e++) {
          m = b[e];
          for (var k = this.morphTargetsRelative, h = 0, g = m.count; h < g; h++) {
            Ka.fromBufferAttribute(m, h), k && (Qd.fromBufferAttribute(a, h), Ka.add(Qd)), f = Math.max(f, c.distanceToSquared(Ka));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(f);
      isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }, computeFaceNormals:function() {
  }, computeVertexNormals:function() {
    var a = this.index, b = this.attributes;
    if (b.position) {
      var c = b.position.array;
      if (void 0 === b.normal) {
        this.setAttribute("normal", new K(new Float32Array(c.length), 3));
      } else {
        for (var e = b.normal.array, d = 0, m = e.length; d < m; d++) {
          e[d] = 0;
        }
      }
      e = b.normal.array;
      var k = new f, h = new f, g = new f, r = new f, n = new f;
      if (a) {
        var q = a.array;
        d = 0;
        for (m = a.count; d < m; d += 3) {
          a = 3 * q[d + 0];
          var p = 3 * q[d + 1];
          var u = 3 * q[d + 2];
          k.fromArray(c, a);
          h.fromArray(c, p);
          g.fromArray(c, u);
          r.subVectors(g, h);
          n.subVectors(k, h);
          r.cross(n);
          e[a] += r.x;
          e[a + 1] += r.y;
          e[a + 2] += r.z;
          e[p] += r.x;
          e[p + 1] += r.y;
          e[p + 2] += r.z;
          e[u] += r.x;
          e[u + 1] += r.y;
          e[u + 2] += r.z;
        }
      } else {
        for (d = 0, m = c.length; d < m; d += 9) {
          k.fromArray(c, d), h.fromArray(c, d + 3), g.fromArray(c, d + 6), r.subVectors(g, h), n.subVectors(k, h), r.cross(n), e[d] = r.x, e[d + 1] = r.y, e[d + 2] = r.z, e[d + 3] = r.x, e[d + 4] = r.y, e[d + 5] = r.z, e[d + 6] = r.x, e[d + 7] = r.y, e[d + 8] = r.z;
        }
      }
      this.normalizeNormals();
      b.normal.needsUpdate = !0;
    }
  }, merge:function(a, b) {
    if (a && a.isBufferGeometry) {
      void 0 === b && (b = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
      var l = this.attributes, c;
      for (c in l) {
        if (void 0 !== a.attributes[c]) {
          var e = l[c].array, d = a.attributes[c], m = d.array, f = d.itemSize * b;
          d = Math.min(m.length, e.length - f);
          for (var k = 0; k < d; k++, f++) {
            e[f] = m[k];
          }
        }
      }
      return this;
    }
    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a);
  }, normalizeNormals:function() {
    for (var a = this.attributes.normal, b = 0, c = a.count; b < c; b++) {
      Ka.x = a.getX(b), Ka.y = a.getY(b), Ka.z = a.getZ(b), Ka.normalize(), a.setXYZ(b, Ka.x, Ka.y, Ka.z);
    }
  }, toNonIndexed:function() {
    function a(a, b) {
      var l = a.array;
      a = a.itemSize;
      for (var c = new l.constructor(b.length * a), e, d = 0, m = 0, f = b.length; m < f; m++) {
        e = b[m] * a;
        for (var k = 0; k < a; k++) {
          c[d++] = l[e++];
        }
      }
      return new K(c, a);
    }
    if (null === this.index) {
      return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
    }
    var b = new M, c = this.index.array, e = this.attributes, d;
    for (d in e) {
      var m = e[d];
      m = a(m, c);
      b.setAttribute(d, m);
    }
    var f = this.morphAttributes;
    for (d in f) {
      var k = [], h = f[d];
      e = 0;
      for (var g = h.length; e < g; e++) {
        m = h[e], m = a(m, c), k.push(m);
      }
      b.morphAttributes[d] = k;
    }
    b.morphTargetsRelative = this.morphTargetsRelative;
    c = this.groups;
    e = 0;
    for (d = c.length; e < d; e++) {
      m = c[e], b.addGroup(m.start, m.count, m.materialIndex);
    }
    return b;
  }, toJSON:function() {
    var a = {metadata:{version:4.5, type:"BufferGeometry", generator:"BufferGeometry.toJSON"}};
    a.uuid = this.uuid;
    a.type = this.type;
    "" !== this.name && (a.name = this.name);
    0 < Object.keys(this.userData).length && (a.userData = this.userData);
    if (void 0 !== this.parameters) {
      var b = this.parameters;
      for (g in b) {
        void 0 !== b[g] && (a[g] = b[g]);
      }
      return a;
    }
    a.data = {attributes:{}};
    b = this.index;
    null !== b && (a.data.index = {type:b.array.constructor.name, array:Array.prototype.slice.call(b.array)});
    var c = this.attributes;
    for (g in c) {
      b = c[g];
      var e = b.toJSON();
      "" !== b.name && (e.name = b.name);
      a.data.attributes[g] = e;
    }
    c = {};
    var d = !1;
    for (g in this.morphAttributes) {
      for (var m = this.morphAttributes[g], f = [], k = 0, h = m.length; k < h; k++) {
        b = m[k], e = b.toJSON(), "" !== b.name && (e.name = b.name), f.push(e);
      }
      0 < f.length && (c[g] = f, d = !0);
    }
    d && (a.data.morphAttributes = c, a.data.morphTargetsRelative = this.morphTargetsRelative);
    var g = this.groups;
    0 < g.length && (a.data.groups = JSON.parse(JSON.stringify(g)));
    g = this.boundingSphere;
    null !== g && (a.data.boundingSphere = {center:g.center.toArray(), radius:g.radius});
    return a;
  }, clone:function() {
    return (new M).copy(this);
  }, copy:function(a) {
    var b;
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingSphere = this.boundingBox = null;
    this.name = a.name;
    var l = a.index;
    null !== l && this.setIndex(l.clone());
    l = a.attributes;
    for (m in l) {
      this.setAttribute(m, l[m].clone());
    }
    var c = a.morphAttributes;
    for (m in c) {
      var e = [], d = c[m];
      l = 0;
      for (b = d.length; l < b; l++) {
        e.push(d[l].clone());
      }
      this.morphAttributes[m] = e;
    }
    this.morphTargetsRelative = a.morphTargetsRelative;
    var m = a.groups;
    l = 0;
    for (b = m.length; l < b; l++) {
      c = m[l], this.addGroup(c.start, c.count, c.materialIndex);
    }
    m = a.boundingBox;
    null !== m && (this.boundingBox = m.clone());
    m = a.boundingSphere;
    null !== m && (this.boundingSphere = m.clone());
    this.drawRange.start = a.drawRange.start;
    this.drawRange.count = a.drawRange.count;
    this.userData = a.userData;
    return this;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }});
  var Hi = new n, Tc = new u, oh = new r, dc = new f, ec = new f, fc = new f, ng = new f, og = new f, pg = new f, We = new f, Xe = new f, Ye = new f, ad = new g, bd = new g, cd = new g, Vd = new f, Ve = new f;
  V.prototype = Object.assign(Object.create(q.prototype), {constructor:V, isMesh:!0, copy:function(a) {
    q.prototype.copy.call(this, a);
    void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice());
    void 0 !== a.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, a.morphTargetDictionary));
    return this;
  }, updateMorphTargets:function() {
    var a = this.geometry;
    if (a.isBufferGeometry) {
      a = a.morphAttributes;
      var b = Object.keys(a);
      if (0 < b.length) {
        var c = a[b[0]];
        if (void 0 !== c) {
          for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) {
            var e = c[a].name || String(a);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[e] = a;
          }
        }
      }
    } else {
      a = a.morphTargets, void 0 !== a && 0 < a.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }, raycast:function(a, b) {
    var l = this.geometry, c = this.material, e = this.matrixWorld;
    if (void 0 !== c && (null === l.boundingSphere && l.computeBoundingSphere(), oh.copy(l.boundingSphere), oh.applyMatrix4(e), !1 !== a.ray.intersectsSphere(oh) && (Hi.getInverse(e), Tc.copy(a.ray).applyMatrix4(Hi), null === l.boundingBox || !1 !== Tc.intersectsBox(l.boundingBox)))) {
      if (l.isBufferGeometry) {
        var d = l.index;
        e = l.attributes.position;
        var m = l.morphAttributes.position, f = l.morphTargetsRelative, k = l.attributes.uv, h = l.attributes.uv2, r = l.groups, n = l.drawRange, q, p;
        if (null !== d) {
          if (Array.isArray(c)) {
            var u = 0;
            for (q = r.length; u < q; u++) {
              var t = r[u];
              var w = c[t.materialIndex];
              var y = Math.max(t.start, n.start);
              for (p = l = Math.min(t.start + t.count, n.start + n.count); y < p; y += 3) {
                l = d.getX(y);
                var v = d.getX(y + 1);
                var x = d.getX(y + 2);
                if (l = ja(this, w, a, Tc, e, m, f, k, h, l, v, x)) {
                  l.faceIndex = Math.floor(y / 3), l.face.materialIndex = t.materialIndex, b.push(l);
                }
              }
            }
          } else {
            for (y = Math.max(0, n.start), l = Math.min(d.count, n.start + n.count), u = y, q = l; u < q; u += 3) {
              if (l = d.getX(u), v = d.getX(u + 1), x = d.getX(u + 2), l = ja(this, c, a, Tc, e, m, f, k, h, l, v, x)) {
                l.faceIndex = Math.floor(u / 3), b.push(l);
              }
            }
          }
        } else {
          if (void 0 !== e) {
            if (Array.isArray(c)) {
              for (u = 0, q = r.length; u < q; u++) {
                for (t = r[u], w = c[t.materialIndex], y = Math.max(t.start, n.start), p = l = Math.min(t.start + t.count, n.start + n.count); y < p; y += 3) {
                  if (l = y, v = y + 1, x = y + 2, l = ja(this, w, a, Tc, e, m, f, k, h, l, v, x)) {
                    l.faceIndex = Math.floor(y / 3), l.face.materialIndex = t.materialIndex, b.push(l);
                  }
                }
              }
            } else {
              for (y = Math.max(0, n.start), l = Math.min(e.count, n.start + n.count), u = y, q = l; u < q; u += 3) {
                if (l = u, v = u + 1, x = u + 2, l = ja(this, c, a, Tc, e, m, f, k, h, l, v, x)) {
                  l.faceIndex = Math.floor(u / 3), b.push(l);
                }
              }
            }
          }
        }
      } else {
        if (l.isGeometry) {
          for (e = Array.isArray(c), m = l.vertices, f = l.faces, l = l.faceVertexUvs[0], 0 < l.length && (d = l), n = 0, u = f.length; n < u; n++) {
            if (q = f[n], l = e ? c[q.materialIndex] : c, void 0 !== l && (k = m[q.a], h = m[q.b], r = m[q.c], l = fa(this, l, a, Tc, k, h, r, Vd))) {
              d && d[n] && (t = d[n], ad.copy(t[0]), bd.copy(t[1]), cd.copy(t[2]), l.uv = C.getUV(Vd, k, h, r, ad, bd, cd, new g)), l.face = q, l.faceIndex = n, b.push(l);
            }
          }
        }
      }
    }
  }, clone:function() {
    return (new this.constructor(this.geometry, this.material)).copy(this);
  }});
  var oj = 0, Ob = new n, ph = new q, Xf = new f;
  X.prototype = Object.assign(Object.create(d.prototype), {constructor:X, isGeometry:!0, applyMatrix4:function(a) {
    for (var b = (new h).getNormalMatrix(a), l = 0, c = this.vertices.length; l < c; l++) {
      this.vertices[l].applyMatrix4(a);
    }
    l = 0;
    for (c = this.faces.length; l < c; l++) {
      a = this.faces[l];
      a.normal.applyMatrix3(b).normalize();
      for (var e = 0, d = a.vertexNormals.length; e < d; e++) {
        a.vertexNormals[e].applyMatrix3(b).normalize();
      }
    }
    null !== this.boundingBox && this.computeBoundingBox();
    null !== this.boundingSphere && this.computeBoundingSphere();
    this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
    return this;
  }, rotateX:function(a) {
    Ob.makeRotationX(a);
    this.applyMatrix4(Ob);
    return this;
  }, rotateY:function(a) {
    Ob.makeRotationY(a);
    this.applyMatrix4(Ob);
    return this;
  }, rotateZ:function(a) {
    Ob.makeRotationZ(a);
    this.applyMatrix4(Ob);
    return this;
  }, translate:function(a, b, c) {
    Ob.makeTranslation(a, b, c);
    this.applyMatrix4(Ob);
    return this;
  }, scale:function(a, b, c) {
    Ob.makeScale(a, b, c);
    this.applyMatrix4(Ob);
    return this;
  }, lookAt:function(a) {
    ph.lookAt(a);
    ph.updateMatrix();
    this.applyMatrix4(ph.matrix);
    return this;
  }, fromBufferGeometry:function(a) {
    function b(a, b, c, e) {
      var d = void 0 === k ? [] : [l.colors[a].clone(), l.colors[b].clone(), l.colors[c].clone()], n = void 0 === m ? [] : [(new f).fromArray(m, 3 * a), (new f).fromArray(m, 3 * b), (new f).fromArray(m, 3 * c)];
      e = new E(a, b, c, n, d, e);
      l.faces.push(e);
      void 0 !== h && l.faceVertexUvs[0].push([(new g).fromArray(h, 2 * a), (new g).fromArray(h, 2 * b), (new g).fromArray(h, 2 * c)]);
      void 0 !== r && l.faceVertexUvs[1].push([(new g).fromArray(r, 2 * a), (new g).fromArray(r, 2 * b), (new g).fromArray(r, 2 * c)]);
    }
    var l = this, c = null !== a.index ? a.index.array : void 0, e = a.attributes;
    if (void 0 === e.position) {
      return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
    }
    var d = e.position.array, m = void 0 !== e.normal ? e.normal.array : void 0, k = void 0 !== e.color ? e.color.array : void 0, h = void 0 !== e.uv ? e.uv.array : void 0, r = void 0 !== e.uv2 ? e.uv2.array : void 0;
    void 0 !== r && (this.faceVertexUvs[1] = []);
    for (e = 0; e < d.length; e += 3) {
      l.vertices.push((new f).fromArray(d, e)), void 0 !== k && l.colors.push((new A).fromArray(k, e));
    }
    var n = a.groups;
    if (0 < n.length) {
      for (e = 0; e < n.length; e++) {
        d = n[e];
        var q = d.start, p = q;
        for (q += d.count; p < q; p += 3) {
          void 0 !== c ? b(c[p], c[p + 1], c[p + 2], d.materialIndex) : b(p, p + 1, p + 2, d.materialIndex);
        }
      }
    } else {
      if (void 0 !== c) {
        for (e = 0; e < c.length; e += 3) {
          b(c[e], c[e + 1], c[e + 2]);
        }
      } else {
        for (e = 0; e < d.length / 3; e += 3) {
          b(e, e + 1, e + 2);
        }
      }
    }
    this.computeFaceNormals();
    null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
    null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
    return this;
  }, center:function() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(Xf).negate();
    this.translate(Xf.x, Xf.y, Xf.z);
    return this;
  }, normalize:function() {
    this.computeBoundingSphere();
    var a = this.boundingSphere.center, b = this.boundingSphere.radius;
    b = 0 === b ? 1 : 1 / b;
    var c = new n;
    c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1);
    this.applyMatrix4(c);
    return this;
  }, computeFaceNormals:function() {
    for (var a = new f, b = new f, c = 0, e = this.faces.length; c < e; c++) {
      var d = this.faces[c], m = this.vertices[d.a], k = this.vertices[d.b];
      a.subVectors(this.vertices[d.c], k);
      b.subVectors(m, k);
      a.cross(b);
      a.normalize();
      d.normal.copy(a);
    }
  }, computeVertexNormals:function(a) {
    void 0 === a && (a = !0);
    var b;
    var l = Array(this.vertices.length);
    var c = 0;
    for (b = this.vertices.length; c < b; c++) {
      l[c] = new f;
    }
    if (a) {
      var e = new f, d = new f;
      a = 0;
      for (c = this.faces.length; a < c; a++) {
        b = this.faces[a];
        var m = this.vertices[b.a];
        var k = this.vertices[b.b];
        var h = this.vertices[b.c];
        e.subVectors(h, k);
        d.subVectors(m, k);
        e.cross(d);
        l[b.a].add(e);
        l[b.b].add(e);
        l[b.c].add(e);
      }
    } else {
      for (this.computeFaceNormals(), a = 0, c = this.faces.length; a < c; a++) {
        b = this.faces[a], l[b.a].add(b.normal), l[b.b].add(b.normal), l[b.c].add(b.normal);
      }
    }
    c = 0;
    for (b = this.vertices.length; c < b; c++) {
      l[c].normalize();
    }
    a = 0;
    for (c = this.faces.length; a < c; a++) {
      b = this.faces[a], m = b.vertexNormals, 3 === m.length ? (m[0].copy(l[b.a]), m[1].copy(l[b.b]), m[2].copy(l[b.c])) : (m[0] = l[b.a].clone(), m[1] = l[b.b].clone(), m[2] = l[b.c].clone());
    }
    0 < this.faces.length && (this.normalsNeedUpdate = !0);
  }, computeFlatVertexNormals:function() {
    var a;
    this.computeFaceNormals();
    var b = 0;
    for (a = this.faces.length; b < a; b++) {
      var c = this.faces[b];
      var e = c.vertexNormals;
      3 === e.length ? (e[0].copy(c.normal), e[1].copy(c.normal), e[2].copy(c.normal)) : (e[0] = c.normal.clone(), e[1] = c.normal.clone(), e[2] = c.normal.clone());
    }
    0 < this.faces.length && (this.normalsNeedUpdate = !0);
  }, computeMorphNormals:function() {
    var a, b;
    var c = 0;
    for (b = this.faces.length; c < b; c++) {
      var e = this.faces[c];
      e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone();
      e.__originalVertexNormals || (e.__originalVertexNormals = []);
      var d = 0;
      for (a = e.vertexNormals.length; d < a; d++) {
        e.__originalVertexNormals[d] ? e.__originalVertexNormals[d].copy(e.vertexNormals[d]) : e.__originalVertexNormals[d] = e.vertexNormals[d].clone();
      }
    }
    var m = new X;
    m.faces = this.faces;
    d = 0;
    for (a = this.morphTargets.length; d < a; d++) {
      if (!this.morphNormals[d]) {
        this.morphNormals[d] = {};
        this.morphNormals[d].faceNormals = [];
        this.morphNormals[d].vertexNormals = [];
        e = this.morphNormals[d].faceNormals;
        var k = this.morphNormals[d].vertexNormals;
        c = 0;
        for (b = this.faces.length; c < b; c++) {
          var h = new f;
          var g = {a:new f, b:new f, c:new f};
          e.push(h);
          k.push(g);
        }
      }
      k = this.morphNormals[d];
      m.vertices = this.morphTargets[d].vertices;
      m.computeFaceNormals();
      m.computeVertexNormals();
      c = 0;
      for (b = this.faces.length; c < b; c++) {
        e = this.faces[c], h = k.faceNormals[c], g = k.vertexNormals[c], h.copy(e.normal), g.a.copy(e.vertexNormals[0]), g.b.copy(e.vertexNormals[1]), g.c.copy(e.vertexNormals[2]);
      }
    }
    c = 0;
    for (b = this.faces.length; c < b; c++) {
      e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals;
    }
  }, computeBoundingBox:function() {
    null === this.boundingBox && (this.boundingBox = new x);
    this.boundingBox.setFromPoints(this.vertices);
  }, computeBoundingSphere:function() {
    null === this.boundingSphere && (this.boundingSphere = new r);
    this.boundingSphere.setFromPoints(this.vertices);
  }, merge:function(a, b, c) {
    if (a && a.isGeometry) {
      var l, e = this.vertices.length, d = this.vertices, m = a.vertices, f = this.faces, k = a.faces, g = this.colors, r = a.colors;
      void 0 === c && (c = 0);
      void 0 !== b && (l = (new h).getNormalMatrix(b));
      for (var n = 0, q = m.length; n < q; n++) {
        var p = m[n].clone();
        void 0 !== b && p.applyMatrix4(b);
        d.push(p);
      }
      n = 0;
      for (q = r.length; n < q; n++) {
        g.push(r[n].clone());
      }
      n = 0;
      for (q = k.length; n < q; n++) {
        m = k[n];
        var u = m.vertexNormals;
        r = m.vertexColors;
        g = new E(m.a + e, m.b + e, m.c + e);
        g.normal.copy(m.normal);
        void 0 !== l && g.normal.applyMatrix3(l).normalize();
        b = 0;
        for (d = u.length; b < d; b++) {
          p = u[b].clone(), void 0 !== l && p.applyMatrix3(l).normalize(), g.vertexNormals.push(p);
        }
        g.color.copy(m.color);
        b = 0;
        for (d = r.length; b < d; b++) {
          p = r[b], g.vertexColors.push(p.clone());
        }
        g.materialIndex = m.materialIndex + c;
        f.push(g);
      }
      n = 0;
      for (q = a.faceVertexUvs.length; n < q; n++) {
        for (c = a.faceVertexUvs[n], void 0 === this.faceVertexUvs[n] && (this.faceVertexUvs[n] = []), b = 0, d = c.length; b < d; b++) {
          l = c[b];
          e = [];
          f = 0;
          for (k = l.length; f < k; f++) {
            e.push(l[f].clone());
          }
          this.faceVertexUvs[n].push(e);
        }
      }
    } else {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a);
    }
  }, mergeMesh:function(a) {
    a && a.isMesh ? (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a);
  }, mergeVertices:function() {
    var a = {}, b = [], c = [], e = Math.pow(10, 4), d;
    var m = 0;
    for (d = this.vertices.length; m < d; m++) {
      var f = this.vertices[m];
      f = Math.round(f.x * e) + "_" + Math.round(f.y * e) + "_" + Math.round(f.z * e);
      void 0 === a[f] ? (a[f] = m, b.push(this.vertices[m]), c[m] = b.length - 1) : c[m] = c[a[f]];
    }
    a = [];
    m = 0;
    for (d = this.faces.length; m < d; m++) {
      for (e = this.faces[m], e.a = c[e.a], e.b = c[e.b], e.c = c[e.c], e = [e.a, e.b, e.c], f = 0; 3 > f; f++) {
        if (e[f] === e[(f + 1) % 3]) {
          a.push(m);
          break;
        }
      }
    }
    for (m = a.length - 1; 0 <= m; m--) {
      for (e = a[m], this.faces.splice(e, 1), c = 0, d = this.faceVertexUvs.length; c < d; c++) {
        this.faceVertexUvs[c].splice(e, 1);
      }
    }
    m = this.vertices.length - b.length;
    this.vertices = b;
    return m;
  }, setFromPoints:function(a) {
    this.vertices = [];
    for (var b = 0, l = a.length; b < l; b++) {
      var c = a[b];
      this.vertices.push(new f(c.x, c.y, c.z || 0));
    }
    return this;
  }, sortFacesByMaterialIndex:function() {
    for (var a = this.faces, b = a.length, c = 0; c < b; c++) {
      a[c]._id = c;
    }
    a.sort(function(a, b) {
      return a.materialIndex - b.materialIndex;
    });
    var e = this.faceVertexUvs[0], d = this.faceVertexUvs[1], m, f;
    e && e.length === b && (m = []);
    d && d.length === b && (f = []);
    for (c = 0; c < b; c++) {
      var k = a[c]._id;
      m && m.push(e[k]);
      f && f.push(d[k]);
    }
    m && (this.faceVertexUvs[0] = m);
    f && (this.faceVertexUvs[1] = f);
  }, toJSON:function() {
    function a(a, b, l) {
      return l ? a | 1 << b : a & ~(1 << b);
    }
    function b(a) {
      var b = a.x.toString() + a.y.toString() + a.z.toString();
      if (void 0 !== g[b]) {
        return g[b];
      }
      g[b] = h.length / 3;
      h.push(a.x, a.y, a.z);
      return g[b];
    }
    function c(a) {
      var b = a.r.toString() + a.g.toString() + a.b.toString();
      if (void 0 !== n[b]) {
        return n[b];
      }
      n[b] = r.length;
      r.push(a.getHex());
      return n[b];
    }
    function e(a) {
      var b = a.x.toString() + a.y.toString();
      if (void 0 !== p[b]) {
        return p[b];
      }
      p[b] = q.length / 2;
      q.push(a.x, a.y);
      return p[b];
    }
    var d = {metadata:{version:4.5, type:"Geometry", generator:"Geometry.toJSON"}};
    d.uuid = this.uuid;
    d.type = this.type;
    "" !== this.name && (d.name = this.name);
    if (void 0 !== this.parameters) {
      var m = this.parameters, f;
      for (f in m) {
        void 0 !== m[f] && (d[f] = m[f]);
      }
      return d;
    }
    m = [];
    for (f = 0; f < this.vertices.length; f++) {
      var k = this.vertices[f];
      m.push(k.x, k.y, k.z);
    }
    k = [];
    var h = [], g = {}, r = [], n = {}, q = [], p = {};
    for (f = 0; f < this.faces.length; f++) {
      var u = this.faces[f], t = void 0 !== this.faceVertexUvs[0][f], y = 0 < u.normal.length(), v = 0 < u.vertexNormals.length, x = 1 !== u.color.r || 1 !== u.color.g || 1 !== u.color.b, U = 0 < u.vertexColors.length, z = 0;
      z = a(z, 0, 0);
      z = a(z, 1, !0);
      z = a(z, 2, !1);
      z = a(z, 3, t);
      z = a(z, 4, y);
      z = a(z, 5, v);
      z = a(z, 6, x);
      z = a(z, 7, U);
      k.push(z);
      k.push(u.a, u.b, u.c);
      k.push(u.materialIndex);
      t && (t = this.faceVertexUvs[0][f], k.push(e(t[0]), e(t[1]), e(t[2])));
      y && k.push(b(u.normal));
      v && (y = u.vertexNormals, k.push(b(y[0]), b(y[1]), b(y[2])));
      x && k.push(c(u.color));
      U && (u = u.vertexColors, k.push(c(u[0]), c(u[1]), c(u[2])));
    }
    d.data = {};
    d.data.vertices = m;
    d.data.normals = h;
    0 < r.length && (d.data.colors = r);
    0 < q.length && (d.data.uvs = [q]);
    d.data.faces = k;
    return d;
  }, clone:function() {
    return (new X).copy(this);
  }, copy:function(a) {
    var b, l, c;
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingSphere = this.boundingBox = null;
    this.name = a.name;
    var e = a.vertices;
    var d = 0;
    for (b = e.length; d < b; d++) {
      this.vertices.push(e[d].clone());
    }
    e = a.colors;
    d = 0;
    for (b = e.length; d < b; d++) {
      this.colors.push(e[d].clone());
    }
    e = a.faces;
    d = 0;
    for (b = e.length; d < b; d++) {
      this.faces.push(e[d].clone());
    }
    d = 0;
    for (b = a.faceVertexUvs.length; d < b; d++) {
      var m = a.faceVertexUvs[d];
      void 0 === this.faceVertexUvs[d] && (this.faceVertexUvs[d] = []);
      e = 0;
      for (l = m.length; e < l; e++) {
        var f = m[e], k = [];
        var h = 0;
        for (c = f.length; h < c; h++) {
          k.push(f[h].clone());
        }
        this.faceVertexUvs[d].push(k);
      }
    }
    h = a.morphTargets;
    d = 0;
    for (b = h.length; d < b; d++) {
      c = {};
      c.name = h[d].name;
      if (void 0 !== h[d].vertices) {
        for (c.vertices = [], e = 0, l = h[d].vertices.length; e < l; e++) {
          c.vertices.push(h[d].vertices[e].clone());
        }
      }
      if (void 0 !== h[d].normals) {
        for (c.normals = [], e = 0, l = h[d].normals.length; e < l; e++) {
          c.normals.push(h[d].normals[e].clone());
        }
      }
      this.morphTargets.push(c);
    }
    h = a.morphNormals;
    d = 0;
    for (b = h.length; d < b; d++) {
      c = {};
      if (void 0 !== h[d].vertexNormals) {
        for (c.vertexNormals = [], e = 0, l = h[d].vertexNormals.length; e < l; e++) {
          m = h[d].vertexNormals[e], f = {}, f.a = m.a.clone(), f.b = m.b.clone(), f.c = m.c.clone(), c.vertexNormals.push(f);
        }
      }
      if (void 0 !== h[d].faceNormals) {
        for (c.faceNormals = [], e = 0, l = h[d].faceNormals.length; e < l; e++) {
          c.faceNormals.push(h[d].faceNormals[e].clone());
        }
      }
      this.morphNormals.push(c);
    }
    e = a.skinWeights;
    d = 0;
    for (b = e.length; d < b; d++) {
      this.skinWeights.push(e[d].clone());
    }
    e = a.skinIndices;
    d = 0;
    for (b = e.length; d < b; d++) {
      this.skinIndices.push(e[d].clone());
    }
    e = a.lineDistances;
    d = 0;
    for (b = e.length; d < b; d++) {
      this.lineDistances.push(e[d]);
    }
    d = a.boundingBox;
    null !== d && (this.boundingBox = d.clone());
    d = a.boundingSphere;
    null !== d && (this.boundingSphere = d.clone());
    this.elementsNeedUpdate = a.elementsNeedUpdate;
    this.verticesNeedUpdate = a.verticesNeedUpdate;
    this.uvsNeedUpdate = a.uvsNeedUpdate;
    this.normalsNeedUpdate = a.normalsNeedUpdate;
    this.colorsNeedUpdate = a.colorsNeedUpdate;
    this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate;
    this.groupsNeedUpdate = a.groupsNeedUpdate;
    return this;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }});
  var qh = function(a) {
    function b(b, l, c, e, d, m) {
      a.call(this);
      this.type = "BoxGeometry";
      this.parameters = {width:b, height:l, depth:c, widthSegments:e, heightSegments:d, depthSegments:m};
      this.fromBufferGeometry(new Wd(b, l, c, e, d, m));
      this.mergeVertices();
    }
    a && (b.__proto__ = a);
    b.prototype = Object.create(a && a.prototype);
    return b.prototype.constructor = b;
  }(X), Wd = function(a) {
    function b(b, l, c, e, d, m) {
      function k(a, b, l, c, e, d, m, k, t, w, y) {
        var v = d / t, x = m / w, U = d / 2, z = m / 2, G = k / 2;
        m = t + 1;
        var C = w + 1, A = d = 0, qa, D, B = new f;
        for (D = 0; D < C; D++) {
          var ba = D * x - z;
          for (qa = 0; qa < m; qa++) {
            B[a] = (qa * v - U) * c, B[b] = ba * e, B[l] = G, r.push(B.x, B.y, B.z), B[a] = 0, B[b] = 0, B[l] = 0 < k ? 1 : -1, n.push(B.x, B.y, B.z), q.push(qa / t), q.push(1 - D / w), d += 1;
          }
        }
        for (D = 0; D < w; D++) {
          for (qa = 0; qa < t; qa++) {
            a = p + qa + m * (D + 1), b = p + (qa + 1) + m * (D + 1), l = p + (qa + 1) + m * D, g.push(p + qa + m * D, a, l), g.push(a, b, l), A += 6;
          }
        }
        h.addGroup(u, A, y);
        u += A;
        p += d;
      }
      a.call(this);
      this.type = "BoxBufferGeometry";
      this.parameters = {width:b, height:l, depth:c, widthSegments:e, heightSegments:d, depthSegments:m};
      var h = this;
      b = b || 1;
      l = l || 1;
      c = c || 1;
      e = Math.floor(e) || 1;
      d = Math.floor(d) || 1;
      m = Math.floor(m) || 1;
      var g = [], r = [], n = [], q = [], p = 0, u = 0;
      k("z", "y", "x", -1, -1, c, l, b, m, d, 0);
      k("z", "y", "x", 1, -1, c, l, -b, m, d, 1);
      k("x", "z", "y", 1, 1, b, c, l, e, m, 2);
      k("x", "z", "y", 1, -1, b, c, -l, e, m, 3);
      k("x", "y", "z", 1, -1, b, l, c, e, d, 4);
      k("x", "y", "z", -1, -1, b, l, -c, e, d, 5);
      this.setIndex(g);
      this.setAttribute("position", new R(r, 3));
      this.setAttribute("normal", new R(n, 3));
      this.setAttribute("uv", new R(q, 2));
    }
    a && (b.__proto__ = a);
    b.prototype = Object.create(a && a.prototype);
    return b.prototype.constructor = b;
  }(M), Uh = {clone:ea, merge:Y};
  T.prototype = Object.create(H.prototype);
  T.prototype.constructor = T;
  T.prototype.isShaderMaterial = !0;
  T.prototype.copy = function(a) {
    H.prototype.copy.call(this, a);
    this.fragmentShader = a.fragmentShader;
    this.vertexShader = a.vertexShader;
    this.uniforms = ea(a.uniforms);
    this.defines = Object.assign({}, a.defines);
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.lights = a.lights;
    this.clipping = a.clipping;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    this.extensions = a.extensions;
    return this;
  };
  T.prototype.toJSON = function(a) {
    var b = H.prototype.toJSON.call(this, a);
    b.uniforms = {};
    for (var l in this.uniforms) {
      var c = this.uniforms[l].value;
      b.uniforms[l] = c && c.isTexture ? {type:"t", value:c.toJSON(a).uuid} : c && c.isColor ? {type:"c", value:c.getHex()} : c && c.isVector2 ? {type:"v2", value:c.toArray()} : c && c.isVector3 ? {type:"v3", value:c.toArray()} : c && c.isVector4 ? {type:"v4", value:c.toArray()} : c && c.isMatrix3 ? {type:"m3", value:c.toArray()} : c && c.isMatrix4 ? {type:"m4", value:c.toArray()} : {value:c};
    }
    0 < Object.keys(this.defines).length && (b.defines = this.defines);
    b.vertexShader = this.vertexShader;
    b.fragmentShader = this.fragmentShader;
    a = {};
    for (var e in this.extensions) {
      !0 === this.extensions[e] && (a[e] = !0);
    }
    0 < Object.keys(a).length && (b.extensions = a);
    return b;
  };
  ma.prototype = Object.assign(Object.create(q.prototype), {constructor:ma, isCamera:!0, copy:function(a, b) {
    q.prototype.copy.call(this, a, b);
    this.matrixWorldInverse.copy(a.matrixWorldInverse);
    this.projectionMatrix.copy(a.projectionMatrix);
    this.projectionMatrixInverse.copy(a.projectionMatrixInverse);
    return this;
  }, getWorldDirection:function(a) {
    void 0 === a && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), a = new f);
    this.updateMatrixWorld(!0);
    var b = this.matrixWorld.elements;
    return a.set(-b[8], -b[9], -b[10]).normalize();
  }, updateMatrixWorld:function(a) {
    q.prototype.updateMatrixWorld.call(this, a);
    this.matrixWorldInverse.getInverse(this.matrixWorld);
  }, updateWorldMatrix:function(a, b) {
    q.prototype.updateWorldMatrix.call(this, a, b);
    this.matrixWorldInverse.getInverse(this.matrixWorld);
  }, clone:function() {
    return (new this.constructor).copy(this);
  }});
  ka.prototype = Object.assign(Object.create(ma.prototype), {constructor:ka, isPerspectiveCamera:!0, copy:function(a, b) {
    ma.prototype.copy.call(this, a, b);
    this.fov = a.fov;
    this.zoom = a.zoom;
    this.near = a.near;
    this.far = a.far;
    this.focus = a.focus;
    this.aspect = a.aspect;
    this.view = null === a.view ? null : Object.assign({}, a.view);
    this.filmGauge = a.filmGauge;
    this.filmOffset = a.filmOffset;
    return this;
  }, setFocalLength:function(a) {
    a = .5 * this.getFilmHeight() / a;
    this.fov = 2 * na.RAD2DEG * Math.atan(a);
    this.updateProjectionMatrix();
  }, getFocalLength:function() {
    var a = Math.tan(.5 * na.DEG2RAD * this.fov);
    return .5 * this.getFilmHeight() / a;
  }, getEffectiveFOV:function() {
    return 2 * na.RAD2DEG * Math.atan(Math.tan(.5 * na.DEG2RAD * this.fov) / this.zoom);
  }, getFilmWidth:function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }, getFilmHeight:function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }, setViewOffset:function(a, b, c, e, d, m) {
    this.aspect = a / b;
    null === this.view && (this.view = {enabled:!0, fullWidth:1, fullHeight:1, offsetX:0, offsetY:0, width:1, height:1});
    this.view.enabled = !0;
    this.view.fullWidth = a;
    this.view.fullHeight = b;
    this.view.offsetX = c;
    this.view.offsetY = e;
    this.view.width = d;
    this.view.height = m;
    this.updateProjectionMatrix();
  }, clearViewOffset:function() {
    null !== this.view && (this.view.enabled = !1);
    this.updateProjectionMatrix();
  }, updateProjectionMatrix:function() {
    var a = this.near, b = a * Math.tan(.5 * na.DEG2RAD * this.fov) / this.zoom, c = 2 * b, e = this.aspect * c, d = -.5 * e, m = this.view;
    if (null !== this.view && this.view.enabled) {
      var f = m.fullWidth, k = m.fullHeight;
      d += m.offsetX * e / f;
      b -= m.offsetY * c / k;
      e *= m.width / f;
      c *= m.height / k;
    }
    m = this.filmOffset;
    0 !== m && (d += a * m / this.getFilmWidth());
    this.projectionMatrix.makePerspective(d, d + e, b, b - c, a, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  }, toJSON:function(a) {
    a = q.prototype.toJSON.call(this, a);
    a.object.fov = this.fov;
    a.object.zoom = this.zoom;
    a.object.near = this.near;
    a.object.far = this.far;
    a.object.focus = this.focus;
    a.object.aspect = this.aspect;
    null !== this.view && (a.object.view = Object.assign({}, this.view));
    a.object.filmGauge = this.filmGauge;
    a.object.filmOffset = this.filmOffset;
    return a;
  }});
  ua.prototype = Object.create(q.prototype);
  ua.prototype.constructor = ua;
  Aa.prototype = Object.create(c.prototype);
  Aa.prototype.constructor = Aa;
  Aa.prototype.isWebGLCubeRenderTarget = !0;
  Aa.prototype.fromEquirectangularTexture = function(a, b) {
    this.texture.type = b.type;
    this.texture.format = b.format;
    this.texture.encoding = b.encoding;
    var l = new y, c = new T({type:"CubemapFromEquirect", uniforms:ea({tEquirect:{value:null}}), vertexShader:"varying vec3 vWorldDirection;\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", fragmentShader:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}", 
    side:1, blending:0});
    c.uniforms.tEquirect.value = b;
    b = new V(new Wd(5, 5, 5), c);
    l.add(b);
    c = new ua(1, 10, 1);
    c.renderTarget = this;
    c.renderTarget.texture.name = "CubeCameraTexture";
    c.update(a, l);
    b.geometry.dispose();
    b.material.dispose();
    return this;
  };
  Ia.prototype = Object.create(e.prototype);
  Ia.prototype.constructor = Ia;
  Ia.prototype.isDataTexture = !0;
  var Rd = new r, Yf = new f;
  Object.assign(Ga.prototype, {set:function(a, b, c, e, d, m) {
    var l = this.planes;
    l[0].copy(a);
    l[1].copy(b);
    l[2].copy(c);
    l[3].copy(e);
    l[4].copy(d);
    l[5].copy(m);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    for (var b = this.planes, l = 0; 6 > l; l++) {
      b[l].copy(a.planes[l]);
    }
    return this;
  }, setFromProjectionMatrix:function(a) {
    var b = this.planes, l = a.elements;
    a = l[0];
    var c = l[1], e = l[2], d = l[3], m = l[4], f = l[5], k = l[6], h = l[7], g = l[8], r = l[9], n = l[10], q = l[11], p = l[12], u = l[13], t = l[14];
    l = l[15];
    b[0].setComponents(d - a, h - m, q - g, l - p).normalize();
    b[1].setComponents(d + a, h + m, q + g, l + p).normalize();
    b[2].setComponents(d + c, h + f, q + r, l + u).normalize();
    b[3].setComponents(d - c, h - f, q - r, l - u).normalize();
    b[4].setComponents(d - e, h - k, q - n, l - t).normalize();
    b[5].setComponents(d + e, h + k, q + n, l + t).normalize();
    return this;
  }, intersectsObject:function(a) {
    var b = a.geometry;
    null === b.boundingSphere && b.computeBoundingSphere();
    Rd.copy(b.boundingSphere).applyMatrix4(a.matrixWorld);
    return this.intersectsSphere(Rd);
  }, intersectsSprite:function(a) {
    Rd.center.set(0, 0, 0);
    Rd.radius = .7071067811865476;
    Rd.applyMatrix4(a.matrixWorld);
    return this.intersectsSphere(Rd);
  }, intersectsSphere:function(a) {
    var b = this.planes, l = a.center;
    a = -a.radius;
    for (var c = 0; 6 > c; c++) {
      if (b[c].distanceToPoint(l) < a) {
        return !1;
      }
    }
    return !0;
  }, intersectsBox:function(a) {
    for (var b = this.planes, l = 0; 6 > l; l++) {
      var c = b[l];
      Yf.x = 0 < c.normal.x ? a.max.x : a.min.x;
      Yf.y = 0 < c.normal.y ? a.max.y : a.min.y;
      Yf.z = 0 < c.normal.z ? a.max.z : a.min.z;
      if (0 > c.distanceToPoint(Yf)) {
        return !1;
      }
    }
    return !0;
  }, containsPoint:function(a) {
    for (var b = this.planes, l = 0; 6 > l; l++) {
      if (0 > b[l].distanceToPoint(a)) {
        return !1;
      }
    }
    return !0;
  }});
  var aa = {common:{diffuse:{value:new A(15658734)}, opacity:{value:1}, map:{value:null}, uvTransform:{value:new h}, uv2Transform:{value:new h}, alphaMap:{value:null}}, specularmap:{specularMap:{value:null}}, envmap:{envMap:{value:null}, flipEnvMap:{value:-1}, reflectivity:{value:1}, refractionRatio:{value:.98}, maxMipLevel:{value:0}}, aomap:{aoMap:{value:null}, aoMapIntensity:{value:1}}, lightmap:{lightMap:{value:null}, lightMapIntensity:{value:1}}, emissivemap:{emissiveMap:{value:null}}, bumpmap:{bumpMap:{value:null}, 
  bumpScale:{value:1}}, normalmap:{normalMap:{value:null}, normalScale:{value:new g(1, 1)}}, displacementmap:{displacementMap:{value:null}, displacementScale:{value:1}, displacementBias:{value:0}}, roughnessmap:{roughnessMap:{value:null}}, metalnessmap:{metalnessMap:{value:null}}, gradientmap:{gradientMap:{value:null}}, fog:{fogDensity:{value:2.5E-4}, fogNear:{value:1}, fogFar:{value:2E3}, fogColor:{value:new A(16777215)}}, lights:{ambientLightColor:{value:[]}, lightProbe:{value:[]}, directionalLights:{value:[], 
  properties:{direction:{}, color:{}}}, directionalLightShadows:{value:[], properties:{shadowBias:{}, shadowRadius:{}, shadowMapSize:{}}}, directionalShadowMap:{value:[]}, directionalShadowMatrix:{value:[]}, spotLights:{value:[], properties:{color:{}, position:{}, direction:{}, distance:{}, coneCos:{}, penumbraCos:{}, decay:{}}}, spotLightShadows:{value:[], properties:{shadowBias:{}, shadowRadius:{}, shadowMapSize:{}}}, spotShadowMap:{value:[]}, spotShadowMatrix:{value:[]}, pointLights:{value:[], 
  properties:{color:{}, position:{}, decay:{}, distance:{}}}, pointLightShadows:{value:[], properties:{shadowBias:{}, shadowRadius:{}, shadowMapSize:{}, shadowCameraNear:{}, shadowCameraFar:{}}}, pointShadowMap:{value:[]}, pointShadowMatrix:{value:[]}, hemisphereLights:{value:[], properties:{direction:{}, skyColor:{}, groundColor:{}}}, rectAreaLights:{value:[], properties:{color:{}, position:{}, width:{}, height:{}}}}, points:{diffuse:{value:new A(15658734)}, opacity:{value:1}, size:{value:1}, scale:{value:1}, 
  map:{value:null}, alphaMap:{value:null}, uvTransform:{value:new h}}, sprite:{diffuse:{value:new A(15658734)}, opacity:{value:1}, center:{value:new g(.5, .5)}, rotation:{value:0}, map:{value:null}, alphaMap:{value:null}, uvTransform:{value:new h}}};
  va.prototype = Object.create(X.prototype);
  va.prototype.constructor = va;
  xa.prototype = Object.create(M.prototype);
  xa.prototype.constructor = xa;
  var oa = {alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", 
  aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex:"vec3 transformed = vec3( position );", beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs:"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", 
  bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", 
  clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", 
  clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", 
  color_vertex:"#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common:"#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}", 
  cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif", 
  defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", 
  displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", 
  emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", 
  envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", 
  envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", 
  envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", 
  envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", 
  fog_vertex:"#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif", fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", 
  gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", 
  lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", 
  lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", 
  lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_toon_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", 
  lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", 
  lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", 
  lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", 
  lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", 
  lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", 
  lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", 
  logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", 
  map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", 
  map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", 
  morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", 
  morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", 
  normal_fragment_begin:"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", 
  normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", 
  normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif", 
  clearcoat_normal_fragment_begin:"#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif", clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", 
  packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", 
  premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", 
  roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", 
  shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", 
  shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", 
  shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", 
  skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", 
  skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", 
  specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment:"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}", 
  uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", 
  uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", 
  background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", 
  cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", 
  depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", 
  distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", 
  distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", 
  equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", 
  equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", 
  linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", 
  meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", 
  meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", 
  meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", 
  meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", 
  meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", 
  meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", 
  meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", 
  meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", 
  meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", 
  meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", 
  meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", 
  normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", 
  normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", 
  points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", 
  points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", 
  shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert:"#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", 
  sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", 
  sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"}, 
  Ab = {basic:{uniforms:Y([aa.common, aa.specularmap, aa.envmap, aa.aomap, aa.lightmap, aa.fog]), vertexShader:oa.meshbasic_vert, fragmentShader:oa.meshbasic_frag}, lambert:{uniforms:Y([aa.common, aa.specularmap, aa.envmap, aa.aomap, aa.lightmap, aa.emissivemap, aa.fog, aa.lights, {emissive:{value:new A(0)}}]), vertexShader:oa.meshlambert_vert, fragmentShader:oa.meshlambert_frag}, phong:{uniforms:Y([aa.common, aa.specularmap, aa.envmap, aa.aomap, aa.lightmap, aa.emissivemap, aa.bumpmap, aa.normalmap, 
  aa.displacementmap, aa.fog, aa.lights, {emissive:{value:new A(0)}, specular:{value:new A(1118481)}, shininess:{value:30}}]), vertexShader:oa.meshphong_vert, fragmentShader:oa.meshphong_frag}, standard:{uniforms:Y([aa.common, aa.envmap, aa.aomap, aa.lightmap, aa.emissivemap, aa.bumpmap, aa.normalmap, aa.displacementmap, aa.roughnessmap, aa.metalnessmap, aa.fog, aa.lights, {emissive:{value:new A(0)}, roughness:{value:1}, metalness:{value:0}, envMapIntensity:{value:1}}]), vertexShader:oa.meshphysical_vert, 
  fragmentShader:oa.meshphysical_frag}, toon:{uniforms:Y([aa.common, aa.specularmap, aa.aomap, aa.lightmap, aa.emissivemap, aa.bumpmap, aa.normalmap, aa.displacementmap, aa.gradientmap, aa.fog, aa.lights, {emissive:{value:new A(0)}, specular:{value:new A(1118481)}, shininess:{value:30}}]), vertexShader:oa.meshtoon_vert, fragmentShader:oa.meshtoon_frag}, matcap:{uniforms:Y([aa.common, aa.bumpmap, aa.normalmap, aa.displacementmap, aa.fog, {matcap:{value:null}}]), vertexShader:oa.meshmatcap_vert, fragmentShader:oa.meshmatcap_frag}, 
  points:{uniforms:Y([aa.points, aa.fog]), vertexShader:oa.points_vert, fragmentShader:oa.points_frag}, dashed:{uniforms:Y([aa.common, aa.fog, {scale:{value:1}, dashSize:{value:1}, totalSize:{value:2}}]), vertexShader:oa.linedashed_vert, fragmentShader:oa.linedashed_frag}, depth:{uniforms:Y([aa.common, aa.displacementmap]), vertexShader:oa.depth_vert, fragmentShader:oa.depth_frag}, normal:{uniforms:Y([aa.common, aa.bumpmap, aa.normalmap, aa.displacementmap, {opacity:{value:1}}]), vertexShader:oa.normal_vert, 
  fragmentShader:oa.normal_frag}, sprite:{uniforms:Y([aa.sprite, aa.fog]), vertexShader:oa.sprite_vert, fragmentShader:oa.sprite_frag}, background:{uniforms:{uvTransform:{value:new h}, t2D:{value:null}}, vertexShader:oa.background_vert, fragmentShader:oa.background_frag}, cube:{uniforms:Y([aa.envmap, {opacity:{value:1}}]), vertexShader:oa.cube_vert, fragmentShader:oa.cube_frag}, equirect:{uniforms:{tEquirect:{value:null}}, vertexShader:oa.equirect_vert, fragmentShader:oa.equirect_frag}, distanceRGBA:{uniforms:Y([aa.common, 
  aa.displacementmap, {referencePosition:{value:new f}, nearDistance:{value:1}, farDistance:{value:1E3}}]), vertexShader:oa.distanceRGBA_vert, fragmentShader:oa.distanceRGBA_frag}, shadow:{uniforms:Y([aa.lights, aa.fog, {color:{value:new A(0)}, opacity:{value:1}}]), vertexShader:oa.shadow_vert, fragmentShader:oa.shadow_frag}};
  Ab.physical = {uniforms:Y([Ab.standard.uniforms, {clearcoat:{value:0}, clearcoatMap:{value:null}, clearcoatRoughness:{value:0}, clearcoatRoughnessMap:{value:null}, clearcoatNormalScale:{value:new g(1, 1)}, clearcoatNormalMap:{value:null}, sheen:{value:new A(0)}, transparency:{value:0}}]), vertexShader:oa.meshphysical_vert, fragmentShader:oa.meshphysical_frag};
  Sa.prototype = Object.create(e.prototype);
  Sa.prototype.constructor = Sa;
  Sa.prototype.isCubeTexture = !0;
  Object.defineProperty(Sa.prototype, "images", {get:function() {
    return this.image;
  }, set:function(a) {
    this.image = a;
  }});
  za.prototype = Object.create(e.prototype);
  za.prototype.constructor = za;
  za.prototype.isDataTexture2DArray = !0;
  hb.prototype = Object.create(e.prototype);
  hb.prototype.constructor = hb;
  hb.prototype.isDataTexture3D = !0;
  var Hh = new e, pj = new za, qj = new hb, Ih = new Sa, Ch = [], Dh = [], Gh = new Float32Array(16), Fh = new Float32Array(9), Eh = new Float32Array(4);
  Jh.prototype.updateCache = function(a) {
    var b = this.cache;
    a instanceof Float32Array && b.length !== a.length && (this.cache = new Float32Array(a.length));
    Ma(b, a);
  };
  Kh.prototype.setValue = function(a, b, c) {
    for (var l = this.seq, e = 0, d = l.length; e !== d; ++e) {
      var m = l[e];
      m.setValue(a, b[m.id], c);
    }
  };
  var qg = /([\w\d_]+)(\])?(\[|\.)?/g;
  kc.prototype.setValue = function(a, b, c, e) {
    b = this.map[b];
    void 0 !== b && b.setValue(a, c, e);
  };
  kc.prototype.setOptional = function(a, b, c) {
    b = b[c];
    void 0 !== b && this.setValue(a, c, b);
  };
  kc.upload = function(a, b, c, e) {
    for (var l = 0, d = b.length; l !== d; ++l) {
      var m = b[l], f = c[m.id];
      !1 !== f.needsUpdate && m.setValue(a, f.value, e);
    }
  };
  kc.seqWithValue = function(a, b) {
    for (var l = [], c = 0, e = a.length; c !== e; ++c) {
      var d = a[c];
      d.id in b && l.push(d);
    }
    return l;
  };
  var Ej = 0, sg = /^[ \t]*#include +<([\w\d./]+)>/gm, Th = /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, Sh = /#pragma unroll_loop_start[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g, Oj = 0;
  lc.prototype = Object.create(H.prototype);
  lc.prototype.constructor = lc;
  lc.prototype.isMeshDepthMaterial = !0;
  lc.prototype.copy = function(a) {
    H.prototype.copy.call(this, a);
    this.depthPacking = a.depthPacking;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.map = a.map;
    this.alphaMap = a.alphaMap;
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    return this;
  };
  mc.prototype = Object.create(H.prototype);
  mc.prototype.constructor = mc;
  mc.prototype.isMeshDistanceMaterial = !0;
  mc.prototype.copy = function(a) {
    H.prototype.copy.call(this, a);
    this.referencePosition.copy(a.referencePosition);
    this.nearDistance = a.nearDistance;
    this.farDistance = a.farDistance;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.map = a.map;
    this.alphaMap = a.alphaMap;
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    return this;
  };
  af.prototype = Object.assign(Object.create(ka.prototype), {constructor:af, isArrayCamera:!0});
  gd.prototype = Object.assign(Object.create(q.prototype), {constructor:gd, isGroup:!0});
  Object.assign(bf.prototype, {constructor:bf, getTargetRaySpace:function() {
    null === this._targetRay && (this._targetRay = new gd, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1);
    return this._targetRay;
  }, getGripSpace:function() {
    null === this._grip && (this._grip = new gd, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1);
    return this._grip;
  }, dispatchEvent:function(a) {
    null !== this._targetRay && this._targetRay.dispatchEvent(a);
    null !== this._grip && this._grip.dispatchEvent(a);
    return this;
  }, disconnect:function(a) {
    this.dispatchEvent({type:"disconnected", data:a});
    null !== this._targetRay && (this._targetRay.visible = !1);
    null !== this._grip && (this._grip.visible = !1);
    return this;
  }, update:function(a, b, c) {
    var l = null, e = null, d = this._targetRay, m = this._grip;
    a && (null !== d && (l = b.getPose(a.targetRaySpace, c), null !== l && (d.matrix.fromArray(l.transform.matrix), d.matrix.decompose(d.position, d.rotation, d.scale))), null !== m && a.gripSpace && (e = b.getPose(a.gripSpace, c), null !== e && (m.matrix.fromArray(e.transform.matrix), m.matrix.decompose(m.position, m.rotation, m.scale))));
    null !== d && (d.visible = null !== l);
    null !== m && (m.visible = null !== e);
    return this;
  }});
  Object.assign(Zh.prototype, d.prototype);
  Object.assign(cf.prototype, {isFogExp2:!0, clone:function() {
    return new cf(this.color, this.density);
  }, toJSON:function() {
    return {type:"FogExp2", color:this.color.getHex(), density:this.density};
  }});
  Object.assign(df.prototype, {isFog:!0, clone:function() {
    return new df(this.color, this.near, this.far);
  }, toJSON:function() {
    return {type:"Fog", color:this.color.getHex(), near:this.near, far:this.far};
  }});
  Object.defineProperty(Sb.prototype, "needsUpdate", {set:function(a) {
    !0 === a && this.version++;
  }});
  Object.assign(Sb.prototype, {isInterleavedBuffer:!0, onUploadCallback:function() {
  }, setUsage:function(a) {
    this.usage = a;
    return this;
  }, copy:function(a) {
    this.array = new a.array.constructor(a.array);
    this.count = a.count;
    this.stride = a.stride;
    this.usage = a.usage;
    return this;
  }, copyAt:function(a, b, c) {
    a *= this.stride;
    c *= b.stride;
    for (var l = 0, e = this.stride; l < e; l++) {
      this.array[a + l] = b.array[c + l];
    }
    return this;
  }, set:function(a, b) {
    void 0 === b && (b = 0);
    this.array.set(a, b);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, onUpload:function(a) {
    this.onUploadCallback = a;
    return this;
  }});
  var Uc = new f;
  Object.defineProperties(ce.prototype, {count:{get:function() {
    return this.data.count;
  }}, array:{get:function() {
    return this.data.array;
  }}});
  Object.assign(ce.prototype, {isInterleavedBufferAttribute:!0, applyMatrix4:function(a) {
    for (var b = 0, l = this.data.count; b < l; b++) {
      Uc.x = this.getX(b), Uc.y = this.getY(b), Uc.z = this.getZ(b), Uc.applyMatrix4(a), this.setXYZ(b, Uc.x, Uc.y, Uc.z);
    }
    return this;
  }, setX:function(a, b) {
    this.data.array[a * this.data.stride + this.offset] = b;
    return this;
  }, setY:function(a, b) {
    this.data.array[a * this.data.stride + this.offset + 1] = b;
    return this;
  }, setZ:function(a, b) {
    this.data.array[a * this.data.stride + this.offset + 2] = b;
    return this;
  }, setW:function(a, b) {
    this.data.array[a * this.data.stride + this.offset + 3] = b;
    return this;
  }, getX:function(a) {
    return this.data.array[a * this.data.stride + this.offset];
  }, getY:function(a) {
    return this.data.array[a * this.data.stride + this.offset + 1];
  }, getZ:function(a) {
    return this.data.array[a * this.data.stride + this.offset + 2];
  }, getW:function(a) {
    return this.data.array[a * this.data.stride + this.offset + 3];
  }, setXY:function(a, b, c) {
    a = a * this.data.stride + this.offset;
    this.data.array[a + 0] = b;
    this.data.array[a + 1] = c;
    return this;
  }, setXYZ:function(a, b, c, e) {
    a = a * this.data.stride + this.offset;
    this.data.array[a + 0] = b;
    this.data.array[a + 1] = c;
    this.data.array[a + 2] = e;
    return this;
  }, setXYZW:function(a, b, c, e, d) {
    a = a * this.data.stride + this.offset;
    this.data.array[a + 0] = b;
    this.data.array[a + 1] = c;
    this.data.array[a + 2] = e;
    this.data.array[a + 3] = d;
    return this;
  }});
  nc.prototype = Object.create(H.prototype);
  nc.prototype.constructor = nc;
  nc.prototype.isSpriteMaterial = !0;
  nc.prototype.copy = function(a) {
    H.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.alphaMap = a.alphaMap;
    this.rotation = a.rotation;
    this.sizeAttenuation = a.sizeAttenuation;
    return this;
  };
  var hd, Pe = new f, Sd = new f, Td = new f, id = new g, ee = new g, ai = new n, Zf = new f, Qe = new f, $f = new f, Ii = new g, rh = new g, Ji = new g;
  de.prototype = Object.assign(Object.create(q.prototype), {constructor:de, isSprite:!0, raycast:function(a, b) {
    null === a.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    Sd.setFromMatrixScale(this.matrixWorld);
    ai.copy(a.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(a.camera.matrixWorldInverse, this.matrixWorld);
    Td.setFromMatrixPosition(this.modelViewMatrix);
    a.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Sd.multiplyScalar(-Td.z);
    var l = this.material.rotation;
    if (0 !== l) {
      var c = Math.cos(l);
      var e = Math.sin(l);
    }
    l = this.center;
    ef(Zf.set(-.5, -.5, 0), Td, l, Sd, e, c);
    ef(Qe.set(.5, -.5, 0), Td, l, Sd, e, c);
    ef($f.set(.5, .5, 0), Td, l, Sd, e, c);
    Ii.set(0, 0);
    rh.set(1, 0);
    Ji.set(1, 1);
    var d = a.ray.intersectTriangle(Zf, Qe, $f, !1, Pe);
    if (null === d && (ef(Qe.set(-.5, .5, 0), Td, l, Sd, e, c), rh.set(0, 1), d = a.ray.intersectTriangle(Zf, $f, Qe, !1, Pe), null === d)) {
      return;
    }
    e = a.ray.origin.distanceTo(Pe);
    e < a.near || e > a.far || b.push({distance:e, point:Pe.clone(), uv:C.getUV(Pe, Zf, Qe, $f, Ii, rh, Ji, new g), face:null, object:this});
  }, clone:function() {
    return (new this.constructor(this.material)).copy(this);
  }, copy:function(a) {
    q.prototype.copy.call(this, a);
    void 0 !== a.center && this.center.copy(a.center);
    return this;
  }});
  var ag = new f, Ki = new f;
  fe.prototype = Object.assign(Object.create(q.prototype), {constructor:fe, isLOD:!0, copy:function(a) {
    q.prototype.copy.call(this, a, !1);
    for (var b = a.levels, l = 0, c = b.length; l < c; l++) {
      var e = b[l];
      this.addLevel(e.object.clone(), e.distance);
    }
    this.autoUpdate = a.autoUpdate;
    return this;
  }, addLevel:function(a, b) {
    void 0 === b && (b = 0);
    b = Math.abs(b);
    for (var l = this.levels, c = 0; c < l.length && !(b < l[c].distance); c++) {
    }
    l.splice(c, 0, {distance:b, object:a});
    this.add(a);
    return this;
  }, getCurrentLevel:function() {
    return this._currentLevel;
  }, getObjectForDistance:function(a) {
    var b = this.levels;
    if (0 < b.length) {
      for (var l = 1, c = b.length; l < c && !(a < b[l].distance); l++) {
      }
      return b[l - 1].object;
    }
    return null;
  }, raycast:function(a, b) {
    if (0 < this.levels.length) {
      ag.setFromMatrixPosition(this.matrixWorld);
      var l = a.ray.origin.distanceTo(ag);
      this.getObjectForDistance(l).raycast(a, b);
    }
  }, update:function(a) {
    var b = this.levels;
    if (1 < b.length) {
      ag.setFromMatrixPosition(a.matrixWorld);
      Ki.setFromMatrixPosition(this.matrixWorld);
      a = ag.distanceTo(Ki) / a.zoom;
      b[0].object.visible = !0;
      for (var l = 1, c = b.length; l < c; l++) {
        if (a >= b[l].distance) {
          b[l - 1].object.visible = !1, b[l].object.visible = !0;
        } else {
          break;
        }
      }
      for (this._currentLevel = l - 1; l < c; l++) {
        b[l].object.visible = !1;
      }
    }
  }, toJSON:function(a) {
    a = q.prototype.toJSON.call(this, a);
    !1 === this.autoUpdate && (a.object.autoUpdate = !1);
    a.object.levels = [];
    for (var b = this.levels, l = 0, c = b.length; l < c; l++) {
      var e = b[l];
      a.object.levels.push({object:e.object.uuid, distance:e.distance});
    }
    return a;
  }});
  ff.prototype = Object.assign(Object.create(V.prototype), {constructor:ff, isSkinnedMesh:!0, bind:function(a, b) {
    this.skeleton = a;
    void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), b = this.matrixWorld);
    this.bindMatrix.copy(b);
    this.bindMatrixInverse.getInverse(b);
  }, pose:function() {
    this.skeleton.pose();
  }, normalizeSkinWeights:function() {
    for (var a = new k, b = this.geometry.attributes.skinWeight, c = 0, e = b.count; c < e; c++) {
      a.x = b.getX(c);
      a.y = b.getY(c);
      a.z = b.getZ(c);
      a.w = b.getW(c);
      var d = 1 / a.manhattanLength();
      Infinity !== d ? a.multiplyScalar(d) : a.set(1, 0, 0, 0);
      b.setXYZW(c, a.x, a.y, a.z, a.w);
    }
  }, updateMatrixWorld:function(a) {
    V.prototype.updateMatrixWorld.call(this, a);
    "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }, clone:function() {
    return (new this.constructor(this.geometry, this.material)).copy(this);
  }, boneTransform:function() {
    var a = new f, b = new k, c = new k, e = new f, d = new n;
    return function(l, m) {
      var f = this.skeleton, k = this.geometry;
      b.fromBufferAttribute(k.attributes.skinIndex, l);
      c.fromBufferAttribute(k.attributes.skinWeight, l);
      a.fromBufferAttribute(k.attributes.position, l).applyMatrix4(this.bindMatrix);
      m.set(0, 0, 0);
      for (l = 0; 4 > l; l++) {
        if (k = c.getComponent(l), 0 !== k) {
          var h = b.getComponent(l);
          d.multiplyMatrices(f.bones[h].matrixWorld, f.boneInverses[h]);
          m.addScaledVector(e.copy(a).applyMatrix4(d), k);
        }
      }
      return m.applyMatrix4(this.bindMatrixInverse);
    };
  }()});
  var Li = new n, ik = new n;
  Object.assign(gf.prototype, {calculateInverses:function() {
    this.boneInverses = [];
    for (var a = 0, b = this.bones.length; a < b; a++) {
      var c = new n;
      this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
      this.boneInverses.push(c);
    }
  }, pose:function() {
    var a, b;
    var c = 0;
    for (b = this.bones.length; c < b; c++) {
      (a = this.bones[c]) && a.matrixWorld.getInverse(this.boneInverses[c]);
    }
    c = 0;
    for (b = this.bones.length; c < b; c++) {
      if (a = this.bones[c]) {
        a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale);
      }
    }
  }, update:function() {
    for (var a = this.bones, b = this.boneInverses, c = this.boneMatrices, e = this.boneTexture, d = 0, m = a.length; d < m; d++) {
      Li.multiplyMatrices(a[d] ? a[d].matrixWorld : ik, b[d]), Li.toArray(c, 16 * d);
    }
    void 0 !== e && (e.needsUpdate = !0);
  }, clone:function() {
    return new gf(this.bones, this.boneInverses);
  }, getBoneByName:function(a) {
    for (var b = 0, l = this.bones.length; b < l; b++) {
      var c = this.bones[b];
      if (c.name === a) {
        return c;
      }
    }
  }, dispose:function() {
    this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0);
  }});
  vg.prototype = Object.assign(Object.create(q.prototype), {constructor:vg, isBone:!0});
  var Mi = new n, Ni = new n, bg = [], Re = new V;
  hf.prototype = Object.assign(Object.create(V.prototype), {constructor:hf, isInstancedMesh:!0, getMatrixAt:function(a, b) {
    b.fromArray(this.instanceMatrix.array, 16 * a);
  }, raycast:function(a, b) {
    var l = this.matrixWorld, c = this.count;
    Re.geometry = this.geometry;
    Re.material = this.material;
    if (void 0 !== Re.material) {
      for (var e = 0; e < c; e++) {
        this.getMatrixAt(e, Mi);
        Ni.multiplyMatrices(l, Mi);
        Re.matrixWorld = Ni;
        Re.raycast(a, bg);
        for (var d = 0, m = bg.length; d < m; d++) {
          var f = bg[d];
          f.instanceId = e;
          f.object = this;
          b.push(f);
        }
        bg.length = 0;
      }
    }
  }, setMatrixAt:function(a, b) {
    b.toArray(this.instanceMatrix.array, 16 * a);
  }, updateMorphTargets:function() {
  }});
  ya.prototype = Object.create(H.prototype);
  ya.prototype.constructor = ya;
  ya.prototype.isLineBasicMaterial = !0;
  ya.prototype.copy = function(a) {
    H.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.linewidth = a.linewidth;
    this.linecap = a.linecap;
    this.linejoin = a.linejoin;
    return this;
  };
  var Oi = new f, Pi = new f, Qi = new n, cg = new u, Se = new r;
  cb.prototype = Object.assign(Object.create(q.prototype), {constructor:cb, isLine:!0, computeLineDistances:function() {
    var a = this.geometry;
    if (a.isBufferGeometry) {
      if (null === a.index) {
        for (var b = a.attributes.position, c = [0], e = 1, d = b.count; e < d; e++) {
          Oi.fromBufferAttribute(b, e - 1), Pi.fromBufferAttribute(b, e), c[e] = c[e - 1], c[e] += Oi.distanceTo(Pi);
        }
        a.setAttribute("lineDistance", new R(c, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else {
      if (a.isGeometry) {
        for (b = a.vertices, c = a.lineDistances, c[0] = 0, e = 1, d = b.length; e < d; e++) {
          c[e] = c[e - 1], c[e] += b[e - 1].distanceTo(b[e]);
        }
      }
    }
    return this;
  }, raycast:function(a, b) {
    var l = this.geometry, c = this.matrixWorld, e = a.params.Line.threshold;
    null === l.boundingSphere && l.computeBoundingSphere();
    Se.copy(l.boundingSphere);
    Se.applyMatrix4(c);
    Se.radius += e;
    if (!1 !== a.ray.intersectsSphere(Se)) {
      Qi.getInverse(c);
      cg.copy(a.ray).applyMatrix4(Qi);
      c = e / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      c *= c;
      var d = new f, m = new f;
      e = new f;
      var k = new f, h = this && this.isLineSegments ? 2 : 1;
      if (l.isBufferGeometry) {
        var g = l.index, r = l.attributes.position.array;
        if (null !== g) {
          g = g.array;
          l = 0;
          for (var n = g.length - 1; l < n; l += h) {
            var q = g[l + 1];
            d.fromArray(r, 3 * g[l]);
            m.fromArray(r, 3 * q);
            q = cg.distanceSqToSegment(d, m, k, e);
            q > c || (k.applyMatrix4(this.matrixWorld), q = a.ray.origin.distanceTo(k), q < a.near || q > a.far || b.push({distance:q, point:e.clone().applyMatrix4(this.matrixWorld), index:l, face:null, faceIndex:null, object:this}));
          }
        } else {
          for (l = 0, n = r.length / 3 - 1; l < n; l += h) {
            d.fromArray(r, 3 * l), m.fromArray(r, 3 * l + 3), q = cg.distanceSqToSegment(d, m, k, e), q > c || (k.applyMatrix4(this.matrixWorld), q = a.ray.origin.distanceTo(k), q < a.near || q > a.far || b.push({distance:q, point:e.clone().applyMatrix4(this.matrixWorld), index:l, face:null, faceIndex:null, object:this}));
          }
        }
      } else {
        if (l.isGeometry) {
          for (d = l.vertices, m = d.length, l = 0; l < m - 1; l += h) {
            q = cg.distanceSqToSegment(d[l], d[l + 1], k, e), q > c || (k.applyMatrix4(this.matrixWorld), q = a.ray.origin.distanceTo(k), q < a.near || q > a.far || b.push({distance:q, point:e.clone().applyMatrix4(this.matrixWorld), index:l, face:null, faceIndex:null, object:this}));
          }
        }
      }
    }
  }, clone:function() {
    return (new this.constructor(this.geometry, this.material)).copy(this);
  }});
  var dg = new f, eg = new f;
  Da.prototype = Object.assign(Object.create(cb.prototype), {constructor:Da, isLineSegments:!0, computeLineDistances:function() {
    var a = this.geometry;
    if (a.isBufferGeometry) {
      if (null === a.index) {
        for (var b = a.attributes.position, c = [], e = 0, d = b.count; e < d; e += 2) {
          dg.fromBufferAttribute(b, e), eg.fromBufferAttribute(b, e + 1), c[e] = 0 === e ? 0 : c[e - 1], c[e + 1] = c[e] + dg.distanceTo(eg);
        }
        a.setAttribute("lineDistance", new R(c, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else {
      if (a.isGeometry) {
        for (b = a.vertices, c = a.lineDistances, e = 0, d = b.length; e < d; e += 2) {
          dg.copy(b[e]), eg.copy(b[e + 1]), c[e] = 0 === e ? 0 : c[e - 1], c[e + 1] = c[e] + dg.distanceTo(eg);
        }
      }
    }
    return this;
  }});
  jf.prototype = Object.assign(Object.create(cb.prototype), {constructor:jf, isLineLoop:!0});
  rb.prototype = Object.create(H.prototype);
  rb.prototype.constructor = rb;
  rb.prototype.isPointsMaterial = !0;
  rb.prototype.copy = function(a) {
    H.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.alphaMap = a.alphaMap;
    this.size = a.size;
    this.sizeAttenuation = a.sizeAttenuation;
    this.morphTargets = a.morphTargets;
    return this;
  };
  var Ri = new n, xg = new u, Te = new r, fg = new f;
  jd.prototype = Object.assign(Object.create(q.prototype), {constructor:jd, isPoints:!0, raycast:function(a, b) {
    var l = this.geometry, c = this.matrixWorld, e = a.params.Points.threshold;
    null === l.boundingSphere && l.computeBoundingSphere();
    Te.copy(l.boundingSphere);
    Te.applyMatrix4(c);
    Te.radius += e;
    if (!1 !== a.ray.intersectsSphere(Te)) {
      if (Ri.getInverse(c), xg.copy(a.ray).applyMatrix4(Ri), e /= (this.scale.x + this.scale.y + this.scale.z) / 3, e *= e, l.isBufferGeometry) {
        var d = l.index;
        l = l.attributes.position.array;
        if (null !== d) {
          var m = d.array;
          d = 0;
          for (var f = m.length; d < f; d++) {
            var k = m[d];
            fg.fromArray(l, 3 * k);
            wg(fg, k, e, c, a, b, this);
          }
        } else {
          for (d = 0, m = l.length / 3; d < m; d++) {
            fg.fromArray(l, 3 * d), wg(fg, d, e, c, a, b, this);
          }
        }
      } else {
        for (l = l.vertices, d = 0, m = l.length; d < m; d++) {
          wg(l[d], d, e, c, a, b, this);
        }
      }
    }
  }, updateMorphTargets:function() {
    var a = this.geometry;
    if (a.isBufferGeometry) {
      a = a.morphAttributes;
      var b = Object.keys(a);
      if (0 < b.length) {
        var c = a[b[0]];
        if (void 0 !== c) {
          for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) {
            var e = c[a].name || String(a);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[e] = a;
          }
        }
      }
    } else {
      a = a.morphTargets, void 0 !== a && 0 < a.length && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }, clone:function() {
    return (new this.constructor(this.geometry, this.material)).copy(this);
  }});
  yg.prototype = Object.assign(Object.create(e.prototype), {constructor:yg, isVideoTexture:!0, update:function() {
    var a = this.image;
    a.readyState >= a.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }});
  kd.prototype = Object.create(e.prototype);
  kd.prototype.constructor = kd;
  kd.prototype.isCompressedTexture = !0;
  ge.prototype = Object.create(e.prototype);
  ge.prototype.constructor = ge;
  ge.prototype.isCanvasTexture = !0;
  he.prototype = Object.create(e.prototype);
  he.prototype.constructor = he;
  he.prototype.isDepthTexture = !0;
  ld.prototype = Object.create(M.prototype);
  ld.prototype.constructor = ld;
  ie.prototype = Object.create(X.prototype);
  ie.prototype.constructor = ie;
  md.prototype = Object.create(M.prototype);
  md.prototype.constructor = md;
  je.prototype = Object.create(X.prototype);
  je.prototype.constructor = je;
  Ya.prototype = Object.create(M.prototype);
  Ya.prototype.constructor = Ya;
  ke.prototype = Object.create(X.prototype);
  ke.prototype.constructor = ke;
  nd.prototype = Object.create(Ya.prototype);
  nd.prototype.constructor = nd;
  le.prototype = Object.create(X.prototype);
  le.prototype.constructor = le;
  Dc.prototype = Object.create(Ya.prototype);
  Dc.prototype.constructor = Dc;
  me.prototype = Object.create(X.prototype);
  me.prototype.constructor = me;
  od.prototype = Object.create(Ya.prototype);
  od.prototype.constructor = od;
  ne.prototype = Object.create(X.prototype);
  ne.prototype.constructor = ne;
  pd.prototype = Object.create(Ya.prototype);
  pd.prototype.constructor = pd;
  oe.prototype = Object.create(X.prototype);
  oe.prototype.constructor = oe;
  Ec.prototype = Object.create(M.prototype);
  Ec.prototype.constructor = Ec;
  Ec.prototype.toJSON = function() {
    var a = M.prototype.toJSON.call(this);
    a.path = this.parameters.path.toJSON();
    return a;
  };
  pe.prototype = Object.create(X.prototype);
  pe.prototype.constructor = pe;
  qd.prototype = Object.create(M.prototype);
  qd.prototype.constructor = qd;
  qe.prototype = Object.create(X.prototype);
  qe.prototype.constructor = qe;
  rd.prototype = Object.create(M.prototype);
  rd.prototype.constructor = rd;
  var jk = {triangulate:function(a, b, c) {
    c = c || 2;
    var l = b && b.length, e = l ? b[0] * c : a.length, d = bi(a, 0, e, c, !0), m = [];
    if (!d || d.next === d.prev) {
      return m;
    }
    var f;
    if (l) {
      var k = c;
      l = [];
      var h;
      var g = 0;
      for (h = b.length; g < h; g++) {
        var r = b[g] * k;
        var n = g < h - 1 ? b[g + 1] * k : a.length;
        r = bi(a, r, n, k, !1);
        r === r.next && (r.steiner = !0);
        l.push(Vj(r));
      }
      l.sort(Tj);
      for (g = 0; g < l.length; g++) {
        k = l[g];
        b = d;
        if (b = Uj(k, b)) {
          k = ei(b, k), oc(b, b.next), oc(k, k.next);
        }
        d = oc(d, d.next);
      }
    }
    if (a.length > 80 * c) {
      var q = f = a[0];
      var p = l = a[1];
      for (k = c; k < e; k += c) {
        g = a[k], b = a[k + 1], g < q && (q = g), b < p && (p = b), g > f && (f = g), b > l && (l = b);
      }
      f = Math.max(f - q, l - p);
      f = 0 !== f ? 1 / f : 0;
    }
    se(d, m, c, q, p, f);
    return m;
  }}, Tb = {area:function(a) {
    for (var b = a.length, l = 0, c = b - 1, e = 0; e < b; c = e++) {
      l += a[c].x * a[e].y - a[e].x * a[c].y;
    }
    return .5 * l;
  }, isClockWise:function(a) {
    return 0 > Tb.area(a);
  }, triangulateShape:function(a, b) {
    var l = [], c = [], e = [];
    fi(a);
    gi(l, a);
    var d = a.length;
    b.forEach(fi);
    for (a = 0; a < b.length; a++) {
      c.push(d), d += b[a].length, gi(l, b[a]);
    }
    b = jk.triangulate(l, c);
    for (a = 0; a < b.length; a += 3) {
      e.push(b.slice(a, a + 3));
    }
    return e;
  }};
  Fc.prototype = Object.create(X.prototype);
  Fc.prototype.constructor = Fc;
  Fc.prototype.toJSON = function() {
    var a = X.prototype.toJSON.call(this);
    return hi(this.parameters.shapes, this.parameters.options, a);
  };
  Gb.prototype = Object.create(M.prototype);
  Gb.prototype.constructor = Gb;
  Gb.prototype.toJSON = function() {
    var a = M.prototype.toJSON.call(this);
    return hi(this.parameters.shapes, this.parameters.options, a);
  };
  var Wj = {generateTopUV:function(a, b, c, e, d) {
    a = b[3 * e];
    e = b[3 * e + 1];
    var l = b[3 * d];
    d = b[3 * d + 1];
    return [new g(b[3 * c], b[3 * c + 1]), new g(a, e), new g(l, d)];
  }, generateSideWallUV:function(a, b, c, e, d, m) {
    a = b[3 * c];
    var l = b[3 * c + 1];
    c = b[3 * c + 2];
    var f = b[3 * e], k = b[3 * e + 1];
    e = b[3 * e + 2];
    var h = b[3 * d], r = b[3 * d + 1];
    d = b[3 * d + 2];
    var n = b[3 * m], q = b[3 * m + 1];
    b = b[3 * m + 2];
    return .01 > Math.abs(l - k) ? [new g(a, 1 - c), new g(f, 1 - e), new g(h, 1 - d), new g(n, 1 - b)] : [new g(l, 1 - c), new g(k, 1 - e), new g(r, 1 - d), new g(q, 1 - b)];
  }};
  ue.prototype = Object.create(X.prototype);
  ue.prototype.constructor = ue;
  td.prototype = Object.create(Gb.prototype);
  td.prototype.constructor = td;
  ve.prototype = Object.create(X.prototype);
  ve.prototype.constructor = ve;
  Gc.prototype = Object.create(M.prototype);
  Gc.prototype.constructor = Gc;
  we.prototype = Object.create(X.prototype);
  we.prototype.constructor = we;
  ud.prototype = Object.create(M.prototype);
  ud.prototype.constructor = ud;
  xe.prototype = Object.create(X.prototype);
  xe.prototype.constructor = xe;
  vd.prototype = Object.create(M.prototype);
  vd.prototype.constructor = vd;
  Hc.prototype = Object.create(X.prototype);
  Hc.prototype.constructor = Hc;
  Hc.prototype.toJSON = function() {
    var a = X.prototype.toJSON.call(this);
    return ii(this.parameters.shapes, a);
  };
  Ic.prototype = Object.create(M.prototype);
  Ic.prototype.constructor = Ic;
  Ic.prototype.toJSON = function() {
    var a = M.prototype.toJSON.call(this);
    return ii(this.parameters.shapes, a);
  };
  wd.prototype = Object.create(M.prototype);
  wd.prototype.constructor = wd;
  Jc.prototype = Object.create(X.prototype);
  Jc.prototype.constructor = Jc;
  Ub.prototype = Object.create(M.prototype);
  Ub.prototype.constructor = Ub;
  ye.prototype = Object.create(Jc.prototype);
  ye.prototype.constructor = ye;
  ze.prototype = Object.create(Ub.prototype);
  ze.prototype.constructor = ze;
  Ae.prototype = Object.create(X.prototype);
  Ae.prototype.constructor = Ae;
  xd.prototype = Object.create(M.prototype);
  xd.prototype.constructor = xd;
  var Xa = Object.freeze({__proto__:null, WireframeGeometry:ld, ParametricGeometry:ie, ParametricBufferGeometry:md, TetrahedronGeometry:ke, TetrahedronBufferGeometry:nd, OctahedronGeometry:le, OctahedronBufferGeometry:Dc, IcosahedronGeometry:me, IcosahedronBufferGeometry:od, DodecahedronGeometry:ne, DodecahedronBufferGeometry:pd, PolyhedronGeometry:je, PolyhedronBufferGeometry:Ya, TubeGeometry:oe, TubeBufferGeometry:Ec, TorusKnotGeometry:pe, TorusKnotBufferGeometry:qd, TorusGeometry:qe, TorusBufferGeometry:rd, 
  TextGeometry:ue, TextBufferGeometry:td, SphereGeometry:ve, SphereBufferGeometry:Gc, RingGeometry:we, RingBufferGeometry:ud, PlaneGeometry:va, PlaneBufferGeometry:xa, LatheGeometry:xe, LatheBufferGeometry:vd, ShapeGeometry:Hc, ShapeBufferGeometry:Ic, ExtrudeGeometry:Fc, ExtrudeBufferGeometry:Gb, EdgesGeometry:wd, ConeGeometry:ye, ConeBufferGeometry:ze, CylinderGeometry:Jc, CylinderBufferGeometry:Ub, CircleGeometry:Ae, CircleBufferGeometry:xd, BoxGeometry:qh, BoxBufferGeometry:Wd});
  Kc.prototype = Object.create(H.prototype);
  Kc.prototype.constructor = Kc;
  Kc.prototype.isShadowMaterial = !0;
  Kc.prototype.copy = function(a) {
    H.prototype.copy.call(this, a);
    this.color.copy(a.color);
    return this;
  };
  Vb.prototype = Object.create(T.prototype);
  Vb.prototype.constructor = Vb;
  Vb.prototype.isRawShaderMaterial = !0;
  Hb.prototype = Object.create(H.prototype);
  Hb.prototype.constructor = Hb;
  Hb.prototype.isMeshStandardMaterial = !0;
  Hb.prototype.copy = function(a) {
    H.prototype.copy.call(this, a);
    this.defines = {STANDARD:""};
    this.color.copy(a.color);
    this.roughness = a.roughness;
    this.metalness = a.metalness;
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.roughnessMap = a.roughnessMap;
    this.metalnessMap = a.metalnessMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.envMapIntensity = a.envMapIntensity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    this.vertexTangents = a.vertexTangents;
    return this;
  };
  Lc.prototype = Object.create(Hb.prototype);
  Lc.prototype.constructor = Lc;
  Lc.prototype.isMeshPhysicalMaterial = !0;
  Lc.prototype.copy = function(a) {
    Hb.prototype.copy.call(this, a);
    this.defines = {STANDARD:"", PHYSICAL:""};
    this.clearcoat = a.clearcoat;
    this.clearcoatMap = a.clearcoatMap;
    this.clearcoatRoughness = a.clearcoatRoughness;
    this.clearcoatRoughnessMap = a.clearcoatRoughnessMap;
    this.clearcoatNormalMap = a.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(a.clearcoatNormalScale);
    this.reflectivity = a.reflectivity;
    this.sheen = a.sheen ? (this.sheen || new A).copy(a.sheen) : null;
    this.transparency = a.transparency;
    return this;
  };
  pc.prototype = Object.create(H.prototype);
  pc.prototype.constructor = pc;
  pc.prototype.isMeshPhongMaterial = !0;
  pc.prototype.copy = function(a) {
    H.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.specular.copy(a.specular);
    this.shininess = a.shininess;
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  Mc.prototype = Object.create(H.prototype);
  Mc.prototype.constructor = Mc;
  Mc.prototype.isMeshToonMaterial = !0;
  Mc.prototype.copy = function(a) {
    H.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.specular.copy(a.specular);
    this.shininess = a.shininess;
    this.map = a.map;
    this.gradientMap = a.gradientMap;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  Nc.prototype = Object.create(H.prototype);
  Nc.prototype.constructor = Nc;
  Nc.prototype.isMeshNormalMaterial = !0;
  Nc.prototype.copy = function(a) {
    H.prototype.copy.call(this, a);
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  Oc.prototype = Object.create(H.prototype);
  Oc.prototype.constructor = Oc;
  Oc.prototype.isMeshLambertMaterial = !0;
  Oc.prototype.copy = function(a) {
    H.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  Pc.prototype = Object.create(H.prototype);
  Pc.prototype.constructor = Pc;
  Pc.prototype.isMeshMatcapMaterial = !0;
  Pc.prototype.copy = function(a) {
    H.prototype.copy.call(this, a);
    this.defines = {MATCAP:""};
    this.color.copy(a.color);
    this.matcap = a.matcap;
    this.map = a.map;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.alphaMap = a.alphaMap;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  Qc.prototype = Object.create(ya.prototype);
  Qc.prototype.constructor = Qc;
  Qc.prototype.isLineDashedMaterial = !0;
  Qc.prototype.copy = function(a) {
    ya.prototype.copy.call(this, a);
    this.scale = a.scale;
    this.dashSize = a.dashSize;
    this.gapSize = a.gapSize;
    return this;
  };
  var kk = Object.freeze({__proto__:null, ShadowMaterial:Kc, SpriteMaterial:nc, RawShaderMaterial:Vb, ShaderMaterial:T, PointsMaterial:rb, MeshPhysicalMaterial:Lc, MeshStandardMaterial:Hb, MeshPhongMaterial:pc, MeshToonMaterial:Mc, MeshNormalMaterial:Nc, MeshLambertMaterial:Oc, MeshDepthMaterial:lc, MeshDistanceMaterial:mc, MeshBasicMaterial:L, MeshMatcapMaterial:Pc, LineDashedMaterial:Qc, LineBasicMaterial:ya, Material:H}), Ba = {arraySlice:function(a, b, c) {
    return Ba.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length)) : a.slice(b, c);
  }, convertArray:function(a, b, c) {
    return !a || !c && a.constructor === b ? a : "number" === typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a);
  }, isTypedArray:function(a) {
    return ArrayBuffer.isView(a) && !(a instanceof DataView);
  }, getKeyframeOrder:function(a) {
    for (var b = a.length, l = Array(b), c = 0; c !== b; ++c) {
      l[c] = c;
    }
    l.sort(function(b, l) {
      return a[b] - a[l];
    });
    return l;
  }, sortedArray:function(a, b, c) {
    for (var l = a.length, e = new a.constructor(l), d = 0, m = 0; m !== l; ++d) {
      for (var f = c[d] * b, k = 0; k !== b; ++k) {
        e[m++] = a[f + k];
      }
    }
    return e;
  }, flattenJSON:function(a, b, c, e) {
    for (var l = 1, d = a[0]; void 0 !== d && void 0 === d[e];) {
      d = a[l++];
    }
    if (void 0 !== d) {
      var m = d[e];
      if (void 0 !== m) {
        if (Array.isArray(m)) {
          do {
            m = d[e], void 0 !== m && (b.push(d.time), c.push.apply(c, m)), d = a[l++];
          } while (void 0 !== d);
        } else {
          if (void 0 !== m.toArray) {
            do {
              m = d[e], void 0 !== m && (b.push(d.time), m.toArray(c, c.length)), d = a[l++];
            } while (void 0 !== d);
          } else {
            do {
              m = d[e], void 0 !== m && (b.push(d.time), c.push(m)), d = a[l++];
            } while (void 0 !== d);
          }
        }
      }
    }
  }, subclip:function(a, b, c, e, d) {
    d = d || 30;
    a = a.clone();
    a.name = b;
    var l = [];
    for (b = 0; b < a.tracks.length; ++b) {
      for (var m = a.tracks[b], f = m.getValueSize(), k = [], h = [], g = 0; g < m.times.length; ++g) {
        var r = m.times[g] * d;
        if (!(r < c || r >= e)) {
          for (k.push(m.times[g]), r = 0; r < f; ++r) {
            h.push(m.values[g * f + r]);
          }
        }
      }
      0 !== k.length && (m.times = Ba.convertArray(k, m.times.constructor), m.values = Ba.convertArray(h, m.values.constructor), l.push(m));
    }
    a.tracks = l;
    c = Infinity;
    for (b = 0; b < a.tracks.length; ++b) {
      c > a.tracks[b].times[0] && (c = a.tracks[b].times[0]);
    }
    for (b = 0; b < a.tracks.length; ++b) {
      a.tracks[b].shift(-1 * c);
    }
    a.resetDuration();
    return a;
  }, makeClipAdditive:function(a, b, c, e) {
    void 0 === b && (b = 0);
    void 0 === c && (c = a);
    if (void 0 === e || 0 >= e) {
      e = 30;
    }
    var l = a.tracks.length;
    b /= e;
    for (e = 0; e < l; ++e) {
      var d = c.tracks[e], m = d.ValueTypeName;
      if ("bool" !== m && "string" !== m) {
        var f = a.tracks.find(function(a) {
          return a.name === d.name && a.ValueTypeName === m;
        });
        if (void 0 !== f) {
          var k = d.getValueSize(), h = d.times.length - 1;
          b <= d.times[0] ? h = Ba.arraySlice(d.values, 0, d.valueSize) : b >= d.times[h] ? h = Ba.arraySlice(d.values, h * k) : (h = d.createInterpolant(), h.evaluate(b), h = h.resultBuffer);
          "quaternion" === m && (new t(h[0], h[1], h[2], h[3])).normalize().conjugate().toArray(h);
          for (var g = f.times.length, r = 0; r < g; ++r) {
            var n = r * k;
            if ("quaternion" === m) {
              t.multiplyQuaternionsFlat(f.values, n, h, 0, f.values, n);
            } else {
              for (var q = 0; q < k; ++q) {
                f.values[n + q] -= h[q];
              }
            }
          }
        }
      }
    }
    a.blendMode = 2501;
    return a;
  }};
  Object.assign(db.prototype, {evaluate:function(a) {
    var b = this.parameterPositions, l = this._cachedIndex, c = b[l], e = b[l - 1];
    a: {
      b: {
        c: {
          d: {
            if (!(a < c)) {
              for (var d = l + 2;;) {
                if (void 0 === c) {
                  if (a < e) {
                    break d;
                  }
                  this._cachedIndex = l = b.length;
                  return this.afterEnd_(l - 1, a, e);
                }
                if (l === d) {
                  break;
                }
                e = c;
                c = b[++l];
                if (a < c) {
                  break b;
                }
              }
              c = b.length;
              break c;
            }
          }
          if (a >= e) {
            break a;
          } else {
            d = b[1];
            a < d && (l = 2, e = d);
            for (d = l - 2;;) {
              if (void 0 === e) {
                return this._cachedIndex = 0, this.beforeStart_(0, a, c);
              }
              if (l === d) {
                break;
              }
              c = e;
              e = b[--l - 1];
              if (a >= e) {
                break b;
              }
            }
            c = l;
            l = 0;
          }
        }
        for (; l < c;) {
          e = l + c >>> 1, a < b[e] ? c = e : l = e + 1;
        }
        c = b[l];
        e = b[l - 1];
        if (void 0 === e) {
          return this._cachedIndex = 0, this.beforeStart_(0, a, c);
        }
        if (void 0 === c) {
          return this._cachedIndex = l = b.length, this.afterEnd_(l - 1, e, a);
        }
      }
      this._cachedIndex = l;
      this.intervalChanged_(l, e, c);
    }
    return this.interpolate_(l, e, a, c);
  }, settings:null, DefaultSettings_:{}, getSettings_:function() {
    return this.settings || this.DefaultSettings_;
  }, copySampleValue_:function(a) {
    var b = this.resultBuffer, l = this.sampleValues, c = this.valueSize;
    a *= c;
    for (var e = 0; e !== c; ++e) {
      b[e] = l[a + e];
    }
    return b;
  }, interpolate_:function() {
    throw Error("call to abstract method");
  }, intervalChanged_:function() {
  }});
  Object.assign(db.prototype, {beforeStart_:db.prototype.copySampleValue_, afterEnd_:db.prototype.copySampleValue_});
  nf.prototype = Object.assign(Object.create(db.prototype), {constructor:nf, DefaultSettings_:{endingStart:2400, endingEnd:2400}, intervalChanged_:function(a, b, c) {
    var l = this.parameterPositions, e = a - 2, d = a + 1, m = l[e], f = l[d];
    if (void 0 === m) {
      switch(this.getSettings_().endingStart) {
        case 2401:
          e = a;
          m = 2 * b - c;
          break;
        case 2402:
          e = l.length - 2;
          m = b + l[e] - l[e + 1];
          break;
        default:
          e = a, m = c;
      }
    }
    if (void 0 === f) {
      switch(this.getSettings_().endingEnd) {
        case 2401:
          d = a;
          f = 2 * c - b;
          break;
        case 2402:
          d = 1;
          f = c + l[1] - l[0];
          break;
        default:
          d = a - 1, f = b;
      }
    }
    a = .5 * (c - b);
    l = this.valueSize;
    this._weightPrev = a / (b - m);
    this._weightNext = a / (f - c);
    this._offsetPrev = e * l;
    this._offsetNext = d * l;
  }, interpolate_:function(a, b, c, e) {
    var l = this.resultBuffer, d = this.sampleValues, m = this.valueSize;
    a *= m;
    var f = a - m, k = this._offsetPrev, h = this._offsetNext, g = this._weightPrev, r = this._weightNext, n = (c - b) / (e - b);
    c = n * n;
    e = c * n;
    b = -g * e + 2 * g * c - g * n;
    g = (1 + g) * e + (-1.5 - 2 * g) * c + (-.5 + g) * n + 1;
    n = (-1 - r) * e + (1.5 + r) * c + .5 * n;
    r = r * e - r * c;
    for (c = 0; c !== m; ++c) {
      l[c] = b * d[k + c] + g * d[f + c] + n * d[a + c] + r * d[h + c];
    }
    return l;
  }});
  Be.prototype = Object.assign(Object.create(db.prototype), {constructor:Be, interpolate_:function(a, b, c, e) {
    var l = this.resultBuffer, d = this.sampleValues, m = this.valueSize;
    a *= m;
    var f = a - m;
    b = (c - b) / (e - b);
    c = 1 - b;
    for (e = 0; e !== m; ++e) {
      l[e] = d[f + e] * c + d[a + e] * b;
    }
    return l;
  }});
  of.prototype = Object.assign(Object.create(db.prototype), {constructor:of, interpolate_:function(a) {
    return this.copySampleValue_(a - 1);
  }});
  Object.assign(Qa, {toJSON:function(a) {
    var b = a.constructor;
    if (void 0 !== b.toJSON) {
      b = b.toJSON(a);
    } else {
      b = {name:a.name, times:Ba.convertArray(a.times, Array), values:Ba.convertArray(a.values, Array)};
      var c = a.getInterpolation();
      c !== a.DefaultInterpolation && (b.interpolation = c);
    }
    b.type = a.ValueTypeName;
    return b;
  }});
  Object.assign(Qa.prototype, {constructor:Qa, TimeBufferType:Float32Array, ValueBufferType:Float32Array, DefaultInterpolation:2301, InterpolantFactoryMethodDiscrete:function(a) {
    return new of(this.times, this.values, this.getValueSize(), a);
  }, InterpolantFactoryMethodLinear:function(a) {
    return new Be(this.times, this.values, this.getValueSize(), a);
  }, InterpolantFactoryMethodSmooth:function(a) {
    return new nf(this.times, this.values, this.getValueSize(), a);
  }, setInterpolation:function(a) {
    switch(a) {
      case 2300:
        var b = this.InterpolantFactoryMethodDiscrete;
        break;
      case 2301:
        b = this.InterpolantFactoryMethodLinear;
        break;
      case 2302:
        b = this.InterpolantFactoryMethodSmooth;
    }
    if (void 0 === b) {
      b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (void 0 === this.createInterpolant) {
        if (a !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw Error(b);
        }
      }
      console.warn("THREE.KeyframeTrack:", b);
      return this;
    }
    this.createInterpolant = b;
    return this;
  }, getInterpolation:function() {
    switch(this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return 2300;
      case this.InterpolantFactoryMethodLinear:
        return 2301;
      case this.InterpolantFactoryMethodSmooth:
        return 2302;
    }
  }, getValueSize:function() {
    return this.values.length / this.times.length;
  }, shift:function(a) {
    if (0 !== a) {
      for (var b = this.times, c = 0, l = b.length; c !== l; ++c) {
        b[c] += a;
      }
    }
    return this;
  }, scale:function(a) {
    if (1 !== a) {
      for (var b = this.times, c = 0, l = b.length; c !== l; ++c) {
        b[c] *= a;
      }
    }
    return this;
  }, trim:function(a, b) {
    for (var c = this.times, l = c.length, e = 0, d = l - 1; e !== l && c[e] < a;) {
      ++e;
    }
    for (; -1 !== d && c[d] > b;) {
      --d;
    }
    ++d;
    if (0 !== e || d !== l) {
      e >= d && (d = Math.max(d, 1), e = d - 1), a = this.getValueSize(), this.times = Ba.arraySlice(c, e, d), this.values = Ba.arraySlice(this.values, e * a, d * a);
    }
    return this;
  }, validate:function() {
    var a = !0, b = this.getValueSize();
    0 !== b - Math.floor(b) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), a = !1);
    var c = this.times;
    b = this.values;
    var e = c.length;
    0 === e && (console.error("THREE.KeyframeTrack: Track is empty.", this), a = !1);
    for (var d = null, m = 0; m !== e; m++) {
      var f = c[m];
      if ("number" === typeof f && isNaN(f)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, m, f);
        a = !1;
        break;
      }
      if (null !== d && d > f) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, m, f, d);
        a = !1;
        break;
      }
      d = f;
    }
    if (void 0 !== b && Ba.isTypedArray(b)) {
      for (m = 0, c = b.length; m !== c; ++m) {
        if (e = b[m], isNaN(e)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, m, e);
          a = !1;
          break;
        }
      }
    }
    return a;
  }, optimize:function() {
    for (var a = Ba.arraySlice(this.times), b = Ba.arraySlice(this.values), c = this.getValueSize(), e = 2302 === this.getInterpolation(), d = 1, m = a.length - 1, f = 1; f < m; ++f) {
      var k = !1, h = a[f];
      if (h !== a[f + 1] && (1 !== f || h !== h[0])) {
        if (e) {
          k = !0;
        } else {
          var g = f * c, r = g - c, n = g + c;
          for (h = 0; h !== c; ++h) {
            var q = b[g + h];
            if (q !== b[r + h] || q !== b[n + h]) {
              k = !0;
              break;
            }
          }
        }
      }
      if (k) {
        if (f !== d) {
          for (a[d] = a[f], k = f * c, g = d * c, h = 0; h !== c; ++h) {
            b[g + h] = b[k + h];
          }
        }
        ++d;
      }
    }
    if (0 < m) {
      a[d] = a[m];
      k = m * c;
      g = d * c;
      for (h = 0; h !== c; ++h) {
        b[g + h] = b[k + h];
      }
      ++d;
    }
    d !== a.length ? (this.times = Ba.arraySlice(a, 0, d), this.values = Ba.arraySlice(b, 0, d * c)) : (this.times = a, this.values = b);
    return this;
  }, clone:function() {
    var a = Ba.arraySlice(this.times, 0), b = Ba.arraySlice(this.values, 0);
    a = new this.constructor(this.name, a, b);
    a.createInterpolant = this.createInterpolant;
    return a;
  }});
  pf.prototype = Object.assign(Object.create(Qa.prototype), {constructor:pf, ValueTypeName:"bool", ValueBufferType:Array, DefaultInterpolation:2300, InterpolantFactoryMethodLinear:void 0, InterpolantFactoryMethodSmooth:void 0});
  qf.prototype = Object.assign(Object.create(Qa.prototype), {constructor:qf, ValueTypeName:"color"});
  yd.prototype = Object.assign(Object.create(Qa.prototype), {constructor:yd, ValueTypeName:"number"});
  rf.prototype = Object.assign(Object.create(db.prototype), {constructor:rf, interpolate_:function(a, b, c, e) {
    var l = this.resultBuffer, d = this.sampleValues, m = this.valueSize;
    a *= m;
    b = (c - b) / (e - b);
    for (c = a + m; a !== c; a += 4) {
      t.slerpFlat(l, 0, d, a - m, d, a, b);
    }
    return l;
  }});
  Ce.prototype = Object.assign(Object.create(Qa.prototype), {constructor:Ce, ValueTypeName:"quaternion", DefaultInterpolation:2301, InterpolantFactoryMethodLinear:function(a) {
    return new rf(this.times, this.values, this.getValueSize(), a);
  }, InterpolantFactoryMethodSmooth:void 0});
  sf.prototype = Object.assign(Object.create(Qa.prototype), {constructor:sf, ValueTypeName:"string", ValueBufferType:Array, DefaultInterpolation:2300, InterpolantFactoryMethodLinear:void 0, InterpolantFactoryMethodSmooth:void 0});
  zd.prototype = Object.assign(Object.create(Qa.prototype), {constructor:zd, ValueTypeName:"vector"});
  Object.assign(kb, {parse:function(a) {
    for (var b = [], c = a.tracks, l = 1 / (a.fps || 1), e = 0, d = c.length; e !== d; ++e) {
      b.push(Yj(c[e]).scale(l));
    }
    return new kb(a.name, a.duration, b, a.blendMode);
  }, toJSON:function(a) {
    var b = [], c = a.tracks;
    a = {name:a.name, duration:a.duration, tracks:b, uuid:a.uuid, blendMode:a.blendMode};
    for (var l = 0, e = c.length; l !== e; ++l) {
      b.push(Qa.toJSON(c[l]));
    }
    return a;
  }, CreateFromMorphTargetSequence:function(a, b, c, e) {
    for (var l = b.length, d = [], m = 0; m < l; m++) {
      var f = [], k = [];
      f.push((m + l - 1) % l, m, (m + 1) % l);
      k.push(0, 1, 0);
      var h = Ba.getKeyframeOrder(f);
      f = Ba.sortedArray(f, 1, h);
      k = Ba.sortedArray(k, 1, h);
      e || 0 !== f[0] || (f.push(l), k.push(k[0]));
      d.push((new yd(".morphTargetInfluences[" + b[m].name + "]", f, k)).scale(1 / c));
    }
    return new kb(a, -1, d);
  }, findByName:function(a, b) {
    var c = a;
    Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations);
    for (a = 0; a < c.length; a++) {
      if (c[a].name === b) {
        return c[a];
      }
    }
    return null;
  }, CreateClipsFromMorphTargetSequences:function(a, b, c) {
    for (var l = {}, e = /^([\w-]*?)([\d]+)$/, d = 0, m = a.length; d < m; d++) {
      var f = a[d], k = f.name.match(e);
      if (k && 1 < k.length) {
        var h = k[1];
        (k = l[h]) || (l[h] = k = []);
        k.push(f);
      }
    }
    a = [];
    for (h in l) {
      a.push(kb.CreateFromMorphTargetSequence(h, l[h], b, c));
    }
    return a;
  }, parseAnimation:function(a, b) {
    if (!a) {
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    }
    var c = function(a, b, c, l, e) {
      if (0 !== c.length) {
        var d = [], m = [];
        Ba.flattenJSON(c, d, m, l);
        0 !== d.length && e.push(new a(b, d, m));
      }
    }, l = [], e = a.name || "default", d = a.length || -1, m = a.fps || 30, f = a.blendMode;
    a = a.hierarchy || [];
    for (var k = 0; k < a.length; k++) {
      var h = a[k].keys;
      if (h && 0 !== h.length) {
        if (h[0].morphTargets) {
          d = {};
          for (var g = 0; g < h.length; g++) {
            if (h[g].morphTargets) {
              for (var r = 0; r < h[g].morphTargets.length; r++) {
                d[h[g].morphTargets[r]] = -1;
              }
            }
          }
          for (var n in d) {
            var q = [], p = [];
            for (r = 0; r !== h[g].morphTargets.length; ++r) {
              var u = h[g];
              q.push(u.time);
              p.push(u.morphTarget === n ? 1 : 0);
            }
            l.push(new yd(".morphTargetInfluence[" + n + "]", q, p));
          }
          d = d.length * (m || 1);
        } else {
          g = ".bones[" + b[k].name + "]", c(zd, g + ".position", h, "pos", l), c(Ce, g + ".quaternion", h, "rot", l), c(zd, g + ".scale", h, "scl", l);
        }
      }
    }
    return 0 === l.length ? null : new kb(e, d, l, f);
  }});
  Object.assign(kb.prototype, {resetDuration:function() {
    for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) {
      var e = this.tracks[b];
      a = Math.max(a, e.times[e.times.length - 1]);
    }
    this.duration = a;
    return this;
  }, trim:function() {
    for (var a = 0; a < this.tracks.length; a++) {
      this.tracks[a].trim(0, this.duration);
    }
    return this;
  }, validate:function() {
    for (var a = !0, b = 0; b < this.tracks.length; b++) {
      a = a && this.tracks[b].validate();
    }
    return a;
  }, optimize:function() {
    for (var a = 0; a < this.tracks.length; a++) {
      this.tracks[a].optimize();
    }
    return this;
  }, clone:function() {
    for (var a = [], b = 0; b < this.tracks.length; b++) {
      a.push(this.tracks[b].clone());
    }
    return new kb(this.name, this.duration, a, this.blendMode);
  }});
  var Vc = {enabled:!1, files:{}, add:function(a, b) {
    !1 !== this.enabled && (this.files[a] = b);
  }, get:function(a) {
    if (!1 !== this.enabled) {
      return this.files[a];
    }
  }, remove:function(a) {
    delete this.files[a];
  }, clear:function() {
    this.files = {};
  }}, ji = new Bg;
  Object.assign(pa.prototype, {load:function() {
  }, loadAsync:function(a, b) {
    var c = this;
    return new Promise(function(l, e) {
      c.load(a, l, b, e);
    });
  }, parse:function() {
  }, setCrossOrigin:function(a) {
    this.crossOrigin = a;
    return this;
  }, setPath:function(a) {
    this.path = a;
    return this;
  }, setResourcePath:function(a) {
    this.resourcePath = a;
    return this;
  }});
  var yb = {};
  lb.prototype = Object.assign(Object.create(pa.prototype), {constructor:lb, load:function(a, b, c, e) {
    void 0 === a && (a = "");
    void 0 !== this.path && (a = this.path + a);
    a = this.manager.resolveURL(a);
    var l = this, d = Vc.get(a);
    if (void 0 !== d) {
      return l.manager.itemStart(a), setTimeout(function() {
        b && b(d);
        l.manager.itemEnd(a);
      }, 0), d;
    }
    if (void 0 !== yb[a]) {
      yb[a].push({onLoad:b, onProgress:c, onError:e});
    } else {
      var m = a.match(/^data:(.*?)(;base64)?,(.*)$/);
      if (m) {
        c = m[1];
        var f = !!m[2];
        m = m[3];
        m = decodeURIComponent(m);
        f && (m = atob(m));
        try {
          var k = (this.responseType || "").toLowerCase();
          switch(k) {
            case "arraybuffer":
            case "blob":
              var h = new Uint8Array(m.length);
              for (f = 0; f < m.length; f++) {
                h[f] = m.charCodeAt(f);
              }
              var g = "blob" === k ? new Blob([h.buffer], {type:c}) : h.buffer;
              break;
            case "document":
              g = (new DOMParser).parseFromString(m, c);
              break;
            case "json":
              g = JSON.parse(m);
              break;
            default:
              g = m;
          }
          setTimeout(function() {
            b && b(g);
            l.manager.itemEnd(a);
          }, 0);
        } catch (nj) {
          setTimeout(function() {
            e && e(nj);
            l.manager.itemError(a);
            l.manager.itemEnd(a);
          }, 0);
        }
      } else {
        yb[a] = [];
        yb[a].push({onLoad:b, onProgress:c, onError:e});
        var r = new XMLHttpRequest;
        r.open("GET", a, !0);
        r.addEventListener("load", function(b) {
          var c = this.response, e = yb[a];
          delete yb[a];
          if (200 === this.status || 0 === this.status) {
            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
            Vc.add(a, c);
            for (var d = 0, m = e.length; d < m; d++) {
              var f = e[d];
              if (f.onLoad) {
                f.onLoad(c);
              }
            }
          } else {
            d = 0;
            for (m = e.length; d < m; d++) {
              if (f = e[d], f.onError) {
                f.onError(b);
              }
            }
            l.manager.itemError(a);
          }
          l.manager.itemEnd(a);
        }, !1);
        r.addEventListener("progress", function(b) {
          for (var c = yb[a], l = 0, e = c.length; l < e; l++) {
            var d = c[l];
            if (d.onProgress) {
              d.onProgress(b);
            }
          }
        }, !1);
        r.addEventListener("error", function(b) {
          var c = yb[a];
          delete yb[a];
          for (var e = 0, d = c.length; e < d; e++) {
            var m = c[e];
            if (m.onError) {
              m.onError(b);
            }
          }
          l.manager.itemError(a);
          l.manager.itemEnd(a);
        }, !1);
        r.addEventListener("abort", function(b) {
          var c = yb[a];
          delete yb[a];
          for (var e = 0, d = c.length; e < d; e++) {
            var m = c[e];
            if (m.onError) {
              m.onError(b);
            }
          }
          l.manager.itemError(a);
          l.manager.itemEnd(a);
        }, !1);
        void 0 !== this.responseType && (r.responseType = this.responseType);
        void 0 !== this.withCredentials && (r.withCredentials = this.withCredentials);
        r.overrideMimeType && r.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
        for (f in this.requestHeader) {
          r.setRequestHeader(f, this.requestHeader[f]);
        }
        r.send(null);
      }
      l.manager.itemStart(a);
      return r;
    }
  }, setResponseType:function(a) {
    this.responseType = a;
    return this;
  }, setWithCredentials:function(a) {
    this.withCredentials = a;
    return this;
  }, setMimeType:function(a) {
    this.mimeType = a;
    return this;
  }, setRequestHeader:function(a) {
    this.requestHeader = a;
    return this;
  }});
  Cg.prototype = Object.assign(Object.create(pa.prototype), {constructor:Cg, load:function(a, b, c, e) {
    var l = this, d = new lb(l.manager);
    d.setPath(l.path);
    d.load(a, function(a) {
      b(l.parse(JSON.parse(a)));
    }, c, e);
  }, parse:function(a) {
    for (var b = [], c = 0; c < a.length; c++) {
      var l = kb.parse(a[c]);
      b.push(l);
    }
    return b;
  }});
  Dg.prototype = Object.assign(Object.create(pa.prototype), {constructor:Dg, load:function(a, b, c, e) {
    function l(l) {
      k.load(a[l], function(a) {
        a = d.parse(a, !0);
        m[l] = {width:a.width, height:a.height, format:a.format, mipmaps:a.mipmaps};
        h += 1;
        6 === h && (1 === a.mipmapCount && (f.minFilter = 1006), f.format = a.format, f.needsUpdate = !0, b && b(f));
      }, c, e);
    }
    var d = this, m = [], f = new kd;
    f.image = m;
    var k = new lb(this.manager);
    k.setPath(this.path);
    k.setResponseType("arraybuffer");
    if (Array.isArray(a)) {
      for (var h = 0, g = 0, r = a.length; g < r; ++g) {
        l(g);
      }
    } else {
      k.load(a, function(a) {
        a = d.parse(a, !0);
        if (a.isCubemap) {
          for (var c = a.mipmaps.length / a.mipmapCount, l = 0; l < c; l++) {
            m[l] = {mipmaps:[]};
            for (var e = 0; e < a.mipmapCount; e++) {
              m[l].mipmaps.push(a.mipmaps[l * a.mipmapCount + e]), m[l].format = a.format, m[l].width = a.width, m[l].height = a.height;
            }
          }
        } else {
          f.image.width = a.width, f.image.height = a.height, f.mipmaps = a.mipmaps;
        }
        1 === a.mipmapCount && (f.minFilter = 1006);
        f.format = a.format;
        f.needsUpdate = !0;
        b && b(f);
      }, c, e);
    }
    return f;
  }});
  tf.prototype = Object.assign(Object.create(pa.prototype), {constructor:tf, load:function(a, b, c, e) {
    var l = this, d = new Ia, m = new lb(this.manager);
    m.setResponseType("arraybuffer");
    m.setPath(this.path);
    m.load(a, function(a) {
      if (a = l.parse(a)) {
        void 0 !== a.image ? d.image = a.image : void 0 !== a.data && (d.image.width = a.width, d.image.height = a.height, d.image.data = a.data), d.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, d.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001, d.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006, d.minFilter = void 0 !== a.minFilter ? a.minFilter : 1006, d.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (d.format = a.format), void 0 !== a.type && (d.type = a.type), 
        void 0 !== a.mipmaps && (d.mipmaps = a.mipmaps, d.minFilter = 1008), 1 === a.mipmapCount && (d.minFilter = 1006), d.needsUpdate = !0, b && b(d, a);
      }
    }, c, e);
    return d;
  }});
  Ad.prototype = Object.assign(Object.create(pa.prototype), {constructor:Ad, load:function(a, b, c, e) {
    function l() {
      k.removeEventListener("load", l, !1);
      k.removeEventListener("error", d, !1);
      Vc.add(a, this);
      b && b(this);
      m.manager.itemEnd(a);
    }
    function d(b) {
      k.removeEventListener("load", l, !1);
      k.removeEventListener("error", d, !1);
      e && e(b);
      m.manager.itemError(a);
      m.manager.itemEnd(a);
    }
    void 0 !== this.path && (a = this.path + a);
    a = this.manager.resolveURL(a);
    var m = this, f = Vc.get(a);
    if (void 0 !== f) {
      return m.manager.itemStart(a), setTimeout(function() {
        b && b(f);
        m.manager.itemEnd(a);
      }, 0), f;
    }
    var k = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    k.addEventListener("load", l, !1);
    k.addEventListener("error", d, !1);
    "data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (k.crossOrigin = this.crossOrigin);
    m.manager.itemStart(a);
    k.src = a;
    return k;
  }});
  uf.prototype = Object.assign(Object.create(pa.prototype), {constructor:uf, load:function(a, b, c, e) {
    function l(c) {
      m.load(a[c], function(a) {
        d.images[c] = a;
        f++;
        6 === f && (d.needsUpdate = !0, b && b(d));
      }, void 0, e);
    }
    var d = new Sa, m = new Ad(this.manager);
    m.setCrossOrigin(this.crossOrigin);
    m.setPath(this.path);
    var f = 0;
    for (c = 0; c < a.length; ++c) {
      l(c);
    }
    return d;
  }});
  vf.prototype = Object.assign(Object.create(pa.prototype), {constructor:vf, load:function(a, b, c, d) {
    var l = new e, m = new Ad(this.manager);
    m.setCrossOrigin(this.crossOrigin);
    m.setPath(this.path);
    m.load(a, function(c) {
      l.image = c;
      c = 0 < a.search(/\.jpe?g($|\?)/i) || 0 === a.search(/^data:image\/jpeg/);
      l.format = c ? 1022 : 1023;
      l.needsUpdate = !0;
      void 0 !== b && b(l);
    }, c, d);
    return l;
  }});
  Object.assign(ha.prototype, {getPoint:function() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }, getPointAt:function(a, b) {
    a = this.getUtoTmapping(a);
    return this.getPoint(a, b);
  }, getPoints:function(a) {
    void 0 === a && (a = 5);
    for (var b = [], c = 0; c <= a; c++) {
      b.push(this.getPoint(c / a));
    }
    return b;
  }, getSpacedPoints:function(a) {
    void 0 === a && (a = 5);
    for (var b = [], c = 0; c <= a; c++) {
      b.push(this.getPointAt(c / a));
    }
    return b;
  }, getLength:function() {
    var a = this.getLengths();
    return a[a.length - 1];
  }, getLengths:function(a) {
    void 0 === a && (a = this.arcLengthDivisions);
    if (this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = !1;
    var b = [], c = this.getPoint(0), l, e = 0;
    b.push(0);
    for (l = 1; l <= a; l++) {
      var d = this.getPoint(l / a);
      e += d.distanceTo(c);
      b.push(e);
      c = d;
    }
    return this.cacheArcLengths = b;
  }, updateArcLengths:function() {
    this.needsUpdate = !0;
    this.getLengths();
  }, getUtoTmapping:function(a, b) {
    var c = this.getLengths(), l = c.length;
    b = b ? b : a * c[l - 1];
    for (var e = 0, d = l - 1, m; e <= d;) {
      if (a = Math.floor(e + (d - e) / 2), m = c[a] - b, 0 > m) {
        e = a + 1;
      } else {
        if (0 < m) {
          d = a - 1;
        } else {
          d = a;
          break;
        }
      }
    }
    a = d;
    if (c[a] === b) {
      return a / (l - 1);
    }
    e = c[a];
    return (a + (b - e) / (c[a + 1] - e)) / (l - 1);
  }, getTangent:function(a, b) {
    var c = a - 1E-4;
    a += 1E-4;
    0 > c && (c = 0);
    1 < a && (a = 1);
    c = this.getPoint(c);
    a = this.getPoint(a);
    b = b || (c.isVector2 ? new g : new f);
    b.copy(a).sub(c).normalize();
    return b;
  }, getTangentAt:function(a, b) {
    a = this.getUtoTmapping(a);
    return this.getTangent(a, b);
  }, computeFrenetFrames:function(a, b) {
    var c = new f, l = [], e = [], d = [], m = new f, k = new n, h;
    for (h = 0; h <= a; h++) {
      var g = h / a;
      l[h] = this.getTangentAt(g, new f);
      l[h].normalize();
    }
    e[0] = new f;
    d[0] = new f;
    h = Number.MAX_VALUE;
    g = Math.abs(l[0].x);
    var r = Math.abs(l[0].y), q = Math.abs(l[0].z);
    g <= h && (h = g, c.set(1, 0, 0));
    r <= h && (h = r, c.set(0, 1, 0));
    q <= h && c.set(0, 0, 1);
    m.crossVectors(l[0], c).normalize();
    e[0].crossVectors(l[0], m);
    d[0].crossVectors(l[0], e[0]);
    for (h = 1; h <= a; h++) {
      e[h] = e[h - 1].clone(), d[h] = d[h - 1].clone(), m.crossVectors(l[h - 1], l[h]), m.length() > Number.EPSILON && (m.normalize(), c = Math.acos(na.clamp(l[h - 1].dot(l[h]), -1, 1)), e[h].applyMatrix4(k.makeRotationAxis(m, c))), d[h].crossVectors(l[h], e[h]);
    }
    if (!0 === b) {
      for (c = Math.acos(na.clamp(e[0].dot(e[a]), -1, 1)), c /= a, 0 < l[0].dot(m.crossVectors(e[0], e[a])) && (c = -c), h = 1; h <= a; h++) {
        e[h].applyMatrix4(k.makeRotationAxis(l[h], c * h)), d[h].crossVectors(l[h], e[h]);
      }
    }
    return {tangents:l, normals:e, binormals:d};
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.arcLengthDivisions = a.arcLengthDivisions;
    return this;
  }, toJSON:function() {
    var a = {metadata:{version:4.5, type:"Curve", generator:"Curve.toJSON"}};
    a.arcLengthDivisions = this.arcLengthDivisions;
    a.type = this.type;
    return a;
  }, fromJSON:function(a) {
    this.arcLengthDivisions = a.arcLengthDivisions;
    return this;
  }});
  eb.prototype = Object.create(ha.prototype);
  eb.prototype.constructor = eb;
  eb.prototype.isEllipseCurve = !0;
  eb.prototype.getPoint = function(a, b) {
    b = b || new g;
    for (var c = 2 * Math.PI, l = this.aEndAngle - this.aStartAngle, e = Math.abs(l) < Number.EPSILON; 0 > l;) {
      l += c;
    }
    for (; l > c;) {
      l -= c;
    }
    l < Number.EPSILON && (l = e ? 0 : c);
    !0 !== this.aClockwise || e || (l = l === c ? -c : l - c);
    c = this.aStartAngle + a * l;
    a = this.aX + this.xRadius * Math.cos(c);
    var d = this.aY + this.yRadius * Math.sin(c);
    0 !== this.aRotation && (c = Math.cos(this.aRotation), l = Math.sin(this.aRotation), e = a - this.aX, d -= this.aY, a = e * c - d * l + this.aX, d = e * l + d * c + this.aY);
    return b.set(a, d);
  };
  eb.prototype.copy = function(a) {
    ha.prototype.copy.call(this, a);
    this.aX = a.aX;
    this.aY = a.aY;
    this.xRadius = a.xRadius;
    this.yRadius = a.yRadius;
    this.aStartAngle = a.aStartAngle;
    this.aEndAngle = a.aEndAngle;
    this.aClockwise = a.aClockwise;
    this.aRotation = a.aRotation;
    return this;
  };
  eb.prototype.toJSON = function() {
    var a = ha.prototype.toJSON.call(this);
    a.aX = this.aX;
    a.aY = this.aY;
    a.xRadius = this.xRadius;
    a.yRadius = this.yRadius;
    a.aStartAngle = this.aStartAngle;
    a.aEndAngle = this.aEndAngle;
    a.aClockwise = this.aClockwise;
    a.aRotation = this.aRotation;
    return a;
  };
  eb.prototype.fromJSON = function(a) {
    ha.prototype.fromJSON.call(this, a);
    this.aX = a.aX;
    this.aY = a.aY;
    this.xRadius = a.xRadius;
    this.yRadius = a.yRadius;
    this.aStartAngle = a.aStartAngle;
    this.aEndAngle = a.aEndAngle;
    this.aClockwise = a.aClockwise;
    this.aRotation = a.aRotation;
    return this;
  };
  Bd.prototype = Object.create(eb.prototype);
  Bd.prototype.constructor = Bd;
  Bd.prototype.isArcCurve = !0;
  var gg = new f, sh = new Eg, th = new Eg, uh = new Eg;
  Ta.prototype = Object.create(ha.prototype);
  Ta.prototype.constructor = Ta;
  Ta.prototype.isCatmullRomCurve3 = !0;
  Ta.prototype.getPoint = function(a, b) {
    b = b || new f;
    var c = this.points, l = c.length;
    a *= l - (this.closed ? 0 : 1);
    var e = Math.floor(a);
    a -= e;
    this.closed ? e += 0 < e ? 0 : (Math.floor(Math.abs(e) / l) + 1) * l : 0 === a && e === l - 1 && (e = l - 2, a = 1);
    if (this.closed || 0 < e) {
      var d = c[(e - 1) % l];
    } else {
      gg.subVectors(c[0], c[1]).add(c[0]), d = gg;
    }
    var m = c[e % l];
    var k = c[(e + 1) % l];
    this.closed || e + 2 < l ? c = c[(e + 2) % l] : (gg.subVectors(c[l - 1], c[l - 2]).add(c[l - 1]), c = gg);
    if ("centripetal" === this.curveType || "chordal" === this.curveType) {
      var h = "chordal" === this.curveType ? .5 : .25;
      l = Math.pow(d.distanceToSquared(m), h);
      e = Math.pow(m.distanceToSquared(k), h);
      h = Math.pow(k.distanceToSquared(c), h);
      1E-4 > e && (e = 1);
      1E-4 > l && (l = e);
      1E-4 > h && (h = e);
      sh.initNonuniformCatmullRom(d.x, m.x, k.x, c.x, l, e, h);
      th.initNonuniformCatmullRom(d.y, m.y, k.y, c.y, l, e, h);
      uh.initNonuniformCatmullRom(d.z, m.z, k.z, c.z, l, e, h);
    } else {
      "catmullrom" === this.curveType && (sh.initCatmullRom(d.x, m.x, k.x, c.x, this.tension), th.initCatmullRom(d.y, m.y, k.y, c.y, this.tension), uh.initCatmullRom(d.z, m.z, k.z, c.z, this.tension));
    }
    b.set(sh.calc(a), th.calc(a), uh.calc(a));
    return b;
  };
  Ta.prototype.copy = function(a) {
    ha.prototype.copy.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++) {
      this.points.push(a.points[b].clone());
    }
    this.closed = a.closed;
    this.curveType = a.curveType;
    this.tension = a.tension;
    return this;
  };
  Ta.prototype.toJSON = function() {
    var a = ha.prototype.toJSON.call(this);
    a.points = [];
    for (var b = 0, c = this.points.length; b < c; b++) {
      a.points.push(this.points[b].toArray());
    }
    a.closed = this.closed;
    a.curveType = this.curveType;
    a.tension = this.tension;
    return a;
  };
  Ta.prototype.fromJSON = function(a) {
    ha.prototype.fromJSON.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++) {
      var l = a.points[b];
      this.points.push((new f).fromArray(l));
    }
    this.closed = a.closed;
    this.curveType = a.curveType;
    this.tension = a.tension;
    return this;
  };
  sb.prototype = Object.create(ha.prototype);
  sb.prototype.constructor = sb;
  sb.prototype.isCubicBezierCurve = !0;
  sb.prototype.getPoint = function(a, b) {
    b = b || new g;
    var c = this.v0, l = this.v1, e = this.v2, d = this.v3;
    b.set(Ee(a, c.x, l.x, e.x, d.x), Ee(a, c.y, l.y, e.y, d.y));
    return b;
  };
  sb.prototype.copy = function(a) {
    ha.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    this.v3.copy(a.v3);
    return this;
  };
  sb.prototype.toJSON = function() {
    var a = ha.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    a.v3 = this.v3.toArray();
    return a;
  };
  sb.prototype.fromJSON = function(a) {
    ha.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    this.v3.fromArray(a.v3);
    return this;
  };
  Ib.prototype = Object.create(ha.prototype);
  Ib.prototype.constructor = Ib;
  Ib.prototype.isCubicBezierCurve3 = !0;
  Ib.prototype.getPoint = function(a, b) {
    b = b || new f;
    var c = this.v0, l = this.v1, e = this.v2, d = this.v3;
    b.set(Ee(a, c.x, l.x, e.x, d.x), Ee(a, c.y, l.y, e.y, d.y), Ee(a, c.z, l.z, e.z, d.z));
    return b;
  };
  Ib.prototype.copy = function(a) {
    ha.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    this.v3.copy(a.v3);
    return this;
  };
  Ib.prototype.toJSON = function() {
    var a = ha.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    a.v3 = this.v3.toArray();
    return a;
  };
  Ib.prototype.fromJSON = function(a) {
    ha.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    this.v3.fromArray(a.v3);
    return this;
  };
  Za.prototype = Object.create(ha.prototype);
  Za.prototype.constructor = Za;
  Za.prototype.isLineCurve = !0;
  Za.prototype.getPoint = function(a, b) {
    b = b || new g;
    1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
    return b;
  };
  Za.prototype.getPointAt = function(a, b) {
    return this.getPoint(a, b);
  };
  Za.prototype.getTangent = function(a, b) {
    a = b || new g;
    return a = a.copy(this.v2).sub(this.v1).normalize();
  };
  Za.prototype.copy = function(a) {
    ha.prototype.copy.call(this, a);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  Za.prototype.toJSON = function() {
    var a = ha.prototype.toJSON.call(this);
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  Za.prototype.fromJSON = function(a) {
    ha.prototype.fromJSON.call(this, a);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  tb.prototype = Object.create(ha.prototype);
  tb.prototype.constructor = tb;
  tb.prototype.isLineCurve3 = !0;
  tb.prototype.getPoint = function(a, b) {
    b = b || new f;
    1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
    return b;
  };
  tb.prototype.getPointAt = function(a, b) {
    return this.getPoint(a, b);
  };
  tb.prototype.copy = function(a) {
    ha.prototype.copy.call(this, a);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  tb.prototype.toJSON = function() {
    var a = ha.prototype.toJSON.call(this);
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  tb.prototype.fromJSON = function(a) {
    ha.prototype.fromJSON.call(this, a);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  ub.prototype = Object.create(ha.prototype);
  ub.prototype.constructor = ub;
  ub.prototype.isQuadraticBezierCurve = !0;
  ub.prototype.getPoint = function(a, b) {
    b = b || new g;
    var c = this.v0, l = this.v1, e = this.v2;
    b.set(De(a, c.x, l.x, e.x), De(a, c.y, l.y, e.y));
    return b;
  };
  ub.prototype.copy = function(a) {
    ha.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  ub.prototype.toJSON = function() {
    var a = ha.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  ub.prototype.fromJSON = function(a) {
    ha.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  Jb.prototype = Object.create(ha.prototype);
  Jb.prototype.constructor = Jb;
  Jb.prototype.isQuadraticBezierCurve3 = !0;
  Jb.prototype.getPoint = function(a, b) {
    b = b || new f;
    var c = this.v0, l = this.v1, e = this.v2;
    b.set(De(a, c.x, l.x, e.x), De(a, c.y, l.y, e.y), De(a, c.z, l.z, e.z));
    return b;
  };
  Jb.prototype.copy = function(a) {
    ha.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  Jb.prototype.toJSON = function() {
    var a = ha.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  Jb.prototype.fromJSON = function(a) {
    ha.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  vb.prototype = Object.create(ha.prototype);
  vb.prototype.constructor = vb;
  vb.prototype.isSplineCurve = !0;
  vb.prototype.getPoint = function(a, b) {
    b = b || new g;
    var c = this.points, l = (c.length - 1) * a;
    a = Math.floor(l);
    l -= a;
    var e = c[0 === a ? a : a - 1], d = c[a], m = c[a > c.length - 2 ? c.length - 1 : a + 1];
    c = c[a > c.length - 3 ? c.length - 1 : a + 2];
    b.set(ki(l, e.x, d.x, m.x, c.x), ki(l, e.y, d.y, m.y, c.y));
    return b;
  };
  vb.prototype.copy = function(a) {
    ha.prototype.copy.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++) {
      this.points.push(a.points[b].clone());
    }
    return this;
  };
  vb.prototype.toJSON = function() {
    var a = ha.prototype.toJSON.call(this);
    a.points = [];
    for (var b = 0, c = this.points.length; b < c; b++) {
      a.points.push(this.points[b].toArray());
    }
    return a;
  };
  vb.prototype.fromJSON = function(a) {
    ha.prototype.fromJSON.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++) {
      var l = a.points[b];
      this.points.push((new g).fromArray(l));
    }
    return this;
  };
  var vh = Object.freeze({__proto__:null, ArcCurve:Bd, CatmullRomCurve3:Ta, CubicBezierCurve:sb, CubicBezierCurve3:Ib, EllipseCurve:eb, LineCurve:Za, LineCurve3:tb, QuadraticBezierCurve:ub, QuadraticBezierCurve3:Jb, SplineCurve:vb});
  Wb.prototype = Object.assign(Object.create(ha.prototype), {constructor:Wb, add:function(a) {
    this.curves.push(a);
  }, closePath:function() {
    var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
    a.equals(b) || this.curves.push(new Za(b, a));
  }, getPoint:function(a) {
    var b = a * this.getLength(), c = this.getCurveLengths();
    for (a = 0; a < c.length;) {
      if (c[a] >= b) {
        return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 - b / c);
      }
      a++;
    }
    return null;
  }, getLength:function() {
    var a = this.getCurveLengths();
    return a[a.length - 1];
  }, updateArcLengths:function() {
    this.needsUpdate = !0;
    this.cacheLengths = null;
    this.getCurveLengths();
  }, getCurveLengths:function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    for (var a = [], b = 0, c = 0, e = this.curves.length; c < e; c++) {
      b += this.curves[c].getLength(), a.push(b);
    }
    return this.cacheLengths = a;
  }, getSpacedPoints:function(a) {
    void 0 === a && (a = 40);
    for (var b = [], c = 0; c <= a; c++) {
      b.push(this.getPoint(c / a));
    }
    this.autoClose && b.push(b[0]);
    return b;
  }, getPoints:function(a) {
    a = a || 12;
    for (var b = [], c, l = 0, e = this.curves; l < e.length; l++) {
      var d = e[l];
      d = d.getPoints(d && d.isEllipseCurve ? 2 * a : d && (d.isLineCurve || d.isLineCurve3) ? 1 : d && d.isSplineCurve ? a * d.points.length : a);
      for (var m = 0; m < d.length; m++) {
        var f = d[m];
        c && c.equals(f) || (b.push(f), c = f);
      }
    }
    this.autoClose && 1 < b.length && !b[b.length - 1].equals(b[0]) && b.push(b[0]);
    return b;
  }, copy:function(a) {
    ha.prototype.copy.call(this, a);
    this.curves = [];
    for (var b = 0, c = a.curves.length; b < c; b++) {
      this.curves.push(a.curves[b].clone());
    }
    this.autoClose = a.autoClose;
    return this;
  }, toJSON:function() {
    var a = ha.prototype.toJSON.call(this);
    a.autoClose = this.autoClose;
    a.curves = [];
    for (var b = 0, c = this.curves.length; b < c; b++) {
      a.curves.push(this.curves[b].toJSON());
    }
    return a;
  }, fromJSON:function(a) {
    ha.prototype.fromJSON.call(this, a);
    this.autoClose = a.autoClose;
    this.curves = [];
    for (var b = 0, c = a.curves.length; b < c; b++) {
      var l = a.curves[b];
      this.curves.push((new vh[l.type]).fromJSON(l));
    }
    return this;
  }});
  wb.prototype = Object.assign(Object.create(Wb.prototype), {constructor:wb, setFromPoints:function(a) {
    this.moveTo(a[0].x, a[0].y);
    for (var b = 1, c = a.length; b < c; b++) {
      this.lineTo(a[b].x, a[b].y);
    }
    return this;
  }, moveTo:function(a, b) {
    this.currentPoint.set(a, b);
    return this;
  }, lineTo:function(a, b) {
    var c = new Za(this.currentPoint.clone(), new g(a, b));
    this.curves.push(c);
    this.currentPoint.set(a, b);
    return this;
  }, quadraticCurveTo:function(a, b, c, e) {
    a = new ub(this.currentPoint.clone(), new g(a, b), new g(c, e));
    this.curves.push(a);
    this.currentPoint.set(c, e);
    return this;
  }, bezierCurveTo:function(a, b, c, e, d, m) {
    a = new sb(this.currentPoint.clone(), new g(a, b), new g(c, e), new g(d, m));
    this.curves.push(a);
    this.currentPoint.set(d, m);
    return this;
  }, splineThru:function(a) {
    var b = [this.currentPoint.clone()].concat(a);
    b = new vb(b);
    this.curves.push(b);
    this.currentPoint.copy(a[a.length - 1]);
    return this;
  }, arc:function(a, b, c, e, d, m) {
    this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, e, d, m);
    return this;
  }, absarc:function(a, b, c, e, d, m) {
    this.absellipse(a, b, c, c, e, d, m);
    return this;
  }, ellipse:function(a, b, c, e, d, m, f, k) {
    this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, e, d, m, f, k);
    return this;
  }, absellipse:function(a, b, c, e, d, m, f, k) {
    a = new eb(a, b, c, e, d, m, f, k);
    0 < this.curves.length && (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y));
    this.curves.push(a);
    a = a.getPoint(1);
    this.currentPoint.copy(a);
    return this;
  }, copy:function(a) {
    Wb.prototype.copy.call(this, a);
    this.currentPoint.copy(a.currentPoint);
    return this;
  }, toJSON:function() {
    var a = Wb.prototype.toJSON.call(this);
    a.currentPoint = this.currentPoint.toArray();
    return a;
  }, fromJSON:function(a) {
    Wb.prototype.fromJSON.call(this, a);
    this.currentPoint.fromArray(a.currentPoint);
    return this;
  }});
  qc.prototype = Object.assign(Object.create(wb.prototype), {constructor:qc, getPointsHoles:function(a) {
    for (var b = [], c = 0, l = this.holes.length; c < l; c++) {
      b[c] = this.holes[c].getPoints(a);
    }
    return b;
  }, extractPoints:function(a) {
    return {shape:this.getPoints(a), holes:this.getPointsHoles(a)};
  }, copy:function(a) {
    wb.prototype.copy.call(this, a);
    this.holes = [];
    for (var b = 0, c = a.holes.length; b < c; b++) {
      this.holes.push(a.holes[b].clone());
    }
    return this;
  }, toJSON:function() {
    var a = wb.prototype.toJSON.call(this);
    a.uuid = this.uuid;
    a.holes = [];
    for (var b = 0, c = this.holes.length; b < c; b++) {
      a.holes.push(this.holes[b].toJSON());
    }
    return a;
  }, fromJSON:function(a) {
    wb.prototype.fromJSON.call(this, a);
    this.uuid = a.uuid;
    this.holes = [];
    for (var b = 0, c = a.holes.length; b < c; b++) {
      var l = a.holes[b];
      this.holes.push((new wb).fromJSON(l));
    }
    return this;
  }});
  wa.prototype = Object.assign(Object.create(q.prototype), {constructor:wa, isLight:!0, copy:function(a) {
    q.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.intensity = a.intensity;
    return this;
  }, toJSON:function(a) {
    a = q.prototype.toJSON.call(this, a);
    a.object.color = this.color.getHex();
    a.object.intensity = this.intensity;
    void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex());
    void 0 !== this.distance && (a.object.distance = this.distance);
    void 0 !== this.angle && (a.object.angle = this.angle);
    void 0 !== this.decay && (a.object.decay = this.decay);
    void 0 !== this.penumbra && (a.object.penumbra = this.penumbra);
    void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON());
    return a;
  }});
  wf.prototype = Object.assign(Object.create(wa.prototype), {constructor:wf, isHemisphereLight:!0, copy:function(a) {
    wa.prototype.copy.call(this, a);
    this.groundColor.copy(a.groundColor);
    return this;
  }});
  Object.assign(Kb.prototype, {_projScreenMatrix:new n, _lightPositionWorld:new f, _lookTarget:new f, getViewportCount:function() {
    return this._viewportCount;
  }, getFrustum:function() {
    return this._frustum;
  }, updateMatrices:function(a) {
    var b = this.camera, c = this.matrix, l = this._projScreenMatrix, e = this._lookTarget, d = this._lightPositionWorld;
    d.setFromMatrixPosition(a.matrixWorld);
    b.position.copy(d);
    e.setFromMatrixPosition(a.target.matrixWorld);
    b.lookAt(e);
    b.updateMatrixWorld();
    l.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(l);
    c.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
    c.multiply(b.projectionMatrix);
    c.multiply(b.matrixWorldInverse);
  }, getViewport:function(a) {
    return this._viewports[a];
  }, getFrameExtents:function() {
    return this._frameExtents;
  }, copy:function(a) {
    this.camera = a.camera.clone();
    this.bias = a.bias;
    this.radius = a.radius;
    this.mapSize.copy(a.mapSize);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, toJSON:function() {
    var a = {};
    0 !== this.bias && (a.bias = this.bias);
    1 !== this.radius && (a.radius = this.radius);
    if (512 !== this.mapSize.x || 512 !== this.mapSize.y) {
      a.mapSize = this.mapSize.toArray();
    }
    a.camera = this.camera.toJSON(!1).object;
    delete a.camera.matrix;
    return a;
  }});
  xf.prototype = Object.assign(Object.create(Kb.prototype), {constructor:xf, isSpotLightShadow:!0, updateMatrices:function(a) {
    var b = this.camera, c = 2 * na.RAD2DEG * a.angle, l = this.mapSize.width / this.mapSize.height, e = a.distance || b.far;
    if (c !== b.fov || l !== b.aspect || e !== b.far) {
      b.fov = c, b.aspect = l, b.far = e, b.updateProjectionMatrix();
    }
    Kb.prototype.updateMatrices.call(this, a);
  }});
  yf.prototype = Object.assign(Object.create(wa.prototype), {constructor:yf, isSpotLight:!0, copy:function(a) {
    wa.prototype.copy.call(this, a);
    this.distance = a.distance;
    this.angle = a.angle;
    this.penumbra = a.penumbra;
    this.decay = a.decay;
    this.target = a.target.clone();
    this.shadow = a.shadow.clone();
    return this;
  }});
  Fg.prototype = Object.assign(Object.create(Kb.prototype), {constructor:Fg, isPointLightShadow:!0, updateMatrices:function(a, b) {
    void 0 === b && (b = 0);
    var c = this.camera, l = this.matrix, e = this._lightPositionWorld, d = this._lookTarget, m = this._projScreenMatrix;
    e.setFromMatrixPosition(a.matrixWorld);
    c.position.copy(e);
    d.copy(c.position);
    d.add(this._cubeDirections[b]);
    c.up.copy(this._cubeUps[b]);
    c.lookAt(d);
    c.updateMatrixWorld();
    l.makeTranslation(-e.x, -e.y, -e.z);
    m.multiplyMatrices(c.projectionMatrix, c.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(m);
  }});
  zf.prototype = Object.assign(Object.create(wa.prototype), {constructor:zf, isPointLight:!0, copy:function(a) {
    wa.prototype.copy.call(this, a);
    this.distance = a.distance;
    this.decay = a.decay;
    this.shadow = a.shadow.clone();
    return this;
  }});
  Cd.prototype = Object.assign(Object.create(ma.prototype), {constructor:Cd, isOrthographicCamera:!0, copy:function(a, b) {
    ma.prototype.copy.call(this, a, b);
    this.left = a.left;
    this.right = a.right;
    this.top = a.top;
    this.bottom = a.bottom;
    this.near = a.near;
    this.far = a.far;
    this.zoom = a.zoom;
    this.view = null === a.view ? null : Object.assign({}, a.view);
    return this;
  }, setViewOffset:function(a, b, c, e, d, m) {
    null === this.view && (this.view = {enabled:!0, fullWidth:1, fullHeight:1, offsetX:0, offsetY:0, width:1, height:1});
    this.view.enabled = !0;
    this.view.fullWidth = a;
    this.view.fullHeight = b;
    this.view.offsetX = c;
    this.view.offsetY = e;
    this.view.width = d;
    this.view.height = m;
    this.updateProjectionMatrix();
  }, clearViewOffset:function() {
    null !== this.view && (this.view.enabled = !1);
    this.updateProjectionMatrix();
  }, updateProjectionMatrix:function() {
    var a = (this.right - this.left) / (2 * this.zoom), b = (this.top - this.bottom) / (2 * this.zoom), c = (this.right + this.left) / 2, e = (this.top + this.bottom) / 2, d = c - a;
    c += a;
    a = e + b;
    b = e - b;
    null !== this.view && this.view.enabled && (e = (this.right - this.left) / this.view.fullWidth / this.zoom, b = (this.top - this.bottom) / this.view.fullHeight / this.zoom, d += e * this.view.offsetX, c = d + e * this.view.width, a -= b * this.view.offsetY, b = a - b * this.view.height);
    this.projectionMatrix.makeOrthographic(d, c, a, b, this.near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  }, toJSON:function(a) {
    a = q.prototype.toJSON.call(this, a);
    a.object.zoom = this.zoom;
    a.object.left = this.left;
    a.object.right = this.right;
    a.object.top = this.top;
    a.object.bottom = this.bottom;
    a.object.near = this.near;
    a.object.far = this.far;
    null !== this.view && (a.object.view = Object.assign({}, this.view));
    return a;
  }});
  Af.prototype = Object.assign(Object.create(Kb.prototype), {constructor:Af, isDirectionalLightShadow:!0, updateMatrices:function(a) {
    Kb.prototype.updateMatrices.call(this, a);
  }});
  Bf.prototype = Object.assign(Object.create(wa.prototype), {constructor:Bf, isDirectionalLight:!0, copy:function(a) {
    wa.prototype.copy.call(this, a);
    this.target = a.target.clone();
    this.shadow = a.shadow.clone();
    return this;
  }});
  Cf.prototype = Object.assign(Object.create(wa.prototype), {constructor:Cf, isAmbientLight:!0});
  Df.prototype = Object.assign(Object.create(wa.prototype), {constructor:Df, isRectAreaLight:!0, copy:function(a) {
    wa.prototype.copy.call(this, a);
    this.width = a.width;
    this.height = a.height;
    return this;
  }, toJSON:function(a) {
    a = wa.prototype.toJSON.call(this, a);
    a.object.width = this.width;
    a.object.height = this.height;
    return a;
  }});
  Object.assign(Ef.prototype, {isSphericalHarmonics3:!0, set:function(a) {
    for (var b = 0; 9 > b; b++) {
      this.coefficients[b].copy(a[b]);
    }
    return this;
  }, zero:function() {
    for (var a = 0; 9 > a; a++) {
      this.coefficients[a].set(0, 0, 0);
    }
    return this;
  }, getAt:function(a, b) {
    var c = a.x, l = a.y;
    a = a.z;
    var e = this.coefficients;
    b.copy(e[0]).multiplyScalar(.282095);
    b.addScaledVector(e[1], .488603 * l);
    b.addScaledVector(e[2], .488603 * a);
    b.addScaledVector(e[3], .488603 * c);
    b.addScaledVector(e[4], 1.092548 * c * l);
    b.addScaledVector(e[5], 1.092548 * l * a);
    b.addScaledVector(e[6], .315392 * (3 * a * a - 1));
    b.addScaledVector(e[7], 1.092548 * c * a);
    b.addScaledVector(e[8], .546274 * (c * c - l * l));
    return b;
  }, getIrradianceAt:function(a, b) {
    var c = a.x, l = a.y;
    a = a.z;
    var e = this.coefficients;
    b.copy(e[0]).multiplyScalar(.886227);
    b.addScaledVector(e[1], 1.023328 * l);
    b.addScaledVector(e[2], 1.023328 * a);
    b.addScaledVector(e[3], 1.023328 * c);
    b.addScaledVector(e[4], .858086 * c * l);
    b.addScaledVector(e[5], .858086 * l * a);
    b.addScaledVector(e[6], .743125 * a * a - .247708);
    b.addScaledVector(e[7], .858086 * c * a);
    b.addScaledVector(e[8], .429043 * (c * c - l * l));
    return b;
  }, add:function(a) {
    for (var b = 0; 9 > b; b++) {
      this.coefficients[b].add(a.coefficients[b]);
    }
    return this;
  }, addScaledSH:function(a, b) {
    for (var c = 0; 9 > c; c++) {
      this.coefficients[c].addScaledVector(a.coefficients[c], b);
    }
    return this;
  }, scale:function(a) {
    for (var b = 0; 9 > b; b++) {
      this.coefficients[b].multiplyScalar(a);
    }
    return this;
  }, lerp:function(a, b) {
    for (var c = 0; 9 > c; c++) {
      this.coefficients[c].lerp(a.coefficients[c], b);
    }
    return this;
  }, equals:function(a) {
    for (var b = 0; 9 > b; b++) {
      if (!this.coefficients[b].equals(a.coefficients[b])) {
        return !1;
      }
    }
    return !0;
  }, copy:function(a) {
    return this.set(a.coefficients);
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    for (var c = this.coefficients, l = 0; 9 > l; l++) {
      c[l].fromArray(a, b + 3 * l);
    }
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    for (var c = this.coefficients, l = 0; 9 > l; l++) {
      c[l].toArray(a, b + 3 * l);
    }
    return a;
  }});
  Object.assign(Ef, {getBasisAt:function(a, b) {
    var c = a.x, l = a.y;
    a = a.z;
    b[0] = .282095;
    b[1] = .488603 * l;
    b[2] = .488603 * a;
    b[3] = .488603 * c;
    b[4] = 1.092548 * c * l;
    b[5] = 1.092548 * l * a;
    b[6] = .315392 * (3 * a * a - 1);
    b[7] = 1.092548 * c * a;
    b[8] = .546274 * (c * c - l * l);
  }});
  mb.prototype = Object.assign(Object.create(wa.prototype), {constructor:mb, isLightProbe:!0, copy:function(a) {
    wa.prototype.copy.call(this, a);
    this.sh.copy(a.sh);
    return this;
  }, fromJSON:function(a) {
    this.intensity = a.intensity;
    this.sh.fromArray(a.sh);
    return this;
  }, toJSON:function(a) {
    a = wa.prototype.toJSON.call(this, a);
    a.object.sh = this.sh.toArray();
    return a;
  }});
  Ff.prototype = Object.assign(Object.create(pa.prototype), {constructor:Ff, load:function(a, b, c, e) {
    var l = this, d = new lb(l.manager);
    d.setPath(l.path);
    d.load(a, function(a) {
      b(l.parse(JSON.parse(a)));
    }, c, e);
  }, parse:function(a) {
    function b(a) {
      void 0 === c[a] && console.warn("THREE.MaterialLoader: Undefined texture", a);
      return c[a];
    }
    var c = this.textures, l = new kk[a.type];
    void 0 !== a.uuid && (l.uuid = a.uuid);
    void 0 !== a.name && (l.name = a.name);
    void 0 !== a.color && l.color.setHex(a.color);
    void 0 !== a.roughness && (l.roughness = a.roughness);
    void 0 !== a.metalness && (l.metalness = a.metalness);
    void 0 !== a.sheen && (l.sheen = (new A).setHex(a.sheen));
    void 0 !== a.emissive && l.emissive.setHex(a.emissive);
    void 0 !== a.specular && l.specular.setHex(a.specular);
    void 0 !== a.shininess && (l.shininess = a.shininess);
    void 0 !== a.clearcoat && (l.clearcoat = a.clearcoat);
    void 0 !== a.clearcoatRoughness && (l.clearcoatRoughness = a.clearcoatRoughness);
    void 0 !== a.fog && (l.fog = a.fog);
    void 0 !== a.flatShading && (l.flatShading = a.flatShading);
    void 0 !== a.blending && (l.blending = a.blending);
    void 0 !== a.combine && (l.combine = a.combine);
    void 0 !== a.side && (l.side = a.side);
    void 0 !== a.opacity && (l.opacity = a.opacity);
    void 0 !== a.transparent && (l.transparent = a.transparent);
    void 0 !== a.alphaTest && (l.alphaTest = a.alphaTest);
    void 0 !== a.depthTest && (l.depthTest = a.depthTest);
    void 0 !== a.depthWrite && (l.depthWrite = a.depthWrite);
    void 0 !== a.colorWrite && (l.colorWrite = a.colorWrite);
    void 0 !== a.stencilWrite && (l.stencilWrite = a.stencilWrite);
    void 0 !== a.stencilWriteMask && (l.stencilWriteMask = a.stencilWriteMask);
    void 0 !== a.stencilFunc && (l.stencilFunc = a.stencilFunc);
    void 0 !== a.stencilRef && (l.stencilRef = a.stencilRef);
    void 0 !== a.stencilFuncMask && (l.stencilFuncMask = a.stencilFuncMask);
    void 0 !== a.stencilFail && (l.stencilFail = a.stencilFail);
    void 0 !== a.stencilZFail && (l.stencilZFail = a.stencilZFail);
    void 0 !== a.stencilZPass && (l.stencilZPass = a.stencilZPass);
    void 0 !== a.wireframe && (l.wireframe = a.wireframe);
    void 0 !== a.wireframeLinewidth && (l.wireframeLinewidth = a.wireframeLinewidth);
    void 0 !== a.wireframeLinecap && (l.wireframeLinecap = a.wireframeLinecap);
    void 0 !== a.wireframeLinejoin && (l.wireframeLinejoin = a.wireframeLinejoin);
    void 0 !== a.rotation && (l.rotation = a.rotation);
    1 !== a.linewidth && (l.linewidth = a.linewidth);
    void 0 !== a.dashSize && (l.dashSize = a.dashSize);
    void 0 !== a.gapSize && (l.gapSize = a.gapSize);
    void 0 !== a.scale && (l.scale = a.scale);
    void 0 !== a.polygonOffset && (l.polygonOffset = a.polygonOffset);
    void 0 !== a.polygonOffsetFactor && (l.polygonOffsetFactor = a.polygonOffsetFactor);
    void 0 !== a.polygonOffsetUnits && (l.polygonOffsetUnits = a.polygonOffsetUnits);
    void 0 !== a.skinning && (l.skinning = a.skinning);
    void 0 !== a.morphTargets && (l.morphTargets = a.morphTargets);
    void 0 !== a.morphNormals && (l.morphNormals = a.morphNormals);
    void 0 !== a.dithering && (l.dithering = a.dithering);
    void 0 !== a.vertexTangents && (l.vertexTangents = a.vertexTangents);
    void 0 !== a.visible && (l.visible = a.visible);
    void 0 !== a.toneMapped && (l.toneMapped = a.toneMapped);
    void 0 !== a.userData && (l.userData = a.userData);
    void 0 !== a.vertexColors && (l.vertexColors = "number" === typeof a.vertexColors ? 0 < a.vertexColors ? !0 : !1 : a.vertexColors);
    if (void 0 !== a.uniforms) {
      for (var e in a.uniforms) {
        var d = a.uniforms[e];
        l.uniforms[e] = {};
        switch(d.type) {
          case "t":
            l.uniforms[e].value = b(d.value);
            break;
          case "c":
            l.uniforms[e].value = (new A).setHex(d.value);
            break;
          case "v2":
            l.uniforms[e].value = (new g).fromArray(d.value);
            break;
          case "v3":
            l.uniforms[e].value = (new f).fromArray(d.value);
            break;
          case "v4":
            l.uniforms[e].value = (new k).fromArray(d.value);
            break;
          case "m3":
            l.uniforms[e].value = (new h).fromArray(d.value);
          case "m4":
            l.uniforms[e].value = (new n).fromArray(d.value);
            break;
          default:
            l.uniforms[e].value = d.value;
        }
      }
    }
    void 0 !== a.defines && (l.defines = a.defines);
    void 0 !== a.vertexShader && (l.vertexShader = a.vertexShader);
    void 0 !== a.fragmentShader && (l.fragmentShader = a.fragmentShader);
    if (void 0 !== a.extensions) {
      for (var m in a.extensions) {
        l.extensions[m] = a.extensions[m];
      }
    }
    void 0 !== a.shading && (l.flatShading = 1 === a.shading);
    void 0 !== a.size && (l.size = a.size);
    void 0 !== a.sizeAttenuation && (l.sizeAttenuation = a.sizeAttenuation);
    void 0 !== a.map && (l.map = b(a.map));
    void 0 !== a.matcap && (l.matcap = b(a.matcap));
    void 0 !== a.alphaMap && (l.alphaMap = b(a.alphaMap));
    void 0 !== a.bumpMap && (l.bumpMap = b(a.bumpMap));
    void 0 !== a.bumpScale && (l.bumpScale = a.bumpScale);
    void 0 !== a.normalMap && (l.normalMap = b(a.normalMap));
    void 0 !== a.normalMapType && (l.normalMapType = a.normalMapType);
    void 0 !== a.normalScale && (e = a.normalScale, !1 === Array.isArray(e) && (e = [e, e]), l.normalScale = (new g).fromArray(e));
    void 0 !== a.displacementMap && (l.displacementMap = b(a.displacementMap));
    void 0 !== a.displacementScale && (l.displacementScale = a.displacementScale);
    void 0 !== a.displacementBias && (l.displacementBias = a.displacementBias);
    void 0 !== a.roughnessMap && (l.roughnessMap = b(a.roughnessMap));
    void 0 !== a.metalnessMap && (l.metalnessMap = b(a.metalnessMap));
    void 0 !== a.emissiveMap && (l.emissiveMap = b(a.emissiveMap));
    void 0 !== a.emissiveIntensity && (l.emissiveIntensity = a.emissiveIntensity);
    void 0 !== a.specularMap && (l.specularMap = b(a.specularMap));
    void 0 !== a.envMap && (l.envMap = b(a.envMap));
    void 0 !== a.envMapIntensity && (l.envMapIntensity = a.envMapIntensity);
    void 0 !== a.reflectivity && (l.reflectivity = a.reflectivity);
    void 0 !== a.refractionRatio && (l.refractionRatio = a.refractionRatio);
    void 0 !== a.lightMap && (l.lightMap = b(a.lightMap));
    void 0 !== a.lightMapIntensity && (l.lightMapIntensity = a.lightMapIntensity);
    void 0 !== a.aoMap && (l.aoMap = b(a.aoMap));
    void 0 !== a.aoMapIntensity && (l.aoMapIntensity = a.aoMapIntensity);
    void 0 !== a.gradientMap && (l.gradientMap = b(a.gradientMap));
    void 0 !== a.clearcoatMap && (l.clearcoatMap = b(a.clearcoatMap));
    void 0 !== a.clearcoatRoughnessMap && (l.clearcoatRoughnessMap = b(a.clearcoatRoughnessMap));
    void 0 !== a.clearcoatNormalMap && (l.clearcoatNormalMap = b(a.clearcoatNormalMap));
    void 0 !== a.clearcoatNormalScale && (l.clearcoatNormalScale = (new g).fromArray(a.clearcoatNormalScale));
    return l;
  }, setTextures:function(a) {
    this.textures = a;
    return this;
  }});
  var wh = {decodeText:function(a) {
    if ("undefined" !== typeof TextDecoder) {
      return (new TextDecoder).decode(a);
    }
    for (var b = "", c = 0, l = a.length; c < l; c++) {
      b += String.fromCharCode(a[c]);
    }
    try {
      return decodeURIComponent(escape(b));
    } catch (da) {
      return b;
    }
  }, extractUrlBase:function(a) {
    var b = a.lastIndexOf("/");
    return -1 === b ? "./" : a.substr(0, b + 1);
  }};
  Gf.prototype = Object.assign(Object.create(M.prototype), {constructor:Gf, isInstancedBufferGeometry:!0, copy:function(a) {
    M.prototype.copy.call(this, a);
    this.maxInstancedCount = a.maxInstancedCount;
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, toJSON:function() {
    var a = M.prototype.toJSON.call(this);
    a.maxInstancedCount = this.maxInstancedCount;
    a.isInstancedBufferGeometry = !0;
    return a;
  }});
  Hf.prototype = Object.assign(Object.create(K.prototype), {constructor:Hf, isInstancedBufferAttribute:!0, copy:function(a) {
    K.prototype.copy.call(this, a);
    this.meshPerAttribute = a.meshPerAttribute;
    return this;
  }, toJSON:function() {
    var a = K.prototype.toJSON.call(this);
    a.meshPerAttribute = this.meshPerAttribute;
    a.isInstancedBufferAttribute = !0;
    return a;
  }});
  If.prototype = Object.assign(Object.create(pa.prototype), {constructor:If, load:function(a, b, c, e) {
    var l = this, d = new lb(l.manager);
    d.setPath(l.path);
    d.load(a, function(a) {
      b(l.parse(JSON.parse(a)));
    }, c, e);
  }, parse:function(a) {
    var b = a.isInstancedBufferGeometry ? new Gf : new M, c = a.data.index;
    if (void 0 !== c) {
      var l = new xh[c.type](c.array);
      b.setIndex(new K(l, 1));
    }
    c = a.data.attributes;
    for (var e in c) {
      var d = c[e];
      l = new xh[d.type](d.array);
      l = new (d.isInstancedBufferAttribute ? Hf : K)(l, d.itemSize, d.normalized);
      void 0 !== d.name && (l.name = d.name);
      b.setAttribute(e, l);
    }
    var m = a.data.morphAttributes;
    if (m) {
      for (e in m) {
        var k = m[e], h = [];
        c = 0;
        for (var g = k.length; c < g; c++) {
          d = k[c], l = new xh[d.type](d.array), l = new K(l, d.itemSize, d.normalized), void 0 !== d.name && (l.name = d.name), h.push(l);
        }
        b.morphAttributes[e] = h;
      }
    }
    a.data.morphTargetsRelative && (b.morphTargetsRelative = !0);
    e = a.data.groups || a.data.drawcalls || a.data.offsets;
    if (void 0 !== e) {
      for (c = 0, d = e.length; c !== d; ++c) {
        l = e[c], b.addGroup(l.start, l.count, l.materialIndex);
      }
    }
    c = a.data.boundingSphere;
    void 0 !== c && (e = new f, void 0 !== c.center && e.fromArray(c.center), b.boundingSphere = new r(e, c.radius));
    a.name && (b.name = a.name);
    a.userData && (b.userData = a.userData);
    return b;
  }});
  var xh = {Int8Array:Int8Array, Uint8Array:Uint8Array, Uint8ClampedArray:"undefined" !== typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array:Int16Array, Uint16Array:Uint16Array, Int32Array:Int32Array, Uint32Array:Uint32Array, Float32Array:Float32Array, Float64Array:Float64Array};
  Jf.prototype = Object.assign(Object.create(pa.prototype), {constructor:Jf, load:function(a, b, c, e) {
    var l = this, d = "" === this.path ? wh.extractUrlBase(a) : this.path;
    this.resourcePath = this.resourcePath || d;
    d = new lb(l.manager);
    d.setPath(this.path);
    d.load(a, function(c) {
      var d = null;
      try {
        d = JSON.parse(c);
      } catch (zb) {
        void 0 !== e && e(zb);
        console.error("THREE:ObjectLoader: Can't parse " + a + ".", zb.message);
        return;
      }
      c = d.metadata;
      void 0 === c || void 0 === c.type || "geometry" === c.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + a) : l.parse(d, b);
    }, c, e);
  }, parse:function(a, b) {
    var c = this.parseShape(a.shapes);
    c = this.parseGeometries(a.geometries, c);
    var l = this.parseImages(a.images, function() {
      void 0 !== b && b(e);
    });
    l = this.parseTextures(a.textures, l);
    l = this.parseMaterials(a.materials, l);
    var e = this.parseObject(a.object, c, l);
    a.animations && (e.animations = this.parseAnimations(a.animations));
    void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e);
    return e;
  }, parseShape:function(a) {
    var b = {};
    if (void 0 !== a) {
      for (var c = 0, l = a.length; c < l; c++) {
        var e = (new qc).fromJSON(a[c]);
        b[e.uuid] = e;
      }
    }
    return b;
  }, parseGeometries:function(a, b) {
    var c = {};
    if (void 0 !== a) {
      for (var l = new If, e = 0, d = a.length; e < d; e++) {
        var m = a[e];
        switch(m.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            var f = new Xa[m.type](m.width, m.height, m.widthSegments, m.heightSegments);
            break;
          case "BoxGeometry":
          case "BoxBufferGeometry":
          case "CubeGeometry":
            f = new Xa[m.type](m.width, m.height, m.depth, m.widthSegments, m.heightSegments, m.depthSegments);
            break;
          case "CircleGeometry":
          case "CircleBufferGeometry":
            f = new Xa[m.type](m.radius, m.segments, m.thetaStart, m.thetaLength);
            break;
          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            f = new Xa[m.type](m.radiusTop, m.radiusBottom, m.height, m.radialSegments, m.heightSegments, m.openEnded, m.thetaStart, m.thetaLength);
            break;
          case "ConeGeometry":
          case "ConeBufferGeometry":
            f = new Xa[m.type](m.radius, m.height, m.radialSegments, m.heightSegments, m.openEnded, m.thetaStart, m.thetaLength);
            break;
          case "SphereGeometry":
          case "SphereBufferGeometry":
            f = new Xa[m.type](m.radius, m.widthSegments, m.heightSegments, m.phiStart, m.phiLength, m.thetaStart, m.thetaLength);
            break;
          case "DodecahedronGeometry":
          case "DodecahedronBufferGeometry":
          case "IcosahedronGeometry":
          case "IcosahedronBufferGeometry":
          case "OctahedronGeometry":
          case "OctahedronBufferGeometry":
          case "TetrahedronGeometry":
          case "TetrahedronBufferGeometry":
            f = new Xa[m.type](m.radius, m.detail);
            break;
          case "RingGeometry":
          case "RingBufferGeometry":
            f = new Xa[m.type](m.innerRadius, m.outerRadius, m.thetaSegments, m.phiSegments, m.thetaStart, m.thetaLength);
            break;
          case "TorusGeometry":
          case "TorusBufferGeometry":
            f = new Xa[m.type](m.radius, m.tube, m.radialSegments, m.tubularSegments, m.arc);
            break;
          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            f = new Xa[m.type](m.radius, m.tube, m.tubularSegments, m.radialSegments, m.p, m.q);
            break;
          case "TubeGeometry":
          case "TubeBufferGeometry":
            f = new Xa[m.type]((new vh[m.path.type]).fromJSON(m.path), m.tubularSegments, m.radius, m.radialSegments, m.closed);
            break;
          case "LatheGeometry":
          case "LatheBufferGeometry":
            f = new Xa[m.type](m.points, m.segments, m.phiStart, m.phiLength);
            break;
          case "PolyhedronGeometry":
          case "PolyhedronBufferGeometry":
            f = new Xa[m.type](m.vertices, m.indices, m.radius, m.details);
            break;
          case "ShapeGeometry":
          case "ShapeBufferGeometry":
            f = [];
            for (var k = 0, h = m.shapes.length; k < h; k++) {
              var g = b[m.shapes[k]];
              f.push(g);
            }
            f = new Xa[m.type](f, m.curveSegments);
            break;
          case "ExtrudeGeometry":
          case "ExtrudeBufferGeometry":
            f = [];
            k = 0;
            for (h = m.shapes.length; k < h; k++) {
              g = b[m.shapes[k]], f.push(g);
            }
            k = m.options.extrudePath;
            void 0 !== k && (m.options.extrudePath = (new vh[k.type]).fromJSON(k));
            f = new Xa[m.type](f, m.options);
            break;
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            f = l.parse(m);
            break;
          case "Geometry":
            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
            break;
          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + m.type + '"');
            continue;
        }
        f.uuid = m.uuid;
        void 0 !== m.name && (f.name = m.name);
        !0 === f.isBufferGeometry && void 0 !== m.userData && (f.userData = m.userData);
        c[m.uuid] = f;
      }
    }
    return c;
  }, parseMaterials:function(a, b) {
    var c = {}, l = {};
    if (void 0 !== a) {
      var e = new Ff;
      e.setTextures(b);
      b = 0;
      for (var d = a.length; b < d; b++) {
        var m = a[b];
        if ("MultiMaterial" === m.type) {
          for (var f = [], k = 0; k < m.materials.length; k++) {
            var h = m.materials[k];
            void 0 === c[h.uuid] && (c[h.uuid] = e.parse(h));
            f.push(c[h.uuid]);
          }
          l[m.uuid] = f;
        } else {
          void 0 === c[m.uuid] && (c[m.uuid] = e.parse(m)), l[m.uuid] = c[m.uuid];
        }
      }
    }
    return l;
  }, parseAnimations:function(a) {
    for (var b = [], c = 0; c < a.length; c++) {
      var l = a[c], e = kb.parse(l);
      void 0 !== l.uuid && (e.uuid = l.uuid);
      b.push(e);
    }
    return b;
  }, parseImages:function(a, b) {
    function c(a) {
      l.manager.itemStart(a);
      return d.load(a, function() {
        l.manager.itemEnd(a);
      }, void 0, function() {
        l.manager.itemError(a);
        l.manager.itemEnd(a);
      });
    }
    var l = this, e = {};
    if (void 0 !== a && 0 < a.length) {
      b = new Bg(b);
      var d = new Ad(b);
      d.setCrossOrigin(this.crossOrigin);
      b = 0;
      for (var m = a.length; b < m; b++) {
        var f = a[b], k = f.url;
        if (Array.isArray(k)) {
          e[f.uuid] = [];
          for (var h = 0, g = k.length; h < g; h++) {
            var r = k[h];
            r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(r) ? r : l.resourcePath + r;
            e[f.uuid].push(c(r));
          }
        } else {
          r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f.url) ? f.url : l.resourcePath + f.url, e[f.uuid] = c(r);
        }
      }
    }
    return e;
  }, parseTextures:function(a, b) {
    function c(a, b) {
      if ("number" === typeof a) {
        return a;
      }
      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a);
      return b[a];
    }
    var l = {};
    if (void 0 !== a) {
      for (var d = 0, m = a.length; d < m; d++) {
        var f = a[d];
        void 0 === f.image && console.warn('THREE.ObjectLoader: No "image" specified for', f.uuid);
        void 0 === b[f.image] && console.warn("THREE.ObjectLoader: Undefined image", f.image);
        var k = Array.isArray(b[f.image]) ? new Sa(b[f.image]) : new e(b[f.image]);
        k.needsUpdate = !0;
        k.uuid = f.uuid;
        void 0 !== f.name && (k.name = f.name);
        void 0 !== f.mapping && (k.mapping = c(f.mapping, lk));
        void 0 !== f.offset && k.offset.fromArray(f.offset);
        void 0 !== f.repeat && k.repeat.fromArray(f.repeat);
        void 0 !== f.center && k.center.fromArray(f.center);
        void 0 !== f.rotation && (k.rotation = f.rotation);
        void 0 !== f.wrap && (k.wrapS = c(f.wrap[0], Si), k.wrapT = c(f.wrap[1], Si));
        void 0 !== f.format && (k.format = f.format);
        void 0 !== f.type && (k.type = f.type);
        void 0 !== f.encoding && (k.encoding = f.encoding);
        void 0 !== f.minFilter && (k.minFilter = c(f.minFilter, Ti));
        void 0 !== f.magFilter && (k.magFilter = c(f.magFilter, Ti));
        void 0 !== f.anisotropy && (k.anisotropy = f.anisotropy);
        void 0 !== f.flipY && (k.flipY = f.flipY);
        void 0 !== f.premultiplyAlpha && (k.premultiplyAlpha = f.premultiplyAlpha);
        void 0 !== f.unpackAlignment && (k.unpackAlignment = f.unpackAlignment);
        l[f.uuid] = k;
      }
    }
    return l;
  }, parseObject:function(a, b, c) {
    function e(a) {
      void 0 === b[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a);
      return b[a];
    }
    function l(a) {
      if (void 0 !== a) {
        if (Array.isArray(a)) {
          for (var b = [], e = 0, l = a.length; e < l; e++) {
            var d = a[e];
            void 0 === c[d] && console.warn("THREE.ObjectLoader: Undefined material", d);
            b.push(c[d]);
          }
          return b;
        }
        void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined material", a);
        return c[a];
      }
    }
    switch(a.type) {
      case "Scene":
        var d = new y;
        void 0 !== a.background && Number.isInteger(a.background) && (d.background = new A(a.background));
        void 0 !== a.fog && ("Fog" === a.fog.type ? d.fog = new df(a.fog.color, a.fog.near, a.fog.far) : "FogExp2" === a.fog.type && (d.fog = new cf(a.fog.color, a.fog.density)));
        break;
      case "PerspectiveCamera":
        d = new ka(a.fov, a.aspect, a.near, a.far);
        void 0 !== a.focus && (d.focus = a.focus);
        void 0 !== a.zoom && (d.zoom = a.zoom);
        void 0 !== a.filmGauge && (d.filmGauge = a.filmGauge);
        void 0 !== a.filmOffset && (d.filmOffset = a.filmOffset);
        void 0 !== a.view && (d.view = Object.assign({}, a.view));
        break;
      case "OrthographicCamera":
        d = new Cd(a.left, a.right, a.top, a.bottom, a.near, a.far);
        void 0 !== a.zoom && (d.zoom = a.zoom);
        void 0 !== a.view && (d.view = Object.assign({}, a.view));
        break;
      case "AmbientLight":
        d = new Cf(a.color, a.intensity);
        break;
      case "DirectionalLight":
        d = new Bf(a.color, a.intensity);
        break;
      case "PointLight":
        d = new zf(a.color, a.intensity, a.distance, a.decay);
        break;
      case "RectAreaLight":
        d = new Df(a.color, a.intensity, a.width, a.height);
        break;
      case "SpotLight":
        d = new yf(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay);
        break;
      case "HemisphereLight":
        d = new wf(a.color, a.groundColor, a.intensity);
        break;
      case "LightProbe":
        d = (new mb).fromJSON(a);
        break;
      case "SkinnedMesh":
        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
      case "Mesh":
        d = e(a.geometry);
        var m = l(a.material);
        d = new V(d, m);
        break;
      case "InstancedMesh":
        d = e(a.geometry);
        m = l(a.material);
        var f = a.instanceMatrix;
        d = new hf(d, m, a.count);
        d.instanceMatrix = new K(new Float32Array(f.array), 16);
        break;
      case "LOD":
        d = new fe;
        break;
      case "Line":
        d = new cb(e(a.geometry), l(a.material), a.mode);
        break;
      case "LineLoop":
        d = new jf(e(a.geometry), l(a.material));
        break;
      case "LineSegments":
        d = new Da(e(a.geometry), l(a.material));
        break;
      case "PointCloud":
      case "Points":
        d = new jd(e(a.geometry), l(a.material));
        break;
      case "Sprite":
        d = new de(l(a.material));
        break;
      case "Group":
        d = new gd;
        break;
      default:
        d = new q;
    }
    d.uuid = a.uuid;
    void 0 !== a.name && (d.name = a.name);
    void 0 !== a.matrix ? (d.matrix.fromArray(a.matrix), void 0 !== a.matrixAutoUpdate && (d.matrixAutoUpdate = a.matrixAutoUpdate), d.matrixAutoUpdate && d.matrix.decompose(d.position, d.quaternion, d.scale)) : (void 0 !== a.position && d.position.fromArray(a.position), void 0 !== a.rotation && d.rotation.fromArray(a.rotation), void 0 !== a.quaternion && d.quaternion.fromArray(a.quaternion), void 0 !== a.scale && d.scale.fromArray(a.scale));
    void 0 !== a.castShadow && (d.castShadow = a.castShadow);
    void 0 !== a.receiveShadow && (d.receiveShadow = a.receiveShadow);
    a.shadow && (void 0 !== a.shadow.bias && (d.shadow.bias = a.shadow.bias), void 0 !== a.shadow.radius && (d.shadow.radius = a.shadow.radius), void 0 !== a.shadow.mapSize && d.shadow.mapSize.fromArray(a.shadow.mapSize), void 0 !== a.shadow.camera && (d.shadow.camera = this.parseObject(a.shadow.camera)));
    void 0 !== a.visible && (d.visible = a.visible);
    void 0 !== a.frustumCulled && (d.frustumCulled = a.frustumCulled);
    void 0 !== a.renderOrder && (d.renderOrder = a.renderOrder);
    void 0 !== a.userData && (d.userData = a.userData);
    void 0 !== a.layers && (d.layers.mask = a.layers);
    if (void 0 !== a.children) {
      for (f = a.children, m = 0; m < f.length; m++) {
        d.add(this.parseObject(f[m], b, c));
      }
    }
    if ("LOD" === a.type) {
      for (void 0 !== a.autoUpdate && (d.autoUpdate = a.autoUpdate), a = a.levels, f = 0; f < a.length; f++) {
        m = a[f];
        var k = d.getObjectByProperty("uuid", m.object);
        void 0 !== k && d.addLevel(k, m.distance);
      }
    }
    return d;
  }});
  var lk = {UVMapping:300, CubeReflectionMapping:301, CubeRefractionMapping:302, EquirectangularReflectionMapping:303, EquirectangularRefractionMapping:304, SphericalReflectionMapping:305, CubeUVReflectionMapping:306, CubeUVRefractionMapping:307}, Si = {RepeatWrapping:1E3, ClampToEdgeWrapping:1001, MirroredRepeatWrapping:1002}, Ti = {NearestFilter:1003, NearestMipmapNearestFilter:1004, NearestMipmapLinearFilter:1005, LinearFilter:1006, LinearMipmapNearestFilter:1007, LinearMipmapLinearFilter:1008};
  Gg.prototype = Object.assign(Object.create(pa.prototype), {constructor:Gg, setOptions:function(a) {
    this.options = a;
    return this;
  }, load:function(a, b, c, e) {
    void 0 === a && (a = "");
    void 0 !== this.path && (a = this.path + a);
    a = this.manager.resolveURL(a);
    var l = this, d = Vc.get(a);
    if (void 0 !== d) {
      return l.manager.itemStart(a), setTimeout(function() {
        b && b(d);
        l.manager.itemEnd(a);
      }, 0), d;
    }
    fetch(a).then(function(a) {
      return a.blob();
    }).then(function(a) {
      return void 0 === l.options ? createImageBitmap(a) : createImageBitmap(a, l.options);
    }).then(function(c) {
      Vc.add(a, c);
      b && b(c);
      l.manager.itemEnd(a);
    }).catch(function(b) {
      e && e(b);
      l.manager.itemError(a);
      l.manager.itemEnd(a);
    });
    l.manager.itemStart(a);
  }});
  Object.assign(Hg.prototype, {moveTo:function(a, b) {
    this.currentPath = new wb;
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(a, b);
    return this;
  }, lineTo:function(a, b) {
    this.currentPath.lineTo(a, b);
    return this;
  }, quadraticCurveTo:function(a, b, c, e) {
    this.currentPath.quadraticCurveTo(a, b, c, e);
    return this;
  }, bezierCurveTo:function(a, b, c, e, d, m) {
    this.currentPath.bezierCurveTo(a, b, c, e, d, m);
    return this;
  }, splineThru:function(a) {
    this.currentPath.splineThru(a);
    return this;
  }, toShapes:function(a, b) {
    function c(a) {
      for (var b = [], c = 0, e = a.length; c < e; c++) {
        var l = a[c], d = new qc;
        d.curves = l.curves;
        b.push(d);
      }
      return b;
    }
    function e(a, b) {
      for (var c = b.length, e = !1, l = c - 1, d = 0; d < c; l = d++) {
        var m = b[l], f = b[d], k = f.x - m.x, h = f.y - m.y;
        if (Math.abs(h) > Number.EPSILON) {
          if (0 > h && (m = b[d], k = -k, f = b[l], h = -h), !(a.y < m.y || a.y > f.y)) {
            if (a.y === m.y) {
              if (a.x === m.x) {
                return !0;
              }
            } else {
              l = h * (a.x - m.x) - k * (a.y - m.y);
              if (0 === l) {
                return !0;
              }
              0 > l || (e = !e);
            }
          }
        } else {
          if (a.y === m.y && (f.x <= a.x && a.x <= m.x || m.x <= a.x && a.x <= f.x)) {
            return !0;
          }
        }
      }
      return e;
    }
    var l = Tb.isClockWise, d = this.subPaths;
    if (0 === d.length) {
      return [];
    }
    if (!0 === b) {
      return c(d);
    }
    b = [];
    if (1 === d.length) {
      var m = d[0];
      var f = new qc;
      f.curves = m.curves;
      b.push(f);
      return b;
    }
    var k = !l(d[0].getPoints());
    k = a ? !k : k;
    f = [];
    var h = [], g = [], r = 0;
    h[r] = void 0;
    g[r] = [];
    for (var n = 0, q = d.length; n < q; n++) {
      m = d[n];
      var p = m.getPoints();
      var u = l(p);
      (u = a ? !u : u) ? (!k && h[r] && r++, h[r] = {s:new qc, p:p}, h[r].s.curves = m.curves, k && r++, g[r] = []) : g[r].push({h:m, p:p[0]});
    }
    if (!h[0]) {
      return c(d);
    }
    if (1 < h.length) {
      n = !1;
      a = [];
      l = 0;
      for (d = h.length; l < d; l++) {
        f[l] = [];
      }
      l = 0;
      for (d = h.length; l < d; l++) {
        for (m = g[l], u = 0; u < m.length; u++) {
          k = m[u];
          r = !0;
          for (p = 0; p < h.length; p++) {
            e(k.p, h[p].p) && (l !== p && a.push({froms:l, tos:p, hole:u}), r ? (r = !1, f[p].push(k)) : n = !0);
          }
          r && f[l].push(k);
        }
      }
      0 < a.length && (n || (g = f));
    }
    n = 0;
    for (l = h.length; n < l; n++) {
      for (f = h[n].s, b.push(f), a = g[n], d = 0, m = a.length; d < m; d++) {
        f.holes.push(a[d].h);
      }
    }
    return b;
  }});
  Object.assign(Ig.prototype, {isFont:!0, generateShapes:function(a, b) {
    void 0 === b && (b = 100);
    var c = [], e = b;
    b = this.data;
    var l = Array.from ? Array.from(a) : String(a).split("");
    e /= b.resolution;
    var d = (b.boundingBox.yMax - b.boundingBox.yMin + b.underlineThickness) * e;
    a = [];
    for (var m = 0, f = 0, k = 0; k < l.length; k++) {
      var h = l[k];
      if ("\n" === h) {
        m = 0, f -= d;
      } else {
        var g = h;
        h = e;
        var r = m, n = f, q = b, p = q.glyphs[g] || q.glyphs["?"];
        if (p) {
          g = new Hg;
          if (p.o) {
            q = p._cachedOutline || (p._cachedOutline = p.o.split(" "));
            for (var u = 0, t = q.length; u < t;) {
              switch(q[u++]) {
                case "m":
                  var y = q[u++] * h + r;
                  var v = q[u++] * h + n;
                  g.moveTo(y, v);
                  break;
                case "l":
                  y = q[u++] * h + r;
                  v = q[u++] * h + n;
                  g.lineTo(y, v);
                  break;
                case "q":
                  var x = q[u++] * h + r;
                  var U = q[u++] * h + n;
                  var z = q[u++] * h + r;
                  var w = q[u++] * h + n;
                  g.quadraticCurveTo(z, w, x, U);
                  break;
                case "b":
                  x = q[u++] * h + r, U = q[u++] * h + n, z = q[u++] * h + r, w = q[u++] * h + n, y = q[u++] * h + r, v = q[u++] * h + n, g.bezierCurveTo(z, w, y, v, x, U);
              }
            }
          }
          h = {offsetX:p.ha * h, path:g};
        } else {
          console.error('THREE.Font: character "' + g + '" does not exists in font family ' + q.familyName + "."), h = void 0;
        }
        m += h.offsetX;
        a.push(h.path);
      }
    }
    b = 0;
    for (l = a.length; b < l; b++) {
      Array.prototype.push.apply(c, a[b].toShapes());
    }
    return c;
  }});
  Jg.prototype = Object.assign(Object.create(pa.prototype), {constructor:Jg, load:function(a, b, c, e) {
    var l = this, d = new lb(this.manager);
    d.setPath(this.path);
    d.load(a, function(a) {
      try {
        var c = JSON.parse(a);
      } catch (zb) {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c = JSON.parse(a.substring(65, a.length - 2));
      }
      a = l.parse(c);
      b && b(a);
    }, c, e);
  }, parse:function(a) {
    return new Ig(a);
  }});
  var hg, Og = {getContext:function() {
    void 0 === hg && (hg = new (window.AudioContext || window.webkitAudioContext));
    return hg;
  }, setContext:function(a) {
    hg = a;
  }};
  Kf.prototype = Object.assign(Object.create(pa.prototype), {constructor:Kf, load:function(a, b, c, e) {
    var l = new lb(this.manager);
    l.setResponseType("arraybuffer");
    l.setPath(this.path);
    l.load(a, function(a) {
      a = a.slice(0);
      Og.getContext().decodeAudioData(a, function(a) {
        b(a);
      });
    }, c, e);
  }});
  Kg.prototype = Object.assign(Object.create(mb.prototype), {constructor:Kg, isHemisphereLightProbe:!0, copy:function(a) {
    mb.prototype.copy.call(this, a);
    return this;
  }, toJSON:function(a) {
    return mb.prototype.toJSON.call(this, a);
  }});
  Lg.prototype = Object.assign(Object.create(mb.prototype), {constructor:Lg, isAmbientLightProbe:!0, copy:function(a) {
    mb.prototype.copy.call(this, a);
    return this;
  }, toJSON:function(a) {
    return mb.prototype.toJSON.call(this, a);
  }});
  var Ui = new n, Vi = new n;
  Object.assign(li.prototype, {update:function(a) {
    var b = this._cache;
    if (b.focus !== a.focus || b.fov !== a.fov || b.aspect !== a.aspect * this.aspect || b.near !== a.near || b.far !== a.far || b.zoom !== a.zoom || b.eyeSep !== this.eyeSep) {
      b.focus = a.focus;
      b.fov = a.fov;
      b.aspect = a.aspect * this.aspect;
      b.near = a.near;
      b.far = a.far;
      b.zoom = a.zoom;
      b.eyeSep = this.eyeSep;
      var c = a.projectionMatrix.clone(), e = b.eyeSep / 2, l = e * b.near / b.focus, d = b.near * Math.tan(na.DEG2RAD * b.fov * .5) / b.zoom;
      Vi.elements[12] = -e;
      Ui.elements[12] = e;
      e = -d * b.aspect + l;
      var m = d * b.aspect + l;
      c.elements[0] = 2 * b.near / (m - e);
      c.elements[8] = (m + e) / (m - e);
      this.cameraL.projectionMatrix.copy(c);
      e = -d * b.aspect - l;
      m = d * b.aspect - l;
      c.elements[0] = 2 * b.near / (m - e);
      c.elements[8] = (m + e) / (m - e);
      this.cameraR.projectionMatrix.copy(c);
    }
    this.cameraL.matrixWorld.copy(a.matrixWorld).multiply(Vi);
    this.cameraR.matrixWorld.copy(a.matrixWorld).multiply(Ui);
  }});
  Object.assign(Mg.prototype, {start:function() {
    this.oldTime = this.startTime = ("undefined" === typeof performance ? Date : performance).now();
    this.elapsedTime = 0;
    this.running = !0;
  }, stop:function() {
    this.getElapsedTime();
    this.autoStart = this.running = !1;
  }, getElapsedTime:function() {
    this.getDelta();
    return this.elapsedTime;
  }, getDelta:function() {
    var a = 0;
    if (this.autoStart && !this.running) {
      return this.start(), 0;
    }
    if (this.running) {
      var b = ("undefined" === typeof performance ? Date : performance).now();
      a = (b - this.oldTime) / 1E3;
      this.oldTime = b;
      this.elapsedTime += a;
    }
    return a;
  }});
  var Wc = new f, Wi = new t, mk = new f, Xc = new f;
  Ng.prototype = Object.assign(Object.create(q.prototype), {constructor:Ng, getInput:function() {
    return this.gain;
  }, removeFilter:function() {
    null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null);
    return this;
  }, getFilter:function() {
    return this.filter;
  }, setFilter:function(a) {
    null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination);
    this.filter = a;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  }, getMasterVolume:function() {
    return this.gain.gain.value;
  }, setMasterVolume:function(a) {
    this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01);
    return this;
  }, updateMatrixWorld:function(a) {
    q.prototype.updateMatrixWorld.call(this, a);
    a = this.context.listener;
    var b = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(Wc, Wi, mk);
    Xc.set(0, 0, -1).applyQuaternion(Wi);
    if (a.positionX) {
      var c = this.context.currentTime + this.timeDelta;
      a.positionX.linearRampToValueAtTime(Wc.x, c);
      a.positionY.linearRampToValueAtTime(Wc.y, c);
      a.positionZ.linearRampToValueAtTime(Wc.z, c);
      a.forwardX.linearRampToValueAtTime(Xc.x, c);
      a.forwardY.linearRampToValueAtTime(Xc.y, c);
      a.forwardZ.linearRampToValueAtTime(Xc.z, c);
      a.upX.linearRampToValueAtTime(b.x, c);
      a.upY.linearRampToValueAtTime(b.y, c);
      a.upZ.linearRampToValueAtTime(b.z, c);
    } else {
      a.setPosition(Wc.x, Wc.y, Wc.z), a.setOrientation(Xc.x, Xc.y, Xc.z, b.x, b.y, b.z);
    }
  }});
  Dd.prototype = Object.assign(Object.create(q.prototype), {constructor:Dd, getOutput:function() {
    return this.gain;
  }, setNodeSource:function(a) {
    this.hasPlaybackControl = !1;
    this.sourceType = "audioNode";
    this.source = a;
    this.connect();
    return this;
  }, setMediaElementSource:function(a) {
    this.hasPlaybackControl = !1;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(a);
    this.connect();
    return this;
  }, setMediaStreamSource:function(a) {
    this.hasPlaybackControl = !1;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(a);
    this.connect();
    return this;
  }, setBuffer:function(a) {
    this.buffer = a;
    this.sourceType = "buffer";
    this.autoplay && this.play();
    return this;
  }, play:function(a) {
    void 0 === a && (a = 0);
    if (!0 === this.isPlaying) {
      console.warn("THREE.Audio: Audio is already playing.");
    } else {
      if (!1 === this.hasPlaybackControl) {
        console.warn("THREE.Audio: this Audio has no playback control.");
      } else {
        return this._startedAt = this.context.currentTime + a, a = this.context.createBufferSource(), a.buffer = this.buffer, a.loop = this.loop, a.loopStart = this.loopStart, a.loopEnd = this.loopEnd, a.onended = this.onEnded.bind(this), a.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = a, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
      }
    }
  }, pause:function() {
    if (!1 === this.hasPlaybackControl) {
      console.warn("THREE.Audio: this Audio has no playback control.");
    } else {
      return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress %= this.duration || this.buffer.duration), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
    }
  }, stop:function() {
    if (!1 === this.hasPlaybackControl) {
      console.warn("THREE.Audio: this Audio has no playback control.");
    } else {
      return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
    }
  }, connect:function() {
    if (0 < this.filters.length) {
      this.source.connect(this.filters[0]);
      for (var a = 1, b = this.filters.length; a < b; a++) {
        this.filters[a - 1].connect(this.filters[a]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    return this;
  }, disconnect:function() {
    if (0 < this.filters.length) {
      this.source.disconnect(this.filters[0]);
      for (var a = 1, b = this.filters.length; a < b; a++) {
        this.filters[a - 1].disconnect(this.filters[a]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    return this;
  }, getFilters:function() {
    return this.filters;
  }, setFilters:function(a) {
    a || (a = []);
    !0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a;
    return this;
  }, setDetune:function(a) {
    this.detune = a;
    if (void 0 !== this.source.detune) {
      return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this;
    }
  }, getDetune:function() {
    return this.detune;
  }, getFilter:function() {
    return this.getFilters()[0];
  }, setFilter:function(a) {
    return this.setFilters(a ? [a] : []);
  }, setPlaybackRate:function(a) {
    if (!1 === this.hasPlaybackControl) {
      console.warn("THREE.Audio: this Audio has no playback control.");
    } else {
      return this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
    }
  }, getPlaybackRate:function() {
    return this.playbackRate;
  }, onEnded:function() {
    this.isPlaying = !1;
  }, getLoop:function() {
    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }, setLoop:function(a) {
    if (!1 === this.hasPlaybackControl) {
      console.warn("THREE.Audio: this Audio has no playback control.");
    } else {
      return this.loop = a, !0 === this.isPlaying && (this.source.loop = this.loop), this;
    }
  }, setLoopStart:function(a) {
    this.loopStart = a;
    return this;
  }, setLoopEnd:function(a) {
    this.loopEnd = a;
    return this;
  }, getVolume:function() {
    return this.gain.gain.value;
  }, setVolume:function(a) {
    this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01);
    return this;
  }});
  var Yc = new f, Xi = new t, nk = new f, Zc = new f;
  Pg.prototype = Object.assign(Object.create(Dd.prototype), {constructor:Pg, getOutput:function() {
    return this.panner;
  }, getRefDistance:function() {
    return this.panner.refDistance;
  }, setRefDistance:function(a) {
    this.panner.refDistance = a;
    return this;
  }, getRolloffFactor:function() {
    return this.panner.rolloffFactor;
  }, setRolloffFactor:function(a) {
    this.panner.rolloffFactor = a;
    return this;
  }, getDistanceModel:function() {
    return this.panner.distanceModel;
  }, setDistanceModel:function(a) {
    this.panner.distanceModel = a;
    return this;
  }, getMaxDistance:function() {
    return this.panner.maxDistance;
  }, setMaxDistance:function(a) {
    this.panner.maxDistance = a;
    return this;
  }, setDirectionalCone:function(a, b, c) {
    this.panner.coneInnerAngle = a;
    this.panner.coneOuterAngle = b;
    this.panner.coneOuterGain = c;
    return this;
  }, updateMatrixWorld:function(a) {
    q.prototype.updateMatrixWorld.call(this, a);
    if (!0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
      if (this.matrixWorld.decompose(Yc, Xi, nk), Zc.set(0, 0, 1).applyQuaternion(Xi), a = this.panner, a.positionX) {
        var b = this.context.currentTime + this.listener.timeDelta;
        a.positionX.linearRampToValueAtTime(Yc.x, b);
        a.positionY.linearRampToValueAtTime(Yc.y, b);
        a.positionZ.linearRampToValueAtTime(Yc.z, b);
        a.orientationX.linearRampToValueAtTime(Zc.x, b);
        a.orientationY.linearRampToValueAtTime(Zc.y, b);
        a.orientationZ.linearRampToValueAtTime(Zc.z, b);
      } else {
        a.setPosition(Yc.x, Yc.y, Yc.z), a.setOrientation(Zc.x, Zc.y, Zc.z);
      }
    }
  }});
  Object.assign(Qg.prototype, {getFrequencyData:function() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }, getAverageFrequency:function() {
    for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++) {
      a += b[c];
    }
    return a / b.length;
  }});
  Object.assign(Rg.prototype, {accumulate:function(a, b) {
    var c = this.buffer, e = this.valueSize;
    a = a * e + e;
    var l = this.cumulativeWeight;
    if (0 === l) {
      for (l = 0; l !== e; ++l) {
        c[a + l] = c[l];
      }
      l = b;
    } else {
      l += b, this._mixBufferRegion(c, a, 0, b / l, e);
    }
    this.cumulativeWeight = l;
  }, accumulateAdditive:function(a) {
    var b = this.buffer, c = this.valueSize, e = c * this._addIndex;
    0 === this.cumulativeWeightAdditive && this._setIdentity();
    this._mixBufferRegionAdditive(b, e, 0, a, c);
    this.cumulativeWeightAdditive += a;
  }, apply:function(a) {
    var b = this.valueSize, c = this.buffer;
    a = a * b + b;
    var e = this.cumulativeWeight, l = this.cumulativeWeightAdditive, d = this.binding;
    this.cumulativeWeightAdditive = this.cumulativeWeight = 0;
    1 > e && this._mixBufferRegion(c, a, b * this._origIndex, 1 - e, b);
    0 < l && this._mixBufferRegionAdditive(c, a, this._addIndex * b, 1, b);
    e = b;
    for (l = b + b; e !== l; ++e) {
      if (c[e] !== c[e + b]) {
        d.setValue(c, a);
        break;
      }
    }
  }, saveOriginalState:function() {
    var a = this.buffer, b = this.valueSize, c = b * this._origIndex;
    this.binding.getValue(a, c);
    for (var e = b; e !== c; ++e) {
      a[e] = a[c + e % b];
    }
    this._setIdentity();
    this.cumulativeWeightAdditive = this.cumulativeWeight = 0;
  }, restoreOriginalState:function() {
    this.binding.setValue(this.buffer, 3 * this.valueSize);
  }, _setAdditiveIdentityNumeric:function() {
    var a = this._addIndex * this.valueSize;
    this.buffer.fill(0, a, a + this.valueSize);
  }, _setAdditiveIdentityQuaternion:function() {
    this._setAdditiveIdentityNumeric();
    this.buffer[4 * this._addIndex + 3] = 1;
  }, _setAdditiveIdentityOther:function() {
    this.buffer.copyWithin(this._addIndex * this.valueSize, this._origIndex * this.valueSize, this.valueSize);
  }, _select:function(a, b, c, e, d) {
    if (.5 <= e) {
      for (e = 0; e !== d; ++e) {
        a[b + e] = a[c + e];
      }
    }
  }, _slerp:function(a, b, c, e) {
    t.slerpFlat(a, b, a, b, a, c, e);
  }, _slerpAdditive:function(a, b, c, e, d) {
    d *= this._workIndex;
    t.multiplyQuaternionsFlat(a, d, a, b, a, c);
    t.slerpFlat(a, b, a, b, a, d, e);
  }, _lerp:function(a, b, c, e, d) {
    for (var l = 1 - e, m = 0; m !== d; ++m) {
      var f = b + m;
      a[f] = a[f] * l + a[c + m] * e;
    }
  }, _lerpAdditive:function(a, b, c, e, d) {
    for (var l = 0; l !== d; ++l) {
      var m = b + l;
      a[m] += a[c + l] * e;
    }
  }});
  var ok = /[\[\]\.:\/]/g, pk = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", qk = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), rk = /(WCOD+)?/.source.replace("WCOD", pk), sk = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), tk = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), uk = new RegExp("^" + qk + rk + sk + tk + "$"), vk = ["material", "materials", "bones"];
  Object.assign(mi.prototype, {getValue:function(a, b) {
    this.bind();
    var c = this._bindings[this._targetGroup.nCachedObjects_];
    void 0 !== c && c.getValue(a, b);
  }, setValue:function(a, b) {
    for (var c = this._bindings, e = this._targetGroup.nCachedObjects_, l = c.length; e !== l; ++e) {
      c[e].setValue(a, b);
    }
  }, bind:function() {
    for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) {
      a[b].bind();
    }
  }, unbind:function() {
    for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) {
      a[b].unbind();
    }
  }});
  Object.assign(Ua, {Composite:mi, create:function(a, b, c) {
    return a && a.isAnimationObjectGroup ? new Ua.Composite(a, b, c) : new Ua(a, b, c);
  }, sanitizeNodeName:function(a) {
    return a.replace(/\s/g, "_").replace(ok, "");
  }, parseTrackName:function(a) {
    var b = uk.exec(a);
    if (!b) {
      throw Error("PropertyBinding: Cannot parse trackName: " + a);
    }
    b = {nodeName:b[2], objectName:b[3], objectIndex:b[4], propertyName:b[5], propertyIndex:b[6]};
    var c = b.nodeName && b.nodeName.lastIndexOf(".");
    if (void 0 !== c && -1 !== c) {
      var e = b.nodeName.substring(c + 1);
      -1 !== vk.indexOf(e) && (b.nodeName = b.nodeName.substring(0, c), b.objectName = e);
    }
    if (null === b.propertyName || 0 === b.propertyName.length) {
      throw Error("PropertyBinding: can not parse propertyName from trackName: " + a);
    }
    return b;
  }, findNode:function(a, b) {
    if (!b || "" === b || "." === b || -1 === b || b === a.name || b === a.uuid) {
      return a;
    }
    if (a.skeleton) {
      var c = a.skeleton.getBoneByName(b);
      if (void 0 !== c) {
        return c;
      }
    }
    if (a.children) {
      var e = function(a) {
        for (var c = 0; c < a.length; c++) {
          var d = a[c];
          if (d.name === b || d.uuid === b || (d = e(d.children))) {
            return d;
          }
        }
        return null;
      };
      if (a = e(a.children)) {
        return a;
      }
    }
    return null;
  }});
  Object.assign(Ua.prototype, {_getValue_unavailable:function() {
  }, _setValue_unavailable:function() {
  }, BindingType:{Direct:0, EntireArray:1, ArrayElement:2, HasFromToArray:3}, Versioning:{None:0, NeedsUpdate:1, MatrixWorldNeedsUpdate:2}, GetterByBindingType:[function(a, b) {
    a[b] = this.node[this.propertyName];
  }, function(a, b) {
    for (var c = this.resolvedProperty, e = 0, d = c.length; e !== d; ++e) {
      a[b++] = c[e];
    }
  }, function(a, b) {
    a[b] = this.resolvedProperty[this.propertyIndex];
  }, function(a, b) {
    this.resolvedProperty.toArray(a, b);
  }], SetterByBindingTypeAndVersioning:[[function(a, b) {
    this.targetObject[this.propertyName] = a[b];
  }, function(a, b) {
    this.targetObject[this.propertyName] = a[b];
    this.targetObject.needsUpdate = !0;
  }, function(a, b) {
    this.targetObject[this.propertyName] = a[b];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }], [function(a, b) {
    for (var c = this.resolvedProperty, e = 0, d = c.length; e !== d; ++e) {
      c[e] = a[b++];
    }
  }, function(a, b) {
    for (var c = this.resolvedProperty, e = 0, d = c.length; e !== d; ++e) {
      c[e] = a[b++];
    }
    this.targetObject.needsUpdate = !0;
  }, function(a, b) {
    for (var c = this.resolvedProperty, e = 0, d = c.length; e !== d; ++e) {
      c[e] = a[b++];
    }
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }], [function(a, b) {
    this.resolvedProperty[this.propertyIndex] = a[b];
  }, function(a, b) {
    this.resolvedProperty[this.propertyIndex] = a[b];
    this.targetObject.needsUpdate = !0;
  }, function(a, b) {
    this.resolvedProperty[this.propertyIndex] = a[b];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }], [function(a, b) {
    this.resolvedProperty.fromArray(a, b);
  }, function(a, b) {
    this.resolvedProperty.fromArray(a, b);
    this.targetObject.needsUpdate = !0;
  }, function(a, b) {
    this.resolvedProperty.fromArray(a, b);
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }]], getValue:function(a, b) {
    this.bind();
    this.getValue(a, b);
  }, setValue:function(a, b) {
    this.bind();
    this.setValue(a, b);
  }, bind:function() {
    var a = this.node, b = this.parsedPath, c = b.objectName, e = b.propertyName, d = b.propertyIndex;
    a || (this.node = a = Ua.findNode(this.rootNode, b.nodeName) || this.rootNode);
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (a) {
      if (c) {
        var m = b.objectIndex;
        switch(c) {
          case "materials":
            if (!a.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!a.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            a = a.material.materials;
            break;
          case "bones":
            if (!a.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            a = a.skeleton.bones;
            for (c = 0; c < a.length; c++) {
              if (a[c].name === m) {
                m = c;
                break;
              }
            }
            break;
          default:
            if (void 0 === a[c]) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            a = a[c];
        }
        if (void 0 !== m) {
          if (void 0 === a[m]) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, a);
            return;
          }
          a = a[m];
        }
      }
      m = a[e];
      if (void 0 === m) {
        console.error("THREE.PropertyBinding: Trying to update property for track: " + b.nodeName + "." + e + " but it wasn't found.", a);
      } else {
        b = this.Versioning.None;
        this.targetObject = a;
        void 0 !== a.needsUpdate ? b = this.Versioning.NeedsUpdate : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate);
        c = this.BindingType.Direct;
        if (void 0 !== d) {
          if ("morphTargetInfluences" === e) {
            if (!a.geometry) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              return;
            }
            if (a.geometry.isBufferGeometry) {
              if (!a.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              for (c = 0; c < this.node.geometry.morphAttributes.position.length; c++) {
                if (a.geometry.morphAttributes.position[c].name === d) {
                  d = c;
                  break;
                }
              }
            } else {
              if (!a.geometry.morphTargets) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                return;
              }
              for (c = 0; c < this.node.geometry.morphTargets.length; c++) {
                if (a.geometry.morphTargets[c].name === d) {
                  d = c;
                  break;
                }
              }
            }
          }
          c = this.BindingType.ArrayElement;
          this.resolvedProperty = m;
          this.propertyIndex = d;
        } else {
          void 0 !== m.fromArray && void 0 !== m.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = m) : Array.isArray(m) ? (c = this.BindingType.EntireArray, this.resolvedProperty = m) : this.propertyName = e;
        }
        this.getValue = this.GetterByBindingType[c];
        this.setValue = this.SetterByBindingTypeAndVersioning[c][b];
      }
    } else {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
    }
  }, unbind:function() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }});
  Object.assign(Ua.prototype, {_getValue_unbound:Ua.prototype.getValue, _setValue_unbound:Ua.prototype.setValue});
  Object.assign(ni.prototype, {isAnimationObjectGroup:!0, add:function() {
    for (var a = this._objects, b = a.length, c = this.nCachedObjects_, e = this._indicesByUUID, d = this._paths, m = this._parsedPaths, f = this._bindings, k = f.length, h = void 0, g = 0, r = arguments.length; g !== r; ++g) {
      var n = arguments[g], q = n.uuid, p = e[q];
      if (void 0 === p) {
        p = b++;
        e[q] = p;
        a.push(n);
        q = 0;
        for (var u = k; q !== u; ++q) {
          f[q].push(new Ua(n, d[q], m[q]));
        }
      } else {
        if (p < c) {
          h = a[p];
          var t = --c;
          u = a[t];
          e[u.uuid] = p;
          a[p] = u;
          e[q] = t;
          a[t] = n;
          q = 0;
          for (u = k; q !== u; ++q) {
            var y = f[q], v = y[p];
            y[p] = y[t];
            void 0 === v && (v = new Ua(n, d[q], m[q]));
            y[t] = v;
          }
        } else {
          a[p] !== h && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
        }
      }
    }
    this.nCachedObjects_ = c;
  }, remove:function() {
    for (var a = this._objects, b = this.nCachedObjects_, c = this._indicesByUUID, e = this._bindings, d = e.length, m = 0, f = arguments.length; m !== f; ++m) {
      var k = arguments[m], h = k.uuid, g = c[h];
      if (void 0 !== g && g >= b) {
        var r = b++, n = a[r];
        c[n.uuid] = g;
        a[g] = n;
        c[h] = r;
        a[r] = k;
        k = 0;
        for (h = d; k !== h; ++k) {
          n = e[k];
          var q = n[g];
          n[g] = n[r];
          n[r] = q;
        }
      }
    }
    this.nCachedObjects_ = b;
  }, uncache:function() {
    for (var a = this._objects, b = a.length, c = this.nCachedObjects_, e = this._indicesByUUID, d = this._bindings, m = d.length, f = 0, k = arguments.length; f !== k; ++f) {
      var h = arguments[f].uuid, g = e[h];
      if (void 0 !== g) {
        if (delete e[h], g < c) {
          h = --c;
          var r = a[h], n = --b, q = a[n];
          e[r.uuid] = g;
          a[g] = r;
          e[q.uuid] = h;
          a[h] = q;
          a.pop();
          r = 0;
          for (q = m; r !== q; ++r) {
            var p = d[r], u = p[n];
            p[g] = p[h];
            p[h] = u;
            p.pop();
          }
        } else {
          for (n = --b, q = a[n], e[q.uuid] = g, a[g] = q, a.pop(), r = 0, q = m; r !== q; ++r) {
            p = d[r], p[g] = p[n], p.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = c;
  }, subscribe_:function(a, b) {
    var c = this._bindingsIndicesByPath, e = c[a], d = this._bindings;
    if (void 0 !== e) {
      return d[e];
    }
    var l = this._paths, m = this._parsedPaths, f = this._objects, k = this.nCachedObjects_, h = Array(f.length);
    e = d.length;
    c[a] = e;
    l.push(a);
    m.push(b);
    d.push(h);
    c = k;
    for (e = f.length; c !== e; ++c) {
      h[c] = new Ua(f[c], a, b);
    }
    return h;
  }, unsubscribe_:function(a) {
    var b = this._bindingsIndicesByPath, c = b[a];
    if (void 0 !== c) {
      var e = this._paths, d = this._parsedPaths, l = this._bindings, m = l.length - 1, f = l[m];
      b[a[m]] = c;
      l[c] = f;
      l.pop();
      d[c] = d[m];
      d.pop();
      e[c] = e[m];
      e.pop();
    }
  }});
  Object.assign(oi.prototype, {play:function() {
    this._mixer._activateAction(this);
    return this;
  }, stop:function() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }, reset:function() {
    this.paused = !1;
    this.enabled = !0;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }, isRunning:function() {
    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
  }, isScheduled:function() {
    return this._mixer._isActiveAction(this);
  }, startAt:function(a) {
    this._startTime = a;
    return this;
  }, setLoop:function(a, b) {
    this.loop = a;
    this.repetitions = b;
    return this;
  }, setEffectiveWeight:function(a) {
    this.weight = a;
    this._effectiveWeight = this.enabled ? a : 0;
    return this.stopFading();
  }, getEffectiveWeight:function() {
    return this._effectiveWeight;
  }, fadeIn:function(a) {
    return this._scheduleFading(a, 0, 1);
  }, fadeOut:function(a) {
    return this._scheduleFading(a, 1, 0);
  }, crossFadeFrom:function(a, b, c) {
    a.fadeOut(b);
    this.fadeIn(b);
    if (c) {
      c = this._clip.duration;
      var e = a._clip.duration, d = c / e;
      a.warp(1, e / c, b);
      this.warp(d, 1, b);
    }
    return this;
  }, crossFadeTo:function(a, b, c) {
    return a.crossFadeFrom(this, b, c);
  }, stopFading:function() {
    var a = this._weightInterpolant;
    null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a));
    return this;
  }, setEffectiveTimeScale:function(a) {
    this.timeScale = a;
    this._effectiveTimeScale = this.paused ? 0 : a;
    return this.stopWarping();
  }, getEffectiveTimeScale:function() {
    return this._effectiveTimeScale;
  }, setDuration:function(a) {
    this.timeScale = this._clip.duration / a;
    return this.stopWarping();
  }, syncWith:function(a) {
    this.time = a.time;
    this.timeScale = a.timeScale;
    return this.stopWarping();
  }, halt:function(a) {
    return this.warp(this._effectiveTimeScale, 0, a);
  }, warp:function(a, b, c) {
    var e = this._mixer, d = e.time, l = this._timeScaleInterpolant, m = this.timeScale;
    null === l && (this._timeScaleInterpolant = l = e._lendControlInterpolant());
    e = l.parameterPositions;
    l = l.sampleValues;
    e[0] = d;
    e[1] = d + c;
    l[0] = a / m;
    l[1] = b / m;
    return this;
  }, stopWarping:function() {
    var a = this._timeScaleInterpolant;
    null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a));
    return this;
  }, getMixer:function() {
    return this._mixer;
  }, getClip:function() {
    return this._clip;
  }, getRoot:function() {
    return this._localRoot || this._mixer._root;
  }, _update:function(a, b, c, e) {
    if (this.enabled) {
      var d = this._startTime;
      if (null !== d) {
        b = (a - d) * c;
        if (0 > b || 0 === c) {
          return;
        }
        this._startTime = null;
        b *= c;
      }
      b *= this._updateTimeScale(a);
      c = this._updateTime(b);
      a = this._updateWeight(a);
      if (0 < a) {
        switch(b = this._interpolants, d = this._propertyBindings, this.blendMode) {
          case 2501:
            for (var l = 0, m = b.length; l !== m; ++l) {
              b[l].evaluate(c), d[l].accumulateAdditive(a);
            }
            break;
          default:
            for (l = 0, m = b.length; l !== m; ++l) {
              b[l].evaluate(c), d[l].accumulate(e, a);
            }
        }
      }
    } else {
      this._updateWeight(a);
    }
  }, _updateWeight:function(a) {
    var b = 0;
    if (this.enabled) {
      b = this.weight;
      var c = this._weightInterpolant;
      if (null !== c) {
        var e = c.evaluate(a)[0];
        b *= e;
        a > c.parameterPositions[1] && (this.stopFading(), 0 === e && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = b;
  }, _updateTimeScale:function(a) {
    var b = 0;
    if (!this.paused) {
      b = this.timeScale;
      var c = this._timeScaleInterpolant;
      if (null !== c) {
        var e = c.evaluate(a)[0];
        b *= e;
        a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b);
      }
    }
    return this._effectiveTimeScale = b;
  }, _updateTime:function(a) {
    var b = this.time + a, c = this._clip.duration, e = this.loop, d = this._loopCount, l = 2202 === e;
    if (0 === a) {
      return -1 === d ? b : l && 1 === (d & 1) ? c - b : b;
    }
    if (2200 === e) {
      a: {
        if (-1 === d && (this._loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) {
          b = c;
        } else {
          if (0 > b) {
            b = 0;
          } else {
            this.time = b;
            break a;
          }
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1;
        this.time = b;
        this._mixer.dispatchEvent({type:"finished", action:this, direction:0 > a ? -1 : 1});
      }
    } else {
      -1 === d && (0 <= a ? (d = 0, this._setEndings(!0, 0 === this.repetitions, l)) : this._setEndings(0 === this.repetitions, !0, l));
      if (b >= c || 0 > b) {
        e = Math.floor(b / c);
        b -= c * e;
        d += Math.abs(e);
        var m = this.repetitions - d;
        0 >= m ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = b = 0 < a ? c : 0, this._mixer.dispatchEvent({type:"finished", action:this, direction:0 < a ? 1 : -1})) : (1 === m ? (a = 0 > a, this._setEndings(a, !a, l)) : this._setEndings(!1, !1, l), this._loopCount = d, this.time = b, this._mixer.dispatchEvent({type:"loop", action:this, loopDelta:e}));
      } else {
        this.time = b;
      }
      if (l && 1 === (d & 1)) {
        return c - b;
      }
    }
    return b;
  }, _setEndings:function(a, b, c) {
    var e = this._interpolantSettings;
    c ? (e.endingStart = 2401, e.endingEnd = 2401) : (e.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, e.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
  }, _scheduleFading:function(a, b, c) {
    var e = this._mixer, d = e.time, l = this._weightInterpolant;
    null === l && (this._weightInterpolant = l = e._lendControlInterpolant());
    e = l.parameterPositions;
    l = l.sampleValues;
    e[0] = d;
    l[0] = b;
    e[1] = d + a;
    l[1] = c;
    return this;
  }});
  Sg.prototype = Object.assign(Object.create(d.prototype), {constructor:Sg, _bindAction:function(a, b) {
    var c = a._localRoot || this._root, e = a._clip.tracks, d = e.length, l = a._propertyBindings;
    a = a._interpolants;
    var m = c.uuid, f = this._bindingsByRootAndName, k = f[m];
    void 0 === k && (k = {}, f[m] = k);
    for (f = 0; f !== d; ++f) {
      var h = e[f], g = h.name, r = k[g];
      if (void 0 === r) {
        r = l[f];
        if (void 0 !== r) {
          null === r._cacheIndex && (++r.referenceCount, this._addInactiveBinding(r, m, g));
          continue;
        }
        r = new Rg(Ua.create(c, g, b && b._propertyBindings[f].binding.parsedPath), h.ValueTypeName, h.getValueSize());
        ++r.referenceCount;
        this._addInactiveBinding(r, m, g);
      }
      l[f] = r;
      a[f].resultBuffer = r.buffer;
    }
  }, _activateAction:function(a) {
    if (!this._isActiveAction(a)) {
      if (null === a._cacheIndex) {
        var b = (a._localRoot || this._root).uuid, c = a._clip.uuid, e = this._actionsByClip[c];
        this._bindAction(a, e && e.knownActions[0]);
        this._addInactiveAction(a, c, b);
      }
      b = a._propertyBindings;
      c = 0;
      for (e = b.length; c !== e; ++c) {
        var d = b[c];
        0 === d.useCount++ && (this._lendBinding(d), d.saveOriginalState());
      }
      this._lendAction(a);
    }
  }, _deactivateAction:function(a) {
    if (this._isActiveAction(a)) {
      for (var b = a._propertyBindings, c = 0, e = b.length; c !== e; ++c) {
        var d = b[c];
        0 === --d.useCount && (d.restoreOriginalState(), this._takeBackBinding(d));
      }
      this._takeBackAction(a);
    }
  }, _initMemoryManager:function() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    var a = this;
    this.stats = {actions:{get total() {
      return a._actions.length;
    }, get inUse() {
      return a._nActiveActions;
    }}, bindings:{get total() {
      return a._bindings.length;
    }, get inUse() {
      return a._nActiveBindings;
    }}, controlInterpolants:{get total() {
      return a._controlInterpolants.length;
    }, get inUse() {
      return a._nActiveControlInterpolants;
    }}};
  }, _isActiveAction:function(a) {
    a = a._cacheIndex;
    return null !== a && a < this._nActiveActions;
  }, _addInactiveAction:function(a, b, c) {
    var e = this._actions, d = this._actionsByClip, l = d[b];
    void 0 === l ? (l = {knownActions:[a], actionByRoot:{}}, a._byClipCacheIndex = 0, d[b] = l) : (b = l.knownActions, a._byClipCacheIndex = b.length, b.push(a));
    a._cacheIndex = e.length;
    e.push(a);
    l.actionByRoot[c] = a;
  }, _removeInactiveAction:function(a) {
    var b = this._actions, c = b[b.length - 1], e = a._cacheIndex;
    c._cacheIndex = e;
    b[e] = c;
    b.pop();
    a._cacheIndex = null;
    b = a._clip.uuid;
    c = this._actionsByClip;
    e = c[b];
    var d = e.knownActions, l = d[d.length - 1], m = a._byClipCacheIndex;
    l._byClipCacheIndex = m;
    d[m] = l;
    d.pop();
    a._byClipCacheIndex = null;
    delete e.actionByRoot[(a._localRoot || this._root).uuid];
    0 === d.length && delete c[b];
    this._removeInactiveBindingsForAction(a);
  }, _removeInactiveBindingsForAction:function(a) {
    a = a._propertyBindings;
    for (var b = 0, c = a.length; b !== c; ++b) {
      var e = a[b];
      0 === --e.referenceCount && this._removeInactiveBinding(e);
    }
  }, _lendAction:function(a) {
    var b = this._actions, c = a._cacheIndex, e = this._nActiveActions++, d = b[e];
    a._cacheIndex = e;
    b[e] = a;
    d._cacheIndex = c;
    b[c] = d;
  }, _takeBackAction:function(a) {
    var b = this._actions, c = a._cacheIndex, e = --this._nActiveActions, d = b[e];
    a._cacheIndex = e;
    b[e] = a;
    d._cacheIndex = c;
    b[c] = d;
  }, _addInactiveBinding:function(a, b, c) {
    var e = this._bindingsByRootAndName, d = e[b], l = this._bindings;
    void 0 === d && (d = {}, e[b] = d);
    d[c] = a;
    a._cacheIndex = l.length;
    l.push(a);
  }, _removeInactiveBinding:function(a) {
    var b = this._bindings, c = a.binding, e = c.rootNode.uuid;
    c = c.path;
    var d = this._bindingsByRootAndName, l = d[e], m = b[b.length - 1];
    a = a._cacheIndex;
    m._cacheIndex = a;
    b[a] = m;
    b.pop();
    delete l[c];
    0 === Object.keys(l).length && delete d[e];
  }, _lendBinding:function(a) {
    var b = this._bindings, c = a._cacheIndex, e = this._nActiveBindings++, d = b[e];
    a._cacheIndex = e;
    b[e] = a;
    d._cacheIndex = c;
    b[c] = d;
  }, _takeBackBinding:function(a) {
    var b = this._bindings, c = a._cacheIndex, e = --this._nActiveBindings, d = b[e];
    a._cacheIndex = e;
    b[e] = a;
    d._cacheIndex = c;
    b[c] = d;
  }, _lendControlInterpolant:function() {
    var a = this._controlInterpolants, b = this._nActiveControlInterpolants++, c = a[b];
    void 0 === c && (c = new Be(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c);
    return c;
  }, _takeBackControlInterpolant:function(a) {
    var b = this._controlInterpolants, c = a.__cacheIndex, e = --this._nActiveControlInterpolants, d = b[e];
    a.__cacheIndex = e;
    b[e] = a;
    d.__cacheIndex = c;
    b[c] = d;
  }, _controlInterpolantsResultBuffer:new Float32Array(1), clipAction:function(a, b, c) {
    var e = b || this._root, d = e.uuid;
    e = "string" === typeof a ? kb.findByName(e, a) : a;
    a = null !== e ? e.uuid : a;
    var l = this._actionsByClip[a], m = null;
    void 0 === c && (c = null !== e ? e.blendMode : 2500);
    if (void 0 !== l) {
      m = l.actionByRoot[d];
      if (void 0 !== m && m.blendMode === c) {
        return m;
      }
      m = l.knownActions[0];
      null === e && (e = m._clip);
    }
    if (null === e) {
      return null;
    }
    b = new oi(this, e, b, c);
    this._bindAction(b, m);
    this._addInactiveAction(b, a, d);
    return b;
  }, existingAction:function(a, b) {
    var c = b || this._root;
    b = c.uuid;
    c = "string" === typeof a ? kb.findByName(c, a) : a;
    a = this._actionsByClip[c ? c.uuid : a];
    return void 0 !== a ? a.actionByRoot[b] || null : null;
  }, stopAllAction:function() {
    for (var a = this._actions, b = this._nActiveActions, c = this._bindings, e = this._nActiveBindings, d = this._nActiveBindings = this._nActiveActions = 0; d !== b; ++d) {
      a[d].reset();
    }
    for (d = 0; d !== e; ++d) {
      c[d].useCount = 0;
    }
    return this;
  }, update:function(a) {
    a *= this.timeScale;
    for (var b = this._actions, c = this._nActiveActions, e = this.time += a, d = Math.sign(a), l = this._accuIndex ^= 1, m = 0; m !== c; ++m) {
      b[m]._update(e, a, d, l);
    }
    a = this._bindings;
    b = this._nActiveBindings;
    for (m = 0; m !== b; ++m) {
      a[m].apply(l);
    }
    return this;
  }, setTime:function(a) {
    for (var b = this.time = 0; b < this._actions.length; b++) {
      this._actions[b].time = 0;
    }
    return this.update(a);
  }, getRoot:function() {
    return this._root;
  }, uncacheClip:function(a) {
    var b = this._actions;
    a = a.uuid;
    var c = this._actionsByClip, e = c[a];
    if (void 0 !== e) {
      e = e.knownActions;
      for (var d = 0, l = e.length; d !== l; ++d) {
        var m = e[d];
        this._deactivateAction(m);
        var f = m._cacheIndex, k = b[b.length - 1];
        m._cacheIndex = null;
        m._byClipCacheIndex = null;
        k._cacheIndex = f;
        b[f] = k;
        b.pop();
        this._removeInactiveBindingsForAction(m);
      }
      delete c[a];
    }
  }, uncacheRoot:function(a) {
    a = a.uuid;
    var b = this._actionsByClip;
    for (e in b) {
      var c = b[e].actionByRoot[a];
      void 0 !== c && (this._deactivateAction(c), this._removeInactiveAction(c));
    }
    var e = this._bindingsByRootAndName[a];
    if (void 0 !== e) {
      for (var d in e) {
        a = e[d], a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
    }
  }, uncacheAction:function(a, b) {
    a = this.existingAction(a, b);
    null !== a && (this._deactivateAction(a), this._removeInactiveAction(a));
  }});
  Lf.prototype.clone = function() {
    return new Lf(void 0 === this.value.clone ? this.value : this.value.clone());
  };
  Tg.prototype = Object.assign(Object.create(Sb.prototype), {constructor:Tg, isInstancedInterleavedBuffer:!0, copy:function(a) {
    Sb.prototype.copy.call(this, a);
    this.meshPerAttribute = a.meshPerAttribute;
    return this;
  }});
  Object.assign(Ug.prototype, {set:function(a, b) {
    this.ray.set(a, b);
  }, setFromCamera:function(a, b) {
    b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize(), this.camera = b) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld), this.camera = b) : console.error("THREE.Raycaster: Unsupported camera type.");
  }, intersectObject:function(a, b, c) {
    c = c || [];
    Vg(a, this, c, b);
    c.sort(pi);
    return c;
  }, intersectObjects:function(a, b, c) {
    c = c || [];
    if (!1 === Array.isArray(a)) {
      return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), c;
    }
    for (var e = 0, d = a.length; e < d; e++) {
      Vg(a[e], this, c, b);
    }
    c.sort(pi);
    return c;
  }});
  Object.assign(qi.prototype, {set:function(a, b, c) {
    this.radius = a;
    this.phi = b;
    this.theta = c;
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.radius = a.radius;
    this.phi = a.phi;
    this.theta = a.theta;
    return this;
  }, makeSafe:function() {
    this.phi = Math.max(1E-6, Math.min(Math.PI - 1E-6, this.phi));
    return this;
  }, setFromVector3:function(a) {
    return this.setFromCartesianCoords(a.x, a.y, a.z);
  }, setFromCartesianCoords:function(a, b, c) {
    this.radius = Math.sqrt(a * a + b * b + c * c);
    0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a, c), this.phi = Math.acos(na.clamp(b / this.radius, -1, 1)));
    return this;
  }});
  Object.assign(ri.prototype, {set:function(a, b, c) {
    this.radius = a;
    this.theta = b;
    this.y = c;
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.radius = a.radius;
    this.theta = a.theta;
    this.y = a.y;
    return this;
  }, setFromVector3:function(a) {
    return this.setFromCartesianCoords(a.x, a.y, a.z);
  }, setFromCartesianCoords:function(a, b, c) {
    this.radius = Math.sqrt(a * a + c * c);
    this.theta = Math.atan2(a, c);
    this.y = b;
    return this;
  }});
  var Yi = new g;
  Object.assign(Wg.prototype, {set:function(a, b) {
    this.min.copy(a);
    this.max.copy(b);
    return this;
  }, setFromPoints:function(a) {
    this.makeEmpty();
    for (var b = 0, c = a.length; b < c; b++) {
      this.expandByPoint(a[b]);
    }
    return this;
  }, setFromCenterAndSize:function(a, b) {
    b = Yi.copy(b).multiplyScalar(.5);
    this.min.copy(a).sub(b);
    this.max.copy(a).add(b);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.min.copy(a.min);
    this.max.copy(a.max);
    return this;
  }, makeEmpty:function() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }, isEmpty:function() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }, getCenter:function(a) {
    void 0 === a && (console.warn("THREE.Box2: .getCenter() target is now required"), a = new g);
    return this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5);
  }, getSize:function(a) {
    void 0 === a && (console.warn("THREE.Box2: .getSize() target is now required"), a = new g);
    return this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min);
  }, expandByPoint:function(a) {
    this.min.min(a);
    this.max.max(a);
    return this;
  }, expandByVector:function(a) {
    this.min.sub(a);
    this.max.add(a);
    return this;
  }, expandByScalar:function(a) {
    this.min.addScalar(-a);
    this.max.addScalar(a);
    return this;
  }, containsPoint:function(a) {
    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0;
  }, containsBox:function(a) {
    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y;
  }, getParameter:function(a, b) {
    void 0 === b && (console.warn("THREE.Box2: .getParameter() target is now required"), b = new g);
    return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y));
  }, intersectsBox:function(a) {
    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0;
  }, clampPoint:function(a, b) {
    void 0 === b && (console.warn("THREE.Box2: .clampPoint() target is now required"), b = new g);
    return b.copy(a).clamp(this.min, this.max);
  }, distanceToPoint:function(a) {
    return Yi.copy(a).clamp(this.min, this.max).sub(a).length();
  }, intersect:function(a) {
    this.min.max(a.min);
    this.max.min(a.max);
    return this;
  }, union:function(a) {
    this.min.min(a.min);
    this.max.max(a.max);
    return this;
  }, translate:function(a) {
    this.min.add(a);
    this.max.add(a);
    return this;
  }, equals:function(a) {
    return a.min.equals(this.min) && a.max.equals(this.max);
  }});
  var Zi = new f, ig = new f;
  Object.assign(Xg.prototype, {set:function(a, b) {
    this.start.copy(a);
    this.end.copy(b);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.start.copy(a.start);
    this.end.copy(a.end);
    return this;
  }, getCenter:function(a) {
    void 0 === a && (console.warn("THREE.Line3: .getCenter() target is now required"), a = new f);
    return a.addVectors(this.start, this.end).multiplyScalar(.5);
  }, delta:function(a) {
    void 0 === a && (console.warn("THREE.Line3: .delta() target is now required"), a = new f);
    return a.subVectors(this.end, this.start);
  }, distanceSq:function() {
    return this.start.distanceToSquared(this.end);
  }, distance:function() {
    return this.start.distanceTo(this.end);
  }, at:function(a, b) {
    void 0 === b && (console.warn("THREE.Line3: .at() target is now required"), b = new f);
    return this.delta(b).multiplyScalar(a).add(this.start);
  }, closestPointToPointParameter:function(a, b) {
    Zi.subVectors(a, this.start);
    ig.subVectors(this.end, this.start);
    a = ig.dot(ig);
    a = ig.dot(Zi) / a;
    b && (a = na.clamp(a, 0, 1));
    return a;
  }, closestPointToPoint:function(a, b, c) {
    a = this.closestPointToPointParameter(a, b);
    void 0 === c && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), c = new f);
    return this.delta(c).multiplyScalar(a).add(this.start);
  }, applyMatrix4:function(a) {
    this.start.applyMatrix4(a);
    this.end.applyMatrix4(a);
    return this;
  }, equals:function(a) {
    return a.start.equals(this.start) && a.end.equals(this.end);
  }});
  Fe.prototype = Object.create(q.prototype);
  Fe.prototype.constructor = Fe;
  Fe.prototype.isImmediateRenderObject = !0;
  var $i = new f;
  Ed.prototype = Object.create(q.prototype);
  Ed.prototype.constructor = Ed;
  Ed.prototype.dispose = function() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  };
  Ed.prototype.update = function() {
    this.light.updateMatrixWorld();
    var a = this.light.distance ? this.light.distance : 1E3, b = a * Math.tan(this.light.angle);
    this.cone.scale.set(b, b, a);
    $i.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt($i);
    void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  };
  var wc = new f, jg = new n, yh = new n;
  Rc.prototype = Object.create(Da.prototype);
  Rc.prototype.constructor = Rc;
  Rc.prototype.isSkeletonHelper = !0;
  Rc.prototype.updateMatrixWorld = function(a) {
    var b = this.bones, c = this.geometry, e = c.getAttribute("position");
    yh.getInverse(this.root.matrixWorld);
    for (var d = 0, m = 0; d < b.length; d++) {
      var l = b[d];
      l.parent && l.parent.isBone && (jg.multiplyMatrices(yh, l.matrixWorld), wc.setFromMatrixPosition(jg), e.setXYZ(m, wc.x, wc.y, wc.z), jg.multiplyMatrices(yh, l.parent.matrixWorld), wc.setFromMatrixPosition(jg), e.setXYZ(m + 1, wc.x, wc.y, wc.z), m += 2);
    }
    c.getAttribute("position").needsUpdate = !0;
    q.prototype.updateMatrixWorld.call(this, a);
  };
  Fd.prototype = Object.create(V.prototype);
  Fd.prototype.constructor = Fd;
  Fd.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
  };
  Fd.prototype.update = function() {
    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  };
  var wk = new f, aj = new A, bj = new A;
  Gd.prototype = Object.create(q.prototype);
  Gd.prototype.constructor = Gd;
  Gd.prototype.dispose = function() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  };
  Gd.prototype.update = function() {
    var a = this.children[0];
    if (void 0 !== this.color) {
      this.material.color.set(this.color);
    } else {
      var b = a.geometry.getAttribute("color");
      aj.copy(this.light.color);
      bj.copy(this.light.groundColor);
      for (var c = 0, e = b.count; c < e; c++) {
        var d = c < e / 2 ? aj : bj;
        b.setXYZ(c, d.r, d.g, d.b);
      }
      b.needsUpdate = !0;
    }
    a.lookAt(wk.setFromMatrixPosition(this.light.matrixWorld).negate());
  };
  Mf.prototype = Object.assign(Object.create(Da.prototype), {constructor:Mf, copy:function(a) {
    Da.prototype.copy.call(this, a);
    this.geometry.copy(a.geometry);
    this.material.copy(a.material);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }});
  Nf.prototype = Object.create(Da.prototype);
  Nf.prototype.constructor = Nf;
  var cj = new f, kg = new f, dj = new f;
  Hd.prototype = Object.create(q.prototype);
  Hd.prototype.constructor = Hd;
  Hd.prototype.dispose = function() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  };
  Hd.prototype.update = function() {
    cj.setFromMatrixPosition(this.light.matrixWorld);
    kg.setFromMatrixPosition(this.light.target.matrixWorld);
    dj.subVectors(kg, cj);
    this.lightPlane.lookAt(kg);
    void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color));
    this.targetLine.lookAt(kg);
    this.targetLine.scale.z = dj.length();
  };
  var Of = new f, Fa = new ma;
  Ge.prototype = Object.create(Da.prototype);
  Ge.prototype.constructor = Ge;
  Ge.prototype.update = function() {
    var a = this.geometry, b = this.pointMap;
    Fa.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    Ha("c", b, a, Fa, 0, 0, -1);
    Ha("t", b, a, Fa, 0, 0, 1);
    Ha("n1", b, a, Fa, -1, -1, -1);
    Ha("n2", b, a, Fa, 1, -1, -1);
    Ha("n3", b, a, Fa, -1, 1, -1);
    Ha("n4", b, a, Fa, 1, 1, -1);
    Ha("f1", b, a, Fa, -1, -1, 1);
    Ha("f2", b, a, Fa, 1, -1, 1);
    Ha("f3", b, a, Fa, -1, 1, 1);
    Ha("f4", b, a, Fa, 1, 1, 1);
    Ha("u1", b, a, Fa, .7, 1.1, -1);
    Ha("u2", b, a, Fa, -.7, 1.1, -1);
    Ha("u3", b, a, Fa, 0, 2, -1);
    Ha("cf1", b, a, Fa, -1, 0, 1);
    Ha("cf2", b, a, Fa, 1, 0, 1);
    Ha("cf3", b, a, Fa, 0, -1, 1);
    Ha("cf4", b, a, Fa, 0, 1, 1);
    Ha("cn1", b, a, Fa, -1, 0, -1);
    Ha("cn2", b, a, Fa, 1, 0, -1);
    Ha("cn3", b, a, Fa, 0, -1, -1);
    Ha("cn4", b, a, Fa, 0, 1, -1);
    a.getAttribute("position").needsUpdate = !0;
  };
  var lg = new x;
  Xb.prototype = Object.create(Da.prototype);
  Xb.prototype.constructor = Xb;
  Xb.prototype.update = function(a) {
    void 0 !== a && console.warn("THREE.BoxHelper: .update() has no longer arguments.");
    void 0 !== this.object && lg.setFromObject(this.object);
    if (!lg.isEmpty()) {
      a = lg.min;
      var b = lg.max, c = this.geometry.attributes.position, e = c.array;
      e[0] = b.x;
      e[1] = b.y;
      e[2] = b.z;
      e[3] = a.x;
      e[4] = b.y;
      e[5] = b.z;
      e[6] = a.x;
      e[7] = a.y;
      e[8] = b.z;
      e[9] = b.x;
      e[10] = a.y;
      e[11] = b.z;
      e[12] = b.x;
      e[13] = b.y;
      e[14] = a.z;
      e[15] = a.x;
      e[16] = b.y;
      e[17] = a.z;
      e[18] = a.x;
      e[19] = a.y;
      e[20] = a.z;
      e[21] = b.x;
      e[22] = a.y;
      e[23] = a.z;
      c.needsUpdate = !0;
      this.geometry.computeBoundingSphere();
    }
  };
  Xb.prototype.setFromObject = function(a) {
    this.object = a;
    this.update();
    return this;
  };
  Xb.prototype.copy = function(a) {
    Da.prototype.copy.call(this, a);
    this.object = a.object;
    return this;
  };
  Xb.prototype.clone = function() {
    return (new this.constructor).copy(this);
  };
  He.prototype = Object.create(Da.prototype);
  He.prototype.constructor = He;
  He.prototype.updateMatrixWorld = function(a) {
    var b = this.box;
    b.isEmpty() || (b.getCenter(this.position), b.getSize(this.scale), this.scale.multiplyScalar(.5), q.prototype.updateMatrixWorld.call(this, a));
  };
  Ie.prototype = Object.create(cb.prototype);
  Ie.prototype.constructor = Ie;
  Ie.prototype.updateMatrixWorld = function(a) {
    var b = -this.plane.constant;
    1E-8 > Math.abs(b) && (b = 1E-8);
    this.scale.set(.5 * this.size, .5 * this.size, b);
    this.children[0].material.side = 0 > b ? 1 : 0;
    this.lookAt(this.plane.normal);
    q.prototype.updateMatrixWorld.call(this, a);
  };
  var ej = new f, Pf, Yg;
  Yb.prototype = Object.create(q.prototype);
  Yb.prototype.constructor = Yb;
  Yb.prototype.setDirection = function(a) {
    .99999 < a.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > a.y ? this.quaternion.set(1, 0, 0, 0) : (ej.set(a.z, 0, -a.x).normalize(), this.quaternion.setFromAxisAngle(ej, Math.acos(a.y)));
  };
  Yb.prototype.setLength = function(a, b, c) {
    void 0 === b && (b = .2 * a);
    void 0 === c && (c = .2 * b);
    this.line.scale.set(1, Math.max(1E-4, a - b), 1);
    this.line.updateMatrix();
    this.cone.scale.set(c, b, c);
    this.cone.position.y = a;
    this.cone.updateMatrix();
  };
  Yb.prototype.setColor = function(a) {
    this.line.material.color.set(a);
    this.cone.material.color.set(a);
  };
  Yb.prototype.copy = function(a) {
    q.prototype.copy.call(this, a, !1);
    this.line.copy(a.line);
    this.cone.copy(a.cone);
    return this;
  };
  Yb.prototype.clone = function() {
    return (new this.constructor).copy(this);
  };
  Je.prototype = Object.create(Da.prototype);
  Je.prototype.constructor = Je;
  var Mb = Math.pow(2, 8), fj = [.125, .215, .35, .446, .526, .582], gj = 5 + fj.length, Lb = {3E3:0, 3001:1, 3002:2, 3004:3, 3005:4, 3006:5, 3007:6}, zh = new Cd, Ah = function() {
    for (var a = [], b = [], c = [], e = 8, d = 0; d < gj; d++) {
      var m = Math.pow(2, e);
      b.push(m);
      var f = 1 / m;
      4 < d ? f = fj[d - 8 + 4 - 1] : 0 == d && (f = 0);
      c.push(f);
      f = 1 / (m - 1);
      m = -f / 2;
      f = 1 + f / 2;
      var k = [m, m, f, m, f, f, m, m, f, f, m, f];
      m = new Float32Array(108);
      f = new Float32Array(72);
      for (var h = new Float32Array(36), g = 0; 6 > g; g++) {
        var r = g % 3 * 2 / 3 - 1, n = 2 < g ? 0 : -1;
        m.set([r, n, 0, r + 2 / 3, n, 0, r + 2 / 3, n + 1, 0, r, n, 0, r + 2 / 3, n + 1, 0, r, n + 1, 0], 18 * g);
        f.set(k, 12 * g);
        h.set([g, g, g, g, g, g], 6 * g);
      }
      k = new M;
      k.setAttribute("position", new K(m, 3));
      k.setAttribute("uv", new K(f, 2));
      k.setAttribute("faceIndex", new K(h, 1));
      a.push(k);
      4 < e && e--;
    }
    return {_lodPlanes:a, _sizeLods:b, _sigmas:c};
  }(), Ue = Ah._lodPlanes, hj = Ah._sizeLods, mg = Ah._sigmas, Bh = null, $c = (1 + Math.sqrt(5)) / 2, Ud = 1 / $c, ij = [new f(1, 1, 1), new f(-1, 1, 1), new f(1, 1, -1), new f(-1, 1, -1), new f(0, $c, Ud), new f(0, $c, -Ud), new f(Ud, 0, $c), new f(-Ud, 0, $c), new f($c, Ud, 0), new f(-$c, Ud, 0)];
  Zg.prototype = {constructor:Zg, fromScene:function(a, b, c, e) {
    void 0 === b && (b = 0);
    void 0 === c && (c = .1);
    void 0 === e && (e = 100);
    Bh = this._renderer.getRenderTarget();
    var d = this._allocateTargets();
    this._sceneToCubeUV(a, c, e, d);
    0 < b && this._blur(d, 0, 0, b);
    this._applyPMREM(d);
    this._cleanup(d);
    return d;
  }, fromEquirectangular:function(a) {
    a.magFilter = 1003;
    a.minFilter = 1003;
    a.generateMipmaps = !1;
    return this.fromCubemap(a);
  }, fromCubemap:function(a) {
    Bh = this._renderer.getRenderTarget();
    var b = this._allocateTargets(a);
    this._textureToCubeUV(a, b);
    this._applyPMREM(b);
    this._cleanup(b);
    return b;
  }, compileCubemapShader:function() {
    null === this._cubemapShader && (this._cubemapShader = vi(), this._compileMaterial(this._cubemapShader));
  }, compileEquirectangularShader:function() {
    null === this._equirectShader && (this._equirectShader = ui(), this._compileMaterial(this._equirectShader));
  }, dispose:function() {
    this._blurMaterial.dispose();
    null !== this._cubemapShader && this._cubemapShader.dispose();
    null !== this._equirectShader && this._equirectShader.dispose();
    for (var a = 0; a < Ue.length; a++) {
      Ue[a].dispose();
    }
  }, _cleanup:function(a) {
    this._pingPongRenderTarget.dispose();
    this._renderer.setRenderTarget(Bh);
    a.scissorTest = !1;
    a.setSize(a.width, a.height);
  }, _allocateTargets:function(a) {
    var b = void 0 === a || 1009 !== a.type ? !1 : 3E3 === a.encoding || 3001 === a.encoding || 3007 === a.encoding;
    b = {magFilter:1003, minFilter:1003, generateMipmaps:!1, type:1009, format:1023, encoding:b ? a.encoding : 3002, depthBuffer:!1, stencilBuffer:!1};
    var c = ti(b);
    c.depthBuffer = a ? !1 : !0;
    this._pingPongRenderTarget = ti(b);
    return c;
  }, _compileMaterial:function(a) {
    var b = new y;
    b.add(new V(Ue[0], a));
    this._renderer.compile(b, zh);
  }, _sceneToCubeUV:function(a, b, c, e) {
    b = new ka(90, 1, b, c);
    c = [1, 1, 1, 1, -1, 1];
    var d = [1, 1, -1, -1, -1, 1], m = this._renderer, l = m.outputEncoding, f = m.toneMapping, k = m.toneMappingExposure, h = m.getClearColor(), g = m.getClearAlpha();
    m.toneMapping = 1;
    m.toneMappingExposure = 1;
    m.outputEncoding = 3E3;
    a.scale.z *= -1;
    var r = a.background;
    if (r && r.isColor) {
      r.convertSRGBToLinear();
      var n = Math.min(Math.max(Math.ceil(Math.log2(Math.max(r.r, r.g, r.b))), -128), 127);
      r = r.multiplyScalar(Math.pow(2, -n));
      m.setClearColor(r, (n + 128) / 255);
      a.background = null;
    }
    for (r = 0; 6 > r; r++) {
      n = r % 3, 0 == n ? (b.up.set(0, c[r], 0), b.lookAt(d[r], 0, 0)) : 1 == n ? (b.up.set(0, 0, c[r]), b.lookAt(0, d[r], 0)) : (b.up.set(0, c[r], 0), b.lookAt(0, 0, d[r])), bh(e, n * Mb, 2 < r ? Mb : 0, Mb, Mb), m.setRenderTarget(e), m.render(a, b);
    }
    m.toneMapping = f;
    m.toneMappingExposure = k;
    m.outputEncoding = l;
    m.setClearColor(h, g);
    a.scale.z *= -1;
  }, _textureToCubeUV:function(a, b) {
    var c = new y, e = this._renderer;
    a.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = vi()) : null == this._equirectShader && (this._equirectShader = ui());
    var d = a.isCubeTexture ? this._cubemapShader : this._equirectShader;
    c.add(new V(Ue[0], d));
    d = d.uniforms;
    d.envMap.value = a;
    a.isCubeTexture || d.texelSize.value.set(1 / a.image.width, 1 / a.image.height);
    d.inputEncoding.value = Lb[a.encoding];
    d.outputEncoding.value = Lb[b.texture.encoding];
    bh(b, 0, 0, 3 * Mb, 2 * Mb);
    e.setRenderTarget(b);
    e.render(c, zh);
  }, _applyPMREM:function(a) {
    var b = this._renderer, c = b.autoClear;
    b.autoClear = !1;
    for (var e = 1; e < gj; e++) {
      this._blur(a, e - 1, e, Math.sqrt(mg[e] * mg[e] - mg[e - 1] * mg[e - 1]), ij[(e - 1) % ij.length]);
    }
    b.autoClear = c;
  }, _blur:function(a, b, c, e, d) {
    var m = this._pingPongRenderTarget;
    this._halfBlur(a, m, b, c, e, "latitudinal", d);
    this._halfBlur(m, a, c, c, e, "longitudinal", d);
  }, _halfBlur:function(a, b, c, e, d, m, f) {
    var l = this._renderer, k = this._blurMaterial;
    "latitudinal" !== m && "longitudinal" !== m && console.error("blur direction must be either latitudinal or longitudinal!");
    var h = new y;
    h.add(new V(Ue[e], k));
    k = k.uniforms;
    var g = hj[c] - 1;
    g = isFinite(d) ? Math.PI / (2 * g) : 2 * Math.PI / 39;
    var r = d / g, n = isFinite(d) ? 1 + Math.floor(3 * r) : 20;
    20 < n && console.warn("sigmaRadians, " + d + ", is too large and will clip, as it requested " + n + " samples when the maximum is set to 20");
    d = [];
    for (var q = 0, p = 0; 20 > p; ++p) {
      var u = p / r;
      u = Math.exp(-u * u / 2);
      d.push(u);
      0 == p ? q += u : p < n && (q += 2 * u);
    }
    for (p = 0; p < d.length; p++) {
      d[p] /= q;
    }
    k.envMap.value = a.texture;
    k.samples.value = n;
    k.weights.value = d;
    k.latitudinal.value = "latitudinal" === m;
    f && (k.poleAxis.value = f);
    k.dTheta.value = g;
    k.mipInt.value = 8 - c;
    k.inputEncoding.value = Lb[a.texture.encoding];
    k.outputEncoding.value = Lb[a.texture.encoding];
    a = hj[e];
    u = 3 * Math.max(0, Mb - 2 * a);
    bh(b, u, (0 === e ? 0 : 2 * Mb) + 2 * a * (4 < e ? e - 8 + 4 : 0), 3 * a, 2 * a);
    l.setRenderTarget(b);
    l.render(h, zh);
  }};
  ha.create = function(a, b) {
    console.log("THREE.Curve.create() has been deprecated");
    a.prototype = Object.create(ha.prototype);
    a.prototype.constructor = a;
    a.prototype.getPoint = b;
    return a;
  };
  Object.assign(Wb.prototype, {createPointsGeometry:function(a) {
    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    a = this.getPoints(a);
    return this.createGeometry(a);
  }, createSpacedPointsGeometry:function(a) {
    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    a = this.getSpacedPoints(a);
    return this.createGeometry(a);
  }, createGeometry:function(a) {
    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    for (var b = new X, c = 0, e = a.length; c < e; c++) {
      var d = a[c];
      b.vertices.push(new f(d.x, d.y, d.z || 0));
    }
    return b;
  }});
  Object.assign(wb.prototype, {fromPoints:function(a) {
    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
    return this.setFromPoints(a);
  }});
  wi.prototype = Object.create(Ta.prototype);
  xi.prototype = Object.create(Ta.prototype);
  ch.prototype = Object.create(Ta.prototype);
  Object.assign(ch.prototype, {initFromArray:function() {
    console.error("THREE.Spline: .initFromArray() has been removed.");
  }, getControlPointsArray:function() {
    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
  }, reparametrizeByArcLength:function() {
    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
  }});
  Mf.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  };
  Rc.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
  };
  Object.assign(pa.prototype, {extractUrlBase:function(a) {
    console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
    return wh.extractUrlBase(a);
  }});
  pa.Handlers = {add:function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  }, get:function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }};
  Object.assign(Jf.prototype, {setTexturePath:function(a) {
    console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
    return this.setResourcePath(a);
  }});
  Object.assign(Wg.prototype, {center:function(a) {
    console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
    return this.getCenter(a);
  }, empty:function() {
    console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  }, isIntersectionBox:function(a) {
    console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(a);
  }, size:function(a) {
    console.warn("THREE.Box2: .size() has been renamed to .getSize().");
    return this.getSize(a);
  }});
  Object.assign(x.prototype, {center:function(a) {
    console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
    return this.getCenter(a);
  }, empty:function() {
    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  }, isIntersectionBox:function(a) {
    console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(a);
  }, isIntersectionSphere:function(a) {
    console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(a);
  }, size:function(a) {
    console.warn("THREE.Box3: .size() has been renamed to .getSize().");
    return this.getSize(a);
  }});
  Object.assign(r.prototype, {empty:function() {
    console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  }});
  Ga.prototype.setFromMatrix = function(a) {
    console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
    return this.setFromProjectionMatrix(a);
  };
  Xg.prototype.center = function(a) {
    console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
    return this.getCenter(a);
  };
  Object.assign(na, {random16:function() {
    console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
    return Math.random();
  }, nearestPowerOfTwo:function(a) {
    console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
    return na.floorPowerOfTwo(a);
  }, nextPowerOfTwo:function(a) {
    console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
    return na.ceilPowerOfTwo(a);
  }});
  Object.assign(h.prototype, {flattenToArrayOffset:function(a, b) {
    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(a, b);
  }, multiplyVector3:function(a) {
    console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
    return a.applyMatrix3(this);
  }, multiplyVector3Array:function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  }, applyToBufferAttribute:function(a) {
    console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
    return a.applyMatrix3(this);
  }, applyToVector3Array:function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }});
  Object.assign(n.prototype, {extractPosition:function(a) {
    console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
    return this.copyPosition(a);
  }, flattenToArrayOffset:function(a, b) {
    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(a, b);
  }, getPosition:function() {
    console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
    return (new f).setFromMatrixColumn(this, 3);
  }, setRotationFromQuaternion:function(a) {
    console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
    return this.makeRotationFromQuaternion(a);
  }, multiplyToArray:function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  }, multiplyVector3:function(a) {
    console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return a.applyMatrix4(this);
  }, multiplyVector4:function(a) {
    console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return a.applyMatrix4(this);
  }, multiplyVector3Array:function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  }, rotateAxis:function(a) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
    a.transformDirection(this);
  }, crossVector:function(a) {
    console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return a.applyMatrix4(this);
  }, translate:function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  }, rotateX:function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  }, rotateY:function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  }, rotateZ:function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  }, rotateByAxis:function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  }, applyToBufferAttribute:function(a) {
    console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
    return a.applyMatrix4(this);
  }, applyToVector3Array:function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  }, makeFrustum:function(a, b, c, e, d, m) {
    console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
    return this.makePerspective(a, b, e, c, d, m);
  }});
  v.prototype.isIntersectionLine = function(a) {
    console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
    return this.intersectsLine(a);
  };
  t.prototype.multiplyVector3 = function(a) {
    console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
    return a.applyQuaternion(this);
  };
  Object.assign(u.prototype, {isIntersectionBox:function(a) {
    console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(a);
  }, isIntersectionPlane:function(a) {
    console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
    return this.intersectsPlane(a);
  }, isIntersectionSphere:function(a) {
    console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(a);
  }});
  Object.assign(C.prototype, {area:function() {
    console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
    return this.getArea();
  }, barycoordFromPoint:function(a, b) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return this.getBarycoord(a, b);
  }, midpoint:function(a) {
    console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
    return this.getMidpoint(a);
  }, normal:function(a) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return this.getNormal(a);
  }, plane:function(a) {
    console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
    return this.getPlane(a);
  }});
  Object.assign(C, {barycoordFromPoint:function(a, b, c, e, d) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return C.getBarycoord(a, b, c, e, d);
  }, normal:function(a, b, c, e) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return C.getNormal(a, b, c, e);
  }});
  Object.assign(qc.prototype, {extractAllPoints:function(a) {
    console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
    return this.extractPoints(a);
  }, extrude:function(a) {
    console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
    return new Fc(this, a);
  }, makeGeometry:function(a) {
    console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
    return new Hc(this, a);
  }});
  Object.assign(g.prototype, {fromAttribute:function(a, b, c) {
    console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(a, b, c);
  }, distanceToManhattan:function(a) {
    console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
    return this.manhattanDistanceTo(a);
  }, lengthManhattan:function() {
    console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  }});
  Object.assign(f.prototype, {setEulerFromRotationMatrix:function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  }, setEulerFromQuaternion:function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  }, getPositionFromMatrix:function(a) {
    console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
    return this.setFromMatrixPosition(a);
  }, getScaleFromMatrix:function(a) {
    console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
    return this.setFromMatrixScale(a);
  }, getColumnFromMatrix:function(a, b) {
    console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
    return this.setFromMatrixColumn(b, a);
  }, applyProjection:function(a) {
    console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
    return this.applyMatrix4(a);
  }, fromAttribute:function(a, b, c) {
    console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(a, b, c);
  }, distanceToManhattan:function(a) {
    console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
    return this.manhattanDistanceTo(a);
  }, lengthManhattan:function() {
    console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  }});
  Object.assign(k.prototype, {fromAttribute:function(a, b, c) {
    console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(a, b, c);
  }, lengthManhattan:function() {
    console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  }});
  Object.assign(X.prototype, {computeTangents:function() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  }, computeLineDistances:function() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  }, applyMatrix:function(a) {
    console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().");
    return this.applyMatrix4(a);
  }});
  Object.assign(q.prototype, {getChildByName:function(a) {
    console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
    return this.getObjectByName(a);
  }, renderDepth:function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  }, translate:function(a, b) {
    console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
    return this.translateOnAxis(b, a);
  }, getWorldRotation:function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  }, applyMatrix:function(a) {
    console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
    return this.applyMatrix4(a);
  }});
  Object.defineProperties(q.prototype, {eulerOrder:{get:function() {
    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
    return this.rotation.order;
  }, set:function(a) {
    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
    this.rotation.order = a;
  }}, useQuaternion:{get:function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  }, set:function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  }}});
  Object.assign(V.prototype, {setDrawMode:function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  }});
  Object.defineProperties(V.prototype, {drawMode:{get:function() {
    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
    return 0;
  }, set:function() {
    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  }}});
  Object.defineProperties(fe.prototype, {objects:{get:function() {
    console.warn("THREE.LOD: .objects has been renamed to .levels.");
    return this.levels;
  }}});
  Object.defineProperty(gf.prototype, "useVertexTexture", {get:function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }, set:function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }});
  ff.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  };
  Object.defineProperty(ha.prototype, "__arcLengthDivisions", {get:function() {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    return this.arcLengthDivisions;
  }, set:function(a) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    this.arcLengthDivisions = a;
  }});
  ka.prototype.setLens = function(a, b) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    void 0 !== b && (this.filmGauge = b);
    this.setFocalLength(a);
  };
  Object.defineProperties(wa.prototype, {onlyShadow:{set:function() {
    console.warn("THREE.Light: .onlyShadow has been removed.");
  }}, shadowCameraFov:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
    this.shadow.camera.fov = a;
  }}, shadowCameraLeft:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
    this.shadow.camera.left = a;
  }}, shadowCameraRight:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
    this.shadow.camera.right = a;
  }}, shadowCameraTop:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
    this.shadow.camera.top = a;
  }}, shadowCameraBottom:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
    this.shadow.camera.bottom = a;
  }}, shadowCameraNear:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
    this.shadow.camera.near = a;
  }}, shadowCameraFar:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
    this.shadow.camera.far = a;
  }}, shadowCameraVisible:{set:function() {
    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
  }}, shadowBias:{set:function(a) {
    console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
    this.shadow.bias = a;
  }}, shadowDarkness:{set:function() {
    console.warn("THREE.Light: .shadowDarkness has been removed.");
  }}, shadowMapWidth:{set:function(a) {
    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
    this.shadow.mapSize.width = a;
  }}, shadowMapHeight:{set:function(a) {
    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
    this.shadow.mapSize.height = a;
  }}});
  Object.defineProperties(K.prototype, {length:{get:function() {
    console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
    return this.array.length;
  }}, dynamic:{get:function() {
    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
    return 35048 === this.usage;
  }, set:function() {
    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
    this.setUsage(35048);
  }}});
  Object.assign(K.prototype, {setDynamic:function(a) {
    console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
    this.setUsage(!0 === a ? 35048 : 35044);
    return this;
  }, copyIndicesArray:function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  }, setArray:function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }});
  Object.assign(M.prototype, {addIndex:function(a) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
    this.setIndex(a);
  }, addAttribute:function(a, b, c) {
    console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
    return b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute ? "index" === a ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b), this) : this.setAttribute(a, b) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(a, new K(b, c)));
  }, addDrawCall:function(a, b, c) {
    void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
    this.addGroup(a, b);
  }, clearDrawCalls:function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
    this.clearGroups();
  }, computeTangents:function() {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  }, computeOffsets:function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  }, removeAttribute:function(a) {
    console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
    return this.deleteAttribute(a);
  }, applyMatrix:function(a) {
    console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
    return this.applyMatrix4(a);
  }});
  Object.defineProperties(M.prototype, {drawcalls:{get:function() {
    console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
    return this.groups;
  }}, offsets:{get:function() {
    console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
    return this.groups;
  }}});
  Object.defineProperties(Ug.prototype, {linePrecision:{get:function() {
    console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
    return this.params.Line.threshold;
  }, set:function(a) {
    console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
    this.params.Line.threshold = a;
  }}});
  Object.defineProperties(Sb.prototype, {dynamic:{get:function() {
    console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
    return 35048 === this.usage;
  }, set:function(a) {
    console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
    this.setUsage(a);
  }}});
  Object.assign(Sb.prototype, {setDynamic:function(a) {
    console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
    this.setUsage(!0 === a ? 35048 : 35044);
    return this;
  }, setArray:function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }});
  Object.assign(Gb.prototype, {getArrays:function() {
    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
  }, addShapeList:function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
  }, addShape:function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
  }});
  Object.defineProperties(Lf.prototype, {dynamic:{set:function() {
    console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
  }}, onUpdate:{value:function() {
    console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
    return this;
  }}});
  Object.defineProperties(H.prototype, {wrapAround:{get:function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  }, set:function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  }}, overdraw:{get:function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  }, set:function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  }}, wrapRGB:{get:function() {
    console.warn("THREE.Material: .wrapRGB has been removed.");
    return new A;
  }}, shading:{get:function() {
    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
  }, set:function(a) {
    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    this.flatShading = 1 === a;
  }}, stencilMask:{get:function() {
    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
    return this.stencilFuncMask;
  }, set:function(a) {
    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
    this.stencilFuncMask = a;
  }}});
  Object.defineProperties(pc.prototype, {metal:{get:function() {
    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
    return !1;
  }, set:function() {
    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
  }}});
  Object.defineProperties(T.prototype, {derivatives:{get:function() {
    console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
    return this.extensions.derivatives;
  }, set:function(a) {
    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
    this.extensions.derivatives = a;
  }}});
  Object.assign(ug.prototype, {clearTarget:function(a, b, c, e) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
    this.setRenderTarget(a);
    this.clear(b, c, e);
  }, animate:function(a) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
    this.setAnimationLoop(a);
  }, getCurrentRenderTarget:function() {
    console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
    return this.getRenderTarget();
  }, getMaxAnisotropy:function() {
    console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
    return this.capabilities.getMaxAnisotropy();
  }, getPrecision:function() {
    console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
    return this.capabilities.precision;
  }, resetGLState:function() {
    console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
    return this.state.reset();
  }, supportsFloatTextures:function() {
    console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
    return this.extensions.get("OES_texture_float");
  }, supportsHalfFloatTextures:function() {
    console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
    return this.extensions.get("OES_texture_half_float");
  }, supportsStandardDerivatives:function() {
    console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
    return this.extensions.get("OES_standard_derivatives");
  }, supportsCompressedTextureS3TC:function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
    return this.extensions.get("WEBGL_compressed_texture_s3tc");
  }, supportsCompressedTexturePVRTC:function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
    return this.extensions.get("WEBGL_compressed_texture_pvrtc");
  }, supportsBlendMinMax:function() {
    console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
    return this.extensions.get("EXT_blend_minmax");
  }, supportsVertexTextures:function() {
    console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
    return this.capabilities.vertexTextures;
  }, supportsInstancedArrays:function() {
    console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
    return this.extensions.get("ANGLE_instanced_arrays");
  }, enableScissorTest:function(a) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
    this.setScissorTest(a);
  }, initMaterial:function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  }, addPrePlugin:function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  }, addPostPlugin:function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  }, updateShadowMap:function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  }, setFaceCulling:function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  }, allocTextureUnit:function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  }, setTexture:function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  }, setTexture2D:function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  }, setTextureCube:function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  }, getActiveMipMapLevel:function() {
    console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
    return this.getActiveMipmapLevel();
  }});
  Object.defineProperties(ug.prototype, {shadowMapEnabled:{get:function() {
    return this.shadowMap.enabled;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
    this.shadowMap.enabled = a;
  }}, shadowMapType:{get:function() {
    return this.shadowMap.type;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
    this.shadowMap.type = a;
  }}, shadowMapCullFace:{get:function() {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
  }, set:function() {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
  }}, context:{get:function() {
    console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
    return this.getContext();
  }}, vr:{get:function() {
    console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
    return this.xr;
  }}, gammaInput:{get:function() {
    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    return !1;
  }, set:function() {
    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
  }}, gammaOutput:{get:function() {
    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
    return !1;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
    this.outputEncoding = !0 === a ? 3001 : 3E3;
  }}});
  Object.defineProperties(Xh.prototype, {cullFace:{get:function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  }, set:function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  }}, renderReverseSided:{get:function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
  }, set:function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
  }}, renderSingleSided:{get:function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  }, set:function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  }}});
  Object.defineProperties(c.prototype, {wrapS:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
    return this.texture.wrapS;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
    this.texture.wrapS = a;
  }}, wrapT:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
    return this.texture.wrapT;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
    this.texture.wrapT = a;
  }}, magFilter:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
    return this.texture.magFilter;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
    this.texture.magFilter = a;
  }}, minFilter:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
    return this.texture.minFilter;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
    this.texture.minFilter = a;
  }}, anisotropy:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
    return this.texture.anisotropy;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
    this.texture.anisotropy = a;
  }}, offset:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
    return this.texture.offset;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
    this.texture.offset = a;
  }}, repeat:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
    return this.texture.repeat;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
    this.texture.repeat = a;
  }}, format:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
    return this.texture.format;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
    this.texture.format = a;
  }}, type:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
    return this.texture.type;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
    this.texture.type = a;
  }}, generateMipmaps:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
    return this.texture.generateMipmaps;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
    this.texture.generateMipmaps = a;
  }}});
  Object.defineProperties(Dd.prototype, {load:{value:function(a) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    var b = this;
    (new Kf).load(a, function(a) {
      b.setBuffer(a);
    });
    return this;
  }}, startTime:{set:function() {
    console.warn("THREE.Audio: .startTime is now .play( delay ).");
  }}});
  Qg.prototype.getData = function() {
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
    return this.getFrequencyData();
  };
  ua.prototype.updateCubeMap = function(a, b) {
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
    return this.update(a, b);
  };
  rc.crossOrigin = void 0;
  rc.loadTexture = function(a, b, c, e) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    var d = new vf;
    d.setCrossOrigin(this.crossOrigin);
    a = d.load(a, c, void 0, e);
    b && (a.mapping = b);
    return a;
  };
  rc.loadTextureCube = function(a, b, c, e) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    var d = new uf;
    d.setCrossOrigin(this.crossOrigin);
    a = d.load(a, c, void 0, e);
    b && (a.mapping = b);
    return a;
  };
  rc.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  };
  rc.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  };
  "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail:{revision:"116"}}));
  a.ACESFilmicToneMapping = 5;
  a.AddEquation = 100;
  a.AddOperation = 2;
  a.AdditiveAnimationBlendMode = 2501;
  a.AdditiveBlending = 2;
  a.AlphaFormat = 1021;
  a.AlwaysDepth = 1;
  a.AlwaysStencilFunc = 519;
  a.AmbientLight = Cf;
  a.AmbientLightProbe = Lg;
  a.AnimationClip = kb;
  a.AnimationLoader = Cg;
  a.AnimationMixer = Sg;
  a.AnimationObjectGroup = ni;
  a.AnimationUtils = Ba;
  a.ArcCurve = Bd;
  a.ArrayCamera = af;
  a.ArrowHelper = Yb;
  a.Audio = Dd;
  a.AudioAnalyser = Qg;
  a.AudioContext = Og;
  a.AudioListener = Ng;
  a.AudioLoader = Kf;
  a.AxesHelper = Je;
  a.AxisHelper = function(a) {
    console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
    return new Je(a);
  };
  a.BackSide = 1;
  a.BasicDepthPacking = 3200;
  a.BasicShadowMap = 0;
  a.BinaryTextureLoader = function(a) {
    console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
    return new tf(a);
  };
  a.Bone = vg;
  a.BooleanKeyframeTrack = pf;
  a.BoundingBoxHelper = function(a, b) {
    console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
    return new Xb(a, b);
  };
  a.Box2 = Wg;
  a.Box3 = x;
  a.Box3Helper = He;
  a.BoxBufferGeometry = Wd;
  a.BoxGeometry = qh;
  a.BoxHelper = Xb;
  a.BufferAttribute = K;
  a.BufferGeometry = M;
  a.BufferGeometryLoader = If;
  a.ByteType = 1010;
  a.Cache = Vc;
  a.Camera = ma;
  a.CameraHelper = Ge;
  a.CanvasRenderer = function() {
    console.error("THREE.CanvasRenderer has been removed");
  };
  a.CanvasTexture = ge;
  a.CatmullRomCurve3 = Ta;
  a.CineonToneMapping = 4;
  a.CircleBufferGeometry = xd;
  a.CircleGeometry = Ae;
  a.ClampToEdgeWrapping = 1001;
  a.Clock = Mg;
  a.ClosedSplineCurve3 = wi;
  a.Color = A;
  a.ColorKeyframeTrack = qf;
  a.CompressedTexture = kd;
  a.CompressedTextureLoader = Dg;
  a.ConeBufferGeometry = ze;
  a.ConeGeometry = ye;
  a.CubeCamera = ua;
  a.CubeGeometry = qh;
  a.CubeReflectionMapping = 301;
  a.CubeRefractionMapping = 302;
  a.CubeTexture = Sa;
  a.CubeTextureLoader = uf;
  a.CubeUVReflectionMapping = 306;
  a.CubeUVRefractionMapping = 307;
  a.CubicBezierCurve = sb;
  a.CubicBezierCurve3 = Ib;
  a.CubicInterpolant = nf;
  a.CullFaceBack = 1;
  a.CullFaceFront = 2;
  a.CullFaceFrontBack = 3;
  a.CullFaceNone = 0;
  a.Curve = ha;
  a.CurvePath = Wb;
  a.CustomBlending = 5;
  a.CylinderBufferGeometry = Ub;
  a.CylinderGeometry = Jc;
  a.Cylindrical = ri;
  a.DataTexture = Ia;
  a.DataTexture2DArray = za;
  a.DataTexture3D = hb;
  a.DataTextureLoader = tf;
  a.DecrementStencilOp = 7683;
  a.DecrementWrapStencilOp = 34056;
  a.DefaultLoadingManager = ji;
  a.DepthFormat = 1026;
  a.DepthStencilFormat = 1027;
  a.DepthTexture = he;
  a.DirectionalLight = Bf;
  a.DirectionalLightHelper = Hd;
  a.DirectionalLightShadow = Af;
  a.DiscreteInterpolant = of;
  a.DodecahedronBufferGeometry = pd;
  a.DodecahedronGeometry = ne;
  a.DoubleSide = 2;
  a.DstAlphaFactor = 206;
  a.DstColorFactor = 208;
  a.DynamicBufferAttribute = function(a, b) {
    console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.");
    return (new K(a, b)).setUsage(35048);
  };
  a.DynamicCopyUsage = 35050;
  a.DynamicDrawUsage = 35048;
  a.DynamicReadUsage = 35049;
  a.EdgesGeometry = wd;
  a.EdgesHelper = function(a, b) {
    console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
    return new Da(new wd(a.geometry), new ya({color:void 0 !== b ? b : 16777215}));
  };
  a.EllipseCurve = eb;
  a.EqualDepth = 4;
  a.EqualStencilFunc = 514;
  a.EquirectangularReflectionMapping = 303;
  a.EquirectangularRefractionMapping = 304;
  a.Euler = b;
  a.EventDispatcher = d;
  a.ExtrudeBufferGeometry = Gb;
  a.ExtrudeGeometry = Fc;
  a.Face3 = E;
  a.Face4 = function(a, b, c, e, d, m, f) {
    console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
    return new E(a, b, c, d, m, f);
  };
  a.FaceColors = 1;
  a.FileLoader = lb;
  a.FlatShading = 1;
  a.Float32Attribute = function(a, b) {
    console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
    return new R(a, b);
  };
  a.Float32BufferAttribute = R;
  a.Float64Attribute = function(a, b) {
    console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
    return new W(a, b);
  };
  a.Float64BufferAttribute = W;
  a.FloatType = 1015;
  a.Fog = df;
  a.FogExp2 = cf;
  a.Font = Ig;
  a.FontLoader = Jg;
  a.FrontFaceDirectionCCW = 1;
  a.FrontFaceDirectionCW = 0;
  a.FrontSide = 0;
  a.Frustum = Ga;
  a.GammaEncoding = 3007;
  a.Geometry = X;
  a.GeometryUtils = {merge:function(a, b, c) {
    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
    if (b.isMesh) {
      b.matrixAutoUpdate && b.updateMatrix();
      var e = b.matrix;
      b = b.geometry;
    }
    a.merge(b, e, c);
  }, center:function(a) {
    console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
    return a.center();
  }};
  a.GreaterDepth = 6;
  a.GreaterEqualDepth = 5;
  a.GreaterEqualStencilFunc = 518;
  a.GreaterStencilFunc = 516;
  a.GridHelper = Mf;
  a.Group = gd;
  a.HalfFloatType = 1016;
  a.HemisphereLight = wf;
  a.HemisphereLightHelper = Gd;
  a.HemisphereLightProbe = Kg;
  a.IcosahedronBufferGeometry = od;
  a.IcosahedronGeometry = me;
  a.ImageBitmapLoader = Gg;
  a.ImageLoader = Ad;
  a.ImageUtils = rc;
  a.ImmediateRenderObject = Fe;
  a.IncrementStencilOp = 7682;
  a.IncrementWrapStencilOp = 34055;
  a.InstancedBufferAttribute = Hf;
  a.InstancedBufferGeometry = Gf;
  a.InstancedInterleavedBuffer = Tg;
  a.InstancedMesh = hf;
  a.Int16Attribute = function(a, b) {
    console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
    return new N(a, b);
  };
  a.Int16BufferAttribute = N;
  a.Int32Attribute = function(a, b) {
    console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
    return new Q(a, b);
  };
  a.Int32BufferAttribute = Q;
  a.Int8Attribute = function(a, b) {
    console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
    return new P(a, b);
  };
  a.Int8BufferAttribute = P;
  a.IntType = 1013;
  a.InterleavedBuffer = Sb;
  a.InterleavedBufferAttribute = ce;
  a.Interpolant = db;
  a.InterpolateDiscrete = 2300;
  a.InterpolateLinear = 2301;
  a.InterpolateSmooth = 2302;
  a.InvertStencilOp = 5386;
  a.JSONLoader = function() {
    console.error("THREE.JSONLoader has been removed.");
  };
  a.KeepStencilOp = 7680;
  a.KeyframeTrack = Qa;
  a.LOD = fe;
  a.LatheBufferGeometry = vd;
  a.LatheGeometry = xe;
  a.Layers = m;
  a.LensFlare = function() {
    console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
  };
  a.LessDepth = 2;
  a.LessEqualDepth = 3;
  a.LessEqualStencilFunc = 515;
  a.LessStencilFunc = 513;
  a.Light = wa;
  a.LightProbe = mb;
  a.LightShadow = Kb;
  a.Line = cb;
  a.Line3 = Xg;
  a.LineBasicMaterial = ya;
  a.LineCurve = Za;
  a.LineCurve3 = tb;
  a.LineDashedMaterial = Qc;
  a.LineLoop = jf;
  a.LinePieces = 1;
  a.LineSegments = Da;
  a.LineStrip = 0;
  a.LinearEncoding = 3E3;
  a.LinearFilter = 1006;
  a.LinearInterpolant = Be;
  a.LinearMipMapLinearFilter = 1008;
  a.LinearMipMapNearestFilter = 1007;
  a.LinearMipmapLinearFilter = 1008;
  a.LinearMipmapNearestFilter = 1007;
  a.LinearToneMapping = 1;
  a.Loader = pa;
  a.LoaderUtils = wh;
  a.LoadingManager = Bg;
  a.LogLuvEncoding = 3003;
  a.LoopOnce = 2200;
  a.LoopPingPong = 2202;
  a.LoopRepeat = 2201;
  a.LuminanceAlphaFormat = 1025;
  a.LuminanceFormat = 1024;
  a.MOUSE = {LEFT:0, MIDDLE:1, RIGHT:2, ROTATE:0, DOLLY:1, PAN:2};
  a.Material = H;
  a.MaterialLoader = Ff;
  a.Math = na;
  a.MathUtils = na;
  a.Matrix3 = h;
  a.Matrix4 = n;
  a.MaxEquation = 104;
  a.Mesh = V;
  a.MeshBasicMaterial = L;
  a.MeshDepthMaterial = lc;
  a.MeshDistanceMaterial = mc;
  a.MeshFaceMaterial = function(a) {
    console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
    return a;
  };
  a.MeshLambertMaterial = Oc;
  a.MeshMatcapMaterial = Pc;
  a.MeshNormalMaterial = Nc;
  a.MeshPhongMaterial = pc;
  a.MeshPhysicalMaterial = Lc;
  a.MeshStandardMaterial = Hb;
  a.MeshToonMaterial = Mc;
  a.MinEquation = 103;
  a.MirroredRepeatWrapping = 1002;
  a.MixOperation = 1;
  a.MultiMaterial = function(a) {
    void 0 === a && (a = []);
    console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
    a.isMultiMaterial = !0;
    a.materials = a;
    a.clone = function() {
      return a.slice();
    };
    return a;
  };
  a.MultiplyBlending = 4;
  a.MultiplyOperation = 0;
  a.NearestFilter = 1003;
  a.NearestMipMapLinearFilter = 1005;
  a.NearestMipMapNearestFilter = 1004;
  a.NearestMipmapLinearFilter = 1005;
  a.NearestMipmapNearestFilter = 1004;
  a.NeverDepth = 0;
  a.NeverStencilFunc = 512;
  a.NoBlending = 0;
  a.NoColors = 0;
  a.NoToneMapping = 0;
  a.NormalAnimationBlendMode = 2500;
  a.NormalBlending = 1;
  a.NotEqualDepth = 7;
  a.NotEqualStencilFunc = 517;
  a.NumberKeyframeTrack = yd;
  a.Object3D = q;
  a.ObjectLoader = Jf;
  a.ObjectSpaceNormalMap = 1;
  a.OctahedronBufferGeometry = Dc;
  a.OctahedronGeometry = le;
  a.OneFactor = 201;
  a.OneMinusDstAlphaFactor = 207;
  a.OneMinusDstColorFactor = 209;
  a.OneMinusSrcAlphaFactor = 205;
  a.OneMinusSrcColorFactor = 203;
  a.OrthographicCamera = Cd;
  a.PCFShadowMap = 1;
  a.PCFSoftShadowMap = 2;
  a.PMREMGenerator = Zg;
  a.ParametricBufferGeometry = md;
  a.ParametricGeometry = ie;
  a.Particle = function(a) {
    console.warn("THREE.Particle has been renamed to THREE.Sprite.");
    return new de(a);
  };
  a.ParticleBasicMaterial = function(a) {
    console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
    return new rb(a);
  };
  a.ParticleSystem = function(a, b) {
    console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
    return new jd(a, b);
  };
  a.ParticleSystemMaterial = function(a) {
    console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
    return new rb(a);
  };
  a.Path = wb;
  a.PerspectiveCamera = ka;
  a.Plane = v;
  a.PlaneBufferGeometry = xa;
  a.PlaneGeometry = va;
  a.PlaneHelper = Ie;
  a.PointCloud = function(a, b) {
    console.warn("THREE.PointCloud has been renamed to THREE.Points.");
    return new jd(a, b);
  };
  a.PointCloudMaterial = function(a) {
    console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
    return new rb(a);
  };
  a.PointLight = zf;
  a.PointLightHelper = Fd;
  a.Points = jd;
  a.PointsMaterial = rb;
  a.PolarGridHelper = Nf;
  a.PolyhedronBufferGeometry = Ya;
  a.PolyhedronGeometry = je;
  a.PositionalAudio = Pg;
  a.PropertyBinding = Ua;
  a.PropertyMixer = Rg;
  a.QuadraticBezierCurve = ub;
  a.QuadraticBezierCurve3 = Jb;
  a.Quaternion = t;
  a.QuaternionKeyframeTrack = Ce;
  a.QuaternionLinearInterpolant = rf;
  a.REVISION = "116";
  a.RGBADepthPacking = 3201;
  a.RGBAFormat = 1023;
  a.RGBAIntegerFormat = 1033;
  a.RGBA_ASTC_10x10_Format = 37819;
  a.RGBA_ASTC_10x5_Format = 37816;
  a.RGBA_ASTC_10x6_Format = 37817;
  a.RGBA_ASTC_10x8_Format = 37818;
  a.RGBA_ASTC_12x10_Format = 37820;
  a.RGBA_ASTC_12x12_Format = 37821;
  a.RGBA_ASTC_4x4_Format = 37808;
  a.RGBA_ASTC_5x4_Format = 37809;
  a.RGBA_ASTC_5x5_Format = 37810;
  a.RGBA_ASTC_6x5_Format = 37811;
  a.RGBA_ASTC_6x6_Format = 37812;
  a.RGBA_ASTC_8x5_Format = 37813;
  a.RGBA_ASTC_8x6_Format = 37814;
  a.RGBA_ASTC_8x8_Format = 37815;
  a.RGBA_BPTC_Format = 36492;
  a.RGBA_ETC2_EAC_Format = 37496;
  a.RGBA_PVRTC_2BPPV1_Format = 35843;
  a.RGBA_PVRTC_4BPPV1_Format = 35842;
  a.RGBA_S3TC_DXT1_Format = 33777;
  a.RGBA_S3TC_DXT3_Format = 33778;
  a.RGBA_S3TC_DXT5_Format = 33779;
  a.RGBDEncoding = 3006;
  a.RGBEEncoding = 3002;
  a.RGBEFormat = 1023;
  a.RGBFormat = 1022;
  a.RGBIntegerFormat = 1032;
  a.RGBM16Encoding = 3005;
  a.RGBM7Encoding = 3004;
  a.RGB_ETC1_Format = 36196;
  a.RGB_ETC2_Format = 37492;
  a.RGB_PVRTC_2BPPV1_Format = 35841;
  a.RGB_PVRTC_4BPPV1_Format = 35840;
  a.RGB_S3TC_DXT1_Format = 33776;
  a.RGFormat = 1030;
  a.RGIntegerFormat = 1031;
  a.RawShaderMaterial = Vb;
  a.Ray = u;
  a.Raycaster = Ug;
  a.RectAreaLight = Df;
  a.RedFormat = 1028;
  a.RedIntegerFormat = 1029;
  a.ReinhardToneMapping = 2;
  a.RepeatWrapping = 1E3;
  a.ReplaceStencilOp = 7681;
  a.ReverseSubtractEquation = 102;
  a.RingBufferGeometry = ud;
  a.RingGeometry = we;
  a.SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
  a.SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
  a.SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
  a.SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
  a.SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
  a.SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
  a.SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
  a.SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
  a.SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
  a.SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
  a.SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
  a.SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
  a.SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
  a.SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
  a.Scene = y;
  a.SceneUtils = {createMultiMaterialObject:function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  }, detach:function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  }, attach:function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  }};
  a.ShaderChunk = oa;
  a.ShaderLib = Ab;
  a.ShaderMaterial = T;
  a.ShadowMaterial = Kc;
  a.Shape = qc;
  a.ShapeBufferGeometry = Ic;
  a.ShapeGeometry = Hc;
  a.ShapePath = Hg;
  a.ShapeUtils = Tb;
  a.ShortType = 1011;
  a.Skeleton = gf;
  a.SkeletonHelper = Rc;
  a.SkinnedMesh = ff;
  a.SmoothShading = 2;
  a.Sphere = r;
  a.SphereBufferGeometry = Gc;
  a.SphereGeometry = ve;
  a.Spherical = qi;
  a.SphericalHarmonics3 = Ef;
  a.SphericalReflectionMapping = 305;
  a.Spline = ch;
  a.SplineCurve = vb;
  a.SplineCurve3 = xi;
  a.SpotLight = yf;
  a.SpotLightHelper = Ed;
  a.SpotLightShadow = xf;
  a.Sprite = de;
  a.SpriteMaterial = nc;
  a.SrcAlphaFactor = 204;
  a.SrcAlphaSaturateFactor = 210;
  a.SrcColorFactor = 202;
  a.StaticCopyUsage = 35046;
  a.StaticDrawUsage = 35044;
  a.StaticReadUsage = 35045;
  a.StereoCamera = li;
  a.StreamCopyUsage = 35042;
  a.StreamDrawUsage = 35040;
  a.StreamReadUsage = 35041;
  a.StringKeyframeTrack = sf;
  a.SubtractEquation = 101;
  a.SubtractiveBlending = 3;
  a.TOUCH = {ROTATE:0, PAN:1, DOLLY_PAN:2, DOLLY_ROTATE:3};
  a.TangentSpaceNormalMap = 0;
  a.TetrahedronBufferGeometry = nd;
  a.TetrahedronGeometry = ke;
  a.TextBufferGeometry = td;
  a.TextGeometry = ue;
  a.Texture = e;
  a.TextureLoader = vf;
  a.TorusBufferGeometry = rd;
  a.TorusGeometry = qe;
  a.TorusKnotBufferGeometry = qd;
  a.TorusKnotGeometry = pe;
  a.Triangle = C;
  a.TriangleFanDrawMode = 2;
  a.TriangleStripDrawMode = 1;
  a.TrianglesDrawMode = 0;
  a.TubeBufferGeometry = Ec;
  a.TubeGeometry = oe;
  a.UVMapping = 300;
  a.Uint16Attribute = function(a, b) {
    console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
    return new S(a, b);
  };
  a.Uint16BufferAttribute = S;
  a.Uint32Attribute = function(a, b) {
    console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
    return new Z(a, b);
  };
  a.Uint32BufferAttribute = Z;
  a.Uint8Attribute = function(a, b) {
    console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
    return new J(a, b);
  };
  a.Uint8BufferAttribute = J;
  a.Uint8ClampedAttribute = function(a, b) {
    console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
    return new I(a, b);
  };
  a.Uint8ClampedBufferAttribute = I;
  a.Uncharted2ToneMapping = 3;
  a.Uniform = Lf;
  a.UniformsLib = aa;
  a.UniformsUtils = Uh;
  a.UnsignedByteType = 1009;
  a.UnsignedInt248Type = 1020;
  a.UnsignedIntType = 1014;
  a.UnsignedShort4444Type = 1017;
  a.UnsignedShort5551Type = 1018;
  a.UnsignedShort565Type = 1019;
  a.UnsignedShortType = 1012;
  a.VSMShadowMap = 3;
  a.Vector2 = g;
  a.Vector3 = f;
  a.Vector4 = k;
  a.VectorKeyframeTrack = zd;
  a.Vertex = function(a, b, c) {
    console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
    return new f(a, b, c);
  };
  a.VertexColors = 2;
  a.VideoTexture = yg;
  a.WebGLCubeRenderTarget = Aa;
  a.WebGLMultisampleRenderTarget = p;
  a.WebGLRenderTarget = c;
  a.WebGLRenderTargetCube = function(a, b, c) {
    console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).");
    return new Aa(a, c);
  };
  a.WebGLRenderer = ug;
  a.WebGLUtils = Yh;
  a.WireframeGeometry = ld;
  a.WireframeHelper = function(a, b) {
    console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
    return new Da(new ld(a.geometry), new ya({color:void 0 !== b ? b : 16777215}));
  };
  a.WrapAroundEnding = 2402;
  a.XHRLoader = function(a) {
    console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
    return new lb(a);
  };
  a.ZeroCurvatureEnding = 2400;
  a.ZeroFactor = 200;
  a.ZeroSlopeEnding = 2401;
  a.ZeroStencilOp = 0;
  a.sRGBEncoding = 3001;
  Object.defineProperty(a, "__esModule", {value:!0});
});
(function() {
  function a() {
    this.tolerance = -1;
    this.faces = [];
    this.newFaces = [];
    this.assigned = new e;
    this.unassigned = new e;
    this.vertices = [];
  }
  function d() {
    this.normal = new THREE.Vector3;
    this.midpoint = new THREE.Vector3;
    this.constant = this.area = 0;
    this.outside = null;
    this.mark = 0;
    this.edge = null;
  }
  function g(a, c) {
    this.vertex = a;
    this.twin = this.next = this.prev = null;
    this.face = c;
  }
  function h(a) {
    this.point = a;
    this.face = this.next = this.prev = null;
  }
  function e() {
    this.tail = this.head = null;
  }
  Object.assign(a.prototype, {setFromPoints:function(a) {
    !0 !== Array.isArray(a) && console.error("THREE.QuickHull: Points parameter is not an array.");
    4 > a.length && console.error("THREE.QuickHull: The algorithm needs at least four points.");
    this.makeEmpty();
    for (var c = 0, e = a.length; c < e; c++) {
      this.vertices.push(new h(a[c]));
    }
    this.compute();
    return this;
  }, setFromObject:function(a) {
    var c = [];
    a.updateMatrixWorld(!0);
    a.traverse(function(a) {
      var e;
      var d = a.geometry;
      if (void 0 !== d) {
        if (d.isGeometry) {
          var k = d.vertices;
          d = 0;
          for (e = k.length; d < e; d++) {
            var b = k[d].clone();
            b.applyMatrix4(a.matrixWorld);
            c.push(b);
          }
        } else {
          if (d.isBufferGeometry && (k = d.attributes.position, void 0 !== k)) {
            for (d = 0, e = k.count; d < e; d++) {
              b = new THREE.Vector3, b.fromBufferAttribute(k, d).applyMatrix4(a.matrixWorld), c.push(b);
            }
          }
        }
      }
    });
    return this.setFromPoints(c);
  }, makeEmpty:function() {
    this.faces = [];
    this.vertices = [];
    return this;
  }, addVertexToFace:function(a, c) {
    a.face = c;
    null === c.outside ? this.assigned.append(a) : this.assigned.insertBefore(c.outside, a);
    c.outside = a;
    return this;
  }, removeVertexFromFace:function(a, c) {
    a === c.outside && (c.outside = null !== a.next && a.next.face === c ? a.next : null);
    this.assigned.remove(a);
    return this;
  }, removeAllVerticesFromFace:function(a) {
    if (null !== a.outside) {
      for (var c = a.outside, e = a.outside; null !== e.next && e.next.face === a;) {
        e = e.next;
      }
      this.assigned.removeSubList(c, e);
      c.prev = e.next = null;
      a.outside = null;
      return c;
    }
  }, deleteFaceVertices:function(a, c) {
    a = this.removeAllVerticesFromFace(a);
    if (void 0 !== a) {
      if (void 0 === c) {
        this.unassigned.appendChain(a);
      } else {
        do {
          var e = a.next;
          c.distanceToPoint(a.point) > this.tolerance ? this.addVertexToFace(a, c) : this.unassigned.append(a);
          a = e;
        } while (null !== a);
      }
    }
    return this;
  }, resolveUnassignedPoints:function(a) {
    if (!1 === this.unassigned.isEmpty()) {
      var c = this.unassigned.first();
      do {
        for (var e = c.next, d = this.tolerance, f = null, k = 0; k < a.length; k++) {
          var b = a[k];
          if (0 === b.mark) {
            var m = b.distanceToPoint(c.point);
            m > d && (d = m, f = b);
            if (d > 1E3 * this.tolerance) {
              break;
            }
          }
        }
        null !== f && this.addVertexToFace(c, f);
        c = e;
      } while (null !== c);
    }
    return this;
  }, computeExtremes:function() {
    var a = new THREE.Vector3, c = new THREE.Vector3, e = [], d = [], f, h, b;
    for (f = 0; 3 > f; f++) {
      e[f] = d[f] = this.vertices[0];
    }
    a.copy(this.vertices[0].point);
    c.copy(this.vertices[0].point);
    f = 0;
    for (h = this.vertices.length; f < h; f++) {
      var m = this.vertices[f], g = m.point;
      for (b = 0; 3 > b; b++) {
        g.getComponent(b) < a.getComponent(b) && (a.setComponent(b, g.getComponent(b)), e[b] = m);
      }
      for (b = 0; 3 > b; b++) {
        g.getComponent(b) > c.getComponent(b) && (c.setComponent(b, g.getComponent(b)), d[b] = m);
      }
    }
    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(a.x), Math.abs(c.x)) + Math.max(Math.abs(a.y), Math.abs(c.y)) + Math.max(Math.abs(a.z), Math.abs(c.z)));
    return {min:e, max:d};
  }, computeInitialHull:function() {
    var a, c, e;
    return function() {
      void 0 === a && (a = new THREE.Line3, c = new THREE.Plane, e = new THREE.Vector3);
      var k = this.vertices, f = this.computeExtremes(), h = f.min, b = f.max, m, g, p = 0;
      for (f = g = 0; 3 > f; f++) {
        var x = b[f].point.getComponent(f) - h[f].point.getComponent(f);
        x > p && (p = x, g = f);
      }
      h = h[g];
      b = b[g];
      p = 0;
      a.set(h.point, b.point);
      f = 0;
      for (m = this.vertices.length; f < m; f++) {
        var z = k[f];
        if (z !== h && z !== b && (a.closestPointToPoint(z.point, !0, e), x = e.distanceToSquared(z.point), x > p)) {
          p = x;
          var r = z;
        }
      }
      p = -1;
      c.setFromCoplanarPoints(h.point, b.point, r.point);
      f = 0;
      for (m = this.vertices.length; f < m; f++) {
        if (z = k[f], z !== h && z !== b && z !== r && (x = Math.abs(c.distanceToPoint(z.point)), x > p)) {
          p = x;
          var u = z;
        }
      }
      x = [];
      if (0 > c.distanceToPoint(u.point)) {
        for (x.push(d.create(h, b, r), d.create(u, b, h), d.create(u, r, b), d.create(u, h, r)), f = 0; 3 > f; f++) {
          g = (f + 1) % 3, x[f + 1].getEdge(2).setTwin(x[0].getEdge(g)), x[f + 1].getEdge(1).setTwin(x[g + 1].getEdge(0));
        }
      } else {
        for (x.push(d.create(h, r, b), d.create(u, h, b), d.create(u, b, r), d.create(u, r, h)), f = 0; 3 > f; f++) {
          g = (f + 1) % 3, x[f + 1].getEdge(2).setTwin(x[0].getEdge((3 - f) % 3)), x[f + 1].getEdge(0).setTwin(x[g + 1].getEdge(1));
        }
      }
      for (f = 0; 4 > f; f++) {
        this.faces.push(x[f]);
      }
      f = 0;
      for (m = k.length; f < m; f++) {
        if (z = k[f], z !== h && z !== b && z !== r && z !== u) {
          p = this.tolerance;
          var v = null;
          for (g = 0; 4 > g; g++) {
            x = this.faces[g].distanceToPoint(z.point), x > p && (p = x, v = this.faces[g]);
          }
          null !== v && this.addVertexToFace(z, v);
        }
      }
      return this;
    };
  }(), reindexFaces:function() {
    for (var a = [], c = 0; c < this.faces.length; c++) {
      var e = this.faces[c];
      0 === e.mark && a.push(e);
    }
    this.faces = a;
    return this;
  }, nextVertexToAdd:function() {
    if (!1 === this.assigned.isEmpty()) {
      var a = 0, c = this.assigned.first().face, e = c.outside;
      do {
        var d = c.distanceToPoint(e.point);
        if (d > a) {
          a = d;
          var f = e;
        }
        e = e.next;
      } while (null !== e && e.face === c);
      return f;
    }
  }, computeHorizon:function(a, c, e, d) {
    this.deleteFaceVertices(e);
    e.mark = 1;
    e = null === c ? c = e.getEdge(0) : c.next;
    do {
      var f = e.twin, k = f.face;
      0 === k.mark && (k.distanceToPoint(a) > this.tolerance ? this.computeHorizon(a, f, k, d) : d.push(e));
      e = e.next;
    } while (e !== c);
    return this;
  }, addAdjoiningFace:function(a, c) {
    a = d.create(a, c.tail(), c.head());
    this.faces.push(a);
    a.getEdge(-1).setTwin(c.twin);
    return a.getEdge(0);
  }, addNewFaces:function(a, c) {
    this.newFaces = [];
    for (var e = null, d = null, f = 0; f < c.length; f++) {
      var k = this.addAdjoiningFace(a, c[f]);
      null === e ? e = k : k.next.setTwin(d);
      this.newFaces.push(k.face);
      d = k;
    }
    e.next.setTwin(d);
    return this;
  }, addVertexToHull:function(a) {
    var c = [];
    this.unassigned.clear();
    this.removeVertexFromFace(a, a.face);
    this.computeHorizon(a.point, null, a.face, c);
    this.addNewFaces(a, c);
    this.resolveUnassignedPoints(this.newFaces);
    return this;
  }, cleanup:function() {
    this.assigned.clear();
    this.unassigned.clear();
    this.newFaces = [];
    return this;
  }, compute:function() {
    var a;
    for (this.computeInitialHull(); void 0 !== (a = this.nextVertexToAdd());) {
      this.addVertexToHull(a);
    }
    this.reindexFaces();
    this.cleanup();
    return this;
  }});
  Object.assign(d, {create:function(a, c, e) {
    var k = new d;
    a = new g(a, k);
    c = new g(c, k);
    e = new g(e, k);
    a.next = e.prev = c;
    c.next = a.prev = e;
    e.next = c.prev = a;
    k.edge = a;
    return k.compute();
  }});
  Object.assign(d.prototype, {getEdge:function(a) {
    for (var c = this.edge; 0 < a;) {
      c = c.next, a--;
    }
    for (; 0 > a;) {
      c = c.prev, a++;
    }
    return c;
  }, compute:function() {
    var a;
    return function() {
      void 0 === a && (a = new THREE.Triangle);
      var c = this.edge.tail(), e = this.edge.head(), d = this.edge.next.head();
      a.set(c.point, e.point, d.point);
      a.getNormal(this.normal);
      a.getMidpoint(this.midpoint);
      this.area = a.getArea();
      this.constant = this.normal.dot(this.midpoint);
      return this;
    };
  }(), distanceToPoint:function(a) {
    return this.normal.dot(a) - this.constant;
  }});
  Object.assign(g.prototype, {head:function() {
    return this.vertex;
  }, tail:function() {
    return this.prev ? this.prev.vertex : null;
  }, length:function() {
    var a = this.head(), c = this.tail();
    return null !== c ? c.point.distanceTo(a.point) : -1;
  }, lengthSquared:function() {
    var a = this.head(), c = this.tail();
    return null !== c ? c.point.distanceToSquared(a.point) : -1;
  }, setTwin:function(a) {
    this.twin = a;
    a.twin = this;
    return this;
  }});
  Object.assign(e.prototype, {first:function() {
    return this.head;
  }, last:function() {
    return this.tail;
  }, clear:function() {
    this.head = this.tail = null;
    return this;
  }, insertBefore:function(a, c) {
    c.prev = a.prev;
    c.next = a;
    null === c.prev ? this.head = c : c.prev.next = c;
    a.prev = c;
    return this;
  }, insertAfter:function(a, c) {
    c.prev = a;
    c.next = a.next;
    null === c.next ? this.tail = c : c.next.prev = c;
    a.next = c;
    return this;
  }, append:function(a) {
    null === this.head ? this.head = a : this.tail.next = a;
    a.prev = this.tail;
    a.next = null;
    this.tail = a;
    return this;
  }, appendChain:function(a) {
    null === this.head ? this.head = a : this.tail.next = a;
    for (a.prev = this.tail; null !== a.next;) {
      a = a.next;
    }
    this.tail = a;
    return this;
  }, remove:function(a) {
    null === a.prev ? this.head = a.next : a.prev.next = a.next;
    null === a.next ? this.tail = a.prev : a.next.prev = a.prev;
    return this;
  }, removeSubList:function(a, c) {
    null === a.prev ? this.head = c.next : a.prev.next = c.next;
    null === c.next ? this.tail = a.prev : c.next.prev = a.prev;
    return this;
  }, isEmpty:function() {
    return null === this.head;
  }});
  THREE.QuickHull = a;
})();
var SimplexNoise = function(a) {
  void 0 == a && (a = Math);
  this.grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]];
  this.grad4 = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, 
  -1, 0]];
  this.p = [];
  for (var d = 0; 256 > d; d++) {
    this.p[d] = Math.floor(256 * a.random());
  }
  this.perm = [];
  for (d = 0; 512 > d; d++) {
    this.perm[d] = this.p[d & 255];
  }
  this.simplex = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 
  0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]];
};
SimplexNoise.prototype.dot = function(a, d, g) {
  return a[0] * d + a[1] * g;
};
SimplexNoise.prototype.dot3 = function(a, d, g, h) {
  return a[0] * d + a[1] * g + a[2] * h;
};
SimplexNoise.prototype.dot4 = function(a, d, g, h, e) {
  return a[0] * d + a[1] * g + a[2] * h + a[3] * e;
};
SimplexNoise.prototype.noise = function(a, d) {
  var g = .5 * (a + d) * (Math.sqrt(3) - 1), h = Math.floor(a + g), e = Math.floor(d + g);
  g = (3 - Math.sqrt(3)) / 6;
  var k = (h + e) * g;
  a -= h - k;
  var c = d - (e - k);
  if (a > c) {
    var p = 1;
    var t = 0;
  } else {
    p = 0, t = 1;
  }
  k = a - p + g;
  var f = c - t + g;
  d = a - 1 + 2 * g;
  g = c - 1 + 2 * g;
  var n = h & 255, b = e & 255;
  h = this.perm[n + this.perm[b]] % 12;
  e = this.perm[n + p + this.perm[b + t]] % 12;
  p = this.perm[n + 1 + this.perm[b + 1]] % 12;
  t = .5 - a * a - c * c;
  0 > t ? a = 0 : (t *= t, a = t * t * this.dot(this.grad3[h], a, c));
  c = .5 - k * k - f * f;
  0 > c ? k = 0 : (c *= c, k = c * c * this.dot(this.grad3[e], k, f));
  f = .5 - d * d - g * g;
  0 > f ? d = 0 : (f *= f, d = f * f * this.dot(this.grad3[p], d, g));
  return 70 * (a + k + d);
};
SimplexNoise.prototype.noise3d = function(a, d, g) {
  var h = 1 / 3 * (a + d + g), e = Math.floor(a + h), k = Math.floor(d + h), c = Math.floor(g + h);
  h = 1 / 6;
  var p = (e + k + c) * h;
  var t = a - (e - p);
  var f = d - (k - p);
  var n = g - (c - p), b, m;
  if (t >= f) {
    if (f >= n) {
      var q = 1;
      var y = b = 0;
      var x = m = 1;
      var z = 0;
    } else {
      t >= n ? (q = 1, y = b = 0) : (b = q = 0, y = 1), m = 1, x = 0, z = 1;
    }
  } else {
    f < n ? (b = q = 0, y = 1, m = 0, z = x = 1) : t < n ? (q = 0, b = 1, m = y = 0, z = x = 1) : (q = 0, b = 1, y = 0, x = m = 1, z = 0);
  }
  var r = t - q + h, u = f - b + h, v = n - y + h;
  p = t - m + 2 * h;
  a = f - x + 2 * h;
  var C = n - z + 2 * h;
  g = t - 1 + 3 * h;
  d = f - 1 + 3 * h;
  h = n - 1 + 3 * h;
  e &= 255;
  var A = k & 255, D = c & 255;
  k = this.perm[e + this.perm[A + this.perm[D]]] % 12;
  c = this.perm[e + q + this.perm[A + b + this.perm[D + y]]] % 12;
  m = this.perm[e + m + this.perm[A + x + this.perm[D + z]]] % 12;
  e = this.perm[e + 1 + this.perm[A + 1 + this.perm[D + 1]]] % 12;
  x = .6 - t * t - f * f - n * n;
  0 > x ? t = 0 : (x *= x, t = x * x * this.dot3(this.grad3[k], t, f, n));
  f = .6 - r * r - u * u - v * v;
  0 > f ? f = 0 : (f *= f, f = f * f * this.dot3(this.grad3[c], r, u, v));
  r = .6 - p * p - a * a - C * C;
  0 > r ? p = 0 : (r *= r, p = r * r * this.dot3(this.grad3[m], p, a, C));
  a = .6 - g * g - d * d - h * h;
  0 > a ? g = 0 : (a *= a, g = a * a * this.dot3(this.grad3[e], g, d, h));
  return 32 * (t + f + p + g);
};
SimplexNoise.prototype.noise4d = function(a, d, g, h) {
  var e = this.grad4, k = this.simplex, c = this.perm, p = (5 - Math.sqrt(5)) / 20;
  var t = (Math.sqrt(5) - 1) / 4 * (a + d + g + h);
  var f = Math.floor(a + t), n = Math.floor(d + t), b = Math.floor(g + t), m = Math.floor(h + t);
  t = (f + n + b + m) * p;
  a -= f - t;
  var q = d - (n - t);
  var y = g - (b - t);
  var x = h - (m - t);
  h = (a > q ? 32 : 0) + (a > y ? 16 : 0) + (q > y ? 8 : 0) + (a > x ? 4 : 0) + (q > x ? 2 : 0) + (y > x ? 1 : 0);
  var z = 3 <= k[h][0] ? 1 : 0;
  var r = 3 <= k[h][1] ? 1 : 0;
  var u = 3 <= k[h][2] ? 1 : 0;
  var v = 3 <= k[h][3] ? 1 : 0;
  var C = 2 <= k[h][0] ? 1 : 0;
  var A = 2 <= k[h][1] ? 1 : 0;
  var D = 2 <= k[h][2] ? 1 : 0;
  var F = 2 <= k[h][3] ? 1 : 0;
  var B = 1 <= k[h][0] ? 1 : 0;
  var E = 1 <= k[h][1] ? 1 : 0;
  var H = 1 <= k[h][2] ? 1 : 0;
  var L = 1 <= k[h][3] ? 1 : 0;
  var K = a - z + p, P = q - r + p, J = y - u + p, I = x - v + p, N = a - C + 2 * p, S = q - A + 2 * p, Q = y - D + 2 * p, Z = x - F + 2 * p;
  t = a - B + 3 * p;
  d = q - E + 3 * p;
  var R = y - H + 3 * p, W = x - L + 3 * p;
  k = a - 1 + 4 * p;
  h = q - 1 + 4 * p;
  g = y - 1 + 4 * p;
  p = x - 1 + 4 * p;
  f &= 255;
  n &= 255;
  var O = b & 255;
  m &= 255;
  b = c[f + c[n + c[O + c[m]]]] % 32;
  z = c[f + z + c[n + r + c[O + u + c[m + v]]]] % 32;
  C = c[f + C + c[n + A + c[O + D + c[m + F]]]] % 32;
  B = c[f + B + c[n + E + c[O + H + c[m + L]]]] % 32;
  c = c[f + 1 + c[n + 1 + c[O + 1 + c[m + 1]]]] % 32;
  m = .6 - a * a - q * q - y * y - x * x;
  0 > m ? a = 0 : (m *= m, a = m * m * this.dot4(e[b], a, q, y, x));
  q = .6 - K * K - P * P - J * J - I * I;
  0 > q ? q = 0 : (q *= q, q = q * q * this.dot4(e[z], K, P, J, I));
  y = .6 - N * N - S * S - Q * Q - Z * Z;
  0 > y ? y = 0 : (y *= y, y = y * y * this.dot4(e[C], N, S, Q, Z));
  N = .6 - t * t - d * d - R * R - W * W;
  0 > N ? t = 0 : (N *= N, t = N * N * this.dot4(e[B], t, d, R, W));
  d = .6 - k * k - h * h - g * g - p * p;
  0 > d ? e = 0 : (d *= d, e = d * d * this.dot4(e[c], k, h, g, p));
  return 27 * (a + q + y + t + e);
};
THREE.AfterimageShader = {uniforms:{damp:{value:.96}, tOld:{value:null}, tNew:{value:null}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform float damp;\nuniform sampler2D tOld;\nuniform sampler2D tNew;\nvarying vec2 vUv;\nvec4 when_gt( vec4 x, float y ) {\n\treturn max( sign( x - y ), 0.0 );\n}\nvoid main() {\n\tvec4 texelOld = texture2D( tOld, vUv );\n\tvec4 texelNew = texture2D( tNew, vUv );\n\ttexelOld *= damp * when_gt( texelOld, 0.1 );\n\tgl_FragColor = max(texelNew, texelOld);\n}"};
THREE.CopyShader = {uniforms:{tDiffuse:{value:null}, opacity:{value:1}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform float opacity;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texel = texture2D( tDiffuse, vUv );\n\tgl_FragColor = opacity * texel;\n}"};
THREE.BokehShader = {defines:{DEPTH_PACKING:1, PERSPECTIVE_CAMERA:1}, uniforms:{tColor:{value:null}, tDepth:{value:null}, focus:{value:1}, aspect:{value:1}, aperture:{value:.025}, maxblur:{value:1}, nearClip:{value:1}, farClip:{value:1E3}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"#include <common>\nvarying vec2 vUv;\nuniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float maxblur;\nuniform float aperture;\nuniform float nearClip;\nuniform float farClip;\nuniform float focus;\nuniform float aspect;\n#include <packing>\nfloat getDepth( const in vec2 screenPosition ) {\n\t#if DEPTH_PACKING == 1\n\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t#else\n\treturn texture2D( tDepth, screenPosition ).x;\n\t#endif\n}\nfloat getViewZ( const in float depth ) {\n\t#if PERSPECTIVE_CAMERA == 1\n\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );\n\t#else\n\treturn orthographicDepthToViewZ( depth, nearClip, farClip );\n\t#endif\n}\nvoid main() {\n\tvec2 aspectcorrect = vec2( 1.0, aspect );\n\tfloat viewZ = getViewZ( getDepth( vUv ) );\n\tfloat factor = ( focus + viewZ );\n\tvec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\n\tvec2 dofblur9 = dofblur * 0.9;\n\tvec2 dofblur7 = dofblur * 0.7;\n\tvec2 dofblur4 = dofblur * 0.4;\n\tvec4 col = vec4( 0.0 );\n\tcol += texture2D( tColor, vUv.xy );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\n\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\n\tgl_FragColor = col / 41.0;\n\tgl_FragColor.a = 1.0;\n}"};
THREE.SAOShader = {defines:{NUM_SAMPLES:7, NUM_RINGS:4, NORMAL_TEXTURE:0, DIFFUSE_TEXTURE:0, DEPTH_PACKING:1, PERSPECTIVE_CAMERA:1}, uniforms:{tDepth:{value:null}, tDiffuse:{value:null}, tNormal:{value:null}, size:{value:new THREE.Vector2(512, 512)}, cameraNear:{value:1}, cameraFar:{value:100}, cameraProjectionMatrix:{value:new THREE.Matrix4}, cameraInverseProjectionMatrix:{value:new THREE.Matrix4}, scale:{value:1}, intensity:{value:.1}, bias:{value:.5}, minResolution:{value:0}, kernelRadius:{value:100}, 
randomSeed:{value:0}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"#include <common>\nvarying vec2 vUv;\n#if DIFFUSE_TEXTURE == 1\nuniform sampler2D tDiffuse;\n#endif\nuniform sampler2D tDepth;\n#if NORMAL_TEXTURE == 1\nuniform sampler2D tNormal;\n#endif\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 cameraProjectionMatrix;\nuniform mat4 cameraInverseProjectionMatrix;\nuniform float scale;\nuniform float intensity;\nuniform float bias;\nuniform float kernelRadius;\nuniform float minResolution;\nuniform vec2 size;\nuniform float randomSeed;\n// RGBA depth\n#include <packing>\nvec4 getDefaultColor( const in vec2 screenPosition ) {\n\t#if DIFFUSE_TEXTURE == 1\n\treturn texture2D( tDiffuse, vUv );\n\t#else\n\treturn vec4( 1.0 );\n\t#endif\n}\nfloat getDepth( const in vec2 screenPosition ) {\n\t#if DEPTH_PACKING == 1\n\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t#else\n\treturn texture2D( tDepth, screenPosition ).x;\n\t#endif\n}\nfloat getViewZ( const in float depth ) {\n\t#if PERSPECTIVE_CAMERA == 1\n\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t#else\n\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t#endif\n}\nvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\tclipPosition *= clipW; // unprojection.\n\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n}\nvec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\n\t#if NORMAL_TEXTURE == 1\n\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\t#else\n\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\n\t#endif\n}\nfloat scaleDividedByCameraFar;\nfloat minResolutionMultipliedByCameraFar;\nfloat getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\n\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\n\tfloat viewDistance = length( viewDelta );\n\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\n\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\n}\n// moving costly divides into consts\nconst float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\nconst float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\nfloat getAmbientOcclusion( const in vec3 centerViewPosition ) {\n\t// precompute some variables require in getOcclusion.\n\tscaleDividedByCameraFar = scale / cameraFar;\n\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;\n\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );\n\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n\tfloat angle = rand( vUv + randomSeed ) * PI2;\n\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\n\tvec2 radiusStep = radius;\n\tfloat occlusionSum = 0.0;\n\tfloat weightSum = 0.0;\n\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;\n\t\tradius += radiusStep;\n\t\tangle += ANGLE_STEP;\n\t\tfloat sampleDepth = getDepth( sampleUv );\n\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfloat sampleViewZ = getViewZ( sampleDepth );\n\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );\n\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\n\t\tweightSum += 1.0;\n\t}\n\tif( weightSum == 0.0 ) discard;\n\treturn occlusionSum * ( intensity / weightSum );\n}\nvoid main() {\n\tfloat centerDepth = getDepth( vUv );\n\tif( centerDepth >= ( 1.0 - EPSILON ) ) {\n\t\tdiscard;\n\t}\n\tfloat centerViewZ = getViewZ( centerDepth );\n\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\n\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\n\tgl_FragColor = getDefaultColor( vUv );\n\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\n}"};
THREE.DepthLimitedBlurShader = {defines:{KERNEL_RADIUS:4, DEPTH_PACKING:1, PERSPECTIVE_CAMERA:1}, uniforms:{tDiffuse:{value:null}, size:{value:new THREE.Vector2(512, 512)}, sampleUvOffsets:{value:[new THREE.Vector2(0, 0)]}, sampleWeights:{value:[1]}, tDepth:{value:null}, cameraNear:{value:10}, cameraFar:{value:1E3}, depthCutoff:{value:10}}, vertexShader:"#include <common>\nuniform vec2 size;\nvarying vec2 vUv;\nvarying vec2 vInvSize;\nvoid main() {\n\tvUv = uv;\n\tvInvSize = 1.0 / size;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", 
fragmentShader:"#include <common>\n#include <packing>\nuniform sampler2D tDiffuse;\nuniform sampler2D tDepth;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform float depthCutoff;\nuniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\nuniform float sampleWeights[ KERNEL_RADIUS + 1 ];\nvarying vec2 vUv;\nvarying vec2 vInvSize;\nfloat getDepth( const in vec2 screenPosition ) {\n\t#if DEPTH_PACKING == 1\n\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t#else\n\treturn texture2D( tDepth, screenPosition ).x;\n\t#endif\n}\nfloat getViewZ( const in float depth ) {\n\t#if PERSPECTIVE_CAMERA == 1\n\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t#else\n\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t#endif\n}\nvoid main() {\n\tfloat depth = getDepth( vUv );\n\tif( depth >= ( 1.0 - EPSILON ) ) {\n\t\tdiscard;\n\t}\n\tfloat centerViewZ = -getViewZ( depth );\n\tbool rBreak = false, lBreak = false;\n\tfloat weightSum = sampleWeights[0];\n\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\n\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\n\t\tfloat sampleWeight = sampleWeights[i];\n\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\n\t\tvec2 sampleUv = vUv + sampleUvOffset;\n\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\n\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\n\t\tif( ! rBreak ) {\n\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n\t\t\tweightSum += sampleWeight;\n\t\t}\n\t\tsampleUv = vUv - sampleUvOffset;\n\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\n\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\n\t\tif( ! lBreak ) {\n\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n\t\t\tweightSum += sampleWeight;\n\t\t}\n\t}\n\tgl_FragColor = diffuseSum / weightSum;\n}"};
THREE.BlurShaderUtils = {createSampleWeights:function(a, d) {
  for (var g = [], h = 0; h <= a; h++) {
    g.push(Math.exp(-(h * h) / (2 * d * d)) / (Math.sqrt(2 * Math.PI) * d));
  }
  return g;
}, createSampleOffsets:function(a, d) {
  for (var g = [], h = 0; h <= a; h++) {
    g.push(d.clone().multiplyScalar(h));
  }
  return g;
}, configure:function(a, d, g, h) {
  a.defines.KERNEL_RADIUS = d;
  a.uniforms.sampleUvOffsets.value = THREE.BlurShaderUtils.createSampleOffsets(d, h);
  a.uniforms.sampleWeights.value = THREE.BlurShaderUtils.createSampleWeights(d, g);
  a.needsUpdate = !0;
}};
THREE.UnpackDepthRGBAShader = {uniforms:{tDiffuse:{value:null}, opacity:{value:1}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform float opacity;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\n#include <packing>\nvoid main() {\n\tfloat depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );\n\tgl_FragColor = vec4( vec3( depth ), opacity );\n}"};
THREE.ConvolutionShader = {defines:{KERNEL_SIZE_FLOAT:"25.0", KERNEL_SIZE_INT:"25"}, uniforms:{tDiffuse:{value:null}, uImageIncrement:{value:new THREE.Vector2(.001953125, 0)}, cKernel:{value:[]}}, vertexShader:"uniform vec2 uImageIncrement;\nvarying vec2 vUv;\nvoid main() {\n\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform float cKernel[ KERNEL_SIZE_INT ];\nuniform sampler2D tDiffuse;\nuniform vec2 uImageIncrement;\nvarying vec2 vUv;\nvoid main() {\n\tvec2 imageCoord = vUv;\n\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\n\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\n\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\n\t\timageCoord += uImageIncrement;\n\t}\n\tgl_FragColor = sum;\n}", 
buildKernel:function(a) {
  var d, g, h = 2 * Math.ceil(3 * a) + 1;
  25 < h && (h = 25);
  var e = .5 * (h - 1);
  var k = Array(h);
  for (d = g = 0; d < h; ++d) {
    var c = d - e;
    k[d] = Math.exp(-(c * c) / (2 * a * a));
    g += k[d];
  }
  for (d = 0; d < h; ++d) {
    k[d] /= g;
  }
  return k;
}};
THREE.LuminosityHighPassShader = {shaderID:"luminosityHighPass", uniforms:{tDiffuse:{value:null}, luminosityThreshold:{value:1}, smoothWidth:{value:1}, defaultColor:{value:new THREE.Color(0)}, defaultOpacity:{value:0}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform sampler2D tDiffuse;\nuniform vec3 defaultColor;\nuniform float defaultOpacity;\nuniform float luminosityThreshold;\nuniform float smoothWidth;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texel = texture2D( tDiffuse, vUv );\n\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\tfloat v = dot( texel.xyz, luma );\n\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\tgl_FragColor = mix( outputColor, texel, alpha );\n}"};
THREE.FXAAShader = {uniforms:{tDiffuse:{value:null}, resolution:{value:new THREE.Vector2(1 / 1024, 1 / 512)}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:'precision highp float;\n\nuniform sampler2D tDiffuse;\n\nuniform vec2 resolution;\n\nvarying vec2 vUv;\n\n// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n//----------------------------------------------------------------------------------\n// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n// SDK Version: v3.00\n// Email:       gameworks@nvidia.com\n// Site:        http://developer.nvidia.com/\n//\n// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//  * Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//  * Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//  * Neither the name of NVIDIA CORPORATION nor the names of its\n//    contributors may be used to endorse or promote products derived\n//    from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS\'\' AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//----------------------------------------------------------------------------------\n\n#define FXAA_PC 1\n#define FXAA_GLSL_100 1\n#define FXAA_QUALITY_PRESET 12\n\n#define FXAA_GREEN_AS_LUMA 1\n\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_PC_CONSOLE\n    //\n    // The console algorithm for PC is included\n    // for developers targeting really low spec machines.\n    // Likely better to just run FXAA_PC, and use a really low preset.\n    //\n    #define FXAA_PC_CONSOLE 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_120\n    #define FXAA_GLSL_120 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_130\n    #define FXAA_GLSL_130 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_3\n    #define FXAA_HLSL_3 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_4\n    #define FXAA_HLSL_4 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_5\n    #define FXAA_HLSL_5 0\n#endif\n/*==========================================================================*/\n#ifndef FXAA_GREEN_AS_LUMA\n    //\n    // For those using non-linear color,\n    // and either not able to get luma in alpha, or not wanting to,\n    // this enables FXAA to run using green as a proxy for luma.\n    // So with this enabled, no need to pack luma in alpha.\n    //\n    // This will turn off AA on anything which lacks some amount of green.\n    // Pure red and blue or combination of only R and B, will get no AA.\n    //\n    // Might want to lower the settings for both,\n    //    fxaaConsoleEdgeThresholdMin\n    //    fxaaQualityEdgeThresholdMin\n    // In order to insure AA does not get turned off on colors\n    // which contain a minor amount of green.\n    //\n    // 1 = On.\n    // 0 = Off.\n    //\n    #define FXAA_GREEN_AS_LUMA 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_EARLY_EXIT\n    //\n    // Controls algorithm\'s early exit path.\n    // On PS3 turning this ON adds 2 cycles to the shader.\n    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n    // Turning this off on console will result in a more blurry image.\n    // So this defaults to on.\n    //\n    // 1 = On.\n    // 0 = Off.\n    //\n    #define FXAA_EARLY_EXIT 1\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_DISCARD\n    //\n    // Only valid for PC OpenGL currently.\n    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n    //\n    // 1 = Use discard on pixels which don\'t need AA.\n    //     For APIs which enable concurrent TEX+ROP from same surface.\n    // 0 = Return unchanged color on pixels which don\'t need AA.\n    //\n    #define FXAA_DISCARD 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_FAST_PIXEL_OFFSET\n    //\n    // Used for GLSL 120 only.\n    //\n    // 1 = GL API supports fast pixel offsets\n    // 0 = do not use fast pixel offsets\n    //\n    #ifdef GL_EXT_gpu_shader4\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifndef FXAA_FAST_PIXEL_OFFSET\n        #define FXAA_FAST_PIXEL_OFFSET 0\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GATHER4_ALPHA\n    //\n    // 1 = API supports gather4 on alpha channel.\n    // 0 = API does not support gather4 on alpha channel.\n    //\n    #if (FXAA_HLSL_5 == 1)\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifndef FXAA_GATHER4_ALPHA\n        #define FXAA_GATHER4_ALPHA 0\n    #endif\n#endif\n\n\n/*============================================================================\n                        FXAA QUALITY - TUNING KNOBS\n------------------------------------------------------------------------------\nNOTE the other tuning knobs are now in the shader function inputs!\n============================================================================*/\n#ifndef FXAA_QUALITY_PRESET\n    //\n    // Choose the quality preset.\n    // This needs to be compiled into the shader as it effects code.\n    // Best option to include multiple presets is to\n    // in each shader define the preset, then include this file.\n    //\n    // OPTIONS\n    // -----------------------------------------------------------------------\n    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n    // 39       - no dither, very expensive\n    //\n    // NOTES\n    // -----------------------------------------------------------------------\n    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n    // 13 = about same speed as FXAA 3.9 and better than 12\n    // 23 = closest to FXAA 3.9 visually and performance wise\n    //  _ = the lowest digit is directly related to performance\n    // _  = the highest digit is directly related to style\n    //\n    #define FXAA_QUALITY_PRESET 12\n#endif\n\n\n/*============================================================================\n\n                           FXAA QUALITY - PRESETS\n\n============================================================================*/\n\n/*============================================================================\n                     FXAA QUALITY - MEDIUM DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n\n/*============================================================================\n                     FXAA QUALITY - LOW DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n/*============================================================================\n                     FXAA QUALITY - EXTREME QUALITY\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n\n\n/*============================================================================\n\n                                API PORTING\n\n============================================================================*/\n#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n    #define FxaaBool bool\n    #define FxaaDiscard discard\n    #define FxaaFloat float\n    #define FxaaFloat2 vec2\n    #define FxaaFloat3 vec3\n    #define FxaaFloat4 vec4\n    #define FxaaHalf float\n    #define FxaaHalf2 vec2\n    #define FxaaHalf3 vec3\n    #define FxaaHalf4 vec4\n    #define FxaaInt2 ivec2\n    #define FxaaSat(x) clamp(x, 0.0, 1.0)\n    #define FxaaTex sampler2D\n#else\n    #define FxaaBool bool\n    #define FxaaDiscard clip(-1)\n    #define FxaaFloat float\n    #define FxaaFloat2 float2\n    #define FxaaFloat3 float3\n    #define FxaaFloat4 float4\n    #define FxaaHalf half\n    #define FxaaHalf2 half2\n    #define FxaaHalf3 half3\n    #define FxaaHalf4 half4\n    #define FxaaSat(x) saturate(x)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_100 == 1)\n  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_120 == 1)\n    // Requires,\n    //  #version 120\n    // And at least,\n    //  #extension GL_EXT_gpu_shader4 : enable\n    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n    #if (FXAA_FAST_PIXEL_OFFSET == 1)\n        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n    #else\n        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n    #endif\n    #if (FXAA_GATHER4_ALPHA == 1)\n        // use #extension GL_ARB_gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_130 == 1)\n    // Requires "#version 130" or better\n    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n    #if (FXAA_GATHER4_ALPHA == 1)\n        // use #extension GL_ARB_gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_3 == 1)\n    #define FxaaInt2 float2\n    #define FxaaTex sampler2D\n    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_4 == 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_5 == 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n#endif\n\n\n/*============================================================================\n                   GREEN AS LUMA OPTION SUPPORT FUNCTION\n============================================================================*/\n#if (FXAA_GREEN_AS_LUMA == 0)\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n#else\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif\n\n\n\n\n/*============================================================================\n\n                             FXAA3 QUALITY - PC\n\n============================================================================*/\n#if (FXAA_PC == 1)\n/*--------------------------------------------------------------------------*/\nFxaaFloat4 FxaaPixelShader(\n    //\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = center of pixel\n    FxaaFloat2 pos,\n    //\n    // Used only for FXAA Console, and not used on the 360 version.\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy_} = upper left of pixel\n    // {_zw} = lower right of pixel\n    FxaaFloat4 fxaaConsolePosPos,\n    //\n    // Input color texture.\n    // {rgb_} = color in linear or perceptual color space\n    // if (FXAA_GREEN_AS_LUMA == 0)\n    //     {__a} = luma in perceptual color space (not linear)\n    FxaaTex tex,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for "tex".\n    // For 360, same texture, just alias with a 2nd sampler.\n    // This sampler needs to have an exponent bias of -1.\n    FxaaTex fxaaConsole360TexExpBiasNegOne,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for "tex".\n    // For 360, same texture, just alias with a 3nd sampler.\n    // This sampler needs to have an exponent bias of -2.\n    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n    //\n    // Only used on FXAA Quality.\n    // This must be from a constant/uniform.\n    // {x_} = 1.0/screenWidthInPixels\n    // {_y} = 1.0/screenHeightInPixels\n    FxaaFloat2 fxaaQualityRcpFrame,\n    //\n    // Only used on FXAA Console.\n    // This must be from a constant/uniform.\n    // This effects sub-pixel AA quality and inversely sharpness.\n    //   Where N ranges between,\n    //     N = 0.50 (default)\n    //     N = 0.33 (sharper)\n    // {x__} = -N/screenWidthInPixels\n    // {_y_} = -N/screenHeightInPixels\n    // {_z_} =  N/screenWidthInPixels\n    // {__w} =  N/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n    //\n    // Only used on FXAA Console.\n    // Not used on 360, but used on PS3 and PC.\n    // This must be from a constant/uniform.\n    // {x__} = -2.0/screenWidthInPixels\n    // {_y_} = -2.0/screenHeightInPixels\n    // {_z_} =  2.0/screenWidthInPixels\n    // {__w} =  2.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n    //\n    // Only used on FXAA Console.\n    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n    // This must be from a constant/uniform.\n    // {x__} =  8.0/screenWidthInPixels\n    // {_y_} =  8.0/screenHeightInPixels\n    // {_z_} = -4.0/screenWidthInPixels\n    // {__w} = -4.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // It is here now to allow easier tuning.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    FxaaFloat fxaaQualitySubpix,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    FxaaFloat fxaaQualityEdgeThreshold,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaQualityEdgeThresholdMin,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only three safe values here: 2 and 4 and 8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // For all other platforms can be a non-power of two.\n    //   8.0 is sharper (default!!!)\n    //   4.0 is softer\n    //   2.0 is really soft (good only for vector graphics inputs)\n    FxaaFloat fxaaConsoleEdgeSharpness,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only two safe values here: 1/4 and 1/8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // The console setting has a different mapping than the quality setting.\n    // Other platforms can use other values.\n    //   0.125 leaves less aliasing, but is softer (default!!!)\n    //   0.25 leaves more aliasing, and is sharper\n    FxaaFloat fxaaConsoleEdgeThreshold,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    // The console setting has a different mapping than the quality setting.\n    // This only applies when FXAA_EARLY_EXIT is 1.\n    // This does not apply to PS3,\n    // PS3 was simplified to avoid more shader instructions.\n    //   0.06 - faster but more aliasing in darks\n    //   0.05 - default\n    //   0.04 - slower and less aliasing in darks\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaConsoleEdgeThresholdMin,\n    //\n    // Extra constants for 360 FXAA Console only.\n    // Use zeros or anything else for other platforms.\n    // These must be in physical constant registers and NOT immediates.\n    // Immediates will result in compiler un-optimizing.\n    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n    FxaaFloat4 fxaaConsole360ConstDir\n) {\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    #if (FXAA_GATHER4_ALPHA == 1)\n        #if (FXAA_DISCARD == 0)\n            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n            #if (FXAA_GREEN_AS_LUMA == 0)\n                #define lumaM rgbyM.w\n            #else\n                #define lumaM rgbyM.y\n            #endif\n        #endif\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n        #else\n            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n        #endif\n        #if (FXAA_DISCARD == 1)\n            #define lumaM luma4A.w\n        #endif\n        #define lumaE luma4A.z\n        #define lumaS luma4A.x\n        #define lumaSE luma4A.y\n        #define lumaNW luma4B.w\n        #define lumaN luma4B.z\n        #define lumaW luma4B.x\n    #else\n        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            #define lumaM rgbyM.w\n        #else\n            #define lumaM rgbyM.y\n        #endif\n        #if (FXAA_GLSL_100 == 1)\n          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n        #else\n          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n        #endif\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n/*--------------------------------------------------------------------------*/\n    if(earlyExit)\n        #if (FXAA_DISCARD == 1)\n            FxaaDiscard;\n        #else\n            return rgbyM;\n        #endif\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_GATHER4_ALPHA == 0)\n        #if (FXAA_GLSL_100 == 1)\n          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n        #else\n          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n        #endif\n    #else\n        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n/*--------------------------------------------------------------------------*/\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n/*--------------------------------------------------------------------------*/\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n/*--------------------------------------------------------------------------*/\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n/*--------------------------------------------------------------------------*/\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n/*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n    #endif\n/*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n/*--------------------------------------------------------------------------*/\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n/*--------------------------------------------------------------------------*/\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n/*--------------------------------------------------------------------------*/\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n    #if (FXAA_DISCARD == 1)\n        return FxaaTexTop(tex, posM);\n    #else\n        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n    #endif\n}\n/*==========================================================================*/\n#endif\n\nvoid main() {\n  gl_FragColor = FxaaPixelShader(\n    vUv,\n    vec4(0.0),\n    tDiffuse,\n    tDiffuse,\n    tDiffuse,\n    resolution,\n    vec4(0.0),\n    vec4(0.0),\n    vec4(0.0),\n    0.75,\n    0.166,\n    0.0833,\n    0.0,\n    0.0,\n    0.0,\n    vec4(0.0)\n  );\n\n  // TODO avoid querying texture twice for same texel\n  gl_FragColor.a = texture2D(tDiffuse, vUv).a;\n}'};
THREE.SSAOShader = {defines:{PERSPECTIVE_CAMERA:1, KERNEL_SIZE:32}, uniforms:{tDiffuse:{value:null}, tNormal:{value:null}, tDepth:{value:null}, tNoise:{value:null}, kernel:{value:null}, cameraNear:{value:null}, cameraFar:{value:null}, resolution:{value:new THREE.Vector2}, cameraProjectionMatrix:{value:new THREE.Matrix4}, cameraInverseProjectionMatrix:{value:new THREE.Matrix4}, kernelRadius:{value:8}, minDistance:{value:.005}, maxDistance:{value:.05}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", 
fragmentShader:"uniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tDepth;\nuniform sampler2D tNoise;\nuniform vec3 kernel[ KERNEL_SIZE ];\nuniform vec2 resolution;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 cameraProjectionMatrix;\nuniform mat4 cameraInverseProjectionMatrix;\nuniform float kernelRadius;\nuniform float minDistance;\nuniform float maxDistance;\nvarying vec2 vUv;\n#include <packing>\nfloat getDepth( const in vec2 screenPosition ) {\n\treturn texture2D( tDepth, screenPosition ).x;\n}\nfloat getLinearDepth( const in vec2 screenPosition ) {\n\t#if PERSPECTIVE_CAMERA == 1\n\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\t#else\n\t\treturn texture2D( depthSampler, coord ).x;\n\t#endif\n}\nfloat getViewZ( const in float depth ) {\n\t#if PERSPECTIVE_CAMERA == 1\n\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t#else\n\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t#endif\n}\nvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\tclipPosition *= clipW; // unprojection.\n\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n}\nvec3 getViewNormal( const in vec2 screenPosition ) {\n\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n}\nvoid main() {\n\tfloat depth = getDepth( vUv );\n\tfloat viewZ = getViewZ( depth );\n\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\n\tvec3 viewNormal = getViewNormal( vUv );\n vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\n\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\n\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\n\tvec3 bitangent = cross( viewNormal, tangent );\n\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\n float occlusion = 0.0;\n for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\n\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];\n\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );\n\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\n\t\tsamplePointNDC /= samplePointNDC.w;\n\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\n\t\tfloat realDepth = getLinearDepth( samplePointUv );\n\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\n\t\tfloat delta = sampleDepth - realDepth;\n\t\tif ( delta > minDistance && delta < maxDistance ) {\n\t\t\tocclusion += 1.0;\n\t\t}\n\t}\n\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\n\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\n}"};
THREE.SSAODepthShader = {defines:{PERSPECTIVE_CAMERA:1}, uniforms:{tDepth:{value:null}, cameraNear:{value:null}, cameraFar:{value:null}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform sampler2D tDepth;\nuniform float cameraNear;\nuniform float cameraFar;\nvarying vec2 vUv;\n#include <packing>\nfloat getLinearDepth( const in vec2 screenPosition ) {\n\t#if PERSPECTIVE_CAMERA == 1\n\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\t#else\n\t\treturn texture2D( depthSampler, coord ).x;\n\t#endif\n}\nvoid main() {\n\tfloat depth = getLinearDepth( vUv );\n\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\n}"};
THREE.SSAOBlurShader = {uniforms:{tDiffuse:{value:null}, resolution:{value:new THREE.Vector2}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvoid main() {\n\tvec2 texelSize = ( 1.0 / resolution );\n\tfloat result = 0.0;\n\tfor ( int i = - 2; i <= 2; i ++ ) {\n\t\tfor ( int j = - 2; j <= 2; j ++ ) {\n\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\n\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\n\t\t}\n\t}\n\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\n}"};
THREE.FilmShader = {uniforms:{tDiffuse:{value:null}, time:{value:0}, nIntensity:{value:.5}, sIntensity:{value:.05}, sCount:{value:4096}, grayscale:{value:1}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"#include <common>\nuniform float time;\nuniform bool grayscale;\nuniform float nIntensity;\nuniform float sIntensity;\nuniform float sCount;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 cTextureScreen = texture2D( tDiffuse, vUv );\n\tfloat dx = rand( vUv + time );\n\tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\n\tvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\n\tcResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\n\tcResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\n\tif( grayscale ) {\n\t\tcResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\n\t}\n\tgl_FragColor =  vec4( cResult, cTextureScreen.a );\n}"};
THREE.DotScreenShader = {uniforms:{tDiffuse:{value:null}, tSize:{value:new THREE.Vector2(256, 256)}, center:{value:new THREE.Vector2(.5, .5)}, angle:{value:1.57}, scale:{value:1}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform vec2 center;\nuniform float angle;\nuniform float scale;\nuniform vec2 tSize;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nfloat pattern() {\n\tfloat s = sin( angle ), c = cos( angle );\n\tvec2 tex = vUv * tSize - center;\n\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\n\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;\n}\nvoid main() {\n\tvec4 color = texture2D( tDiffuse, vUv );\n\tfloat average = ( color.r + color.g + color.b ) / 3.0;\n\tgl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\n}"};
THREE.LuminosityShader = {uniforms:{tDiffuse:{value:null}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"#include <common>\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texel = texture2D( tDiffuse, vUv );\n\tfloat l = linearToRelativeLuminance( texel.rgb );\n\tgl_FragColor = vec4( l, l, l, texel.w );\n}"};
THREE.SobelOperatorShader = {uniforms:{tDiffuse:{value:null}, resolution:{value:new THREE.Vector2}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvoid main() {\n\tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );\n\tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );\n\tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );\n\tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;\n\tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;\n\tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;\n\tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;\n\tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;\n\tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;\n\tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;\n\tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;\n\tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;\n\tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + \n\t\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + \n\t\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; \n\tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + \n\t\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + \n\t\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; \n\tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );\n\tgl_FragColor = vec4( vec3( G ), 1 );\n}"};
THREE.ColorifyShader = {uniforms:{tDiffuse:{value:null}, color:{value:new THREE.Color(16777215)}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform vec3 color;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texel = texture2D( tDiffuse, vUv );\n\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\tfloat v = dot( texel.xyz, luma );\n\tgl_FragColor = vec4( v * color, texel.w );\n}"};
THREE.ToneMapShader = {uniforms:{tDiffuse:{value:null}, averageLuminance:{value:1}, luminanceMap:{value:null}, maxLuminance:{value:16}, minLuminance:{value:.01}, middleGrey:{value:.6}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"#include <common>\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nuniform float middleGrey;\nuniform float minLuminance;\nuniform float maxLuminance;\n#ifdef ADAPTED_LUMINANCE\n\tuniform sampler2D luminanceMap;\n#else\n\tuniform float averageLuminance;\n#endif\nvec3 ToneMap( vec3 vColor ) {\n\t#ifdef ADAPTED_LUMINANCE\n\t\tfloat fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;\n\t#else\n\t\tfloat fLumAvg = averageLuminance;\n\t#endif\n\tfloat fLumPixel = linearToRelativeLuminance( vColor );\n\tfloat fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );\n\tfloat fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);\n\treturn fLumCompressed * vColor;\n}\nvoid main() {\n\tvec4 texel = texture2D( tDiffuse, vUv );\n\tgl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );\n}"};
THREE.TechnicolorShader = {uniforms:{tDiffuse:{value:null}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );\n\tvec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);\n\tgl_FragColor = newTex;\n}"};
THREE.HueSaturationShader = {uniforms:{tDiffuse:{value:null}, hue:{value:0}, saturation:{value:0}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform sampler2D tDiffuse;\nuniform float hue;\nuniform float saturation;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( tDiffuse, vUv );\n\tfloat angle = hue * 3.14159265;\n\tfloat s = sin(angle), c = cos(angle);\n\tvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\n\tfloat len = length(gl_FragColor.rgb);\n\tgl_FragColor.rgb = vec3(\n\t\tdot(gl_FragColor.rgb, weights.xyz),\n\t\tdot(gl_FragColor.rgb, weights.zxy),\n\t\tdot(gl_FragColor.rgb, weights.yzx)\n\t);\n\tfloat average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\n\tif (saturation > 0.0) {\n\t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\n\t} else {\n\t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);\n\t}\n}"};
THREE.EffectComposer = function(a, d) {
  this.renderer = a;
  if (void 0 === d) {
    d = {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBAFormat, stencilBuffer:!1};
    var g = a.getSize(new THREE.Vector2);
    this._pixelRatio = a.getPixelRatio();
    this._width = g.width;
    this._height = g.height;
    d = new THREE.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, d);
    d.texture.name = "EffectComposer.rt1";
  } else {
    this._pixelRatio = 1, this._width = d.width, this._height = d.height;
  }
  this.renderTarget1 = d;
  this.renderTarget2 = d.clone();
  this.renderTarget2.texture.name = "EffectComposer.rt2";
  this.writeBuffer = this.renderTarget1;
  this.readBuffer = this.renderTarget2;
  this.renderToScreen = !0;
  this.passes = [];
  void 0 === THREE.CopyShader && console.error("THREE.EffectComposer relies on THREE.CopyShader");
  void 0 === THREE.ShaderPass && console.error("THREE.EffectComposer relies on THREE.ShaderPass");
  this.copyPass = new THREE.ShaderPass(THREE.CopyShader);
  this.clock = new THREE.Clock;
};
Object.assign(THREE.EffectComposer.prototype, {swapBuffers:function() {
  var a = this.readBuffer;
  this.readBuffer = this.writeBuffer;
  this.writeBuffer = a;
}, addPass:function(a) {
  this.passes.push(a);
  a.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
}, insertPass:function(a, d) {
  this.passes.splice(d, 0, a);
}, isLastEnabledPass:function(a) {
  for (a += 1; a < this.passes.length; a++) {
    if (this.passes[a].enabled) {
      return !1;
    }
  }
  return !0;
}, render:function(a) {
  void 0 === a && (a = this.clock.getDelta());
  var d = this.renderer.getRenderTarget(), g = !1, h, e = this.passes.length;
  for (h = 0; h < e; h++) {
    var k = this.passes[h];
    if (!1 !== k.enabled) {
      k.renderToScreen = this.renderToScreen && this.isLastEnabledPass(h);
      k.render(this.renderer, this.writeBuffer, this.readBuffer, a, g);
      if (k.needsSwap) {
        if (g) {
          var c = this.renderer.getContext(), p = this.renderer.state.buffers.stencil;
          p.setFunc(c.NOTEQUAL, 1, 4294967295);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, a);
          p.setFunc(c.EQUAL, 1, 4294967295);
        }
        this.swapBuffers();
      }
      void 0 !== THREE.MaskPass && (k instanceof THREE.MaskPass ? g = !0 : k instanceof THREE.ClearMaskPass && (g = !1));
    }
  }
  this.renderer.setRenderTarget(d);
}, reset:function(a) {
  void 0 === a && (a = this.renderer.getSize(new THREE.Vector2), this._pixelRatio = this.renderer.getPixelRatio(), this._width = a.width, this._height = a.height, a = this.renderTarget1.clone(), a.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio));
  this.renderTarget1.dispose();
  this.renderTarget2.dispose();
  this.renderTarget1 = a;
  this.renderTarget2 = a.clone();
  this.writeBuffer = this.renderTarget1;
  this.readBuffer = this.renderTarget2;
}, setSize:function(a, d) {
  this._width = a;
  this._height = d;
  a = this._width * this._pixelRatio;
  d = this._height * this._pixelRatio;
  this.renderTarget1.setSize(a, d);
  this.renderTarget2.setSize(a, d);
  for (var g = 0; g < this.passes.length; g++) {
    this.passes[g].setSize(a, d);
  }
}, setPixelRatio:function(a) {
  this._pixelRatio = a;
  this.setSize(this._width, this._height);
}});
THREE.Pass = function() {
  this.needsSwap = this.enabled = !0;
  this.renderToScreen = this.clear = !1;
};
Object.assign(THREE.Pass.prototype, {setSize:function() {
}, render:function() {
  console.error("THREE.Pass: .render() must be implemented in derived pass.");
}});
THREE.Pass.FullScreenQuad = function() {
  var a = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), d = new THREE.PlaneBufferGeometry(2, 2), g = function(a) {
    this._mesh = new THREE.Mesh(d, a);
  };
  Object.defineProperty(g.prototype, "material", {get:function() {
    return this._mesh.material;
  }, set:function(a) {
    this._mesh.material = a;
  }});
  Object.assign(g.prototype, {dispose:function() {
    this._mesh.geometry.dispose();
  }, render:function(d) {
    d.render(this._mesh, a);
  }});
  return g;
}();
THREE.RenderPass = function(a, d, g, h, e) {
  THREE.Pass.call(this);
  this.scene = a;
  this.camera = d;
  this.overrideMaterial = g;
  this.clearColor = h;
  this.clearAlpha = void 0 !== e ? e : 0;
  this.clear = !0;
  this.needsSwap = this.clearDepth = !1;
};
THREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {constructor:THREE.RenderPass, render:function(a, d, g) {
  d = a.autoClear;
  a.autoClear = !1;
  if (void 0 !== this.overrideMaterial) {
    var h = this.scene.overrideMaterial;
    this.scene.overrideMaterial = this.overrideMaterial;
  }
  if (this.clearColor) {
    var e = a.getClearColor().getHex();
    var k = a.getClearAlpha();
    a.setClearColor(this.clearColor, this.clearAlpha);
  }
  this.clearDepth && a.clearDepth();
  a.setRenderTarget(this.renderToScreen ? null : g);
  this.clear && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil);
  a.render(this.scene, this.camera);
  this.clearColor && a.setClearColor(e, k);
  void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = h);
  a.autoClear = d;
}});
THREE.ShaderPass = function(a, d) {
  THREE.Pass.call(this);
  this.textureID = void 0 !== d ? d : "tDiffuse";
  a instanceof THREE.ShaderMaterial ? (this.uniforms = a.uniforms, this.material = a) : a && (this.uniforms = THREE.UniformsUtils.clone(a.uniforms), this.material = new THREE.ShaderMaterial({defines:Object.assign({}, a.defines), uniforms:this.uniforms, vertexShader:a.vertexShader, fragmentShader:a.fragmentShader}));
  this.fsQuad = new THREE.Pass.FullScreenQuad(this.material);
};
THREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {constructor:THREE.ShaderPass, render:function(a, d, g) {
  this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = g.texture);
  this.fsQuad.material = this.material;
  this.renderToScreen ? a.setRenderTarget(null) : (a.setRenderTarget(d), this.clear && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil));
  this.fsQuad.render(a);
}});
THREE.MaskPass = function(a, d) {
  THREE.Pass.call(this);
  this.scene = a;
  this.camera = d;
  this.clear = !0;
  this.inverse = this.needsSwap = !1;
};
THREE.MaskPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {constructor:THREE.MaskPass, render:function(a, d, g) {
  var h = a.getContext(), e = a.state;
  e.buffers.color.setMask(!1);
  e.buffers.depth.setMask(!1);
  e.buffers.color.setLocked(!0);
  e.buffers.depth.setLocked(!0);
  if (this.inverse) {
    var k = 0;
    var c = 1;
  } else {
    k = 1, c = 0;
  }
  e.buffers.stencil.setTest(!0);
  e.buffers.stencil.setOp(h.REPLACE, h.REPLACE, h.REPLACE);
  e.buffers.stencil.setFunc(h.ALWAYS, k, 4294967295);
  e.buffers.stencil.setClear(c);
  e.buffers.stencil.setLocked(!0);
  a.setRenderTarget(g);
  this.clear && a.clear();
  a.render(this.scene, this.camera);
  a.setRenderTarget(d);
  this.clear && a.clear();
  a.render(this.scene, this.camera);
  e.buffers.color.setLocked(!1);
  e.buffers.depth.setLocked(!1);
  e.buffers.stencil.setLocked(!1);
  e.buffers.stencil.setFunc(h.EQUAL, 1, 4294967295);
  e.buffers.stencil.setOp(h.KEEP, h.KEEP, h.KEEP);
  e.buffers.stencil.setLocked(!0);
}});
THREE.ClearMaskPass = function() {
  THREE.Pass.call(this);
  this.needsSwap = !1;
};
THREE.ClearMaskPass.prototype = Object.create(THREE.Pass.prototype);
Object.assign(THREE.ClearMaskPass.prototype, {render:function(a) {
  a.state.buffers.stencil.setLocked(!1);
  a.state.buffers.stencil.setTest(!1);
}});
THREE.LightProbeGenerator = {fromCubeTexture:function(a) {
  for (var d, g, h = 0, e = new THREE.Vector3, k = new THREE.Vector3, c = new THREE.Color, p = [0, 0, 0, 0, 0, 0, 0, 0, 0], t = new THREE.SphericalHarmonics3, f = t.coefficients, n = 0; 6 > n; n++) {
    var b = a.image[n], m = b.width, q = b.height, y = document.createElement("canvas");
    y.width = m;
    y.height = q;
    y = y.getContext("2d");
    y.drawImage(b, 0, 0, m, q);
    m = y.getImageData(0, 0, m, q);
    b = m.data;
    m = m.width;
    q = 2 / m;
    y = 0;
    for (var x = b.length; y < x; y += 4) {
      c.setRGB(b[y] / 255, b[y + 1] / 255, b[y + 2] / 255);
      convertColorToLinear(c, a.encoding);
      g = y / 4;
      d = -1 + (g % m + .5) * q;
      g = 1 - (Math.floor(g / m) + .5) * q;
      switch(n) {
        case 0:
          e.set(-1, g, -d);
          break;
        case 1:
          e.set(1, g, d);
          break;
        case 2:
          e.set(-d, 1, -g);
          break;
        case 3:
          e.set(-d, -1, g);
          break;
        case 4:
          e.set(-d, g, 1);
          break;
        case 5:
          e.set(d, g, -1);
      }
      d = e.lengthSq();
      g = 4 / (Math.sqrt(d) * d);
      h += g;
      k.copy(e).normalize();
      THREE.SphericalHarmonics3.getBasisAt(k, p);
      for (d = 0; 9 > d; d++) {
        f[d].x += p[d] * c.r * g, f[d].y += p[d] * c.g * g, f[d].z += p[d] * c.b * g;
      }
    }
  }
  a = 4 * Math.PI / h;
  for (d = 0; 9 > d; d++) {
    f[d].x *= a, f[d].y *= a, f[d].z *= a;
  }
  return new THREE.LightProbe(t);
}, fromCubeRenderTarget:function(a, d) {
  for (var g, h, e = 0, k = new THREE.Vector3, c = new THREE.Vector3, p = new THREE.Color, t = [0, 0, 0, 0, 0, 0, 0, 0, 0], f = new THREE.SphericalHarmonics3, n = f.coefficients, b = 0; 6 > b; b++) {
    var m = d.width, q = new Uint8Array(m * m * 4);
    a.readRenderTargetPixels(d, 0, 0, m, m, q, b);
    for (var y = 2 / m, x = 0, z = q.length; x < z; x += 4) {
      p.setRGB(q[x] / 255, q[x + 1] / 255, q[x + 2] / 255);
      convertColorToLinear(p, d.texture.encoding);
      h = x / 4;
      g = -1 + (h % m + .5) * y;
      h = 1 - (Math.floor(h / m) + .5) * y;
      switch(b) {
        case 0:
          k.set(1, h, -g);
          break;
        case 1:
          k.set(-1, h, g);
          break;
        case 2:
          k.set(g, 1, -h);
          break;
        case 3:
          k.set(g, -1, h);
          break;
        case 4:
          k.set(g, h, 1);
          break;
        case 5:
          k.set(-g, h, -1);
      }
      g = k.lengthSq();
      h = 4 / (Math.sqrt(g) * g);
      e += h;
      c.copy(k).normalize();
      THREE.SphericalHarmonics3.getBasisAt(c, t);
      for (g = 0; 9 > g; g++) {
        n[g].x += t[g] * p.r * h, n[g].y += t[g] * p.g * h, n[g].z += t[g] * p.b * h;
      }
    }
  }
  a = 4 * Math.PI / e;
  for (g = 0; 9 > g; g++) {
    n[g].x *= a, n[g].y *= a, n[g].z *= a;
  }
  return new THREE.LightProbe(f);
}};
var convertColorToLinear = function(a, d) {
  switch(d) {
    case THREE.sRGBEncoding:
      a.convertSRGBToLinear();
      break;
    case THREE.LinearEncoding:
      break;
    default:
      console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.");
  }
  return a;
};
THREE.NURBSCurve = function(a, d, g, h, e) {
  THREE.Curve.call(this);
  this.degree = a;
  this.knots = d;
  this.controlPoints = [];
  this.startKnot = h || 0;
  this.endKnot = e || this.knots.length - 1;
  for (a = 0; a < g.length; ++a) {
    d = g[a], this.controlPoints[a] = new THREE.Vector4(d.x, d.y, d.z, d.w);
  }
};
THREE.NURBSCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.NURBSCurve.prototype.constructor = THREE.NURBSCurve;
THREE.NURBSCurve.prototype.getPoint = function(a, d) {
  d = d || new THREE.Vector3;
  a = THREE.NURBSUtils.calcBSplinePoint(this.degree, this.knots, this.controlPoints, this.knots[this.startKnot] + a * (this.knots[this.endKnot] - this.knots[this.startKnot]));
  1 != a.w && a.divideScalar(a.w);
  return d.set(a.x, a.y, a.z);
};
THREE.NURBSCurve.prototype.getTangent = function(a, d) {
  d = d || new THREE.Vector3;
  a = THREE.NURBSUtils.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, this.knots[0] + a * (this.knots[this.knots.length - 1] - this.knots[0]), 1);
  d.copy(a[1]).normalize();
  return d;
};
THREE.NURBSSurface = function(a, d, g, h, e) {
  this.degree1 = a;
  this.degree2 = d;
  this.knots1 = g;
  this.knots2 = h;
  this.controlPoints = [];
  a = g.length - a - 1;
  d = h.length - d - 1;
  for (h = 0; h < a; ++h) {
    for (this.controlPoints[h] = [], g = 0; g < d; ++g) {
      var k = e[h][g];
      this.controlPoints[h][g] = new THREE.Vector4(k.x, k.y, k.z, k.w);
    }
  }
};
THREE.NURBSSurface.prototype = {constructor:THREE.NURBSSurface, getPoint:function(a, d, g) {
  THREE.NURBSUtils.calcSurfacePoint(this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, this.knots1[0] + a * (this.knots1[this.knots1.length - 1] - this.knots1[0]), this.knots2[0] + d * (this.knots2[this.knots2.length - 1] - this.knots2[0]), g);
}};
THREE.NURBSUtils = {findSpan:function(a, d, g) {
  var h = g.length - a - 1;
  if (d >= g[h]) {
    return h - 1;
  }
  if (d <= g[a]) {
    return a;
  }
  for (var e = Math.floor((a + h) / 2); d < g[e] || d >= g[e + 1];) {
    d < g[e] ? h = e : a = e, e = Math.floor((a + h) / 2);
  }
  return e;
}, calcBasisFunctions:function(a, d, g, h) {
  for (var e = [], k = [], c = [], p = e[0] = 1; p <= g; ++p) {
    k[p] = d - h[a + 1 - p];
    c[p] = h[a + p] - d;
    for (var t = 0, f = 0; f < p; ++f) {
      var n = c[f + 1], b = k[p - f], m = e[f] / (n + b);
      e[f] = t + n * m;
      t = b * m;
    }
    e[p] = t;
  }
  return e;
}, calcBSplinePoint:function(a, d, g, h) {
  var e = this.findSpan(a, h, d);
  d = this.calcBasisFunctions(e, h, a, d);
  h = new THREE.Vector4(0, 0, 0, 0);
  for (var k = 0; k <= a; ++k) {
    var c = g[e - a + k], p = d[k], t = c.w * p;
    h.x += c.x * t;
    h.y += c.y * t;
    h.z += c.z * t;
    h.w += c.w * p;
  }
  return h;
}, calcBasisFunctionDerivatives:function(a, d, g, h, e) {
  for (var k = [], c = 0; c <= g; ++c) {
    k[c] = 0;
  }
  var p = [];
  for (c = 0; c <= h; ++c) {
    p[c] = k.slice(0);
  }
  var t = [];
  for (c = 0; c <= g; ++c) {
    t[c] = k.slice(0);
  }
  t[0][0] = 1;
  var f = k.slice(0), n = k.slice(0);
  for (c = 1; c <= g; ++c) {
    f[c] = d - e[a + 1 - c];
    n[c] = e[a + c] - d;
    for (var b = 0, m = 0; m < c; ++m) {
      var q = n[m + 1], y = f[c - m];
      t[c][m] = q + y;
      var x = t[m][c - 1] / t[c][m];
      t[m][c] = b + q * x;
      b = y * x;
    }
    t[c][c] = b;
  }
  for (c = 0; c <= g; ++c) {
    p[0][c] = t[c][g];
  }
  for (m = 0; m <= g; ++m) {
    a = 0;
    d = 1;
    e = [];
    for (c = 0; c <= g; ++c) {
      e[c] = k.slice(0);
    }
    for (f = e[0][0] = 1; f <= h; ++f) {
      n = 0;
      b = m - f;
      q = g - f;
      m >= f && (e[d][0] = e[a][0] / t[q + 1][b], n = e[d][0] * t[b][q]);
      y = m - 1 <= q ? f - 1 : g - m;
      for (c = -1 <= b ? 1 : -b; c <= y; ++c) {
        e[d][c] = (e[a][c] - e[a][c - 1]) / t[q + 1][b + c], n += e[d][c] * t[b + c][q];
      }
      m <= q && (e[d][f] = -e[a][f - 1] / t[q + 1][m], n += e[d][f] * t[m][q]);
      p[f][m] = n;
      c = a;
      a = d;
      d = c;
    }
  }
  m = g;
  for (f = 1; f <= h; ++f) {
    for (c = 0; c <= g; ++c) {
      p[f][c] *= m;
    }
    m *= g - f;
  }
  return p;
}, calcBSplineDerivatives:function(a, d, g, h, e) {
  var k = e < a ? e : a, c = [], p = this.findSpan(a, h, d);
  d = this.calcBasisFunctionDerivatives(p, h, a, k, d);
  h = [];
  for (var t = 0; t < g.length; ++t) {
    var f = g[t].clone(), n = f.w;
    f.x *= n;
    f.y *= n;
    f.z *= n;
    h[t] = f;
  }
  for (g = 0; g <= k; ++g) {
    f = h[p - a].clone().multiplyScalar(d[g][0]);
    for (t = 1; t <= a; ++t) {
      f.add(h[p - a + t].clone().multiplyScalar(d[g][t]));
    }
    c[g] = f;
  }
  for (g = k + 1; g <= e + 1; ++g) {
    c[g] = new THREE.Vector4(0, 0, 0);
  }
  return c;
}, calcKoverI:function(a, d) {
  for (var g = 1, h = 2; h <= a; ++h) {
    g *= h;
  }
  var e = 1;
  for (h = 2; h <= d; ++h) {
    e *= h;
  }
  for (h = 2; h <= a - d; ++h) {
    e *= h;
  }
  return g / e;
}, calcRationalCurveDerivatives:function(a) {
  for (var d = a.length, g = [], h = [], e = 0; e < d; ++e) {
    var k = a[e];
    g[e] = new THREE.Vector3(k.x, k.y, k.z);
    h[e] = k.w;
  }
  a = [];
  for (k = 0; k < d; ++k) {
    var c = g[k].clone();
    for (e = 1; e <= k; ++e) {
      c.sub(a[k - e].clone().multiplyScalar(this.calcKoverI(k, e) * h[e]));
    }
    a[k] = c.divideScalar(h[0]);
  }
  return a;
}, calcNURBSDerivatives:function(a, d, g, h, e) {
  a = this.calcBSplineDerivatives(a, d, g, h, e);
  return this.calcRationalCurveDerivatives(a);
}, calcSurfacePoint:function(a, d, g, h, e, k, c, p) {
  var t = this.findSpan(a, k, g), f = this.findSpan(d, c, h);
  g = this.calcBasisFunctions(t, k, a, g);
  h = this.calcBasisFunctions(f, c, d, h);
  c = [];
  for (k = 0; k <= d; ++k) {
    c[k] = new THREE.Vector4(0, 0, 0, 0);
    for (var n = 0; n <= a; ++n) {
      var b = e[t - a + n][f - d + k].clone(), m = b.w;
      b.x *= m;
      b.y *= m;
      b.z *= m;
      c[k].add(b.multiplyScalar(g[n]));
    }
  }
  a = new THREE.Vector4(0, 0, 0, 0);
  for (k = 0; k <= d; ++k) {
    a.add(c[k].multiplyScalar(h[k]));
  }
  a.divideScalar(a.w);
  p.set(a.x, a.y, a.z);
}};
THREE.Lensflare = function() {
  THREE.Mesh.call(this, THREE.Lensflare.Geometry, new THREE.MeshBasicMaterial({opacity:0, transparent:!0}));
  this.type = "Lensflare";
  this.frustumCulled = !1;
  this.renderOrder = Infinity;
  var a = new THREE.Vector3, d = new THREE.DataTexture(new Uint8Array(768), 16, 16, THREE.RGBFormat);
  d.minFilter = THREE.NearestFilter;
  d.magFilter = THREE.NearestFilter;
  d.wrapS = THREE.ClampToEdgeWrapping;
  d.wrapT = THREE.ClampToEdgeWrapping;
  d.needsUpdate = !0;
  var g = new THREE.DataTexture(new Uint8Array(768), 16, 16, THREE.RGBFormat);
  g.minFilter = THREE.NearestFilter;
  g.magFilter = THREE.NearestFilter;
  g.wrapS = THREE.ClampToEdgeWrapping;
  g.wrapT = THREE.ClampToEdgeWrapping;
  g.needsUpdate = !0;
  var h = THREE.Lensflare.Geometry, e = new THREE.RawShaderMaterial({uniforms:{scale:{value:null}, screenPosition:{value:null}}, vertexShader:"precision highp float;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nattribute vec3 position;\nvoid main() {\n\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n}", fragmentShader:"precision highp float;\nvoid main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n}", depthTest:!0, depthWrite:!1, transparent:!1}), 
  k = new THREE.RawShaderMaterial({uniforms:{map:{value:d}, scale:{value:null}, screenPosition:{value:null}}, vertexShader:"precision highp float;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\n\tvUV = uv;\n\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n}", fragmentShader:"precision highp float;\nuniform sampler2D map;\nvarying vec2 vUV;\nvoid main() {\n\tgl_FragColor = texture2D( map, vUV );\n}", 
  depthTest:!1, depthWrite:!1, transparent:!1}), c = new THREE.Mesh(h, e), p = [], t = THREE.LensflareElement.Shader, f = new THREE.RawShaderMaterial({uniforms:{map:{value:null}, occlusionMap:{value:g}, color:{value:new THREE.Color(16777215)}, scale:{value:new THREE.Vector2}, screenPosition:{value:new THREE.Vector3}}, vertexShader:t.vertexShader, fragmentShader:t.fragmentShader, blending:THREE.AdditiveBlending, transparent:!0, depthWrite:!1}), n = new THREE.Mesh(h, f);
  this.addElement = function(a) {
    p.push(a);
  };
  var b = new THREE.Vector2, m = new THREE.Vector2, q = new THREE.Box2, y = new THREE.Vector4;
  this.onBeforeRender = function(t, z, r) {
    y.copy(t.getCurrentViewport());
    z = y.w / y.z;
    var u = y.z / 2, v = y.w / 2, x = 16 / y.w;
    b.set(x * z, x);
    q.min.set(y.x, y.y);
    q.max.set(y.x + (y.z - 16), y.y + (y.w - 16));
    a.setFromMatrixPosition(this.matrixWorld);
    a.applyMatrix4(r.matrixWorldInverse);
    a.applyMatrix4(r.projectionMatrix);
    m.x = y.x + a.x * u + u - 8;
    m.y = y.y + a.y * v + v - 8;
    if (q.containsPoint(m)) {
      t.copyFramebufferToTexture(m, d);
      u = e.uniforms;
      u.scale.value = b;
      u.screenPosition.value = a;
      t.renderBufferDirect(r, null, h, e, c, null);
      t.copyFramebufferToTexture(m, g);
      u = k.uniforms;
      u.scale.value = b;
      u.screenPosition.value = a;
      t.renderBufferDirect(r, null, h, k, c, null);
      v = 2 * -a.x;
      for (var A = 2 * -a.y, D = 0, F = p.length; D < F; D++) {
        z = p[D], u = f.uniforms, u.color.value.copy(z.color), u.map.value = z.texture, u.screenPosition.value.x = a.x + v * z.distance, u.screenPosition.value.y = a.y + A * z.distance, x = z.size / y.w, z = y.w / y.z, u.scale.value.set(x * z, x), f.uniformsNeedUpdate = !0, t.renderBufferDirect(r, null, h, f, n, null);
      }
    }
  };
  this.dispose = function() {
    e.dispose();
    k.dispose();
    f.dispose();
    d.dispose();
    g.dispose();
    for (var a = 0, b = p.length; a < b; a++) {
      p[a].texture.dispose();
    }
  };
};
THREE.Lensflare.prototype = Object.create(THREE.Mesh.prototype);
THREE.Lensflare.prototype.constructor = THREE.Lensflare;
THREE.Lensflare.prototype.isLensflare = !0;
THREE.LensflareElement = function(a, d, g, h) {
  this.texture = a;
  this.size = d || 1;
  this.distance = g || 0;
  this.color = h || new THREE.Color(16777215);
};
THREE.LensflareElement.Shader = {uniforms:{map:{value:null}, occlusionMap:{value:null}, color:{value:null}, scale:{value:null}, screenPosition:{value:null}}, vertexShader:"precision highp float;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform sampler2D occlusionMap;\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\n\tvUV = uv;\n\tvec2 pos = position.xy;\n\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\tvVisibility =        visibility.r / 9.0;\n\tvVisibility *= 1.0 - visibility.g / 9.0;\n\tvVisibility *=       visibility.b / 9.0;\n\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}", 
fragmentShader:"precision highp float;\nuniform sampler2D map;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\n\tvec4 texture = texture2D( map, vUV );\n\ttexture.a *= vVisibility;\n\tgl_FragColor = texture;\n\tgl_FragColor.rgb *= color;\n}"};
THREE.Lensflare.Geometry = function() {
  var a = new THREE.BufferGeometry, d = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);
  d = new THREE.InterleavedBuffer(d, 5);
  a.setIndex([0, 1, 2, 0, 2, 3]);
  a.setAttribute("position", new THREE.InterleavedBufferAttribute(d, 3, 0, !1));
  a.setAttribute("uv", new THREE.InterleavedBufferAttribute(d, 2, 3, !1));
  return a;
}();
THREE.TTFLoader = function(a) {
  THREE.Loader.call(this, a);
  this.reversed = !1;
};
THREE.TTFLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {constructor:THREE.TTFLoader, load:function(a, d, g, h) {
  var e = this, k = new THREE.FileLoader(this.manager);
  k.setPath(this.path);
  k.setResponseType("arraybuffer");
  k.load(a, function(a) {
    d(e.parse(a));
  }, g, h);
}, parse:function(a) {
  function d(a) {
    var d = [], e;
    a.forEach(function(a) {
      "m" === a.type.toLowerCase() ? (e = [a], d.push(e)) : "z" !== a.type.toLowerCase() && e.push(a);
    });
    var k = [];
    d.forEach(function(a) {
      var c = {type:"m", x:a[a.length - 1].x, y:a[a.length - 1].y};
      k.push(c);
      for (var e = a.length - 1; 0 < e; e--) {
        var d = a[e];
        c = {type:d.type};
        void 0 !== d.x2 && void 0 !== d.y2 ? (c.x1 = d.x2, c.y1 = d.y2, c.x2 = d.x1, c.y2 = d.y1) : void 0 !== d.x1 && void 0 !== d.y1 && (c.x1 = d.x1, c.y1 = d.y1);
        c.x = a[e - 1].x;
        c.y = a[e - 1].y;
        k.push(c);
      }
    });
    return k;
  }
  return "undefined" === typeof opentype ? (console.warn("THREE.TTFLoader: The loader requires opentype.js. Make sure it's included before using the loader."), null) : function(a, h) {
    for (var e = Math.round, k = {}, c = 1E5 / (72 * (a.unitsPerEm || 2048)), g = a.encoding.cmap.glyphIndexMap, t = Object.keys(g), f = 0; f < t.length; f++) {
      var n = t[f], b = a.glyphs.glyphs[g[n]];
      if (void 0 !== n) {
        var m = {ha:e(b.advanceWidth * c), x_min:e(b.xMin * c), x_max:e(b.xMax * c), o:""};
        h && (b.path.commands = d(b.path.commands));
        b.path.commands.forEach(function(a) {
          "c" === a.type.toLowerCase() && (a.type = "b");
          m.o += a.type.toLowerCase() + " ";
          void 0 !== a.x && void 0 !== a.y && (m.o += e(a.x * c) + " " + e(a.y * c) + " ");
          void 0 !== a.x1 && void 0 !== a.y1 && (m.o += e(a.x1 * c) + " " + e(a.y1 * c) + " ");
          void 0 !== a.x2 && void 0 !== a.y2 && (m.o += e(a.x2 * c) + " " + e(a.y2 * c) + " ");
        });
        k[String.fromCodePoint(b.unicode)] = m;
      }
    }
    return {glyphs:k, familyName:a.getEnglishName("fullName"), ascender:e(a.ascender * c), descender:e(a.descender * c), underlinePosition:a.tables.post.underlinePosition, underlineThickness:a.tables.post.underlineThickness, boundingBox:{xMin:a.tables.head.xMin, xMax:a.tables.head.xMax, yMin:a.tables.head.yMin, yMax:a.tables.head.yMax}, resolution:1E3, original_font_information:a.tables.name};
  }(opentype.parse(a), this.reversed);
}});
(function(a, d) {
  if ("function" === typeof define && define.amd) {
    define(["long"], d);
  } else {
    if ("function" === typeof require && "object" === typeof module && module && module.exports) {
      a = module;
      try {
        var g = require("long");
      } catch (h) {
      }
      g = d(g);
      a.exports = g;
    } else {
      (a.dcodeIO = a.dcodeIO || {}).ByteBuffer = d(a.dcodeIO.Long);
    }
  }
})(this, function(a) {
  function d(a) {
    var b = 0;
    return function() {
      return b < a.length ? a.charCodeAt(b++) : null;
    };
  }
  function g() {
    var a = [], c = [];
    return function() {
      if (0 === arguments.length) {
        return c.join("") + t.apply(String, a);
      }
      1024 < a.length + arguments.length && (c.push(t.apply(String, a)), a.length = 0);
      Array.prototype.push.apply(a, arguments);
    };
  }
  function h(a, c, e, d, f) {
    var b = 8 * f - d - 1;
    var m = (1 << b) - 1, k = m >> 1, h = -7;
    f = e ? f - 1 : 0;
    var g = e ? -1 : 1, n = a[c + f];
    f += g;
    e = n & (1 << -h) - 1;
    n >>= -h;
    for (h += b; 0 < h; e = 256 * e + a[c + f], f += g, h -= 8) {
    }
    b = e & (1 << -h) - 1;
    e >>= -h;
    for (h += d; 0 < h; b = 256 * b + a[c + f], f += g, h -= 8) {
    }
    if (0 === e) {
      e = 1 - k;
    } else {
      if (e === m) {
        return b ? NaN : Infinity * (n ? -1 : 1);
      }
      b += Math.pow(2, d);
      e -= k;
    }
    return (n ? -1 : 1) * b * Math.pow(2, e - d);
  }
  function e(a, c, e, d, f, k) {
    var b, m = 8 * k - f - 1, h = (1 << m) - 1, g = h >> 1, n = 23 === f ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    k = d ? 0 : k - 1;
    var q = d ? 1 : -1, p = 0 > c || 0 === c && 0 > 1 / c ? 1 : 0;
    c = Math.abs(c);
    for (isNaN(c) || Infinity === c ? (c = isNaN(c) ? 1 : 0, d = h) : (d = Math.floor(Math.log(c) / Math.LN2), 1 > c * (b = Math.pow(2, -d)) && (d--, b *= 2), c = 1 <= d + g ? c + n / b : c + n * Math.pow(2, 1 - g), 2 <= c * b && (d++, b /= 2), d + g >= h ? (c = 0, d = h) : 1 <= d + g ? (c = (c * b - 1) * Math.pow(2, f), d += g) : (c = c * Math.pow(2, g - 1) * Math.pow(2, f), d = 0)); 8 <= f; a[e + k] = c & 255, k += q, c /= 256, f -= 8) {
    }
    d = d << f | c;
    for (m += f; 0 < m; a[e + k] = d & 255, k += q, d /= 256, m -= 8) {
    }
    a[e + k - q] |= 128 * p;
  }
  var k = function(a, c, e) {
    "undefined" === typeof a && (a = k.DEFAULT_CAPACITY);
    "undefined" === typeof c && (c = k.DEFAULT_ENDIAN);
    "undefined" === typeof e && (e = k.DEFAULT_NOASSERT);
    if (!e) {
      a |= 0;
      if (0 > a) {
        throw RangeError("Illegal capacity");
      }
      c = !!c;
      e = !!e;
    }
    this.buffer = 0 === a ? p : new ArrayBuffer(a);
    this.view = 0 === a ? null : new Uint8Array(this.buffer);
    this.offset = 0;
    this.markedOffset = -1;
    this.limit = a;
    this.littleEndian = c;
    this.noAssert = e;
  };
  k.VERSION = "5.0.1";
  k.LITTLE_ENDIAN = !0;
  k.BIG_ENDIAN = !1;
  k.DEFAULT_CAPACITY = 16;
  k.DEFAULT_ENDIAN = k.BIG_ENDIAN;
  k.DEFAULT_NOASSERT = !1;
  k.Long = a || null;
  var c = k.prototype;
  Object.defineProperty(c, "__isByteBuffer__", {value:!0, enumerable:!1, configurable:!1});
  var p = new ArrayBuffer(0), t = String.fromCharCode;
  k.accessor = function() {
    return Uint8Array;
  };
  k.allocate = function(a, c, e) {
    return new k(a, c, e);
  };
  k.concat = function(a, c, e, d) {
    if ("boolean" === typeof c || "string" !== typeof c) {
      d = e, e = c, c = void 0;
    }
    for (var b = 0, m = 0, f = a.length, h; m < f; ++m) {
      k.isByteBuffer(a[m]) || (a[m] = k.wrap(a[m], c)), h = a[m].limit - a[m].offset, 0 < h && (b += h);
    }
    if (0 === b) {
      return new k(0, e, d);
    }
    c = new k(b, e, d);
    for (m = 0; m < f;) {
      e = a[m++], h = e.limit - e.offset, 0 >= h || (c.view.set(e.view.subarray(e.offset, e.limit), c.offset), c.offset += h);
    }
    c.limit = c.offset;
    c.offset = 0;
    return c;
  };
  k.isByteBuffer = function(a) {
    return !0 === (a && a.__isByteBuffer__);
  };
  k.type = function() {
    return ArrayBuffer;
  };
  k.wrap = function(a, e, d, f) {
    "string" !== typeof e && (f = d, d = e, e = void 0);
    if ("string" === typeof a) {
      switch("undefined" === typeof e && (e = "utf8"), e) {
        case "base64":
          return k.fromBase64(a, d);
        case "hex":
          return k.fromHex(a, d);
        case "binary":
          return k.fromBinary(a, d);
        case "utf8":
          return k.fromUTF8(a, d);
        case "debug":
          return k.fromDebug(a, d);
        default:
          throw Error("Unsupported encoding: " + e);
      }
    }
    if (null === a || "object" !== typeof a) {
      throw TypeError("Illegal buffer");
    }
    if (k.isByteBuffer(a)) {
      return e = c.clone.call(a), e.markedOffset = -1, e;
    }
    if (a instanceof Uint8Array) {
      e = new k(0, d, f), 0 < a.length && (e.buffer = a.buffer, e.offset = a.byteOffset, e.limit = a.byteOffset + a.byteLength, e.view = new Uint8Array(a.buffer));
    } else {
      if (a instanceof ArrayBuffer) {
        e = new k(0, d, f), 0 < a.byteLength && (e.buffer = a, e.offset = 0, e.limit = a.byteLength, e.view = 0 < a.byteLength ? new Uint8Array(a) : null);
      } else {
        if ("[object Array]" === Object.prototype.toString.call(a)) {
          for (e = new k(a.length, d, f), e.limit = a.length, d = 0; d < a.length; ++d) {
            e.view[d] = a[d];
          }
        } else {
          throw TypeError("Illegal buffer");
        }
      }
    }
    return e;
  };
  c.writeBitSet = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    if (!this.noAssert) {
      if (!(a instanceof Array)) {
        throw TypeError("Illegal BitSet: Not an array");
      }
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    var e = c, d = a.length, m = d >> 3, f = 0;
    for (c += this.writeVarint32(d, c); m--;) {
      var k = !!a[f++] & 1 | (!!a[f++] & 1) << 1 | (!!a[f++] & 1) << 2 | (!!a[f++] & 1) << 3 | (!!a[f++] & 1) << 4 | (!!a[f++] & 1) << 5 | (!!a[f++] & 1) << 6 | (!!a[f++] & 1) << 7;
      this.writeByte(k, c++);
    }
    if (f < d) {
      for (k = m = 0; f < d;) {
        k |= (!!a[f++] & 1) << m++;
      }
      this.writeByte(k, c++);
    }
    return b ? (this.offset = c, this) : c - e;
  };
  c.readBitSet = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    var c = this.readVarint32(a), e = c.value, d = e >> 3, f = 0, k = [];
    for (a += c.length; d--;) {
      c = this.readByte(a++), k[f++] = !!(c & 1), k[f++] = !!(c & 2), k[f++] = !!(c & 4), k[f++] = !!(c & 8), k[f++] = !!(c & 16), k[f++] = !!(c & 32), k[f++] = !!(c & 64), k[f++] = !!(c & 128);
    }
    if (f < e) {
      for (d = 0, c = this.readByte(a++); f < e;) {
        k[f++] = !!(c >> d++ & 1);
      }
    }
    b && (this.offset = a);
    return k;
  };
  c.readBytes = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + a > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+" + a + ") <= " + this.buffer.byteLength);
      }
    }
    c = this.slice(c, c + a);
    b && (this.offset += a);
    return c;
  };
  c.writeBytes = c.append;
  c.writeInt8 = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a |= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    c += 1;
    var e = this.buffer.byteLength;
    c > e && this.resize((e *= 2) > c ? e : c);
    this.view[c - 1] = a;
    b && (this.offset += 1);
    return this;
  };
  c.writeByte = c.writeInt8;
  c.readInt8 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 1 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
      }
    }
    a = this.view[a];
    128 === (a & 128) && (a = -(255 - a + 1));
    b && (this.offset += 1);
    return a;
  };
  c.readByte = c.readInt8;
  c.writeUint8 = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a >>>= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    c += 1;
    var e = this.buffer.byteLength;
    c > e && this.resize((e *= 2) > c ? e : c);
    this.view[c - 1] = a;
    b && (this.offset += 1);
    return this;
  };
  c.writeUInt8 = c.writeUint8;
  c.readUint8 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 1 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
      }
    }
    a = this.view[a];
    b && (this.offset += 1);
    return a;
  };
  c.readUInt8 = c.readUint8;
  c.writeInt16 = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a |= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    c += 2;
    var e = this.buffer.byteLength;
    c > e && this.resize((e *= 2) > c ? e : c);
    c -= 2;
    this.littleEndian ? (this.view[c + 1] = (a & 65280) >>> 8, this.view[c] = a & 255) : (this.view[c] = (a & 65280) >>> 8, this.view[c + 1] = a & 255);
    b && (this.offset += 2);
    return this;
  };
  c.writeShort = c.writeInt16;
  c.readInt16 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 2 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+2) <= " + this.buffer.byteLength);
      }
    }
    var c = 0;
    this.littleEndian ? (c = this.view[a], c |= this.view[a + 1] << 8) : (c = this.view[a] << 8, c |= this.view[a + 1]);
    32768 === (c & 32768) && (c = -(65535 - c + 1));
    b && (this.offset += 2);
    return c;
  };
  c.readShort = c.readInt16;
  c.writeUint16 = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a >>>= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    c += 2;
    var e = this.buffer.byteLength;
    c > e && this.resize((e *= 2) > c ? e : c);
    c -= 2;
    this.littleEndian ? (this.view[c + 1] = (a & 65280) >>> 8, this.view[c] = a & 255) : (this.view[c] = (a & 65280) >>> 8, this.view[c + 1] = a & 255);
    b && (this.offset += 2);
    return this;
  };
  c.writeUInt16 = c.writeUint16;
  c.readUint16 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 2 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+2) <= " + this.buffer.byteLength);
      }
    }
    var c = 0;
    this.littleEndian ? (c = this.view[a], c |= this.view[a + 1] << 8) : (c = this.view[a] << 8, c |= this.view[a + 1]);
    b && (this.offset += 2);
    return c;
  };
  c.readUInt16 = c.readUint16;
  c.writeInt32 = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a |= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    c += 4;
    var e = this.buffer.byteLength;
    c > e && this.resize((e *= 2) > c ? e : c);
    c -= 4;
    this.littleEndian ? (this.view[c + 3] = a >>> 24 & 255, this.view[c + 2] = a >>> 16 & 255, this.view[c + 1] = a >>> 8 & 255, this.view[c] = a & 255) : (this.view[c] = a >>> 24 & 255, this.view[c + 1] = a >>> 16 & 255, this.view[c + 2] = a >>> 8 & 255, this.view[c + 3] = a & 255);
    b && (this.offset += 4);
    return this;
  };
  c.writeInt = c.writeInt32;
  c.readInt32 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 4 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
      }
    }
    var c = 0;
    this.littleEndian ? (c = this.view[a + 2] << 16, c |= this.view[a + 1] << 8, c |= this.view[a], c += this.view[a + 3] << 24 >>> 0) : (c = this.view[a + 1] << 16, c |= this.view[a + 2] << 8, c |= this.view[a + 3], c += this.view[a] << 24 >>> 0);
    b && (this.offset += 4);
    return c | 0;
  };
  c.readInt = c.readInt32;
  c.writeUint32 = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a >>>= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    c += 4;
    var e = this.buffer.byteLength;
    c > e && this.resize((e *= 2) > c ? e : c);
    c -= 4;
    this.littleEndian ? (this.view[c + 3] = a >>> 24 & 255, this.view[c + 2] = a >>> 16 & 255, this.view[c + 1] = a >>> 8 & 255, this.view[c] = a & 255) : (this.view[c] = a >>> 24 & 255, this.view[c + 1] = a >>> 16 & 255, this.view[c + 2] = a >>> 8 & 255, this.view[c + 3] = a & 255);
    b && (this.offset += 4);
    return this;
  };
  c.writeUInt32 = c.writeUint32;
  c.readUint32 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 4 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
      }
    }
    var c = 0;
    this.littleEndian ? (c = this.view[a + 2] << 16, c |= this.view[a + 1] << 8, c |= this.view[a], c += this.view[a + 3] << 24 >>> 0) : (c = this.view[a + 1] << 16, c |= this.view[a + 2] << 8, c |= this.view[a + 3], c += this.view[a] << 24 >>> 0);
    b && (this.offset += 4);
    return c;
  };
  c.readUInt32 = c.readUint32;
  a && (c.writeInt64 = function(b, c) {
    var e = "undefined" === typeof c;
    e && (c = this.offset);
    if (!this.noAssert) {
      if ("number" === typeof b) {
        b = a.fromNumber(b);
      } else {
        if ("string" === typeof b) {
          b = a.fromString(b);
        } else {
          if (!(b && b instanceof a)) {
            throw TypeError("Illegal value: " + b + " (not an integer or Long)");
          }
        }
      }
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    "number" === typeof b ? b = a.fromNumber(b) : "string" === typeof b && (b = a.fromString(b));
    c += 8;
    var d = this.buffer.byteLength;
    c > d && this.resize((d *= 2) > c ? d : c);
    c -= 8;
    d = b.low;
    b = b.high;
    this.littleEndian ? (this.view[c + 3] = d >>> 24 & 255, this.view[c + 2] = d >>> 16 & 255, this.view[c + 1] = d >>> 8 & 255, this.view[c] = d & 255, c += 4, this.view[c + 3] = b >>> 24 & 255, this.view[c + 2] = b >>> 16 & 255, this.view[c + 1] = b >>> 8 & 255, this.view[c] = b & 255) : (this.view[c] = b >>> 24 & 255, this.view[c + 1] = b >>> 16 & 255, this.view[c + 2] = b >>> 8 & 255, this.view[c + 3] = b & 255, c += 4, this.view[c] = d >>> 24 & 255, this.view[c + 1] = d >>> 16 & 255, this.view[c + 
    2] = d >>> 8 & 255, this.view[c + 3] = d & 255);
    e && (this.offset += 8);
    return this;
  }, c.writeLong = c.writeInt64, c.readInt64 = function(b) {
    var c = "undefined" === typeof b;
    c && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 8 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+8) <= " + this.buffer.byteLength);
      }
    }
    var e = 0, d = 0;
    this.littleEndian ? (e = this.view[b + 2] << 16, e |= this.view[b + 1] << 8, e |= this.view[b], e += this.view[b + 3] << 24 >>> 0, b += 4, d = this.view[b + 2] << 16, d |= this.view[b + 1] << 8, d |= this.view[b], d += this.view[b + 3] << 24 >>> 0) : (d = this.view[b + 1] << 16, d |= this.view[b + 2] << 8, d |= this.view[b + 3], d += this.view[b] << 24 >>> 0, b += 4, e = this.view[b + 1] << 16, e |= this.view[b + 2] << 8, e |= this.view[b + 3], e += this.view[b] << 24 >>> 0);
    b = new a(e, d, !1);
    c && (this.offset += 8);
    return b;
  }, c.readLong = c.readInt64, c.writeUint64 = function(b, c) {
    var e = "undefined" === typeof c;
    e && (c = this.offset);
    if (!this.noAssert) {
      if ("number" === typeof b) {
        b = a.fromNumber(b);
      } else {
        if ("string" === typeof b) {
          b = a.fromString(b);
        } else {
          if (!(b && b instanceof a)) {
            throw TypeError("Illegal value: " + b + " (not an integer or Long)");
          }
        }
      }
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    "number" === typeof b ? b = a.fromNumber(b) : "string" === typeof b && (b = a.fromString(b));
    c += 8;
    var d = this.buffer.byteLength;
    c > d && this.resize((d *= 2) > c ? d : c);
    c -= 8;
    d = b.low;
    b = b.high;
    this.littleEndian ? (this.view[c + 3] = d >>> 24 & 255, this.view[c + 2] = d >>> 16 & 255, this.view[c + 1] = d >>> 8 & 255, this.view[c] = d & 255, c += 4, this.view[c + 3] = b >>> 24 & 255, this.view[c + 2] = b >>> 16 & 255, this.view[c + 1] = b >>> 8 & 255, this.view[c] = b & 255) : (this.view[c] = b >>> 24 & 255, this.view[c + 1] = b >>> 16 & 255, this.view[c + 2] = b >>> 8 & 255, this.view[c + 3] = b & 255, c += 4, this.view[c] = d >>> 24 & 255, this.view[c + 1] = d >>> 16 & 255, this.view[c + 
    2] = d >>> 8 & 255, this.view[c + 3] = d & 255);
    e && (this.offset += 8);
    return this;
  }, c.writeUInt64 = c.writeUint64, c.readUint64 = function(b) {
    var c = "undefined" === typeof b;
    c && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 8 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+8) <= " + this.buffer.byteLength);
      }
    }
    var e = 0, d = 0;
    this.littleEndian ? (e = this.view[b + 2] << 16, e |= this.view[b + 1] << 8, e |= this.view[b], e += this.view[b + 3] << 24 >>> 0, b += 4, d = this.view[b + 2] << 16, d |= this.view[b + 1] << 8, d |= this.view[b], d += this.view[b + 3] << 24 >>> 0) : (d = this.view[b + 1] << 16, d |= this.view[b + 2] << 8, d |= this.view[b + 3], d += this.view[b] << 24 >>> 0, b += 4, e = this.view[b + 1] << 16, e |= this.view[b + 2] << 8, e |= this.view[b + 3], e += this.view[b] << 24 >>> 0);
    b = new a(e, d, !0);
    c && (this.offset += 8);
    return b;
  }, c.readUInt64 = c.readUint64);
  c.writeFloat32 = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a) {
        throw TypeError("Illegal value: " + a + " (not a number)");
      }
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    c += 4;
    var d = this.buffer.byteLength;
    c > d && this.resize((d *= 2) > c ? d : c);
    e(this.view, a, c - 4, this.littleEndian, 23, 4);
    b && (this.offset += 4);
    return this;
  };
  c.writeFloat = c.writeFloat32;
  c.readFloat32 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 4 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
      }
    }
    a = h(this.view, a, this.littleEndian, 23, 4);
    b && (this.offset += 4);
    return a;
  };
  c.readFloat = c.readFloat32;
  c.writeFloat64 = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a) {
        throw TypeError("Illegal value: " + a + " (not a number)");
      }
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    c += 8;
    var d = this.buffer.byteLength;
    c > d && this.resize((d *= 2) > c ? d : c);
    e(this.view, a, c - 8, this.littleEndian, 52, 8);
    b && (this.offset += 8);
    return this;
  };
  c.writeDouble = c.writeFloat64;
  c.readFloat64 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 8 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+8) <= " + this.buffer.byteLength);
      }
    }
    a = h(this.view, a, this.littleEndian, 52, 8);
    b && (this.offset += 8);
    return a;
  };
  c.readDouble = c.readFloat64;
  k.MAX_VARINT32_BYTES = 5;
  k.calculateVarint32 = function(a) {
    a >>>= 0;
    return 128 > a ? 1 : 16384 > a ? 2 : 2097152 > a ? 3 : 268435456 > a ? 4 : 5;
  };
  k.zigZagEncode32 = function(a) {
    return ((a |= 0) << 1 ^ a >> 31) >>> 0;
  };
  k.zigZagDecode32 = function(a) {
    return a >>> 1 ^ -(a & 1) | 0;
  };
  c.writeVarint32 = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a |= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    var e = k.calculateVarint32(a);
    c += e;
    var d = this.buffer.byteLength;
    c > d && this.resize((d *= 2) > c ? d : c);
    c -= e;
    for (a >>>= 0; 128 <= a;) {
      d = a & 127 | 128, this.view[c++] = d, a >>>= 7;
    }
    this.view[c++] = a;
    return b ? (this.offset = c, this) : e;
  };
  c.writeVarint32ZigZag = function(a, c) {
    return this.writeVarint32(k.zigZagEncode32(a), c);
  };
  c.readVarint32 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 1 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
      }
    }
    var c = 0, e = 0;
    do {
      if (!this.noAssert && a > this.limit) {
        throw a = Error("Truncated"), a.truncated = !0, a;
      }
      var d = this.view[a++];
      5 > c && (e |= (d & 127) << 7 * c);
      ++c;
    } while (0 !== (d & 128));
    e |= 0;
    return b ? (this.offset = a, e) : {value:e, length:c};
  };
  c.readVarint32ZigZag = function(a) {
    a = this.readVarint32(a);
    "object" === typeof a ? a.value = k.zigZagDecode32(a.value) : a = k.zigZagDecode32(a);
    return a;
  };
  a && (k.MAX_VARINT64_BYTES = 10, k.calculateVarint64 = function(b) {
    "number" === typeof b ? b = a.fromNumber(b) : "string" === typeof b && (b = a.fromString(b));
    var c = b.toInt() >>> 0, e = b.shiftRightUnsigned(28).toInt() >>> 0;
    b = b.shiftRightUnsigned(56).toInt() >>> 0;
    return 0 == b ? 0 == e ? 16384 > c ? 128 > c ? 1 : 2 : 2097152 > c ? 3 : 4 : 16384 > e ? 128 > e ? 5 : 6 : 2097152 > e ? 7 : 8 : 128 > b ? 9 : 10;
  }, k.zigZagEncode64 = function(b) {
    "number" === typeof b ? b = a.fromNumber(b, !1) : "string" === typeof b ? b = a.fromString(b, !1) : !1 !== b.unsigned && (b = b.toSigned());
    return b.shiftLeft(1).xor(b.shiftRight(63)).toUnsigned();
  }, k.zigZagDecode64 = function(b) {
    "number" === typeof b ? b = a.fromNumber(b, !1) : "string" === typeof b ? b = a.fromString(b, !1) : !1 !== b.unsigned && (b = b.toSigned());
    return b.shiftRightUnsigned(1).xor(b.and(a.ONE).toSigned().negate()).toSigned();
  }, c.writeVarint64 = function(b, c) {
    var e = "undefined" === typeof c;
    e && (c = this.offset);
    if (!this.noAssert) {
      if ("number" === typeof b) {
        b = a.fromNumber(b);
      } else {
        if ("string" === typeof b) {
          b = a.fromString(b);
        } else {
          if (!(b && b instanceof a)) {
            throw TypeError("Illegal value: " + b + " (not an integer or Long)");
          }
        }
      }
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    "number" === typeof b ? b = a.fromNumber(b, !1) : "string" === typeof b ? b = a.fromString(b, !1) : !1 !== b.unsigned && (b = b.toSigned());
    var d = k.calculateVarint64(b), m = b.toInt() >>> 0, f = b.shiftRightUnsigned(28).toInt() >>> 0;
    b = b.shiftRightUnsigned(56).toInt() >>> 0;
    c += d;
    var h = this.buffer.byteLength;
    c > h && this.resize((h *= 2) > c ? h : c);
    c -= d;
    switch(d) {
      case 10:
        this.view[c + 9] = b >>> 7 & 1;
      case 9:
        this.view[c + 8] = 9 !== d ? b | 128 : b & 127;
      case 8:
        this.view[c + 7] = 8 !== d ? f >>> 21 | 128 : f >>> 21 & 127;
      case 7:
        this.view[c + 6] = 7 !== d ? f >>> 14 | 128 : f >>> 14 & 127;
      case 6:
        this.view[c + 5] = 6 !== d ? f >>> 7 | 128 : f >>> 7 & 127;
      case 5:
        this.view[c + 4] = 5 !== d ? f | 128 : f & 127;
      case 4:
        this.view[c + 3] = 4 !== d ? m >>> 21 | 128 : m >>> 21 & 127;
      case 3:
        this.view[c + 2] = 3 !== d ? m >>> 14 | 128 : m >>> 14 & 127;
      case 2:
        this.view[c + 1] = 2 !== d ? m >>> 7 | 128 : m >>> 7 & 127;
      case 1:
        this.view[c] = 1 !== d ? m | 128 : m & 127;
    }
    return e ? (this.offset += d, this) : d;
  }, c.writeVarint64ZigZag = function(a, c) {
    return this.writeVarint64(k.zigZagEncode64(a), c);
  }, c.readVarint64 = function(b) {
    var c = "undefined" === typeof b;
    c && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 1 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+1) <= " + this.buffer.byteLength);
      }
    }
    var e = b, d = 0, f = 0;
    var k = this.view[b++];
    var h = k & 127;
    if (k & 128 && (k = this.view[b++], h |= (k & 127) << 7, k & 128 || this.noAssert && "undefined" === typeof k) && (k = this.view[b++], h |= (k & 127) << 14, k & 128 || this.noAssert && "undefined" === typeof k) && (k = this.view[b++], h |= (k & 127) << 21, k & 128 || this.noAssert && "undefined" === typeof k) && (k = this.view[b++], d = k & 127, k & 128 || this.noAssert && "undefined" === typeof k) && (k = this.view[b++], d |= (k & 127) << 7, k & 128 || this.noAssert && "undefined" === typeof k) && 
    (k = this.view[b++], d |= (k & 127) << 14, k & 128 || this.noAssert && "undefined" === typeof k) && (k = this.view[b++], d |= (k & 127) << 21, k & 128 || this.noAssert && "undefined" === typeof k) && (k = this.view[b++], f = k & 127, k & 128 || this.noAssert && "undefined" === typeof k) && (k = this.view[b++], f |= (k & 127) << 7, k & 128 || this.noAssert && "undefined" === typeof k)) {
      throw Error("Buffer overrun");
    }
    h = a.fromBits(h | d << 28, d >>> 4 | f << 24, !1);
    return c ? (this.offset = b, h) : {value:h, length:b - e};
  }, c.readVarint64ZigZag = function(b) {
    (b = this.readVarint64(b)) && b.value instanceof a ? b.value = k.zigZagDecode64(b.value) : b = k.zigZagDecode64(b);
    return b;
  });
  c.writeCString = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    var e, m = a.length;
    if (!this.noAssert) {
      if ("string" !== typeof a) {
        throw TypeError("Illegal str: Not a string");
      }
      for (e = 0; e < m; ++e) {
        if (0 === a.charCodeAt(e)) {
          throw RangeError("Illegal str: Contains NULL-characters");
        }
      }
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    m = n.calculateUTF16asUTF8(d(a))[1];
    c += m + 1;
    e = this.buffer.byteLength;
    c > e && this.resize((e *= 2) > c ? e : c);
    c -= m + 1;
    n.encodeUTF16toUTF8(d(a), function(a) {
      this.view[c++] = a;
    }.bind(this));
    this.view[c++] = 0;
    return b ? (this.offset = c, this) : m;
  };
  c.readCString = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 1 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
      }
    }
    var c = a, e, d = -1;
    n.decodeUTF8toUTF16(function() {
      if (0 === d) {
        return null;
      }
      if (a >= this.limit) {
        throw RangeError("Illegal range: Truncated data, " + a + " < " + this.limit);
      }
      d = this.view[a++];
      return 0 === d ? null : d;
    }.bind(this), e = g(), !0);
    return b ? (this.offset = a, e()) : {string:e(), length:a - c};
  };
  c.writeIString = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    if (!this.noAssert) {
      if ("string" !== typeof a) {
        throw TypeError("Illegal str: Not a string");
      }
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    var e = c;
    var m = n.calculateUTF16asUTF8(d(a), this.noAssert)[1];
    c += 4 + m;
    var f = this.buffer.byteLength;
    c > f && this.resize((f *= 2) > c ? f : c);
    c -= 4 + m;
    this.littleEndian ? (this.view[c + 3] = m >>> 24 & 255, this.view[c + 2] = m >>> 16 & 255, this.view[c + 1] = m >>> 8 & 255, this.view[c] = m & 255) : (this.view[c] = m >>> 24 & 255, this.view[c + 1] = m >>> 16 & 255, this.view[c + 2] = m >>> 8 & 255, this.view[c + 3] = m & 255);
    c += 4;
    n.encodeUTF16toUTF8(d(a), function(a) {
      this.view[c++] = a;
    }.bind(this));
    if (c !== e + 4 + m) {
      throw RangeError("Illegal range: Truncated data, " + c + " == " + (c + 4 + m));
    }
    return b ? (this.offset = c, this) : c - e;
  };
  c.readIString = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 4 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
      }
    }
    var c = a, e = this.readUint32(a);
    e = this.readUTF8String(e, k.METRICS_BYTES, a += 4);
    a += e.length;
    return b ? (this.offset = a, e.string) : {string:e.string, length:a - c};
  };
  k.METRICS_CHARS = "c";
  k.METRICS_BYTES = "b";
  c.writeUTF8String = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    var e = c;
    var m = n.calculateUTF16asUTF8(d(a))[1];
    c += m;
    var f = this.buffer.byteLength;
    c > f && this.resize((f *= 2) > c ? f : c);
    c -= m;
    n.encodeUTF16toUTF8(d(a), function(a) {
      this.view[c++] = a;
    }.bind(this));
    return b ? (this.offset = c, this) : c - e;
  };
  c.writeString = c.writeUTF8String;
  k.calculateUTF8Chars = function(a) {
    return n.calculateUTF16asUTF8(d(a))[0];
  };
  k.calculateUTF8Bytes = function(a) {
    return n.calculateUTF16asUTF8(d(a))[1];
  };
  k.calculateString = k.calculateUTF8Bytes;
  c.readUTF8String = function(a, c, e) {
    "number" === typeof c && (e = c, c = void 0);
    var b = "undefined" === typeof e;
    b && (e = this.offset);
    "undefined" === typeof c && (c = k.METRICS_CHARS);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal length: " + a + " (not an integer)");
      }
      a |= 0;
      if ("number" !== typeof e || 0 !== e % 1) {
        throw TypeError("Illegal offset: " + e + " (not an integer)");
      }
      e >>>= 0;
      if (0 > e || e + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + e + " (+0) <= " + this.buffer.byteLength);
      }
    }
    var d = 0, m = e;
    if (c === k.METRICS_CHARS) {
      var f = g();
      n.decodeUTF8(function() {
        return d < a && e < this.limit ? this.view[e++] : null;
      }.bind(this), function(a) {
        ++d;
        n.UTF8toUTF16(a, f);
      });
      if (d !== a) {
        throw RangeError("Illegal range: Truncated data, " + d + " == " + a);
      }
      return b ? (this.offset = e, f()) : {string:f(), length:e - m};
    }
    if (c === k.METRICS_BYTES) {
      if (!this.noAssert) {
        if ("number" !== typeof e || 0 !== e % 1) {
          throw TypeError("Illegal offset: " + e + " (not an integer)");
        }
        e >>>= 0;
        if (0 > e || e + a > this.buffer.byteLength) {
          throw RangeError("Illegal offset: 0 <= " + e + " (+" + a + ") <= " + this.buffer.byteLength);
        }
      }
      var h = e + a;
      n.decodeUTF8toUTF16(function() {
        return e < h ? this.view[e++] : null;
      }.bind(this), f = g(), this.noAssert);
      if (e !== h) {
        throw RangeError("Illegal range: Truncated data, " + e + " == " + h);
      }
      return b ? (this.offset = e, f()) : {string:f(), length:e - m};
    }
    throw TypeError("Unsupported metrics: " + c);
  };
  c.readString = c.readUTF8String;
  c.writeVString = function(a, c) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    if (!this.noAssert) {
      if ("string" !== typeof a) {
        throw TypeError("Illegal str: Not a string");
      }
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    var e = c;
    var m = n.calculateUTF16asUTF8(d(a), this.noAssert)[1];
    var f = k.calculateVarint32(m);
    c += f + m;
    var h = this.buffer.byteLength;
    c > h && this.resize((h *= 2) > c ? h : c);
    c -= f + m;
    c += this.writeVarint32(m, c);
    n.encodeUTF16toUTF8(d(a), function(a) {
      this.view[c++] = a;
    }.bind(this));
    if (c !== e + m + f) {
      throw RangeError("Illegal range: Truncated data, " + c + " == " + (c + m + f));
    }
    return b ? (this.offset = c, this) : c - e;
  };
  c.readVString = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 1 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
      }
    }
    var c = a, e = this.readVarint32(a);
    e = this.readUTF8String(e.value, k.METRICS_BYTES, a += e.length);
    a += e.length;
    return b ? (this.offset = a, e.string) : {string:e.string, length:a - c};
  };
  c.append = function(a, c, e) {
    if ("number" === typeof c || "string" !== typeof c) {
      e = c, c = void 0;
    }
    var b = "undefined" === typeof e;
    b && (e = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof e || 0 !== e % 1) {
        throw TypeError("Illegal offset: " + e + " (not an integer)");
      }
      e >>>= 0;
      if (0 > e || e + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + e + " (+0) <= " + this.buffer.byteLength);
      }
    }
    a instanceof k || (a = k.wrap(a, c));
    c = a.limit - a.offset;
    if (0 >= c) {
      return this;
    }
    e += c;
    var d = this.buffer.byteLength;
    e > d && this.resize((d *= 2) > e ? d : e);
    e -= c;
    this.view.set(a.view.subarray(a.offset, a.limit), e);
    a.offset += c;
    b && (this.offset += c);
    return this;
  };
  c.appendTo = function(a, c) {
    a.append(this, c);
    return this;
  };
  c.assert = function(a) {
    this.noAssert = !a;
    return this;
  };
  c.capacity = function() {
    return this.buffer.byteLength;
  };
  c.clear = function() {
    this.offset = 0;
    this.limit = this.buffer.byteLength;
    this.markedOffset = -1;
    return this;
  };
  c.clone = function(a) {
    var b = new k(0, this.littleEndian, this.noAssert);
    a ? (b.buffer = new ArrayBuffer(this.buffer.byteLength), b.view = new Uint8Array(b.buffer)) : (b.buffer = this.buffer, b.view = this.view);
    b.offset = this.offset;
    b.markedOffset = this.markedOffset;
    b.limit = this.limit;
    return b;
  };
  c.compact = function(a, c) {
    "undefined" === typeof a && (a = this.offset);
    "undefined" === typeof c && (c = this.limit);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal begin: Not an integer");
      }
      a >>>= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal end: Not an integer");
      }
      c >>>= 0;
      if (0 > a || a > c || c > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + a + " <= " + c + " <= " + this.buffer.byteLength);
      }
    }
    if (0 === a && c === this.buffer.byteLength) {
      return this;
    }
    var b = c - a;
    if (0 === b) {
      return this.buffer = p, this.view = null, 0 <= this.markedOffset && (this.markedOffset -= a), this.limit = this.offset = 0, this;
    }
    var e = new ArrayBuffer(b), d = new Uint8Array(e);
    d.set(this.view.subarray(a, c));
    this.buffer = e;
    this.view = d;
    0 <= this.markedOffset && (this.markedOffset -= a);
    this.offset = 0;
    this.limit = b;
    return this;
  };
  c.copy = function(a, c) {
    "undefined" === typeof a && (a = this.offset);
    "undefined" === typeof c && (c = this.limit);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal begin: Not an integer");
      }
      a >>>= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal end: Not an integer");
      }
      c >>>= 0;
      if (0 > a || a > c || c > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + a + " <= " + c + " <= " + this.buffer.byteLength);
      }
    }
    if (a === c) {
      return new k(0, this.littleEndian, this.noAssert);
    }
    var b = c - a, e = new k(b, this.littleEndian, this.noAssert);
    e.offset = 0;
    e.limit = b;
    0 <= e.markedOffset && (e.markedOffset -= a);
    this.copyTo(e, 0, a, c);
    return e;
  };
  c.copyTo = function(a, c, e, d) {
    var b, m;
    if (!this.noAssert && !k.isByteBuffer(a)) {
      throw TypeError("Illegal target: Not a ByteBuffer");
    }
    c = (m = "undefined" === typeof c) ? a.offset : c | 0;
    e = (b = "undefined" === typeof e) ? this.offset : e | 0;
    d = "undefined" === typeof d ? this.limit : d | 0;
    if (0 > c || c > a.buffer.byteLength) {
      throw RangeError("Illegal target range: 0 <= " + c + " <= " + a.buffer.byteLength);
    }
    if (0 > e || d > this.buffer.byteLength) {
      throw RangeError("Illegal source range: 0 <= " + e + " <= " + this.buffer.byteLength);
    }
    var f = d - e;
    if (0 === f) {
      return a;
    }
    a.ensureCapacity(c + f);
    a.view.set(this.view.subarray(e, d), c);
    b && (this.offset += f);
    m && (a.offset += f);
    return this;
  };
  c.ensureCapacity = function(a) {
    var b = this.buffer.byteLength;
    return b < a ? this.resize((b *= 2) > a ? b : a) : this;
  };
  c.fill = function(a, c, e) {
    var b = "undefined" === typeof c;
    b && (c = this.offset);
    "string" === typeof a && 0 < a.length && (a = a.charCodeAt(0));
    "undefined" === typeof c && (c = this.offset);
    "undefined" === typeof e && (e = this.limit);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a |= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal begin: Not an integer");
      }
      c >>>= 0;
      if ("number" !== typeof e || 0 !== e % 1) {
        throw TypeError("Illegal end: Not an integer");
      }
      e >>>= 0;
      if (0 > c || c > e || e > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + c + " <= " + e + " <= " + this.buffer.byteLength);
      }
    }
    if (c >= e) {
      return this;
    }
    for (; c < e;) {
      this.view[c++] = a;
    }
    b && (this.offset = c);
    return this;
  };
  c.flip = function() {
    this.limit = this.offset;
    this.offset = 0;
    return this;
  };
  c.mark = function(a) {
    a = "undefined" === typeof a ? this.offset : a;
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+0) <= " + this.buffer.byteLength);
      }
    }
    this.markedOffset = a;
    return this;
  };
  c.order = function(a) {
    if (!this.noAssert && "boolean" !== typeof a) {
      throw TypeError("Illegal littleEndian: Not a boolean");
    }
    this.littleEndian = !!a;
    return this;
  };
  c.LE = function(a) {
    this.littleEndian = "undefined" !== typeof a ? !!a : !0;
    return this;
  };
  c.BE = function(a) {
    this.littleEndian = "undefined" !== typeof a ? !a : !1;
    return this;
  };
  c.prepend = function(a, c, e) {
    if ("number" === typeof c || "string" !== typeof c) {
      e = c, c = void 0;
    }
    var b = "undefined" === typeof e;
    b && (e = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof e || 0 !== e % 1) {
        throw TypeError("Illegal offset: " + e + " (not an integer)");
      }
      e >>>= 0;
      if (0 > e || e + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + e + " (+0) <= " + this.buffer.byteLength);
      }
    }
    a instanceof k || (a = k.wrap(a, c));
    c = a.limit - a.offset;
    if (0 >= c) {
      return this;
    }
    var d = c - e;
    if (0 < d) {
      var m = new ArrayBuffer(this.buffer.byteLength + d), f = new Uint8Array(m);
      f.set(this.view.subarray(e, this.buffer.byteLength), c);
      this.buffer = m;
      this.view = f;
      this.offset += d;
      0 <= this.markedOffset && (this.markedOffset += d);
      this.limit += d;
      e += d;
    } else {
      new Uint8Array(this.buffer);
    }
    this.view.set(a.view.subarray(a.offset, a.limit), e - c);
    a.offset = a.limit;
    b && (this.offset -= c);
    return this;
  };
  c.prependTo = function(a, c) {
    a.prepend(this, c);
    return this;
  };
  c.printDebug = function(a) {
    "function" !== typeof a && (a = console.log.bind(console));
    a(this.toString() + "\n-------------------------------------------------------------------\n" + this.toDebug(!0));
  };
  c.remaining = function() {
    return this.limit - this.offset;
  };
  c.reset = function() {
    0 <= this.markedOffset ? (this.offset = this.markedOffset, this.markedOffset = -1) : this.offset = 0;
    return this;
  };
  c.resize = function(a) {
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal capacity: " + a + " (not an integer)");
      }
      a |= 0;
      if (0 > a) {
        throw RangeError("Illegal capacity: 0 <= " + a);
      }
    }
    if (this.buffer.byteLength < a) {
      a = new ArrayBuffer(a);
      var b = new Uint8Array(a);
      b.set(this.view);
      this.buffer = a;
      this.view = b;
    }
    return this;
  };
  c.reverse = function(a, c) {
    "undefined" === typeof a && (a = this.offset);
    "undefined" === typeof c && (c = this.limit);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal begin: Not an integer");
      }
      a >>>= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal end: Not an integer");
      }
      c >>>= 0;
      if (0 > a || a > c || c > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + a + " <= " + c + " <= " + this.buffer.byteLength);
      }
    }
    if (a === c) {
      return this;
    }
    Array.prototype.reverse.call(this.view.subarray(a, c));
    return this;
  };
  c.skip = function(a) {
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal length: " + a + " (not an integer)");
      }
      a |= 0;
    }
    var b = this.offset + a;
    if (!this.noAssert && (0 > b || b > this.buffer.byteLength)) {
      throw RangeError("Illegal length: 0 <= " + this.offset + " + " + a + " <= " + this.buffer.byteLength);
    }
    this.offset = b;
    return this;
  };
  c.slice = function(a, c) {
    "undefined" === typeof a && (a = this.offset);
    "undefined" === typeof c && (c = this.limit);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal begin: Not an integer");
      }
      a >>>= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal end: Not an integer");
      }
      c >>>= 0;
      if (0 > a || a > c || c > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + a + " <= " + c + " <= " + this.buffer.byteLength);
      }
    }
    var b = this.clone();
    b.offset = a;
    b.limit = c;
    return b;
  };
  c.toBuffer = function(a) {
    var b = this.offset, c = this.limit;
    if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: Not an integer");
      }
      b >>>= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal limit: Not an integer");
      }
      c >>>= 0;
      if (0 > b || b > c || c > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + b + " <= " + c + " <= " + this.buffer.byteLength);
      }
    }
    if (!a && 0 === b && c === this.buffer.byteLength) {
      return this.buffer;
    }
    if (b === c) {
      return p;
    }
    a = new ArrayBuffer(c - b);
    (new Uint8Array(a)).set((new Uint8Array(this.buffer)).subarray(b, c), 0);
    return a;
  };
  c.toArrayBuffer = c.toBuffer;
  c.toString = function(a, c, e) {
    if ("undefined" === typeof a) {
      return "ByteBufferAB(offset=" + this.offset + ",markedOffset=" + this.markedOffset + ",limit=" + this.limit + ",capacity=" + this.capacity() + ")";
    }
    "number" === typeof a && (e = c = a = "utf8");
    switch(a) {
      case "utf8":
        return this.toUTF8(c, e);
      case "base64":
        return this.toBase64(c, e);
      case "hex":
        return this.toHex(c, e);
      case "binary":
        return this.toBinary(c, e);
      case "debug":
        return this.toDebug();
      case "columns":
        return this.toColumns();
      default:
        throw Error("Unsupported encoding: " + a);
    }
  };
  var f = function() {
    for (var a = {}, c = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47], e = [], d = 0, f = c.length; d < f; ++d) {
      e[c[d]] = d;
    }
    a.encode = function(a, b) {
      for (var e, d; null !== (e = a());) {
        b(c[e >> 2 & 63]), d = (e & 3) << 4, null !== (e = a()) ? (d |= e >> 4 & 15, b(c[(d | e >> 4 & 15) & 63]), d = (e & 15) << 2, null !== (e = a()) ? (b(c[(d | e >> 6 & 3) & 63]), b(c[e & 63])) : (b(c[d & 63]), b(61))) : (b(c[d & 63]), b(61), b(61));
      }
    };
    a.decode = function(a, b) {
      function c(a) {
        throw Error("Illegal character code: " + a);
      }
      for (var d, f, m; null !== (d = a());) {
        if (f = e[d], "undefined" === typeof f && c(d), null !== (d = a()) && (m = e[d], "undefined" === typeof m && c(d), b(f << 2 >>> 0 | (m & 48) >> 4), null !== (d = a()))) {
          f = e[d];
          if ("undefined" === typeof f) {
            if (61 === d) {
              break;
            } else {
              c(d);
            }
          }
          b((m & 15) << 4 >>> 0 | (f & 60) >> 2);
          if (null !== (d = a())) {
            m = e[d];
            if ("undefined" === typeof m) {
              if (61 === d) {
                break;
              } else {
                c(d);
              }
            }
            b((f & 3) << 6 >>> 0 | m);
          }
        }
      }
    };
    a.test = function(a) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(a);
    };
    return a;
  }();
  c.toBase64 = function(a, c) {
    "undefined" === typeof a && (a = this.offset);
    "undefined" === typeof c && (c = this.limit);
    a |= 0;
    c |= 0;
    if (0 > a || c > this.capacity || a > c) {
      throw RangeError("begin, end");
    }
    var b;
    f.encode(function() {
      return a < c ? this.view[a++] : null;
    }.bind(this), b = g());
    return b();
  };
  k.fromBase64 = function(a, c) {
    if ("string" !== typeof a) {
      throw TypeError("str");
    }
    var b = new k(a.length / 4 * 3, c), e = 0;
    f.decode(d(a), function(a) {
      b.view[e++] = a;
    });
    b.limit = e;
    return b;
  };
  k.btoa = function(a) {
    return k.fromBinary(a).toBase64();
  };
  k.atob = function(a) {
    return k.fromBase64(a).toBinary();
  };
  c.toBinary = function(a, c) {
    "undefined" === typeof a && (a = this.offset);
    "undefined" === typeof c && (c = this.limit);
    a |= 0;
    c |= 0;
    if (0 > a || c > this.capacity() || a > c) {
      throw RangeError("begin, end");
    }
    if (a === c) {
      return "";
    }
    for (var b = [], e = []; a < c;) {
      b.push(this.view[a++]), 1024 <= b.length && (e.push(String.fromCharCode.apply(String, b)), b = []);
    }
    return e.join("") + String.fromCharCode.apply(String, b);
  };
  k.fromBinary = function(a, c) {
    if ("string" !== typeof a) {
      throw TypeError("str");
    }
    for (var b = 0, e = a.length, d = new k(e, c); b < e;) {
      c = a.charCodeAt(b);
      if (255 < c) {
        throw RangeError("illegal char code: " + c);
      }
      d.view[b++] = c;
    }
    d.limit = e;
    return d;
  };
  c.toDebug = function(a) {
    for (var b = -1, c = this.buffer.byteLength, e, d = "", f = "", k = ""; b < c;) {
      -1 !== b && (e = this.view[b], d = 16 > e ? d + ("0" + e.toString(16).toUpperCase()) : d + e.toString(16).toUpperCase(), a && (f += 32 < e && 127 > e ? String.fromCharCode(e) : "."));
      ++b;
      if (a && 0 < b && 0 === b % 16 && b !== c) {
        for (; 51 > d.length;) {
          d += " ";
        }
        k += d + f + "\n";
        d = f = "";
      }
      d = b === this.offset && b === this.limit ? d + (b === this.markedOffset ? "!" : "|") : b === this.offset ? d + (b === this.markedOffset ? "[" : "<") : b === this.limit ? d + (b === this.markedOffset ? "]" : ">") : d + (b === this.markedOffset ? "'" : a || 0 !== b && b !== c ? " " : "");
    }
    if (a && " " !== d) {
      for (; 51 > d.length;) {
        d += " ";
      }
      k += d + f + "\n";
    }
    return a ? k : d;
  };
  k.fromDebug = function(a, c, e) {
    var b = a.length;
    c = new k((b + 1) / 3 | 0, c, e);
    for (var d = 0, f = 0, m, h = !1, g = !1, n = !1, p = !1, q = !1; d < b;) {
      switch(m = a.charAt(d++)) {
        case "!":
          if (!e) {
            if (g || n || p) {
              q = !0;
              break;
            }
            g = n = p = !0;
          }
          c.offset = c.markedOffset = c.limit = f;
          h = !1;
          break;
        case "|":
          if (!e) {
            if (g || p) {
              q = ! 0;
              break;
            }
            g = p = !0;
          }
          c.offset = c.limit = f;
          h = !1;
          break;
        case "[":
          if (!e) {
            if (g || n) {
              q = !0;
              break;
            }
            g = n = !0;
          }
          c.offset = c.markedOffset = f;
          h = !1;
          break;
        case "<":
          if (!e) {
            if (g) {
              q = !0;
              break;
            }
            g = ! 0;
          }
          c.offset = f;
          h = !1;
          break;
        case "]":
          if (!e) {
            if (p || n) {
              q = !0;
              break;
            }
            p = n = !0;
          }
          c.limit = c.markedOffset = f;
          h = !1;
          break;
        case ">":
          if (!e) {
            if (p) {
              q = !0;
              break;
            }
            p = !0;
          }
          c.limit = f;
          h = !1;
          break;
        case "'":
          if (!e) {
            if (n) {
              q = !0;
              break;
            }
            n = !0;
          }
          c.markedOffset = f;
          h = !1;
          break;
        case " ":
          h = !1;
          break;
        default:
          if (!e && h) {
            q = !0;
          } else {
            m = parseInt(m + a.charAt(d++), 16);
            if (!e && (isNaN(m) || 0 > m || 255 < m)) {
              throw TypeError("Illegal str: Not a debug encoded string");
            }
            c.view[f++] = m;
            h = !0;
          }
      }
      if (q) {
        throw TypeError("Illegal str: Invalid symbol at " + d);
      }
    }
    if (!e) {
      if (!g || !p) {
        throw TypeError("Illegal str: Missing offset or limit");
      }
      if (f < c.buffer.byteLength) {
        throw TypeError("Illegal str: Not a debug encoded string (is it hex?) " + f + " < " + b);
      }
    }
    return c;
  };
  c.toHex = function(a, c) {
    a = "undefined" === typeof a ? this.offset : a;
    c = "undefined" === typeof c ? this.limit : c;
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal begin: Not an integer");
      }
      a >>>= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal end: Not an integer");
      }
      c >>>= 0;
      if (0 > a || a > c || c > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + a + " <= " + c + " <= " + this.buffer.byteLength);
      }
    }
    for (var b = Array(c - a), e; a < c;) {
      e = this.view[a++], 16 > e ? b.push("0", e.toString(16)) : b.push(e.toString(16));
    }
    return b.join("");
  };
  k.fromHex = function(a, c, e) {
    if (!e) {
      if ("string" !== typeof a) {
        throw TypeError("Illegal str: Not a string");
      }
      if (0 !== a.length % 2) {
        throw TypeError("Illegal str: Length not a multiple of 2");
      }
    }
    var b = a.length;
    c = new k(b / 2 | 0, c);
    for (var d, f = 0, m = 0; f < b; f += 2) {
      d = parseInt(a.substring(f, f + 2), 16);
      if (!e && (!isFinite(d) || 0 > d || 255 < d)) {
        throw TypeError("Illegal str: Contains non-hex characters");
      }
      c.view[m++] = d;
    }
    c.limit = m;
    return c;
  };
  var n = function() {
    var a = {MAX_CODEPOINT:1114111, encodeUTF8:function(a, b) {
      var c = null;
      for ("number" === typeof a && (c = a, a = function() {
        return null;
      }); null !== c || null !== (c = a());) {
        128 > c ? b(c & 127) : (2048 > c ? b(c >> 6 & 31 | 192) : (65536 > c ? b(c >> 12 & 15 | 224) : (b(c >> 18 & 7 | 240), b(c >> 12 & 63 | 128)), b(c >> 6 & 63 | 128)), b(c & 63 | 128)), c = null;
      }
    }, decodeUTF8:function(a, b) {
      for (var c, e, d, f, m = function(a) {
        a = a.slice(0, a.indexOf(null));
        var b = Error(a.toString());
        b.name = "TruncatedError";
        b.bytes = a;
        throw b;
      }; null !== (c = a());) {
        if (0 === (c & 128)) {
          b(c);
        } else {
          if (192 === (c & 224)) {
            null === (e = a()) && m([c, e]), b((c & 31) << 6 | e & 63);
          } else {
            if (224 === (c & 240)) {
              null !== (e = a()) && null !== (d = a()) || m([c, e, d]), b((c & 15) << 12 | (e & 63) << 6 | d & 63);
            } else {
              if (240 === (c & 248)) {
                null !== (e = a()) && null !== (d = a()) && null !== (f = a()) || m([c, e, d, f]), b((c & 7) << 18 | (e & 63) << 12 | (d & 63) << 6 | f & 63);
              } else {
                throw RangeError("Illegal starting byte: " + c);
              }
            }
          }
        }
      }
    }, UTF16toUTF8:function(a, b) {
      for (var c, e = null; null !== (c = null !== e ? e : a());) {
        55296 <= c && 57343 >= c && null !== (e = a()) && 56320 <= e && 57343 >= e ? (b(1024 * (c - 55296) + e - 56320 + 65536), e = null) : b(c);
      }
      null !== e && b(e);
    }, UTF8toUTF16:function(a, b) {
      var c = null;
      for ("number" === typeof a && (c = a, a = function() {
        return null;
      }); null !== c || null !== (c = a());) {
        65535 >= c ? b(c) : (c -= 65536, b((c >> 10) + 55296), b(c % 1024 + 56320)), c = null;
      }
    }, encodeUTF16toUTF8:function(b, c) {
      a.UTF16toUTF8(b, function(b) {
        a.encodeUTF8(b, c);
      });
    }, decodeUTF8toUTF16:function(b, c) {
      a.decodeUTF8(b, function(b) {
        a.UTF8toUTF16(b, c);
      });
    }, calculateCodePoint:function(a) {
      return 128 > a ? 1 : 2048 > a ? 2 : 65536 > a ? 3 : 4;
    }, calculateUTF8:function(a) {
      for (var b, c = 0; null !== (b = a());) {
        c += 128 > b ? 1 : 2048 > b ? 2 : 65536 > b ? 3 : 4;
      }
      return c;
    }, calculateUTF16asUTF8:function(b) {
      var c = 0, e = 0;
      a.UTF16toUTF8(b, function(a) {
        ++c;
        e += 128 > a ? 1 : 2048 > a ? 2 : 65536 > a ? 3 : 4;
      });
      return [c, e];
    }};
    return a;
  }();
  c.toUTF8 = function(a, c) {
    "undefined" === typeof a && (a = this.offset);
    "undefined" === typeof c && (c = this.limit);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal begin: Not an integer");
      }
      a >>>= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal end: Not an integer");
      }
      c >>>= 0;
      if (0 > a || a > c || c > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + a + " <= " + c + " <= " + this.buffer.byteLength);
      }
    }
    var b;
    try {
      n.decodeUTF8toUTF16(function() {
        return a < c ? this.view[a++] : null;
      }.bind(this), b = g());
    } catch (y) {
      if (a !== c) {
        throw RangeError("Illegal range: Truncated data, " + a + " != " + c);
      }
    }
    return b();
  };
  k.fromUTF8 = function(a, c, e) {
    if (!e && "string" !== typeof a) {
      throw TypeError("Illegal str: Not a string");
    }
    var b = new k(n.calculateUTF16asUTF8(d(a), !0)[1], c, e), f = 0;
    n.encodeUTF16toUTF8(d(a), function(a) {
      b.view[f++] = a;
    });
    b.limit = f;
    return b;
  };
  return k;
});
(function(a, d) {
  "function" === typeof define && define.amd ? define([], d) : "function" === typeof require && "object" === typeof module && module && module.exports ? module.exports = d() : (a.dcodeIO = a.dcodeIO || {}).Long = d();
})(this, function() {
  function a(a, b, c) {
    this.low = a | 0;
    this.high = b | 0;
    this.unsigned = !!c;
  }
  function d(a) {
    return !0 === (a && a.__isLong__);
  }
  function g(a, b) {
    var c;
    if (b) {
      a >>>= 0;
      if (c = 0 <= a && 256 > a) {
        if (b = t[a]) {
          return b;
        }
      }
      b = e(a, 0 > (a | 0) ? -1 : 0, !0);
      c && (t[a] = b);
    } else {
      a |= 0;
      if (c = -128 <= a && 128 > a) {
        if (b = p[a]) {
          return b;
        }
      }
      b = e(a, 0 > a ? -1 : 0, !1);
      c && (p[a] = b);
    }
    return b;
  }
  function h(a, c) {
    if (isNaN(a) || !isFinite(a)) {
      return c ? y : q;
    }
    if (c) {
      if (0 > a) {
        return y;
      }
      if (a >= n) {
        return v;
      }
    } else {
      if (a <= -b) {
        return C;
      }
      if (a + 1 >= b) {
        return u;
      }
    }
    return 0 > a ? h(-a, c).neg() : e(a % 4294967296 | 0, a / 4294967296 | 0, c);
  }
  function e(b, c, e) {
    return new a(b, c, e);
  }
  function k(a, b, c) {
    if (0 === a.length) {
      throw Error("empty string");
    }
    if ("NaN" === a || "Infinity" === a || "+Infinity" === a || "-Infinity" === a) {
      return q;
    }
    "number" === typeof b ? (c = b, b = !1) : b = !!b;
    c = c || 10;
    if (2 > c || 36 < c) {
      throw RangeError("radix");
    }
    var e;
    if (0 < (e = a.indexOf("-"))) {
      throw Error("interior hyphen");
    }
    if (0 === e) {
      return k(a.substring(1), b, c).neg();
    }
    e = h(f(c, 8));
    for (var d = q, m = 0; m < a.length; m += 8) {
      var g = Math.min(8, a.length - m), r = parseInt(a.substring(m, m + g), c);
      8 > g ? (g = h(f(c, g)), d = d.mul(g).add(h(r))) : (d = d.mul(e), d = d.add(h(r)));
    }
    d.unsigned = b;
    return d;
  }
  function c(b) {
    return b instanceof a ? b : "number" === typeof b ? h(b) : "string" === typeof b ? k(b) : e(b.low, b.high, b.unsigned);
  }
  Object.defineProperty(a.prototype, "__isLong__", {value:!0, enumerable:!1, configurable:!1});
  a.isLong = d;
  var p = {}, t = {};
  a.fromInt = g;
  a.fromNumber = h;
  a.fromBits = e;
  var f = Math.pow;
  a.fromString = k;
  a.fromValue = c;
  var n = 4294967296 * 4294967296, b = n / 2, m = g(16777216), q = g(0);
  a.ZERO = q;
  var y = g(0, !0);
  a.UZERO = y;
  var x = g(1);
  a.ONE = x;
  var z = g(1, !0);
  a.UONE = z;
  var r = g(-1);
  a.NEG_ONE = r;
  var u = e(-1, 2147483647, !1);
  a.MAX_VALUE = u;
  var v = e(-1, -1, !0);
  a.MAX_UNSIGNED_VALUE = v;
  var C = e(0, -2147483648, !1);
  a.MIN_VALUE = C;
  var A = a.prototype;
  A.toInt = function() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  A.toNumber = function() {
    return this.unsigned ? 4294967296 * (this.high >>> 0) + (this.low >>> 0) : 4294967296 * this.high + (this.low >>> 0);
  };
  A.toString = function(a) {
    a = a || 10;
    if (2 > a || 36 < a) {
      throw RangeError("radix");
    }
    if (this.isZero()) {
      return "0";
    }
    if (this.isNegative()) {
      if (this.eq(C)) {
        var b = h(a), c = this.div(b);
        b = c.mul(b).sub(this);
        return c.toString(a) + b.toInt().toString(a);
      }
      return "-" + this.neg().toString(a);
    }
    c = h(f(a, 6), this.unsigned);
    b = this;
    for (var e = "";;) {
      var d = b.div(c), m = (b.sub(d.mul(c)).toInt() >>> 0).toString(a);
      b = d;
      if (b.isZero()) {
        return m + e;
      }
      for (; 6 > m.length;) {
        m = "0" + m;
      }
      e = "" + m + e;
    }
  };
  A.getHighBits = function() {
    return this.high;
  };
  A.getHighBitsUnsigned = function() {
    return this.high >>> 0;
  };
  A.getLowBits = function() {
    return this.low;
  };
  A.getLowBitsUnsigned = function() {
    return this.low >>> 0;
  };
  A.getNumBitsAbs = function() {
    if (this.isNegative()) {
      return this.eq(C) ? 64 : this.neg().getNumBitsAbs();
    }
    for (var a = 0 != this.high ? this.high : this.low, b = 31; 0 < b && 0 == (a & 1 << b); b--) {
    }
    return 0 != this.high ? b + 33 : b + 1;
  };
  A.isZero = function() {
    return 0 === this.high && 0 === this.low;
  };
  A.isNegative = function() {
    return !this.unsigned && 0 > this.high;
  };
  A.isPositive = function() {
    return this.unsigned || 0 <= this.high;
  };
  A.isOdd = function() {
    return 1 === (this.low & 1);
  };
  A.isEven = function() {
    return 0 === (this.low & 1);
  };
  A.equals = function(a) {
    d(a) || (a = c(a));
    return this.unsigned !== a.unsigned && 1 === this.high >>> 31 && 1 === a.high >>> 31 ? !1 : this.high === a.high && this.low === a.low;
  };
  A.eq = A.equals;
  A.notEquals = function(a) {
    return !this.eq(a);
  };
  A.neq = A.notEquals;
  A.lessThan = function(a) {
    return 0 > this.comp(a);
  };
  A.lt = A.lessThan;
  A.lessThanOrEqual = function(a) {
    return 0 >= this.comp(a);
  };
  A.lte = A.lessThanOrEqual;
  A.greaterThan = function(a) {
    return 0 < this.comp(a);
  };
  A.gt = A.greaterThan;
  A.greaterThanOrEqual = function(a) {
    return 0 <= this.comp(a);
  };
  A.gte = A.greaterThanOrEqual;
  A.compare = function(a) {
    d(a) || (a = c(a));
    if (this.eq(a)) {
      return 0;
    }
    var b = this.isNegative(), e = a.isNegative();
    return b && !e ? -1 : !b && e ? 1 : this.unsigned ? a.high >>> 0 > this.high >>> 0 || a.high === this.high && a.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(a).isNegative() ? -1 : 1;
  };
  A.comp = A.compare;
  A.negate = function() {
    return !this.unsigned && this.eq(C) ? C : this.not().add(x);
  };
  A.neg = A.negate;
  A.add = function(a) {
    d(a) || (a = c(a));
    var b = this.high >>> 16, f = this.high & 65535, m = this.low >>> 16, k = a.high >>> 16, h = a.high & 65535, g = a.low >>> 16;
    var r = (this.low & 65535) + (a.low & 65535);
    a = (r >>> 16) + (m + g);
    m = (a >>> 16) + (f + h);
    f = (m >>> 16) + (b + k) & 65535;
    return e((a & 65535) << 16 | r & 65535, f << 16 | m & 65535, this.unsigned);
  };
  A.subtract = function(a) {
    d(a) || (a = c(a));
    return this.add(a.neg());
  };
  A.sub = A.subtract;
  A.multiply = function(a) {
    if (this.isZero()) {
      return q;
    }
    d(a) || (a = c(a));
    if (a.isZero()) {
      return q;
    }
    if (this.eq(C)) {
      return a.isOdd() ? C : q;
    }
    if (a.eq(C)) {
      return this.isOdd() ? C : q;
    }
    if (this.isNegative()) {
      return a.isNegative() ? this.neg().mul(a.neg()) : this.neg().mul(a).neg();
    }
    if (a.isNegative()) {
      return this.mul(a.neg()).neg();
    }
    if (this.lt(m) && a.lt(m)) {
      return h(this.toNumber() * a.toNumber(), this.unsigned);
    }
    var b = this.high >>> 16, f = this.high & 65535, k = this.low >>> 16, g = this.low & 65535, r = a.high >>> 16, n = a.high & 65535, p = a.low >>> 16;
    a = a.low & 65535;
    var u = g * a;
    var t = (u >>> 16) + k * a;
    var v = t >>> 16;
    t = (t & 65535) + g * p;
    v += t >>> 16;
    v += f * a;
    var y = v >>> 16;
    v = (v & 65535) + k * p;
    y += v >>> 16;
    v = (v & 65535) + g * n;
    return e((t & 65535) << 16 | u & 65535, (y + (v >>> 16) + (b * a + f * p + k * n + g * r) & 65535) << 16 | v & 65535, this.unsigned);
  };
  A.mul = A.multiply;
  A.divide = function(a) {
    d(a) || (a = c(a));
    if (a.isZero()) {
      throw Error("division by zero");
    }
    if (this.isZero()) {
      return this.unsigned ? y : q;
    }
    if (this.unsigned) {
      a.unsigned || (a = a.toUnsigned());
      if (a.gt(this)) {
        return y;
      }
      if (a.gt(this.shru(1))) {
        return z;
      }
      var b = y;
    } else {
      if (this.eq(C)) {
        if (a.eq(x) || a.eq(r)) {
          return C;
        }
        if (a.eq(C)) {
          return x;
        }
        var e = this.shr(1).div(a).shl(1);
        if (e.eq(q)) {
          return a.isNegative() ? x : r;
        }
        var m = this.sub(a.mul(e));
        return e.add(m.div(a));
      }
      if (a.eq(C)) {
        return this.unsigned ? y : q;
      }
      if (this.isNegative()) {
        return a.isNegative() ? this.neg().div(a.neg()) : this.neg().div(a).neg();
      }
      if (a.isNegative()) {
        return this.div(a.neg()).neg();
      }
      b = q;
    }
    for (m = this; m.gte(a);) {
      e = Math.max(1, Math.floor(m.toNumber() / a.toNumber()));
      var k = Math.ceil(Math.log(e) / Math.LN2);
      k = 48 >= k ? 1 : f(2, k - 48);
      for (var g = h(e), n = g.mul(a); n.isNegative() || n.gt(m);) {
        e -= k, g = h(e, this.unsigned), n = g.mul(a);
      }
      g.isZero() && (g = x);
      b = b.add(g);
      m = m.sub(n);
    }
    return b;
  };
  A.div = A.divide;
  A.modulo = function(a) {
    d(a) || (a = c(a));
    return this.sub(this.div(a).mul(a));
  };
  A.mod = A.modulo;
  A.not = function() {
    return e(~this.low, ~this.high, this.unsigned);
  };
  A.and = function(a) {
    d(a) || (a = c(a));
    return e(this.low & a.low, this.high & a.high, this.unsigned);
  };
  A.or = function(a) {
    d(a) || (a = c(a));
    return e(this.low | a.low, this.high | a.high, this.unsigned);
  };
  A.xor = function(a) {
    d(a) || (a = c(a));
    return e(this.low ^ a.low, this.high ^ a.high, this.unsigned);
  };
  A.shiftLeft = function(a) {
    d(a) && (a = a.toInt());
    return 0 === (a &= 63) ? this : 32 > a ? e(this.low << a, this.high << a | this.low >>> 32 - a, this.unsigned) : e(0, this.low << a - 32, this.unsigned);
  };
  A.shl = A.shiftLeft;
  A.shiftRight = function(a) {
    d(a) && (a = a.toInt());
    return 0 === (a &= 63) ? this : 32 > a ? e(this.low >>> a | this.high << 32 - a, this.high >> a, this.unsigned) : e(this.high >> a - 32, 0 <= this.high ? 0 : -1, this.unsigned);
  };
  A.shr = A.shiftRight;
  A.shiftRightUnsigned = function(a) {
    d(a) && (a = a.toInt());
    a &= 63;
    if (0 === a) {
      return this;
    }
    var b = this.high;
    return 32 > a ? e(this.low >>> a | b << 32 - a, b >>> a, this.unsigned) : 32 === a ? e(b, 0, this.unsigned) : e(b >>> a - 32, 0, this.unsigned);
  };
  A.shru = A.shiftRightUnsigned;
  A.toSigned = function() {
    return this.unsigned ? e(this.low, this.high, !1) : this;
  };
  A.toUnsigned = function() {
    return this.unsigned ? this : e(this.low, this.high, !0);
  };
  A.toBytes = function(a) {
    return a ? this.toBytesLE() : this.toBytesBE();
  };
  A.toBytesLE = function() {
    var a = this.high, b = this.low;
    return [b & 255, b >>> 8 & 255, b >>> 16 & 255, b >>> 24 & 255, a & 255, a >>> 8 & 255, a >>> 16 & 255, a >>> 24 & 255];
  };
  A.toBytesBE = function() {
    var a = this.high, b = this.low;
    return [a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, a & 255, b >>> 24 & 255, b >>> 16 & 255, b >>> 8 & 255, b & 255];
  };
  return a;
});
(function(a) {
  function d(a) {
    if (!a) {
      throw Error("PSON requires ByteBuffer.js: Get it at https://github.com/dcodeIO/ByteBuffer.js");
    }
    var d = {T:{ZERO:0, MAX:239, NULL:240, TRUE:241, FALSE:242, EOBJECT:243, EARRAY:244, ESTRING:245, OBJECT:246, ARRAY:247, INTEGER:248, LONG:249, FLOAT:250, DOUBLE:251, STRING:252, STRING_ADD:253, STRING_GET:254, BINARY:255}};
    d.Encoder = function(a, d) {
      var c = new a(4);
      c.length = 4;
      var e = a.Long, k = function(a, c, b) {
        this.dict = {};
        this.next = 0;
        if (a && Array.isArray(a)) {
          for (; this.next < a.length;) {
            this.dict[a[this.next]] = this.next++;
          }
        }
        this.progressive = !!c;
        this.options = b || {};
      };
      k.prototype.encode = function(c, e) {
        var b = !1;
        e || (e = new a, b = !0);
        var d = e.littleEndian;
        try {
          return this._encodeValue(c, e.LE()), e.littleEndian = d, b ? e.flip() : e;
        } catch (q) {
          throw e.littleEndian = d, q;
        }
      };
      k.prototype._encodeValue = function(f, k, b) {
        if (null === f) {
          k.writeUint8(d.NULL);
        } else {
          switch(typeof f) {
            case "function":
              f = f.toString();
            case "string":
              0 === f.length ? k.writeUint8(d.ESTRING) : this.dict.hasOwnProperty(f) ? (k.writeUint8(d.STRING_GET), k.writeVarint32(this.dict[f])) : (k.writeUint8(d.STRING), k.writeVString(f));
              break;
            case "number":
              b = parseInt(f);
              f === b ? (b = a.zigZagEncode32(f), b <= d.MAX ? k.writeUint8(b) : (k.writeUint8(d.INTEGER), k.writeVarint32ZigZag(f))) : (c.writeFloat32(f, 0), f === c.readFloat32(0) ? (k.writeUint8(d.FLOAT), k.writeFloat32(f)) : (k.writeUint8(d.DOUBLE), k.writeFloat64(f)));
              break;
            case "boolean":
              k.writeUint8(f ? d.TRUE : d.FALSE);
              break;
            case "object":
              var m;
              if (Array.isArray(f)) {
                if (0 === f.length) {
                  k.writeUint8(d.EARRAY);
                } else {
                  for (k.writeUint8(d.ARRAY), k.writeVarint32(f.length), m = 0; m < f.length; m++) {
                    this._encodeValue(f[m], k);
                  }
                }
              } else {
                if (e && f instanceof e) {
                  k.writeUint8(d.LONG), k.writeVarint64ZigZag(f);
                } else {
                  try {
                    f = a.wrap(f), k.writeUint8(d.BINARY), k.writeVarint32(f.remaining()), k.append(f);
                  } catch (x) {
                    var h = Object.keys(f), g = 0;
                    for (m = 0; m < h.length; m++) {
                      "undefined" !== typeof f[h[m]] && g++;
                    }
                    if (0 === g) {
                      k.writeUint8(d.EOBJECT);
                    } else {
                      for (k.writeUint8(d.OBJECT), k.writeVarint32(g), b || (b = !!f._PSON_EXCL_), m = 0; m < h.length; m++) {
                        g = h[m], "undefined" !== typeof f[g] && (this.dict.hasOwnProperty(g) ? (k.writeUint8(d.STRING_GET), k.writeVarint32(this.dict[g])) : (this.progressive && !b ? (this.dict[g] = this.next++, k.writeUint8(d.STRING_ADD)) : k.writeUint8(d.STRING), k.writeVString(g)), this._encodeValue(f[g], k));
                      }
                    }
                  }
                }
              }
              break;
            case "undefined":
              k.writeUint8(d.NULL);
          }
        }
      };
      return k;
    }(a, d.T);
    d.Decoder = function(a, d) {
      var c = a.Long, e = function(a, c, e) {
        this.dict = a && Array.isArray(a) ? a : [];
        this.progressive = !!c;
        this.options = e || {};
      };
      e.prototype.decode = function(c) {
        c instanceof a || (c = a.wrap(c));
        var e = c.littleEndian;
        try {
          var d = this._decodeValue(c.LE());
          c.littleEndian = e;
          return d;
        } catch (b) {
          throw c.littleEndian = e, b;
        }
      };
      e.prototype._decodeValue = function(e) {
        var f = e.readUint8();
        if (f <= d.MAX) {
          return a.zigZagDecode32(f);
        }
        switch(f) {
          case d.NULL:
            return null;
          case d.TRUE:
            return !0;
          case d.FALSE:
            return !1;
          case d.EOBJECT:
            return {};
          case d.EARRAY:
            return [];
          case d.ESTRING:
            return "";
          case d.OBJECT:
            f = e.readVarint32();
            for (var k = {}; 0 <= --f;) {
              k[this._decodeValue(e)] = this._decodeValue(e);
            }
            return k;
          case d.ARRAY:
            f = e.readVarint32();
            for (k = []; 0 <= --f;) {
              k.push(this._decodeValue(e));
            }
            return k;
          case d.INTEGER:
            return e.readVarint32ZigZag();
          case d.LONG:
            return c ? e.readVarint64ZigZag() : e.readVarint32ZigZag();
          case d.FLOAT:
            return e.readFloat32();
          case d.DOUBLE:
            return e.readFloat64();
          case d.STRING:
            return e.readVString();
          case d.STRING_ADD:
            return e = e.readVString(), this.dict.push(e), e;
          case d.STRING_GET:
            return this.dict[e.readVarint32()];
          case d.BINARY:
            return f = e.readVarint32(), k = e.slice(e.offset, e.offset + f), e.offset += f, k;
          default:
            throw Error("Illegal type at " + e.offset + ": " + f);
        }
      };
      return e;
    }(a, d.T);
    d.Pair = function() {
      var a = function() {
      };
      a.prototype.encode = function(a) {
        return this.encoder.encode(a);
      };
      a.prototype.toArrayBuffer = function(a) {
        return this.encoder.encode(a).toArrayBuffer();
      };
      a.prototype.toBuffer = function(a) {
        return this.encoder.encode(a).toBuffer();
      };
      a.prototype.decode = function(a) {
        return this.decoder.decode(a);
      };
      return a;
    }();
    d.StaticPair = function(a, d, c) {
      var e = function(e, f) {
        a.call(this);
        this.encoder = new d(e, !1, f);
        this.decoder = new c(e, !1, f);
      };
      e.prototype = Object.create(a.prototype);
      return e;
    }(d.Pair, d.Encoder, d.Decoder);
    d.ProgressivePair = function(a, k, c) {
      var e = function(e, d) {
        a.call(this);
        this.encoder = new k(e, !0, d);
        this.decoder = new c(e, !0, d);
      };
      e.prototype = Object.create(a.prototype);
      e.prototype.exclude = function(a) {
        d.exclude(a);
      };
      e.prototype.include = function(a) {
        d.include(a);
      };
      return e;
    }(d.Pair, d.Encoder, d.Decoder);
    d.exclude = function(a) {
      "object" === typeof a && Object.defineProperty(a, "_PSON_EXCL_", {value:!0, enumerable:!1, configurable:!0});
    };
    d.include = function(a) {
      "object" === typeof a && delete a._PSON_EXCL_;
    };
    return d;
  }
  "undefined" != typeof module && module.exports ? module.exports = d(require("bytebuffer")) : "undefined" != typeof define && define.amd ? define("PSON", ["ByteBuffer"], d) : (a.dcodeIO || (a.dcodeIO = {}), a.dcodeIO.PSON = d(a.dcodeIO.ByteBuffer));
})(this);
function _typeof(a) {
  $jscomp.initSymbol();
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(a) {
    return typeof a;
  } : function(a) {
    $jscomp.initSymbol();
    $jscomp.initSymbol();
    $jscomp.initSymbol();
    return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
  }, _typeof(a);
}
(function(a, d) {
  "object" === ("undefined" == typeof exports ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? d(exports) : "function" == typeof define && define.amd ? define(["exports"], d) : (a = a || self, d(a.SPARSEOCTREE = {}));
})(this, function(a) {
  function d(a, b) {
    if (!(a instanceof b)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function g(a, b) {
    for (var c, e = 0; e < b.length; e++) {
      c = b[e], c.enumerable = c.enumerable || !1, c.configurable = !0, "value" in c && (c.writable = !0), Object.defineProperty(a, c.key, c);
    }
  }
  function h(a, b, c) {
    return b && g(a.prototype, b), c && g(a, c), a;
  }
  function e(a, b) {
    if ("function" != typeof b && null !== b) {
      throw new TypeError("Super expression must either be null or a function");
    }
    a.prototype = Object.create(b && b.prototype, {constructor:{value:a, writable:!0, configurable:!0}});
    b && c(a, b);
  }
  function k(a) {
    return k = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
      return a.__proto__ || Object.getPrototypeOf(a);
    }, k(a);
  }
  function c(a, b) {
    return c = Object.setPrototypeOf || function(a, b) {
      return a.__proto__ = b, a;
    }, c(a, b);
  }
  function p(a, b) {
    if (!b || "object" !== _typeof(b) && "function" != typeof b) {
      if (void 0 === a) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
    } else {
      a = b;
    }
    return a;
  }
  function t(a, b, c) {
    return t = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(a, b, c) {
      for (; !Object.prototype.hasOwnProperty.call(a, b) && (a = k(a), null !== a);) {
      }
      if (a) {
        return b = Object.getOwnPropertyDescriptor(a, b), b.get ? b.get.call(c) : b.value;
      }
    }, t(a, b, c || a);
  }
  function f(a) {
    if (Array.isArray(a)) {
      var b = 0;
      for (var c = Array(a.length); b < a.length; b++) {
        c[b] = a[b];
      }
      b = c;
    } else {
      b = void 0;
    }
    b || ($jscomp.initSymbol(), $jscomp.initSymbolIterator(), b = Symbol.iterator in Object(a) || "[object Arguments]" === Object.prototype.toString.call(a) ? Array.from(a) : void 0);
    if (!(a = b)) {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }
    return a;
  }
  function n(a, b, c, e) {
    var d, f = 0;
    return b < c ? (d = b, f = 0) : (d = c, f = 1), e < d && (f = 2), Sa[a][f];
  }
  function b(a, c, e, d, f, m, k, h, g) {
    var r = a.children;
    if (0 <= f && 0 <= m && 0 <= k) {
      if (null === r) {
        g.push(a);
      } else {
        var p = .5 * (c + f);
        var u = .5 * (e + m);
        var q = .5 * (d + k);
        var t = 0;
        a = (c > e && c > d ? (u < c && (t |= 2), q < c && (t |= 1)) : e > d ? (p < e && (t |= 4), q < e && (t |= 1)) : (p < d && (t |= 4), u < d && (t |= 2)), t);
        do {
          0 === a ? (b(r[za], c, e, d, p, u, q, h, g), a = n(a, p, u, q)) : 1 === a ? (b(r[1 ^ za], c, e, q, p, u, k, h, g), a = n(a, p, u, k)) : 2 === a ? (b(r[2 ^ za], c, u, d, p, m, q, h, g), a = n(a, p, m, q)) : 3 === a ? (b(r[3 ^ za], c, u, q, p, m, k, h, g), a = n(a, p, m, k)) : 4 === a ? (b(r[4 ^ za], p, e, d, f, u, q, h, g), a = n(a, f, u, q)) : 5 === a ? (b(r[5 ^ za], p, e, q, f, u, k, h, g), a = n(a, f, u, k)) : 6 === a ? (b(r[6 ^ za], p, u, d, f, m, q, h, g), a = n(a, f, m, q)) : 7 === 
          a ? (b(r[7 ^ za], p, u, q, f, m, k, h, g), a = 8) : void 0;
        } while (8 > a);
      }
    }
  }
  function m(a) {
    var b, c = a.children, e = 0;
    if (null !== c) {
      for (a = 0, b = c.length; a < b; ++a) {
        var d = 1 + m(c[a]);
        d > e && (e = d);
      }
    }
    return e;
  }
  function q(a, b, c) {
    var e, d = a.children;
    if (Oa.min = a.min, Oa.max = a.max, b.intersectsBox(Oa)) {
      if (null !== d) {
        for (a = 0, e = d.length; a < e; ++a) {
          q(d[a], b, c);
        }
      } else {
        c.push(a);
      }
    }
  }
  function y(a, b, c, e) {
    var d, f = a.children;
    if (c === b) {
      e.push(a);
    } else {
      if (null !== f) {
        for (++c, a = 0, d = f.length; a < d; ++a) {
          y(f[a], b, c, e);
        }
      }
    }
  }
  function x(a) {
    var b, c = a.children, e = 0;
    if (null !== c) {
      for (a = 0, b = c.length; a < b; ++a) {
        e += x(c[a]);
      }
    } else {
      null !== a.points && (e = a.points.length);
    }
    return e;
  }
  function z(a, b, c, e, d) {
    var f, m = e.children, k = !1, h = !1;
    if (e.contains(a, c.bias)) {
      if (null === m) {
        if (null === e.points) {
          e.points = [], e.data = [];
        } else {
          var g = 0;
          for (f = e.points.length; !k && g < f; ++g) {
            k = e.points[g].equals(a);
          }
        }
        k ? (e.data[g - 1] = b, h = !0) : e.points.length < c.maxPoints || d === c.maxDepth ? (e.points.push(a.clone()), e.data.push(b), ++c.pointCount, h = !0) : (e.split(), e.redistribute(c.bias), m = e.children);
      }
      if (null !== m) {
        for (++d, g = 0, f = m.length; !h && g < f; ++g) {
          h = z(a, b, c, m[g], d);
        }
      }
    }
    return h;
  }
  function r(a, b, c, e) {
    var d;
    var f = c.children;
    var m = null;
    if (c.contains(a, b.bias)) {
      if (null !== f) {
        var k = 0;
        for (d = f.length; null === m && k < d; ++k) {
          m = r(a, b, f[k], c);
        }
      } else {
        if (null !== c.points) {
          for (f = c.points, c = c.data, k = 0, d = f.length; k < d; ++k) {
            if (f[k].equals(a)) {
              a = d - 1;
              m = c[k];
              k < a && (f[k] = f[a], c[k] = c[a]);
              f.pop();
              c.pop();
              --b.pointCount;
              null !== e && x(e) <= b.maxPoints && e.merge();
              break;
            }
          }
        }
      }
    }
    return m;
  }
  function u(a, b, c) {
    var e, d = c.children, f = null;
    if (c.contains(a, b.bias)) {
      if (null !== d) {
        var m = 0;
        for (e = d.length; null === f && m < e; ++m) {
          f = u(a, b, d[m]);
        }
      } else {
        if (null !== c.points) {
          for (b = c.points, m = 0, e = b.length; null === f && m < e; ++m) {
            a.equals(b[m]) && (f = c.data[m]);
          }
        }
      }
    }
    return f;
  }
  function v(a, b, c, e, d, f) {
    var m, k = e.children, h = null;
    if (e.contains(a, c.bias)) {
      if (!e.contains(b, c.bias)) {
        h = r(a, c, e, d), z(b, h, c, d, f - 1);
      } else {
        if (null !== k) {
          for (++f, d = 0, m = k.length; null === h && d < m; ++d) {
            h = v(a, b, c, k[d], e, f);
          }
        } else {
          if (null !== e.points) {
            for (c = e.points, d = 0, m = c.length; d < m; ++d) {
              if (a.equals(c[d])) {
                c[d].copy(b);
                h = e.data[d];
                break;
              }
            }
          }
        }
      }
    }
    return h;
  }
  function C(a, b, c, e) {
    var d, f = null, m = b;
    if (null !== e.children) {
      var k, h;
      e = e.children.map(function(b) {
        return {octant:b, distance:b.distanceToCenterSquared(a)};
      }).sort(function(a, b) {
        return a.distance - b.distance;
      });
      b = 0;
      for (d = e.length; b < d && (k = e[b].octant, !k.contains(a, m) || (h = C(a, m, c, k), null === h || (m = h.distance, f = h, 0 !== m))); ++b) {
      }
    } else {
      if (null !== e.points) {
        h = e.points;
        var g = -1;
        b = 0;
        for (d = h.length; b < d; ++b) {
          if (!h[b].equals(a)) {
            k = a.distanceTo(h[b]), k < m && (m = k, g = b);
          } else {
            if (!c) {
              m = 0;
              g = b;
              break;
            }
          }
        }
        0 <= g && (f = {point:h[g], data:e.data[g], distance:m});
      }
    }
    return f;
  }
  function A(a, b, c, e, d) {
    var f, m = e.children;
    if (null !== m) {
      var k = 0;
      for (f = m.length; k < f; ++k) {
        e = m[k], e.contains(a, b) && A(a, b, c, e, d);
      }
    } else {
      if (null !== e.points) {
        var h = e.points;
        k = 0;
        for (f = h.length; k < f; ++k) {
          m = h[k], m.equals(a) ? !c && d.push({point:m.clone(), data:e.data[k]}) : m.distanceToSquared(a) <= b * b && d.push({point:m.clone(), data:e.data[k]});
        }
      }
    }
  }
  var D = Math.PI, F = Math.atan2, B = Math.round, E = Math.ceil, H = Math.floor, L = Math.abs, K = Math.acos, P = Math.sqrt, J = Math.cos, I = Math.sin, N = Math.max, S = Math.min, Q = function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, e = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
      d(this, a);
      this.x = b;
      this.y = c;
      this.z = e;
    }
    return h(a, [{key:"set", value:function(a, b, c) {
      return this.x = a, this.y = b, this.z = c, this;
    }}, {key:"copy", value:function(a) {
      return this.x = a.x, this.y = a.y, this.z = a.z, this;
    }}, {key:"clone", value:function() {
      return new this.constructor(this.x, this.y, this.z);
    }}, {key:"fromArray", value:function(a) {
      var b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
      return this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this;
    }}, {key:"toArray", value:function() {
      var a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [], b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
      return a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a;
    }}, {key:"setFromSpherical", value:function(a) {
      this.setFromSphericalCoords(a.radius, a.phi, a.theta);
    }}, {key:"setFromSphericalCoords", value:function(a, b, c) {
      var e = I(b) * a;
      return this.x = e * I(c), this.y = J(b) * a, this.z = e * J(c), this;
    }}, {key:"setFromCylindrical", value:function(a) {
      this.setFromCylindricalCoords(a.radius, a.theta, a.y);
    }}, {key:"setFromCylindricalCoords", value:function(a, b, c) {
      return this.x = a * I(b), this.y = c, this.z = a * J(b), this;
    }}, {key:"setFromMatrixColumn", value:function(a, b) {
      return this.fromArray(a.elements, 4 * b);
    }}, {key:"setFromMatrixPosition", value:function(a) {
      a = a.elements;
      return this.x = a[12], this.y = a[13], this.z = a[14], this;
    }}, {key:"setFromMatrixScale", value:function(a) {
      var b = this.setFromMatrixColumn(a, 0).length(), c = this.setFromMatrixColumn(a, 1).length();
      a = this.setFromMatrixColumn(a, 2).length();
      return this.x = b, this.y = c, this.z = a, this;
    }}, {key:"add", value:function(a) {
      return this.x += a.x, this.y += a.y, this.z += a.z, this;
    }}, {key:"addScalar", value:function(a) {
      return this.x += a, this.y += a, this.z += a, this;
    }}, {key:"addVectors", value:function(a, b) {
      return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this;
    }}, {key:"addScaledVector", value:function(a, b) {
      return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this;
    }}, {key:"sub", value:function(a) {
      return this.x -= a.x, this.y -= a.y, this.z -= a.z, this;
    }}, {key:"subScalar", value:function(a) {
      return this.x -= a, this.y -= a, this.z -= a, this;
    }}, {key:"subVectors", value:function(a, b) {
      return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this;
    }}, {key:"multiply", value:function(a) {
      return this.x *= a.x, this.y *= a.y, this.z *= a.z, this;
    }}, {key:"multiplyScalar", value:function(a) {
      return this.x *= a, this.y *= a, this.z *= a, this;
    }}, {key:"multiplyVectors", value:function(a, b) {
      return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this;
    }}, {key:"divide", value:function(a) {
      return this.x /= a.x, this.y /= a.y, this.z /= a.z, this;
    }}, {key:"divideScalar", value:function(a) {
      return this.x /= a, this.y /= a, this.z /= a, this;
    }}, {key:"crossVectors", value:function(a, b) {
      var c = a.x, e = a.y;
      a = a.z;
      var d = b.x, f = b.y;
      b = b.z;
      return this.x = e * b - a * f, this.y = a * d - c * b, this.z = c * f - e * d, this;
    }}, {key:"cross", value:function(a) {
      return this.crossVectors(this, a);
    }}, {key:"transformDirection", value:function(a) {
      var b = this.x, c = this.y, e = this.z;
      a = a.elements;
      return this.x = a[0] * b + a[4] * c + a[8] * e, this.y = a[1] * b + a[5] * c + a[9] * e, this.z = a[2] * b + a[6] * c + a[10] * e, this.normalize();
    }}, {key:"applyMatrix3", value:function(a) {
      var b = this.x, c = this.y, e = this.z;
      a = a.elements;
      return this.x = a[0] * b + a[3] * c + a[6] * e, this.y = a[1] * b + a[4] * c + a[7] * e, this.z = a[2] * b + a[5] * c + a[8] * e, this;
    }}, {key:"applyMatrix4", value:function(a) {
      var b = this.x, c = this.y, e = this.z;
      a = a.elements;
      return this.x = a[0] * b + a[4] * c + a[8] * e + a[12], this.y = a[1] * b + a[5] * c + a[9] * e + a[13], this.z = a[2] * b + a[6] * c + a[10] * e + a[14], this;
    }}, {key:"applyQuaternion", value:function(a) {
      var b = this.x, c = this.y, e = this.z, d = a.x, f = a.y, m = a.z;
      a = a.w;
      var k = a * b + f * e - m * c, h = a * c + m * b - d * e, g = a * e + d * c - f * b;
      b = -d * b - f * c - m * e;
      return this.x = k * a + b * -d + h * -m - g * -f, this.y = h * a + b * -f + g * -d - k * -m, this.z = g * a + b * -m + k * -f - h * -d, this;
    }}, {key:"negate", value:function() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }}, {key:"dot", value:function(a) {
      return this.x * a.x + this.y * a.y + this.z * a.z;
    }}, {key:"reflect", value:function(a) {
      var b = a.x, c = a.y, e = a.z;
      return this.sub(a.multiplyScalar(2 * this.dot(a))), a.set(b, c, e), this;
    }}, {key:"angleTo", value:function(a) {
      a = this.dot(a) / P(this.lengthSquared() * a.lengthSquared());
      return K(S(N(a, -1), 1));
    }}, {key:"manhattanLength", value:function() {
      return L(this.x) + L(this.y) + L(this.z);
    }}, {key:"lengthSquared", value:function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }}, {key:"length", value:function() {
      return P(this.x * this.x + this.y * this.y + this.z * this.z);
    }}, {key:"manhattanDistanceTo", value:function(a) {
      return L(this.x - a.x) + L(this.y - a.y) + L(this.z - a.z);
    }}, {key:"distanceToSquared", value:function(a) {
      var b = this.x - a.x, c = this.y - a.y;
      a = this.z - a.z;
      return b * b + c * c + a * a;
    }}, {key:"distanceTo", value:function(a) {
      return P(this.distanceToSquared(a));
    }}, {key:"normalize", value:function() {
      return this.divideScalar(this.length());
    }}, {key:"setLength", value:function(a) {
      return this.normalize().multiplyScalar(a);
    }}, {key:"min", value:function(a) {
      return this.x = S(this.x, a.x), this.y = S(this.y, a.y), this.z = S(this.z, a.z), this;
    }}, {key:"max", value:function(a) {
      return this.x = N(this.x, a.x), this.y = N(this.y, a.y), this.z = N(this.z, a.z), this;
    }}, {key:"clamp", value:function(a, b) {
      return this.x = N(a.x, S(b.x, this.x)), this.y = N(a.y, S(b.y, this.y)), this.z = N(a.z, S(b.z, this.z)), this;
    }}, {key:"floor", value:function() {
      return this.x = H(this.x), this.y = H(this.y), this.z = H(this.z), this;
    }}, {key:"ceil", value:function() {
      return this.x = E(this.x), this.y = E(this.y), this.z = E(this.z), this;
    }}, {key:"round", value:function() {
      return this.x = B(this.x), this.y = B(this.y), this.z = B(this.z), this;
    }}, {key:"lerp", value:function(a, b) {
      return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, this;
    }}, {key:"lerpVectors", value:function(a, b, c) {
      return this.subVectors(b, a).multiplyScalar(c).add(a);
    }}, {key:"equals", value:function(a) {
      return a.x === this.x && a.y === this.y && a.z === this.z;
    }}]), a;
  }(), Z = new Q, R = [new Q, new Q, new Q, new Q, new Q, new Q, new Q, new Q], W = function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q(1 / 0, 1 / 0, 1 / 0), c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Q(-Infinity, -Infinity, -Infinity);
      d(this, a);
      this.min = b;
      this.max = c;
    }
    return h(a, [{key:"set", value:function(a, b) {
      return this.min.copy(a), this.max.copy(b), this;
    }}, {key:"copy", value:function(a) {
      return this.min.copy(a.min), this.max.copy(a.max), this;
    }}, {key:"clone", value:function() {
      return (new this.constructor).copy(this);
    }}, {key:"makeEmpty", value:function() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -Infinity, this;
    }}, {key:"isEmpty", value:function() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }}, {key:"getCenter", value:function() {
      var a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q;
      return this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5);
    }}, {key:"getSize", value:function() {
      var a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q;
      return this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min);
    }}, {key:"setFromSphere", value:function(a) {
      return this.set(a.center, a.center), this.expandByScalar(a.radius), this;
    }}, {key:"expandByPoint", value:function(a) {
      return this.min.min(a), this.max.max(a), this;
    }}, {key:"expandByVector", value:function(a) {
      return this.min.sub(a), this.max.add(a), this;
    }}, {key:"expandByScalar", value:function(a) {
      return this.min.addScalar(-a), this.max.addScalar(a), this;
    }}, {key:"setFromPoints", value:function(a) {
      var b;
      this.min.set(0, 0, 0);
      this.max.set(0, 0, 0);
      var c = 0;
      for (b = a.length; c < b; ++c) {
        this.expandByPoint(a[c]);
      }
      return this;
    }}, {key:"setFromCenterAndSize", value:function(a, b) {
      b = Z.copy(b).multiplyScalar(.5);
      return this.min.copy(a).sub(b), this.max.copy(a).add(b), this;
    }}, {key:"clampPoint", value:function(a) {
      return (1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Q).copy(a).clamp(this.min, this.max);
    }}, {key:"distanceToPoint", value:function(a) {
      return Z.copy(a).clamp(this.min, this.max).sub(a).length();
    }}, {key:"applyMatrix4", value:function(a) {
      var b = this.min, c = this.max;
      return this.isEmpty() || (R[0].set(b.x, b.y, b.z).applyMatrix4(a), R[1].set(b.x, b.y, c.z).applyMatrix4(a), R[2].set(b.x, c.y, b.z).applyMatrix4(a), R[3].set(b.x, c.y, c.z).applyMatrix4(a), R[4].set(c.x, b.y, b.z).applyMatrix4(a), R[5].set(c.x, b.y, c.z).applyMatrix4(a), R[6].set(c.x, c.y, b.z).applyMatrix4(a), R[7].set(c.x, c.y, c.z).applyMatrix4(a), this.setFromPoints(R)), this;
    }}, {key:"translate", value:function(a) {
      return this.min.add(a), this.max.add(a), this;
    }}, {key:"intersect", value:function(a) {
      return this.min.max(a.min), this.max.min(a.max), this.isEmpty() && this.makeEmpty(), this;
    }}, {key:"union", value:function(a) {
      return this.min.min(a.min), this.max.max(a.max), this;
    }}, {key:"containsPoint", value:function(a) {
      var b = this.min, c = this.max;
      return a.x >= b.x && a.y >= b.y && a.z >= b.z && a.x <= c.x && a.y <= c.y && a.z <= c.z;
    }}, {key:"containsBox", value:function(a) {
      var b = this.min, c = this.max, e = a.min;
      a = a.max;
      return b.x <= e.x && a.x <= c.x && b.y <= e.y && a.y <= c.y && b.z <= e.z && a.z <= c.z;
    }}, {key:"intersectsBox", value:function(a) {
      var b = this.min, c = this.max, e = a.min;
      a = a.max;
      return a.x >= b.x && a.y >= b.y && a.z >= b.z && e.x <= c.x && e.y <= c.y && e.z <= c.z;
    }}, {key:"intersectsSphere", value:function(a) {
      return this.clampPoint(a.center, Z).distanceToSquared(a.center) <= a.radius * a.radius;
    }}, {key:"intersectsPlane", value:function(a) {
      var b, c;
      return 0 < a.normal.x ? (b = a.normal.x * this.min.x, c = a.normal.x * this.max.x) : (b = a.normal.x * this.max.x, c = a.normal.x * this.min.x), 0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y), 0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z), b <= -a.constant && c >= -a.constant;
    }}, {key:"equals", value:function(a) {
      return a.min.equals(this.min) && a.max.equals(this.max);
    }}]), a;
  }(), O = new W, ca = new Q, M = function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
      d(this, a);
      this.center = b;
      this.radius = c;
    }
    return h(a, [{key:"set", value:function(a, b) {
      return this.center.copy(a), this.radius = b, this;
    }}, {key:"copy", value:function(a) {
      return this.center.copy(a.center), this.radius = a.radius, this;
    }}, {key:"clone", value:function() {
      return (new this.constructor).copy(this);
    }}, {key:"setFromPoints", value:function(a) {
      var b, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : O.setFromPoints(a).getCenter(this.center), e = 0;
      var d = 0;
      for (b = a.length; d < b; ++d) {
        e = N(e, c.distanceToSquared(a[d]));
      }
      return this.radius = P(e), this;
    }}, {key:"setFromBox", value:function(a) {
      return a.getCenter(this.center), this.radius = .5 * a.getSize(ca).length(), this;
    }}, {key:"isEmpty", value:function() {
      return 0 >= this.radius;
    }}, {key:"translate", value:function(a) {
      return this.center.add(a), this;
    }}, {key:"clampPoint", value:function(a) {
      var b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Q, c = this.center.distanceToSquared(a);
      return b.copy(a), c > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center)), b;
    }}, {key:"distanceToPoint", value:function(a) {
      return a.distanceTo(this.center) - this.radius;
    }}, {key:"containsPoint", value:function(a) {
      return a.distanceToSquared(this.center) <= this.radius * this.radius;
    }}, {key:"intersectsSphere", value:function(a) {
      var b = this.radius + a.radius;
      return a.center.distanceToSquared(this.center) <= b * b;
    }}, {key:"intersectsBox", value:function(a) {
      return a.intersectsSphere(this);
    }}, {key:"intersectsPlane", value:function(a) {
      return L(a.distanceToPoint(this.center)) <= this.radius;
    }}, {key:"equals", value:function(a) {
      return a.center.equals(this.center) && a.radius === this.radius;
    }}]), a;
  }(), V = function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
      d(this, a);
      this.x = b;
      this.y = c;
    }
    return h(a, [{key:"set", value:function(a, b) {
      return this.x = a, this.y = b, this;
    }}, {key:"copy", value:function(a) {
      return this.x = a.x, this.y = a.y, this;
    }}, {key:"clone", value:function() {
      return new this.constructor(this.x, this.y);
    }}, {key:"fromArray", value:function(a) {
      var b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
      return this.x = a[b], this.y = a[b + 1], this;
    }}, {key:"toArray", value:function() {
      var a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [], b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
      return a[b] = this.x, a[b + 1] = this.y, a;
    }}, {key:"add", value:function(a) {
      return this.x += a.x, this.y += a.y, this;
    }}, {key:"addScalar", value:function(a) {
      return this.x += a, this.y += a, this;
    }}, {key:"addVectors", value:function(a, b) {
      return this.x = a.x + b.x, this.y = a.y + b.y, this;
    }}, {key:"addScaledVector", value:function(a, b) {
      return this.x += a.x * b, this.y += a.y * b, this;
    }}, {key:"sub", value:function(a) {
      return this.x -= a.x, this.y -= a.y, this;
    }}, {key:"subScalar", value:function(a) {
      return this.x -= a, this.y -= a, this;
    }}, {key:"subVectors", value:function(a, b) {
      return this.x = a.x - b.x, this.y = a.y - b.y, this;
    }}, {key:"multiply", value:function(a) {
      return this.x *= a.x, this.y *= a.y, this;
    }}, {key:"multiplyScalar", value:function(a) {
      return this.x *= a, this.y *= a, this;
    }}, {key:"divide", value:function(a) {
      return this.x /= a.x, this.y /= a.y, this;
    }}, {key:"divideScalar", value:function(a) {
      return this.x /= a, this.y /= a, this;
    }}, {key:"applyMatrix3", value:function(a) {
      var b = this.x, c = this.y;
      a = a.elements;
      return this.x = a[0] * b + a[3] * c + a[6], this.y = a[1] * b + a[4] * c + a[7], this;
    }}, {key:"dot", value:function(a) {
      return this.x * a.x + this.y * a.y;
    }}, {key:"cross", value:function(a) {
      return this.x * a.y - this.y * a.x;
    }}, {key:"manhattanLength", value:function() {
      return L(this.x) + L(this.y);
    }}, {key:"lengthSquared", value:function() {
      return this.x * this.x + this.y * this.y;
    }}, {key:"length", value:function() {
      return P(this.x * this.x + this.y * this.y);
    }}, {key:"manhattanDistanceTo", value:function(a) {
      return L(this.x - a.x) + L(this.y - a.y);
    }}, {key:"distanceToSquared", value:function(a) {
      var b = this.x - a.x;
      a = this.y - a.y;
      return b * b + a * a;
    }}, {key:"distanceTo", value:function(a) {
      return P(this.distanceToSquared(a));
    }}, {key:"normalize", value:function() {
      return this.divideScalar(this.length());
    }}, {key:"setLength", value:function(a) {
      return this.normalize().multiplyScalar(a);
    }}, {key:"min", value:function(a) {
      return this.x = S(this.x, a.x), this.y = S(this.y, a.y), this;
    }}, {key:"max", value:function(a) {
      return this.x = N(this.x, a.x), this.y = N(this.y, a.y), this;
    }}, {key:"clamp", value:function(a, b) {
      return this.x = N(a.x, S(b.x, this.x)), this.y = N(a.y, S(b.y, this.y)), this;
    }}, {key:"floor", value:function() {
      return this.x = H(this.x), this.y = H(this.y), this;
    }}, {key:"ceil", value:function() {
      return this.x = E(this.x), this.y = E(this.y), this;
    }}, {key:"round", value:function() {
      return this.x = B(this.x), this.y = B(this.y), this;
    }}, {key:"negate", value:function() {
      return this.x = -this.x, this.y = -this.y, this;
    }}, {key:"angle", value:function() {
      var a = F(this.y, this.x);
      return 0 > a && (a += 2 * D), a;
    }}, {key:"lerp", value:function(a, b) {
      return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this;
    }}, {key:"lerpVectors", value:function(a, b, c) {
      return this.subVectors(b, a).multiplyScalar(c).add(a);
    }}, {key:"rotateAround", value:function(a, b) {
      var c = J(b);
      b = I(b);
      var e = this.x - a.x, d = this.y - a.y;
      return this.x = e * c - d * b + a.x, this.y = e * b + d * c + a.y, this;
    }}, {key:"equals", value:function(a) {
      return a.x === this.x && a.y === this.y;
    }}, {key:"width", get:function() {
      return this.x;
    }, set:function(a) {
      return this.x = a;
    }}, {key:"height", get:function() {
      return this.y;
    }, set:function(a) {
      return this.y = a;
    }}]), a;
  }(), fa = new V;
  (function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new V(1 / 0, 1 / 0), c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new V(-Infinity, -Infinity);
      d(this, a);
      this.min = b;
      this.max = c;
    }
    return h(a, [{key:"set", value:function(a, b) {
      return this.min.copy(a), this.max.copy(b), this;
    }}, {key:"copy", value:function(a) {
      return this.min.copy(a.min), this.max.copy(a.max), this;
    }}, {key:"clone", value:function() {
      return (new this.constructor).copy(this);
    }}, {key:"makeEmpty", value:function() {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -Infinity, this;
    }}, {key:"isEmpty", value:function() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }}, {key:"getCenter", value:function() {
      var a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new V;
      return this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5);
    }}, {key:"getSize", value:function() {
      var a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new V;
      return this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min);
    }}, {key:"getBoundingSphere", value:function() {
      var a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new M;
      return this.getCenter(a.center), a.radius = .5 * this.getSize(fa).length(), a;
    }}, {key:"expandByPoint", value:function(a) {
      return this.min.min(a), this.max.max(a), this;
    }}, {key:"expandByVector", value:function(a) {
      return this.min.sub(a), this.max.add(a), this;
    }}, {key:"expandByScalar", value:function(a) {
      return this.min.addScalar(-a), this.max.addScalar(a), this;
    }}, {key:"setFromPoints", value:function(a) {
      var b;
      this.min.set(0, 0);
      this.max.set(0, 0);
      var c = 0;
      for (b = a.length; c < b; ++c) {
        this.expandByPoint(a[c]);
      }
      return this;
    }}, {key:"setFromCenterAndSize", value:function(a, b) {
      b = fa.copy(b).multiplyScalar(.5);
      return this.min.copy(a).sub(b), this.max.copy(a).add(b), this;
    }}, {key:"clampPoint", value:function(a) {
      return (1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new V).copy(a).clamp(this.min, this.max);
    }}, {key:"distanceToPoint", value:function(a) {
      return fa.copy(a).clamp(this.min, this.max).sub(a).length();
    }}, {key:"translate", value:function(a) {
      return this.min.add(a), this.max.add(a), this;
    }}, {key:"intersect", value:function(a) {
      return this.min.max(a.min), this.max.min(a.max), this.isEmpty() && this.makeEmpty(), this;
    }}, {key:"union", value:function(a) {
      return this.min.min(a.min), this.max.max(a.max), this;
    }}, {key:"containsPoint", value:function(a) {
      var b = this.min, c = this.max;
      return a.x >= b.x && a.y >= b.y && a.x <= c.x && a.y <= c.y;
    }}, {key:"containsBox", value:function(a) {
      var b = this.min, c = this.max, e = a.min;
      a = a.max;
      return b.x <= e.x && a.x <= c.x && b.y <= e.y && a.y <= c.y;
    }}, {key:"intersectsBox", value:function(a) {
      var b = this.min, c = this.max, e = a.min;
      a = a.max;
      return a.x >= b.x && a.y >= b.y && e.x <= c.x && e.y <= c.y;
    }}, {key:"equals", value:function(a) {
      return a.min.equals(this.min) && a.max.equals(this.max);
    }}]), a;
  })();
  (function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, e = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
      d(this, a);
      this.radius = b;
      this.theta = c;
      this.y = e;
    }
    return h(a, [{key:"set", value:function(a, b, c) {
      return this.radius = a, this.theta = b, this.y = c, this;
    }}, {key:"copy", value:function(a) {
      return this.radius = a.radius, this.theta = a.theta, this.y = a.y, this;
    }}, {key:"clone", value:function() {
      return (new this.constructor).copy(this);
    }}, {key:"setFromVector3", value:function(a) {
      return this.setFromCartesianCoords(a.x, a.y, a.z);
    }}, {key:"setFromCartesianCoords", value:function(a, b, c) {
      return this.radius = P(a * a + c * c), this.theta = F(a, c), this.y = b, this;
    }}]), a;
  })();
  var ja = function() {
    function a() {
      d(this, a);
      this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    }
    return h(a, [{key:"set", value:function(a, b, c, e, d, f, m, k, h) {
      var g = this.elements;
      return g[0] = a, g[3] = b, g[6] = c, g[1] = e, g[4] = d, g[7] = f, g[2] = m, g[5] = k, g[8] = h, this;
    }}, {key:"identity", value:function() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }}, {key:"copy", value:function(a) {
      a = a.elements;
      var b = this.elements;
      return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], this;
    }}, {key:"clone", value:function() {
      return (new this.constructor).fromArray(this.elements);
    }}, {key:"fromArray", value:function(a) {
      var b, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, e = this.elements;
      for (b = 0; 9 > b; ++b) {
        e[b] = a[b + c];
      }
      return this;
    }}, {key:"toArray", value:function() {
      var a, b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [], c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, e = this.elements;
      for (a = 0; 9 > a; ++a) {
        b[a + c] = e[a];
      }
      return b;
    }}, {key:"multiplyMatrices", value:function(a, b) {
      var c = a.elements, e = b.elements;
      b = this.elements;
      a = c[0];
      var d = c[3], f = c[6], m = c[1], k = c[4], h = c[7], g = c[2], r = c[5];
      c = c[8];
      var n = e[0], p = e[3], u = e[6], q = e[1], t = e[4], v = e[7], y = e[2], x = e[5];
      e = e[8];
      return b[0] = a * n + d * q + f * y, b[3] = a * p + d * t + f * x, b[6] = a * u + d * v + f * e, b[1] = m * n + k * q + h * y, b[4] = m * p + k * t + h * x, b[7] = m * u + k * v + h * e, b[2] = g * n + r * q + c * y, b[5] = g * p + r * t + c * x, b[8] = g * u + r * v + c * e, this;
    }}, {key:"multiply", value:function(a) {
      return this.multiplyMatrices(this, a);
    }}, {key:"premultiply", value:function(a) {
      return this.multiplyMatrices(a, this);
    }}, {key:"multiplyScalar", value:function(a) {
      var b = this.elements;
      return b[0] *= a, b[3] *= a, b[6] *= a, b[1] *= a, b[4] *= a, b[7] *= a, b[2] *= a, b[5] *= a, b[8] *= a, this;
    }}, {key:"determinant", value:function() {
      var a = this.elements, b = a[0], c = a[1], e = a[2], d = a[3], f = a[4], m = a[5], k = a[6], h = a[7];
      a = a[8];
      return b * f * a - b * m * h - c * d * a + c * m * k + e * d * h - e * f * k;
    }}, {key:"getInverse", value:function(a) {
      var b, c = a.elements, e = this.elements, d = c[0], f = c[1], m = c[2], k = c[3], h = c[4], g = c[5], r = c[6], n = c[7];
      c = c[8];
      var p = c * h - g * n, u = g * r - c * k, q = n * k - h * r, t = d * p + f * u + m * q;
      return 0 === t ? (console.error("Can't invert matrix, determinant is zero", a), this.identity()) : (b = 1 / t, e[0] = p * b, e[1] = (m * n - c * f) * b, e[2] = (g * f - m * h) * b, e[3] = u * b, e[4] = (c * d - m * r) * b, e[5] = (m * k - g * d) * b, e[6] = q * b, e[7] = (f * r - n * d) * b, e[8] = (h * d - f * k) * b), this;
    }}, {key:"transpose", value:function() {
      var a, b = this.elements;
      return a = b[1], b[1] = b[3], b[3] = a, a = b[2], b[2] = b[6], b[6] = a, a = b[5], b[5] = b[7], b[7] = a, this;
    }}, {key:"scale", value:function(a, b) {
      var c = this.elements;
      return c[0] *= a, c[3] *= a, c[6] *= a, c[1] *= b, c[4] *= b, c[7] *= b, this;
    }}, {key:"rotate", value:function(a) {
      var b = J(a);
      a = I(a);
      var c = this.elements, e = c[0], d = c[3], f = c[6], m = c[1], k = c[4], h = c[7];
      return c[0] = b * e + a * m, c[3] = b * d + a * k, c[6] = b * f + a * h, c[1] = -a * e + b * m, c[4] = -a * d + b * k, c[7] = -a * f + b * h, this;
    }}, {key:"translate", value:function(a, b) {
      var c = this.elements;
      return c[0] += a * c[2], c[3] += a * c[5], c[6] += a * c[8], c[1] += b * c[2], c[4] += b * c[5], c[7] += b * c[8], this;
    }}, {key:"equals", value:function(a) {
      var b = this.elements, c = a.elements, e = !0;
      for (a = 0; e && 9 > a; ++a) {
        b[a] !== c[a] && (e = !1);
      }
      return e;
    }}]), a;
  }(), X = new Q, ea = function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, e = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, f = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0;
      d(this, a);
      this.x = b;
      this.y = c;
      this.z = e;
      this.w = f;
    }
    var b = Number.EPSILON;
    return h(a, [{key:"set", value:function(a, b, c, e) {
      return this.x = a, this.y = b, this.z = c, this.w = e, this;
    }}, {key:"copy", value:function(a) {
      return this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w, this;
    }}, {key:"clone", value:function() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }}, {key:"fromArray", value:function(a) {
      var b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
      return this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this.w = a[b + 3], this;
    }}, {key:"toArray", value:function() {
      var a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [], b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
      return a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a[b + 3] = this.w, a;
    }}, {key:"setFromEuler", value:function(a) {
      var b = a.x, c = a.y, e = a.z, d = J(b / 2), f = J(c / 2), m = J(e / 2);
      b = I(b / 2);
      c = I(c / 2);
      e = I(e / 2);
      switch(a.order) {
        case "XYZ":
          this.x = b * f * m + d * c * e;
          this.y = d * c * m - b * f * e;
          this.z = d * f * e + b * c * m;
          this.w = d * f * m - b * c * e;
          break;
        case "YXZ":
          this.x = b * f * m + d * c * e;
          this.y = d * c * m - b * f * e;
          this.z = d * f * e - b * c * m;
          this.w = d * f * m + b * c * e;
          break;
        case "ZXY":
          this.x = b * f * m - d * c * e;
          this.y = d * c * m + b * f * e;
          this.z = d * f * e + b * c * m;
          this.w = d * f * m - b * c * e;
          break;
        case "ZYX":
          this.x = b * f * m - d * c * e;
          this.y = d * c * m + b * f * e;
          this.z = d * f * e - b * c * m;
          this.w = d * f * m + b * c * e;
          break;
        case "YZX":
          this.x = b * f * m + d * c * e;
          this.y = d * c * m + b * f * e;
          this.z = d * f * e - b * c * m;
          this.w = d * f * m - b * c * e;
          break;
        case "XZY":
          this.x = b * f * m - d * c * e, this.y = d * c * m - b * f * e, this.z = d * f * e + b * c * m, this.w = d * f * m + b * c * e;
      }
      return this;
    }}, {key:"setFromAxisAngle", value:function(a, b) {
      b /= 2;
      var c = I(b);
      return this.x = a.x * c, this.y = a.y * c, this.z = a.z * c, this.w = J(b), this;
    }}, {key:"setFromRotationMatrix", value:function(a) {
      var b, c = a.elements;
      a = c[0];
      var e = c[4], d = c[8], f = c[1], m = c[5], k = c[9], h = c[2], g = c[6];
      c = c[10];
      var r = a + m + c;
      return 0 < r ? (b = .5 / P(r + 1), this.w = .25 / b, this.x = (g - k) * b, this.y = (d - h) * b, this.z = (f - e) * b) : a > m && a > c ? (b = 2 * P(1 + a - m - c), this.w = (g - k) / b, this.x = .25 * b, this.y = (e + f) / b, this.z = (d + h) / b) : m > c ? (b = 2 * P(1 + m - a - c), this.w = (d - h) / b, this.x = (e + f) / b, this.y = .25 * b, this.z = (k + g) / b) : (b = 2 * P(1 + c - a - m), this.w = (f - e) / b, this.x = (d + h) / b, this.y = (k + g) / b, this.z = .25 * b), this;
    }}, {key:"setFromUnitVectors", value:function(a, b) {
      var c = a.dot(b) + 1;
      return 1E-6 > c ? (c = 0, L(a.x) > L(a.z) ? X.set(-a.y, a.x, 0) : X.set(0, -a.z, a.y)) : X.crossVectors(a, b), this.x = X.x, this.y = X.y, this.z = X.z, this.w = c, this.normalize();
    }}, {key:"angleTo", value:function(a) {
      return 2 * K(L(S(N(this.dot(a), -1), 1)));
    }}, {key:"rotateTowards", value:function(a, b) {
      var c = this.angleTo(a);
      return 0 !== c && this.slerp(a, S(1, b / c)), this;
    }}, {key:"invert", value:function() {
      return this.conjugate();
    }}, {key:"conjugate", value:function() {
      return this.x *= -1, this.y *= -1, this.z *= -1, this;
    }}, {key:"lengthSquared", value:function() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }}, {key:"length", value:function() {
      return P(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }}, {key:"normalize", value:function() {
      var a, b = this.length();
      return 0 === b ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (a = 1 / b, this.x *= a, this.y *= a, this.z *= a, this.w *= a), this;
    }}, {key:"dot", value:function(a) {
      return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
    }}, {key:"multiplyQuaternions", value:function(a, b) {
      var c = a.x, e = a.y, d = a.z;
      a = a.w;
      var f = b.x, m = b.y, k = b.z;
      b = b.w;
      return this.x = c * b + a * f + e * k - d * m, this.y = e * b + a * m + d * f - c * k, this.z = d * b + a * k + c * m - e * f, this.w = a * b - c * f - e * m - d * k, this;
    }}, {key:"multiply", value:function(a) {
      return this.multiplyQuaternions(this, a);
    }}, {key:"premultiply", value:function(a) {
      return this.multiplyQuaternions(a, this);
    }}, {key:"slerp", value:function(a, c) {
      var e, d, f, m, k, h, g, r = this.x, n = this.y, p = this.z, u = this.w;
      return 1 === c ? this.copy(a) : 0 < c && (e = u * a.w + r * a.x + n * a.y + p * a.z, 0 > e ? (this.w = -a.w, this.x = -a.x, this.y = -a.y, this.z = -a.z, e = -e) : this.copy(a), 1 <= e ? (this.w = u, this.x = r, this.y = n, this.z = p) : (d = 1 - e * e, k = 1 - c, d <= b ? (this.w = k * u + c * this.w, this.x = k * r + c * this.x, this.y = k * n + c * this.y, this.z = k * p + c * this.z, this.normalize()) : (f = P(d), m = F(f, e), h = I(k * m) / f, g = I(c * m) / f, this.w = u * h + this.w * 
      g, this.x = r * h + this.x * g, this.y = n * h + this.y * g, this.z = p * h + this.z * g))), this;
    }}, {key:"equals", value:function(a) {
      return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;
    }}], [{key:"slerp", value:function(a, b, c, e) {
      return c.copy(a).slerp(b, e);
    }}, {key:"slerpFlat", value:function(a, c, e, d, f, m, k) {
      var h, g, r, n, p, u, q, t, v = f[m], y = f[m + 1], x = f[m + 2];
      f = f[m + 3];
      m = e[d];
      var z = e[d + 1], C = e[d + 2];
      e = e[d + 3];
      (e !== f || m !== v || z !== y || C !== x) && (h = 1 - k, n = m * v + z * y + C * x + e * f, u = 0 <= n ? 1 : -1, p = 1 - n * n, p > b && (r = P(p), q = F(r, n * u), h = I(h * q) / r, k = I(k * q) / r), t = k * u, m = m * h + v * t, z = z * h + y * t, C = C * h + x * t, e = e * h + f * t, h === 1 - k && (g = 1 / P(m * m + z * z + C * C + e * e), m *= g, z *= g, C *= g, e *= g));
      a[c] = m;
      a[c + 1] = z;
      a[c + 2] = C;
      a[c + 3] = e;
    }}]), a;
  }(), Y = new ja, T = new ea;
  (function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, e = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
      d(this, a);
      this.x = b;
      this.y = c;
      this.z = e;
      this.order = a.defaultOrder;
    }
    return h(a, [{key:"set", value:function(a, b, c, e) {
      return this.x = a, this.y = b, this.z = c, this.order = e, this;
    }}, {key:"copy", value:function(a) {
      return this.x = a.x, this.y = a.y, this.z = a.z, this.order = a.order, this;
    }}, {key:"clone", value:function() {
      return new this.constructor(this.x, this.y, this.z, this.order);
    }}, {key:"fromArray", value:function(a) {
      var b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
      return this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this.order = a[b + 3], this;
    }}, {key:"toArray", value:function() {
      var a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [], b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
      return a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a[b + 3] = this.order, a;
    }}, {key:"toVector3", value:function() {
      return (0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q).set(this.x, this.y, this.z);
    }}, {key:"setFromRotationMatrix", value:function(a) {
      var b = Math.asin, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : this.order, e = a.elements, d = e[0], f = e[4], m = e[8], k = e[1], h = e[5], g = e[9], r = e[2], n = e[6];
      e = e[10];
      switch(c) {
        case "XYZ":
          this.y = b(N(S(m, 1), -1));
          .99999 > L(m) ? (this.x = F(-g, e), this.z = F(-f, d)) : (this.x = F(n, h), this.z = 0);
          break;
        case "YXZ":
          this.x = b(-N(S(g, 1), -1));
          .99999 > L(g) ? (this.y = F(m, e), this.z = F(k, h)) : (this.y = F(-r, d), this.z = 0);
          break;
        case "ZXY":
          this.x = b(N(S(n, 1), -1));
          .99999 > L(n) ? (this.y = F(-r, e), this.z = F(-f, h)) : (this.y = 0, this.z = F(k, d));
          break;
        case "ZYX":
          this.y = b(-N(S(r, 1), -1));
          .99999 > L(r) ? (this.x = F(n, e), this.z = F(k, d)) : (this.x = 0, this.z = F(-f, h));
          break;
        case "YZX":
          this.z = b(N(S(k, 1), -1));
          .99999 > L(k) ? (this.x = F(-g, h), this.y = F(-r, d)) : (this.x = 0, this.y = F(m, e));
          break;
        case "XZY":
          this.z = b(-N(S(f, 1), -1)), .99999 > L(f) ? (this.x = F(n, h), this.y = F(m, d)) : (this.x = F(-g, e), this.y = 0);
      }
      return this.order = c, this;
    }}, {key:"setFromQuaternion", value:function(a, b) {
      return Y.makeRotationFromQuaternion(a), this.setFromRotationMatrix(Y, b);
    }}, {key:"setFromVector3", value:function(a) {
      return this.set(a.x, a.y, a.z, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : this.order);
    }}, {key:"reorder", value:function(a) {
      return T.setFromEuler(this), this.setFromQuaternion(T, a);
    }}, {key:"equals", value:function(a) {
      return a.x === this.x && a.y === this.y && a.z === this.z && a.order === this.order;
    }}], [{key:"defaultOrder", get:function() {
      return "XYZ";
    }}]), a;
  })();
  var ma = new Q, ka = new Q, ua = function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q(1, 0, 0), c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
      d(this, a);
      this.normal = b;
      this.constant = c;
    }
    return h(a, [{key:"set", value:function(a, b) {
      return this.normal.copy(a), this.constant = b, this;
    }}, {key:"setComponents", value:function(a, b, c, e) {
      return this.normal.set(a, b, c), this.constant = e, this;
    }}, {key:"copy", value:function(a) {
      return this.normal.copy(a.normal), this.constant = a.constant, this;
    }}, {key:"clone", value:function() {
      return (new this.constructor).copy(this);
    }}, {key:"setFromNormalAndCoplanarPoint", value:function(a, b) {
      return this.normal.copy(a), this.constant = -b.dot(this.normal), this;
    }}, {key:"setFromCoplanarPoints", value:function(a, b, c) {
      a = ma.subVectors(c, b).cross(ka.subVectors(a, b)).normalize();
      return this.setFromNormalAndCoplanarPoint(a, ma), this;
    }}, {key:"normalize", value:function() {
      var a = 1 / this.normal.length();
      return this.normal.multiplyScalar(a), this.constant *= a, this;
    }}, {key:"negate", value:function() {
      return this.normal.negate(), this.constant = -this.constant, this;
    }}, {key:"distanceToPoint", value:function(a) {
      return this.normal.dot(a) + this.constant;
    }}, {key:"distanceToSphere", value:function(a) {
      return this.distanceToPoint(a.center) - a.radius;
    }}, {key:"projectPoint", value:function(a, b) {
      return b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a);
    }}, {key:"coplanarPoint", value:function(a) {
      return a.copy(this.normal).multiplyScalar(-this.constant);
    }}, {key:"translate", value:function(a) {
      return this.constant -= a.dot(this.normal), this;
    }}, {key:"intersectLine", value:function(a, b) {
      var c = a.delta(ma), e = this.normal.dot(c);
      0 === e ? 0 === this.distanceToPoint(a.start) && b.copy(a.start) : (e = -(a.start.dot(this.normal) + this.constant) / e, 0 <= e && 1 >= e && b.copy(c).multiplyScalar(e).add(a.start));
      return b;
    }}, {key:"intersectsLine", value:function(a) {
      var b = this.distanceToPoint(a.start);
      a = this.distanceToPoint(a.end);
      return 0 > b && 0 < a || 0 > a && 0 < b;
    }}, {key:"intersectsBox", value:function(a) {
      return a.intersectsPlane(this);
    }}, {key:"intersectsSphere", value:function(a) {
      return a.intersectsPlane(this);
    }}, {key:"equals", value:function(a) {
      return a.normal.equals(this.normal) && a.constant === this.constant;
    }}]), a;
  }(), Aa = new Q;
  (function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new ua, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new ua, e = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : new ua, f = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : new ua, m = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : new ua, k = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : new ua;
      d(this, a);
      this.planes = [b, c, e, f, m, k];
    }
    return h(a, [{key:"set", value:function(a, b, c, e, d, f) {
      var m = this.planes;
      return m[0].copy(a), m[1].copy(b), m[2].copy(c), m[3].copy(e), m[4].copy(d), m[5].copy(f), this;
    }}, {key:"clone", value:function() {
      return (new this.constructor).copy(this);
    }}, {key:"copy", value:function(a) {
      var b, c = this.planes;
      for (b = 0; 6 > b; ++b) {
        c[b].copy(a.planes[b]);
      }
      return this;
    }}, {key:"setFromMatrix", value:function(a) {
      var b = this.planes, c = a.elements;
      a = c[0];
      var e = c[1], d = c[2], f = c[3], m = c[4], k = c[5], h = c[6], g = c[7], r = c[8], n = c[9], p = c[10], u = c[11], q = c[12], t = c[13], v = c[14];
      c = c[15];
      return b[0].setComponents(f - a, g - m, u - r, c - q).normalize(), b[1].setComponents(f + a, g + m, u + r, c + q).normalize(), b[2].setComponents(f + e, g + k, u + n, c + t).normalize(), b[3].setComponents(f - e, g - k, u - n, c - t).normalize(), b[4].setComponents(f - d, g - h, u - p, c - v).normalize(), b[5].setComponents(f + d, g + h, u + p, c + v).normalize(), this;
    }}, {key:"intersectsSphere", value:function(a) {
      var b, c = this.planes, e = a.center, d = -a.radius, f = !0;
      for (a = 0; 6 > a; ++a) {
        if (b = c[a].distanceToPoint(e), b < d) {
          f = !1;
          break;
        }
      }
      return f;
    }}, {key:"intersectsBox", value:function(a) {
      var b, c = this.planes, e = a.min, d = a.max;
      for (a = 0; 6 > a; ++a) {
        if (b = c[a], Aa.x = 0 < b.normal.x ? d.x : e.x, Aa.y = 0 < b.normal.y ? d.y : e.y, Aa.z = 0 < b.normal.z ? d.z : e.z, 0 > b.distanceToPoint(Aa)) {
          return !1;
        }
      }
      return !0;
    }}, {key:"containsPoint", value:function(a) {
      var b, c = this.planes, e = !0;
      for (b = 0; 6 > b; ++b) {
        if (0 > c[b].distanceToPoint(a)) {
          e = !1;
          break;
        }
      }
      return e;
    }}]), a;
  })();
  var Ia = new Q, Ga = new Q;
  (function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Q;
      d(this, a);
      this.start = b;
      this.end = c;
    }
    return h(a, [{key:"set", value:function(a, b) {
      return this.start.copy(a), this.end.copy(b), this;
    }}, {key:"copy", value:function(a) {
      return this.start.copy(a.start), this.end.copy(a.end), this;
    }}, {key:"clone", value:function() {
      return (new this.constructor).copy(this);
    }}, {key:"getCenter", value:function() {
      return (0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q).addVectors(this.start, this.end).multiplyScalar(.5);
    }}, {key:"delta", value:function() {
      return (0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q).subVectors(this.end, this.start);
    }}, {key:"lengthSquared", value:function() {
      return this.start.distanceToSquared(this.end);
    }}, {key:"length", value:function() {
      return this.start.distanceTo(this.end);
    }}, {key:"at", value:function(a, b) {
      return this.delta(b).multiplyScalar(a).add(this.start);
    }}, {key:"closestPointToPointParameter", value:function(a, b) {
      Ia.subVectors(a, this.start);
      Ga.subVectors(this.end, this.start);
      a = Ga.dot(Ga);
      var c = Ga.dot(Ia);
      return b ? S(N(c / a, 0), 1) : c / a;
    }}, {key:"closestPointToPoint", value:function(a) {
      var b = !!(1 < arguments.length && void 0 !== arguments[1]) && arguments[1], c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : new Q;
      b = this.closestPointToPointParameter(a, b);
      return this.delta(c).multiplyScalar(b).add(this.start);
    }}, {key:"equals", value:function(a) {
      return a.start.equals(this.start) && a.end.equals(this.end);
    }}]), a;
  })();
  var sa = new Q, Qb = new Q, va = new Q;
  (function() {
    function a() {
      d(this, a);
      this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    }
    return h(a, [{key:"set", value:function(a, b, c, e, d, f, m, k, h, g, r, n, p, u, q, t) {
      var v = this.elements;
      return v[0] = a, v[4] = b, v[8] = c, v[12] = e, v[1] = d, v[5] = f, v[9] = m, v[13] = k, v[2] = h, v[6] = g, v[10] = r, v[14] = n, v[3] = p, v[7] = u, v[11] = q, v[15] = t, this;
    }}, {key:"identity", value:function() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }}, {key:"copy", value:function(a) {
      a = a.elements;
      var b = this.elements;
      return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], b[9] = a[9], b[10] = a[10], b[11] = a[11], b[12] = a[12], b[13] = a[13], b[14] = a[14], b[15] = a[15], this;
    }}, {key:"clone", value:function() {
      return (new this.constructor).fromArray(this.elements);
    }}, {key:"fromArray", value:function(a) {
      var b, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, e = this.elements;
      for (b = 0; 16 > b; ++b) {
        e[b] = a[b + c];
      }
      return this;
    }}, {key:"toArray", value:function() {
      var a, b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [], c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, e = this.elements;
      for (a = 0; 16 > a; ++a) {
        b[a + c] = e[a];
      }
      return b;
    }}, {key:"getMaxScaleOnAxis", value:function() {
      var a = this.elements;
      return P(N(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]));
    }}, {key:"copyPosition", value:function(a) {
      var b = this.elements;
      a = a.elements;
      return b[12] = a[12], b[13] = a[13], b[14] = a[14], this;
    }}, {key:"setPosition", value:function(a) {
      var b = this.elements;
      return b[12] = a.x, b[13] = a.y, b[14] = a.z, this;
    }}, {key:"extractBasis", value:function(a, b, c) {
      return a.setFromMatrixColumn(this, 0), b.setFromMatrixColumn(this, 1), c.setFromMatrixColumn(this, 2), this;
    }}, {key:"makeBasis", value:function(a, b, c) {
      return this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1), this;
    }}, {key:"extractRotation", value:function(a) {
      var b = this.elements, c = a.elements, e = 1 / sa.setFromMatrixColumn(a, 0).length(), d = 1 / sa.setFromMatrixColumn(a, 1).length();
      a = 1 / sa.setFromMatrixColumn(a, 2).length();
      return b[0] = c[0] * e, b[1] = c[1] * e, b[2] = c[2] * e, b[3] = 0, b[4] = c[4] * d, b[5] = c[5] * d, b[6] = c[6] * d, b[7] = 0, b[8] = c[8] * a, b[9] = c[9] * a, b[10] = c[10] * a, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this;
    }}, {key:"makeRotationFromEuler", value:function(a) {
      var b = this.elements, c = a.x, e = a.y, d = a.z, f = J(c);
      c = I(c);
      var m = J(e);
      e = I(e);
      var k = J(d);
      d = I(d);
      switch(a.order) {
        case "XYZ":
          a = f * k;
          var h = f * d;
          var g = c * k;
          var r = c * d;
          b[0] = m * k;
          b[4] = -m * d;
          b[8] = e;
          b[1] = h + g * e;
          b[5] = a - r * e;
          b[9] = -c * m;
          b[2] = r - a * e;
          b[6] = g + h * e;
          b[10] = f * m;
          break;
        case "YXZ":
          a = m * k;
          h = m * d;
          g = e * k;
          r = e * d;
          b[0] = a + r * c;
          b[4] = g * c - h;
          b[8] = f * e;
          b[1] = f * d;
          b[5] = f * k;
          b[9] = -c;
          b[2] = h * c - g;
          b[6] = r + a * c;
          b[10] = f * m;
          break;
        case "ZXY":
          a = m * k;
          h = m * d;
          g = e * k;
          r = e * d;
          b[0] = a - r * c;
          b[4] = -f * d;
          b[8] = g + h * c;
          b[1] = h + g * c;
          b[5] = f * k;
          b[9] = r - a * c;
          b[2] = -f * e;
          b[6] = c;
          b[10] = f * m;
          break;
        case "ZYX":
          a = f * k;
          h = f * d;
          g = c * k;
          r = c * d;
          b[0] = m * k;
          b[4] = g * e - h;
          b[8] = a * e + r;
          b[1] = m * d;
          b[5] = r * e + a;
          b[9] = h * e - g;
          b[2] = -e;
          b[6] = c * m;
          b[10] = f * m;
          break;
        case "YZX":
          a = f * m;
          h = f * e;
          g = c * m;
          r = c * e;
          b[0] = m * k;
          b[4] = r - a * d;
          b[8] = g * d + h;
          b[1] = d;
          b[5] = f * k;
          b[9] = -c * k;
          b[2] = -e * k;
          b[6] = h * d + g;
          b[10] = a - r * d;
          break;
        case "XZY":
          a = f * m, h = f * e, g = c * m, r = c * e, b[0] = m * k, b[4] = -d, b[8] = e * k, b[1] = a * d + r, b[5] = f * k, b[9] = h * d - g, b[2] = g * d - h, b[6] = c * k, b[10] = r * d + a;
      }
      return b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this;
    }}, {key:"makeRotationFromQuaternion", value:function(a) {
      return this.compose(sa.set(0, 0, 0), a, Qb.set(1, 1, 1));
    }}, {key:"lookAt", value:function(a, b, c) {
      var e = this.elements;
      return va.subVectors(a, b), 0 === va.lengthSquared() && (va.z = 1), va.normalize(), sa.crossVectors(c, va), 0 === sa.lengthSquared() && (1 === L(c.z) ? va.x += 1E-4 : va.z += 1E-4, va.normalize(), sa.crossVectors(c, va)), sa.normalize(), Qb.crossVectors(va, sa), e[0] = sa.x, e[4] = Qb.x, e[8] = va.x, e[1] = sa.y, e[5] = Qb.y, e[9] = va.y, e[2] = sa.z, e[6] = Qb.z, e[10] = va.z, this;
    }}, {key:"multiplyMatrices", value:function(a, b) {
      var c = this.elements, e = a.elements, d = b.elements;
      b = e[0];
      a = e[4];
      var f = e[8], m = e[12], k = e[1], h = e[5], g = e[9], r = e[13], n = e[2], p = e[6], u = e[10], q = e[14], t = e[3], v = e[7], y = e[11];
      e = e[15];
      var x = d[0], z = d[4], C = d[8], A = d[12], B = d[1], D = d[5], F = d[9], U = d[13], E = d[2], O = d[6], H = d[10], J = d[14], I = d[3], N = d[7], Q = d[11];
      d = d[15];
      return c[0] = b * x + a * B + f * E + m * I, c[4] = b * z + a * D + f * O + m * N, c[8] = b * C + a * F + f * H + m * Q, c[12] = b * A + a * U + f * J + m * d, c[1] = k * x + h * B + g * E + r * I, c[5] = k * z + h * D + g * O + r * N, c[9] = k * C + h * F + g * H + r * Q, c[13] = k * A + h * U + g * J + r * d, c[2] = n * x + p * B + u * E + q * I, c[6] = n * z + p * D + u * O + q * N, c[10] = n * C + p * F + u * H + q * Q, c[14] = n * A + p * U + u * J + q * d, c[3] = t * x + v * B + y * E + 
      e * I, c[7] = t * z + v * D + y * O + e * N, c[11] = t * C + v * F + y * H + e * Q, c[15] = t * A + v * U + y * J + e * d, this;
    }}, {key:"multiply", value:function(a) {
      return this.multiplyMatrices(this, a);
    }}, {key:"premultiply", value:function(a) {
      return this.multiplyMatrices(a, this);
    }}, {key:"multiplyScalar", value:function(a) {
      var b = this.elements;
      return b[0] *= a, b[4] *= a, b[8] *= a, b[12] *= a, b[1] *= a, b[5] *= a, b[9] *= a, b[13] *= a, b[2] *= a, b[6] *= a, b[10] *= a, b[14] *= a, b[3] *= a, b[7] *= a, b[11] *= a, b[15] *= a, this;
    }}, {key:"determinant", value:function() {
      var a = this.elements, b = a[0], c = a[4], e = a[8], d = a[12], f = a[1], m = a[5], k = a[9], h = a[13], g = a[2], r = a[6], n = a[10], p = a[14], u = b * m, q = b * k;
      b *= h;
      var t = c * f, v = c * k;
      c *= h;
      var y = e * f, x = e * m;
      e *= h;
      f *= d;
      m *= d;
      d *= k;
      return a[3] * (d * r - e * r - m * n + c * n + x * p - v * p) + a[7] * (q * p - b * n + f * n - y * p + e * g - d * g) + a[11] * (b * r - u * p - f * r + t * p + m * g - c * g) + a[15] * (-x * g - q * r + u * n + y * r - t * n + v * g);
    }}, {key:"getInverse", value:function(a) {
      var b, c = this.elements, e = a.elements, d = e[0], f = e[1], m = e[2], k = e[3], h = e[4], g = e[5], r = e[6], n = e[7], p = e[8], u = e[9], q = e[10], t = e[11], v = e[12], y = e[13], x = e[14];
      e = e[15];
      var z = u * x * n - y * q * n + y * r * t - g * x * t - u * r * e + g * q * e, C = v * q * n - p * x * n - v * r * t + h * x * t + p * r * e - h * q * e, A = p * y * n - v * u * n + v * g * t - h * y * t - p * g * e + h * u * e, B = v * u * r - p * y * r - v * g * q + h * y * q + p * g * x - h * u * x, D = d * z + f * C + m * A + k * B;
      return 0 === D ? (console.error("Can't invert matrix, determinant is zero", a), this.identity()) : (b = 1 / D, c[0] = z * b, c[1] = (y * q * k - u * x * k - y * m * t + f * x * t + u * m * e - f * q * e) * b, c[2] = (g * x * k - y * r * k + y * m * n - f * x * n - g * m * e + f * r * e) * b, c[3] = (u * r * k - g * q * k - u * m * n + f * q * n + g * m * t - f * r * t) * b, c[4] = C * b, c[5] = (p * x * k - v * q * k + v * m * t - d * x * t - p * m * e + d * q * e) * b, c[6] = (v * r * k - 
      h * x * k - v * m * n + d * x * n + h * m * e - d * r * e) * b, c[7] = (h * q * k - p * r * k + p * m * n - d * q * n - h * m * t + d * r * t) * b, c[8] = A * b, c[9] = (v * u * k - p * y * k - v * f * t + d * y * t + p * f * e - d * u * e) * b, c[10] = (h * y * k - v * g * k + v * f * n - d * y * n - h * f * e + d * g * e) * b, c[11] = (p * g * k - h * u * k - p * f * n + d * u * n + h * f * t - d * g * t) * b, c[12] = B * b, c[13] = (p * y * m - v * u * m + v * f * q - d * y * q - p * f * 
      x + d * u * x) * b, c[14] = (v * g * m - h * y * m - v * f * r + d * y * r + h * f * x - d * g * x) * b, c[15] = (h * u * m - p * g * m + p * f * r - d * u * r - h * f * q + d * g * q) * b), this;
    }}, {key:"transpose", value:function() {
      var a, b = this.elements;
      return a = b[1], b[1] = b[4], b[4] = a, a = b[2], b[2] = b[8], b[8] = a, a = b[6], b[6] = b[9], b[9] = a, a = b[3], b[3] = b[12], b[12] = a, a = b[7], b[7] = b[13], b[13] = a, a = b[11], b[11] = b[14], b[14] = a, this;
    }}, {key:"scale", value:function(a, b, c) {
      var e = this.elements;
      return e[0] *= a, e[4] *= b, e[8] *= c, e[1] *= a, e[5] *= b, e[9] *= c, e[2] *= a, e[6] *= b, e[10] *= c, e[3] *= a, e[7] *= b, e[11] *= c, this;
    }}, {key:"makeScale", value:function(a, b, c) {
      return this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1), this;
    }}, {key:"makeTranslation", value:function(a, b, c) {
      return this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1), this;
    }}, {key:"makeRotationX", value:function(a) {
      var b = J(a);
      a = I(a);
      return this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1), this;
    }}, {key:"makeRotationY", value:function(a) {
      var b = J(a);
      a = I(a);
      return this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1), this;
    }}, {key:"makeRotationZ", value:function(a) {
      var b = J(a);
      a = I(a);
      return this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }}, {key:"makeRotationAxis", value:function(a, b) {
      var c = J(b);
      b = I(b);
      var e = 1 - c, d = a.x, f = a.y;
      a = a.z;
      var m = e * d, k = e * f;
      return this.set(m * d + c, m * f - b * a, m * a + b * f, 0, m * f + b * a, k * f + c, k * a - b * d, 0, m * a - b * f, k * a + b * d, e * a * a + c, 0, 0, 0, 0, 1), this;
    }}, {key:"makeShear", value:function(a, b, c) {
      return this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1), this;
    }}, {key:"compose", value:function(a, b, c) {
      var e = this.elements, d = b.x, f = b.y, m = b.z, k = b.w, h = d + d, g = f + f, r = m + m;
      b = d * h;
      var n = d * g;
      d *= r;
      var p = f * g;
      f *= r;
      m *= r;
      h *= k;
      g *= k;
      k *= r;
      r = c.x;
      var u = c.y;
      c = c.z;
      return e[0] = (1 - (p + m)) * r, e[1] = (n + k) * r, e[2] = (d - g) * r, e[3] = 0, e[4] = (n - k) * u, e[5] = (1 - (b + m)) * u, e[6] = (f + h) * u, e[7] = 0, e[8] = (d + g) * c, e[9] = (f - h) * c, e[10] = (1 - (b + p)) * c, e[11] = 0, e[12] = a.x, e[13] = a.y, e[14] = a.z, e[15] = 1, this;
    }}, {key:"decompose", value:function(a, b, c) {
      var e = this.elements, d = e[0], f = e[1], m = e[2], k = e[4], h = e[5], g = e[6], r = e[8], n = e[9], p = e[10], u = this.determinant();
      u = sa.set(d, f, m).length() * (0 > u ? -1 : 1);
      var q = sa.set(k, h, g).length(), t = sa.set(r, n, p).length(), v = 1 / u, y = 1 / q, x = 1 / t;
      return a.x = e[12], a.y = e[13], a.z = e[14], e[0] *= v, e[1] *= v, e[2] *= v, e[4] *= y, e[5] *= y, e[6] *= y, e[8] *= x, e[9] *= x, e[10] *= x, b.setFromRotationMatrix(this), e[0] = d, e[1] = f, e[2] = m, e[4] = k, e[5] = h, e[6] = g, e[8] = r, e[9] = n, e[10] = p, c.x = u, c.y = q, c.z = t, this;
    }}, {key:"makePerspective", value:function(a, b, c, e, d, f) {
      var m = this.elements;
      return m[0] = 2 * d / (b - a), m[4] = 0, m[8] = (b + a) / (b - a), m[12] = 0, m[1] = 0, m[5] = 2 * d / (c - e), m[9] = (c + e) / (c - e), m[13] = 0, m[2] = 0, m[6] = 0, m[10] = -(f + d) / (f - d), m[14] = -2 * f * d / (f - d), m[3] = 0, m[7] = 0, m[11] = -1, m[15] = 0, this;
    }}, {key:"makeOrthographic", value:function(a, b, c, e, d, f) {
      var m = this.elements, k = 1 / (b - a), h = 1 / (c - e), g = 1 / (f - d);
      return m[0] = 2 * k, m[4] = 0, m[8] = 0, m[12] = -((b + a) * k), m[1] = 0, m[5] = 2 * h, m[9] = 0, m[13] = -((c + e) * h), m[2] = 0, m[6] = 0, m[10] = -2 * g, m[14] = -((f + d) * g), m[3] = 0, m[7] = 0, m[11] = 0, m[15] = 1, this;
    }}, {key:"equals", value:function(a) {
      var b = this.elements, c = a.elements, e = !0;
      for (a = 0; e && 16 > a; ++a) {
        b[a] !== c[a] && (e = !1);
      }
      return e;
    }}]), a;
  })();
  var xa = [new Q, new Q, new Q, new Q], gc = function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Q;
      d(this, a);
      this.origin = b;
      this.direction = c;
    }
    return h(a, [{key:"set", value:function(a, b) {
      return this.origin.copy(a), this.direction.copy(b), this;
    }}, {key:"copy", value:function(a) {
      return this.origin.copy(a.origin), this.direction.copy(a.direction), this;
    }}, {key:"clone", value:function() {
      return (new this.constructor).copy(this);
    }}, {key:"at", value:function(a) {
      return (1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Q).copy(this.direction).multiplyScalar(a).add(this.origin);
    }}, {key:"lookAt", value:function(a) {
      return this.direction.copy(a).sub(this.origin).normalize(), this;
    }}, {key:"recast", value:function(a) {
      return this.origin.copy(this.at(a, xa[0])), this;
    }}, {key:"closestPointToPoint", value:function(a) {
      var b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Q, c = b.subVectors(a, this.origin).dot(this.direction);
      return 0 <= c ? b.copy(this.direction).multiplyScalar(c).add(this.origin) : b.copy(this.origin);
    }}, {key:"distanceSquaredToPoint", value:function(a) {
      var b = xa[0].subVectors(a, this.origin).dot(this.direction);
      return 0 > b ? this.origin.distanceToSquared(a) : xa[0].copy(this.direction).multiplyScalar(b).add(this.origin).distanceToSquared(a);
    }}, {key:"distanceToPoint", value:function(a) {
      return P(this.distanceSquaredToPoint(a));
    }}, {key:"distanceToPlane", value:function(a) {
      var b = a.normal.dot(this.direction);
      a = 0 === b ? 0 === a.distanceToPoint(this.origin) ? 0 : -1 : -(this.origin.dot(a.normal) + a.constant) / b;
      return 0 <= a ? a : null;
    }}, {key:"distanceSquaredToSegment", value:function(a, b, c, e) {
      var d, f, m, k, h, g = xa[0].copy(a).add(b).multiplyScalar(.5), r = xa[1].copy(b).sub(a).normalize(), n = xa[2].copy(this.origin).sub(g);
      a = .5 * a.distanceTo(b);
      b = -this.direction.dot(r);
      var p = n.dot(this.direction), u = -n.dot(r);
      n = n.lengthSq();
      var q = L(1 - b * b);
      return 0 < q ? (d = b * u - p, f = b * p - u, m = a * q, 0 <= d ? f >= -m ? f <= m ? (k = 1 / q, d *= k, f *= k, h = d * (d + b * f + 2 * p) + f * (b * d + f + 2 * u) + n) : (f = a, d = N(0, -(b * f + p)), h = -d * d + f * (f + 2 * u) + n) : (f = -a, d = N(0, -(b * f + p)), h = -d * d + f * (f + 2 * u) + n) : f <= -m ? (d = N(0, -(-b * a + p)), f = 0 < d ? -a : S(N(-a, -u), a), h = -d * d + f * (f + 2 * u) + n) : f <= m ? (d = 0, f = S(N(-a, -u), a), h = f * (f + 2 * u) + n) : (d = N(0, -(b * 
      a + p)), f = 0 < d ? a : S(N(-a, -u), a), h = -d * d + f * (f + 2 * u) + n)) : (f = 0 < b ? -a : a, d = N(0, -(b * f + p)), h = -d * d + f * (f + 2 * u) + n), void 0 !== c && c.copy(this.direction).multiplyScalar(d).add(this.origin), void 0 !== e && e.copy(r).multiplyScalar(f).add(g), h;
    }}, {key:"intersectSphere", value:function(a) {
      var b, c, e, d = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Q, f = xa[0].subVectors(a.center, this.origin), m = f.dot(this.direction);
      f = f.dot(f) - m * m;
      var k = a.radius * a.radius, h = null;
      return f <= k && (b = P(k - f), c = m - b, e = m + b, (0 <= c || 0 <= e) && (h = 0 > c ? this.at(e, d) : this.at(c, d))), h;
    }}, {key:"intersectsSphere", value:function(a) {
      return this.distanceSqToPoint(a.center) <= a.radius * a.radius;
    }}, {key:"intersectPlane", value:function(a) {
      var b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Q, c = this.distanceToPlane(a);
      return null === c ? null : this.at(c, b);
    }}, {key:"intersectsPlane", value:function(a) {
      var b = a.distanceToPoint(this.origin);
      return 0 === b || 0 > a.normal.dot(this.direction) * b;
    }}, {key:"intersectBox", value:function(a) {
      var b, c, e, d, f, m, k = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Q, h = this.origin, g = this.direction, r = a.min, n = a.max, p = 1 / g.x, u = 1 / g.y;
      g = 1 / g.z;
      var q = null;
      return 0 <= p ? (b = (r.x - h.x) * p, c = (n.x - h.x) * p) : (b = (n.x - h.x) * p, c = (r.x - h.x) * p), 0 <= u ? (e = (r.y - h.y) * u, d = (n.y - h.y) * u) : (e = (n.y - h.y) * u, d = (r.y - h.y) * u), b <= d && e <= c && ((e > b || b !== b) && (b = e), (d < c || c !== c) && (c = d), 0 <= g ? (f = (r.z - h.z) * g, m = (n.z - h.z) * g) : (f = (n.z - h.z) * g, m = (r.z - h.z) * g), b <= m && f <= c && ((f > b || b !== b) && (b = f), (m < c || c !== c) && (c = m), 0 <= c && (q = this.at(0 <= 
      b ? b : c, k)))), q;
    }}, {key:"intersectsBox", value:function(a) {
      return null !== this.intersectBox(a, xa[0]);
    }}, {key:"intersectTriangle", value:function(a, b, c, e, d) {
      var f, m, k, h, g, r = this.direction, n = xa[0], p = xa[1], u = xa[2], q = xa[3], t = null;
      return p.subVectors(b, a), u.subVectors(c, a), q.crossVectors(p, u), f = r.dot(q), 0 === f || e && 0 < f || (0 < f ? m = 1 : (m = -1, f = -f), n.subVectors(this.origin, a), k = m * r.dot(u.crossVectors(n, u)), 0 <= k && (h = m * r.dot(p.cross(n)), 0 <= h && k + h <= f && (g = -m * n.dot(q), 0 <= g && (t = this.at(g / f, d))))), t;
    }}, {key:"applyMatrix4", value:function(a) {
      return this.origin.applyMatrix4(a), this.direction.transformDirection(a), this;
    }}, {key:"equals", value:function(a) {
      return a.origin.equals(this.origin) && a.direction.equals(this.direction);
    }}]), a;
  }();
  (function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, e = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
      d(this, a);
      this.radius = b;
      this.phi = c;
      this.theta = e;
    }
    return h(a, [{key:"set", value:function(a, b, c) {
      return this.radius = a, this.phi = b, this.theta = c, this;
    }}, {key:"copy", value:function(a) {
      return this.radius = a.radius, this.phi = a.phi, this.theta = a.theta, this;
    }}, {key:"clone", value:function() {
      return (new this.constructor).copy(this);
    }}, {key:"makeSafe", value:function() {
      return this.phi = N(1E-6, S(D - 1E-6, this.phi)), this;
    }}, {key:"setFromVector3", value:function(a) {
      return this.setFromCartesianCoords(a.x, a.y, a.z);
    }}, {key:"setFromCartesianCoords", value:function(a, b, c) {
      return this.radius = P(a * a + b * b + c * c), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = F(a, c), this.phi = K(S(N(b / this.radius, -1), 1))), this;
    }}]), a;
  })();
  (function() {
    function a() {
      d(this, a);
      this.elements = new Float32Array([1, 0, 0, 1, 0, 1]);
    }
    return h(a, [{key:"set", value:function(a, b, c, e, d, f) {
      var m = this.elements;
      return m[0] = a, m[1] = b, m[3] = e, m[2] = c, m[4] = d, m[5] = f, this;
    }}, {key:"identity", value:function() {
      return this.set(1, 0, 0, 1, 0, 1), this;
    }}, {key:"copy", value:function(a) {
      a = a.elements;
      return this.set(a[0], a[1], a[2], a[3], a[4], a[5]), this;
    }}, {key:"clone", value:function() {
      return (new this.constructor).copy(this);
    }}, {key:"toMatrix3", value:function(a) {
      var b = a.elements;
      a.set(b[0], b[1], b[2], b[1], b[3], b[4], b[2], b[4], b[5]);
    }}, {key:"add", value:function(a) {
      var b = this.elements;
      a = a.elements;
      return b[0] += a[0], b[1] += a[1], b[3] += a[3], b[2] += a[2], b[4] += a[4], b[5] += a[5], this;
    }}, {key:"norm", value:function() {
      var a = this.elements, b = a[1] * a[1], c = a[2] * a[2], e = a[4] * a[4];
      return P(a[0] * a[0] + b + c + b + a[3] * a[3] + e + c + e + a[5] * a[5]);
    }}, {key:"off", value:function() {
      var a = this.elements;
      return P(2 * (a[1] * a[1] + a[2] * a[2] + a[4] * a[4]));
    }}, {key:"applyToVector3", value:function(a) {
      var b = a.x, c = a.y, e = a.z, d = this.elements;
      return a.x = d[0] * b + d[1] * c + d[2] * e, a.y = d[1] * b + d[3] * c + d[4] * e, a.z = d[2] * b + d[4] * c + d[5] * e, a;
    }}, {key:"equals", value:function(a) {
      var b = this.elements, c = a.elements, e = !0;
      for (a = 0; e && 6 > a; ++a) {
        b[a] !== c[a] && (e = !1);
      }
      return e;
    }}], [{key:"calculateIndex", value:function(a, b) {
      return 3 - (3 - a) * (2 - a) / 2 + b;
    }}]), a;
  })();
  (function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, e = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, f = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0;
      d(this, a);
      this.x = b;
      this.y = c;
      this.z = e;
      this.w = f;
    }
    return h(a, [{key:"set", value:function(a, b, c, e) {
      return this.x = a, this.y = b, this.z = c, this.w = e, this;
    }}, {key:"copy", value:function(a) {
      return this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w, this;
    }}, {key:"clone", value:function() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }}, {key:"fromArray", value:function(a) {
      var b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
      return this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this.w = a[b + 3], this;
    }}, {key:"toArray", value:function() {
      var a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [], b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
      return a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a[b + 3] = this.w, a;
    }}, {key:"setAxisAngleFromQuaternion", value:function(a) {
      this.w = 2 * K(a.w);
      var b = P(1 - a.w * a.w);
      return 1E-4 > b ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b), this;
    }}, {key:"setAxisAngleFromRotationMatrix", value:function(a) {
      var b, c, e, d, f, m, k, h, g, r, n = a.elements;
      a = n[0];
      var p = n[4], u = n[8], q = n[1], t = n[5], v = n[9], y = n[2], x = n[6];
      n = n[10];
      return .01 > L(p - q) && .01 > L(u - y) && .01 > L(v - x) ? .1 > L(p + q) && .1 > L(u + y) && .1 > L(v + x) && .1 > L(a + t + n - 3) ? this.set(1, 0, 0, 0) : (d = (a + 1) / 2, f = (t + 1) / 2, m = (n + 1) / 2, k = (p + q) / 4, h = (u + y) / 4, g = (v + x) / 4, d > f && d > m ? .01 > d ? (b = 0, c = .707106781, e = .707106781) : (b = P(d), c = k / b, e = h / b) : f > m ? .01 > f ? (b = .707106781, c = 0, e = .707106781) : (c = P(f), b = k / c, e = g / c) : .01 > m ? (b = .707106781, c = .707106781, 
      e = 0) : (e = P(m), b = h / e, c = g / e), this.set(b, c, e, D)) : (r = P((x - v) * (x - v) + (u - y) * (u - y) + (q - p) * (q - p)), .001 > L(r) && (r = 1), this.x = (x - v) / r, this.y = (u - y) / r, this.z = (q - p) / r, this.w = K((a + t + n - 1) / 2)), this;
    }}, {key:"add", value:function(a) {
      return this.x += a.x, this.y += a.y, this.z += a.z, this.w += a.w, this;
    }}, {key:"addScalar", value:function(a) {
      return this.x += a, this.y += a, this.z += a, this.w += a, this;
    }}, {key:"addVectors", value:function(a, b) {
      return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, this;
    }}, {key:"addScaledVector", value:function(a, b) {
      return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this.w += a.w * b, this;
    }}, {key:"sub", value:function(a) {
      return this.x -= a.x, this.y -= a.y, this.z -= a.z, this.w -= a.w, this;
    }}, {key:"subScalar", value:function(a) {
      return this.x -= a, this.y -= a, this.z -= a, this.w -= a, this;
    }}, {key:"subVectors", value:function(a, b) {
      return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, this;
    }}, {key:"multiply", value:function(a) {
      return this.x *= a.x, this.y *= a.y, this.z *= a.z, this.w *= a.w, this;
    }}, {key:"multiplyScalar", value:function(a) {
      return this.x *= a, this.y *= a, this.z *= a, this.w *= a, this;
    }}, {key:"multiplyVectors", value:function(a, b) {
      return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this.w = a.w * b.w, this;
    }}, {key:"divide", value:function(a) {
      return this.x /= a.x, this.y /= a.y, this.z /= a.z, this.w /= a.w, this;
    }}, {key:"divideScalar", value:function(a) {
      return this.x /= a, this.y /= a, this.z /= a, this.w /= a, this;
    }}, {key:"applyMatrix4", value:function(a) {
      var b = this.x, c = this.y, e = this.z, d = this.w;
      a = a.elements;
      return this.x = a[0] * b + a[4] * c + a[8] * e + a[12] * d, this.y = a[1] * b + a[5] * c + a[9] * e + a[13] * d, this.z = a[2] * b + a[6] * c + a[10] * e + a[14] * d, this.w = a[3] * b + a[7] * c + a[11] * e + a[15] * d, this;
    }}, {key:"negate", value:function() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }}, {key:"dot", value:function(a) {
      return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
    }}, {key:"manhattanLength", value:function() {
      return L(this.x) + L(this.y) + L(this.z) + L(this.w);
    }}, {key:"lengthSquared", value:function() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }}, {key:"length", value:function() {
      return P(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }}, {key:"manhattanDistanceTo", value:function(a) {
      return L(this.x - a.x) + L(this.y - a.y) + L(this.z - a.z) + L(this.w - a.w);
    }}, {key:"distanceToSquared", value:function(a) {
      var b = this.x - a.x, c = this.y - a.y, e = this.z - a.z;
      a = this.w - a.w;
      return b * b + c * c + e * e + a * a;
    }}, {key:"distanceTo", value:function(a) {
      return P(this.distanceToSquared(a));
    }}, {key:"normalize", value:function() {
      return this.divideScalar(this.length());
    }}, {key:"setLength", value:function(a) {
      return this.normalize().multiplyScalar(a);
    }}, {key:"min", value:function(a) {
      return this.x = S(this.x, a.x), this.y = S(this.y, a.y), this.z = S(this.z, a.z), this.w = S(this.w, a.w), this;
    }}, {key:"max", value:function(a) {
      return this.x = N(this.x, a.x), this.y = N(this.y, a.y), this.z = N(this.z, a.z), this.w = N(this.w, a.w), this;
    }}, {key:"clamp", value:function(a, b) {
      return this.x = N(a.x, S(b.x, this.x)), this.y = N(a.y, S(b.y, this.y)), this.z = N(a.z, S(b.z, this.z)), this.w = N(a.w, S(b.w, this.w)), this;
    }}, {key:"floor", value:function() {
      return this.x = H(this.x), this.y = H(this.y), this.z = H(this.z), this.w = H(this.w), this;
    }}, {key:"ceil", value:function() {
      return this.x = E(this.x), this.y = E(this.y), this.z = E(this.z), this.w = E(this.w), this;
    }}, {key:"round", value:function() {
      return this.x = B(this.x), this.y = B(this.y), this.z = B(this.z), this.w = B(this.w), this;
    }}, {key:"lerp", value:function(a, b) {
      return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, this.w += (a.w - this.w) * b, this;
    }}, {key:"lerpVectors", value:function(a, b, c) {
      return this.subVectors(b, a).multiplyScalar(c).add(a);
    }}, {key:"equals", value:function(a) {
      return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;
    }}]), a;
  })();
  var Xd = new Q, yc = function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Q;
      d(this, a);
      this.min = b;
      this.max = c;
      this.children = null;
    }
    return h(a, [{key:"getCenter", value:function() {
      return (0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q).addVectors(this.min, this.max).multiplyScalar(.5);
    }}, {key:"getDimensions", value:function() {
      return (0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q).subVectors(this.max, this.min);
    }}, {key:"split", value:function() {
      var a, b = this.min, c = this.max, e = this.getCenter(Xd), d = this.children = [null, null, null, null, null, null, null, null];
      for (a = 0; 8 > a; ++a) {
        var f = Va[a];
        d[a] = new this.constructor(new Q(0 === f[0] ? b.x : e.x, 0 === f[1] ? b.y : e.y, 0 === f[2] ? b.z : e.z), new Q(0 === f[0] ? e.x : c.x, 0 === f[1] ? e.y : c.y, 0 === f[2] ? e.z : c.z));
      }
    }}]), a;
  }(), Va = [new Uint8Array([0, 0, 0]), new Uint8Array([0, 0, 1]), new Uint8Array([0, 1, 0]), new Uint8Array([0, 1, 1]), new Uint8Array([1, 0, 0]), new Uint8Array([1, 0, 1]), new Uint8Array([1, 1, 0]), new Uint8Array([1, 1, 1])];
  ja = [new Uint8Array([0, 4]), new Uint8Array([1, 5]), new Uint8Array([2, 6]), new Uint8Array([3, 7]), new Uint8Array([0, 2]), new Uint8Array([1, 3]), new Uint8Array([4, 6]), new Uint8Array([5, 7]), new Uint8Array([0, 1]), new Uint8Array([2, 3]), new Uint8Array([4, 5]), new Uint8Array([6, 7])];
  var nb = new Q;
  ea = function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q, c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
      d(this, a);
      this.min = b;
      this.size = c;
      this.children = null;
    }
    return h(a, [{key:"getCenter", value:function() {
      return (0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q).copy(this.min).addScalar(.5 * this.size);
    }}, {key:"getDimensions", value:function() {
      return (0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Q).set(this.size, this.size, this.size);
    }}, {key:"split", value:function() {
      var a, b = this.min, c = this.getCenter(nb), e = .5 * this.size, d = this.children = [null, null, null, null, null, null, null, null];
      for (a = 0; 8 > a; ++a) {
        var f = Va[a];
        d[a] = new this.constructor(new Q(0 === f[0] ? b.x : c.x, 0 === f[1] ? b.y : c.y, 0 === f[2] ? b.z : c.z), e);
      }
    }}, {key:"max", get:function() {
      return this.min.clone().addScalar(this.size);
    }}]), a;
  }();
  var zc = function() {
    function a() {
      var b = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null, c = !!(1 < arguments.length && void 0 !== arguments[1]) && arguments[1];
      d(this, a);
      this.value = b;
      this.done = c;
    }
    return h(a, [{key:"reset", value:function() {
      this.value = null;
      this.done = !1;
    }}]), a;
  }(), Bb = new W, Rb = function() {
    function a(b) {
      var c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null;
      d(this, a);
      this.octree = b;
      this.region = c;
      this.cull = null !== c;
      this.result = new zc;
      this.indices = this.trace = null;
      this.reset();
    }
    $jscomp.initSymbol();
    $jscomp.initSymbolIterator();
    return h(a, [{key:"reset", value:function() {
      var a = this.octree.root;
      return this.trace = [], this.indices = [], null !== a && (Bb.min = a.min, Bb.max = a.max, (!this.cull || this.region.intersectsBox(Bb)) && (this.trace.push(a), this.indices.push(0))), this.result.reset(), this;
    }}, {key:"next", value:function() {
      for (var a, b, c, e = this.cull, d = this.region, f = this.indices, m = this.trace, k = null, h = m.length - 1; null === k && 0 <= h;) {
        if (a = f[h]++, b = m[h].children, 8 > a) {
          if (null !== b) {
            if (c = b[a], !e || (Bb.min = c.min, Bb.max = c.max, d.intersectsBox(Bb))) {
              m.push(c), f.push(0), ++h;
            }
          } else {
            k = m.pop(), f.pop();
          }
        } else {
          m.pop(), f.pop(), --h;
        }
      }
      return this.result.value = k, this.result.done = null === k, this.result;
    }}, {key:"return", value:function(a) {
      return this.result.value = a, this.result.done = !0, this.result;
    }}, {key:Symbol.iterator, value:function() {
      return this;
    }}]), a;
  }(), Cb = [new Q, new Q, new Q], gb = new W, Ac = new gc, Sa = [new Uint8Array([4, 2, 1]), new Uint8Array([5, 3, 8]), new Uint8Array([6, 8, 3]), new Uint8Array([7, 8, 8]), new Uint8Array([8, 6, 5]), new Uint8Array([8, 7, 8]), new Uint8Array([8, 8, 7]), new Uint8Array([8, 8, 8])], za = 0, hb = function() {
    function a() {
      d(this, a);
    }
    return h(a, null, [{key:"intersectOctree", value:function(a, c, e) {
      var d = gb.min.set(0, 0, 0);
      var f = gb.max.subVectors(a.max, a.min);
      var m = a.getDimensions(Cb[0]);
      var k = Cb[1].copy(m).multiplyScalar(.5);
      var h = Ac.origin.copy(c.ray.origin);
      var g = Ac.direction.copy(c.ray.direction);
      h.sub(a.getCenter(Cb[2])).add(k);
      za = 0;
      0 > g.x && (h.x = m.x - h.x, g.x = -g.x, za |= 4);
      0 > g.y && (h.y = m.y - h.y, g.y = -g.y, za |= 2);
      0 > g.z && (h.z = m.z - h.z, g.z = -g.z, za |= 1);
      k = 1 / g.x;
      var r = 1 / g.y;
      m = 1 / g.z;
      g = (d.x - h.x) * k;
      k *= f.x - h.x;
      var n = (d.y - h.y) * r;
      r *= f.y - h.y;
      d = (d.z - h.z) * m;
      f = (f.z - h.z) * m;
      N(N(g, n), d) < S(S(k, r), f) && b(a.root, g, n, d, k, r, f, c, e);
    }}]), a;
  }(), Oa = new W;
  gc = function() {
    function a(b, c) {
      d(this, a);
      this.root = void 0 !== b && void 0 !== c ? new yc(b, c) : null;
    }
    $jscomp.initSymbol();
    $jscomp.initSymbolIterator();
    return h(a, [{key:"getCenter", value:function(a) {
      return this.root.getCenter(a);
    }}, {key:"getDimensions", value:function(a) {
      return this.root.getDimensions(a);
    }}, {key:"getDepth", value:function() {
      return m(this.root);
    }}, {key:"cull", value:function(a) {
      var b = [];
      return q(this.root, a, b), b;
    }}, {key:"findOctantsByLevel", value:function(a) {
      var b = [];
      return y(this.root, a, 0, b), b;
    }}, {key:"raycast", value:function(a) {
      var b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : [];
      return hb.intersectOctree(this, a, b), b;
    }}, {key:"leaves", value:function(a) {
      return new Rb(this, a);
    }}, {key:Symbol.iterator, value:function() {
      return new Rb(this);
    }}, {key:"min", get:function() {
      return this.root.min;
    }}, {key:"max", get:function() {
      return this.root.max;
    }}, {key:"children", get:function() {
      return this.root.children;
    }}]), a;
  }();
  var La = new Q, Ma = function(a) {
    function b(a, c) {
      var e;
      return d(this, b), e = p(this, k(b).call(this, a, c)), e.points = null, e.data = null, e;
    }
    return e(b, a), h(b, [{key:"distanceToSquared", value:function(a) {
      return La.copy(a).clamp(this.min, this.max).sub(a).lengthSquared();
    }}, {key:"distanceToCenterSquared", value:function(a) {
      var b = this.getCenter(La), c = a.x - b.x, e = a.y - b.x;
      a = a.z - b.z;
      return c * c + e * e + a * a;
    }}, {key:"contains", value:function(a, b) {
      var c = this.min, e = this.max;
      return a.x >= c.x - b && a.y >= c.y - b && a.z >= c.z - b && a.x <= e.x + b && a.y <= e.y + b && a.z <= e.z + b;
    }}, {key:"redistribute", value:function(a) {
      var b, c, e, d = this.children, f = this.points, m = this.data;
      if (null !== d && null !== f) {
        var k = 0;
        for (b = f.length; k < b; ++k) {
          var h = f[k];
          var g = m[k];
          var r = 0;
          for (c = d.length; r < c; ++r) {
            if (e = d[r], e.contains(h, a)) {
              null === e.points && (e.points = [], e.data = []);
              e.points.push(h);
              e.data.push(g);
              break;
            }
          }
        }
      }
      this.data = this.points = null;
    }}, {key:"merge", value:function() {
      var a, b, c = this.children;
      if (null !== c) {
        this.points = [];
        this.data = [];
        var e = 0;
        for (a = c.length; e < a; ++e) {
          if (b = c[e], null !== b.points) {
            var d, m;
            (d = this.points).push.apply(d, f(b.points));
            (m = this.data).push.apply(m, f(b.data));
          }
        }
        this.children = null;
      }
    }}]), b;
  }(yc), ib = function Ca(a, b, c) {
    var e = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    d(this, Ca);
    this.distance = a;
    this.distanceToRay = b;
    this.point = c;
    this.object = e;
  }, ob = function(a) {
    function b(a, c) {
      var e, f = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, m = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 8, h = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 8;
      return d(this, b), e = p(this, k(b).call(this)), e.root = new Ma(a, c), e.bias = N(0, f), e.maxPoints = N(1, B(m)), e.maxDepth = N(0, B(h)), e.pointCount = 0, e;
    }
    return e(b, a), h(b, [{key:"countPoints", value:function(a) {
      return x(a);
    }}, {key:"put", value:function(a, b) {
      return z(a, b, this, this.root, 0);
    }}, {key:"remove", value:function(a) {
      return r(a, this, this.root, null);
    }}, {key:"fetch", value:function(a) {
      return u(a, this, this.root);
    }}, {key:"move", value:function(a, b) {
      return v(a, b, this, this.root, null, 0);
    }}, {key:"findNearestPoint", value:function(a) {
      var b = C(a, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1 / 0, !!(2 < arguments.length && void 0 !== arguments[2]) && arguments[2], this.root);
      return null !== b && (b.point = b.point.clone()), b;
    }}, {key:"findPoints", value:function(a, b) {
      var c = [];
      return A(a, b, !!(2 < arguments.length && void 0 !== arguments[2]) && arguments[2], this.root, c), c;
    }}, {key:"raycast", value:function(a) {
      var c = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : [], e = t(k(b.prototype), "raycast", this).call(this, a);
      return 0 < e.length && this.testPoints(e, a, c), c;
    }}, {key:"testPoints", value:function(a, b, c) {
      var e, d, f, m, k, h, g, r = b.params.Points.threshold;
      var n = 0;
      for (m = a.length; n < m; ++n) {
        if (h = a[n], g = h.points, null !== g) {
          var p = 0;
          for (k = g.length; p < k; ++p) {
            var u = g[p];
            var q = b.ray.distanceSqToPoint(u);
            q < r * r && (e = b.ray.closestPointToPoint(u, new Q), d = b.ray.origin.distanceTo(e), d >= b.near && d <= b.far && (f = P(q), c.push(new ib(d, f, e, h.data[p]))));
          }
        }
      }
    }}]), b;
  }(gc), ab = new W, Bc = new Q, pb = new Q, Db = new Q;
  W = function() {
    function a() {
      d(this, a);
    }
    return h(a, null, [{key:"recycleOctants", value:function(a, b) {
      var c, e = a.min, d = a.getCenter(pb), f = a.getDimensions(Db).multiplyScalar(.5), m = a.children, k = b.length;
      for (a = 0; 8 > a; ++a) {
        var h = Va[a];
        ab.min.addVectors(e, Bc.fromArray(h).multiply(f));
        ab.max.addVectors(d, Bc.fromArray(h).multiply(f));
        for (h = 0; h < k; ++h) {
          if (c = b[h], null !== c && ab.min.equals(c.min) && ab.max.equals(c.max)) {
            m[a] = c;
            b[h] = null;
            break;
          }
        }
      }
    }}]), a;
  }();
  a.CubicOctant = ea;
  a.edges = ja;
  a.Octant = yc;
  a.Octree = gc;
  a.OctantIterator = Rb;
  a.OctreeRaycaster = hb;
  a.pattern = Va;
  a.PointOctant = Ma;
  a.PointOctree = ob;
  a.RayPointIntersection = ib;
  a.OctreeUtils = W;
  Object.defineProperty(a, "__esModule", {value:!0});
});
(function e$jscomp$0(a, d, g) {
  function e(c, t) {
    if (!d[c]) {
      if (!a[c]) {
        var f = "function" == typeof require && require;
        if (!t && f) {
          return f(c, !0);
        }
        if (k) {
          return k(c, !0);
        }
        t = Error("Cannot find module '" + c + "'");
        throw t.code = "MODULE_NOT_FOUND", t;
      }
      t = d[c] = {exports:{}};
      a[c][0].call(t.exports, function(d) {
        var b = a[c][1][d];
        return e(b ? b : d);
      }, t, t.exports, e$jscomp$0, a, d, g);
    }
    return d[c].exports;
  }
  for (var k = "function" == typeof require && require, c = 0; c < g.length; c++) {
    e(g[c]);
  }
  return e;
})({1:[function(a, d, g) {
  var h = Object.prototype.toString;
  d.exports = function(a) {
    return a.BYTES_PER_ELEMENT && "[object ArrayBuffer]" === h.call(a.buffer) || Array.isArray(a);
  };
}, {}], 2:[function(a, d, g) {
  d.exports = function(a, e) {
    return "number" === typeof a ? a : "number" === typeof e ? e : 0;
  };
}, {}], 3:[function(a, d, g) {
  d.exports = function(a) {
    switch(a) {
      case "int8":
        return Int8Array;
      case "int16":
        return Int16Array;
      case "int32":
        return Int32Array;
      case "uint8":
        return Uint8Array;
      case "uint16":
        return Uint16Array;
      case "uint32":
        return Uint32Array;
      case "float32":
        return Float32Array;
      case "float64":
        return Float64Array;
      case "array":
        return Array;
      case "uint8_clamped":
        return Uint8ClampedArray;
    }
  };
}, {}], 4:[function(a, d, g) {
  var h = a("dtype");
  d.exports = function(a, d, c) {
    if (!a) {
      throw new TypeError("must specify data as first parameter");
    }
    c = +(c || 0) | 0;
    if (Array.isArray(a) && Array.isArray(a[0])) {
      var e = a[0].length, k = a.length * e;
      d && "string" !== typeof d || (d = new (h(d || "float32"))(k + c));
      var f = d.length - c;
      if (k !== f) {
        throw Error("source length " + k + " (" + e + "x" + a.length + ") does not match destination length " + f);
      }
      for (k = 0; k < a.length; k++) {
        for (f = 0; f < e; f++) {
          d[c++] = a[k][f];
        }
      }
    } else {
      d && "string" !== typeof d ? d.set(a, c) : (d = h(d || "float32"), 0 === c ? d = new d(a) : (d = new d(a.length + c), d.set(a, c)));
    }
    return d;
  };
}, {dtype:3}], 5:[function(a, d, g) {
  d.exports = function(a) {
    if (!a || "string" !== typeof a) {
      throw Error("must specify property for indexof search");
    }
    return new Function("array", "value", "start", ["start = start || 0\nfor (var i=start; i<array.length; i++)", '  if (array[i]["' + a + '"] === value)', "      return i\nreturn -1"].join("\n"));
  };
}, {}], 6:[function(a, d, g) {
  d.exports = "function" === typeof Object.create ? function(a, e) {
    a.super_ = e;
    a.prototype = Object.create(e.prototype, {constructor:{value:a, enumerable:!1, writable:!0, configurable:!0}});
  } : function(a, e) {
    a.super_ = e;
    var d = function() {
    };
    d.prototype = e.prototype;
    a.prototype = new d;
    a.prototype.constructor = a;
  };
}, {}], 7:[function(a, d, g) {
  function h(a) {
    return !!a.constructor && "function" === typeof a.constructor.isBuffer && a.constructor.isBuffer(a);
  }
  d.exports = function(a) {
    return null != a && (h(a) || "function" === typeof a.readFloatLE && "function" === typeof a.slice && h(a.slice(0, 0)) || !!a._isBuffer);
  };
}, {}], 8:[function(a, d, g) {
  function h(a) {
    this.glyphs = [];
    this._measure = this.computeMetrics.bind(this);
    this.update(a);
  }
  function e(a, c) {
    if (!a.chars || 0 === a.chars.length) {
      return null;
    }
    c = b(a.chars, c);
    return 0 <= c ? a.chars[c] : null;
  }
  function k(a) {
    for (var c = 0; c < q.length; c++) {
      var e = q[c].charCodeAt(0);
      e = b(a.chars, e);
      if (0 <= e) {
        return a.chars[e].height;
      }
    }
    return 0;
  }
  function c(a) {
    for (var c = 0; c < x.length; c++) {
      var e = x[c].charCodeAt(0);
      e = b(a.chars, e);
      if (0 <= e) {
        return a.chars[e].height;
      }
    }
    return 0;
  }
  function p(a, b, c) {
    if (!a.kernings || 0 === a.kernings.length) {
      return 0;
    }
    a = a.kernings;
    for (var e = 0; e < a.length; e++) {
      var d = a[e];
      if (d.first === b && d.second === c) {
        return d.amount;
      }
    }
    return 0;
  }
  function t(a) {
    return "center" === a ? 1 : "right" === a ? 2 : 0;
  }
  var f = a("word-wrapper"), n = a("xtend"), b = a("indexof-property")("id"), m = a("as-number"), q = "xeaonsrcumvwz".split(""), y = ["m", "w"], x = "HINEFKLTUVWXYZ".split("");
  d.exports = function(a) {
    return new h(a);
  };
  h.prototype.update = function(a) {
    this._opt = a = n({measure:this._measure}, a);
    this._opt.tabSize = m(this._opt.tabSize, 4);
    if (!a.font) {
      throw Error("must provide a valid bitmap font");
    }
    var b = this.glyphs, e = a.text || "", d = a.font;
    this._setupSpaceGlyphs(d);
    var h = f.lines(e, a), g = a.width || 0;
    b.length = 0;
    var q = h.reduce(function(a, b) {
      return Math.max(a, b.width, g);
    }, 0), y = 0, x = 0, z = m(a.lineHeight, d.common.lineHeight), H = d.common.base, L = z - H, K = a.letterSpacing || 0;
    a = z * h.length - L;
    var P = t(this._opt.align);
    x -= a;
    this._width = q;
    this._height = a;
    this._descender = z - H;
    this._baseline = H;
    this._xHeight = k(d);
    this._capHeight = c(d);
    this._lineHeight = z;
    this._ascender = z - L - this._xHeight;
    var J = this;
    h.forEach(function(a, c) {
      var f = a.end, m = a.width;
      for (a = a.start; a < f; a++) {
        var k = e.charCodeAt(a);
        if (k = J.getGlyph(d, k)) {
          h && (y += p(d, h.id, k.id));
          var h = y;
          1 === P ? h += (q - m) / 2 : 2 === P && (h += q - m);
          b.push({position:[h, x], data:k, index:a, line:c});
          y += k.xadvance + K;
          h = k;
        }
      }
      x += z;
      y = 0;
    });
    this._linesTotal = h.length;
  };
  h.prototype._setupSpaceGlyphs = function(a) {
    this._fallbackTabGlyph = this._fallbackSpaceGlyph = null;
    if (a.chars && 0 !== a.chars.length) {
      var c;
      if (!(c = e(a, 32))) {
        a: {
          for (c = 0; c < y.length; c++) {
            var d = y[c].charCodeAt(0);
            d = b(a.chars, d);
            if (0 <= d) {
              c = a.chars[d];
              break a;
            }
          }
          c = 0;
        }
      }
      a = c || a.chars[0];
      c = this._opt.tabSize * a.xadvance;
      this._fallbackSpaceGlyph = a;
      this._fallbackTabGlyph = n(a, {x:0, y:0, xadvance:c, id:9, xoffset:0, yoffset:0, width:0, height:0});
    }
  };
  h.prototype.getGlyph = function(a, b) {
    return (a = e(a, b)) ? a : 9 === b ? this._fallbackTabGlyph : 32 === b ? this._fallbackSpaceGlyph : null;
  };
  h.prototype.computeMetrics = function(a, b, c, e) {
    var d = this._opt.letterSpacing || 0, f = this._opt.font, m = 0, k = 0, h = 0;
    if (!f.chars || 0 === f.chars.length) {
      return {start:b, end:b, width:0};
    }
    c = Math.min(a.length, c);
    for (var g = b; g < c; g++) {
      var r = a.charCodeAt(g);
      if (r = this.getGlyph(f, r)) {
        var n = q ? p(f, q.id, r.id) : 0;
        m += n;
        n = m + r.xadvance + d;
        var u = m + r.width;
        if (u >= e || n >= e) {
          break;
        }
        m = n;
        k = u;
        var q = r;
      }
      h++;
    }
    q && (k += q.xoffset);
    return {start:b, end:b + h, width:k};
  };
  "width height descender ascender xHeight baseline capHeight lineHeight".split(" ").forEach(function(a) {
    Object.defineProperty(h.prototype, a, {get:(new Function(["return function " + a + "() {", "  return this._" + a, "}"].join("\n")))(), configurable:!0});
  });
}, {"as-number":2, "indexof-property":5, "word-wrapper":15, xtend:16}], 9:[function(a, d, g) {
  var h = Object.prototype.hasOwnProperty, e = Object.prototype.propertyIsEnumerable;
  d.exports = function() {
    try {
      if (!Object.assign) {
        return !1;
      }
      var a = new String("abc");
      a[5] = "de";
      if ("5" === Object.getOwnPropertyNames(a)[0]) {
        return !1;
      }
      var c = {};
      for (a = 0; 10 > a; a++) {
        c["_" + String.fromCharCode(a)] = a;
      }
      if ("0123456789" !== Object.getOwnPropertyNames(c).map(function(a) {
        return c[a];
      }).join("")) {
        return !1;
      }
      var e = {};
      "abcdefghijklmnopqrst".split("").forEach(function(a) {
        e[a] = a;
      });
      return "abcdefghijklmnopqrst" !== Object.keys(Object.assign({}, e)).join("") ? !1 : !0;
    } catch (t) {
      return !1;
    }
  }() ? Object.assign : function(a, c) {
    if (null === a || void 0 === a) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    var d = Object(a);
    for (var k, f = 1; f < arguments.length; f++) {
      var g = Object(arguments[f]);
      for (var b in g) {
        h.call(g, b) && (d[b] = g[b]);
      }
      if (Object.getOwnPropertySymbols) {
        k = Object.getOwnPropertySymbols(g);
        for (var m = 0; m < k.length; m++) {
          e.call(g, k[m]) && (d[k[m]] = g[k[m]]);
        }
      }
    }
    return d;
  };
}, {}], 10:[function(a, d, g) {
  var h = a("dtype"), e = a("an-array"), k = a("is-buffer"), c = [0, 2, 3], p = [2, 1, 3];
  d.exports = function(a, d) {
    a && (e(a) || k(a)) || (d = a || {}, a = null);
    d = "number" === typeof d ? {count:d} : d || {};
    var f = "string" === typeof d.type ? d.type : "uint16", b = d.start || 0, m = !1 !== d.clockwise ? c : p, g = m[0], t = m[1];
    m = m[2];
    d = 6 * ("number" === typeof d.count ? d.count : 1);
    a = a || new (h(f))(d);
    for (var x = f = 0; f < d; f += 6, x += 4) {
      var z = f + b;
      a[z + 0] = x + 0;
      a[z + 1] = x + 1;
      a[z + 2] = x + 2;
      a[z + 3] = x + g;
      a[z + 4] = x + t;
      a[z + 5] = x + m;
    }
    return a;
  };
}, {"an-array":1, dtype:3, "is-buffer":7}], 11:[function(a, d, g) {
  function h(a) {
    n.call(this);
    "string" === typeof a && (a = {text:a});
    this._opt = p({}, a);
    a && this.update(a);
  }
  var e = a("layout-bmfont-text");
  g = a("inherits");
  var k = a("quad-indices"), c = a("three-buffer-vertex-data"), p = a("object-assign"), t = a("./lib/vertices"), f = a("./lib/utils"), n = THREE.BufferGeometry;
  d.exports = function(a) {
    return new h(a);
  };
  g(h, n);
  h.prototype.update = function(a) {
    "string" === typeof a && (a = {text:a});
    a = p({}, this._opt, a);
    if (!a.font) {
      throw new TypeError("must specify a { font } in options");
    }
    this.layout = e(a);
    var b = !1 !== a.flipY, d = a.font, f = d.common.scaleW, h = d.common.scaleH;
    this.visibleGlyphs = d = this.layout.glyphs.filter(function(a) {
      a = a.data;
      return 0 < a.width * a.height;
    });
    var g = t.positions(d);
    b = t.uvs(d, f, h, b);
    f = k({clockwise:!0, type:"uint16", count:d.length});
    c.index(this, f, 1, "uint16");
    c.attr(this, "position", g, 2);
    c.attr(this, "uv", b, 2);
    !a.multipage && "page" in this.attributes ? this.removeAttribute("page") : a.multipage && (a = t.pages(d), c.attr(this, "page", a, 1));
  };
  h.prototype.computeBoundingSphere = function() {
    null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
    var a = this.attributes.position.array, c = this.attributes.position.itemSize;
    !a || !c || 2 > a.length ? (this.boundingSphere.radius = 0, this.boundingSphere.center.set(0, 0, 0)) : (f.computeSphere(a, this.boundingSphere), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.'));
  };
  h.prototype.computeBoundingBox = function() {
    null === this.boundingBox && (this.boundingBox = new THREE.Box3);
    var a = this.boundingBox, c = this.attributes.position.array, e = this.attributes.position.itemSize;
    !c || !e || 2 > c.length ? a.makeEmpty() : f.computeBox(c, a);
  };
}, {"./lib/utils":12, "./lib/vertices":13, inherits:6, "layout-bmfont-text":8, "object-assign":9, "quad-indices":10, "three-buffer-vertex-data":14}], 12:[function(a, d, g) {
  function h(a) {
    var c = a.length / 2;
    e.min[0] = a[0];
    e.min[1] = a[1];
    e.max[0] = a[0];
    e.max[1] = a[1];
    for (var d = 0; d < c; d++) {
      var k = a[2 * d], f = a[2 * d + 1];
      e.min[0] = Math.min(k, e.min[0]);
      e.min[1] = Math.min(f, e.min[1]);
      e.max[0] = Math.max(k, e.max[0]);
      e.max[1] = Math.max(f, e.max[1]);
    }
  }
  var e = {min:[0, 0], max:[0, 0]};
  d.exports.computeBox = function(a, c) {
    h(a);
    c.min.set(e.min[0], e.min[1], 0);
    c.max.set(e.max[0], e.max[1], 0);
  };
  d.exports.computeSphere = function(a, c) {
    h(a);
    a = e.min[0];
    var d = e.min[1], k = e.max[0] - a, f = e.max[1] - d, g = Math.sqrt(k * k + f * f);
    c.center.set(a + k / 2, d + f / 2, 0);
    c.radius = g / 2;
  };
}, {}], 13:[function(a, d, g) {
  d.exports.pages = function(a) {
    var e = new Float32Array(4 * a.length), d = 0;
    a.forEach(function(a) {
      a = a.data.page || 0;
      e[d++] = a;
      e[d++] = a;
      e[d++] = a;
      e[d++] = a;
    });
    return e;
  };
  d.exports.uvs = function(a, e, d, c) {
    var k = new Float32Array(8 * a.length), h = 0;
    a.forEach(function(a) {
      a = a.data;
      var f = a.y + a.height, b = a.x / e, m = a.y / d, g = (a.x + a.width) / e, p = f / d;
      c && (m = (d - a.y) / d, p = (d - f) / d);
      k[h++] = b;
      k[h++] = m;
      k[h++] = b;
      k[h++] = p;
      k[h++] = g;
      k[h++] = p;
      k[h++] = g;
      k[h++] = m;
    });
    return k;
  };
  d.exports.positions = function(a) {
    var e = new Float32Array(8 * a.length), d = 0;
    a.forEach(function(a) {
      var c = a.data, k = a.position[0] + c.xoffset;
      a = a.position[1] + c.yoffset;
      var f = c.width;
      c = c.height;
      e[d++] = k;
      e[d++] = a;
      e[d++] = k;
      e[d++] = a + c;
      e[d++] = k + f;
      e[d++] = a + c;
      e[d++] = k + f;
      e[d++] = a;
    });
    return e;
  };
}, {}], 14:[function(a, d, g) {
  function h(a, c, d, h) {
    c = c || [];
    var f;
    if (!(f = !a)) {
      if (f = c, a.itemSize === d && a.array) {
        var k = a.array.length;
        f = Array.isArray(f) && Array.isArray(f[0]) ? k !== f.length * d : k !== f.length;
      } else {
        f = !0;
      }
    }
    if (f) {
      return c = e(c, h), a = new THREE.BufferAttribute(c, d), a.needsUpdate = !0, a;
    }
    e(c, a.array);
    a.needsUpdate = !0;
    return null;
  }
  var e = a("flatten-vertex-data");
  d.exports.attr = function(a, c, e, d, f) {
    "number" !== typeof d && (d = 3);
    "string" !== typeof f && (f = "float32");
    if (Array.isArray(e) && Array.isArray(e[0]) && e[0].length !== d) {
      throw Error("Nested vertex array has unexpected size; expected " + d + " but found " + e[0].length);
    }
    var k = a.getAttribute(c);
    (e = h(k, e, d, f)) && a.addAttribute(c, e);
  };
  d.exports.index = function(a, c, e, d) {
    "number" !== typeof e && (e = 1);
    "string" !== typeof d && (d = "uint16");
    var f = !a.index && "function" !== typeof a.setIndex, k = f ? a.getAttribute("index") : a.index;
    if (c = h(k, c, e, d)) {
      f ? a.addAttribute("index", c) : a.index = c;
    }
  };
}, {"flatten-vertex-data":4}], 15:[function(a, d, g) {
  function h(a, e, d, f) {
    return {start:e, end:e + Math.min(f, d - e)};
  }
  var e = /\n/, k = /\s/;
  d.exports = function(a, e) {
    return d.exports.lines(a, e).map(function(c) {
      return a.substring(c.start, c.end);
    }).join("\n");
  };
  d.exports.lines = function(a, d) {
    d = d || {};
    if (0 === d.width && "nowrap" !== d.mode) {
      return [];
    }
    a = a || "";
    var c = "number" === typeof d.width ? d.width : Number.MAX_VALUE, f = Math.max(0, d.start || 0), g = "number" === typeof d.end ? d.end : a.length, b = d.mode;
    d = d.measure || h;
    if ("pre" === b) {
      var m = [];
      for (b = f; f < g && f < a.length; f++) {
        var p = a.charAt(f);
        if ((p = e.test(p)) || f === g - 1) {
          b = d(a, b, p ? f : f + 1, c), m.push(b), b = f + 1;
        }
      }
      return m;
    }
    m = f;
    f = [];
    "nowrap" === b && (c = Number.MAX_VALUE);
    for (; m < g && m < a.length;) {
      b = g;
      p = a.indexOf("\n", m);
      for (b = -1 === p || p > b ? b : p; m < b && k.test(a.charAt(m));) {
        m++;
      }
      p = d(a, m, b, c);
      var y = m + (p.end - p.start);
      p = y + 1;
      if (y < b) {
        for (; y > m && !k.test(a.charAt(y));) {
          y--;
        }
        if (y === m) {
          p > m + 1 && p--, y = p;
        } else {
          for (p = y; y > m && k.test(a.charAt(y - 1));) {
            y--;
          }
        }
      }
      y >= m && (m = d(a, m, y, c), f.push(m));
      m = p;
    }
    return f;
  };
}, {}], 16:[function(a, d, g) {
  d.exports = function() {
    for (var a = {}, d = 0; d < arguments.length; d++) {
      var c = arguments[d], g;
      for (g in c) {
        h.call(c, g) && (a[g] = c[g]);
      }
    }
    return a;
  };
  var h = Object.prototype.hasOwnProperty;
}, {}], 17:[function(a, d, g) {
  window.createGeometry = a("three-bmfont-text");
}, {"three-bmfont-text":11}]}, {}, [17]);
!function(a) {
  if ("object" == typeof exports && "undefined" != typeof module) {
    module.exports = a();
  } else {
    var d;
    "undefined" != typeof window ? d = window : "undefined" != typeof global ? d = global : "undefined" != typeof self && (d = self);
    d.CANNON = a();
  }
}(function() {
  return function e(d, g, h) {
    function k(p, f) {
      if (!g[p]) {
        if (!d[p]) {
          var n = "function" == typeof require && require;
          if (!f && n) {
            return n(p, !0);
          }
          if (c) {
            return c(p, !0);
          }
          throw Error("Cannot find module '" + p + "'");
        }
        f = g[p] = {exports:{}};
        d[p][0].call(f.exports, function(b) {
          var c = d[p][1][b];
          return k(c ? c : b);
        }, f, f.exports, e, d, g, h);
      }
      return g[p].exports;
    }
    for (var c = "function" == typeof require && require, p = 0; p < h.length; p++) {
      k(h[p]);
    }
    return k;
  }({1:[function(d, g, h) {
    g.exports = {name:"cannon", version:"0.6.2", description:"A lightweight 3D physics engine written in JavaScript.", homepage:"https://github.com/schteppe/cannon.js", author:"Stefan Hedman <schteppe@gmail.com> (http://steffe.se)", keywords:["cannon.js", "cannon", "physics", "engine", "3d"], main:"./build/cannon.js", engines:{node:"*"}, repository:{type:"git", url:"https://github.com/schteppe/cannon.js.git"}, bugs:{url:"https://github.com/schteppe/cannon.js/issues"}, licenses:[{type:"MIT"}], devDependencies:{jshint:"latest", 
    "uglify-js":"latest", nodeunit:"^0.9.0", grunt:"~0.4.0", "grunt-contrib-jshint":"~0.1.1", "grunt-contrib-nodeunit":"^0.4.1", "grunt-contrib-concat":"~0.1.3", "grunt-contrib-uglify":"^0.5.1", "grunt-browserify":"^2.1.4", "grunt-contrib-yuidoc":"^0.5.2", browserify:"*"}, dependencies:{}};
  }, {}], 2:[function(d, g, h) {
    g.exports = {version:d("../package.json").version, AABB:d("./collision/AABB"), ArrayCollisionMatrix:d("./collision/ArrayCollisionMatrix"), Body:d("./objects/Body"), Box:d("./shapes/Box"), Broadphase:d("./collision/Broadphase"), Constraint:d("./constraints/Constraint"), ContactEquation:d("./equations/ContactEquation"), Narrowphase:d("./world/Narrowphase"), ConeTwistConstraint:d("./constraints/ConeTwistConstraint"), ContactMaterial:d("./material/ContactMaterial"), ConvexPolyhedron:d("./shapes/ConvexPolyhedron"), 
    Cylinder:d("./shapes/Cylinder"), DistanceConstraint:d("./constraints/DistanceConstraint"), Equation:d("./equations/Equation"), EventTarget:d("./utils/EventTarget"), FrictionEquation:d("./equations/FrictionEquation"), GSSolver:d("./solver/GSSolver"), GridBroadphase:d("./collision/GridBroadphase"), Heightfield:d("./shapes/Heightfield"), HingeConstraint:d("./constraints/HingeConstraint"), LockConstraint:d("./constraints/LockConstraint"), Mat3:d("./math/Mat3"), Material:d("./material/Material"), 
    NaiveBroadphase:d("./collision/NaiveBroadphase"), ObjectCollisionMatrix:d("./collision/ObjectCollisionMatrix"), Pool:d("./utils/Pool"), Particle:d("./shapes/Particle"), Plane:d("./shapes/Plane"), PointToPointConstraint:d("./constraints/PointToPointConstraint"), Quaternion:d("./math/Quaternion"), Ray:d("./collision/Ray"), RaycastVehicle:d("./objects/RaycastVehicle"), RaycastResult:d("./collision/RaycastResult"), RigidVehicle:d("./objects/RigidVehicle"), RotationalEquation:d("./equations/RotationalEquation"), 
    RotationalMotorEquation:d("./equations/RotationalMotorEquation"), SAPBroadphase:d("./collision/SAPBroadphase"), SPHSystem:d("./objects/SPHSystem"), Shape:d("./shapes/Shape"), Solver:d("./solver/Solver"), Sphere:d("./shapes/Sphere"), SplitSolver:d("./solver/SplitSolver"), Spring:d("./objects/Spring"), Trimesh:d("./shapes/Trimesh"), Vec3:d("./math/Vec3"), Vec3Pool:d("./utils/Vec3Pool"), World:d("./world/World")};
  }, {"../package.json":1, "./collision/AABB":3, "./collision/ArrayCollisionMatrix":4, "./collision/Broadphase":5, "./collision/GridBroadphase":6, "./collision/NaiveBroadphase":7, "./collision/ObjectCollisionMatrix":8, "./collision/Ray":9, "./collision/RaycastResult":10, "./collision/SAPBroadphase":11, "./constraints/ConeTwistConstraint":12, "./constraints/Constraint":13, "./constraints/DistanceConstraint":14, "./constraints/HingeConstraint":15, "./constraints/LockConstraint":16, "./constraints/PointToPointConstraint":17, 
  "./equations/ContactEquation":19, "./equations/Equation":20, "./equations/FrictionEquation":21, "./equations/RotationalEquation":22, "./equations/RotationalMotorEquation":23, "./material/ContactMaterial":24, "./material/Material":25, "./math/Mat3":27, "./math/Quaternion":28, "./math/Vec3":30, "./objects/Body":31, "./objects/RaycastVehicle":32, "./objects/RigidVehicle":33, "./objects/SPHSystem":34, "./objects/Spring":35, "./shapes/Box":37, "./shapes/ConvexPolyhedron":38, "./shapes/Cylinder":39, 
  "./shapes/Heightfield":40, "./shapes/Particle":41, "./shapes/Plane":42, "./shapes/Shape":43, "./shapes/Sphere":44, "./shapes/Trimesh":45, "./solver/GSSolver":46, "./solver/Solver":47, "./solver/SplitSolver":48, "./utils/EventTarget":49, "./utils/Pool":51, "./utils/Vec3Pool":54, "./world/Narrowphase":55, "./world/World":56}], 3:[function(d, g, h) {
    function e(c) {
      c = c || {};
      this.lowerBound = new k;
      c.lowerBound && this.lowerBound.copy(c.lowerBound);
      this.upperBound = new k;
      c.upperBound && this.upperBound.copy(c.upperBound);
    }
    var k = d("../math/Vec3");
    d("../utils/Utils");
    g.exports = e;
    var c = new k;
    e.prototype.setFromPoints = function(e, d, k, b) {
      var f = this.lowerBound, h = this.upperBound;
      f.copy(e[0]);
      k && k.vmult(f, f);
      h.copy(f);
      for (var g = 1; g < e.length; g++) {
        var n = e[g];
        k && (k.vmult(n, c), n = c);
        n.x > h.x && (h.x = n.x);
        n.x < f.x && (f.x = n.x);
        n.y > h.y && (h.y = n.y);
        n.y < f.y && (f.y = n.y);
        n.z > h.z && (h.z = n.z);
        n.z < f.z && (f.z = n.z);
      }
      d && (d.vadd(f, f), d.vadd(h, h));
      b && (f.x -= b, f.y -= b, f.z -= b, h.x += b, h.y += b, h.z += b);
      return this;
    };
    e.prototype.copy = function(c) {
      this.lowerBound.copy(c.lowerBound);
      this.upperBound.copy(c.upperBound);
      return this;
    };
    e.prototype.clone = function() {
      return (new e).copy(this);
    };
    e.prototype.extend = function(c) {
      var e = c.lowerBound.x;
      this.lowerBound.x > e && (this.lowerBound.x = e);
      e = c.upperBound.x;
      this.upperBound.x < e && (this.upperBound.x = e);
      e = c.lowerBound.y;
      this.lowerBound.y > e && (this.lowerBound.y = e);
      e = c.upperBound.y;
      this.upperBound.y < e && (this.upperBound.y = e);
      e = c.lowerBound.z;
      this.lowerBound.z > e && (this.lowerBound.z = e);
      e = c.upperBound.z;
      this.upperBound.z < e && (this.upperBound.z = e);
    };
    e.prototype.overlaps = function(c) {
      var e = this.lowerBound, d = this.upperBound, b = c.lowerBound;
      c = c.upperBound;
      return (b.x <= d.x && d.x <= c.x || e.x <= c.x && c.x <= d.x) && (b.y <= d.y && d.y <= c.y || e.y <= c.y && c.y <= d.y) && (b.z <= d.z && d.z <= c.z || e.z <= c.z && c.z <= d.z);
    };
    e.prototype.contains = function(c) {
      var e = this.lowerBound, d = this.upperBound, b = c.lowerBound;
      c = c.upperBound;
      return e.x <= b.x && d.x >= c.x && e.y <= b.y && d.y >= c.y && e.z <= b.z && d.z >= c.z;
    };
    e.prototype.getCorners = function(c, e, d, b, m, k, h, g) {
      var f = this.lowerBound, r = this.upperBound;
      c.copy(f);
      e.set(r.x, f.y, f.z);
      d.set(r.x, r.y, f.z);
      b.set(f.x, r.y, r.z);
      m.set(r.x, f.y, f.z);
      k.set(f.x, r.y, f.z);
      h.set(f.x, f.y, r.z);
      g.copy(r);
    };
    var p = [new k, new k, new k, new k, new k, new k, new k, new k];
    e.prototype.toLocalFrame = function(c, e) {
      this.getCorners(p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
      for (var d = 0; 8 !== d; d++) {
        var b = p[d];
        c.pointToLocal(b, b);
      }
      return e.setFromPoints(p);
    };
    e.prototype.toWorldFrame = function(c, e) {
      this.getCorners(p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
      for (var d = 0; 8 !== d; d++) {
        var b = p[d];
        c.pointToWorld(b, b);
      }
      return e.setFromPoints(p);
    };
  }, {"../math/Vec3":30, "../utils/Utils":53}], 4:[function(d, g, h) {
    function e() {
      this.matrix = [];
    }
    g.exports = e;
    e.prototype.get = function(e, c) {
      e = e.index;
      c = c.index;
      if (c > e) {
        var d = c;
        c = e;
        e = d;
      }
      return this.matrix[(e * (e + 1) >> 1) + c - 1];
    };
    e.prototype.set = function(e, c, d) {
      e = e.index;
      c = c.index;
      if (c > e) {
        var k = c;
        c = e;
        e = k;
      }
      this.matrix[(e * (e + 1) >> 1) + c - 1] = d ? 1 : 0;
    };
    e.prototype.reset = function() {
      for (var e = 0, c = this.matrix.length; e !== c; e++) {
        this.matrix[e] = 0;
      }
    };
    e.prototype.setNumObjects = function(e) {
      this.matrix.length = e * (e - 1) >> 1;
    };
  }, {}], 5:[function(d, g, h) {
    function e() {
      this.world = null;
      this.useBoundingBoxes = !1;
      this.dirty = !0;
    }
    var k = d("../objects/Body");
    h = d("../math/Vec3");
    var c = d("../math/Quaternion");
    d("../shapes/Shape");
    d("../shapes/Plane");
    g.exports = e;
    e.prototype.collisionPairs = function(b, c, e) {
      throw Error("collisionPairs not implemented for this BroadPhase class!");
    };
    var p = k.STATIC | k.KINEMATIC;
    e.prototype.needBroadphaseCollision = function(b, c) {
      return 0 !== (b.collisionFilterGroup & c.collisionFilterMask) && 0 !== (c.collisionFilterGroup & b.collisionFilterMask) && (0 === (b.type & p) && b.sleepState !== k.SLEEPING || 0 === (c.type & p) && c.sleepState !== k.SLEEPING) ? !0 : !1;
    };
    e.prototype.intersectionTest = function(b, c, e, d) {
      this.useBoundingBoxes ? this.doBoundingBoxBroadphase(b, c, e, d) : this.doBoundingSphereBroadphase(b, c, e, d);
    };
    var t = new h;
    new h;
    new c;
    new h;
    e.prototype.doBoundingSphereBroadphase = function(b, c, e, d) {
      c.position.vsub(b.position, t);
      var f = Math.pow(b.boundingRadius + c.boundingRadius, 2);
      t.norm2() < f && (e.push(b), d.push(c));
    };
    e.prototype.doBoundingBoxBroadphase = function(b, c, e, d) {
      b.aabbNeedsUpdate && b.computeAABB();
      c.aabbNeedsUpdate && c.computeAABB();
      b.aabb.overlaps(c.aabb) && (e.push(b), d.push(c));
    };
    var f = {keys:[]}, n = [], b = [];
    e.prototype.makePairsUnique = function(c, e) {
      for (var d = c.length, m = 0; m !== d; m++) {
        n[m] = c[m], b[m] = e[m];
      }
      c.length = 0;
      for (m = e.length = 0; m !== d; m++) {
        var k = n[m].id, h = b[m].id;
        k = k < h ? k + "," + h : h + "," + k;
        f[k] = m;
        f.keys.push(k);
      }
      for (m = 0; m !== f.keys.length; m++) {
        k = f.keys.pop(), d = f[k], c.push(n[d]), e.push(b[d]), delete f[k];
      }
    };
    e.prototype.setWorld = function(b) {
    };
    var m = new h;
    e.boundingSphereCheck = function(b, c) {
      b.position.vsub(c.position, m);
      return Math.pow(b.shape.boundingSphereRadius + c.shape.boundingSphereRadius, 2) > m.norm2();
    };
    e.prototype.aabbQuery = function(b, c, e) {
      console.warn(".aabbQuery is not implemented in this Broadphase subclass.");
      return [];
    };
  }, {"../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "../shapes/Plane":42, "../shapes/Shape":43}], 6:[function(d, g, h) {
    function e(e, d, b, m, h) {
      k.apply(this);
      this.nx = b || 10;
      this.ny = m || 10;
      this.nz = h || 10;
      this.aabbMin = e || new c(100, 100, 100);
      this.aabbMax = d || new c(-100, -100, -100);
      e = this.nx * this.ny * this.nz;
      if (0 >= e) {
        throw "GridBroadphase: Each dimension's n must be >0";
      }
      this.bins = [];
      this.binLengths = [];
      this.bins.length = e;
      this.binLengths.length = e;
      for (d = 0; d < e; d++) {
        this.bins[d] = [], this.binLengths[d] = 0;
      }
    }
    g.exports = e;
    var k = d("./Broadphase"), c = d("../math/Vec3"), p = d("../shapes/Shape");
    e.prototype = new k;
    e.prototype.constructor = e;
    var t = new c;
    new c;
    e.prototype.collisionPairs = function(c, e, b) {
      function d(b, c, e, d, f, m, k) {
        b = (b - B) * L | 0;
        c = (c - E) * K | 0;
        e = (e - H) * P | 0;
        d = R((d - B) * L);
        f = R((f - E) * K);
        m = R((m - H) * P);
        0 > b ? b = 0 : b >= g && (b = g - 1);
        0 > c ? c = 0 : c >= r && (c = r - 1);
        0 > e ? e = 0 : e >= n && (e = n - 1);
        0 > d ? d = 0 : d >= g && (d = g - 1);
        0 > f ? f = 0 : f >= r && (f = r - 1);
        0 > m ? m = 0 : m >= n && (m = n - 1);
        b *= v;
        c *= C;
        e *= 1;
        d *= v;
        f *= C;
        for (m *= 1; b <= d; b += v) {
          for (var h = c; h <= f; h += C) {
            for (var p = e; p <= m; p += 1) {
              var u = b + h + p;
              Q[u][Z[u]++] = k;
            }
          }
        }
      }
      var f = c.numObjects();
      c = c.bodies;
      var k = this.aabbMax, h = this.aabbMin, g = this.nx, r = this.ny, n = this.nz, v = r * n, C = n, A = k.x, D = k.y, F = k.z, B = h.x, E = h.y, H = h.z, L = g / (A - B), K = r / (D - E), P = n / (F - H);
      A = (A - B) / g;
      var J = (D - E) / r;
      F = (F - H) / n;
      var I = .5 * Math.sqrt(A * A + J * J + F * F);
      D = p.types;
      var N = D.SPHERE, S = D.PLANE, Q = this.bins, Z = this.binLengths;
      D = this.bins.length;
      for (h = 0; h !== D; h++) {
        Z[h] = 0;
      }
      var R = Math.ceil;
      h = Math.min;
      k = Math.max;
      for (h = 0; h !== f; h++) {
        k = c[h];
        var W = k.shape;
        switch(W.type) {
          case N:
            var O = k.position.x, ca = k.position.y, M = k.position.z;
            W = W.radius;
            d(O - W, ca - W, M - W, O + W, ca + W, M + W, k);
            break;
          case S:
            W.worldNormalNeedsUpdate && W.computeWorldNormal(k.quaternion);
            M = W.worldNormal;
            W = E + .5 * J - k.position.y;
            var V = H + .5 * F - k.position.z, fa = t;
            fa.set(B + .5 * A - k.position.x, W, V);
            for (var ja = O = 0; O !== g; O++, ja += v, fa.y = W, fa.x += A) {
              for (var X = ca = 0; ca !== r; ca++, X += C, fa.z = V, fa.y += J) {
                for (var ea = 0, Y = 0; ea !== n; ea++, Y += 1, fa.z += F) {
                  if (fa.dot(M) < I) {
                    var T = ja + X + Y;
                    Q[T][Z[T]++] = k;
                  }
                }
              }
            }
            break;
          default:
            k.aabbNeedsUpdate && k.computeAABB(), d(k.aabb.lowerBound.x, k.aabb.lowerBound.y, k.aabb.lowerBound.z, k.aabb.upperBound.x, k.aabb.upperBound.y, k.aabb.upperBound.z, k);
        }
      }
      for (h = 0; h !== D; h++) {
        if (f = Z[h], 1 < f) {
          for (c = Q[h], O = 0; O !== f; O++) {
            for (k = c[O], ca = 0; ca !== O; ca++) {
              A = c[ca], this.needBroadphaseCollision(k, A) && this.intersectionTest(k, A, e, b);
            }
          }
        }
      }
      this.makePairsUnique(e, b);
    };
  }, {"../math/Vec3":30, "../shapes/Shape":43, "./Broadphase":5}], 7:[function(d, g, h) {
    function e() {
      k.apply(this);
    }
    g.exports = e;
    var k = d("./Broadphase");
    d = d("./AABB");
    e.prototype = new k;
    e.prototype.constructor = e;
    e.prototype.collisionPairs = function(c, e, d) {
      c = c.bodies;
      var f = c.length, k, b;
      for (k = 0; k !== f; k++) {
        for (b = 0; b !== k; b++) {
          var m = c[k];
          var h = c[b];
          this.needBroadphaseCollision(m, h) && this.intersectionTest(m, h, e, d);
        }
      }
    };
    new d;
    e.prototype.aabbQuery = function(c, e, d) {
      d = d || [];
      for (var f = 0; f < c.bodies.length; f++) {
        var k = c.bodies[f];
        k.aabbNeedsUpdate && k.computeAABB();
        k.aabb.overlaps(e) && d.push(k);
      }
      return d;
    };
  }, {"./AABB":3, "./Broadphase":5}], 8:[function(d, g, h) {
    function e() {
      this.matrix = {};
    }
    g.exports = e;
    e.prototype.get = function(e, c) {
      e = e.id;
      c = c.id;
      if (c > e) {
        var d = c;
        c = e;
        e = d;
      }
      return e + "-" + c in this.matrix;
    };
    e.prototype.set = function(e, c, d) {
      e = e.id;
      c = c.id;
      if (c > e) {
        var k = c;
        c = e;
        e = k;
      }
      d ? this.matrix[e + "-" + c] = !0 : delete this.matrix[e + "-" + c];
    };
    e.prototype.reset = function() {
      this.matrix = {};
    };
    e.prototype.setNumObjects = function(e) {
    };
  }, {}], 9:[function(d, g, h) {
    function e(b, d) {
      this.from = b ? b.clone() : new c;
      this.to = d ? d.clone() : new c;
      this._direction = new c;
      this.precision = 1E-4;
      this.checkCollisionResponse = !0;
      this.skipBackfaces = !1;
      this.collisionFilterGroup = this.collisionFilterMask = -1;
      this.mode = e.ANY;
      this.result = new t;
      this.hasHit = !1;
      this.callback = function(b) {
      };
    }
    function k(c, e, d, f) {
      f.vsub(e, N);
      d.vsub(e, b);
      c.vsub(e, m);
      c = N.dot(N);
      e = N.dot(b);
      d = N.dot(m);
      f = b.dot(b);
      var k = b.dot(m), h, g;
      return 0 <= (h = f * d - e * k) && 0 <= (g = c * k - e * d) && h + g < c * f - e * e;
    }
    g.exports = e;
    var c = d("../math/Vec3");
    g = d("../math/Quaternion");
    var p = d("../math/Transform");
    d("../shapes/ConvexPolyhedron");
    d("../shapes/Box");
    var t = d("../collision/RaycastResult");
    h = d("../shapes/Shape");
    d = d("../collision/AABB");
    e.prototype.constructor = e;
    e.CLOSEST = 1;
    e.ANY = 2;
    e.ALL = 4;
    var f = new d, n = [];
    e.prototype.intersectWorld = function(b, c) {
      this.mode = c.mode || e.ANY;
      this.result = c.result || new t;
      this.skipBackfaces = !!c.skipBackfaces;
      this.collisionFilterMask = "undefined" !== typeof c.collisionFilterMask ? c.collisionFilterMask : -1;
      this.collisionFilterGroup = "undefined" !== typeof c.collisionFilterGroup ? c.collisionFilterGroup : -1;
      c.from && this.from.copy(c.from);
      c.to && this.to.copy(c.to);
      this.callback = c.callback || function() {
      };
      this.hasHit = !1;
      this.result.reset();
      this._updateDirection();
      this.getAABB(f);
      n.length = 0;
      b.broadphase.aabbQuery(b, f, n);
      this.intersectBodies(n);
      return this.hasHit;
    };
    var b = new c, m = new c;
    e.pointInTriangle = k;
    var q = new c, y = new g;
    e.prototype.intersectBody = function(b, c) {
      c && (this.result = c, this._updateDirection());
      c = this.checkCollisionResponse;
      if ((!c || b.collisionResponse) && 0 !== (this.collisionFilterGroup & b.collisionFilterMask) && 0 !== (b.collisionFilterGroup & this.collisionFilterMask)) {
        for (var e = 0, d = b.shapes.length; e < d; e++) {
          var f = b.shapes[e];
          if (!c || f.collisionResponse) {
            if (b.quaternion.mult(b.shapeOrientations[e], y), b.quaternion.vmult(b.shapeOffsets[e], q), q.vadd(b.position, q), this.intersectShape(f, y, q, b), this.result._shouldStop) {
              break;
            }
          }
        }
      }
    };
    e.prototype.intersectBodies = function(b, c) {
      c && (this.result = c, this._updateDirection());
      c = 0;
      for (var e = b.length; !this.result._shouldStop && c < e; c++) {
        this.intersectBody(b[c]);
      }
    };
    e.prototype._updateDirection = function() {
      this.to.vsub(this.from, this._direction);
      this._direction.normalize();
    };
    e.prototype.intersectShape = function(b, c, e, d) {
      var f = this.from, m = this._direction;
      e.vsub(f, N);
      var k = N.dot(m);
      m.mult(k, S);
      S.vadd(f, S);
      e.distanceTo(S) > b.boundingSphereRadius || (f = this[b.type]) && f.call(this, b, c, e, d);
    };
    new c;
    new c;
    var x = new c, z = new c, r = new c, u = new c;
    new c;
    new t;
    e.prototype.intersectBox = function(b, c, e, d) {
      return this.intersectConvex(b.convexPolyhedronRepresentation, c, e, d);
    };
    e.prototype[h.types.BOX] = e.prototype.intersectBox;
    e.prototype.intersectPlane = function(b, e, d, f) {
      var m = this.from, k = this.to, h = this._direction, g = new c(0, 0, 1);
      e.vmult(g, g);
      var r = new c;
      m.vsub(d, r);
      e = r.dot(g);
      k.vsub(d, r);
      r = r.dot(g);
      if (!(0 < e * r || m.distanceTo(k) < e || (r = g.dot(h), Math.abs(r) < this.precision))) {
        var n = new c;
        k = new c;
        e = new c;
        m.vsub(d, n);
        d = -g.dot(n) / r;
        h.scale(d, k);
        m.vadd(k, e);
        this.reportIntersection(g, e, b, f, -1);
      }
    };
    e.prototype[h.types.PLANE] = e.prototype.intersectPlane;
    e.prototype.getAABB = function(b) {
      var c = this.to, e = this.from;
      b.lowerBound.x = Math.min(c.x, e.x);
      b.lowerBound.y = Math.min(c.y, e.y);
      b.lowerBound.z = Math.min(c.z, e.z);
      b.upperBound.x = Math.max(c.x, e.x);
      b.upperBound.y = Math.max(c.y, e.y);
      b.upperBound.z = Math.max(c.z, e.z);
    };
    var v = {faceList:[0]};
    e.prototype.intersectHeightfield = function(b, d, f, m) {
      var k = new c, h = new e(this.from, this.to);
      p.pointToLocalFrame(f, d, h.from, h.from);
      p.pointToLocalFrame(f, d, h.to, h.to);
      var g = [], r = null, n = null, u = null, q = null, t = b.getIndexOfPosition(h.from.x, h.from.y, g, !1);
      t && (r = g[0], n = g[1], u = g[0], q = g[1]);
      if (t = b.getIndexOfPosition(h.to.x, h.to.y, g, !1)) {
        if (null === r || g[0] < r) {
          r = g[0];
        }
        if (null === u || g[0] > u) {
          u = g[0];
        }
        if (null === n || g[1] < n) {
          n = g[1];
        }
        if (null === q || g[1] > q) {
          q = g[1];
        }
      }
      if (null !== r) {
        for (b.getRectMinMax(r, n, u, q, []), h = r; h <= u; h++) {
          for (g = n; g <= q; g++) {
            if (this.result._shouldStop) {
              return;
            }
            b.getConvexTrianglePillar(h, g, !1);
            p.pointToWorldFrame(f, d, b.pillarOffset, k);
            this.intersectConvex(b.pillarConvex, d, k, m, v);
            if (this.result._shouldStop) {
              return;
            }
            b.getConvexTrianglePillar(h, g, !0);
            p.pointToWorldFrame(f, d, b.pillarOffset, k);
            this.intersectConvex(b.pillarConvex, d, k, m, v);
          }
        }
      }
    };
    e.prototype[h.types.HEIGHTFIELD] = e.prototype.intersectHeightfield;
    var C = new c, A = new c;
    e.prototype.intersectSphere = function(b, c, e, d) {
      c = this.from;
      var f = this.to, m = Math.pow(f.x - c.x, 2) + Math.pow(f.y - c.y, 2) + Math.pow(f.z - c.z, 2), k = 2 * ((f.x - c.x) * (c.x - e.x) + (f.y - c.y) * (c.y - e.y) + (f.z - c.z) * (c.z - e.z)), h = Math.pow(k, 2) - 4 * m * (Math.pow(c.x - e.x, 2) + Math.pow(c.y - e.y, 2) + Math.pow(c.z - e.z, 2) - Math.pow(b.radius, 2));
      if (!(0 > h)) {
        if (0 === h) {
          c.lerp(f, h, C), C.vsub(e, A), A.normalize(), this.reportIntersection(A, C, b, d, -1);
        } else {
          var g = (-k - Math.sqrt(h)) / (2 * m);
          m = (-k + Math.sqrt(h)) / (2 * m);
          0 <= g && 1 >= g && (c.lerp(f, g, C), C.vsub(e, A), A.normalize(), this.reportIntersection(A, C, b, d, -1));
          !this.result._shouldStop && 0 <= m && 1 >= m && (c.lerp(f, m, C), C.vsub(e, A), A.normalize(), this.reportIntersection(A, C, b, d, -1));
        }
      }
    };
    e.prototype[h.types.SPHERE] = e.prototype.intersectSphere;
    var D = new c;
    new c;
    new c;
    var F = new c;
    e.prototype.intersectConvex = function(b, c, e, d, f) {
      f = f && f.faceList || null;
      for (var m = b.faces, h = b.vertices, g = b.faceNormals, n = this._direction, p = this.from, q = p.distanceTo(this.to), t = f ? f.length : m.length, v = this.result, y = 0; !v._shouldStop && y < t; y++) {
        var C = f ? f[y] : y, A = m[C], B = g[C], E = c, J = e;
        F.copy(h[A[0]]);
        E.vmult(F, F);
        F.vadd(J, F);
        F.vsub(p, F);
        E.vmult(B, D);
        B = n.dot(D);
        if (!(Math.abs(B) < this.precision || (B = D.dot(F) / B, 0 > B))) {
          for (n.mult(B, x), x.vadd(p, x), z.copy(h[A[0]]), E.vmult(z, z), J.vadd(z, z), B = 1; !v._shouldStop && B < A.length - 1; B++) {
            r.copy(h[A[B]]);
            u.copy(h[A[B + 1]]);
            E.vmult(r, r);
            E.vmult(u, u);
            J.vadd(r, r);
            J.vadd(u, u);
            var H = x.distanceTo(p);
            !k(x, z, r, u) && !k(x, r, z, u) || H > q || this.reportIntersection(D, x, b, d, C);
          }
        }
      }
    };
    e.prototype[h.types.CONVEXPOLYHEDRON] = e.prototype.intersectConvex;
    var B = new c, E = new c, H = new c, L = new c, K = new c, P = new c;
    new d;
    var J = [], I = new p;
    e.prototype.intersectTrimesh = function(b, c, e, d, f) {
      f = b.indices;
      var m = this.from, h = this.to, g = this._direction;
      I.position.copy(e);
      I.quaternion.copy(c);
      p.vectorToLocalFrame(e, c, g, E);
      p.pointToLocalFrame(e, c, m, H);
      p.pointToLocalFrame(e, c, h, L);
      m = H.distanceSquared(L);
      b.tree.rayQuery(this, I, J);
      h = 0;
      for (g = J.length; !this.result._shouldStop && h !== g; h++) {
        var n = J[h];
        b.getNormal(n, B);
        b.getVertex(f[3 * n], z);
        z.vsub(H, F);
        var q = E.dot(B);
        q = B.dot(F) / q;
        0 > q || (E.scale(q, x), x.vadd(H, x), b.getVertex(f[3 * n + 1], r), b.getVertex(f[3 * n + 2], u), q = x.distanceSquared(H), !k(x, r, z, u) && !k(x, z, r, u) || q > m || (p.vectorToWorldFrame(c, B, K), p.pointToWorldFrame(e, c, x, P), this.reportIntersection(K, P, b, d, n)));
      }
      J.length = 0;
    };
    e.prototype[h.types.TRIMESH] = e.prototype.intersectTrimesh;
    e.prototype.reportIntersection = function(b, c, d, f, m) {
      var k = this.from, h = this.to, g = k.distanceTo(c), r = this.result;
      if (!(this.skipBackfaces && 0 < b.dot(this._direction))) {
        switch(r.hitFaceIndex = "undefined" !== typeof m ? m : -1, this.mode) {
          case e.ALL:
            this.hasHit = !0;
            r.set(k, h, b, c, d, f, g);
            r.hasHit = !0;
            this.callback(r);
            break;
          case e.CLOSEST:
            if (g < r.distance || !r.hasHit) {
              this.hasHit = !0, r.hasHit = !0, r.set(k, h, b, c, d, f, g);
            }
            break;
          case e.ANY:
            this.hasHit = !0, r.hasHit = !0, r.set(k, h, b, c, d, f, g), r._shouldStop = !0;
        }
      }
    };
    var N = new c, S = new c;
  }, {"../collision/AABB":3, "../collision/RaycastResult":10, "../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "../shapes/Box":37, "../shapes/ConvexPolyhedron":38, "../shapes/Shape":43}], 10:[function(d, g, h) {
    function e() {
      this.rayFromWorld = new k;
      this.rayToWorld = new k;
      this.hitNormalWorld = new k;
      this.hitPointWorld = new k;
      this.hasHit = !1;
      this.body = this.shape = null;
      this.distance = this.hitFaceIndex = -1;
      this._shouldStop = !1;
    }
    var k = d("../math/Vec3");
    g.exports = e;
    e.prototype.reset = function() {
      this.rayFromWorld.setZero();
      this.rayToWorld.setZero();
      this.hitNormalWorld.setZero();
      this.hitPointWorld.setZero();
      this.hasHit = !1;
      this.body = this.shape = null;
      this.distance = this.hitFaceIndex = -1;
      this._shouldStop = !1;
    };
    e.prototype.abort = function() {
      this._shouldStop = !0;
    };
    e.prototype.set = function(c, e, d, f, k, b, m) {
      this.rayFromWorld.copy(c);
      this.rayToWorld.copy(e);
      this.hitNormalWorld.copy(d);
      this.hitPointWorld.copy(f);
      this.shape = k;
      this.body = b;
      this.distance = m;
    };
  }, {"../math/Vec3":30}], 11:[function(d, g, h) {
    function e(c) {
      k.apply(this);
      this.axisList = [];
      this.world = null;
      this.axisIndex = 0;
      var e = this.axisList;
      this._addBodyHandler = function(c) {
        e.push(c.body);
      };
      this._removeBodyHandler = function(c) {
        c = e.indexOf(c.body);
        -1 !== c && e.splice(c, 1);
      };
      c && this.setWorld(c);
    }
    d("../shapes/Shape");
    var k = d("../collision/Broadphase");
    g.exports = e;
    e.prototype = new k;
    e.prototype.setWorld = function(c) {
      for (var e = this.axisList.length = 0; e < c.bodies.length; e++) {
        this.axisList.push(c.bodies[e]);
      }
      c.removeEventListener("addBody", this._addBodyHandler);
      c.removeEventListener("removeBody", this._removeBodyHandler);
      c.addEventListener("addBody", this._addBodyHandler);
      c.addEventListener("removeBody", this._removeBodyHandler);
      this.world = c;
      this.dirty = !0;
    };
    e.insertionSortX = function(c) {
      for (var e = 1, d = c.length; e < d; e++) {
        for (var f = c[e], k = e - 1; 0 <= k && !(c[k].aabb.lowerBound.x <= f.aabb.lowerBound.x); k--) {
          c[k + 1] = c[k];
        }
        c[k + 1] = f;
      }
      return c;
    };
    e.insertionSortY = function(c) {
      for (var e = 1, d = c.length; e < d; e++) {
        for (var f = c[e], k = e - 1; 0 <= k && !(c[k].aabb.lowerBound.y <= f.aabb.lowerBound.y); k--) {
          c[k + 1] = c[k];
        }
        c[k + 1] = f;
      }
      return c;
    };
    e.insertionSortZ = function(c) {
      for (var e = 1, d = c.length; e < d; e++) {
        for (var f = c[e], k = e - 1; 0 <= k && !(c[k].aabb.lowerBound.z <= f.aabb.lowerBound.z); k--) {
          c[k + 1] = c[k];
        }
        c[k + 1] = f;
      }
      return c;
    };
    e.prototype.collisionPairs = function(c, d, k) {
      c = this.axisList;
      var f = c.length, h = this.axisIndex, b, m;
      this.dirty && (this.sortList(), this.dirty = !1);
      for (b = 0; b !== f; b++) {
        var g = c[b];
        for (m = b + 1; m < f; m++) {
          var p = c[m];
          if (this.needBroadphaseCollision(g, p)) {
            if (!e.checkBounds(g, p, h)) {
              break;
            }
            this.intersectionTest(g, p, d, k);
          }
        }
      }
    };
    e.prototype.sortList = function() {
      for (var c = this.axisList, d = this.axisIndex, k = c.length, f = 0; f !== k; f++) {
        var h = c[f];
        h.aabbNeedsUpdate && h.computeAABB();
      }
      0 === d ? e.insertionSortX(c) : 1 === d ? e.insertionSortY(c) : 2 === d && e.insertionSortZ(c);
    };
    e.checkBounds = function(c, e, d) {
      if (0 === d) {
        var f = c.position.x;
        var k = e.position.x;
      } else {
        1 === d ? (f = c.position.y, k = e.position.y) : 2 === d && (f = c.position.z, k = e.position.z);
      }
      return k - e.boundingRadius < f + c.boundingRadius;
    };
    e.prototype.autoDetectAxis = function() {
      for (var c = 0, e = 0, d = 0, f = 0, k = 0, b = 0, m = this.axisList, h = m.length, g = 1 / h, x = 0; x !== h; x++) {
        var z = m[x], r = z.position.x;
        c += r;
        e += r * r;
        r = z.position.y;
        d += r;
        f += r * r;
        z = z.position.z;
        k += z;
        b += z * z;
      }
      c = e - c * c * g;
      d = f - d * d * g;
      k = b - k * k * g;
      this.axisIndex = c > d ? c > k ? 0 : 2 : d > k ? 1 : 2;
    };
    e.prototype.aabbQuery = function(c, e, d) {
      d = d || [];
      this.dirty && (this.sortList(), this.dirty = !1);
      c = this.axisList;
      for (var f = 0; f < c.length; f++) {
        var k = c[f];
        k.aabbNeedsUpdate && k.computeAABB();
        k.aabb.overlaps(e) && d.push(k);
      }
      return d;
    };
  }, {"../collision/Broadphase":5, "../shapes/Shape":43}], 12:[function(d, g, h) {
    function e(e, d, b) {
      b = b || {};
      var f = "undefined" !== typeof b.maxForce ? b.maxForce : 1E6, h = b.pivotA ? b.pivotA.clone() : new t, g = b.pivotB ? b.pivotB.clone() : new t;
      this.axisA = b.axisA ? b.axisA.clone() : new t;
      this.axisB = b.axisB ? b.axisB.clone() : new t;
      k.call(this, e, h, d, g, f);
      this.collideConnected = !!b.collideConnected;
      this.angle = "undefined" !== typeof b.angle ? b.angle : 0;
      h = this.coneEquation = new c(e, d, b);
      e = this.twistEquation = new p(e, d, b);
      this.twistAngle = "undefined" !== typeof b.twistAngle ? b.twistAngle : 0;
      h.maxForce = 0;
      h.minForce = -f;
      e.maxForce = 0;
      e.minForce = -f;
      this.equations.push(h, e);
    }
    g.exports = e;
    d("./Constraint");
    var k = d("./PointToPointConstraint"), c = d("../equations/ConeEquation"), p = d("../equations/RotationalEquation");
    d("../equations/ContactEquation");
    var t = d("../math/Vec3");
    e.prototype = new k;
    e.constructor = e;
    new t;
    new t;
    e.prototype.update = function() {
      var c = this.bodyA, e = this.bodyB, b = this.coneEquation, d = this.twistEquation;
      k.prototype.update.call(this);
      c.vectorToWorldFrame(this.axisA, b.axisA);
      e.vectorToWorldFrame(this.axisB, b.axisB);
      this.axisA.tangents(d.axisA, d.axisA);
      c.vectorToWorldFrame(d.axisA, d.axisA);
      this.axisB.tangents(d.axisB, d.axisB);
      e.vectorToWorldFrame(d.axisB, d.axisB);
      b.angle = this.angle;
      d.maxAngle = this.twistAngle;
    };
  }, {"../equations/ConeEquation":18, "../equations/ContactEquation":19, "../equations/RotationalEquation":22, "../math/Vec3":30, "./Constraint":13, "./PointToPointConstraint":17}], 13:[function(d, g, h) {
    function e(c, d, h) {
      h = k.defaults(h, {collideConnected:!0, wakeUpBodies:!0});
      this.equations = [];
      this.bodyA = c;
      this.bodyB = d;
      this.id = e.idCounter++;
      this.collideConnected = h.collideConnected;
      h.wakeUpBodies && (c && c.wakeUp(), d && d.wakeUp());
    }
    g.exports = e;
    var k = d("../utils/Utils");
    e.prototype.update = function() {
      throw Error("method update() not implmemented in this Constraint subclass!");
    };
    e.prototype.enable = function() {
      for (var c = this.equations, e = 0; e < c.length; e++) {
        c[e].enabled = !0;
      }
    };
    e.prototype.disable = function() {
      for (var c = this.equations, e = 0; e < c.length; e++) {
        c[e].enabled = !1;
      }
    };
    e.idCounter = 0;
  }, {"../utils/Utils":53}], 14:[function(d, g, h) {
    function e(e, d, f, h) {
      k.call(this, e, d);
      "undefined" === typeof f && (f = e.position.distanceTo(d.position));
      "undefined" === typeof h && (h = 1E6);
      this.distance = f;
      e = this.distanceEquation = new c(e, d);
      this.equations.push(e);
      e.minForce = -h;
      e.maxForce = h;
    }
    g.exports = e;
    var k = d("./Constraint"), c = d("../equations/ContactEquation");
    e.prototype = new k;
    e.prototype.update = function() {
      var c = this.distanceEquation, e = .5 * this.distance, d = c.ni;
      this.bodyB.position.vsub(this.bodyA.position, d);
      d.normalize();
      d.mult(e, c.ri);
      d.mult(-e, c.rj);
    };
  }, {"../equations/ContactEquation":19, "./Constraint":13}], 15:[function(d, g, h) {
    function e(b, e, d) {
      d = d || {};
      var f = "undefined" !== typeof d.maxForce ? d.maxForce : 1E6, m = d.pivotA ? d.pivotA.clone() : new t, h = d.pivotB ? d.pivotB.clone() : new t;
      k.call(this, b, m, e, h, f);
      (this.axisA = d.axisA ? d.axisA.clone() : new t(1, 0, 0)).normalize();
      (this.axisB = d.axisB ? d.axisB.clone() : new t(1, 0, 0)).normalize();
      m = this.rotationalEquation1 = new c(b, e, d);
      d = this.rotationalEquation2 = new c(b, e, d);
      b = this.motorEquation = new p(b, e, f);
      b.enabled = !1;
      this.equations.push(m, d, b);
    }
    g.exports = e;
    d("./Constraint");
    var k = d("./PointToPointConstraint"), c = d("../equations/RotationalEquation"), p = d("../equations/RotationalMotorEquation");
    d("../equations/ContactEquation");
    var t = d("../math/Vec3");
    e.prototype = new k;
    e.constructor = e;
    e.prototype.enableMotor = function() {
      this.motorEquation.enabled = !0;
    };
    e.prototype.disableMotor = function() {
      this.motorEquation.enabled = !1;
    };
    e.prototype.setMotorSpeed = function(b) {
      this.motorEquation.targetVelocity = b;
    };
    e.prototype.setMotorMaxForce = function(b) {
      this.motorEquation.maxForce = b;
      this.motorEquation.minForce = -b;
    };
    var f = new t, n = new t;
    e.prototype.update = function() {
      var b = this.bodyA, c = this.bodyB, e = this.motorEquation, d = this.rotationalEquation1, h = this.rotationalEquation2, g = this.axisA, r = this.axisB;
      k.prototype.update.call(this);
      b.quaternion.vmult(g, f);
      c.quaternion.vmult(r, n);
      f.tangents(d.axisA, h.axisA);
      d.axisB.copy(n);
      h.axisB.copy(n);
      this.motorEquation.enabled && (b.quaternion.vmult(this.axisA, e.axisA), c.quaternion.vmult(this.axisB, e.axisB));
    };
  }, {"../equations/ContactEquation":19, "../equations/RotationalEquation":22, "../equations/RotationalMotorEquation":23, "../math/Vec3":30, "./Constraint":13, "./PointToPointConstraint":17}], 16:[function(d, g, h) {
    function e(e, d, h) {
      h = h || {};
      var b = "undefined" !== typeof h.maxForce ? h.maxForce : 1E6, f = new p, g = new p, n = new p;
      e.position.vadd(d.position, n);
      n.scale(.5, n);
      d.pointToLocalFrame(n, g);
      e.pointToLocalFrame(n, f);
      k.call(this, e, f, d, g, b);
      b = this.rotationalEquation1 = new c(e, d, h);
      f = this.rotationalEquation2 = new c(e, d, h);
      e = this.rotationalEquation3 = new c(e, d, h);
      this.equations.push(b, f, e);
    }
    g.exports = e;
    d("./Constraint");
    var k = d("./PointToPointConstraint"), c = d("../equations/RotationalEquation");
    d("../equations/RotationalMotorEquation");
    d("../equations/ContactEquation");
    var p = d("../math/Vec3");
    e.prototype = new k;
    e.constructor = e;
    new p;
    new p;
    e.prototype.update = function() {
      var c = this.bodyA, e = this.bodyB, d = this.rotationalEquation1, b = this.rotationalEquation2, m = this.rotationalEquation3;
      k.prototype.update.call(this);
      c.vectorToWorldFrame(p.UNIT_X, d.axisA);
      e.vectorToWorldFrame(p.UNIT_Y, d.axisB);
      c.vectorToWorldFrame(p.UNIT_Y, b.axisA);
      e.vectorToWorldFrame(p.UNIT_Z, b.axisB);
      c.vectorToWorldFrame(p.UNIT_Z, m.axisA);
      e.vectorToWorldFrame(p.UNIT_X, m.axisB);
    };
  }, {"../equations/ContactEquation":19, "../equations/RotationalEquation":22, "../equations/RotationalMotorEquation":23, "../math/Vec3":30, "./Constraint":13, "./PointToPointConstraint":17}], 17:[function(d, g, h) {
    function e(e, d, h, b, m) {
      k.call(this, e, h);
      m = "undefined" !== typeof m ? m : 1E6;
      this.pivotA = d ? d.clone() : new p;
      this.pivotB = b ? b.clone() : new p;
      d = this.equationX = new c(e, h);
      b = this.equationY = new c(e, h);
      e = this.equationZ = new c(e, h);
      this.equations.push(d, b, e);
      d.minForce = b.minForce = e.minForce = -m;
      d.maxForce = b.maxForce = e.maxForce = m;
      d.ni.set(1, 0, 0);
      b.ni.set(0, 1, 0);
      e.ni.set(0, 0, 1);
    }
    g.exports = e;
    var k = d("./Constraint"), c = d("../equations/ContactEquation"), p = d("../math/Vec3");
    e.prototype = new k;
    e.prototype.update = function() {
      var c = this.bodyB, e = this.equationX, d = this.equationY, b = this.equationZ;
      this.bodyA.quaternion.vmult(this.pivotA, e.ri);
      c.quaternion.vmult(this.pivotB, e.rj);
      d.ri.copy(e.ri);
      d.rj.copy(e.rj);
      b.ri.copy(e.ri);
      b.rj.copy(e.rj);
    };
  }, {"../equations/ContactEquation":19, "../math/Vec3":30, "./Constraint":13}], 18:[function(d, g, h) {
    function e(e, d, b) {
      b = b || {};
      var f = "undefined" !== typeof b.maxForce ? b.maxForce : 1E6;
      c.call(this, e, d, -f, f);
      this.axisA = b.axisA ? b.axisA.clone() : new k(1, 0, 0);
      this.axisB = b.axisB ? b.axisB.clone() : new k(0, 1, 0);
      this.angle = "undefined" !== typeof b.angle ? b.angle : 0;
    }
    g.exports = e;
    var k = d("../math/Vec3");
    d("../math/Mat3");
    var c = d("./Equation");
    e.prototype = new c;
    e.prototype.constructor = e;
    var p = new k, t = new k;
    e.prototype.computeB = function(c) {
      var e = this.a, b = this.b, d = this.axisA, f = this.axisB, k = this.jacobianElementA, h = this.jacobianElementB;
      d.cross(f, p);
      f.cross(d, t);
      k.rotational.copy(t);
      h.rotational.copy(p);
      d = Math.cos(this.angle) - d.dot(f);
      f = this.computeGW();
      k = this.computeGiMf();
      return -d * e - f * b - c * k;
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 19:[function(d, g, h) {
    function e(b, e, d) {
      k.call(this, b, e, 0, "undefined" !== typeof d ? d : 1E6);
      this.restitution = 0;
      this.ri = new c;
      this.rj = new c;
      this.ni = new c;
    }
    g.exports = e;
    var k = d("./Equation"), c = d("../math/Vec3");
    d("../math/Mat3");
    e.prototype = new k;
    e.prototype.constructor = e;
    var p = new c, t = new c, f = new c;
    e.prototype.computeB = function(b) {
      var c = this.a, e = this.b, d = this.bi, m = this.bj, k = this.ri, h = this.rj, g = d.velocity, n = d.angularVelocity, q = m.velocity, y = m.angularVelocity, x = this.jacobianElementA, L = this.jacobianElementB, K = this.ni;
      k.cross(K, p);
      h.cross(K, t);
      K.negate(x.spatial);
      p.negate(x.rotational);
      L.spatial.copy(K);
      L.rotational.copy(t);
      f.copy(m.position);
      f.vadd(h, f);
      f.vsub(d.position, f);
      f.vsub(k, f);
      d = K.dot(f);
      m = this.restitution + 1;
      g = m * q.dot(K) - m * g.dot(K) + y.dot(t) - n.dot(p);
      n = this.computeGiMf();
      return -d * c - g * e - b * n;
    };
    var n = new c, b = new c, m = new c, q = new c, y = new c;
    e.prototype.getImpactVelocityAlongNormal = function() {
      this.bi.position.vadd(this.ri, m);
      this.bj.position.vadd(this.rj, q);
      this.bi.getVelocityAtWorldPoint(m, n);
      this.bj.getVelocityAtWorldPoint(q, b);
      n.vsub(b, y);
      return this.ni.dot(y);
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 20:[function(d, g, h) {
    function e(b, c, d, f) {
      this.id = e.id++;
      this.minForce = "undefined" === typeof d ? -1E6 : d;
      this.maxForce = "undefined" === typeof f ? 1E6 : f;
      this.bi = b;
      this.bj = c;
      this.eps = this.b = this.a = 0;
      this.jacobianElementA = new k;
      this.jacobianElementB = new k;
      this.enabled = !0;
      this.setSpookParams(1E7, 4, 1 / 60);
    }
    g.exports = e;
    var k = d("../math/JacobianElement");
    d = d("../math/Vec3");
    e.prototype.constructor = e;
    e.id = 0;
    e.prototype.setSpookParams = function(b, c, e) {
      this.a = 4 / (e * (1 + 4 * c));
      this.b = 4 * c / (1 + 4 * c);
      this.eps = 4 / (e * e * b * (1 + 4 * c));
    };
    e.prototype.computeB = function(b, c, e) {
      var d = this.computeGW(), f = this.computeGq(), m = this.computeGiMf();
      return -f * b - d * c - m * e;
    };
    e.prototype.computeGq = function() {
      var b = this.jacobianElementB, c = this.bj.position;
      return this.jacobianElementA.spatial.dot(this.bi.position) + b.spatial.dot(c);
    };
    var c = new d;
    e.prototype.computeGW = function() {
      var b = this.jacobianElementB, e = this.bi, d = this.bj, f = d.velocity;
      d = d.angularVelocity || c;
      return this.jacobianElementA.multiplyVectors(e.velocity, e.angularVelocity || c) + b.multiplyVectors(f, d);
    };
    e.prototype.computeGWlambda = function() {
      var b = this.jacobianElementB, e = this.bi, d = this.bj, f = d.vlambda;
      d = d.wlambda || c;
      return this.jacobianElementA.multiplyVectors(e.vlambda, e.wlambda || c) + b.multiplyVectors(f, d);
    };
    var p = new d, t = new d, f = new d, n = new d;
    e.prototype.computeGiMf = function() {
      var b = this.jacobianElementA, c = this.jacobianElementB, e = this.bi, d = this.bj, m = e.force, k = e.torque, h = d.force, g = d.torque, A = e.invMassSolve, D = d.invMassSolve;
      e.invInertiaWorldSolve ? e.invInertiaWorldSolve.vmult(k, f) : f.set(0, 0, 0);
      d.invInertiaWorldSolve ? d.invInertiaWorldSolve.vmult(g, n) : n.set(0, 0, 0);
      m.mult(A, p);
      h.mult(D, t);
      return b.multiplyVectors(p, f) + c.multiplyVectors(t, n);
    };
    var b = new d;
    e.prototype.computeGiMGt = function() {
      var c = this.jacobianElementA, e = this.jacobianElementB, d = this.bi, f = this.bj, m = d.invInertiaWorldSolve, k = f.invInertiaWorldSolve;
      d = d.invMassSolve + f.invMassSolve;
      m && (m.vmult(c.rotational, b), d += b.dot(c.rotational));
      k && (k.vmult(e.rotational, b), d += b.dot(e.rotational));
      return d;
    };
    var m = new d;
    new d;
    new d;
    new d;
    new d;
    new d;
    e.prototype.addToWlambda = function(b) {
      var c = this.jacobianElementA, e = this.jacobianElementB, d = this.bi, f = this.bj;
      c.spatial.mult(d.invMassSolve * b, m);
      d.vlambda.vadd(m, d.vlambda);
      e.spatial.mult(f.invMassSolve * b, m);
      f.vlambda.vadd(m, f.vlambda);
      d.invInertiaWorldSolve && (d.invInertiaWorldSolve.vmult(c.rotational, m), m.mult(b, m), d.wlambda.vadd(m, d.wlambda));
      f.invInertiaWorldSolve && (f.invInertiaWorldSolve.vmult(e.rotational, m), m.mult(b, m), f.wlambda.vadd(m, f.wlambda));
    };
    e.prototype.computeC = function() {
      return this.computeGiMGt() + this.eps;
    };
  }, {"../math/JacobianElement":26, "../math/Vec3":30}], 21:[function(d, g, h) {
    function e(e, d, b) {
      k.call(this, e, d, -b, b);
      this.ri = new c;
      this.rj = new c;
      this.t = new c;
    }
    g.exports = e;
    var k = d("./Equation"), c = d("../math/Vec3");
    d("../math/Mat3");
    e.prototype = new k;
    e.prototype.constructor = e;
    var p = new c, t = new c;
    e.prototype.computeB = function(c) {
      var e = this.b, b = this.rj, d = this.t;
      this.ri.cross(d, p);
      b.cross(d, t);
      b = this.jacobianElementA;
      var f = this.jacobianElementB;
      d.negate(b.spatial);
      p.negate(b.rotational);
      f.spatial.copy(d);
      f.rotational.copy(t);
      d = this.computeGW();
      b = this.computeGiMf();
      return -d * e - c * b;
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 22:[function(d, g, h) {
    function e(e, d, b) {
      b = b || {};
      var f = "undefined" !== typeof b.maxForce ? b.maxForce : 1E6;
      c.call(this, e, d, -f, f);
      this.axisA = b.axisA ? b.axisA.clone() : new k(1, 0, 0);
      this.axisB = b.axisB ? b.axisB.clone() : new k(0, 1, 0);
      this.maxAngle = Math.PI / 2;
    }
    g.exports = e;
    var k = d("../math/Vec3");
    d("../math/Mat3");
    var c = d("./Equation");
    e.prototype = new c;
    e.prototype.constructor = e;
    var p = new k, t = new k;
    e.prototype.computeB = function(c) {
      var e = this.a, b = this.b, d = this.axisA, f = this.axisB, k = this.jacobianElementA, h = this.jacobianElementB;
      d.cross(f, p);
      f.cross(d, t);
      k.rotational.copy(t);
      h.rotational.copy(p);
      d = Math.cos(this.maxAngle) - d.dot(f);
      f = this.computeGW();
      k = this.computeGiMf();
      return -d * e - f * b - c * k;
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 23:[function(d, g, h) {
    function e(e, d, f) {
      f = "undefined" !== typeof f ? f : 1E6;
      c.call(this, e, d, -f, f);
      this.axisA = new k;
      this.axisB = new k;
      this.targetVelocity = 0;
    }
    g.exports = e;
    var k = d("../math/Vec3");
    d("../math/Mat3");
    var c = d("./Equation");
    e.prototype = new c;
    e.prototype.constructor = e;
    e.prototype.computeB = function(c) {
      var e = this.b, d = this.axisB, k = this.jacobianElementB;
      this.jacobianElementA.rotational.copy(this.axisA);
      d.negate(k.rotational);
      d = this.computeGW() - this.targetVelocity;
      k = this.computeGiMf();
      return -d * e - c * k;
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 24:[function(d, g, h) {
    function e(c, d, h) {
      h = k.defaults(h, {friction:.3, restitution:.3, contactEquationStiffness:1E7, contactEquationRelaxation:3, frictionEquationStiffness:1E7, frictionEquationRelaxation:3});
      this.id = e.idCounter++;
      this.materials = [c, d];
      this.friction = h.friction;
      this.restitution = h.restitution;
      this.contactEquationStiffness = h.contactEquationStiffness;
      this.contactEquationRelaxation = h.contactEquationRelaxation;
      this.frictionEquationStiffness = h.frictionEquationStiffness;
      this.frictionEquationRelaxation = h.frictionEquationRelaxation;
    }
    var k = d("../utils/Utils");
    g.exports = e;
    e.idCounter = 0;
  }, {"../utils/Utils":53}], 25:[function(d, g, h) {
    function e(d) {
      var c = "";
      d = d || {};
      "string" === typeof d ? (c = d, d = {}) : "object" === typeof d && (c = "");
      this.name = c;
      this.id = e.idCounter++;
      this.friction = "undefined" !== typeof d.friction ? d.friction : -1;
      this.restitution = "undefined" !== typeof d.restitution ? d.restitution : -1;
    }
    g.exports = e;
    e.idCounter = 0;
  }, {}], 26:[function(d, g, h) {
    function e() {
      this.spatial = new k;
      this.rotational = new k;
    }
    g.exports = e;
    var k = d("./Vec3");
    e.prototype.multiplyElement = function(c) {
      return c.spatial.dot(this.spatial) + c.rotational.dot(this.rotational);
    };
    e.prototype.multiplyVectors = function(c, e) {
      return c.dot(this.spatial) + e.dot(this.rotational);
    };
  }, {"./Vec3":30}], 27:[function(d, g, h) {
    function e(c) {
      this.elements = c ? c : [0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    g.exports = e;
    var k = d("./Vec3");
    e.prototype.identity = function() {
      var c = this.elements;
      c[0] = 1;
      c[1] = 0;
      c[2] = 0;
      c[3] = 0;
      c[4] = 1;
      c[5] = 0;
      c[6] = 0;
      c[7] = 0;
      c[8] = 1;
    };
    e.prototype.setZero = function() {
      var c = this.elements;
      c[0] = 0;
      c[1] = 0;
      c[2] = 0;
      c[3] = 0;
      c[4] = 0;
      c[5] = 0;
      c[6] = 0;
      c[7] = 0;
      c[8] = 0;
    };
    e.prototype.setTrace = function(c) {
      var e = this.elements;
      e[0] = c.x;
      e[4] = c.y;
      e[8] = c.z;
    };
    e.prototype.getTrace = function(c) {
      c = c || new k;
      var e = this.elements;
      c.x = e[0];
      c.y = e[4];
      c.z = e[8];
    };
    e.prototype.vmult = function(c, e) {
      e = e || new k;
      var d = this.elements, f = c.x, h = c.y;
      c = c.z;
      e.x = d[0] * f + d[1] * h + d[2] * c;
      e.y = d[3] * f + d[4] * h + d[5] * c;
      e.z = d[6] * f + d[7] * h + d[8] * c;
      return e;
    };
    e.prototype.smult = function(c) {
      for (var e = 0; e < this.elements.length; e++) {
        this.elements[e] *= c;
      }
    };
    e.prototype.mmult = function(c, d) {
      d = d || new e;
      for (var k = 0; 3 > k; k++) {
        for (var f = 0; 3 > f; f++) {
          for (var h = 0, b = 0; 3 > b; b++) {
            h += c.elements[k + 3 * b] * this.elements[b + 3 * f];
          }
          d.elements[k + 3 * f] = h;
        }
      }
      return d;
    };
    e.prototype.scale = function(c, d) {
      d = d || new e;
      for (var k = this.elements, f = d.elements, h = 0; 3 !== h; h++) {
        f[3 * h] = c.x * k[3 * h], f[3 * h + 1] = c.y * k[3 * h + 1], f[3 * h + 2] = c.z * k[3 * h + 2];
      }
      return d;
    };
    e.prototype.solve = function(c, e) {
      e = e || new k;
      for (var d = [], f = 0; 12 > f; f++) {
        d.push(0);
      }
      var h;
      for (f = 0; 3 > f; f++) {
        for (h = 0; 3 > h; h++) {
          d[f + 4 * h] = this.elements[f + 3 * h];
        }
      }
      d[3] = c.x;
      d[7] = c.y;
      d[11] = c.z;
      var b = 3, m = b;
      do {
        f = m - b;
        if (0 === d[f + 4 * f]) {
          for (h = f + 1; h < m; h++) {
            if (0 !== d[f + 4 * h]) {
              var g = 4;
              do {
                var p = 4 - g;
                d[p + 4 * f] += d[p + 4 * h];
              } while (--g);
              break;
            }
          }
        }
        if (0 !== d[f + 4 * f]) {
          for (h = f + 1; h < m; h++) {
            var x = d[f + 4 * h] / d[f + 4 * f];
            g = 4;
            do {
              p = 4 - g, d[p + 4 * h] = p <= f ? 0 : d[p + 4 * h] - d[p + 4 * f] * x;
            } while (--g);
          }
        }
      } while (--b);
      e.z = d[11] / d[10];
      e.y = (d[7] - d[6] * e.z) / d[5];
      e.x = (d[3] - d[2] * e.z - d[1] * e.y) / d[0];
      if (isNaN(e.x) || isNaN(e.y) || isNaN(e.z) || Infinity === e.x || Infinity === e.y || Infinity === e.z) {
        throw "Could not solve equation! Got x=[" + e.toString() + "], b=[" + c.toString() + "], A=[" + this.toString() + "]";
      }
      return e;
    };
    e.prototype.e = function(c, e, d) {
      if (void 0 === d) {
        return this.elements[e + 3 * c];
      }
      this.elements[e + 3 * c] = d;
    };
    e.prototype.copy = function(c) {
      for (var e = 0; e < c.elements.length; e++) {
        this.elements[e] = c.elements[e];
      }
      return this;
    };
    e.prototype.toString = function() {
      for (var c = "", e = 0; 9 > e; e++) {
        c += this.elements[e] + ",";
      }
      return c;
    };
    e.prototype.reverse = function(c) {
      c = c || new e;
      for (var d = [], k = 0; 18 > k; k++) {
        d.push(0);
      }
      var f;
      for (k = 0; 3 > k; k++) {
        for (f = 0; 3 > f; f++) {
          d[k + 6 * f] = this.elements[k + 3 * f];
        }
      }
      d[3] = 1;
      d[9] = 0;
      d[15] = 0;
      d[4] = 0;
      d[10] = 1;
      d[16] = 0;
      d[5] = 0;
      d[11] = 0;
      d[17] = 1;
      var h = 3, b = h;
      do {
        k = b - h;
        if (0 === d[k + 6 * k]) {
          for (f = k + 1; f < b; f++) {
            if (0 !== d[k + 6 * f]) {
              var m = 6;
              do {
                var g = 6 - m;
                d[g + 6 * k] += d[g + 6 * f];
              } while (--m);
              break;
            }
          }
        }
        if (0 !== d[k + 6 * k]) {
          for (f = k + 1; f < b; f++) {
            var y = d[k + 6 * f] / d[k + 6 * k];
            m = 6;
            do {
              g = 6 - m, d[g + 6 * f] = g <= k ? 0 : d[g + 6 * f] - d[g + 6 * k] * y;
            } while (--m);
          }
        }
      } while (--h);
      k = 2;
      do {
        f = k - 1;
        do {
          y = d[k + 6 * f] / d[k + 6 * k];
          m = 6;
          do {
            g = 6 - m, d[g + 6 * f] -= d[g + 6 * k] * y;
          } while (--m);
        } while (f--);
      } while (--k);
      k = 2;
      do {
        y = 1 / d[k + 6 * k];
        m = 6;
        do {
          g = 6 - m, d[g + 6 * k] *= y;
        } while (--m);
      } while (k--);
      k = 2;
      do {
        f = 2;
        do {
          g = d[3 + f + 6 * k];
          if (isNaN(g) || Infinity === g) {
            throw "Could not reverse! A=[" + this.toString() + "]";
          }
          c.e(k, f, g);
        } while (f--);
      } while (k--);
      return c;
    };
    e.prototype.setRotationFromQuaternion = function(c) {
      var e = c.x, d = c.y, f = c.z, k = c.w, b = e + e, m = d + d, h = f + f;
      c = e * b;
      var g = e * m;
      e *= h;
      var x = d * m;
      d *= h;
      f *= h;
      b *= k;
      m *= k;
      k *= h;
      h = this.elements;
      h[0] = 1 - (x + f);
      h[1] = g - k;
      h[2] = e + m;
      h[3] = g + k;
      h[4] = 1 - (c + f);
      h[5] = d - b;
      h[6] = e - m;
      h[7] = d + b;
      h[8] = 1 - (c + x);
      return this;
    };
    e.prototype.transpose = function(c) {
      c = c || new e;
      for (var d = c.elements, k = this.elements, f = 0; 3 !== f; f++) {
        for (var h = 0; 3 !== h; h++) {
          d[3 * f + h] = k[3 * h + f];
        }
      }
      return c;
    };
  }, {"./Vec3":30}], 28:[function(d, g, h) {
    function e(b, c, e, d) {
      this.x = void 0 !== b ? b : 0;
      this.y = void 0 !== c ? c : 0;
      this.z = void 0 !== e ? e : 0;
      this.w = void 0 !== d ? d : 1;
    }
    g.exports = e;
    var k = d("./Vec3");
    e.prototype.set = function(b, c, e, d) {
      this.x = b;
      this.y = c;
      this.z = e;
      this.w = d;
    };
    e.prototype.toString = function() {
      return this.x + "," + this.y + "," + this.z + "," + this.w;
    };
    e.prototype.toArray = function() {
      return [this.x, this.y, this.z, this.w];
    };
    e.prototype.setFromAxisAngle = function(b, c) {
      var e = Math.sin(.5 * c);
      this.x = b.x * e;
      this.y = b.y * e;
      this.z = b.z * e;
      this.w = Math.cos(.5 * c);
    };
    e.prototype.toAxisAngle = function(b) {
      b = b || new k;
      this.normalize();
      var c = 2 * Math.acos(this.w), e = Math.sqrt(1 - this.w * this.w);
      .001 > e ? (b.x = this.x, b.y = this.y, b.z = this.z) : (b.x = this.x / e, b.y = this.y / e, b.z = this.z / e);
      return [b, c];
    };
    var c = new k, p = new k;
    e.prototype.setFromVectors = function(b, e) {
      if (b.isAntiparallelTo(e)) {
        b.tangents(c, p), this.setFromAxisAngle(c, Math.PI);
      } else {
        var d = b.cross(e);
        this.x = d.x;
        this.y = d.y;
        this.z = d.z;
        this.w = Math.sqrt(Math.pow(b.norm(), 2) * Math.pow(e.norm(), 2)) + b.dot(e);
        this.normalize();
      }
    };
    var t = new k, f = new k, n = new k;
    e.prototype.mult = function(b, c) {
      c = c || new e;
      var d = this.w;
      t.set(this.x, this.y, this.z);
      f.set(b.x, b.y, b.z);
      c.w = d * b.w - t.dot(f);
      t.cross(f, n);
      c.x = d * f.x + b.w * t.x + n.x;
      c.y = d * f.y + b.w * t.y + n.y;
      c.z = d * f.z + b.w * t.z + n.z;
      return c;
    };
    e.prototype.inverse = function(b) {
      var c = this.x, d = this.y, f = this.z, k = this.w;
      b = b || new e;
      this.conjugate(b);
      c = 1 / (c * c + d * d + f * f + k * k);
      b.x *= c;
      b.y *= c;
      b.z *= c;
      b.w *= c;
      return b;
    };
    e.prototype.conjugate = function(b) {
      b = b || new e;
      b.x = -this.x;
      b.y = -this.y;
      b.z = -this.z;
      b.w = this.w;
      return b;
    };
    e.prototype.normalize = function() {
      var b = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      0 === b ? this.w = this.z = this.y = this.x = 0 : (b = 1 / b, this.x *= b, this.y *= b, this.z *= b, this.w *= b);
    };
    e.prototype.normalizeFast = function() {
      var b = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
      0 === b ? this.w = this.z = this.y = this.x = 0 : (this.x *= b, this.y *= b, this.z *= b, this.w *= b);
    };
    e.prototype.vmult = function(b, c) {
      c = c || new k;
      var e = b.x, d = b.y, f = b.z;
      b = this.x;
      var m = this.y, h = this.z, g = this.w, n = g * e + m * f - h * d, p = g * d + h * e - b * f, t = g * f + b * d - m * e;
      e = -b * e - m * d - h * f;
      c.x = n * g + e * -b + p * -h - t * -m;
      c.y = p * g + e * -m + t * -b - n * -h;
      c.z = t * g + e * -h + n * -m - p * -b;
      return c;
    };
    e.prototype.copy = function(b) {
      this.x = b.x;
      this.y = b.y;
      this.z = b.z;
      this.w = b.w;
      return this;
    };
    e.prototype.toEuler = function(b, c) {
      c = c || "YZX";
      var e = this.x, d = this.y, f = this.z, m = this.w;
      switch(c) {
        case "YZX":
          c = e * d + f * m;
          if (.499 < c) {
            var k = 2 * Math.atan2(e, m);
            var h = Math.PI / 2;
            var g = 0;
          }
          -.499 > c && (k = -2 * Math.atan2(e, m), h = -Math.PI / 2, g = 0);
          isNaN(k) && (g = f * f, k = Math.atan2(2 * d * m - 2 * e * f, 1 - 2 * d * d - 2 * g), h = Math.asin(2 * c), g = Math.atan2(2 * e * m - 2 * d * f, 1 - 2 * e * e - 2 * g));
          break;
        default:
          throw Error("Euler order " + c + " not supported yet.");
      }
      b.y = k;
      b.z = h;
      b.x = g;
    };
    e.prototype.setFromEuler = function(b, c, e, d) {
      d = d || "XYZ";
      var f = Math.cos(b / 2), m = Math.cos(c / 2), k = Math.cos(e / 2);
      b = Math.sin(b / 2);
      c = Math.sin(c / 2);
      e = Math.sin(e / 2);
      "XYZ" === d ? (this.x = b * m * k + f * c * e, this.y = f * c * k - b * m * e, this.z = f * m * e + b * c * k, this.w = f * m * k - b * c * e) : "YXZ" === d ? (this.x = b * m * k + f * c * e, this.y = f * c * k - b * m * e, this.z = f * m * e - b * c * k, this.w = f * m * k + b * c * e) : "ZXY" === d ? (this.x = b * m * k - f * c * e, this.y = f * c * k + b * m * e, this.z = f * m * e + b * c * k, this.w = f * m * k - b * c * e) : "ZYX" === d ? (this.x = b * m * k - f * c * e, this.y = f * 
      c * k + b * m * e, this.z = f * m * e - b * c * k, this.w = f * m * k + b * c * e) : "YZX" === d ? (this.x = b * m * k + f * c * e, this.y = f * c * k + b * m * e, this.z = f * m * e - b * c * k, this.w = f * m * k - b * c * e) : "XZY" === d && (this.x = b * m * k - f * c * e, this.y = f * c * k - b * m * e, this.z = f * m * e + b * c * k, this.w = f * m * k + b * c * e);
      return this;
    };
    e.prototype.clone = function() {
      return new e(this.x, this.y, this.z, this.w);
    };
  }, {"./Vec3":30}], 29:[function(d, g, h) {
    function e(e) {
      e = e || {};
      this.position = new k;
      e.position && this.position.copy(e.position);
      this.quaternion = new c;
      e.quaternion && this.quaternion.copy(e.quaternion);
    }
    var k = d("./Vec3"), c = d("./Quaternion");
    g.exports = e;
    var p = new c;
    e.pointToLocalFrame = function(c, e, d, b) {
      b = b || new k;
      d.vsub(c, b);
      e.conjugate(p);
      p.vmult(b, b);
      return b;
    };
    e.prototype.pointToLocal = function(c, d) {
      return e.pointToLocalFrame(this.position, this.quaternion, c, d);
    };
    e.pointToWorldFrame = function(c, e, d, b) {
      b = b || new k;
      e.vmult(d, b);
      b.vadd(c, b);
      return b;
    };
    e.prototype.pointToWorld = function(c, d) {
      return e.pointToWorldFrame(this.position, this.quaternion, c, d);
    };
    e.prototype.vectorToWorldFrame = function(c, e) {
      e = e || new k;
      this.quaternion.vmult(c, e);
      return e;
    };
    e.vectorToWorldFrame = function(c, e, d) {
      c.vmult(e, d);
      return d;
    };
    e.vectorToLocalFrame = function(c, e, d, b) {
      b = b || new k;
      e.w *= -1;
      e.vmult(d, b);
      e.w *= -1;
      return b;
    };
  }, {"./Quaternion":28, "./Vec3":30}], 30:[function(d, g, h) {
    function e(c, e, b) {
      this.x = c || 0;
      this.y = e || 0;
      this.z = b || 0;
    }
    g.exports = e;
    var k = d("./Mat3");
    e.ZERO = new e(0, 0, 0);
    e.UNIT_X = new e(1, 0, 0);
    e.UNIT_Y = new e(0, 1, 0);
    e.UNIT_Z = new e(0, 0, 1);
    e.prototype.cross = function(c, d) {
      var b = c.x, f = c.y;
      c = c.z;
      var k = this.x, h = this.y, g = this.z;
      d = d || new e;
      d.x = h * c - g * f;
      d.y = g * b - k * c;
      d.z = k * f - h * b;
      return d;
    };
    e.prototype.set = function(c, e, b) {
      this.x = c;
      this.y = e;
      this.z = b;
      return this;
    };
    e.prototype.setZero = function() {
      this.x = this.y = this.z = 0;
    };
    e.prototype.vadd = function(c, d) {
      if (d) {
        d.x = c.x + this.x, d.y = c.y + this.y, d.z = c.z + this.z;
      } else {
        return new e(this.x + c.x, this.y + c.y, this.z + c.z);
      }
    };
    e.prototype.vsub = function(c, d) {
      if (d) {
        d.x = this.x - c.x, d.y = this.y - c.y, d.z = this.z - c.z;
      } else {
        return new e(this.x - c.x, this.y - c.y, this.z - c.z);
      }
    };
    e.prototype.crossmat = function() {
      return new k([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
    };
    e.prototype.normalize = function() {
      var c = this.x, e = this.y, b = this.z;
      c = Math.sqrt(c * c + e * e + b * b);
      0 < c ? (e = 1 / c, this.x *= e, this.y *= e, this.z *= e) : this.z = this.y = this.x = 0;
      return c;
    };
    e.prototype.unit = function(c) {
      c = c || new e;
      var d = this.x, b = this.y, f = this.z, k = Math.sqrt(d * d + b * b + f * f);
      0 < k ? (k = 1 / k, c.x = d * k, c.y = b * k, c.z = f * k) : (c.x = 1, c.y = 0, c.z = 0);
      return c;
    };
    e.prototype.norm = function() {
      var c = this.x, e = this.y, b = this.z;
      return Math.sqrt(c * c + e * e + b * b);
    };
    e.prototype.length = e.prototype.norm;
    e.prototype.norm2 = function() {
      return this.dot(this);
    };
    e.prototype.lengthSquared = e.prototype.norm2;
    e.prototype.distanceTo = function(c) {
      var e = this.x, b = this.y, d = this.z, f = c.x, k = c.y;
      c = c.z;
      return Math.sqrt((f - e) * (f - e) + (k - b) * (k - b) + (c - d) * (c - d));
    };
    e.prototype.distanceSquared = function(c) {
      var e = this.x, b = this.y, d = this.z, f = c.x, k = c.y;
      c = c.z;
      return (f - e) * (f - e) + (k - b) * (k - b) + (c - d) * (c - d);
    };
    e.prototype.mult = function(c, d) {
      d = d || new e;
      var b = this.y, f = this.z;
      d.x = c * this.x;
      d.y = c * b;
      d.z = c * f;
      return d;
    };
    e.prototype.scale = e.prototype.mult;
    e.prototype.dot = function(c) {
      return this.x * c.x + this.y * c.y + this.z * c.z;
    };
    e.prototype.isZero = function() {
      return 0 === this.x && 0 === this.y && 0 === this.z;
    };
    e.prototype.negate = function(c) {
      c = c || new e;
      c.x = -this.x;
      c.y = -this.y;
      c.z = -this.z;
      return c;
    };
    var c = new e, p = new e;
    e.prototype.tangents = function(e, d) {
      var b = this.norm();
      0 < b ? (b = 1 / b, c.set(this.x * b, this.y * b, this.z * b), .9 > Math.abs(c.x) ? p.set(1, 0, 0) : p.set(0, 1, 0), c.cross(p, e), c.cross(e, d)) : (e.set(1, 0, 0), d.set(0, 1, 0));
    };
    e.prototype.toString = function() {
      return this.x + "," + this.y + "," + this.z;
    };
    e.prototype.toArray = function() {
      return [this.x, this.y, this.z];
    };
    e.prototype.copy = function(c) {
      this.x = c.x;
      this.y = c.y;
      this.z = c.z;
      return this;
    };
    e.prototype.lerp = function(c, e, b) {
      var d = this.x, f = this.y, k = this.z;
      b.x = d + (c.x - d) * e;
      b.y = f + (c.y - f) * e;
      b.z = k + (c.z - k) * e;
    };
    e.prototype.almostEquals = function(c, e) {
      void 0 === e && (e = 1E-6);
      return Math.abs(this.x - c.x) > e || Math.abs(this.y - c.y) > e || Math.abs(this.z - c.z) > e ? !1 : !0;
    };
    e.prototype.almostZero = function(c) {
      void 0 === c && (c = 1E-6);
      return Math.abs(this.x) > c || Math.abs(this.y) > c || Math.abs(this.z) > c ? !1 : !0;
    };
    var t = new e;
    e.prototype.isAntiparallelTo = function(c, e) {
      this.negate(t);
      return t.almostEquals(c, e);
    };
    e.prototype.clone = function() {
      return new e(this.x, this.y, this.z);
    };
  }, {"./Mat3":27}], 31:[function(d, g, h) {
    function e(b) {
      b = b || {};
      k.apply(this);
      this.id = e.idCounter++;
      this.postStep = this.preStep = this.world = null;
      this.vlambda = new c;
      this.collisionFilterGroup = "number" === typeof b.collisionFilterGroup ? b.collisionFilterGroup : 1;
      this.collisionFilterMask = "number" === typeof b.collisionFilterMask ? b.collisionFilterMask : 1;
      this.collisionResponse = !0;
      this.position = new c;
      b.position && this.position.copy(b.position);
      this.previousPosition = new c;
      this.initPosition = new c;
      this.velocity = new c;
      b.velocity && this.velocity.copy(b.velocity);
      this.initVelocity = new c;
      this.force = new c;
      var d = "number" === typeof b.mass ? b.mass : 0;
      this.mass = d;
      this.invMass = 0 < d ? 1 / d : 0;
      this.material = b.material || null;
      this.linearDamping = "number" === typeof b.linearDamping ? b.linearDamping : .01;
      this.type = 0 >= d ? e.STATIC : e.DYNAMIC;
      typeof b.type === typeof e.STATIC && (this.type = b.type);
      this.allowSleep = "undefined" !== typeof b.allowSleep ? b.allowSleep : !0;
      this.sleepState = 0;
      this.sleepSpeedLimit = "undefined" !== typeof b.sleepSpeedLimit ? b.sleepSpeedLimit : .1;
      this.sleepTimeLimit = "undefined" !== typeof b.sleepTimeLimit ? b.sleepTimeLimit : 1;
      this.timeLastSleepy = 0;
      this._wakeUpAfterNarrowphase = !1;
      this.torque = new c;
      this.quaternion = new t;
      b.quaternion && this.quaternion.copy(b.quaternion);
      this.initQuaternion = new t;
      this.angularVelocity = new c;
      b.angularVelocity && this.angularVelocity.copy(b.angularVelocity);
      this.initAngularVelocity = new c;
      this.interpolatedPosition = new c;
      this.interpolatedQuaternion = new t;
      this.shapes = [];
      this.shapeOffsets = [];
      this.shapeOrientations = [];
      this.inertia = new c;
      this.invInertia = new c;
      this.invInertiaWorld = new p;
      this.invMassSolve = 0;
      this.invInertiaSolve = new c;
      this.invInertiaWorldSolve = new p;
      this.fixedRotation = "undefined" !== typeof b.fixedRotation ? b.fixedRotation : !1;
      this.angularDamping = "undefined" !== typeof b.angularDamping ? b.angularDamping : .01;
      this.aabb = new f;
      this.aabbNeedsUpdate = !0;
      this.wlambda = new c;
      b.shape && this.addShape(b.shape);
      this.updateMassProperties();
    }
    g.exports = e;
    var k = d("../utils/EventTarget");
    d("../shapes/Shape");
    var c = d("../math/Vec3"), p = d("../math/Mat3"), t = d("../math/Quaternion");
    d("../material/Material");
    var f = d("../collision/AABB"), n = d("../shapes/Box");
    e.prototype = new k;
    e.prototype.constructor = e;
    e.DYNAMIC = 1;
    e.STATIC = 2;
    e.KINEMATIC = 4;
    e.AWAKE = 0;
    e.SLEEPY = 1;
    e.SLEEPING = 2;
    e.idCounter = 0;
    e.prototype.wakeUp = function() {
      var b = this.sleepState;
      this.sleepState = 0;
      b === e.SLEEPING && this.dispatchEvent({type:"wakeup"});
    };
    e.prototype.sleep = function() {
      this.sleepState = e.SLEEPING;
      this.velocity.set(0, 0, 0);
      this.angularVelocity.set(0, 0, 0);
    };
    e.sleepyEvent = {type:"sleepy"};
    e.sleepEvent = {type:"sleep"};
    e.prototype.sleepTick = function(b) {
      if (this.allowSleep) {
        var c = this.sleepState, d = this.velocity.norm2() + this.angularVelocity.norm2(), f = Math.pow(this.sleepSpeedLimit, 2);
        c === e.AWAKE && d < f ? (this.sleepState = e.SLEEPY, this.timeLastSleepy = b, this.dispatchEvent(e.sleepyEvent)) : c === e.SLEEPY && d > f ? this.wakeUp() : c === e.SLEEPY && b - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), this.dispatchEvent(e.sleepEvent));
      }
    };
    e.prototype.updateSolveMassProperties = function() {
      this.sleepState === e.SLEEPING || this.type === e.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld));
    };
    e.prototype.pointToLocalFrame = function(b, e) {
      e = e || new c;
      b.vsub(this.position, e);
      this.quaternion.conjugate().vmult(e, e);
      return e;
    };
    e.prototype.vectorToLocalFrame = function(b, e) {
      e = e || new c;
      this.quaternion.conjugate().vmult(b, e);
      return e;
    };
    e.prototype.pointToWorldFrame = function(b, e) {
      e = e || new c;
      this.quaternion.vmult(b, e);
      e.vadd(this.position, e);
      return e;
    };
    e.prototype.vectorToWorldFrame = function(b, e) {
      e = e || new c;
      this.quaternion.vmult(b, e);
      return e;
    };
    var b = new c, m = new t;
    e.prototype.addShape = function(b, e, d) {
      var f = new c, m = new t;
      e && f.copy(e);
      d && m.copy(d);
      this.shapes.push(b);
      this.shapeOffsets.push(f);
      this.shapeOrientations.push(m);
      this.updateMassProperties();
      this.updateBoundingRadius();
      this.aabbNeedsUpdate = !0;
      return this;
    };
    e.prototype.updateBoundingRadius = function() {
      for (var b = this.shapes, c = this.shapeOffsets, e = b.length, d = 0, f = 0; f !== e; f++) {
        var m = b[f];
        m.updateBoundingSphereRadius();
        var k = c[f].norm();
        m = m.boundingSphereRadius;
        k + m > d && (d = k + m);
      }
      this.boundingRadius = d;
    };
    var q = new f;
    e.prototype.computeAABB = function() {
      for (var c = this.shapes, e = this.shapeOffsets, d = this.shapeOrientations, f = c.length, k = this.quaternion, h = this.aabb, g = 0; g !== f; g++) {
        var r = c[g];
        d[g].mult(k, m);
        m.vmult(e[g], b);
        b.vadd(this.position, b);
        r.calculateWorldAABB(b, m, q.lowerBound, q.upperBound);
        0 === g ? h.copy(q) : h.extend(q);
      }
      this.aabbNeedsUpdate = !1;
    };
    var y = new p, x = new p;
    new p;
    e.prototype.updateInertiaWorld = function(b) {
      var c = this.invInertia;
      if (c.x !== c.y || c.y !== c.z || b) {
        y.setRotationFromQuaternion(this.quaternion), y.transpose(x), y.scale(c, y), y.mmult(x, this.invInertiaWorld);
      }
    };
    var z = new c, r = new c;
    e.prototype.applyForce = function(b, c) {
      this.type === e.DYNAMIC && (c.vsub(this.position, z), z.cross(b, r), this.force.vadd(b, this.force), this.torque.vadd(r, this.torque));
    };
    var u = new c, v = new c;
    e.prototype.applyLocalForce = function(b, c) {
      this.type === e.DYNAMIC && (this.vectorToWorldFrame(b, u), this.pointToWorldFrame(c, v), this.applyForce(u, v));
    };
    var C = new c, A = new c, D = new c;
    e.prototype.applyImpulse = function(b, c) {
      this.type === e.DYNAMIC && (c.vsub(this.position, C), A.copy(b), A.mult(this.invMass, A), this.velocity.vadd(A, this.velocity), C.cross(b, D), this.invInertiaWorld.vmult(D, D), this.angularVelocity.vadd(D, this.angularVelocity));
    };
    var F = new c, B = new c;
    e.prototype.applyLocalImpulse = function(b, c) {
      this.type === e.DYNAMIC && (this.vectorToWorldFrame(b, F), this.pointToWorldFrame(c, B), this.applyImpulse(F, B));
    };
    var E = new c;
    e.prototype.updateMassProperties = function() {
      this.invMass = 0 < this.mass ? 1 / this.mass : 0;
      var b = this.inertia, c = this.fixedRotation;
      this.computeAABB();
      E.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);
      n.calculateInertia(E, this.mass, b);
      this.invInertia.set(0 < b.x && !c ? 1 / b.x : 0, 0 < b.y && !c ? 1 / b.y : 0, 0 < b.z && !c ? 1 / b.z : 0);
      this.updateInertiaWorld(!0);
    };
    e.prototype.getVelocityAtWorldPoint = function(b, e) {
      var d = new c;
      b.vsub(this.position, d);
      this.angularVelocity.cross(d, e);
      this.velocity.vadd(e, e);
      return e;
    };
  }, {"../collision/AABB":3, "../material/Material":25, "../math/Mat3":27, "../math/Quaternion":28, "../math/Vec3":30, "../shapes/Box":37, "../shapes/Shape":43, "../utils/EventTarget":49}], 32:[function(d, g, h) {
    function e(b) {
      this.chassisBody = b.chassisBody;
      this.wheelInfos = [];
      this.sliding = !1;
      this.world = null;
      this.indexRightAxis = "undefined" !== typeof b.indexRightAxis ? b.indexRightAxis : 1;
      this.indexForwardAxis = "undefined" !== typeof b.indexForwardAxis ? b.indexForwardAxis : 0;
      this.indexUpAxis = "undefined" !== typeof b.indexUpAxis ? b.indexUpAxis : 2;
    }
    function k(b, c, e) {
      var d = A, f = D, m = F, k = B;
      c.vsub(b.position, d);
      d.cross(e, f);
      b.invInertiaWorld.vmult(f, k);
      k.cross(d, m);
      return b.invMass + e.dot(m);
    }
    d("./Body");
    var c = d("../math/Vec3"), p = d("../math/Quaternion");
    d("../collision/RaycastResult");
    h = d("../collision/Ray");
    var t = d("../objects/WheelInfo");
    g.exports = e;
    new c;
    new c;
    new c;
    var f = new c, n = new c, b = new c;
    new h;
    e.prototype.addWheel = function(b) {
      b = b || {};
      b = new t(b);
      var c = this.wheelInfos.length;
      this.wheelInfos.push(b);
      return c;
    };
    e.prototype.setSteeringValue = function(b, c) {
      this.wheelInfos[c].steering = b;
    };
    new c;
    e.prototype.applyEngineForce = function(b, c) {
      this.wheelInfos[c].engineForce = b;
    };
    e.prototype.setBrake = function(b, c) {
      this.wheelInfos[c].brake = b;
    };
    e.prototype.addToWorld = function(b) {
      b.add(this.chassisBody);
      var c = this;
      this.preStepCallback = function() {
        c.updateVehicle(b.dt);
      };
      b.addEventListener("preStep", this.preStepCallback);
      this.world = b;
    };
    e.prototype.getVehicleAxisWorld = function(b, c) {
      c.set(0 === b ? 1 : 0, 1 === b ? 1 : 0, 2 === b ? 1 : 0);
      this.chassisBody.vectorToWorldFrame(c, c);
    };
    e.prototype.updateVehicle = function(b) {
      for (var e = this.wheelInfos, d = e.length, f = this.chassisBody, m = 0; m < d; m++) {
        this.updateWheelTransform(m);
      }
      this.currentVehicleSpeedKmHour = 3.6 * f.velocity.norm();
      m = new c;
      this.getVehicleAxisWorld(this.indexForwardAxis, m);
      0 > m.dot(f.velocity) && (this.currentVehicleSpeedKmHour *= -1);
      for (m = 0; m < d; m++) {
        this.castRay(e[m]);
      }
      this.updateSuspension(b);
      var k = new c, h = new c;
      for (m = 0; m < d; m++) {
        var g = e[m], r = g.suspensionForce;
        r > g.maxSuspensionForce && (r = g.maxSuspensionForce);
        g.raycastResult.hitNormalWorld.scale(r * b, k);
        g.raycastResult.hitPointWorld.vsub(f.position, h);
        f.applyImpulse(k, g.raycastResult.hitPointWorld);
      }
      this.updateFriction(b);
      k = new c;
      h = new c;
      r = new c;
      for (m = 0; m < d; m++) {
        g = e[m];
        f.getVelocityAtWorldPoint(g.chassisConnectionPointWorld, r);
        var n = 1;
        switch(this.indexUpAxis) {
          case 1:
            n = -1;
        }
        if (g.isInContact) {
          this.getVehicleAxisWorld(this.indexForwardAxis, h);
          var u = h.dot(g.raycastResult.hitNormalWorld);
          g.raycastResult.hitNormalWorld.scale(u, k);
          h.vsub(k, h);
          u = h.dot(r);
          g.deltaRotation = n * u * b / g.radius;
        }
        !g.sliding && g.isInContact || 0 === g.engineForce || !g.useCustomSlidingRotationalSpeed || (g.deltaRotation = (0 < g.engineForce ? 1 : -1) * g.customSlidingRotationalSpeed * b);
        Math.abs(g.brake) > Math.abs(g.engineForce) && (g.deltaRotation = 0);
        g.rotation += g.deltaRotation;
        g.deltaRotation *= .99;
      }
    };
    e.prototype.updateSuspension = function(b) {
      b = this.chassisBody.mass;
      for (var c = this.wheelInfos, e = c.length, d = 0; d < e; d++) {
        var f = c[d];
        if (f.isInContact) {
          var m = f.suspensionStiffness * (f.suspensionRestLength - f.suspensionLength) * f.clippedInvContactDotSuspension;
          var k = f.suspensionRelativeVelocity;
          m -= (0 > k ? f.dampingCompression : f.dampingRelaxation) * k;
          f.suspensionForce = m * b;
          0 > f.suspensionForce && (f.suspensionForce = 0);
        } else {
          f.suspensionForce = 0;
        }
      }
    };
    e.prototype.removeFromWorld = function(b) {
      b.remove(this.chassisBody);
      b.removeEventListener("preStep", this.preStepCallback);
      this.world = null;
    };
    var m = new c, q = new c;
    e.prototype.castRay = function(b) {
      this.updateWheelTransformWorld(b);
      var e = this.chassisBody, d = -1;
      b.directionWorld.scale(b.suspensionRestLength + b.radius, m);
      var f = b.chassisConnectionPointWorld;
      f.vadd(m, q);
      var k = b.raycastResult;
      k.reset();
      var h = e.collisionResponse;
      e.collisionResponse = !1;
      this.world.rayTest(f, q, k);
      e.collisionResponse = h;
      f = k.body;
      b.raycastResult.groundObject = 0;
      f ? (d = k.distance, b.raycastResult.hitNormalWorld = k.hitNormalWorld, b.isInContact = !0, b.suspensionLength = k.distance - b.radius, k = b.suspensionRestLength - b.maxSuspensionTravel, f = b.suspensionRestLength + b.maxSuspensionTravel, b.suspensionLength < k && (b.suspensionLength = k), b.suspensionLength > f && (b.suspensionLength = f, b.raycastResult.reset()), k = b.raycastResult.hitNormalWorld.dot(b.directionWorld), f = new c, e.getVelocityAtWorldPoint(b.raycastResult.hitPointWorld, 
      f), e = b.raycastResult.hitNormalWorld.dot(f), -.1 <= k ? (b.suspensionRelativeVelocity = 0, b.clippedInvContactDotSuspension = 10) : (k = -1 / k, b.suspensionRelativeVelocity = e * k, b.clippedInvContactDotSuspension = k)) : (b.suspensionLength = b.suspensionRestLength + 0 * b.maxSuspensionTravel, b.suspensionRelativeVelocity = 0, b.directionWorld.scale(-1, b.raycastResult.hitNormalWorld), b.clippedInvContactDotSuspension = 1);
      return d;
    };
    e.prototype.updateWheelTransformWorld = function(b) {
      b.isInContact = !1;
      var c = this.chassisBody;
      c.pointToWorldFrame(b.chassisConnectionPointLocal, b.chassisConnectionPointWorld);
      c.vectorToWorldFrame(b.directionLocal, b.directionWorld);
      c.vectorToWorldFrame(b.axleLocal, b.axleWorld);
    };
    e.prototype.updateWheelTransform = function(c) {
      c = this.wheelInfos[c];
      this.updateWheelTransformWorld(c);
      c.directionLocal.scale(-1, f);
      n.copy(c.axleLocal);
      f.cross(n, b);
      b.normalize();
      n.normalize();
      var e = c.steering, d = new p;
      d.setFromAxisAngle(f, e);
      e = new p;
      e.setFromAxisAngle(n, c.rotation);
      var m = c.worldTransform.quaternion;
      this.chassisBody.quaternion.mult(d, m);
      m.mult(e, m);
      m.normalize();
      d = c.worldTransform.position;
      d.copy(c.directionWorld);
      d.scale(c.suspensionLength, d);
      d.vadd(c.chassisConnectionPointWorld, d);
    };
    var y = [new c(1, 0, 0), new c(0, 1, 0), new c(0, 0, 1)];
    e.prototype.getWheelTransformWorld = function(b) {
      return this.wheelInfos[b].worldTransform;
    };
    var x = new c, z = [], r = [];
    e.prototype.updateFriction = function(b) {
      for (var e = this.wheelInfos, d = e.length, f = this.chassisBody, m = 0, h = 0; h < d; h++) {
        var g = e[h], n = g.raycastResult.body;
        n && m++;
        g.sideImpulse = 0;
        g.forwardImpulse = 0;
        r[h] || (r[h] = new c);
        z[h] || (z[h] = new c);
      }
      for (h = 0; h < d; h++) {
        if (g = e[h], n = g.raycastResult.body) {
          var p = z[h];
          this.getWheelTransformWorld(h).vectorToWorldFrame(y[this.indexRightAxis], p);
          m = g.raycastResult.hitNormalWorld;
          var q = p.dot(m);
          m.scale(q, x);
          p.vsub(x, p);
          p.normalize();
          m.cross(p, r[h]);
          r[h].normalize();
          m = g;
          q = f;
          var t = g.raycastResult.hitPointWorld, A = g.raycastResult.hitPointWorld;
          if (1.1 < p.norm2()) {
            n = 0;
          } else {
            var B = E, D = H, F = L;
            q.getVelocityAtWorldPoint(t, B);
            n.getVelocityAtWorldPoint(A, D);
            B.vsub(D, F);
            n = -.2 * p.dot(F) * (1 / (q.invMass + n.invMass));
          }
          m.sideImpulse = n;
          g.sideImpulse *= 1;
        }
      }
      this.sliding = !1;
      for (h = 0; h < d; h++) {
        g = e[h];
        n = g.raycastResult.body;
        q = 0;
        g.slipInfo = 1;
        if (n) {
          m = g.brake ? g.brake : 0;
          B = f;
          t = n;
          A = g.raycastResult.hitPointWorld;
          p = r[h];
          q = m;
          D = A;
          F = u;
          var K = v, X = C;
          B.getVelocityAtWorldPoint(D, F);
          t.getVelocityAtWorldPoint(D, K);
          F.vsub(K, X);
          D = p.dot(X);
          B = k(B, A, p);
          t = k(t, A, p);
          t = 1 / (B + t) * -D;
          q < t && (t = q);
          t < -q && (t = -q);
          q = t;
          q += g.engineForce * b;
          m /= q;
          g.slipInfo *= m;
        }
        g.forwardImpulse = 0;
        g.skidInfo = 1;
        n && (g.skidInfo = 1, n = g.suspensionForce * b * g.frictionSlip, m = n * n, g.forwardImpulse = q, q = .5 * g.forwardImpulse, t = 1 * g.sideImpulse, q = q * q + t * t, g.sliding = !1, q > m && (this.sliding = !0, g.sliding = !0, m = n / Math.sqrt(q), g.skidInfo *= m));
      }
      if (this.sliding) {
        for (h = 0; h < d; h++) {
          g = e[h], 0 !== g.sideImpulse && 1 > g.skidInfo && (g.forwardImpulse *= g.skidInfo, g.sideImpulse *= g.skidInfo);
        }
      }
      for (h = 0; h < d; h++) {
        g = e[h], b = new c, b.copy(g.raycastResult.hitPointWorld), 0 !== g.forwardImpulse && (n = new c, r[h].scale(g.forwardImpulse, n), f.applyImpulse(n, b)), 0 !== g.sideImpulse && (n = g.raycastResult.body, m = new c, m.copy(g.raycastResult.hitPointWorld), q = new c, z[h].scale(g.sideImpulse, q), f.pointToLocalFrame(b, b), b["xyz"[this.indexUpAxis]] *= g.rollInfluence, f.pointToWorldFrame(b, b), f.applyImpulse(q, b), q.scale(-1, q), n.applyImpulse(q, m));
      }
    };
    var u = new c, v = new c, C = new c, A = new c, D = new c, F = new c, B = new c, E = new c, H = new c, L = new c;
  }, {"../collision/Ray":9, "../collision/RaycastResult":10, "../math/Quaternion":28, "../math/Vec3":30, "../objects/WheelInfo":36, "./Body":31}], 33:[function(d, g, h) {
    function e(b) {
      this.wheelBodies = [];
      this.coordinateSystem = "undefined" === typeof b.coordinateSystem ? new t(1, 2, 3) : b.coordinateSystem.clone();
      this.chassisBody = b.chassisBody;
      this.chassisBody || (b = new p(new t(5, 2, .5)), this.chassisBody = new k(1, b));
      this.constraints = [];
      this.wheelAxes = [];
      this.wheelForces = [];
    }
    var k = d("./Body"), c = d("../shapes/Sphere"), p = d("../shapes/Box"), t = d("../math/Vec3"), f = d("../constraints/HingeConstraint");
    g.exports = e;
    e.prototype.addWheel = function(b) {
      b = b || {};
      var e = b.body;
      e || (e = new k(1, new c(1.2)));
      this.wheelBodies.push(e);
      this.wheelForces.push(0);
      new t;
      var d = "undefined" !== typeof b.position ? b.position.clone() : new t, m = new t;
      this.chassisBody.pointToWorldFrame(d, m);
      e.position.set(m.x, m.y, m.z);
      b = "undefined" !== typeof b.axis ? b.axis.clone() : new t(0, 1, 0);
      this.wheelAxes.push(b);
      e = new f(this.chassisBody, e, {pivotA:d, axisA:b, pivotB:t.ZERO, axisB:b, collideConnected:!1});
      this.constraints.push(e);
      return this.wheelBodies.length - 1;
    };
    e.prototype.setSteeringValue = function(b, c) {
      var e = this.wheelAxes[c], d = Math.cos(b);
      b = Math.sin(b);
      var f = e.x;
      e = e.y;
      this.constraints[c].axisA.set(d * f - b * e, b * f + d * e, 0);
    };
    e.prototype.setMotorSpeed = function(b, c) {
      c = this.constraints[c];
      c.enableMotor();
      c.motorTargetVelocity = b;
    };
    e.prototype.disableMotor = function(b) {
      this.constraints[b].disableMotor();
    };
    var n = new t;
    e.prototype.setWheelForce = function(b, c) {
      this.wheelForces[c] = b;
    };
    e.prototype.applyWheelForce = function(b, c) {
      var e = this.wheelBodies[c], d = e.torque;
      this.wheelAxes[c].scale(b, n);
      e.vectorToWorldFrame(n, n);
      d.vadd(n, d);
    };
    e.prototype.addToWorld = function(b) {
      for (var c = this.constraints, e = this.wheelBodies.concat([this.chassisBody]), d = 0; d < e.length; d++) {
        b.add(e[d]);
      }
      for (d = 0; d < c.length; d++) {
        b.addConstraint(c[d]);
      }
      b.addEventListener("preStep", this._update.bind(this));
    };
    e.prototype._update = function() {
      for (var b = this.wheelForces, c = 0; c < b.length; c++) {
        this.applyWheelForce(b[c], c);
      }
    };
    e.prototype.removeFromWorld = function(b) {
      for (var c = this.constraints, e = this.wheelBodies.concat([this.chassisBody]), d = 0; d < e.length; d++) {
        b.remove(e[d]);
      }
      for (d = 0; d < c.length; d++) {
        b.removeConstraint(c[d]);
      }
    };
    var b = new t;
    e.prototype.getWheelSpeed = function(c) {
      var e = this.wheelBodies[c].angularVelocity;
      this.chassisBody.vectorToWorldFrame(this.wheelAxes[c], b);
      return e.dot(b);
    };
  }, {"../constraints/HingeConstraint":15, "../math/Vec3":30, "../shapes/Box":37, "../shapes/Sphere":44, "./Body":31}], 34:[function(d, g, h) {
    function e() {
      this.particles = [];
      this.speedOfSound = this.smoothingRadius = this.density = 1;
      this.viscosity = .01;
      this.eps = 1E-6;
      this.pressures = [];
      this.densities = [];
      this.neighbors = [];
    }
    g.exports = e;
    d("../shapes/Shape");
    g = d("../math/Vec3");
    d("../math/Quaternion");
    d("../shapes/Particle");
    d("../objects/Body");
    d("../material/Material");
    e.prototype.add = function(b) {
      this.particles.push(b);
      this.neighbors.length < this.particles.length && this.neighbors.push([]);
    };
    e.prototype.remove = function(b) {
      b = this.particles.indexOf(b);
      -1 !== b && (this.particles.splice(b, 1), this.neighbors.length > this.particles.length && this.neighbors.pop());
    };
    var k = new g;
    e.prototype.getNeighbors = function(b, c) {
      for (var e = this.particles.length, d = b.id, f = this.smoothingRadius * this.smoothingRadius, m = 0; m !== e; m++) {
        var h = this.particles[m];
        h.position.vsub(b.position, k);
        d !== h.id && k.norm2() < f && c.push(h);
      }
    };
    var c = new g, p = new g, t = new g, f = new g, n = new g, b = new g;
    e.prototype.update = function() {
      for (var e = this.particles.length, d = this.speedOfSound, k = this.eps, h = 0; h !== e; h++) {
        var g = this.particles[h], r = this.neighbors[h];
        r.length = 0;
        this.getNeighbors(g, r);
        r.push(this.particles[h]);
        for (var u = r.length, v = 0, C = 0; C !== u; C++) {
          g.position.vsub(r[C].position, c);
          var A = c.norm();
          A = this.w(A);
          v += r[C].mass * A;
        }
        this.densities[h] = v;
        this.pressures[h] = d * d * (this.densities[h] - this.density);
      }
      for (h = 0; h !== e; h++) {
        d = this.particles[h];
        p.set(0, 0, 0);
        t.set(0, 0, 0);
        r = this.neighbors[h];
        u = r.length;
        for (C = 0; C !== u; C++) {
          v = r[C], d.position.vsub(v.position, n), A = n.norm(), g = -v.mass * (this.pressures[h] / (this.densities[h] * this.densities[h] + k) + this.pressures[C] / (this.densities[C] * this.densities[C] + k)), this.gradw(n, f), f.mult(g, f), p.vadd(f, p), v.velocity.vsub(d.velocity, b), b.mult(1 / (1E-4 + this.densities[h] * this.densities[C]) * this.viscosity * v.mass, b), g = this.nablaw(A), b.mult(g, b), t.vadd(b, t);
        }
        t.mult(d.mass, t);
        p.mult(d.mass, p);
        d.force.vadd(t, d.force);
        d.force.vadd(p, d.force);
      }
    };
    e.prototype.w = function(b) {
      var c = this.smoothingRadius;
      return 315 / (64 * Math.PI * Math.pow(c, 9)) * Math.pow(c * c - b * b, 3);
    };
    e.prototype.gradw = function(b, c) {
      var e = b.norm(), d = this.smoothingRadius;
      b.mult(945 / (32 * Math.PI * Math.pow(d, 9)) * Math.pow(d * d - e * e, 2), c);
    };
    e.prototype.nablaw = function(b) {
      var c = this.smoothingRadius;
      return 945 / (32 * Math.PI * Math.pow(c, 9)) * (c * c - b * b) * (7 * b * b - 3 * c * c);
    };
  }, {"../material/Material":25, "../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "../shapes/Particle":41, "../shapes/Shape":43}], 35:[function(d, g, h) {
    function e(b, c, e) {
      e = e || {};
      this.restLength = "number" === typeof e.restLength ? e.restLength : 1;
      this.stiffness = e.stiffness || 100;
      this.damping = e.damping || 1;
      this.bodyA = b;
      this.bodyB = c;
      this.localAnchorA = new k;
      this.localAnchorB = new k;
      e.localAnchorA && this.localAnchorA.copy(e.localAnchorA);
      e.localAnchorB && this.localAnchorB.copy(e.localAnchorB);
      e.worldAnchorA && this.setWorldAnchorA(e.worldAnchorA);
      e.worldAnchorB && this.setWorldAnchorB(e.worldAnchorB);
    }
    var k = d("../math/Vec3");
    g.exports = e;
    e.prototype.setWorldAnchorA = function(b) {
      this.bodyA.pointToLocalFrame(b, this.localAnchorA);
    };
    e.prototype.setWorldAnchorB = function(b) {
      this.bodyB.pointToLocalFrame(b, this.localAnchorB);
    };
    e.prototype.getWorldAnchorA = function(b) {
      this.bodyA.pointToWorldFrame(this.localAnchorA, b);
    };
    e.prototype.getWorldAnchorB = function(b) {
      this.bodyB.pointToWorldFrame(this.localAnchorB, b);
    };
    var c = new k, p = new k, t = new k, f = new k, n = new k, b = new k, m = new k, q = new k, y = new k, x = new k, z = new k;
    e.prototype.applyForce = function() {
      var e = this.stiffness, d = this.damping, k = this.restLength, h = this.bodyA, g = this.bodyB;
      this.getWorldAnchorA(n);
      this.getWorldAnchorB(b);
      n.vsub(h.position, m);
      b.vsub(g.position, q);
      b.vsub(n, c);
      var D = c.norm();
      p.copy(c);
      p.normalize();
      g.velocity.vsub(h.velocity, t);
      g.angularVelocity.cross(q, z);
      t.vadd(z, t);
      h.angularVelocity.cross(m, z);
      t.vsub(z, t);
      p.mult(-e * (D - k) - d * t.dot(p), f);
      h.force.vsub(f, h.force);
      g.force.vadd(f, g.force);
      m.cross(f, y);
      q.cross(f, x);
      h.torque.vsub(y, h.torque);
      g.torque.vadd(x, g.torque);
    };
  }, {"../math/Vec3":30}], 36:[function(d, g, h) {
    function e(b) {
      b = t.defaults(b, {chassisConnectionPointLocal:new k, chassisConnectionPointWorld:new k, directionLocal:new k, directionWorld:new k, axleLocal:new k, axleWorld:new k, suspensionRestLength:1, suspensionMaxLength:2, radius:1, suspensionStiffness:100, dampingCompression:10, dampingRelaxation:10, frictionSlip:1E4, steering:0, rotation:0, deltaRotation:0, rollInfluence:.01, maxSuspensionForce:Number.MAX_VALUE, isFrontWheel:!0, clippedInvContactDotSuspension:1, suspensionRelativeVelocity:0, suspensionForce:0, 
      skidInfo:0, suspensionLength:0, maxSuspensionTravel:1, useCustomSlidingRotationalSpeed:!1, customSlidingRotationalSpeed:-.1});
      this.maxSuspensionTravel = b.maxSuspensionTravel;
      this.customSlidingRotationalSpeed = b.customSlidingRotationalSpeed;
      this.useCustomSlidingRotationalSpeed = b.useCustomSlidingRotationalSpeed;
      this.sliding = !1;
      this.chassisConnectionPointLocal = b.chassisConnectionPointLocal.clone();
      this.chassisConnectionPointWorld = b.chassisConnectionPointWorld.clone();
      this.directionLocal = b.directionLocal.clone();
      this.directionWorld = b.directionWorld.clone();
      this.axleLocal = b.axleLocal.clone();
      this.axleWorld = b.axleWorld.clone();
      this.suspensionRestLength = b.suspensionRestLength;
      this.suspensionMaxLength = b.suspensionMaxLength;
      this.radius = b.radius;
      this.suspensionStiffness = b.suspensionStiffness;
      this.dampingCompression = b.dampingCompression;
      this.dampingRelaxation = b.dampingRelaxation;
      this.frictionSlip = b.frictionSlip;
      this.deltaRotation = this.rotation = this.steering = 0;
      this.rollInfluence = b.rollInfluence;
      this.maxSuspensionForce = b.maxSuspensionForce;
      this.brake = this.engineForce = 0;
      this.isFrontWheel = b.isFrontWheel;
      this.clippedInvContactDotSuspension = 1;
      this.forwardImpulse = this.sideImpulse = this.suspensionLength = this.skidInfo = this.suspensionForce = this.suspensionRelativeVelocity = 0;
      this.raycastResult = new p;
      this.worldTransform = new c;
      this.isInContact = !1;
    }
    var k = d("../math/Vec3"), c = d("../math/Transform"), p = d("../collision/RaycastResult"), t = d("../utils/Utils");
    g.exports = e;
    var f = new k, n = new k;
    f = new k;
    e.prototype.updateWheel = function(b) {
      var c = this.raycastResult;
      if (this.isInContact) {
        var e = c.hitNormalWorld.dot(c.directionWorld);
        c.hitPointWorld.vsub(b.position, n);
        b.getVelocityAtWorldPoint(n, f);
        b = c.hitNormalWorld.dot(f);
        -.1 <= e ? (this.suspensionRelativeVelocity = 0, this.clippedInvContactDotSuspension = 10) : (e = -1 / e, this.suspensionRelativeVelocity = b * e, this.clippedInvContactDotSuspension = e);
      } else {
        c.suspensionLength = this.suspensionRestLength, this.suspensionRelativeVelocity = 0, c.directionWorld.scale(-1, c.hitNormalWorld), this.clippedInvContactDotSuspension = 1;
      }
    };
  }, {"../collision/RaycastResult":10, "../math/Transform":29, "../math/Vec3":30, "../utils/Utils":53}], 37:[function(d, g, h) {
    function e(c) {
      k.call(this);
      this.type = k.types.BOX;
      this.halfExtents = c;
      this.convexPolyhedronRepresentation = null;
      this.updateConvexPolyhedronRepresentation();
      this.updateBoundingSphereRadius();
    }
    g.exports = e;
    var k = d("./Shape"), c = d("../math/Vec3"), p = d("./ConvexPolyhedron");
    e.prototype = new k;
    e.prototype.constructor = e;
    e.prototype.updateConvexPolyhedronRepresentation = function() {
      var e = this.halfExtents.x, b = this.halfExtents.y, d = this.halfExtents.z;
      e = [new c(-e, -b, -d), new c(e, -b, -d), new c(e, b, -d), new c(-e, b, -d), new c(-e, -b, d), new c(e, -b, d), new c(e, b, d), new c(-e, b, d)];
      new c(0, 0, 1);
      new c(0, 1, 0);
      new c(1, 0, 0);
      this.convexPolyhedronRepresentation = e = new p(e, [[3, 2, 1, 0], [4, 5, 6, 7], [5, 4, 0, 1], [2, 3, 7, 6], [0, 4, 7, 3], [1, 2, 6, 5]]);
      e.material = this.material;
    };
    e.prototype.calculateLocalInertia = function(d, b) {
      b = b || new c;
      e.calculateInertia(this.halfExtents, d, b);
      return b;
    };
    e.calculateInertia = function(c, b, e) {
      e.x = 1 / 12 * b * (4 * c.y * c.y + 4 * c.z * c.z);
      e.y = 1 / 12 * b * (4 * c.x * c.x + 4 * c.z * c.z);
      e.z = 1 / 12 * b * (4 * c.y * c.y + 4 * c.x * c.x);
    };
    e.prototype.getSideNormals = function(c, b) {
      var e = this.halfExtents;
      c[0].set(e.x, 0, 0);
      c[1].set(0, e.y, 0);
      c[2].set(0, 0, e.z);
      c[3].set(-e.x, 0, 0);
      c[4].set(0, -e.y, 0);
      c[5].set(0, 0, -e.z);
      if (void 0 !== b) {
        for (e = 0; e !== c.length; e++) {
          b.vmult(c[e], c[e]);
        }
      }
      return c;
    };
    e.prototype.volume = function() {
      return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
    };
    e.prototype.updateBoundingSphereRadius = function() {
      this.boundingSphereRadius = this.halfExtents.norm();
    };
    var t = new c;
    new c;
    e.prototype.forEachWorldCorner = function(c, b, e) {
      var d = this.halfExtents;
      d = [[d.x, d.y, d.z], [-d.x, d.y, d.z], [-d.x, -d.y, d.z], [-d.x, -d.y, -d.z], [d.x, -d.y, -d.z], [d.x, d.y, -d.z], [-d.x, d.y, -d.z], [d.x, -d.y, d.z]];
      for (var f = 0; f < d.length; f++) {
        t.set(d[f][0], d[f][1], d[f][2]), b.vmult(t, t), c.vadd(t, t), e(t.x, t.y, t.z);
      }
    };
    var f = [new c, new c, new c, new c, new c, new c, new c, new c];
    e.prototype.calculateWorldAABB = function(c, b, e, d) {
      var m = this.halfExtents;
      f[0].set(m.x, m.y, m.z);
      f[1].set(-m.x, m.y, m.z);
      f[2].set(-m.x, -m.y, m.z);
      f[3].set(-m.x, -m.y, -m.z);
      f[4].set(m.x, -m.y, -m.z);
      f[5].set(m.x, m.y, -m.z);
      f[6].set(-m.x, m.y, -m.z);
      f[7].set(m.x, -m.y, m.z);
      var k = f[0];
      b.vmult(k, k);
      c.vadd(k, k);
      d.copy(k);
      e.copy(k);
      for (m = 1; 8 > m; m++) {
        k = f[m];
        b.vmult(k, k);
        c.vadd(k, k);
        var h = k.x, g = k.y;
        k = k.z;
        h > d.x && (d.x = h);
        g > d.y && (d.y = g);
        k > d.z && (d.z = k);
        h < e.x && (e.x = h);
        g < e.y && (e.y = g);
        k < e.z && (e.z = k);
      }
    };
  }, {"../math/Vec3":30, "./ConvexPolyhedron":38, "./Shape":43}], 38:[function(d, g, h) {
    function e(b, c, e) {
      k.call(this);
      this.type = k.types.CONVEXPOLYHEDRON;
      this.vertices = b || [];
      this.worldVertices = [];
      this.worldVerticesNeedsUpdate = !0;
      this.faces = c || [];
      this.faceNormals = [];
      this.computeNormals();
      this.worldFaceNormalsNeedsUpdate = !0;
      this.worldFaceNormals = [];
      this.uniqueEdges = [];
      this.uniqueAxes = e ? e.slice() : null;
      this.computeEdges();
      this.updateBoundingSphereRadius();
    }
    g.exports = e;
    var k = d("./Shape"), c = d("../math/Vec3");
    d("../math/Quaternion");
    var p = d("../math/Transform");
    e.prototype = new k;
    e.prototype.constructor = e;
    var t = new c;
    e.prototype.computeEdges = function() {
      for (var b = this.faces, c = this.vertices, e = this.uniqueEdges, d = e.length = 0; d !== b.length; d++) {
        for (var f = b[d], m = f.length, k = 0; k !== m; k++) {
          c[f[k]].vsub(c[f[(k + 1) % m]], t);
          t.normalize();
          for (var h = !1, g = 0; g !== e.length; g++) {
            if (e[g].almostEquals(t) || e[g].almostEquals(t)) {
              h = !0;
              break;
            }
          }
          h || e.push(t.clone());
        }
      }
    };
    e.prototype.computeNormals = function() {
      this.faceNormals.length = this.faces.length;
      for (var b = 0; b < this.faces.length; b++) {
        for (var e = 0; e < this.faces[b].length; e++) {
          if (!this.vertices[this.faces[b][e]]) {
            throw Error("Vertex " + this.faces[b][e] + " not found!");
          }
        }
        e = this.faceNormals[b] || new c;
        this.getFaceNormal(b, e);
        e.negate(e);
        this.faceNormals[b] = e;
        if (0 > e.dot(this.vertices[this.faces[b][0]])) {
          for (console.error(".faceNormals[" + b + "] = Vec3(" + e.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule."), e = 0; e < this.faces[b].length; e++) {
            console.warn(".vertices[" + this.faces[b][e] + "] = Vec3(" + this.vertices[this.faces[b][e]].toString() + ")");
          }
        }
      }
    };
    var f = new c, n = new c;
    e.computeNormal = function(b, c, e, d) {
      c.vsub(b, n);
      e.vsub(c, f);
      f.cross(n, d);
      d.isZero() || d.normalize();
    };
    e.prototype.getFaceNormal = function(b, c) {
      b = this.faces[b];
      return e.computeNormal(this.vertices[b[0]], this.vertices[b[1]], this.vertices[b[2]], c);
    };
    var b = new c;
    e.prototype.clipAgainstHull = function(e, d, f, m, k, h, g, r, n) {
      for (var u = -1, p = -Number.MAX_VALUE, q = 0; q < f.faces.length; q++) {
        b.copy(f.faceNormals[q]);
        k.vmult(b, b);
        var t = b.dot(h);
        t > p && (p = t, u = q);
      }
      p = [];
      q = f.faces[u];
      t = q.length;
      for (var v = 0; v < t; v++) {
        var y = f.vertices[q[v]], x = new c;
        x.copy(y);
        k.vmult(x, x);
        m.vadd(x, x);
        p.push(x);
      }
      0 <= u && this.clipFaceAgainstHull(h, e, d, p, g, r, n);
    };
    var m = new c, q = new c, y = new c, x = new c, z = new c, r = new c;
    e.prototype.findSeparatingAxis = function(b, c, e, d, f, k, h, g) {
      var n = Number.MAX_VALUE, u = 0;
      if (this.uniqueAxes) {
        for (t = 0; t !== this.uniqueAxes.length; t++) {
          e.vmult(this.uniqueAxes[t], m);
          v = this.testSepAxis(m, b, c, e, d, f);
          if (!1 === v) {
            return !1;
          }
          v < n && (n = v, k.copy(m));
        }
      } else {
        for (var p = h ? h.length : this.faces.length, t = 0; t < p; t++) {
          v = h ? h[t] : t;
          m.copy(this.faceNormals[v]);
          e.vmult(m, m);
          var v = this.testSepAxis(m, b, c, e, d, f);
          if (!1 === v) {
            return !1;
          }
          v < n && (n = v, k.copy(m));
        }
      }
      if (b.uniqueAxes) {
        for (t = 0; t !== b.uniqueAxes.length; t++) {
          f.vmult(b.uniqueAxes[t], q);
          u++;
          v = this.testSepAxis(q, b, c, e, d, f);
          if (!1 === v) {
            return !1;
          }
          v < n && (n = v, k.copy(q));
        }
      } else {
        for (h = g ? g.length : b.faces.length, t = 0; t < h; t++) {
          v = g ? g[t] : t;
          q.copy(b.faceNormals[v]);
          f.vmult(q, q);
          u++;
          v = this.testSepAxis(q, b, c, e, d, f);
          if (!1 === v) {
            return !1;
          }
          v < n && (n = v, k.copy(q));
        }
      }
      for (g = 0; g !== this.uniqueEdges.length; g++) {
        for (e.vmult(this.uniqueEdges[g], x), u = 0; u !== b.uniqueEdges.length; u++) {
          if (f.vmult(b.uniqueEdges[u], z), x.cross(z, r), !r.almostZero()) {
            r.normalize();
            t = this.testSepAxis(r, b, c, e, d, f);
            if (!1 === t) {
              return !1;
            }
            t < n && (n = t, k.copy(r));
          }
        }
      }
      d.vsub(c, y);
      0 < y.dot(k) && k.negate(k);
      return !0;
    };
    var u = [], v = [];
    e.prototype.testSepAxis = function(b, c, d, f, m, k) {
      e.project(this, b, d, f, u);
      e.project(c, b, m, k, v);
      d = u[0];
      b = u[1];
      c = v[0];
      f = v[1];
      if (d < f || c < b) {
        return !1;
      }
      d -= f;
      b = c - b;
      return d < b ? d : b;
    };
    var C = new c, A = new c;
    e.prototype.calculateLocalInertia = function(b, c) {
      this.computeLocalAABB(C, A);
      var e = A.x - C.x, d = A.y - C.y, f = A.z - C.z;
      c.x = 1 / 12 * b * (4 * d * d + 4 * f * f);
      c.y = 1 / 12 * b * (4 * e * e + 4 * f * f);
      c.z = 1 / 12 * b * (4 * d * d + 4 * e * e);
    };
    e.prototype.getPlaneConstantOfFace = function(b) {
      return -this.faceNormals[b].dot(this.vertices[this.faces[b][0]]);
    };
    var D = new c, F = new c, B = new c, E = new c, H = new c, L = new c, K = new c, P = new c;
    e.prototype.clipFaceAgainstHull = function(b, c, e, d, f, m, k) {
      for (var h = [], g = -1, r = Number.MAX_VALUE, n = 0; n < this.faces.length; n++) {
        D.copy(this.faceNormals[n]);
        e.vmult(D, D);
        var u = D.dot(b);
        u < r && (r = u, g = n);
      }
      if (!(0 > g)) {
        b = this.faces[g];
        b.connectedFaces = [];
        for (r = 0; r < this.faces.length; r++) {
          for (n = 0; n < this.faces[r].length; n++) {
            -1 !== b.indexOf(this.faces[r][n]) && r !== g && -1 === b.connectedFaces.indexOf(r) && b.connectedFaces.push(r);
          }
        }
        r = b.length;
        for (n = 0; n < r; n++) {
          u = this.vertices[b[n]];
          u.vsub(this.vertices[b[(n + 1) % r]], F);
          B.copy(F);
          e.vmult(B, B);
          c.vadd(B, B);
          E.copy(this.faceNormals[g]);
          e.vmult(E, E);
          c.vadd(E, E);
          B.cross(E, H);
          H.negate(H);
          L.copy(u);
          e.vmult(L, L);
          c.vadd(L, L);
          L.dot(H);
          u = b.connectedFaces[n];
          K.copy(this.faceNormals[u]);
          u = this.getPlaneConstantOfFace(u);
          P.copy(K);
          e.vmult(P, P);
          u -= P.dot(c);
          for (this.clipFaceAgainstPlane(d, h, P, u); d.length;) {
            d.shift();
          }
          for (; h.length;) {
            d.push(h.shift());
          }
        }
        K.copy(this.faceNormals[g]);
        u = this.getPlaneConstantOfFace(g);
        P.copy(K);
        e.vmult(P, P);
        u -= P.dot(c);
        for (r = 0; r < d.length; r++) {
          c = P.dot(d[r]) + u, c <= f && (console.log("clamped: depth=" + c + " to minDist=" + (f + "")), c = f), c <= m && (e = d[r], 0 >= c && k.push({point:e, normal:P, depth:c}));
        }
      }
    };
    e.prototype.clipFaceAgainstPlane = function(b, e, d, f) {
      var m = b.length;
      if (2 > m) {
        return e;
      }
      var k = b[b.length - 1];
      var h = d.dot(k) + f;
      for (var g = 0; g < m; g++) {
        var r = b[g];
        var n = d.dot(r) + f;
        if (0 > h) {
          if (0 > n) {
            var u = new c;
            u.copy(r);
          } else {
            u = new c, k.lerp(r, h / (h - n), u);
          }
          e.push(u);
        } else {
          0 > n && (u = new c, k.lerp(r, h / (h - n), u), e.push(u), e.push(r));
        }
        k = r;
        h = n;
      }
      return e;
    };
    e.prototype.computeWorldVertices = function(b, e) {
      for (var d = this.vertices.length; this.worldVertices.length < d;) {
        this.worldVertices.push(new c);
      }
      for (var f = this.vertices, m = this.worldVertices, k = 0; k !== d; k++) {
        e.vmult(f[k], m[k]), b.vadd(m[k], m[k]);
      }
      this.worldVerticesNeedsUpdate = !1;
    };
    new c;
    e.prototype.computeLocalAABB = function(b, c) {
      var e = this.vertices.length, d = this.vertices;
      b.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      c.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
      for (var f = 0; f < e; f++) {
        var m = d[f];
        m.x < b.x ? b.x = m.x : m.x > c.x && (c.x = m.x);
        m.y < b.y ? b.y = m.y : m.y > c.y && (c.y = m.y);
        m.z < b.z ? b.z = m.z : m.z > c.z && (c.z = m.z);
      }
    };
    e.prototype.computeWorldFaceNormals = function(b) {
      for (var e = this.faceNormals.length; this.worldFaceNormals.length < e;) {
        this.worldFaceNormals.push(new c);
      }
      for (var d = this.faceNormals, f = this.worldFaceNormals, m = 0; m !== e; m++) {
        b.vmult(d[m], f[m]);
      }
      this.worldFaceNormalsNeedsUpdate = !1;
    };
    e.prototype.updateBoundingSphereRadius = function() {
      for (var b = 0, c = this.vertices, e = 0, d = c.length; e !== d; e++) {
        var f = c[e].norm2();
        f > b && (b = f);
      }
      this.boundingSphereRadius = Math.sqrt(b);
    };
    var J = new c;
    e.prototype.calculateWorldAABB = function(b, c, e, d) {
      for (var f = this.vertices.length, m = this.vertices, k, h, g, r, n, u, p = 0; p < f; p++) {
        J.copy(m[p]);
        c.vmult(J, J);
        b.vadd(J, J);
        var q = J;
        if (q.x < k || void 0 === k) {
          k = q.x;
        } else {
          if (q.x > r || void 0 === r) {
            r = q.x;
          }
        }
        if (q.y < h || void 0 === h) {
          h = q.y;
        } else {
          if (q.y > n || void 0 === n) {
            n = q.y;
          }
        }
        if (q.z < g || void 0 === g) {
          g = q.z;
        } else {
          if (q.z > u || void 0 === u) {
            u = q.z;
          }
        }
      }
      e.set(k, h, g);
      d.set(r, n, u);
    };
    e.prototype.volume = function() {
      return 4 * Math.PI * this.boundingSphereRadius / 3;
    };
    e.prototype.getAveragePointLocal = function(b) {
      b = b || new c;
      for (var e = this.vertices.length, d = this.vertices, f = 0; f < e; f++) {
        b.vadd(d[f], b);
      }
      b.mult(1 / e, b);
      return b;
    };
    e.prototype.transformAllPoints = function(b, c) {
      var e = this.vertices.length, d = this.vertices;
      if (c) {
        for (var f = 0; f < e; f++) {
          var m = d[f];
          c.vmult(m, m);
        }
        for (f = 0; f < this.faceNormals.length; f++) {
          m = this.faceNormals[f], c.vmult(m, m);
        }
      }
      if (b) {
        for (f = 0; f < e; f++) {
          m = d[f], m.vadd(b, m);
        }
      }
    };
    var I = new c, N = new c, S = new c;
    e.prototype.pointIsInside = function(b) {
      var c = this.vertices, e = this.faces, d = this.faceNormals, f = this.faces.length;
      this.getAveragePointLocal(I);
      for (var m = 0; m < f; m++) {
        var k = d[m];
        var h = c[e[m][0]], g = N;
        b.vsub(h, g);
        g = k.dot(g);
        var r = S;
        I.vsub(h, r);
        k = k.dot(r);
        if (0 > g && 0 < k || 0 < g && 0 > k) {
          return !1;
        }
      }
      return -1;
    };
    new c;
    var Q = new c, Z = new c;
    e.project = function(b, c, e, d, f) {
      var m = b.vertices.length;
      b = b.vertices;
      Z.setZero();
      p.vectorToLocalFrame(e, d, c, Q);
      p.pointToLocalFrame(e, d, Z, Z);
      d = Z.dot(Q);
      e = c = b[0].dot(Q);
      for (var k = 1; k < m; k++) {
        var h = b[k].dot(Q);
        h > c && (c = h);
        h < e && (e = h);
      }
      e -= d;
      c -= d;
      e > c && (m = e, e = c, c = m);
      f[0] = c;
      f[1] = e;
    };
  }, {"../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "./Shape":43}], 39:[function(d, g, h) {
    function e(e, d, h, b) {
      var f = [], g = [], n = [], t = [], z = [], r = Math.cos, u = Math.sin;
      f.push(new c(d * r(0), d * u(0), .5 * -h));
      t.push(0);
      f.push(new c(e * r(0), e * u(0), .5 * h));
      z.push(1);
      for (var v = 0; v < b; v++) {
        var C = 2 * Math.PI / b * (v + 1), A = 2 * Math.PI / b * (v + .5);
        v < b - 1 ? (f.push(new c(d * r(C), d * u(C), .5 * -h)), t.push(2 * v + 2), f.push(new c(e * r(C), e * u(C), .5 * h)), z.push(2 * v + 3), n.push([2 * v + 2, 2 * v + 3, 2 * v + 1, 2 * v])) : n.push([0, 1, 2 * v + 1, 2 * v]);
        (1 === b % 2 || v < b / 2) && g.push(new c(r(A), u(A), 0));
      }
      n.push(z);
      g.push(new c(0, 0, 1));
      e = [];
      for (v = 0; v < t.length; v++) {
        e.push(t[t.length - v - 1]);
      }
      n.push(e);
      this.type = k.types.CONVEXPOLYHEDRON;
      p.call(this, f, n, g);
    }
    g.exports = e;
    var k = d("./Shape"), c = d("../math/Vec3");
    d("../math/Quaternion");
    var p = d("./ConvexPolyhedron");
    e.prototype = new p;
  }, {"../math/Quaternion":28, "../math/Vec3":30, "./ConvexPolyhedron":38, "./Shape":43}], 40:[function(d, g, h) {
    function e(e, d) {
      d = t.defaults(d, {maxValue:null, minValue:null, elementSize:1});
      this.data = e;
      this.maxValue = d.maxValue;
      this.minValue = d.minValue;
      this.elementSize = d.elementSize;
      null === d.minValue && this.updateMinValue();
      null === d.maxValue && this.updateMaxValue();
      this.cacheEnabled = !0;
      k.call(this);
      this.pillarConvex = new c;
      this.pillarOffset = new p;
      this.type = k.types.HEIGHTFIELD;
      this.updateBoundingSphereRadius();
      this._cachedPillars = {};
    }
    var k = d("./Shape"), c = d("./ConvexPolyhedron"), p = d("../math/Vec3"), t = d("../utils/Utils");
    g.exports = e;
    e.prototype = new k;
    e.prototype.update = function() {
      this._cachedPillars = {};
    };
    e.prototype.updateMinValue = function() {
      for (var c = this.data, e = c[0][0], b = 0; b !== c.length; b++) {
        for (var d = 0; d !== c[b].length; d++) {
          var k = c[b][d];
          k < e && (e = k);
        }
      }
      this.minValue = e;
    };
    e.prototype.updateMaxValue = function() {
      for (var c = this.data, e = c[0][0], b = 0; b !== c.length; b++) {
        for (var d = 0; d !== c[b].length; d++) {
          var k = c[b][d];
          k > e && (e = k);
        }
      }
      this.maxValue = e;
    };
    e.prototype.setHeightValueAtIndex = function(c, e, b) {
      this.data[c][e] = b;
      this.clearCachedConvexTrianglePillar(c, e, !1);
      0 < c && (this.clearCachedConvexTrianglePillar(c - 1, e, !0), this.clearCachedConvexTrianglePillar(c - 1, e, !1));
      0 < e && (this.clearCachedConvexTrianglePillar(c, e - 1, !0), this.clearCachedConvexTrianglePillar(c, e - 1, !1));
      0 < e && 0 < c && this.clearCachedConvexTrianglePillar(c - 1, e - 1, !0);
    };
    e.prototype.getRectMinMax = function(c, e, b, d, k) {
      k = k || [];
      for (var f = this.data, m = this.minValue; c <= b; c++) {
        for (var h = e; h <= d; h++) {
          var g = f[c][h];
          g > m && (m = g);
        }
      }
      k[0] = this.minValue;
      k[1] = m;
    };
    e.prototype.getIndexOfPosition = function(c, e, b, d) {
      var f = this.elementSize, m = this.data;
      c = Math.floor(c / f);
      e = Math.floor(e / f);
      b[0] = c;
      b[1] = e;
      d && (0 > c && (c = 0), 0 > e && (e = 0), c >= m.length - 1 && (c = m.length - 1), e >= m[0].length - 1 && (e = m[0].length - 1));
      return 0 > c || 0 > e || c >= m.length - 1 || e >= m[0].length - 1 ? !1 : !0;
    };
    e.prototype.getHeightAt = function(c, e, b) {
      var d = [];
      this.getIndexOfPosition(c, e, d, b);
      c = [];
      this.getRectMinMax(d[0], d[1] + 1, d[0], d[1] + 1, c);
      return (c[0] + c[1]) / 2;
    };
    e.prototype.getCacheConvexTrianglePillarKey = function(c, e, b) {
      return c + "_" + e + "_" + (b ? 1 : 0);
    };
    e.prototype.getCachedConvexTrianglePillar = function(c, e, b) {
      return this._cachedPillars[this.getCacheConvexTrianglePillarKey(c, e, b)];
    };
    e.prototype.setCachedConvexTrianglePillar = function(c, e, b, d, k) {
      this._cachedPillars[this.getCacheConvexTrianglePillarKey(c, e, b)] = {convex:d, offset:k};
    };
    e.prototype.clearCachedConvexTrianglePillar = function(c, e, b) {
      delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(c, e, b)];
    };
    e.prototype.getConvexTrianglePillar = function(e, d, b) {
      var f = this.pillarConvex, k = this.pillarOffset;
      if (this.cacheEnabled) {
        var h = this.getCachedConvexTrianglePillar(e, d, b);
        if (h) {
          this.pillarConvex = h.convex;
          this.pillarOffset = h.offset;
          return;
        }
        f = new c;
        k = new p;
        this.pillarConvex = f;
        this.pillarOffset = k;
      }
      h = this.data;
      var g = this.elementSize, n = f.faces;
      f.vertices.length = 6;
      for (var r = 0; 6 > r; r++) {
        f.vertices[r] || (f.vertices[r] = new p);
      }
      n.length = 5;
      for (r = 0; 5 > r; r++) {
        n[r] || (n[r] = []);
      }
      r = f.vertices;
      var u = (Math.min(h[e][d], h[e + 1][d], h[e][d + 1], h[e + 1][d + 1]) - this.minValue) / 2 + this.minValue;
      b ? (k.set((e + .75) * g, (d + .75) * g, u), r[0].set(.25 * g, .25 * g, h[e + 1][d + 1] - u), r[1].set(-.75 * g, .25 * g, h[e][d + 1] - u), r[2].set(.25 * g, -.75 * g, h[e + 1][d] - u), r[3].set(.25 * g, .25 * g, -u - 1), r[4].set(-.75 * g, .25 * g, -u - 1), r[5].set(.25 * g, -.75 * g, -u - 1), n[0][0] = 0, n[0][1] = 1, n[0][2] = 2, n[1][0] = 5, n[1][1] = 4, n[1][2] = 3, n[2][0] = 2, n[2][1] = 5, n[2][2] = 3, n[2][3] = 0, n[3][0] = 3, n[3][1] = 4, n[3][2] = 1, n[3][3] = 0, n[4][0] = 1, n[4][1] = 
      4, n[4][2] = 5, n[4][3] = 2) : (k.set((e + .25) * g, (d + .25) * g, u), r[0].set(-.25 * g, -.25 * g, h[e][d] - u), r[1].set(.75 * g, -.25 * g, h[e + 1][d] - u), r[2].set(-.25 * g, .75 * g, h[e][d + 1] - u), r[3].set(-.25 * g, -.25 * g, -u - 1), r[4].set(.75 * g, -.25 * g, -u - 1), r[5].set(-.25 * g, .75 * g, -u - 1), n[0][0] = 0, n[0][1] = 1, n[0][2] = 2, n[1][0] = 5, n[1][1] = 4, n[1][2] = 3, n[2][0] = 0, n[2][1] = 2, n[2][2] = 5, n[2][3] = 3, n[3][0] = 1, n[3][1] = 0, n[3][2] = 3, n[3][3] = 
      4, n[4][0] = 4, n[4][1] = 5, n[4][2] = 2, n[4][3] = 1);
      f.computeNormals();
      f.computeEdges();
      f.updateBoundingSphereRadius();
      this.setCachedConvexTrianglePillar(e, d, b, f, k);
    };
    e.prototype.calculateLocalInertia = function(c, e) {
      e = e || new p;
      e.set(0, 0, 0);
      return e;
    };
    e.prototype.volume = function() {
      return Number.MAX_VALUE;
    };
    e.prototype.calculateWorldAABB = function(c, e, b, d) {
      b.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
      d.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    };
    e.prototype.updateBoundingSphereRadius = function() {
      var c = this.data, e = this.elementSize;
      this.boundingSphereRadius = (new p(c.length * e, c[0].length * e, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue)))).norm();
    };
  }, {"../math/Vec3":30, "../utils/Utils":53, "./ConvexPolyhedron":38, "./Shape":43}], 41:[function(d, g, h) {
    function e() {
      k.call(this);
      this.type = k.types.PARTICLE;
    }
    g.exports = e;
    var k = d("./Shape"), c = d("../math/Vec3");
    e.prototype = new k;
    e.prototype.constructor = e;
    e.prototype.calculateLocalInertia = function(e, d) {
      d = d || new c;
      d.set(0, 0, 0);
      return d;
    };
    e.prototype.volume = function() {
      return 0;
    };
    e.prototype.updateBoundingSphereRadius = function() {
      this.boundingSphereRadius = 0;
    };
    e.prototype.calculateWorldAABB = function(c, e, d, k) {
      d.copy(c);
      k.copy(c);
    };
  }, {"../math/Vec3":30, "./Shape":43}], 42:[function(d, g, h) {
    function e() {
      k.call(this);
      this.type = k.types.PLANE;
      this.worldNormal = new c;
      this.worldNormalNeedsUpdate = !0;
      this.boundingSphereRadius = Number.MAX_VALUE;
    }
    g.exports = e;
    var k = d("./Shape"), c = d("../math/Vec3");
    e.prototype = new k;
    e.prototype.constructor = e;
    e.prototype.computeWorldNormal = function(c) {
      var e = this.worldNormal;
      e.set(0, 0, 1);
      c.vmult(e, e);
      this.worldNormalNeedsUpdate = !1;
    };
    e.prototype.calculateLocalInertia = function(e, d) {
      return d = d || new c;
    };
    e.prototype.volume = function() {
      return Number.MAX_VALUE;
    };
    var p = new c;
    e.prototype.calculateWorldAABB = function(c, e, d, b) {
      p.set(0, 0, 1);
      e.vmult(p, p);
      e = Number.MAX_VALUE;
      d.set(-e, -e, -e);
      b.set(e, e, e);
      1 === p.x && (b.x = c.x);
      1 === p.y && (b.y = c.y);
      1 === p.z && (b.z = c.z);
      -1 === p.x && (d.x = c.x);
      -1 === p.y && (d.y = c.y);
      -1 === p.z && (d.z = c.z);
    };
    e.prototype.updateBoundingSphereRadius = function() {
      this.boundingSphereRadius = Number.MAX_VALUE;
    };
  }, {"../math/Vec3":30, "./Shape":43}], 43:[function(d, g, h) {
    function e() {
      this.id = e.idCounter++;
      this.boundingSphereRadius = this.type = 0;
      this.collisionResponse = !0;
      this.material = null;
    }
    g.exports = e;
    e = d("./Shape");
    d("../math/Vec3");
    d("../math/Quaternion");
    d("../material/Material");
    e.prototype.constructor = e;
    e.prototype.updateBoundingSphereRadius = function() {
      throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
    };
    e.prototype.volume = function() {
      throw "volume() not implemented for shape type " + this.type;
    };
    e.prototype.calculateLocalInertia = function(e, c) {
      throw "calculateLocalInertia() not implemented for shape type " + this.type;
    };
    e.idCounter = 0;
    e.types = {SPHERE:1, PLANE:2, BOX:4, COMPOUND:8, CONVEXPOLYHEDRON:16, HEIGHTFIELD:32, PARTICLE:64, CYLINDER:128, TRIMESH:256};
  }, {"../material/Material":25, "../math/Quaternion":28, "../math/Vec3":30, "./Shape":43}], 44:[function(d, g, h) {
    function e(c) {
      k.call(this);
      this.radius = void 0 !== c ? Number(c) : 1;
      this.type = k.types.SPHERE;
      if (0 > this.radius) {
        throw Error("The sphere radius cannot be negative.");
      }
      this.updateBoundingSphereRadius();
    }
    g.exports = e;
    var k = d("./Shape"), c = d("../math/Vec3");
    e.prototype = new k;
    e.prototype.constructor = e;
    e.prototype.calculateLocalInertia = function(e, d) {
      d = d || new c;
      e = 2 * e * this.radius * this.radius / 5;
      d.x = e;
      d.y = e;
      d.z = e;
      return d;
    };
    e.prototype.volume = function() {
      return 4 * Math.PI * this.radius / 3;
    };
    e.prototype.updateBoundingSphereRadius = function() {
      this.boundingSphereRadius = this.radius;
    };
    e.prototype.calculateWorldAABB = function(c, e, d, k) {
      e = this.radius;
      for (var b = ["x", "y", "z"], f = 0; f < b.length; f++) {
        var h = b[f];
        d[h] = c[h] - e;
        k[h] = c[h] + e;
      }
    };
  }, {"../math/Vec3":30, "./Shape":43}], 45:[function(d, g, h) {
    function e(b, e) {
      k.call(this);
      this.type = k.types.TRIMESH;
      this.vertices = new Float32Array(b);
      this.indices = new Int16Array(e);
      this.normals = new Float32Array(e.length);
      this.aabb = new t;
      this.edges = null;
      this.scale = new c(1, 1, 1);
      this.tree = new f;
      this.updateEdges();
      this.updateNormals();
      this.updateAABB();
      this.updateBoundingSphereRadius();
      this.updateTree();
    }
    g.exports = e;
    var k = d("./Shape"), c = d("../math/Vec3");
    d("../math/Quaternion");
    var p = d("../math/Transform"), t = d("../collision/AABB"), f = d("../utils/Octree");
    e.prototype = new k;
    e.prototype.constructor = e;
    var n = new c;
    e.prototype.updateTree = function() {
      var b = this.tree;
      b.reset();
      b.aabb.copy(this.aabb);
      var e = this.scale;
      b.aabb.lowerBound.x *= 1 / e.x;
      b.aabb.lowerBound.y *= 1 / e.y;
      b.aabb.lowerBound.z *= 1 / e.z;
      b.aabb.upperBound.x *= 1 / e.x;
      b.aabb.upperBound.y *= 1 / e.y;
      b.aabb.upperBound.z *= 1 / e.z;
      e = new t;
      for (var d = new c, f = new c, k = new c, m = [d, f, k], h = 0; h < this.indices.length / 3; h++) {
        var g = 3 * h;
        this._getUnscaledVertex(this.indices[g], d);
        this._getUnscaledVertex(this.indices[g + 1], f);
        this._getUnscaledVertex(this.indices[g + 2], k);
        e.setFromPoints(m);
        b.insert(e, h);
      }
      b.removeEmptyNodes();
    };
    var b = new t;
    e.prototype.getTrianglesInAABB = function(c, e) {
      b.copy(c);
      var d = this.scale;
      c = d.x;
      var f = d.y;
      d = d.z;
      var k = b.lowerBound, m = b.upperBound;
      k.x /= c;
      k.y /= f;
      k.z /= d;
      m.x /= c;
      m.y /= f;
      m.z /= d;
      return this.tree.aabbQuery(b, e);
    };
    e.prototype.setScale = function(b) {
      var c = b.x === b.y === b.z;
      this.scale.x === this.scale.y === this.scale.z && c || this.updateNormals();
      this.scale.copy(b);
      this.updateAABB();
      this.updateBoundingSphereRadius();
    };
    e.prototype.updateNormals = function() {
      for (var b = this.normals, c = 0; c < this.indices.length / 3; c++) {
        var d = 3 * c, f = this.indices[d + 1], k = this.indices[d + 2];
        this.getVertex(this.indices[d], z);
        this.getVertex(f, r);
        this.getVertex(k, u);
        e.computeNormal(r, z, u, n);
        b[d] = n.x;
        b[d + 1] = n.y;
        b[d + 2] = n.z;
      }
    };
    e.prototype.updateEdges = function() {
      for (var b = {}, c = function(c, e) {
        b[f < k ? f + "_" + k : k + "_" + f] = !0;
      }, e = 0; e < this.indices.length / 3; e++) {
        var d = 3 * e, f = this.indices[d], k = this.indices[d + 1];
        d = this.indices[d + 2];
        c(f, k);
        c(k, d);
        c(d, f);
      }
      c = Object.keys(b);
      this.edges = new Int16Array(2 * c.length);
      for (e = 0; e < c.length; e++) {
        d = c[e].split("_"), this.edges[2 * e] = parseInt(d[0], 10), this.edges[2 * e + 1] = parseInt(d[1], 10);
      }
    };
    e.prototype.getEdgeVertex = function(b, c, e) {
      this.getVertex(this.edges[2 * b + (c ? 1 : 0)], e);
    };
    var m = new c, q = new c;
    e.prototype.getEdgeVector = function(b, c) {
      this.getEdgeVertex(b, 0, m);
      this.getEdgeVertex(b, 1, q);
      q.vsub(m, c);
    };
    var y = new c, x = new c;
    e.computeNormal = function(b, c, e, d) {
      c.vsub(b, x);
      e.vsub(c, y);
      y.cross(x, d);
      d.isZero() || d.normalize();
    };
    var z = new c, r = new c, u = new c;
    e.prototype.getVertex = function(b, c) {
      var e = this.scale;
      this._getUnscaledVertex(b, c);
      c.x *= e.x;
      c.y *= e.y;
      c.z *= e.z;
      return c;
    };
    e.prototype._getUnscaledVertex = function(b, c) {
      b *= 3;
      var e = this.vertices;
      return c.set(e[b], e[b + 1], e[b + 2]);
    };
    e.prototype.getWorldVertex = function(b, c, e, d) {
      this.getVertex(b, d);
      p.pointToWorldFrame(c, e, d, d);
      return d;
    };
    e.prototype.getTriangleVertices = function(b, c, e, d) {
      b *= 3;
      this.getVertex(this.indices[b], c);
      this.getVertex(this.indices[b + 1], e);
      this.getVertex(this.indices[b + 2], d);
    };
    e.prototype.getNormal = function(b, c) {
      b *= 3;
      return c.set(this.normals[b], this.normals[b + 1], this.normals[b + 2]);
    };
    var v = new t;
    e.prototype.calculateLocalInertia = function(b, c) {
      this.computeLocalAABB(v);
      var e = v.upperBound.x - v.lowerBound.x, d = v.upperBound.y - v.lowerBound.y, f = v.upperBound.z - v.lowerBound.z;
      return c.set(1 / 12 * b * (4 * d * d + 4 * f * f), 1 / 12 * b * (4 * e * e + 4 * f * f), 1 / 12 * b * (4 * d * d + 4 * e * e));
    };
    var C = new c;
    e.prototype.computeLocalAABB = function(b) {
      var c = b.lowerBound;
      b = b.upperBound;
      var e = this.vertices.length;
      this.getVertex(0, C);
      c.copy(C);
      b.copy(C);
      for (var d = 0; d !== e; d++) {
        this.getVertex(d, C), C.x < c.x ? c.x = C.x : C.x > b.x && (b.x = C.x), C.y < c.y ? c.y = C.y : C.y > b.y && (b.y = C.y), C.z < c.z ? c.z = C.z : C.z > b.z && (b.z = C.z);
      }
    };
    e.prototype.updateAABB = function() {
      this.computeLocalAABB(this.aabb);
    };
    e.prototype.updateBoundingSphereRadius = function() {
      var b = 0, e = this.vertices, d = new c, f = 0;
      for (e = e.length / 3; f !== e; f++) {
        this.getVertex(f, d);
        var k = d.norm2();
        k > b && (b = k);
      }
      this.boundingSphereRadius = Math.sqrt(b);
    };
    new c;
    var A = new p, D = new t;
    e.prototype.calculateWorldAABB = function(b, c, e, d) {
      A.position = b;
      A.quaternion = c;
      this.aabb.toWorldFrame(A, D);
      e.copy(D.lowerBound);
      d.copy(D.upperBound);
    };
    e.prototype.volume = function() {
      return 4 * Math.PI * this.boundingSphereRadius / 3;
    };
    e.createTorus = function(b, c, d, f, k) {
      b = b || 1;
      c = c || .5;
      d = d || 8;
      f = f || 6;
      k = k || 2 * Math.PI;
      for (var m = [], h = [], g = 0; g <= d; g++) {
        for (var r = 0; r <= f; r++) {
          var n = r / f * k, u = g / d * Math.PI * 2;
          m.push((b + c * Math.cos(u)) * Math.cos(n), (b + c * Math.cos(u)) * Math.sin(n), c * Math.sin(u));
        }
      }
      for (g = 1; g <= d; g++) {
        for (r = 1; r <= f; r++) {
          b = (f + 1) * (g - 1) + r - 1, c = (f + 1) * (g - 1) + r, k = (f + 1) * g + r, h.push((f + 1) * g + r - 1, b, k), h.push(b, c, k);
        }
      }
      return new e(m, h);
    };
  }, {"../collision/AABB":3, "../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "../utils/Octree":50, "./Shape":43}], 46:[function(d, g, h) {
    function e() {
      k.call(this);
      this.iterations = 10;
      this.tolerance = 1E-7;
    }
    g.exports = e;
    d("../math/Vec3");
    d("../math/Quaternion");
    var k = d("./Solver");
    e.prototype = new k;
    var c = [], p = [], t = [];
    e.prototype.solve = function(e, d) {
      var b = 0, f = this.iterations, k = this.tolerance * this.tolerance, h = this.equations, g = h.length;
      d = d.bodies;
      var n = d.length, r;
      if (0 !== g) {
        for (r = 0; r !== n; r++) {
          d[r].updateSolveMassProperties();
        }
      }
      p.length = g;
      t.length = g;
      c.length = g;
      for (r = 0; r !== g; r++) {
        var u = h[r];
        c[r] = 0;
        t[r] = u.computeB(e);
        p[r] = 1 / u.computeC();
      }
      if (0 !== g) {
        for (r = 0; r !== n; r++) {
          u = d[r], b = u.wlambda, u.vlambda.set(0, 0, 0), b && b.set(0, 0, 0);
        }
        for (b = 0; b !== f; b++) {
          for (var v = r = 0; v !== g; v++) {
            u = h[v];
            var C = t[v];
            var A = p[v];
            e = c[v];
            var D = u.computeGWlambda();
            C = A * (C - D - u.eps * e);
            e + C < u.minForce ? C = u.minForce - e : e + C > u.maxForce && (C = u.maxForce - e);
            c[v] += C;
            r += 0 < C ? C : -C;
            u.addToWlambda(C);
          }
          if (r * r < k) {
            break;
          }
        }
        for (r = 0; r !== n; r++) {
          u = d[r], f = u.velocity, k = u.angularVelocity, f.vadd(u.vlambda, f), k && k.vadd(u.wlambda, k);
        }
      }
      return b;
    };
  }, {"../math/Quaternion":28, "../math/Vec3":30, "./Solver":47}], 47:[function(d, g, h) {
    function e() {
      this.equations = [];
    }
    g.exports = e;
    e.prototype.solve = function(e, c) {
      return 0;
    };
    e.prototype.addEquation = function(e) {
      e.enabled && this.equations.push(e);
    };
    e.prototype.removeEquation = function(e) {
      var c = this.equations;
      e = c.indexOf(e);
      -1 !== e && c.splice(e, 1);
    };
    e.prototype.removeAllEquations = function() {
      this.equations.length = 0;
    };
  }, {}], 48:[function(d, g, h) {
    function e(b) {
      t.call(this);
      this.iterations = 10;
      this.tolerance = 1E-7;
      this.subsolver = b;
      this.nodes = [];
      for (this.nodePool = []; 128 > this.nodePool.length;) {
        this.nodePool.push(this.createNode());
      }
    }
    function k(b) {
      for (var c = b.length, e = 0; e !== c; e++) {
        var d = b[e];
        if (!(d.visited || d.body.type & m)) {
          return d;
        }
      }
      return !1;
    }
    function c(b, c, e) {
      c.push(b.body);
      c = b.eqs.length;
      for (var d = 0; d !== c; d++) {
        var f = b.eqs[d];
        -1 === e.indexOf(f) && e.push(f);
      }
    }
    function p(b, c) {
      return c.id - b.id;
    }
    g.exports = e;
    d("../math/Vec3");
    d("../math/Quaternion");
    var t = d("./Solver");
    d = d("../objects/Body");
    e.prototype = new t;
    var f = [], n = [], b = {bodies:[]}, m = d.STATIC, q = [];
    e.prototype.createNode = function() {
      return {body:null, children:[], eqs:[], visited:!1};
    };
    e.prototype.solve = function(e, d) {
      var m = this.nodePool, h = d.bodies, g = this.equations, t = g.length, y = h.length;
      for (d = this.subsolver; m.length < y;) {
        m.push(this.createNode());
      }
      f.length = y;
      for (var x = 0; x < y; x++) {
        f[x] = m[x];
      }
      for (x = 0; x !== y; x++) {
        m = f[x], m.body = h[x], m.children.length = 0, m.eqs.length = 0, m.visited = !1;
      }
      for (m = 0; m !== t; m++) {
        y = g[m];
        x = h.indexOf(y.bi);
        var D = h.indexOf(y.bj);
        x = f[x];
        D = f[D];
        x.children.push(D);
        x.eqs.push(y);
        D.children.push(x);
        D.eqs.push(y);
      }
      h = 0;
      g = n;
      d.tolerance = this.tolerance;
      for (d.iterations = this.iterations; x = k(f);) {
        g.length = 0;
        b.bodies.length = 0;
        y = x;
        x = c;
        t = b.bodies;
        m = g;
        q.push(y);
        y.visited = !0;
        for (x(y, t, m); q.length;) {
          for (y = q.pop(); D = k(y.children);) {
            D.visited = !0, x(D, t, m), q.push(D);
          }
        }
        t = g.length;
        g = g.sort(p);
        for (x = 0; x !== t; x++) {
          d.addEquation(g[x]);
        }
        d.solve(e, b);
        d.removeAllEquations();
        h++;
      }
      return h;
    };
  }, {"../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "./Solver":47}], 49:[function(d, g, h) {
    d = function() {
    };
    g.exports = d;
    d.prototype = {constructor:d, addEventListener:function(e, d) {
      void 0 === this._listeners && (this._listeners = {});
      var c = this._listeners;
      void 0 === c[e] && (c[e] = []);
      -1 === c[e].indexOf(d) && c[e].push(d);
      return this;
    }, hasEventListener:function(e, d) {
      if (void 0 === this._listeners) {
        return !1;
      }
      var c = this._listeners;
      return void 0 !== c[e] && -1 !== c[e].indexOf(d) ? !0 : !1;
    }, removeEventListener:function(e, d) {
      if (void 0 === this._listeners) {
        return this;
      }
      var c = this._listeners;
      if (void 0 === c[e]) {
        return this;
      }
      d = c[e].indexOf(d);
      -1 !== d && c[e].splice(d, 1);
      return this;
    }, dispatchEvent:function(e) {
      if (void 0 === this._listeners) {
        return this;
      }
      var d = this._listeners[e.type];
      if (void 0 !== d) {
        e.target = this;
        for (var c = 0, h = d.length; c < h; c++) {
          d[c].call(this, e);
        }
      }
      return this;
    }};
  }, {}], 50:[function(d, g, h) {
    function e(e) {
      e = e || {};
      this.root = e.root || null;
      this.aabb = e.aabb ? e.aabb.clone() : new c;
      this.data = [];
      this.children = [];
    }
    function k(c, b) {
      b = b || {};
      b.root = null;
      b.aabb = c;
      e.call(this, b);
      this.maxDepth = "undefined" !== typeof b.maxDepth ? b.maxDepth : 8;
    }
    var c = d("../collision/AABB"), p = d("../math/Vec3");
    g.exports = k;
    k.prototype = new e;
    e.prototype.reset = function(c, b) {
      this.children.length = this.data.length = 0;
    };
    e.prototype.insert = function(c, b, e) {
      var d = this.data;
      e = e || 0;
      if (!this.aabb.contains(c)) {
        return !1;
      }
      var f = this.children;
      if (e < (this.maxDepth || this.root.maxDepth)) {
        var k = !1;
        f.length || (this.subdivide(), k = !0);
        for (var m = 0; 8 !== m; m++) {
          if (f[m].insert(c, b, e + 1)) {
            return !0;
          }
        }
        k && (f.length = 0);
      }
      d.push(b);
      return !0;
    };
    var t = new p;
    e.prototype.subdivide = function() {
      var d = this.aabb, b = d.lowerBound, f = d.upperBound;
      d = this.children;
      d.push(new e({aabb:new c({lowerBound:new p(0, 0, 0)})}), new e({aabb:new c({lowerBound:new p(1, 0, 0)})}), new e({aabb:new c({lowerBound:new p(1, 1, 0)})}), new e({aabb:new c({lowerBound:new p(1, 1, 1)})}), new e({aabb:new c({lowerBound:new p(0, 1, 1)})}), new e({aabb:new c({lowerBound:new p(0, 0, 1)})}), new e({aabb:new c({lowerBound:new p(1, 0, 1)})}), new e({aabb:new c({lowerBound:new p(0, 1, 0)})}));
      f.vsub(b, t);
      t.scale(.5, t);
      f = this.root || this;
      for (var k = 0; 8 !== k; k++) {
        var h = d[k];
        h.root = f;
        var g = h.aabb.lowerBound;
        g.x *= t.x;
        g.y *= t.y;
        g.z *= t.z;
        g.vadd(b, g);
        g.vadd(t, h.aabb.upperBound);
      }
    };
    e.prototype.aabbQuery = function(c, b) {
      for (var e = [this]; e.length;) {
        var d = e.pop();
        d.aabb.overlaps(c) && Array.prototype.push.apply(b, d.data);
        Array.prototype.push.apply(e, d.children);
      }
      return b;
    };
    var f = new c;
    e.prototype.rayQuery = function(c, b, e) {
      c.getAABB(f);
      f.toLocalFrame(b, f);
      this.aabbQuery(f, e);
      return e;
    };
    e.prototype.removeEmptyNodes = function() {
      for (var c = [this]; c.length;) {
        for (var b = c.pop(), e = b.children.length - 1; 0 <= e; e--) {
          b.children[e].data.length || b.children.splice(e, 1);
        }
        Array.prototype.push.apply(c, b.children);
      }
    };
  }, {"../collision/AABB":3, "../math/Vec3":30}], 51:[function(d, g, h) {
    function e() {
      this.objects = [];
      this.type = Object;
    }
    g.exports = e;
    e.prototype.release = function() {
      for (var e = arguments.length, c = 0; c !== e; c++) {
        this.objects.push(arguments[c]);
      }
    };
    e.prototype.get = function() {
      return 0 === this.objects.length ? this.constructObject() : this.objects.pop();
    };
    e.prototype.constructObject = function() {
      throw Error("constructObject() not implemented in this Pool subclass yet!");
    };
  }, {}], 52:[function(d, g, h) {
    function e() {
      this.data = {keys:[]};
    }
    g.exports = e;
    e.prototype.get = function(e, c) {
      if (e > c) {
        var d = c;
        c = e;
        e = d;
      }
      return this.data[e + "-" + c];
    };
    e.prototype.set = function(e, c, d) {
      if (e > c) {
        var k = c;
        c = e;
        e = k;
      }
      k = e + "-" + c;
      this.get(e, c) || this.data.keys.push(k);
      this.data[k] = d;
    };
    e.prototype.reset = function() {
      for (var e = this.data, c = e.keys; 0 < c.length;) {
        var d = c.pop();
        delete e[d];
      }
    };
  }, {}], 53:[function(d, g, h) {
    function e() {
    }
    g.exports = e;
    e.defaults = function(e, c) {
      e = e || {};
      for (var d in c) {
        d in e || (e[d] = c[d]);
      }
      return e;
    };
  }, {}], 54:[function(d, g, h) {
    function e() {
      c.call(this);
      this.type = k;
    }
    g.exports = e;
    var k = d("../math/Vec3"), c = d("./Pool");
    e.prototype = new c;
    e.prototype.constructObject = function() {
      return new k;
    };
  }, {"../math/Vec3":30, "./Pool":51}], 55:[function(d, g, h) {
    function e(b) {
      this.contactPointPool = [];
      this.frictionEquationPool = [];
      this.result = [];
      this.frictionResult = [];
      this.v3pool = new f;
      this.world = b;
      this.currentContactMaterial = null;
      this.enableFrictionReduction = !1;
    }
    g.exports = e;
    g = d("../collision/AABB");
    h = d("../shapes/Shape");
    var k = d("../collision/Ray"), c = d("../math/Vec3"), p = d("../math/Transform");
    d("../shapes/ConvexPolyhedron");
    var t = d("../math/Quaternion");
    d("../solver/Solver");
    var f = d("../utils/Vec3Pool"), n = d("../equations/ContactEquation"), b = d("../equations/FrictionEquation");
    e.prototype.createContactEquation = function(b, c, e, d, f, k) {
      if (this.contactPointPool.length) {
        var m = this.contactPointPool.pop();
        m.bi = b;
        m.bj = c;
      } else {
        m = new n(b, c);
      }
      m.enabled = b.collisionResponse && c.collisionResponse && e.collisionResponse && d.collisionResponse;
      var h = this.currentContactMaterial;
      m.restitution = h.restitution;
      m.setSpookParams(h.contactEquationStiffness, h.contactEquationRelaxation, this.world.dt);
      b = e.material || b.material;
      c = d.material || c.material;
      b && c && 0 <= b.restitution && 0 <= c.restitution && (m.restitution = b.restitution * c.restitution);
      m.si = f || e;
      m.sj = k || d;
      return m;
    };
    e.prototype.createFrictionEquationsFromContact = function(c, e) {
      var d = c.bi, f = c.bj, k = this.world, m = this.currentContactMaterial, h = m.friction, g = c.si.material || d.material, r = c.sj.material || f.material;
      g && r && 0 <= g.friction && 0 <= r.friction && (h = g.friction * r.friction);
      if (0 < h) {
        h *= k.gravity.length();
        g = d.invMass + f.invMass;
        0 < g && (g = 1 / g);
        var n = this.frictionEquationPool;
        r = n.length ? n.pop() : new b(d, f, h * g);
        n = n.length ? n.pop() : new b(d, f, h * g);
        r.bi = n.bi = d;
        r.bj = n.bj = f;
        r.minForce = n.minForce = -h * g;
        r.maxForce = n.maxForce = h * g;
        r.ri.copy(c.ri);
        r.rj.copy(c.rj);
        n.ri.copy(c.ri);
        n.rj.copy(c.rj);
        c.ni.tangents(r.t, n.t);
        r.setSpookParams(m.frictionEquationStiffness, m.frictionEquationRelaxation, k.dt);
        n.setSpookParams(m.frictionEquationStiffness, m.frictionEquationRelaxation, k.dt);
        r.enabled = n.enabled = c.enabled;
        e.push(r, n);
        return !0;
      }
      return !1;
    };
    var m = new c, q = new c, y = new c;
    e.prototype.createFrictionFromAverage = function(b) {
      var c = this.result[this.result.length - 1];
      if (this.createFrictionEquationsFromContact(c, this.frictionResult) && 1 !== b) {
        var e = this.frictionResult[this.frictionResult.length - 2], d = this.frictionResult[this.frictionResult.length - 1];
        m.setZero();
        q.setZero();
        y.setZero();
        for (var f = c.bi, k = 0; k !== b; k++) {
          c = this.result[this.result.length - 1 - k], c.bodyA !== f ? (m.vadd(c.ni, m), q.vadd(c.ri, q), y.vadd(c.rj, y)) : (m.vsub(c.ni, m), q.vadd(c.rj, q), y.vadd(c.ri, y));
        }
        b = 1 / b;
        q.scale(b, e.ri);
        y.scale(b, e.rj);
        d.ri.copy(e.ri);
        d.rj.copy(e.rj);
        m.normalize();
        m.tangents(e.t, d.t);
      }
    };
    var x = new c, z = new c, r = new t, u = new t;
    e.prototype.getContacts = function(b, c, e, d, f, k, m) {
      this.contactPointPool = f;
      this.frictionEquationPool = m;
      this.result = d;
      this.frictionResult = k;
      d = 0;
      for (f = b.length; d !== f; d++) {
        k = b[d];
        m = c[d];
        var h = null;
        k.material && m.material && (h = e.getContactMaterial(k.material, m.material) || null);
        for (var g = 0; g < k.shapes.length; g++) {
          k.quaternion.mult(k.shapeOrientations[g], r);
          k.quaternion.vmult(k.shapeOffsets[g], x);
          x.vadd(k.position, x);
          for (var n = k.shapes[g], p = 0; p < m.shapes.length; p++) {
            m.quaternion.mult(m.shapeOrientations[p], u);
            m.quaternion.vmult(m.shapeOffsets[p], z);
            z.vadd(m.position, z);
            var q = m.shapes[p];
            if (!(x.distanceTo(z) > n.boundingSphereRadius + q.boundingSphereRadius)) {
              var t = null;
              n.material && q.material && (t = e.getContactMaterial(n.material, q.material) || null);
              this.currentContactMaterial = t || h || e.defaultContactMaterial;
              (t = this[n.type | q.type]) && (n.type < q.type ? t.call(this, n, q, x, z, r, u, k, m, n, q) : t.call(this, q, n, z, x, u, r, m, k, n, q));
            }
          }
        }
      }
    };
    e.prototype[h.types.BOX | h.types.BOX] = e.prototype.boxBox = function(b, c, e, d, f, k, m, h) {
      b.convexPolyhedronRepresentation.material = b.material;
      c.convexPolyhedronRepresentation.material = c.material;
      b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
      c.convexPolyhedronRepresentation.collisionResponse = c.collisionResponse;
      this.convexConvex(b.convexPolyhedronRepresentation, c.convexPolyhedronRepresentation, e, d, f, k, m, h, b, c);
    };
    e.prototype[h.types.BOX | h.types.CONVEXPOLYHEDRON] = e.prototype.boxConvex = function(b, c, e, d, f, k, m, h) {
      b.convexPolyhedronRepresentation.material = b.material;
      b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
      this.convexConvex(b.convexPolyhedronRepresentation, c, e, d, f, k, m, h, b, c);
    };
    e.prototype[h.types.BOX | h.types.PARTICLE] = e.prototype.boxParticle = function(b, c, e, d, f, k, m, h) {
      b.convexPolyhedronRepresentation.material = b.material;
      b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
      this.convexParticle(b.convexPolyhedronRepresentation, c, e, d, f, k, m, h, b, c);
    };
    e.prototype[h.types.SPHERE] = e.prototype.sphereSphere = function(b, c, e, d, f, k, m, h) {
      f = this.createContactEquation(m, h, b, c);
      d.vsub(e, f.ni);
      f.ni.normalize();
      f.ri.copy(f.ni);
      f.rj.copy(f.ni);
      f.ri.mult(b.radius, f.ri);
      f.rj.mult(-c.radius, f.rj);
      f.ri.vadd(e, f.ri);
      f.ri.vsub(m.position, f.ri);
      f.rj.vadd(d, f.rj);
      f.rj.vsub(h.position, f.rj);
      this.result.push(f);
      this.createFrictionEquationsFromContact(f, this.frictionResult);
    };
    var v = new c, C = new c, A = new c;
    e.prototype[h.types.PLANE | h.types.TRIMESH] = e.prototype.planeTrimesh = function(b, e, d, f, k, m, h, g) {
      var r = new c;
      v.set(0, 0, 1);
      k.vmult(v, v);
      for (k = 0; k < e.vertices.length / 3; k++) {
        e.getVertex(k, r);
        var n = new c;
        n.copy(r);
        p.pointToWorldFrame(f, m, n, r);
        n = C;
        r.vsub(d, n);
        if (0 >= v.dot(n)) {
          var u = this.createContactEquation(h, g, b, e);
          u.ni.copy(v);
          var q = A;
          v.scale(n.dot(v), q);
          r.vsub(q, q);
          u.ri.copy(q);
          u.ri.vsub(h.position, u.ri);
          u.rj.copy(r);
          u.rj.vsub(g.position, u.rj);
          this.result.push(u);
          this.createFrictionEquationsFromContact(u, this.frictionResult);
        }
      }
    };
    var D = new c, F = new c;
    new c;
    var B = new c, E = new c, H = new c, L = new c, K = new c, P = new c, J = new c, I = new c, N = new c, S = new c, Q = new c, Z = new g, R = [];
    e.prototype[h.types.SPHERE | h.types.TRIMESH] = e.prototype.sphereTrimesh = function(b, c, e, d, f, m, h, g) {
      p.pointToLocalFrame(d, m, e, J);
      f = b.radius;
      Z.lowerBound.set(J.x - f, J.y - f, J.z - f);
      Z.upperBound.set(J.x + f, J.y + f, J.z + f);
      c.getTrianglesInAABB(Z, R);
      var r = b.radius * b.radius;
      for (f = 0; f < R.length; f++) {
        for (var n = 0; 3 > n; n++) {
          if (c.getVertex(c.indices[3 * R[f] + n], B), B.vsub(J, F), F.norm2() <= r) {
            E.copy(B);
            p.pointToWorldFrame(d, m, E, B);
            B.vsub(e, F);
            var u = this.createContactEquation(h, g, b, c);
            u.ni.copy(F);
            u.ni.normalize();
            u.ri.copy(u.ni);
            u.ri.scale(b.radius, u.ri);
            u.ri.vadd(e, u.ri);
            u.ri.vsub(h.position, u.ri);
            u.rj.copy(B);
            u.rj.vsub(g.position, u.rj);
            this.result.push(u);
            this.createFrictionEquationsFromContact(u, this.frictionResult);
          }
        }
      }
      for (f = 0; f < R.length; f++) {
        for (n = 0; 3 > n; n++) {
          c.getVertex(c.indices[3 * R[f] + n], H), c.getVertex(c.indices[3 * R[f] + (n + 1) % 3], L), L.vsub(H, K), J.vsub(L, I), e = I.dot(K), J.vsub(H, I), u = I.dot(K), 0 < u && 0 > e && (J.vsub(H, I), P.copy(K), P.normalize(), u = I.dot(P), P.scale(u, I), I.vadd(H, I), e = I.distanceTo(J), e < b.radius && (u = this.createContactEquation(h, g, b, c), I.vsub(J, u.ni), u.ni.normalize(), u.ni.scale(b.radius, u.ri), p.pointToWorldFrame(d, m, I, I), I.vsub(g.position, u.rj), p.vectorToWorldFrame(m, 
          u.ni, u.ni), p.vectorToWorldFrame(m, u.ri, u.ri), this.result.push(u), this.createFrictionEquationsFromContact(u, this.frictionResult)));
        }
      }
      f = 0;
      for (n = R.length; f !== n; f++) {
        c.getTriangleVertices(R[f], N, S, Q), c.getNormal(R[f], D), J.vsub(N, I), e = I.dot(D), D.scale(e, I), J.vsub(I, I), e = I.distanceTo(J), k.pointInTriangle(I, N, S, Q) && e < b.radius && (u = this.createContactEquation(h, g, b, c), I.vsub(J, u.ni), u.ni.normalize(), u.ni.scale(b.radius, u.ri), p.pointToWorldFrame(d, m, I, I), I.vsub(g.position, u.rj), p.vectorToWorldFrame(m, u.ni, u.ni), p.vectorToWorldFrame(m, u.ri, u.ri), this.result.push(u), this.createFrictionEquationsFromContact(u, this.frictionResult));
      }
      R.length = 0;
    };
    var W = new c, O = new c;
    e.prototype[h.types.SPHERE | h.types.PLANE] = e.prototype.spherePlane = function(b, c, e, d, f, k, m, h) {
      c = this.createContactEquation(m, h, b, c);
      c.ni.set(0, 0, 1);
      k.vmult(c.ni, c.ni);
      c.ni.negate(c.ni);
      c.ni.normalize();
      c.ni.mult(b.radius, c.ri);
      e.vsub(d, W);
      c.ni.mult(c.ni.dot(W), O);
      W.vsub(O, c.rj);
      -W.dot(c.ni) <= b.radius && (b = c.ri, k = c.rj, b.vadd(e, b), b.vsub(m.position, b), k.vadd(d, k), k.vsub(h.position, k), this.result.push(c), this.createFrictionEquationsFromContact(c, this.frictionResult));
    };
    var ca = new c, M = new c, V = new c, fa = new c, ja = new c, X = new c, ea = new c, Y = [new c, new c, new c, new c, new c, new c], T = new c, ma = new c, ka = new c, ua = new c;
    e.prototype[h.types.SPHERE | h.types.BOX] = e.prototype.sphereBox = function(b, c, e, d, f, k, m, h) {
      f = this.v3pool;
      e.vsub(d, fa);
      c.getSideNormals(Y, k);
      k = b.radius;
      for (var g = !1, r = null, n = 0, u = 0, p = 0, q = null, t = 0, v = Y.length; t !== v && !1 === g; t++) {
        var y = ja;
        y.copy(Y[t]);
        var x = y.norm();
        y.normalize();
        var C = fa.dot(y);
        if (C < x + k && 0 < C) {
          var A = X, z = ea;
          A.copy(Y[(t + 1) % 3]);
          z.copy(Y[(t + 2) % 3]);
          var B = A.norm(), D = z.norm();
          A.normalize();
          z.normalize();
          var F = fa.dot(A), J = fa.dot(z);
          F < B && F > -B && J < D && J > -D && (C = Math.abs(C - x - k), null === q || C < q) && (q = C, u = F, p = J, r = x, ma.copy(y), ka.copy(A), ua.copy(z), n++);
        }
      }
      n && (g = !0, n = this.createContactEquation(m, h, b, c), ma.mult(-k, n.ri), n.ni.copy(ma), n.ni.negate(n.ni), ma.mult(r, ma), ka.mult(u, ka), ma.vadd(ka, ma), ua.mult(p, ua), ma.vadd(ua, n.rj), n.ri.vadd(e, n.ri), n.ri.vsub(m.position, n.ri), n.rj.vadd(d, n.rj), n.rj.vsub(h.position, n.rj), this.result.push(n), this.createFrictionEquationsFromContact(n, this.frictionResult));
      C = f.get();
      for (r = 0; 2 !== r && !g; r++) {
        for (u = 0; 2 !== u && !g; u++) {
          for (p = 0; 2 !== p && !g; p++) {
            C.set(0, 0, 0), r ? C.vadd(Y[0], C) : C.vsub(Y[0], C), u ? C.vadd(Y[1], C) : C.vsub(Y[1], C), p ? C.vadd(Y[2], C) : C.vsub(Y[2], C), d.vadd(C, T), T.vsub(e, T), T.norm2() < k * k && (g = !0, n = this.createContactEquation(m, h, b, c), n.ri.copy(T), n.ri.normalize(), n.ni.copy(n.ri), n.ri.mult(k, n.ri), n.rj.copy(C), n.ri.vadd(e, n.ri), n.ri.vsub(m.position, n.ri), n.rj.vadd(d, n.rj), n.rj.vsub(h.position, n.rj), this.result.push(n), this.createFrictionEquationsFromContact(n, this.frictionResult));
          }
        }
      }
      f.release(C);
      q = f.get();
      t = f.get();
      n = f.get();
      v = f.get();
      C = f.get();
      y = Y.length;
      for (r = 0; r !== y && !g; r++) {
        for (u = 0; u !== y && !g; u++) {
          if (r % 3 !== u % 3) {
            Y[u].cross(Y[r], q);
            q.normalize();
            Y[r].vadd(Y[u], t);
            n.copy(e);
            n.vsub(t, n);
            n.vsub(d, n);
            x = n.dot(q);
            q.mult(x, v);
            for (p = 0; p === r % 3 || p === u % 3;) {
              p++;
            }
            C.copy(e);
            C.vsub(v, C);
            C.vsub(t, C);
            C.vsub(d, C);
            x = Math.abs(x);
            A = C.norm();
            x < Y[p].norm() && A < k && (g = !0, p = this.createContactEquation(m, h, b, c), t.vadd(v, p.rj), p.rj.copy(p.rj), C.negate(p.ni), p.ni.normalize(), p.ri.copy(p.rj), p.ri.vadd(d, p.ri), p.ri.vsub(e, p.ri), p.ri.normalize(), p.ri.mult(k, p.ri), p.ri.vadd(e, p.ri), p.ri.vsub(m.position, p.ri), p.rj.vadd(d, p.rj), p.rj.vsub(h.position, p.rj), this.result.push(p), this.createFrictionEquationsFromContact(p, this.frictionResult));
          }
        }
      }
      f.release(q, t, n, v, C);
    };
    var Aa = new c, Ia = new c, Ga = new c, sa = new c, Qb = new c, va = new c, xa = new c, gc = new c, Xd = new c, yc = new c;
    e.prototype[h.types.SPHERE | h.types.CONVEXPOLYHEDRON] = e.prototype.sphereConvex = function(b, c, e, d, f, k, m, h) {
      f = this.v3pool;
      e.vsub(d, Aa);
      for (var g = c.faceNormals, r = c.faces, n = c.vertices, u = b.radius, p = 0; p !== n.length; p++) {
        var q = Qb;
        k.vmult(n[p], q);
        d.vadd(q, q);
        var t = sa;
        q.vsub(e, t);
        if (t.norm2() < u * u) {
          b = this.createContactEquation(m, h, b, c);
          b.ri.copy(t);
          b.ri.normalize();
          b.ni.copy(b.ri);
          b.ri.mult(u, b.ri);
          q.vsub(d, b.rj);
          b.ri.vadd(e, b.ri);
          b.ri.vsub(m.position, b.ri);
          b.rj.vadd(d, b.rj);
          b.rj.vsub(h.position, b.rj);
          this.result.push(b);
          this.createFrictionEquationsFromContact(b, this.frictionResult);
          return;
        }
      }
      p = 0;
      for (q = r.length; p !== q; p++) {
        t = r[p];
        var v = va;
        k.vmult(g[p], v);
        var y = xa;
        k.vmult(n[t[0]], y);
        y.vadd(d, y);
        var x = gc;
        v.mult(-u, x);
        e.vadd(x, x);
        var C = Xd;
        x.vsub(y, C);
        x = C.dot(v);
        C = yc;
        e.vsub(y, C);
        if (0 > x && 0 < C.dot(v)) {
          y = [];
          C = 0;
          for (var A = t.length; C !== A; C++) {
            var z = f.get();
            k.vmult(n[t[C]], z);
            d.vadd(z, z);
            y.push(z);
          }
          a: {
            C = y;
            A = v;
            z = e;
            for (var B = null, D = C.length, F = 0; F !== D; F++) {
              var J = C[F], E = ca;
              C[(F + 1) % D].vsub(J, E);
              var I = M;
              E.cross(A, I);
              E = V;
              z.vsub(J, E);
              J = I.dot(E);
              if (null === B || 0 < J && !0 === B || 0 >= J && !1 === B) {
                null === B && (B = 0 < J);
              } else {
                C = !1;
                break a;
              }
            }
            C = !0;
          }
          if (C) {
            b = this.createContactEquation(m, h, b, c);
            v.mult(-u, b.ri);
            v.negate(b.ni);
            c = f.get();
            v.mult(-x, c);
            k = f.get();
            v.mult(-u, k);
            e.vsub(d, b.rj);
            b.rj.vadd(k, b.rj);
            b.rj.vadd(c, b.rj);
            b.rj.vadd(d, b.rj);
            b.rj.vsub(h.position, b.rj);
            b.ri.vadd(e, b.ri);
            b.ri.vsub(m.position, b.ri);
            f.release(c);
            f.release(k);
            this.result.push(b);
            this.createFrictionEquationsFromContact(b, this.frictionResult);
            C = 0;
            for (t = y.length; C !== t; C++) {
              f.release(y[C]);
            }
            break;
          } else {
            for (C = 0; C !== t.length; C++) {
              v = f.get();
              x = f.get();
              k.vmult(n[t[(C + 1) % t.length]], v);
              k.vmult(n[t[(C + 2) % t.length]], x);
              d.vadd(v, v);
              d.vadd(x, x);
              D = Ia;
              x.vsub(v, D);
              B = Ga;
              D.unit(B);
              A = f.get();
              z = f.get();
              e.vsub(v, z);
              F = z.dot(B);
              B.mult(F, A);
              A.vadd(v, A);
              B = f.get();
              A.vsub(e, B);
              if (0 < F && F * F < D.norm2() && B.norm2() < u * u) {
                b = this.createContactEquation(m, h, b, c);
                A.vsub(d, b.rj);
                A.vsub(e, b.ni);
                b.ni.normalize();
                b.ni.mult(u, b.ri);
                b.rj.vadd(d, b.rj);
                b.rj.vsub(h.position, b.rj);
                b.ri.vadd(e, b.ri);
                b.ri.vsub(m.position, b.ri);
                this.result.push(b);
                this.createFrictionEquationsFromContact(b, this.frictionResult);
                C = 0;
                for (t = y.length; C !== t; C++) {
                  f.release(y[C]);
                }
                f.release(v);
                f.release(x);
                f.release(A);
                f.release(B);
                f.release(z);
                return;
              }
              f.release(v);
              f.release(x);
              f.release(A);
              f.release(B);
              f.release(z);
            }
          }
          C = 0;
          for (t = y.length; C !== t; C++) {
            f.release(y[C]);
          }
        }
      }
    };
    new c;
    new c;
    e.prototype[h.types.PLANE | h.types.BOX] = e.prototype.planeBox = function(b, c, e, d, f, k, m, h) {
      c.convexPolyhedronRepresentation.material = c.material;
      c.convexPolyhedronRepresentation.collisionResponse = c.collisionResponse;
      this.planeConvex(b, c.convexPolyhedronRepresentation, e, d, f, k, m, h);
    };
    var Va = new c, nb = new c, zc = new c, Bb = new c;
    e.prototype[h.types.PLANE | h.types.CONVEXPOLYHEDRON] = e.prototype.planeConvex = function(b, c, e, d, f, k, m, h) {
      nb.set(0, 0, 1);
      f.vmult(nb, nb);
      for (var g = f = 0; g !== c.vertices.length; g++) {
        if (Va.copy(c.vertices[g]), k.vmult(Va, Va), d.vadd(Va, Va), Va.vsub(e, zc), 0 >= nb.dot(zc)) {
          var r = this.createContactEquation(m, h, b, c), n = Bb;
          nb.mult(nb.dot(zc), n);
          Va.vsub(n, n);
          n.vsub(e, r.ri);
          r.ni.copy(nb);
          Va.vsub(d, r.rj);
          r.ri.vadd(e, r.ri);
          r.ri.vsub(m.position, r.ri);
          r.rj.vadd(d, r.rj);
          r.rj.vsub(h.position, r.rj);
          this.result.push(r);
          f++;
          this.enableFrictionReduction || this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }
      this.enableFrictionReduction && f && this.createFrictionFromAverage(f);
    };
    var Rb = new c, Cb = new c;
    e.prototype[h.types.CONVEXPOLYHEDRON] = e.prototype.convexConvex = function(b, c, e, d, f, k, m, h, g, r, n, u) {
      if (!(e.distanceTo(d) > b.boundingSphereRadius + c.boundingSphereRadius) && b.findSeparatingAxis(c, e, f, d, k, Rb, n, u)) {
        n = [];
        b.clipAgainstHull(e, f, c, d, k, Rb, -100, 100, n);
        for (k = f = 0; k !== n.length; k++) {
          u = this.createContactEquation(m, h, b, c, g, r);
          var p = u.ri, q = u.rj;
          Rb.negate(u.ni);
          n[k].normal.negate(Cb);
          Cb.mult(n[k].depth, Cb);
          n[k].point.vadd(Cb, p);
          q.copy(n[k].point);
          p.vsub(e, p);
          q.vsub(d, q);
          p.vadd(e, p);
          p.vsub(m.position, p);
          q.vadd(d, q);
          q.vsub(h.position, q);
          this.result.push(u);
          f++;
          this.enableFrictionReduction || this.createFrictionEquationsFromContact(u, this.frictionResult);
        }
        this.enableFrictionReduction && f && this.createFrictionFromAverage(f);
      }
    };
    var gb = new c, Ac = new c, Sa = new c;
    e.prototype[h.types.PLANE | h.types.PARTICLE] = e.prototype.planeParticle = function(b, c, e, d, f, k, m, h) {
      gb.set(0, 0, 1);
      m.quaternion.vmult(gb, gb);
      d.vsub(m.position, Ac);
      0 >= gb.dot(Ac) && (b = this.createContactEquation(h, m, c, b), b.ni.copy(gb), b.ni.negate(b.ni), b.ri.set(0, 0, 0), gb.mult(gb.dot(d), Sa), d.vsub(Sa, Sa), b.rj.copy(Sa), this.result.push(b), this.createFrictionEquationsFromContact(b, this.frictionResult));
    };
    var za = new c;
    e.prototype[h.types.PARTICLE | h.types.SPHERE] = e.prototype.sphereParticle = function(b, c, e, d, f, k, m, h) {
      za.set(0, 0, 1);
      d.vsub(e, za);
      za.norm2() <= b.radius * b.radius && (c = this.createContactEquation(h, m, c, b), za.normalize(), c.rj.copy(za), c.rj.mult(b.radius, c.rj), c.ni.copy(za), c.ni.negate(c.ni), c.ri.set(0, 0, 0), this.result.push(c), this.createFrictionEquationsFromContact(c, this.frictionResult));
    };
    var hb = new t, Oa = new c;
    new c;
    var La = new c, Ma = new c, ib = new c;
    e.prototype[h.types.PARTICLE | h.types.CONVEXPOLYHEDRON] = e.prototype.convexParticle = function(b, c, e, d, f, k, m, h) {
      var g = -1;
      k = null;
      var r = 0;
      Oa.copy(d);
      Oa.vsub(e, Oa);
      f.conjugate(hb);
      hb.vmult(Oa, Oa);
      if (b.pointIsInside(Oa)) {
        b.worldVerticesNeedsUpdate && b.computeWorldVertices(e, f);
        b.worldFaceNormalsNeedsUpdate && b.computeWorldFaceNormals(f);
        f = 0;
        for (var n = b.faces.length; f !== n; f++) {
          var u = b.worldFaceNormals[f];
          d.vsub(b.worldVertices[b.faces[f][0]], Ma);
          var p = -u.dot(Ma);
          if (null === k || Math.abs(p) < Math.abs(k)) {
            k = p, g = f, La.copy(u), r++;
          }
        }
        -1 !== g ? (b = this.createContactEquation(h, m, c, b), La.mult(k, ib), ib.vadd(d, ib), ib.vsub(e, ib), b.rj.copy(ib), La.negate(b.ni), b.ri.set(0, 0, 0), c = b.ri, k = b.rj, c.vadd(d, c), c.vsub(h.position, c), k.vadd(e, k), k.vsub(m.position, k), this.result.push(b), this.createFrictionEquationsFromContact(b, this.frictionResult)) : console.warn("Point found inside convex, but did not find penetrating face!");
      }
    };
    e.prototype[h.types.BOX | h.types.HEIGHTFIELD] = e.prototype.boxHeightfield = function(b, c, e, d, f, k, m, h) {
      b.convexPolyhedronRepresentation.material = b.material;
      b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
      this.convexHeightfield(b.convexPolyhedronRepresentation, c, e, d, f, k, m, h);
    };
    var ob = new c, ab = new c, Bc = [0];
    e.prototype[h.types.CONVEXPOLYHEDRON | h.types.HEIGHTFIELD] = e.prototype.convexHeightfield = function(b, c, e, d, f, k, m, h) {
      var g = c.data, r = c.elementSize, n = b.boundingSphereRadius;
      p.pointToLocalFrame(d, k, e, ob);
      var u = Math.floor((ob.x - n) / r) - 1, q = Math.ceil((ob.x + n) / r) + 1, t = Math.floor((ob.y - n) / r) - 1;
      r = Math.ceil((ob.y + n) / r) + 1;
      if (!(0 > q || 0 > r || u > g.length || t > g[0].length)) {
        0 > u && (u = 0);
        0 > q && (q = 0);
        0 > t && (t = 0);
        0 > r && (r = 0);
        u >= g.length && (u = g.length - 1);
        q >= g.length && (q = g.length - 1);
        r >= g[0].length && (r = g[0].length - 1);
        t >= g[0].length && (t = g[0].length - 1);
        g = [];
        c.getRectMinMax(u, t, q, r, g);
        var v = g[0];
        if (!(ob.z - n > g[1] || ob.z + n < v)) {
          for (n = u; n < q; n++) {
            for (u = t; u < r; u++) {
              c.getConvexTrianglePillar(n, u, !1), p.pointToWorldFrame(d, k, c.pillarOffset, ab), e.distanceTo(ab) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.convexConvex(b, c.pillarConvex, e, ab, f, k, m, h, null, null, Bc, null), c.getConvexTrianglePillar(n, u, !0), p.pointToWorldFrame(d, k, c.pillarOffset, ab), e.distanceTo(ab) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.convexConvex(b, c.pillarConvex, e, ab, f, k, m, h, null, null, Bc, null);
            }
          }
        }
      }
    };
    var pb = new c, Db = new c;
    e.prototype[h.types.SPHERE | h.types.HEIGHTFIELD] = e.prototype.sphereHeightfield = function(b, c, e, d, f, k, m, h) {
      var g = c.data, r = b.radius, n = c.elementSize;
      p.pointToLocalFrame(d, k, e, pb);
      var u = Math.floor((pb.x - r) / n) - 1, q = Math.ceil((pb.x + r) / n) + 1, t = Math.floor((pb.y - r) / n) - 1;
      n = Math.ceil((pb.y + r) / n) + 1;
      if (!(0 > q || 0 > n || u > g.length || n > g[0].length)) {
        0 > u && (u = 0);
        0 > q && (q = 0);
        0 > t && (t = 0);
        0 > n && (n = 0);
        u >= g.length && (u = g.length - 1);
        q >= g.length && (q = g.length - 1);
        n >= g[0].length && (n = g[0].length - 1);
        t >= g[0].length && (t = g[0].length - 1);
        g = [];
        c.getRectMinMax(u, t, q, n, g);
        var v = g[0];
        if (!(pb.z - r > g[1] || pb.z + r < v)) {
          for (r = this.result; u < q; u++) {
            for (g = t; g < n; g++) {
              if (v = r.length, c.getConvexTrianglePillar(u, g, !1), p.pointToWorldFrame(d, k, c.pillarOffset, Db), e.distanceTo(Db) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.sphereConvex(b, c.pillarConvex, e, Db, f, k, m, h), c.getConvexTrianglePillar(u, g, !0), p.pointToWorldFrame(d, k, c.pillarOffset, Db), e.distanceTo(Db) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.sphereConvex(b, c.pillarConvex, e, Db, f, k, m, h), 2 < r.length - v) {
                return;
              }
            }
          }
        }
      }
    };
  }, {"../collision/AABB":3, "../collision/Ray":9, "../equations/ContactEquation":19, "../equations/FrictionEquation":21, "../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "../shapes/ConvexPolyhedron":38, "../shapes/Shape":43, "../solver/Solver":47, "../utils/Vec3Pool":54}], 56:[function(d, g, h) {
    function e() {
      t.apply(this);
      this.dt = -1;
      this.allowSleep = !1;
      this.contacts = [];
      this.frictionEquations = [];
      this.quatNormalizeSkip = 0;
      this.quatNormalizeFast = !1;
      this.stepnumber = this.time = 0;
      this.default_dt = 1 / 60;
      this.nextId = 0;
      this.gravity = new k;
      this.broadphase = new z;
      this.bodies = [];
      this.solver = new c;
      this.constraints = [];
      this.narrowphase = new p(this);
      this.collisionMatrix = new f;
      this.collisionMatrixPrevious = new f;
      this.materials = [];
      this.contactmaterials = [];
      this.contactMaterialTable = new q;
      this.defaultMaterial = new n("default");
      this.defaultContactMaterial = new b(this.defaultMaterial, this.defaultMaterial, {friction:.3, restitution:0});
      this.doProfiling = !1;
      this.profile = {solve:0, makeContactConstraints:0, broadphase:0, integrate:0, narrowphase:0};
      this.subsystems = [];
      this.addBodyEvent = {type:"addBody", body:null};
      this.removeBodyEvent = {type:"removeBody", body:null};
    }
    g.exports = e;
    d("../shapes/Shape");
    var k = d("../math/Vec3");
    g = d("../math/Quaternion");
    var c = d("../solver/GSSolver");
    d("../utils/Vec3Pool");
    d("../equations/ContactEquation");
    d("../equations/FrictionEquation");
    var p = d("./Narrowphase"), t = d("../utils/EventTarget"), f = d("../collision/ArrayCollisionMatrix"), n = d("../material/Material"), b = d("../material/ContactMaterial"), m = d("../objects/Body"), q = d("../utils/TupleDictionary"), y = d("../collision/RaycastResult");
    h = d("../collision/AABB");
    var x = d("../collision/Ray"), z = d("../collision/NaiveBroadphase");
    e.prototype = new t;
    new h;
    var r = new x;
    e.prototype.getContactMaterial = function(b, c) {
      return this.contactMaterialTable.get(b.id, c.id);
    };
    e.prototype.numObjects = function() {
      return this.bodies.length;
    };
    e.prototype.collisionMatrixTick = function() {
      var b = this.collisionMatrixPrevious;
      this.collisionMatrixPrevious = this.collisionMatrix;
      this.collisionMatrix = b;
      this.collisionMatrix.reset();
    };
    e.prototype.add = e.prototype.addBody = function(b) {
      -1 === this.bodies.indexOf(b) && (b.index = this.bodies.length, this.bodies.push(b), b.world = this, b.initPosition.copy(b.position), b.initVelocity.copy(b.velocity), b.timeLastSleepy = this.time, b instanceof m && (b.initAngularVelocity.copy(b.angularVelocity), b.initQuaternion.copy(b.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), this.addBodyEvent.body = b, this.dispatchEvent(this.addBodyEvent));
    };
    e.prototype.addConstraint = function(b) {
      this.constraints.push(b);
    };
    e.prototype.removeConstraint = function(b) {
      b = this.constraints.indexOf(b);
      -1 !== b && this.constraints.splice(b, 1);
    };
    e.prototype.rayTest = function(b, c, e) {
      e instanceof y ? this.raycastClosest(b, c, {skipBackfaces:!0}, e) : this.raycastAll(b, c, {skipBackfaces:!0}, e);
    };
    e.prototype.raycastAll = function(b, c, e, d) {
      e.mode = x.ALL;
      e.from = b;
      e.to = c;
      e.callback = d;
      return r.intersectWorld(this, e);
    };
    e.prototype.raycastAny = function(b, c, e, d) {
      e.mode = x.ANY;
      e.from = b;
      e.to = c;
      e.result = d;
      return r.intersectWorld(this, e);
    };
    e.prototype.raycastClosest = function(b, c, e, d) {
      e.mode = x.CLOSEST;
      e.from = b;
      e.to = c;
      e.result = d;
      return r.intersectWorld(this, e);
    };
    e.prototype.remove = function(b) {
      b.world = null;
      var c = this.bodies.length - 1, e = this.bodies, d = e.indexOf(b);
      if (-1 !== d) {
        e.splice(d, 1);
        for (d = 0; d !== e.length; d++) {
          e[d].index = d;
        }
        this.collisionMatrix.setNumObjects(c);
        this.removeBodyEvent.body = b;
        this.dispatchEvent(this.removeBodyEvent);
      }
    };
    e.prototype.removeBody = e.prototype.remove;
    e.prototype.addMaterial = function(b) {
      this.materials.push(b);
    };
    e.prototype.addContactMaterial = function(b) {
      this.contactmaterials.push(b);
      this.contactMaterialTable.set(b.materials[0].id, b.materials[1].id, b);
    };
    "undefined" === typeof performance && (performance = {});
    if (!performance.now) {
      var u = Date.now();
      performance.timing && performance.timing.navigationStart && (u = performance.timing.navigationStart);
      performance.now = function() {
        return Date.now() - u;
      };
    }
    var v = new k;
    e.prototype.step = function(b, c, e) {
      e = e || 10;
      c = c || 0;
      if (0 === c) {
        this.internalStep(b), this.time += b;
      } else {
        var d = Math.floor((this.time + c) / b) - Math.floor(this.time / b);
        d = Math.min(d, e);
        e = performance.now();
        for (var f = 0; f !== d && !(this.internalStep(b), performance.now() - e > 1E3 * b); f++) {
        }
        this.time += c;
        b = this.time % b / b;
        c = this.bodies;
        for (d = 0; d !== c.length; d++) {
          e = c[d], e.type !== m.STATIC && e.sleepState !== m.SLEEPING ? (e.position.vsub(e.previousPosition, v), v.scale(b, v), e.position.vadd(v, e.interpolatedPosition)) : (e.interpolatedPosition.copy(e.position), e.interpolatedQuaternion.copy(e.quaternion));
        }
      }
    };
    var C = {type:"postStep"}, A = {type:"preStep"}, D = {type:"collide", body:null, contact:null}, F = [], B = [], E = [], H = [];
    new k;
    new k;
    new k;
    new k;
    new k;
    new k;
    new k;
    new k;
    new k;
    new g;
    var L = new g, K = new g, P = new k;
    e.prototype.internalStep = function(b) {
      this.dt = b;
      var c = this.contacts, e = this.numObjects(), d = this.bodies, f = this.solver, k = this.gravity, h = this.doProfiling, g = this.profile, r = m.DYNAMIC, n, u = this.constraints;
      k.norm();
      var p = k.x, q = k.y, t = k.z;
      h && (n = performance.now());
      for (k = 0; k !== e; k++) {
        var v = d[k];
        if (v.type & r) {
          var y = v.force;
          v = v.mass;
          y.x += v * p;
          y.y += v * q;
          y.z += v * t;
        }
      }
      k = 0;
      for (v = this.subsystems.length; k !== v; k++) {
        this.subsystems[k].update();
      }
      h && (n = performance.now());
      E.length = 0;
      H.length = 0;
      this.broadphase.collisionPairs(this, E, H);
      h && (g.broadphase = performance.now() - n);
      v = u.length;
      for (k = 0; k !== v; k++) {
        if (p = u[k], !p.collideConnected) {
          for (q = E.length - 1; 0 <= q; --q) {
            if (p.bodyA === E[q] && p.bodyB === H[q] || p.bodyB === E[q] && p.bodyA === H[q]) {
              E.splice(q, 1), H.splice(q, 1);
            }
          }
        }
      }
      this.collisionMatrixTick();
      h && (n = performance.now());
      v = c.length;
      for (k = 0; k !== v; k++) {
        F.push(c[k]);
      }
      c.length = 0;
      v = this.frictionEquations.length;
      for (k = 0; k !== v; k++) {
        B.push(this.frictionEquations[k]);
      }
      this.frictionEquations.length = 0;
      this.narrowphase.getContacts(E, H, this, c, F, this.frictionEquations, B);
      h && (g.narrowphase = performance.now() - n);
      h && (n = performance.now());
      for (k = 0; k < this.frictionEquations.length; k++) {
        f.addEquation(this.frictionEquations[k]);
      }
      k = c.length;
      for (q = 0; q !== k; q++) {
        p = c[q], v = p.bi, t = p.bj, v.material && t.material && this.getContactMaterial(v.material, t.material), v.material && t.material && 0 <= v.material.restitution && 0 <= t.material.restitution && (p.restitution = v.material.restitution * t.material.restitution), f.addEquation(p), v.allowSleep && v.type === m.DYNAMIC && v.sleepState === m.SLEEPING && t.sleepState === m.AWAKE && t.type !== m.STATIC && t.velocity.norm2() + t.angularVelocity.norm2() >= 2 * Math.pow(t.sleepSpeedLimit, 2) && (v._wakeUpAfterNarrowphase = 
        !0), t.allowSleep && t.type === m.DYNAMIC && t.sleepState === m.SLEEPING && v.sleepState === m.AWAKE && v.type !== m.STATIC && v.velocity.norm2() + v.angularVelocity.norm2() >= 2 * Math.pow(v.sleepSpeedLimit, 2) && (t._wakeUpAfterNarrowphase = !0), this.collisionMatrix.set(v, t, !0), this.collisionMatrixPrevious.get(v, t) || (D.body = t, D.contact = p, v.dispatchEvent(D), D.body = v, t.dispatchEvent(D));
      }
      h && (g.makeContactConstraints = performance.now() - n, n = performance.now());
      for (k = 0; k !== e; k++) {
        v = d[k], v._wakeUpAfterNarrowphase && (v.wakeUp(), v._wakeUpAfterNarrowphase = !1);
      }
      v = u.length;
      for (k = 0; k !== v; k++) {
        for (p = u[k], p.update(), q = 0, c = p.equations.length; q !== c; q++) {
          f.addEquation(p.equations[q]);
        }
      }
      f.solve(b, this);
      h && (g.solve = performance.now() - n);
      f.removeAllEquations();
      f = Math.pow;
      for (k = 0; k !== e; k++) {
        if (v = d[k], v.type & r && (u = f(1 - v.linearDamping, b), c = v.velocity, c.mult(u, c), u = v.angularVelocity)) {
          c = f(1 - v.angularDamping, b), u.mult(c, u);
        }
      }
      this.dispatchEvent(A);
      for (k = 0; k !== e; k++) {
        v = d[k], v.preStep && v.preStep.call(v);
      }
      h && (n = performance.now());
      r = m.DYNAMIC | m.KINEMATIC;
      f = 0 === this.stepnumber % (this.quatNormalizeSkip + 1);
      u = this.quatNormalizeFast;
      c = .5 * b;
      for (k = 0; k !== e; k++) {
        if (v = d[k], p = v.force, q = v.torque, v.type & r && v.sleepState !== m.SLEEPING) {
          t = v.velocity;
          y = v.angularVelocity;
          var x = v.position, z = v.quaternion, J = v.invMass, ka = v.invInertiaWorld;
          t.x += p.x * J * b;
          t.y += p.y * J * b;
          t.z += p.z * J * b;
          v.angularVelocity && (ka.vmult(q, P), P.mult(b, P), P.vadd(y, y));
          x.x += t.x * b;
          x.y += t.y * b;
          x.z += t.z * b;
          v.angularVelocity && (L.set(y.x, y.y, y.z, 0), L.mult(z, K), z.x += c * K.x, z.y += c * K.y, z.z += c * K.z, z.w += c * K.w, f && (u ? z.normalizeFast() : z.normalize()));
          v.aabb && (v.aabbNeedsUpdate = !0);
          v.updateInertiaWorld && v.updateInertiaWorld();
        }
      }
      this.clearForces();
      this.broadphase.dirty = !0;
      h && (g.integrate = performance.now() - n);
      this.time += b;
      this.stepnumber += 1;
      this.dispatchEvent(C);
      for (k = 0; k !== e; k++) {
        v = d[k], (b = v.postStep) && b.call(v);
      }
      if (this.allowSleep) {
        for (k = 0; k !== e; k++) {
          d[k].sleepTick(this.time);
        }
      }
    };
    e.prototype.clearForces = function() {
      for (var b = this.bodies, c = b.length, e = 0; e !== c; e++) {
        var d = b[e];
        d.force.set(0, 0, 0);
        d.torque.set(0, 0, 0);
      }
    };
  }, {"../collision/AABB":3, "../collision/ArrayCollisionMatrix":4, "../collision/NaiveBroadphase":7, "../collision/Ray":9, "../collision/RaycastResult":10, "../equations/ContactEquation":19, "../equations/FrictionEquation":21, "../material/ContactMaterial":24, "../material/Material":25, "../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "../shapes/Shape":43, "../solver/GSSolver":46, "../utils/EventTarget":49, "../utils/TupleDictionary":52, "../utils/Vec3Pool":54, "./Narrowphase":55}]}, 
  {}, [2])(2);
});
!function(a, d, g) {
  function h(c, k) {
    if (!d[c]) {
      if (!a[c]) {
        var g = "function" == typeof require && require;
        if (!k && g) {
          return g(c, !0);
        }
        if (e) {
          return e(c, !0);
        }
        throw Error("Cannot find module '" + c + "'");
      }
      k = d[c] = {exports:{}};
      a[c][0].call(k.exports, function(e) {
        var d = a[c][1][e];
        return h(d ? d : e);
      }, k, k.exports);
    }
    return d[c].exports;
  }
  for (var e = "function" == typeof require && require, k = 0; k < g.length; k++) {
    h(g[k]);
  }
  return h;
}({1:[function(a, d) {
  var g = (a("./pointable"), a("gl-matrix")), h = g.vec3, e = g.mat3, k = g.mat4;
  a = (a("underscore"), d.exports = function(a, e) {
    this.finger = a;
    this._matrix = this._center = null;
    this.type = e.type;
    this.prevJoint = e.prevJoint;
    this.nextJoint = e.nextJoint;
    this.width = e.width;
    a = Array(3);
    h.sub(a, e.nextJoint, e.prevJoint);
    this.length = h.length(a);
    this.basis = e.basis;
  });
  a.prototype.left = function() {
    return this._left ? this._left : (this._left = 0 > e.determinant(this.basis[0].concat(this.basis[1]).concat(this.basis[2])), this._left);
  };
  a.prototype.matrix = function() {
    if (this._matrix) {
      return this._matrix;
    }
    var a = this.basis, e = this._matrix = k.create();
    return e[0] = a[0][0], e[1] = a[0][1], e[2] = a[0][2], e[4] = a[1][0], e[5] = a[1][1], e[6] = a[1][2], e[8] = a[2][0], e[9] = a[2][1], e[10] = a[2][2], e[3] = this.center()[0], e[7] = this.center()[1], e[11] = this.center()[2], this.left() && (e[0] *= -1, e[1] *= -1, e[2] *= -1), this._matrix;
  };
  a.prototype.lerp = function(a, e) {
    h.lerp(a, this.prevJoint, this.nextJoint, e);
  };
  a.prototype.center = function() {
    if (this._center) {
      return this._center;
    }
    var a = h.create();
    return this.lerp(a, .5), this._center = a, a;
  };
  a.prototype.direction = function() {
    return [-1 * this.basis[2][0], -1 * this.basis[2][1], -1 * this.basis[2][2]];
  };
}, {"./pointable":14, "gl-matrix":23, underscore:24}], 2:[function(a, d) {
  a = d.exports = function(a) {
    this.pos = 0;
    this._buf = [];
    this.size = a;
  };
  a.prototype.get = function(a) {
    return void 0 == a && (a = 0), a >= this.size ? void 0 : a >= this._buf.length ? void 0 : this._buf[(this.pos - a - 1) % this.size];
  };
  a.prototype.push = function(a) {
    return this._buf[this.pos % this.size] = a, this.pos++;
  };
}, {}], 3:[function(a, d) {
  var g = a("../protocol").chooseProtocol, h = a("events").EventEmitter, e = a("underscore"), k = d.exports = function(a) {
    this.opts = e.defaults(a || {}, {host:"127.0.0.1", enableGestures:!1, scheme:this.getScheme(), port:this.getPort(), background:!1, optimizeHMD:!1, requestProtocolVersion:k.defaultProtocolVersion});
    this.host = this.opts.host;
    this.port = this.opts.port;
    this.scheme = this.opts.scheme;
    this.protocolVersionVerified = !1;
    this.optimizeHMD = this.background = null;
    this.on("ready", function() {
      this.enableGestures(this.opts.enableGestures);
      this.setBackground(this.opts.background);
      this.setOptimizeHMD(this.opts.optimizeHMD);
      console.log(this.opts.optimizeHMD ? "Optimized for head mounted display usage." : "Optimized for desktop usage.");
    });
  };
  k.defaultProtocolVersion = 6;
  k.prototype.getUrl = function() {
    return this.scheme + "//" + this.host + ":" + this.port + "/v" + this.opts.requestProtocolVersion + ".json";
  };
  k.prototype.getScheme = function() {
    return "ws:";
  };
  k.prototype.getPort = function() {
    return 6437;
  };
  k.prototype.setBackground = function(a) {
    this.opts.background = a;
    this.protocol && this.protocol.sendBackground && this.background !== this.opts.background && (this.background = this.opts.background, this.protocol.sendBackground(this, this.opts.background));
  };
  k.prototype.setOptimizeHMD = function(a) {
    this.opts.optimizeHMD = a;
    this.protocol && this.protocol.sendOptimizeHMD && this.optimizeHMD !== this.opts.optimizeHMD && (this.optimizeHMD = this.opts.optimizeHMD, this.protocol.sendOptimizeHMD(this, this.opts.optimizeHMD));
  };
  k.prototype.handleOpen = function() {
    this.connected || (this.connected = !0, this.emit("connect"));
  };
  k.prototype.enableGestures = function(a) {
    this.gesturesEnabled = a ? !0 : !1;
    this.send(this.protocol.encode({enableGestures:this.gesturesEnabled}));
  };
  k.prototype.handleClose = function(a) {
    this.connected && (this.disconnect(), 1001 === a && 1 < this.opts.requestProtocolVersion && (this.protocolVersionVerified ? this.protocolVersionVerified = !1 : this.opts.requestProtocolVersion--), this.startReconnection());
  };
  k.prototype.startReconnection = function() {
    var a = this;
    this.reconnectionTimer || (this.reconnectionTimer = setInterval(function() {
      a.reconnect();
    }, 500));
  };
  k.prototype.stopReconnection = function() {
    this.reconnectionTimer = clearInterval(this.reconnectionTimer);
  };
  k.prototype.disconnect = function(a) {
    return a || this.stopReconnection(), this.socket ? (this.socket.close(), delete this.socket, delete this.protocol, delete this.background, delete this.optimizeHMD, delete this.focusedState, this.connected && (this.connected = !1, this.emit("disconnect")), !0) : void 0;
  };
  k.prototype.reconnect = function() {
    this.connected ? this.stopReconnection() : (this.disconnect(!0), this.connect());
  };
  k.prototype.handleData = function(a) {
    var c;
    a = JSON.parse(a);
    void 0 === this.protocol ? (c = this.protocol = g(a), this.protocolVersionVerified = !0, this.emit("ready")) : c = this.protocol(a);
    this.emit(c.type, c);
  };
  k.prototype.connect = function() {
    return this.socket ? void 0 : (this.socket = this.setupSocket(), !0);
  };
  k.prototype.send = function(a) {
    this.socket.send(a);
  };
  k.prototype.reportFocus = function(a) {
    this.connected && this.focusedState !== a && (this.focusedState = a, this.emit(this.focusedState ? "focus" : "blur"), this.protocol && this.protocol.sendFocused && this.protocol.sendFocused(this, this.focusedState));
  };
  e.extend(k.prototype, h.prototype);
}, {"../protocol":15, events:21, underscore:24}], 4:[function(a, d) {
  var g = d.exports = a("./base");
  a = a("underscore");
  d = d.exports = function(a) {
    g.call(this, a);
    var e = this;
    this.on("ready", function() {
      e.startFocusLoop();
    });
    this.on("disconnect", function() {
      e.stopFocusLoop();
    });
  };
  a.extend(d.prototype, g.prototype);
  d.__proto__ = g;
  d.prototype.useSecure = function() {
    return "https:" === location.protocol;
  };
  d.prototype.getScheme = function() {
    return this.useSecure() ? "wss:" : "ws:";
  };
  d.prototype.getPort = function() {
    return this.useSecure() ? 6436 : 6437;
  };
  d.prototype.setupSocket = function() {
    var a = this, e = new WebSocket(this.getUrl());
    return e.onopen = function() {
      a.handleOpen();
    }, e.onclose = function(e) {
      a.handleClose(e.code, e.reason);
    }, e.onmessage = function(e) {
      a.handleData(e.data);
    }, e.onerror = function() {
      a.useSecure() && "wss:" === a.scheme && (a.scheme = "ws:", a.port = 6437, a.disconnect(), a.connect());
    }, e;
  };
  d.prototype.startFocusLoop = function() {
    if (!this.focusDetectorTimer) {
      var a = this, e = null;
      e = "undefined" != typeof document.hidden ? "hidden" : "undefined" != typeof document.mozHidden ? "mozHidden" : "undefined" != typeof document.msHidden ? "msHidden" : "undefined" != typeof document.webkitHidden ? "webkitHidden" : void 0;
      void 0 === a.windowVisible && (a.windowVisible = void 0 === e ? !0 : !1 === document[e]);
      var d = window.addEventListener("focus", function() {
        a.windowVisible = !0;
        g();
      }), c = window.addEventListener("blur", function() {
        a.windowVisible = !1;
        g();
      });
      this.on("disconnect", function() {
        window.removeEventListener("focus", d);
        window.removeEventListener("blur", c);
      });
      var g = function() {
        a.reportFocus((void 0 === e ? !0 : !1 === document[e]) && a.windowVisible);
      };
      g();
      this.focusDetectorTimer = setInterval(g, 100);
    }
  };
  d.prototype.stopFocusLoop = function() {
    this.focusDetectorTimer && (clearTimeout(this.focusDetectorTimer), delete this.focusDetectorTimer);
  };
}, {"./base":3, underscore:24}], 5:[function(a, d) {
  var g = a("__browserify_process"), h = a("./frame"), e = a("./hand"), k = a("./pointable"), c = a("./finger"), p = a("./circular_buffer"), t = a("./pipeline"), f = a("events").EventEmitter, n = a("./gesture").gestureListener, b = a("./dialog"), m = a("underscore"), q = d.exports = function(b) {
    var c = this;
    b = m.defaults(b || {}, {inNode:"undefined" != typeof g && g.versions && g.versions.node});
    this.inNode = b.inNode;
    b = m.defaults(b || {}, {frameEventName:this.useAnimationLoop() ? "animationFrame" : "deviceFrame", suppressAnimationLoop:!this.useAnimationLoop(), loopWhileDisconnected:!0, useAllPlugins:!1, checkVersion:!0});
    this.animationFrameRequested = !1;
    this.onAnimationFrame = function(a) {
      c.lastConnectionFrame.valid && c.emit("animationFrame", c.lastConnectionFrame);
      c.emit("frameEnd", a);
      c.loopWhileDisconnected && (!1 !== c.connection.focusedState || c.connection.opts.background) ? window.requestAnimationFrame(c.onAnimationFrame) : c.animationFrameRequested = !1;
    };
    this.suppressAnimationLoop = b.suppressAnimationLoop;
    this.loopWhileDisconnected = b.loopWhileDisconnected;
    this.frameEventName = b.frameEventName;
    this.useAllPlugins = b.useAllPlugins;
    this.history = new p(200);
    this.lastConnectionFrame = this.lastValidFrame = this.lastFrame = h.Invalid;
    this.accumulatedGestures = [];
    this.checkVersion = b.checkVersion;
    this.connectionType = void 0 === b.connectionType ? a(this.inBrowser() ? "./connection/browser" : "./connection/node") : b.connectionType;
    this.connection = new this.connectionType(b);
    this.streamingCount = 0;
    this.devices = {};
    this.plugins = {};
    this._pluginPipelineSteps = {};
    this._pluginExtendedMethods = {};
    b.useAllPlugins && this.useRegisteredPlugins();
    this.setupFrameEvents(b);
    this.setupConnectionEvents();
    this.startAnimationLoop();
  };
  q.prototype.gesture = function(a, b) {
    a = n(this, a);
    return void 0 !== b && a.stop(b), a;
  };
  q.prototype.setBackground = function(a) {
    return this.connection.setBackground(a), this;
  };
  q.prototype.setOptimizeHMD = function(a) {
    return this.connection.setOptimizeHMD(a), this;
  };
  q.prototype.inBrowser = function() {
    return !this.inNode;
  };
  q.prototype.useAnimationLoop = function() {
    return this.inBrowser() && !this.inBackgroundPage();
  };
  q.prototype.inBackgroundPage = function() {
    return "undefined" != typeof chrome && chrome.extension && chrome.extension.getBackgroundPage && chrome.extension.getBackgroundPage() === window;
  };
  q.prototype.connect = function() {
    return this.connection.connect(), this;
  };
  q.prototype.streaming = function() {
    return 0 < this.streamingCount;
  };
  q.prototype.connected = function() {
    return !!this.connection.connected;
  };
  q.prototype.startAnimationLoop = function() {
    this.suppressAnimationLoop || this.animationFrameRequested || (this.animationFrameRequested = !0, window.requestAnimationFrame(this.onAnimationFrame));
  };
  q.prototype.disconnect = function() {
    return this.connection.disconnect(), this;
  };
  q.prototype.frame = function(a) {
    return this.history.get(a) || h.Invalid;
  };
  q.prototype.loop = function(a) {
    return a && ("function" == typeof a ? this.on(this.frameEventName, a) : this.setupFrameEvents(a)), this.connect();
  };
  q.prototype.addStep = function(a) {
    this.pipeline || (this.pipeline = new t(this));
    this.pipeline.addStep(a);
  };
  q.prototype.processFrame = function(a) {
    a.gestures && (this.accumulatedGestures = this.accumulatedGestures.concat(a.gestures));
    this.lastConnectionFrame = a;
    this.startAnimationLoop();
    this.emit("deviceFrame", a);
  };
  q.prototype.processFinishedFrame = function(a) {
    if (this.lastFrame = a, a.valid && (this.lastValidFrame = a), a.controller = this, a.historyIdx = this.history.push(a), a.gestures) {
      a.gestures = this.accumulatedGestures;
      this.accumulatedGestures = [];
      for (var b = 0; b != a.gestures.length; b++) {
        this.emit("gesture", a.gestures[b], a);
      }
    }
    this.pipeline && (a = this.pipeline.run(a), a || (a = h.Invalid));
    this.emit("frame", a);
    this.emitHandEvents(a);
  };
  q.prototype.emitHandEvents = function(a) {
    for (var b = 0; b < a.hands.length; b++) {
      this.emit("hand", a.hands[b]);
    }
  };
  q.prototype.setupFrameEvents = function(a) {
    a.frame && this.on("frame", a.frame);
    a.hand && this.on("hand", a.hand);
  };
  q.prototype.setupConnectionEvents = function() {
    var a = this;
    this.connection.on("frame", function(b) {
      a.processFrame(b);
    });
    this.on(this.frameEventName, function(b) {
      a.processFinishedFrame(b);
    });
    var b = function() {
      if (5 > a.connection.opts.requestProtocolVersion && 0 == a.streamingCount) {
        a.streamingCount = 1;
        var c = {attached:!0, streaming:!0, type:"unknown", id:"Lx00000000000"};
        a.devices[c.id] = c;
        a.emit("deviceAttached", c);
        a.emit("deviceStreaming", c);
        a.emit("streamingStarted", c);
        a.connection.removeListener("frame", b);
      }
    }, c = function() {
      if (0 < a.streamingCount) {
        for (var b in a.devices) {
          a.emit("deviceStopped", a.devices[b]), a.emit("deviceRemoved", a.devices[b]);
        }
        a.emit("streamingStopped", a.devices[b]);
        a.streamingCount = 0;
        for (b in a.devices) {
          delete a.devices[b];
        }
      }
    };
    this.connection.on("focus", function() {
      a.loopWhileDisconnected && a.startAnimationLoop();
      a.emit("focus");
    });
    this.connection.on("blur", function() {
      a.emit("blur");
    });
    this.connection.on("protocol", function(b) {
      b.on("beforeFrameCreated", function(b) {
        a.emit("beforeFrameCreated", b);
      });
      b.on("afterFrameCreated", function(b, c) {
        a.emit("afterFrameCreated", b, c);
      });
      a.emit("protocol", b);
    });
    this.connection.on("ready", function() {
      a.checkVersion && !a.inNode && a.checkOutOfDate();
      a.emit("ready");
    });
    this.connection.on("connect", function() {
      a.emit("connect");
      a.connection.removeListener("frame", b);
      a.connection.on("frame", b);
    });
    this.connection.on("disconnect", function() {
      a.emit("disconnect");
      c();
    });
    this.connection.on("deviceConnect", function(e) {
      e.state ? (a.emit("deviceConnected"), a.connection.removeListener("frame", b), a.connection.on("frame", b)) : (a.emit("deviceDisconnected"), c());
    });
    this.connection.on("deviceEvent", function(b) {
      b = b.state;
      var c = a.devices[b.id], e = {}, d;
      for (d in b) {
        c && c.hasOwnProperty(d) && c[d] == b[d] || (e[d] = !0);
      }
      a.devices[b.id] = b;
      e.attached && a.emit(b.attached ? "deviceAttached" : "deviceRemoved", b);
      e.streaming && (b.streaming ? (a.streamingCount++, a.emit("deviceStreaming", b), 1 == a.streamingCount && a.emit("streamingStarted", b), e.attached || a.emit("deviceConnected")) : e.attached && b.attached || (a.streamingCount--, a.emit("deviceStopped", b), 0 == a.streamingCount && a.emit("streamingStopped", b), a.emit("deviceDisconnected")));
    });
    this.on("newListener", function(a) {
      "deviceConnected" != a && "deviceDisconnected" != a || console.warn(a + " events are depricated.  Consider using 'streamingStarted/streamingStopped' or 'deviceStreaming/deviceStopped' instead");
    });
  };
  q.prototype.checkOutOfDate = function() {
    console.assert(this.connection && this.connection.protocol);
    var a = this.connection.protocol.serviceVersion, c = this.connection.protocol.version, e = this.connectionType.defaultProtocolVersion;
    return e > c ? (console.warn("Your Protocol Version is v" + c + ", this app was designed for v" + e), b.warnOutOfDate({sV:a, pV:c}), !0) : !1;
  };
  q._pluginFactories = {};
  q.plugin = function(a, b) {
    return this._pluginFactories[a] && console.warn('Plugin "' + a + '" already registered'), this._pluginFactories[a] = b;
  };
  q.plugins = function() {
    return m.keys(this._pluginFactories);
  };
  q.prototype.use = function(a, b) {
    var d, f;
    if (d = "function" == typeof a ? a : q._pluginFactories[a], !d) {
      throw "Leap Plugin " + a + " not found.";
    }
    if (b || (b = {}), this.plugins[a]) {
      return m.extend(this.plugins[a], b), this;
    }
    this.plugins[a] = b;
    b = d.call(this, b);
    for (f in b) {
      if (d = b[f], "function" == typeof d) {
        var g = a, n = f;
        -1 != ["beforeFrameCreated", "afterFrameCreated"].indexOf(n) ? this.on(n, d) : (this.pipeline || (this.pipeline = new t(this)), this._pluginPipelineSteps[g] || (this._pluginPipelineSteps[g] = []), this._pluginPipelineSteps[g].push(this.pipeline.addWrappedStep(n, d)));
      } else {
        g = a;
        n = f;
        switch(this._pluginExtendedMethods[g] || (this._pluginExtendedMethods[g] = []), n) {
          case "frame":
            n = h;
            break;
          case "hand":
            n = e;
            break;
          case "pointable":
            n = k;
            m.extend(c.prototype, d);
            m.extend(c.Invalid, d);
            break;
          case "finger":
            n = c;
            break;
          default:
            throw g + ' specifies invalid object type "' + n + '" for prototypical extension';
        }
        m.extend(n.prototype, d);
        m.extend(n.Invalid, d);
        this._pluginExtendedMethods[g].push([n, d]);
      }
    }
    return this;
  };
  q.prototype.stopUsing = function(a) {
    var b = this._pluginPipelineSteps[a];
    var c = this._pluginExtendedMethods[a], e;
    if (this.plugins[a]) {
      if (b) {
        for (e = 0; e < b.length; e++) {
          this.pipeline.removeStep(b[e]);
        }
      }
      if (c) {
        for (e = 0; e < c.length; e++) {
          b = c[e][0];
          var d = c[e][1];
          for (var f in d) {
            delete b.prototype[f], delete b.Invalid[f];
          }
        }
      }
      return delete this.plugins[a], this;
    }
  };
  q.prototype.useRegisteredPlugins = function() {
    for (var a in q._pluginFactories) {
      this.use(a);
    }
  };
  m.extend(q.prototype, f.prototype);
}, {"./circular_buffer":2, "./connection/browser":4, "./connection/node":20, "./dialog":6, "./finger":7, "./frame":8, "./gesture":9, "./hand":10, "./pipeline":13, "./pointable":14, __browserify_process:22, events:21, underscore:24}], 6:[function(a, d) {
  var g = a("__browserify_process"), h = d.exports = function(a, d) {
    this.options = d || {};
    this.message = a;
    this.createElement();
  };
  h.prototype.createElement = function() {
    this.element = document.createElement("div");
    this.element.className = "leapjs-dialog";
    this.element.style.position = "fixed";
    this.element.style.top = "8px";
    this.element.style.left = 0;
    this.element.style.right = 0;
    this.element.style.textAlign = "center";
    this.element.style.zIndex = 1E3;
    var a = document.createElement("div");
    this.element.appendChild(a);
    a.style.className = "leapjs-dialog";
    a.style.display = "inline-block";
    a.style.margin = "auto";
    a.style.padding = "8px";
    a.style.color = "#222";
    a.style.background = "#eee";
    a.style.borderRadius = "4px";
    a.style.border = "1px solid #999";
    a.style.textAlign = "left";
    a.style.cursor = "pointer";
    a.style.whiteSpace = "nowrap";
    a.style.transition = "box-shadow 1s linear";
    a.innerHTML = this.message;
    this.options.onclick && a.addEventListener("click", this.options.onclick);
    this.options.onmouseover && a.addEventListener("mouseover", this.options.onmouseover);
    this.options.onmouseout && a.addEventListener("mouseout", this.options.onmouseout);
    this.options.onmousemove && a.addEventListener("mousemove", this.options.onmousemove);
  };
  h.prototype.show = function() {
    return document.body.appendChild(this.element), this;
  };
  h.prototype.hide = function() {
    return document.body.removeChild(this.element), this;
  };
  h.warnOutOfDate = function(a) {
    a || (a = {});
    var e = "http://developer.leapmotion.com?";
    a.returnTo = window.location.href;
    for (var c in a) {
      e += c + "=" + encodeURIComponent(a[c]) + "&";
    }
    var d;
    return d = new h("This site requires Leap Motion Tracking V2.<button id='leapjs-accept-upgrade'  style='color: #444; transition: box-shadow 100ms linear; cursor: pointer; vertical-align: baseline; margin-left: 16px;'>Upgrade</button><button id='leapjs-decline-upgrade' style='color: #444; transition: box-shadow 100ms linear; cursor: pointer; vertical-align: baseline; margin-left: 8px; '>Not Now</button>", {onclick:function(a) {
      "leapjs-decline-upgrade" != a.target.id && (a = window.open(e, "_blank", "height=800,width=1000,location=1,menubar=1,resizable=1,status=1,toolbar=1,scrollbars=1"), window.focus && a.focus());
      return d.hide(), !0;
    }, onmousemove:function(a) {
      a.target == document.getElementById("leapjs-decline-upgrade") ? (document.getElementById("leapjs-decline-upgrade").style.color = "#000", document.getElementById("leapjs-decline-upgrade").style.boxShadow = "0px 0px 2px #5daa00", document.getElementById("leapjs-accept-upgrade").style.color = "#444", document.getElementById("leapjs-accept-upgrade").style.boxShadow = "none") : (document.getElementById("leapjs-accept-upgrade").style.color = "#000", document.getElementById("leapjs-accept-upgrade").style.boxShadow = 
      "0px 0px 2px #5daa00", document.getElementById("leapjs-decline-upgrade").style.color = "#444", document.getElementById("leapjs-decline-upgrade").style.boxShadow = "none");
    }, onmouseout:function() {
      document.getElementById("leapjs-decline-upgrade").style.color = "#444";
      document.getElementById("leapjs-decline-upgrade").style.boxShadow = "none";
      document.getElementById("leapjs-accept-upgrade").style.color = "#444";
      document.getElementById("leapjs-accept-upgrade").style.boxShadow = "none";
    }}), d.show();
  };
  h.hasWarnedBones = !1;
  h.warnBones = function() {
    this.hasWarnedBones || (this.hasWarnedBones = !0, console.warn("Your Leap Service is out of date"), "undefined" != typeof g && g.versions && g.versions.node || this.warnOutOfDate({reason:"bones"}));
  };
}, {__browserify_process:22}], 7:[function(a, d) {
  var g = a("./pointable"), h = a("./bone"), e = a("./dialog");
  a = a("underscore");
  d = d.exports = function(a) {
    g.call(this, a);
    this.dipPosition = a.dipPosition;
    this.pipPosition = a.pipPosition;
    this.mcpPosition = a.mcpPosition;
    this.carpPosition = a.carpPosition;
    this.extended = a.extended;
    this.type = a.type;
    this.finger = !0;
    this.positions = [this.carpPosition, this.mcpPosition, this.pipPosition, this.dipPosition, this.tipPosition];
    a.bases ? this.addBones(a) : e.warnBones();
  };
  a.extend(d.prototype, g.prototype);
  d.prototype.addBones = function(a) {
    this.metacarpal = new h(this, {type:0, width:this.width, prevJoint:this.carpPosition, nextJoint:this.mcpPosition, basis:a.bases[0]});
    this.proximal = new h(this, {type:1, width:this.width, prevJoint:this.mcpPosition, nextJoint:this.pipPosition, basis:a.bases[1]});
    this.medial = new h(this, {type:2, width:this.width, prevJoint:this.pipPosition, nextJoint:this.dipPosition, basis:a.bases[2]});
    this.distal = new h(this, {type:3, width:this.width, prevJoint:this.dipPosition, nextJoint:a.btipPosition, basis:a.bases[3]});
    this.bones = [this.metacarpal, this.proximal, this.medial, this.distal];
  };
  d.prototype.toString = function() {
    return "Finger [ id:" + this.id + " " + this.length + "mmx | width:" + this.width + "mm | direction:" + this.direction + " ]";
  };
  d.Invalid = {valid:!1};
}, {"./bone":1, "./dialog":6, "./pointable":14, underscore:24}], 8:[function(a, d) {
  var g = a("./hand"), h = a("./pointable"), e = a("./gesture").createGesture, k = a("gl-matrix"), c = k.mat3, p = k.vec3, t = a("./interaction_box"), f = a("./finger"), n = a("underscore");
  a = d.exports = function(a) {
    if (this.valid = !0, this.id = a.id, this.timestamp = a.timestamp, this.hands = [], this.handsMap = {}, this.pointables = [], this.tools = [], this.fingers = [], a.interactionBox && (this.interactionBox = new t(a.interactionBox)), this.gestures = [], this.pointablesMap = {}, this._translation = a.t, this._rotation = n.flatten(a.r), this._scaleFactor = a.s, this.data = a, this.type = "frame", this.currentFrameRate = a.currentFrameRate, a.gestures) {
      for (var b = 0, c = a.gestures.length; b != c; b++) {
        this.gestures.push(e(a.gestures[b]));
      }
    }
    this.postprocessData(a);
  };
  a.prototype.postprocessData = function(a) {
    a || (a = this.data);
    for (var b = 0, c = a.hands.length; b != c; b++) {
      var e = new g(a.hands[b]);
      e.frame = this;
      this.hands.push(e);
      this.handsMap[e.id] = e;
    }
    a.pointables = n.sortBy(a.pointables, function(a) {
      return a.id;
    });
    b = 0;
    for (c = a.pointables.length; b != c; b++) {
      e = a.pointables[b], e = e.dipPosition ? new f(e) : new h(e), e.frame = this, this.addPointable(e);
    }
  };
  a.prototype.addPointable = function(a) {
    if (this.pointables.push(a), this.pointablesMap[a.id] = a, (a.tool ? this.tools : this.fingers).push(a), void 0 !== a.handId && this.handsMap.hasOwnProperty(a.handId)) {
      var b = this.handsMap[a.handId];
      switch(b.pointables.push(a), (a.tool ? b.tools : b.fingers).push(a), a.type) {
        case 0:
          b.thumb = a;
          break;
        case 1:
          b.indexFinger = a;
          break;
        case 2:
          b.middleFinger = a;
          break;
        case 3:
          b.ringFinger = a;
          break;
        case 4:
          b.pinky = a;
      }
    }
  };
  a.prototype.tool = function(a) {
    a = this.pointable(a);
    return a.tool ? a : h.Invalid;
  };
  a.prototype.pointable = function(a) {
    return this.pointablesMap[a] || h.Invalid;
  };
  a.prototype.finger = function(a) {
    a = this.pointable(a);
    return a.tool ? h.Invalid : a;
  };
  a.prototype.hand = function(a) {
    return this.handsMap[a] || g.Invalid;
  };
  a.prototype.rotationAngle = function(a, c) {
    if (!this.valid || !a.valid) {
      return 0;
    }
    var b = this.rotationMatrix(a);
    b = Math.acos(.5 * (b[0] + b[4] + b[8] - 1));
    if (b = isNaN(b) ? 0 : b, void 0 !== c) {
      a = this.rotationAxis(a), b *= p.dot(a, p.normalize(p.create(), c));
    }
    return b;
  };
  a.prototype.rotationAxis = function(a) {
    return this.valid && a.valid ? p.normalize(p.create(), [this._rotation[7] - a._rotation[5], this._rotation[2] - a._rotation[6], this._rotation[3] - a._rotation[1]]) : p.create();
  };
  a.prototype.rotationMatrix = function(a) {
    if (!this.valid || !a.valid) {
      return c.create();
    }
    var b = c.transpose(c.create(), this._rotation);
    return c.multiply(c.create(), a._rotation, b);
  };
  a.prototype.scaleFactor = function(a) {
    return this.valid && a.valid ? Math.exp(this._scaleFactor - a._scaleFactor) : 1;
  };
  a.prototype.translation = function(a) {
    return this.valid && a.valid ? p.subtract(p.create(), this._translation, a._translation) : p.create();
  };
  a.prototype.toString = function() {
    var a = "Frame [ id:" + this.id + " | timestamp:" + this.timestamp + " | Hand count:(" + this.hands.length + ") | Pointable count:(" + this.pointables.length + ")";
    return this.gestures && (a += " | Gesture count:(" + this.gestures.length + ")"), a + " ]";
  };
  a.prototype.dump = function() {
    var a = "Frame Info:<br/>" + this.toString();
    a += "<br/><br/>Hands:<br/>";
    for (var c = 0, e = this.hands.length; c != e; c++) {
      a += "  " + this.hands[c].toString() + "<br/>";
    }
    a += "<br/><br/>Pointables:<br/>";
    c = 0;
    for (e = this.pointables.length; c != e; c++) {
      a += "  " + this.pointables[c].toString() + "<br/>";
    }
    if (this.gestures) {
      for (a += "<br/><br/>Gestures:<br/>", c = 0, e = this.gestures.length; c != e; c++) {
        a += "  " + this.gestures[c].toString() + "<br/>";
      }
    }
    return a += "<br/><br/>Raw JSON:<br/>", a + JSON.stringify(this.data);
  };
  a.Invalid = {valid:!1, hands:[], fingers:[], tools:[], gestures:[], pointables:[], pointable:function() {
    return h.Invalid;
  }, finger:function() {
    return h.Invalid;
  }, hand:function() {
    return g.Invalid;
  }, toString:function() {
    return "invalid frame";
  }, dump:function() {
    return this.toString();
  }, rotationAngle:function() {
    return 0;
  }, rotationMatrix:function() {
    return c.create();
  }, rotationAxis:function() {
    return p.create();
  }, scaleFactor:function() {
    return 1;
  }, translation:function() {
    return p.create();
  }};
}, {"./finger":7, "./gesture":9, "./hand":10, "./interaction_box":12, "./pointable":14, "gl-matrix":23, underscore:24}], 9:[function(a, d, g) {
  var h = a("gl-matrix").vec3;
  d = a("events").EventEmitter;
  var e = a("underscore"), k = (g.createGesture = function(a) {
    switch(a.type) {
      case "circle":
        var b = new c(a);
        break;
      case "swipe":
        b = new p(a);
        break;
      case "screenTap":
        b = new t(a);
        break;
      case "keyTap":
        b = new f(a);
        break;
      default:
        throw "unknown gesture type";
    }
    return b.id = a.id, b.handIds = a.handIds.slice(), b.pointableIds = a.pointableIds.slice(), b.duration = a.duration, b.state = a.state, b.type = a.type, b;
  }, g.gestureListener = function(a, b) {
    var c = {}, d = {};
    a.on("gesture", function(a, f) {
      if (a.type == b) {
        if (("start" == a.state || "stop" == a.state) && void 0 === d[a.id]) {
          var m = new k(a, f);
          d[a.id] = m;
          e.each(c, function(a, b) {
            m.on(b, a);
          });
        }
        d[a.id].update(a, f);
        "stop" == a.state && delete d[a.id];
      }
    });
    var f = {start:function(a) {
      return c.start = a, f;
    }, stop:function(a) {
      return c.stop = a, f;
    }, complete:function(a) {
      return c.stop = a, f;
    }, update:function(a) {
      return c.update = a, f;
    }};
    return f;
  }, g.Gesture = function(a, b) {
    this.gestures = [a];
    this.frames = [b];
  });
  k.prototype.update = function(a, b) {
    this.lastGesture = a;
    this.lastFrame = b;
    this.gestures.push(a);
    this.frames.push(b);
    this.emit(a.state, this);
  };
  k.prototype.translation = function() {
    return h.subtract(h.create(), this.lastGesture.startPosition, this.lastGesture.position);
  };
  e.extend(k.prototype, d.prototype);
  var c = function(a) {
    this.center = a.center;
    this.normal = a.normal;
    this.progress = a.progress;
    this.radius = a.radius;
  };
  c.prototype.toString = function() {
    return "CircleGesture [" + JSON.stringify(this) + "]";
  };
  var p = function(a) {
    this.startPosition = a.startPosition;
    this.position = a.position;
    this.direction = a.direction;
    this.speed = a.speed;
  };
  p.prototype.toString = function() {
    return "SwipeGesture [" + JSON.stringify(this) + "]";
  };
  var t = function(a) {
    this.position = a.position;
    this.direction = a.direction;
    this.progress = a.progress;
  };
  t.prototype.toString = function() {
    return "ScreenTapGesture [" + JSON.stringify(this) + "]";
  };
  var f = function(a) {
    this.position = a.position;
    this.direction = a.direction;
    this.progress = a.progress;
  };
  f.prototype.toString = function() {
    return "KeyTapGesture [" + JSON.stringify(this) + "]";
  };
}, {events:21, "gl-matrix":23, underscore:24}], 10:[function(a, d) {
  var g = a("./pointable"), h = a("./bone"), e = a("gl-matrix"), k = e.mat3, c = e.vec3, p = a("underscore");
  a = d.exports = function(a) {
    this.id = a.id;
    this.palmPosition = a.palmPosition;
    this.direction = a.direction;
    this.palmVelocity = a.palmVelocity;
    this.palmNormal = a.palmNormal;
    this.sphereCenter = a.sphereCenter;
    this.sphereRadius = a.sphereRadius;
    this.valid = !0;
    this.pointables = [];
    this.fingers = [];
    this.arm = a.armBasis ? new h(this, {type:4, width:a.armWidth, prevJoint:a.elbow, nextJoint:a.wrist, basis:a.armBasis}) : null;
    this.tools = [];
    this._translation = a.t;
    this._rotation = p.flatten(a.r);
    this._scaleFactor = a.s;
    this.timeVisible = a.timeVisible;
    this.stabilizedPalmPosition = a.stabilizedPalmPosition;
    this.type = a.type;
    this.grabStrength = a.grabStrength;
    this.pinchStrength = a.pinchStrength;
    this.confidence = a.confidence;
  };
  a.prototype.finger = function(a) {
    return (a = this.frame.finger(a)) && a.handId == this.id ? a : g.Invalid;
  };
  a.prototype.rotationAngle = function(a, e) {
    if (!this.valid || !a.valid || !a.hand(this.id).valid) {
      return 0;
    }
    var d = this.rotationMatrix(a);
    d = Math.acos(.5 * (d[0] + d[4] + d[8] - 1));
    if (d = isNaN(d) ? 0 : d, void 0 !== e) {
      a = this.rotationAxis(a), d *= c.dot(a, c.normalize(c.create(), e));
    }
    return d;
  };
  a.prototype.rotationAxis = function(a) {
    if (!this.valid || !a.valid) {
      return c.create();
    }
    a = a.hand(this.id);
    return a.valid ? c.normalize(c.create(), [this._rotation[7] - a._rotation[5], this._rotation[2] - a._rotation[6], this._rotation[3] - a._rotation[1]]) : c.create();
  };
  a.prototype.rotationMatrix = function(a) {
    if (!this.valid || !a.valid) {
      return k.create();
    }
    a = a.hand(this.id);
    if (!a.valid) {
      return k.create();
    }
    var c = k.transpose(k.create(), this._rotation);
    return k.multiply(k.create(), a._rotation, c);
  };
  a.prototype.scaleFactor = function(a) {
    if (!this.valid || !a.valid) {
      return 1;
    }
    a = a.hand(this.id);
    return a.valid ? Math.exp(this._scaleFactor - a._scaleFactor) : 1;
  };
  a.prototype.translation = function(a) {
    if (!this.valid || !a.valid) {
      return c.create();
    }
    a = a.hand(this.id);
    return a.valid ? [this._translation[0] - a._translation[0], this._translation[1] - a._translation[1], this._translation[2] - a._translation[2]] : c.create();
  };
  a.prototype.toString = function() {
    return "Hand (" + this.type + ") [ id: " + this.id + " | palm velocity:" + this.palmVelocity + " | sphere center:" + this.sphereCenter + " ] ";
  };
  a.prototype.pitch = function() {
    return Math.atan2(this.direction[1], -this.direction[2]);
  };
  a.prototype.yaw = function() {
    return Math.atan2(this.direction[0], -this.direction[2]);
  };
  a.prototype.roll = function() {
    return Math.atan2(this.palmNormal[0], -this.palmNormal[1]);
  };
  a.Invalid = {valid:!1, fingers:[], tools:[], pointables:[], left:!1, pointable:function() {
    return g.Invalid;
  }, finger:function() {
    return g.Invalid;
  }, toString:function() {
    return "invalid frame";
  }, dump:function() {
    return this.toString();
  }, rotationAngle:function() {
    return 0;
  }, rotationMatrix:function() {
    return k.create();
  }, rotationAxis:function() {
    return c.create();
  }, scaleFactor:function() {
    return 1;
  }, translation:function() {
    return c.create();
  }};
}, {"./bone":1, "./pointable":14, "gl-matrix":23, underscore:24}], 11:[function(a, d) {
  d.exports = {Controller:a("./controller"), Frame:a("./frame"), Gesture:a("./gesture"), Hand:a("./hand"), Pointable:a("./pointable"), Finger:a("./finger"), InteractionBox:a("./interaction_box"), CircularBuffer:a("./circular_buffer"), UI:a("./ui"), JSONProtocol:a("./protocol").JSONProtocol, glMatrix:a("gl-matrix"), mat3:a("gl-matrix").mat3, vec3:a("gl-matrix").vec3, loopController:void 0, version:a("./version.js"), _:a("underscore"), EventEmitter:a("events").EventEmitter, loop:function(a, d) {
    return a && void 0 === d && "[object Function]" === {}.toString.call(a) && (d = a, a = {}), this.loopController ? a && this.loopController.setupFrameEvents(a) : this.loopController = new this.Controller(a), this.loopController.loop(d), this.loopController;
  }, plugin:function(a, d) {
    this.Controller.plugin(a, d);
  }};
}, {"./circular_buffer":2, "./controller":5, "./finger":7, "./frame":8, "./gesture":9, "./hand":10, "./interaction_box":12, "./pointable":14, "./protocol":15, "./ui":16, "./version.js":19, events:21, "gl-matrix":23, underscore:24}], 12:[function(a, d) {
  var g = a("gl-matrix").vec3;
  a = d.exports = function(a) {
    this.valid = !0;
    this.center = a.center;
    this.size = a.size;
    this.width = a.size[0];
    this.height = a.size[1];
    this.depth = a.size[2];
  };
  a.prototype.denormalizePoint = function(a) {
    return g.fromValues((a[0] - .5) * this.size[0] + this.center[0], (a[1] - .5) * this.size[1] + this.center[1], (a[2] - .5) * this.size[2] + this.center[2]);
  };
  a.prototype.normalizePoint = function(a, e) {
    a = g.fromValues((a[0] - this.center[0]) / this.size[0] + .5, (a[1] - this.center[1]) / this.size[1] + .5, (a[2] - this.center[2]) / this.size[2] + .5);
    return e && (a[0] = Math.min(Math.max(a[0], 0), 1), a[1] = Math.min(Math.max(a[1], 0), 1), a[2] = Math.min(Math.max(a[2], 0), 1)), a;
  };
  a.prototype.toString = function() {
    return "InteractionBox [ width:" + this.width + " | height:" + this.height + " | depth:" + this.depth + " ]";
  };
  a.Invalid = {valid:!1};
}, {"gl-matrix":23}], 13:[function(a, d) {
  a = d.exports = function(a) {
    this.steps = [];
    this.controller = a;
  };
  a.prototype.addStep = function(a) {
    this.steps.push(a);
  };
  a.prototype.run = function(a) {
    for (var d = this.steps.length, e = 0; e != d && a; e++) {
      a = this.steps[e](a);
    }
    return a;
  };
  a.prototype.removeStep = function(a) {
    a = this.steps.indexOf(a);
    if (-1 === a) {
      throw "Step not found in pipeline";
    }
    this.steps.splice(a, 1);
  };
  a.prototype.addWrappedStep = function(a, d) {
    var e = this.controller, k = function(c) {
      var k;
      var h = "frame" == a ? [c] : c[a + "s"] || [];
      var f = 0;
      for (k = h.length; k > f; f++) {
        d.call(e, h[f]);
      }
      return c;
    };
    return this.addStep(k), k;
  };
}, {}], 14:[function(a, d) {
  a = a("gl-matrix");
  d = (a.vec3, d.exports = function(a) {
    this.valid = !0;
    this.id = a.id;
    this.handId = a.handId;
    this.length = a.length;
    this.tool = a.tool;
    this.width = a.width;
    this.direction = a.direction;
    this.stabilizedTipPosition = a.stabilizedTipPosition;
    this.tipPosition = a.tipPosition;
    this.tipVelocity = a.tipVelocity;
    this.touchZone = a.touchZone;
    this.touchDistance = a.touchDistance;
    this.timeVisible = a.timeVisible;
  });
  d.prototype.toString = function() {
    return "Pointable [ id:" + this.id + " " + this.length + "mmx | width:" + this.width + "mm | direction:" + this.direction + " ]";
  };
  d.prototype.hand = function() {
    return this.frame.hand(this.handId);
  };
  d.Invalid = {valid:!1};
}, {"gl-matrix":23}], 15:[function(a, d, g) {
  var h = a("./frame"), e = (a("./hand"), a("./pointable"), a("./finger"), a("underscore")), k = a("events").EventEmitter, c = function(a) {
    this.type = a.type;
    this.state = a.state;
  };
  g.chooseProtocol = function(a) {
    switch(a.version) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
        var c = p(a);
        c.sendBackground = function(a, b) {
          a.send(c.encode({background:b}));
        };
        c.sendFocused = function(a, b) {
          a.send(c.encode({focused:b}));
        };
        c.sendOptimizeHMD = function(a, b) {
          a.send(c.encode({optimizeHMD:b}));
        };
        break;
      default:
        throw "unrecognized version";
    }
    return c;
  };
  var p = g.JSONProtocol = function(a) {
    var d = function(a) {
      if (a.event) {
        return new c(a.event);
      }
      d.emit("beforeFrameCreated", a);
      var b = new h(a);
      return d.emit("afterFrameCreated", b, a), b;
    };
    return d.encode = function(a) {
      return JSON.stringify(a);
    }, d.version = a.version, d.serviceVersion = a.serviceVersion, d.versionLong = "Version " + a.version, d.type = "protocol", e.extend(d, k.prototype), d;
  };
}, {"./finger":7, "./frame":8, "./hand":10, "./pointable":14, events:21, underscore:24}], 16:[function(a, d, g) {
  g.UI = {Region:a("./ui/region"), Cursor:a("./ui/cursor")};
}, {"./ui/cursor":17, "./ui/region":18}], 17:[function(a, d) {
  d.exports = function() {
    return function(a) {
      var d = a.pointables.sort(function(a, d) {
        return a.z - d.z;
      })[0];
      return d && d.valid && (a.cursorPosition = d.tipPosition), a;
    };
  };
}, {}], 18:[function(a, d) {
  var g = a("events").EventEmitter;
  a = a("underscore");
  var h = d.exports = function(a, d) {
    this.start = new Vector(a);
    this.end = new Vector(d);
    this.enteredFrame = null;
  };
  h.prototype.hasPointables = function(a) {
    for (var e = 0; e != a.pointables.length; e++) {
      var c = a.pointables[e].tipPosition;
      if (c.x >= this.start.x && c.x <= this.end.x && c.y >= this.start.y && c.y <= this.end.y && c.z >= this.start.z && c.z <= this.end.z) {
        return !0;
      }
    }
    return !1;
  };
  h.prototype.listener = function(a) {
    var e = this;
    return a && a.nearThreshold && this.setupNearRegion(a.nearThreshold), function(a) {
      return e.updatePosition(a);
    };
  };
  h.prototype.clipper = function() {
    var a = this;
    return function(e) {
      return a.updatePosition(e), a.enteredFrame ? e : null;
    };
  };
  h.prototype.setupNearRegion = function(a) {
    a = this.nearRegion = new h([this.start.x - a, this.start.y - a, this.start.z - a], [this.end.x + a, this.end.y + a, this.end.z + a]);
    var e = this;
    a.on("enter", function(a) {
      e.emit("near", a);
    });
    a.on("exit", function(a) {
      e.emit("far", a);
    });
    e.on("exit", function(a) {
      e.emit("near", a);
    });
  };
  h.prototype.updatePosition = function(a) {
    return this.nearRegion && this.nearRegion.updatePosition(a), this.hasPointables(a) && null == this.enteredFrame ? (this.enteredFrame = a, this.emit("enter", this.enteredFrame)) : this.hasPointables(a) || null == this.enteredFrame || (this.enteredFrame = null, this.emit("exit", this.enteredFrame)), a;
  };
  h.prototype.normalize = function(a) {
    return new Vector([(a.x - this.start.x) / (this.end.x - this.start.x), (a.y - this.start.y) / (this.end.y - this.start.y), (a.z - this.start.z) / (this.end.z - this.start.z)]);
  };
  h.prototype.mapToXY = function(a, d, c) {
    a = this.normalize(a);
    var e = a.x, k = a.y;
    return 1 < e ? e = 1 : -1 > e && (e = -1), 1 < k ? k = 1 : -1 > k && (k = -1), [(e + 1) / 2 * d, (1 - k) / 2 * c, a.z];
  };
  a.extend(h.prototype, g.prototype);
}, {events:21, underscore:24}], 19:[function(a, d) {
  d.exports = {full:"0.6.4", major:0, minor:6, dot:4};
}, {}], 20:[function() {
}, {}], 21:[function(a, d, g) {
  a = a("__browserify_process");
  a.EventEmitter || (a.EventEmitter = function() {
  });
  g = g.EventEmitter = a.EventEmitter;
  var h = "function" == typeof Array.isArray ? Array.isArray : function(a) {
    return "[object Array]" === Object.prototype.toString.call(a);
  };
  g.prototype.setMaxListeners = function(a) {
    this._events || (this._events = {});
    this._events.maxListeners = a;
  };
  g.prototype.emit = function(a) {
    if ("error" === a && (!this._events || !this._events.error || h(this._events.error) && !this._events.error.length)) {
      throw arguments[1] instanceof Error ? arguments[1] : Error("Uncaught, unspecified 'error' event.");
    }
    if (!this._events) {
      return !1;
    }
    var e = this._events[a];
    if (!e) {
      return !1;
    }
    if ("function" == typeof e) {
      switch(arguments.length) {
        case 1:
          e.call(this);
          break;
        case 2:
          e.call(this, arguments[1]);
          break;
        case 3:
          e.call(this, arguments[1], arguments[2]);
          break;
        default:
          var c = Array.prototype.slice.call(arguments, 1);
          e.apply(this, c);
      }
      return !0;
    }
    if (h(e)) {
      c = Array.prototype.slice.call(arguments, 1);
      e = e.slice();
      for (var d = 0, g = e.length; g > d; d++) {
        e[d].apply(this, c);
      }
      return !0;
    }
    return !1;
  };
  g.prototype.addListener = function(a, d) {
    if ("function" != typeof d) {
      throw Error("addListener only takes instances of Function");
    }
    if (this._events || (this._events = {}), this.emit("newListener", a, d), this._events[a]) {
      if (h(this._events[a])) {
        if (!this._events[a].warned) {
          var c;
          (c = void 0 !== this._events.maxListeners ? this._events.maxListeners : 10) && 0 < c && this._events[a].length > c && (this._events[a].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[a].length), console.trace());
        }
        this._events[a].push(d);
      } else {
        this._events[a] = [this._events[a], d];
      }
    } else {
      this._events[a] = d;
    }
    return this;
  };
  g.prototype.on = g.prototype.addListener;
  g.prototype.once = function(a, d) {
    var c = this;
    return c.on(a, function t() {
      c.removeListener(a, t);
      d.apply(this, arguments);
    }), this;
  };
  g.prototype.removeListener = function(a, d) {
    if ("function" != typeof d) {
      throw Error("removeListener only takes instances of Function");
    }
    if (!this._events || !this._events[a]) {
      return this;
    }
    var c = this._events[a];
    if (h(c)) {
      a: {
        if (c.indexOf) {
          d = c.indexOf(d);
        } else {
          for (var e = 0; e < c.length; e++) {
            if (d === c[e]) {
              d = e;
              break a;
            }
          }
          d = -1;
        }
      }
      if (0 > d) {
        return this;
      }
      c.splice(d, 1);
      0 == c.length && delete this._events[a];
    } else {
      this._events[a] === d && delete this._events[a];
    }
    return this;
  };
  g.prototype.removeAllListeners = function(a) {
    return 0 === arguments.length ? (this._events = {}, this) : (a && this._events && this._events[a] && (this._events[a] = null), this);
  };
  g.prototype.listeners = function(a) {
    return this._events || (this._events = {}), this._events[a] || (this._events[a] = []), h(this._events[a]) || (this._events[a] = [this._events[a]]), this._events[a];
  };
  g.listenerCount = function(a, d) {
    return a._events && a._events[d] ? "function" == typeof a._events[d] ? 1 : a._events[d].length : 0;
  };
}, {__browserify_process:22}], 22:[function(a, d) {
  a = d.exports = {};
  a.nextTick = function() {
    if ("undefined" != typeof window && window.setImmediate) {
      return function(a) {
        return window.setImmediate(a);
      };
    }
    if ("undefined" != typeof window && window.postMessage && window.addEventListener) {
      var a = [];
      return window.addEventListener("message", function(d) {
        var e = d.source;
        (e === window || null === e) && "process-tick" === d.data && (d.stopPropagation(), 0 < a.length) && a.shift()();
      }, !0), function(d) {
        a.push(d);
        window.postMessage("process-tick", "*");
      };
    }
    return function(a) {
      setTimeout(a, 0);
    };
  }();
  a.title = "browser";
  a.browser = !0;
  a.env = {};
  a.argv = [];
  a.binding = function() {
    throw Error("process.binding is not supported");
  };
  a.cwd = function() {
    return "/";
  };
  a.chdir = function() {
    throw Error("process.chdir is not supported");
  };
}, {}], 23:[function(a, d, g) {
  !function(a) {
    var e;
    "undefined" == typeof g ? "function" == typeof define && "object" == typeof define.amd && define.amd ? (e = {}, define(function() {
      return e;
    })) : e = "undefined" != typeof window ? window : a : e = g;
    (function(a) {
      if (!c) {
        var c = 1E-6;
      }
      if (!e) {
        var e = "undefined" != typeof Float32Array ? Float32Array : Array;
      }
      if (!d) {
        var d = Math.random;
      }
      var f = {setMatrixArrayType:function(a) {
        e = a;
      }};
      "undefined" != typeof a && (a.glMatrix = f);
      var k = Math.PI / 180;
      f.toRadian = function(a) {
        return a * k;
      };
      var b = {create:function() {
        var a = new e(2);
        return a[0] = 0, a[1] = 0, a;
      }, clone:function(a) {
        var b = new e(2);
        return b[0] = a[0], b[1] = a[1], b;
      }, fromValues:function(a, b) {
        var c = new e(2);
        return c[0] = a, c[1] = b, c;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a;
      }, set:function(a, b, c) {
        return a[0] = b, a[1] = c, a;
      }, add:function(a, b, c) {
        return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a;
      }, subtract:function(a, b, c) {
        return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a;
      }};
      b.sub = b.subtract;
      b.multiply = function(a, b, c) {
        return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a;
      };
      b.mul = b.multiply;
      b.divide = function(a, b, c) {
        return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a;
      };
      b.div = b.divide;
      b.min = function(a, b, c) {
        return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a;
      };
      b.max = function(a, b, c) {
        return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a;
      };
      b.scale = function(a, b, c) {
        return a[0] = b[0] * c, a[1] = b[1] * c, a;
      };
      b.scaleAndAdd = function(a, b, c, e) {
        return a[0] = b[0] + c[0] * e, a[1] = b[1] + c[1] * e, a;
      };
      b.distance = function(a, b) {
        var c = b[0] - a[0];
        a = b[1] - a[1];
        return Math.sqrt(c * c + a * a);
      };
      b.dist = b.distance;
      b.squaredDistance = function(a, b) {
        var c = b[0] - a[0];
        a = b[1] - a[1];
        return c * c + a * a;
      };
      b.sqrDist = b.squaredDistance;
      b.length = function(a) {
        var b = a[0];
        a = a[1];
        return Math.sqrt(b * b + a * a);
      };
      b.len = b.length;
      b.squaredLength = function(a) {
        var b = a[0];
        a = a[1];
        return b * b + a * a;
      };
      b.sqrLen = b.squaredLength;
      b.negate = function(a, b) {
        return a[0] = -b[0], a[1] = -b[1], a;
      };
      b.normalize = function(a, b) {
        var c = b[0], e = b[1];
        c = c * c + e * e;
        return 0 < c && (c = 1 / Math.sqrt(c), a[0] = b[0] * c, a[1] = b[1] * c), a;
      };
      b.dot = function(a, b) {
        return a[0] * b[0] + a[1] * b[1];
      };
      b.cross = function(a, b, c) {
        b = b[0] * c[1] - b[1] * c[0];
        return a[0] = a[1] = 0, a[2] = b, a;
      };
      b.lerp = function(a, b, c, e) {
        var d = b[0];
        b = b[1];
        return a[0] = d + e * (c[0] - d), a[1] = b + e * (c[1] - b), a;
      };
      b.random = function(a, b) {
        b = b || 1;
        var c = 2 * d() * Math.PI;
        return a[0] = Math.cos(c) * b, a[1] = Math.sin(c) * b, a;
      };
      b.transformMat2 = function(a, b, c) {
        var e = b[0];
        b = b[1];
        return a[0] = c[0] * e + c[2] * b, a[1] = c[1] * e + c[3] * b, a;
      };
      b.transformMat2d = function(a, b, c) {
        var e = b[0];
        b = b[1];
        return a[0] = c[0] * e + c[2] * b + c[4], a[1] = c[1] * e + c[3] * b + c[5], a;
      };
      b.transformMat3 = function(a, b, c) {
        var e = b[0];
        b = b[1];
        return a[0] = c[0] * e + c[3] * b + c[6], a[1] = c[1] * e + c[4] * b + c[7], a;
      };
      b.transformMat4 = function(a, b, c) {
        var e = b[0];
        b = b[1];
        return a[0] = c[0] * e + c[4] * b + c[12], a[1] = c[1] * e + c[5] * b + c[13], a;
      };
      b.forEach = function() {
        var a = b.create();
        return function(b, c, e, d, f, k) {
          c || (c = 2);
          e || (e = 0);
          for (d = d ? Math.min(d * c + e, b.length) : b.length; d > e; e += c) {
            a[0] = b[e], a[1] = b[e + 1], f(a, a, k), b[e] = a[0], b[e + 1] = a[1];
          }
          return b;
        };
      }();
      b.str = function(a) {
        return "vec2(" + a[0] + ", " + a[1] + ")";
      };
      "undefined" != typeof a && (a.vec2 = b);
      var m = {create:function() {
        var a = new e(3);
        return a[0] = 0, a[1] = 0, a[2] = 0, a;
      }, clone:function(a) {
        var b = new e(3);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b;
      }, fromValues:function(a, b, c) {
        var d = new e(3);
        return d[0] = a, d[1] = b, d[2] = c, d;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a;
      }, set:function(a, b, c, e) {
        return a[0] = b, a[1] = c, a[2] = e, a;
      }, add:function(a, b, c) {
        return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a[2] = b[2] + c[2], a;
      }, subtract:function(a, b, c) {
        return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a[2] = b[2] - c[2], a;
      }};
      m.sub = m.subtract;
      m.multiply = function(a, b, c) {
        return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a[2] = b[2] * c[2], a;
      };
      m.mul = m.multiply;
      m.divide = function(a, b, c) {
        return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a[2] = b[2] / c[2], a;
      };
      m.div = m.divide;
      m.min = function(a, b, c) {
        return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a[2] = Math.min(b[2], c[2]), a;
      };
      m.max = function(a, b, c) {
        return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a[2] = Math.max(b[2], c[2]), a;
      };
      m.scale = function(a, b, c) {
        return a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a;
      };
      m.scaleAndAdd = function(a, b, c, e) {
        return a[0] = b[0] + c[0] * e, a[1] = b[1] + c[1] * e, a[2] = b[2] + c[2] * e, a;
      };
      m.distance = function(a, b) {
        var c = b[0] - a[0], e = b[1] - a[1];
        a = b[2] - a[2];
        return Math.sqrt(c * c + e * e + a * a);
      };
      m.dist = m.distance;
      m.squaredDistance = function(a, b) {
        var c = b[0] - a[0], e = b[1] - a[1];
        a = b[2] - a[2];
        return c * c + e * e + a * a;
      };
      m.sqrDist = m.squaredDistance;
      m.length = function(a) {
        var b = a[0], c = a[1];
        a = a[2];
        return Math.sqrt(b * b + c * c + a * a);
      };
      m.len = m.length;
      m.squaredLength = function(a) {
        var b = a[0], c = a[1];
        a = a[2];
        return b * b + c * c + a * a;
      };
      m.sqrLen = m.squaredLength;
      m.negate = function(a, b) {
        return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a;
      };
      m.normalize = function(a, b) {
        var c = b[0], e = b[1], d = b[2];
        c = c * c + e * e + d * d;
        return 0 < c && (c = 1 / Math.sqrt(c), a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c), a;
      };
      m.dot = function(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      };
      m.cross = function(a, b, c) {
        var e = b[0], d = b[1];
        b = b[2];
        var f = c[0], k = c[1];
        c = c[2];
        return a[0] = d * c - b * k, a[1] = b * f - e * c, a[2] = e * k - d * f, a;
      };
      m.lerp = function(a, b, c, e) {
        var d = b[0], f = b[1];
        b = b[2];
        return a[0] = d + e * (c[0] - d), a[1] = f + e * (c[1] - f), a[2] = b + e * (c[2] - b), a;
      };
      m.random = function(a, b) {
        b = b || 1;
        var c = 2 * d() * Math.PI, e = 2 * d() - 1, f = Math.sqrt(1 - e * e) * b;
        return a[0] = Math.cos(c) * f, a[1] = Math.sin(c) * f, a[2] = e * b, a;
      };
      m.transformMat4 = function(a, b, c) {
        var e = b[0], d = b[1];
        b = b[2];
        return a[0] = c[0] * e + c[4] * d + c[8] * b + c[12], a[1] = c[1] * e + c[5] * d + c[9] * b + c[13], a[2] = c[2] * e + c[6] * d + c[10] * b + c[14], a;
      };
      m.transformMat3 = function(a, b, c) {
        var e = b[0], d = b[1];
        b = b[2];
        return a[0] = e * c[0] + d * c[3] + b * c[6], a[1] = e * c[1] + d * c[4] + b * c[7], a[2] = e * c[2] + d * c[5] + b * c[8], a;
      };
      m.transformQuat = function(a, b, c) {
        var e = b[0], d = b[1], f = b[2];
        b = c[0];
        var k = c[1], m = c[2];
        c = c[3];
        var h = c * e + k * f - m * d, g = c * d + m * e - b * f, n = c * f + b * d - k * e;
        e = -b * e - k * d - m * f;
        return a[0] = h * c + e * -b + g * -m - n * -k, a[1] = g * c + e * -k + n * -b - h * -m, a[2] = n * c + e * -m + h * -k - g * -b, a;
      };
      m.rotateX = function(a, b, c, e) {
        var d = [], f = [];
        return d[0] = b[0] - c[0], d[1] = b[1] - c[1], d[2] = b[2] - c[2], f[0] = d[0], f[1] = d[1] * Math.cos(e) - d[2] * Math.sin(e), f[2] = d[1] * Math.sin(e) + d[2] * Math.cos(e), a[0] = f[0] + c[0], a[1] = f[1] + c[1], a[2] = f[2] + c[2], a;
      };
      m.rotateY = function(a, b, c, e) {
        var d = [], f = [];
        return d[0] = b[0] - c[0], d[1] = b[1] - c[1], d[2] = b[2] - c[2], f[0] = d[2] * Math.sin(e) + d[0] * Math.cos(e), f[1] = d[1], f[2] = d[2] * Math.cos(e) - d[0] * Math.sin(e), a[0] = f[0] + c[0], a[1] = f[1] + c[1], a[2] = f[2] + c[2], a;
      };
      m.rotateZ = function(a, b, c, e) {
        var d = [], f = [];
        return d[0] = b[0] - c[0], d[1] = b[1] - c[1], d[2] = b[2] - c[2], f[0] = d[0] * Math.cos(e) - d[1] * Math.sin(e), f[1] = d[0] * Math.sin(e) + d[1] * Math.cos(e), f[2] = d[2], a[0] = f[0] + c[0], a[1] = f[1] + c[1], a[2] = f[2] + c[2], a;
      };
      m.forEach = function() {
        var a = m.create();
        return function(b, c, e, d, f, k) {
          c || (c = 3);
          e || (e = 0);
          for (d = d ? Math.min(d * c + e, b.length) : b.length; d > e; e += c) {
            a[0] = b[e], a[1] = b[e + 1], a[2] = b[e + 2], f(a, a, k), b[e] = a[0], b[e + 1] = a[1], b[e + 2] = a[2];
          }
          return b;
        };
      }();
      m.str = function(a) {
        return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
      };
      "undefined" != typeof a && (a.vec3 = m);
      var h = {create:function() {
        var a = new e(4);
        return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 0, a;
      }, clone:function(a) {
        var b = new e(4);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b;
      }, fromValues:function(a, b, c, d) {
        var f = new e(4);
        return f[0] = a, f[1] = b, f[2] = c, f[3] = d, f;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a;
      }, set:function(a, b, c, e, d) {
        return a[0] = b, a[1] = c, a[2] = e, a[3] = d, a;
      }, add:function(a, b, c) {
        return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a[2] = b[2] + c[2], a[3] = b[3] + c[3], a;
      }, subtract:function(a, b, c) {
        return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a[2] = b[2] - c[2], a[3] = b[3] - c[3], a;
      }};
      h.sub = h.subtract;
      h.multiply = function(a, b, c) {
        return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a[2] = b[2] * c[2], a[3] = b[3] * c[3], a;
      };
      h.mul = h.multiply;
      h.divide = function(a, b, c) {
        return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a[2] = b[2] / c[2], a[3] = b[3] / c[3], a;
      };
      h.div = h.divide;
      h.min = function(a, b, c) {
        return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a[2] = Math.min(b[2], c[2]), a[3] = Math.min(b[3], c[3]), a;
      };
      h.max = function(a, b, c) {
        return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a[2] = Math.max(b[2], c[2]), a[3] = Math.max(b[3], c[3]), a;
      };
      h.scale = function(a, b, c) {
        return a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a[3] = b[3] * c, a;
      };
      h.scaleAndAdd = function(a, b, c, e) {
        return a[0] = b[0] + c[0] * e, a[1] = b[1] + c[1] * e, a[2] = b[2] + c[2] * e, a[3] = b[3] + c[3] * e, a;
      };
      h.distance = function(a, b) {
        var c = b[0] - a[0], e = b[1] - a[1], d = b[2] - a[2];
        a = b[3] - a[3];
        return Math.sqrt(c * c + e * e + d * d + a * a);
      };
      h.dist = h.distance;
      h.squaredDistance = function(a, b) {
        var c = b[0] - a[0], e = b[1] - a[1], d = b[2] - a[2];
        a = b[3] - a[3];
        return c * c + e * e + d * d + a * a;
      };
      h.sqrDist = h.squaredDistance;
      h.length = function(a) {
        var b = a[0], c = a[1], e = a[2];
        a = a[3];
        return Math.sqrt(b * b + c * c + e * e + a * a);
      };
      h.len = h.length;
      h.squaredLength = function(a) {
        var b = a[0], c = a[1], e = a[2];
        a = a[3];
        return b * b + c * c + e * e + a * a;
      };
      h.sqrLen = h.squaredLength;
      h.negate = function(a, b) {
        return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a[3] = -b[3], a;
      };
      h.normalize = function(a, b) {
        var c = b[0], e = b[1], d = b[2], f = b[3];
        c = c * c + e * e + d * d + f * f;
        return 0 < c && (c = 1 / Math.sqrt(c), a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a[3] = b[3] * c), a;
      };
      h.dot = function(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
      };
      h.lerp = function(a, b, c, e) {
        var d = b[0], f = b[1], k = b[2];
        b = b[3];
        return a[0] = d + e * (c[0] - d), a[1] = f + e * (c[1] - f), a[2] = k + e * (c[2] - k), a[3] = b + e * (c[3] - b), a;
      };
      h.random = function(a, b) {
        return b = b || 1, a[0] = d(), a[1] = d(), a[2] = d(), a[3] = d(), h.normalize(a, a), h.scale(a, a, b), a;
      };
      h.transformMat4 = function(a, b, c) {
        var e = b[0], d = b[1], f = b[2];
        b = b[3];
        return a[0] = c[0] * e + c[4] * d + c[8] * f + c[12] * b, a[1] = c[1] * e + c[5] * d + c[9] * f + c[13] * b, a[2] = c[2] * e + c[6] * d + c[10] * f + c[14] * b, a[3] = c[3] * e + c[7] * d + c[11] * f + c[15] * b, a;
      };
      h.transformQuat = function(a, b, c) {
        var e = b[0], d = b[1], f = b[2];
        b = c[0];
        var k = c[1], m = c[2];
        c = c[3];
        var h = c * e + k * f - m * d, g = c * d + m * e - b * f, n = c * f + b * d - k * e;
        e = -b * e - k * d - m * f;
        return a[0] = h * c + e * -b + g * -m - n * -k, a[1] = g * c + e * -k + n * -b - h * -m, a[2] = n * c + e * -m + h * -k - g * -b, a;
      };
      h.forEach = function() {
        var a = h.create();
        return function(b, c, e, d, f, k) {
          c || (c = 4);
          e || (e = 0);
          for (d = d ? Math.min(d * c + e, b.length) : b.length; d > e; e += c) {
            a[0] = b[e], a[1] = b[e + 1], a[2] = b[e + 2], a[3] = b[e + 3], f(a, a, k), b[e] = a[0], b[e + 1] = a[1], b[e + 2] = a[2], b[e + 3] = a[3];
          }
          return b;
        };
      }();
      h.str = function(a) {
        return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
      };
      "undefined" != typeof a && (a.vec4 = h);
      f = {create:function() {
        var a = new e(4);
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a;
      }, clone:function(a) {
        var b = new e(4);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a;
      }, identity:function(a) {
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a;
      }, transpose:function(a, b) {
        if (a === b) {
          var c = b[1];
          a[1] = b[2];
          a[2] = c;
        } else {
          a[0] = b[0], a[1] = b[2], a[2] = b[1], a[3] = b[3];
        }
        return a;
      }, invert:function(a, b) {
        var c = b[0], e = b[1], d = b[2];
        b = b[3];
        var f = c * b - d * e;
        return f ? (f = 1 / f, a[0] = b * f, a[1] = -e * f, a[2] = -d * f, a[3] = c * f, a) : null;
      }, adjoint:function(a, b) {
        var c = b[0];
        return a[0] = b[3], a[1] = -b[1], a[2] = -b[2], a[3] = c, a;
      }, determinant:function(a) {
        return a[0] * a[3] - a[2] * a[1];
      }, multiply:function(a, b, c) {
        var e = b[0], d = b[1], f = b[2];
        b = b[3];
        var k = c[0], m = c[1], h = c[2];
        c = c[3];
        return a[0] = e * k + f * m, a[1] = d * k + b * m, a[2] = e * h + f * c, a[3] = d * h + b * c, a;
      }};
      f.mul = f.multiply;
      f.rotate = function(a, b, c) {
        var e = b[0], d = b[1], f = b[2];
        b = b[3];
        var k = Math.sin(c);
        c = Math.cos(c);
        return a[0] = e * c + f * k, a[1] = d * c + b * k, a[2] = e * -k + f * c, a[3] = d * -k + b * c, a;
      };
      f.scale = function(a, b, c) {
        var e = b[1], d = b[2], f = b[3], k = c[0];
        c = c[1];
        return a[0] = b[0] * k, a[1] = e * k, a[2] = d * c, a[3] = f * c, a;
      };
      f.str = function(a) {
        return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
      };
      f.frob = function(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
      };
      f.LDU = function(a, b, c, e) {
        return a[2] = e[2] / e[0], c[0] = e[0], c[1] = e[1], c[3] = e[3] - a[2] * c[1], [a, b, c];
      };
      "undefined" != typeof a && (a.mat2 = f);
      f = {create:function() {
        var a = new e(6);
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a[4] = 0, a[5] = 0, a;
      }, clone:function(a) {
        var b = new e(6);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], a;
      }, identity:function(a) {
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a[4] = 0, a[5] = 0, a;
      }, invert:function(a, b) {
        var c = b[0], e = b[1], d = b[2], f = b[3], k = b[4];
        b = b[5];
        var m = c * f - e * d;
        return m ? (m = 1 / m, a[0] = f * m, a[1] = -e * m, a[2] = -d * m, a[3] = c * m, a[4] = (d * b - f * k) * m, a[5] = (e * k - c * b) * m, a) : null;
      }, determinant:function(a) {
        return a[0] * a[3] - a[1] * a[2];
      }, multiply:function(a, b, c) {
        var e = b[0], d = b[1], f = b[2], k = b[3], m = b[4];
        b = b[5];
        var h = c[0], g = c[1], n = c[2], r = c[3], p = c[4];
        c = c[5];
        return a[0] = e * h + f * g, a[1] = d * h + k * g, a[2] = e * n + f * r, a[3] = d * n + k * r, a[4] = e * p + f * c + m, a[5] = d * p + k * c + b, a;
      }};
      f.mul = f.multiply;
      f.rotate = function(a, b, c) {
        var e = b[0], d = b[1], f = b[2], k = b[3], m = b[4];
        b = b[5];
        var h = Math.sin(c);
        c = Math.cos(c);
        return a[0] = e * c + f * h, a[1] = d * c + k * h, a[2] = e * -h + f * c, a[3] = d * -h + k * c, a[4] = m, a[5] = b, a;
      };
      f.scale = function(a, b, c) {
        var e = b[1], d = b[2], f = b[3], k = b[4], m = b[5], h = c[0];
        c = c[1];
        return a[0] = b[0] * h, a[1] = e * h, a[2] = d * c, a[3] = f * c, a[4] = k, a[5] = m, a;
      };
      f.translate = function(a, b, c) {
        var e = b[0], d = b[1], f = b[2], k = b[3], m = b[4];
        b = b[5];
        var h = c[0];
        c = c[1];
        return a[0] = e, a[1] = d, a[2] = f, a[3] = k, a[4] = e * h + f * c + m, a[5] = d * h + k * c + b, a;
      };
      f.str = function(a) {
        return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
      };
      f.frob = function(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
      };
      "undefined" != typeof a && (a.mat2d = f);
      var g = {create:function() {
        var a = new e(9);
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 1, a[5] = 0, a[6] = 0, a[7] = 0, a[8] = 1, a;
      }, fromMat4:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[4], a[4] = b[5], a[5] = b[6], a[6] = b[8], a[7] = b[9], a[8] = b[10], a;
      }, clone:function(a) {
        var b = new e(9);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], b;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[8] = b[8], a;
      }, identity:function(a) {
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 1, a[5] = 0, a[6] = 0, a[7] = 0, a[8] = 1, a;
      }, transpose:function(a, b) {
        if (a === b) {
          var c = b[1], e = b[2], d = b[5];
          a[1] = b[3];
          a[2] = b[6];
          a[3] = c;
          a[5] = b[7];
          a[6] = e;
          a[7] = d;
        } else {
          a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], a[6] = b[2], a[7] = b[5], a[8] = b[8];
        }
        return a;
      }, invert:function(a, b) {
        var c = b[0], e = b[1], d = b[2], f = b[3], k = b[4], m = b[5], h = b[6], g = b[7];
        b = b[8];
        var n = b * k - m * g, p = -b * f + m * h, r = g * f - k * h, u = c * n + e * p + d * r;
        return u ? (u = 1 / u, a[0] = n * u, a[1] = (-b * e + d * g) * u, a[2] = (m * e - d * k) * u, a[3] = p * u, a[4] = (b * c - d * h) * u, a[5] = (-m * c + d * f) * u, a[6] = r * u, a[7] = (-g * c + e * h) * u, a[8] = (k * c - e * f) * u, a) : null;
      }, adjoint:function(a, b) {
        var c = b[0], e = b[1], d = b[2], f = b[3], k = b[4], m = b[5], h = b[6], g = b[7];
        b = b[8];
        return a[0] = k * b - m * g, a[1] = d * g - e * b, a[2] = e * m - d * k, a[3] = m * h - f * b, a[4] = c * b - d * h, a[5] = d * f - c * m, a[6] = f * g - k * h, a[7] = e * h - c * g, a[8] = c * k - e * f, a;
      }, determinant:function(a) {
        var b = a[3], c = a[4], e = a[5], d = a[6], f = a[7], k = a[8];
        return a[0] * (k * c - e * f) + a[1] * (-k * b + e * d) + a[2] * (f * b - c * d);
      }, multiply:function(a, b, c) {
        var e = b[0], d = b[1], f = b[2], k = b[3], m = b[4], h = b[5], g = b[6], n = b[7];
        b = b[8];
        var p = c[0], r = c[1], q = c[2], u = c[3], t = c[4], v = c[5], x = c[6], y = c[7];
        c = c[8];
        return a[0] = p * e + r * k + q * g, a[1] = p * d + r * m + q * n, a[2] = p * f + r * h + q * b, a[3] = u * e + t * k + v * g, a[4] = u * d + t * m + v * n, a[5] = u * f + t * h + v * b, a[6] = x * e + y * k + c * g, a[7] = x * d + y * m + c * n, a[8] = x * f + y * h + c * b, a;
      }};
      g.mul = g.multiply;
      g.translate = function(a, b, c) {
        var e = b[0], d = b[1], f = b[2], k = b[3], m = b[4], h = b[5], g = b[6], n = b[7];
        b = b[8];
        var p = c[0];
        c = c[1];
        return a[0] = e, a[1] = d, a[2] = f, a[3] = k, a[4] = m, a[5] = h, a[6] = p * e + c * k + g, a[7] = p * d + c * m + n, a[8] = p * f + c * h + b, a;
      };
      g.rotate = function(a, b, c) {
        var e = b[0], d = b[1], f = b[2], k = b[3], m = b[4], h = b[5], g = b[6], n = b[7];
        b = b[8];
        var p = Math.sin(c);
        c = Math.cos(c);
        return a[0] = c * e + p * k, a[1] = c * d + p * m, a[2] = c * f + p * h, a[3] = c * k - p * e, a[4] = c * m - p * d, a[5] = c * h - p * f, a[6] = g, a[7] = n, a[8] = b, a;
      };
      g.scale = function(a, b, c) {
        var e = c[0];
        c = c[1];
        return a[0] = e * b[0], a[1] = e * b[1], a[2] = e * b[2], a[3] = c * b[3], a[4] = c * b[4], a[5] = c * b[5], a[6] = b[6], a[7] = b[7], a[8] = b[8], a;
      };
      g.fromMat2d = function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = 0, a[3] = b[2], a[4] = b[3], a[5] = 0, a[6] = b[4], a[7] = b[5], a[8] = 1, a;
      };
      g.fromQuat = function(a, b) {
        var c = b[0], e = b[1], d = b[2];
        b = b[3];
        var f = c + c, k = e + e, m = d + d;
        c *= f;
        var h = e * f;
        e *= k;
        var g = d * f, n = d * k;
        d *= m;
        f *= b;
        k *= b;
        b *= m;
        return a[0] = 1 - e - d, a[3] = h - b, a[6] = g + k, a[1] = h + b, a[4] = 1 - c - d, a[7] = n - f, a[2] = g - k, a[5] = n + f, a[8] = 1 - c - e, a;
      };
      g.normalFromMat4 = function(a, b) {
        var c = b[0], e = b[1], d = b[2], f = b[3], k = b[4], m = b[5], h = b[6], g = b[7], n = b[8], p = b[9], r = b[10], q = b[11], t = b[12], u = b[13], x = b[14];
        b = b[15];
        var y = c * m - e * k, z = c * h - d * k, R = c * g - f * k, W = e * h - d * m, O = e * g - f * m, ca = d * g - f * h, M = n * u - p * t, V = n * x - r * t;
        n = n * b - q * t;
        var fa = p * x - r * u;
        p = p * b - q * u;
        r = r * b - q * x;
        return (q = y * r - z * p + R * fa + W * n - O * V + ca * M) ? (q = 1 / q, a[0] = (m * r - h * p + g * fa) * q, a[1] = (h * n - k * r - g * V) * q, a[2] = (k * p - m * n + g * M) * q, a[3] = (d * p - e * r - f * fa) * q, a[4] = (c * r - d * n + f * V) * q, a[5] = (e * n - c * p - f * M) * q, a[6] = (u * ca - x * O + b * W) * q, a[7] = (x * R - t * ca - b * z) * q, a[8] = (t * O - u * R + b * y) * q, a) : null;
      };
      g.str = function(a) {
        return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
      };
      g.frob = function(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
      };
      "undefined" != typeof a && (a.mat3 = g);
      var x = {create:function() {
        var a = new e(16);
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
      }, clone:function(a) {
        var b = new e(16);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], b[9] = a[9], b[10] = a[10], b[11] = a[11], b[12] = a[12], b[13] = a[13], b[14] = a[14], b[15] = a[15], b;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[8] = b[8], a[9] = b[9], a[10] = b[10], a[11] = b[11], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15], a;
      }, identity:function(a) {
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
      }, transpose:function(a, b) {
        if (a === b) {
          var c = b[1], e = b[2], d = b[3], f = b[6], k = b[7], m = b[11];
          a[1] = b[4];
          a[2] = b[8];
          a[3] = b[12];
          a[4] = c;
          a[6] = b[9];
          a[7] = b[13];
          a[8] = e;
          a[9] = f;
          a[11] = b[14];
          a[12] = d;
          a[13] = k;
          a[14] = m;
        } else {
          a[0] = b[0], a[1] = b[4], a[2] = b[8], a[3] = b[12], a[4] = b[1], a[5] = b[5], a[6] = b[9], a[7] = b[13], a[8] = b[2], a[9] = b[6], a[10] = b[10], a[11] = b[14], a[12] = b[3], a[13] = b[7], a[14] = b[11], a[15] = b[15];
        }
        return a;
      }, invert:function(a, b) {
        var c = b[0], e = b[1], d = b[2], f = b[3], k = b[4], m = b[5], h = b[6], g = b[7], n = b[8], p = b[9], r = b[10], q = b[11], t = b[12], u = b[13], x = b[14];
        b = b[15];
        var y = c * m - e * k, z = c * h - d * k, R = c * g - f * k, W = e * h - d * m, O = e * g - f * m, ca = d * g - f * h, M = n * u - p * t, V = n * x - r * t, fa = n * b - q * t, ja = p * x - r * u, X = p * b - q * u, ea = r * b - q * x, Y = y * ea - z * X + R * ja + W * fa - O * V + ca * M;
        return Y ? (Y = 1 / Y, a[0] = (m * ea - h * X + g * ja) * Y, a[1] = (d * X - e * ea - f * ja) * Y, a[2] = (u * ca - x * O + b * W) * Y, a[3] = (r * O - p * ca - q * W) * Y, a[4] = (h * fa - k * ea - g * V) * Y, a[5] = (c * ea - d * fa + f * V) * Y, a[6] = (x * R - t * ca - b * z) * Y, a[7] = (n * ca - r * R + q * z) * Y, a[8] = (k * X - m * fa + g * M) * Y, a[9] = (e * fa - c * X - f * M) * Y, a[10] = (t * O - u * R + b * y) * Y, a[11] = (p * R - n * O - q * y) * Y, a[12] = (m * V - k * ja - 
        h * M) * Y, a[13] = (c * ja - e * V + d * M) * Y, a[14] = (u * z - t * W - x * y) * Y, a[15] = (n * W - p * z + r * y) * Y, a) : null;
      }, adjoint:function(a, b) {
        var c = b[0], e = b[1], d = b[2], f = b[3], k = b[4], m = b[5], h = b[6], g = b[7], n = b[8], p = b[9], r = b[10], q = b[11], t = b[12], u = b[13], x = b[14];
        b = b[15];
        return a[0] = m * (r * b - q * x) - p * (h * b - g * x) + u * (h * q - g * r), a[1] = -(e * (r * b - q * x) - p * (d * b - f * x) + u * (d * q - f * r)), a[2] = e * (h * b - g * x) - m * (d * b - f * x) + u * (d * g - f * h), a[3] = -(e * (h * q - g * r) - m * (d * q - f * r) + p * (d * g - f * h)), a[4] = -(k * (r * b - q * x) - n * (h * b - g * x) + t * (h * q - g * r)), a[5] = c * (r * b - q * x) - n * (d * b - f * x) + t * (d * q - f * r), a[6] = -(c * (h * b - g * x) - k * (d * b - f * 
        x) + t * (d * g - f * h)), a[7] = c * (h * q - g * r) - k * (d * q - f * r) + n * (d * g - f * h), a[8] = k * (p * b - q * u) - n * (m * b - g * u) + t * (m * q - g * p), a[9] = -(c * (p * b - q * u) - n * (e * b - f * u) + t * (e * q - f * p)), a[10] = c * (m * b - g * u) - k * (e * b - f * u) + t * (e * g - f * m), a[11] = -(c * (m * q - g * p) - k * (e * q - f * p) + n * (e * g - f * m)), a[12] = -(k * (p * x - r * u) - n * (m * x - h * u) + t * (m * r - h * p)), a[13] = c * (p * x - r * 
        u) - n * (e * x - d * u) + t * (e * r - d * p), a[14] = -(c * (m * x - h * u) - k * (e * x - d * u) + t * (e * h - d * m)), a[15] = c * (m * r - h * p) - k * (e * r - d * p) + n * (e * h - d * m), a;
      }, determinant:function(a) {
        var b = a[0], c = a[1], e = a[2], d = a[3], f = a[4], k = a[5], m = a[6], h = a[7], g = a[8], n = a[9], p = a[10], r = a[11], q = a[12], t = a[13], x = a[14];
        a = a[15];
        return (b * k - c * f) * (p * a - r * x) - (b * m - e * f) * (n * a - r * t) + (b * h - d * f) * (n * x - p * t) + (c * m - e * k) * (g * a - r * q) - (c * h - d * k) * (g * x - p * q) + (e * h - d * m) * (g * t - n * q);
      }, multiply:function(a, b, c) {
        var e = b[0], d = b[1], f = b[2], k = b[3], m = b[4], h = b[5], g = b[6], n = b[7], p = b[8], q = b[9], r = b[10], t = b[11], u = b[12], v = b[13], x = b[14];
        b = b[15];
        var y = c[0], z = c[1], W = c[2], O = c[3];
        return a[0] = y * e + z * m + W * p + O * u, a[1] = y * d + z * h + W * q + O * v, a[2] = y * f + z * g + W * r + O * x, a[3] = y * k + z * n + W * t + O * b, y = c[4], z = c[5], W = c[6], O = c[7], a[4] = y * e + z * m + W * p + O * u, a[5] = y * d + z * h + W * q + O * v, a[6] = y * f + z * g + W * r + O * x, a[7] = y * k + z * n + W * t + O * b, y = c[8], z = c[9], W = c[10], O = c[11], a[8] = y * e + z * m + W * p + O * u, a[9] = y * d + z * h + W * q + O * v, a[10] = y * f + z * g + 
        W * r + O * x, a[11] = y * k + z * n + W * t + O * b, y = c[12], z = c[13], W = c[14], O = c[15], a[12] = y * e + z * m + W * p + O * u, a[13] = y * d + z * h + W * q + O * v, a[14] = y * f + z * g + W * r + O * x, a[15] = y * k + z * n + W * t + O * b, a;
      }};
      x.mul = x.multiply;
      x.translate = function(a, b, c) {
        var e, d, f, k, m, h, g, n, p, q, r, t, u = c[0], v = c[1];
        c = c[2];
        return b === a ? (a[12] = b[0] * u + b[4] * v + b[8] * c + b[12], a[13] = b[1] * u + b[5] * v + b[9] * c + b[13], a[14] = b[2] * u + b[6] * v + b[10] * c + b[14], a[15] = b[3] * u + b[7] * v + b[11] * c + b[15]) : (e = b[0], d = b[1], f = b[2], k = b[3], m = b[4], h = b[5], g = b[6], n = b[7], p = b[8], q = b[9], r = b[10], t = b[11], a[0] = e, a[1] = d, a[2] = f, a[3] = k, a[4] = m, a[5] = h, a[6] = g, a[7] = n, a[8] = p, a[9] = q, a[10] = r, a[11] = t, a[12] = e * u + m * v + p * c + b[12], 
        a[13] = d * u + h * v + q * c + b[13], a[14] = f * u + g * v + r * c + b[14], a[15] = k * u + n * v + t * c + b[15]), a;
      };
      x.scale = function(a, b, c) {
        var e = c[0], d = c[1];
        c = c[2];
        return a[0] = b[0] * e, a[1] = b[1] * e, a[2] = b[2] * e, a[3] = b[3] * e, a[4] = b[4] * d, a[5] = b[5] * d, a[6] = b[6] * d, a[7] = b[7] * d, a[8] = b[8] * c, a[9] = b[9] * c, a[10] = b[10] * c, a[11] = b[11] * c, a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15], a;
      };
      x.rotate = function(a, b, e, d) {
        var f, k, m, h, g, n, p, q, r, t, u, v, x, y, z, C, W, O, ca, M, V, fa, ja, X, ea = d[0], Y = d[1];
        d = d[2];
        var T = Math.sqrt(ea * ea + Y * Y + d * d);
        return Math.abs(T) < c ? null : (T = 1 / T, ea *= T, Y *= T, d *= T, f = Math.sin(e), k = Math.cos(e), m = 1 - k, h = b[0], g = b[1], n = b[2], p = b[3], q = b[4], r = b[5], t = b[6], u = b[7], v = b[8], x = b[9], y = b[10], z = b[11], C = ea * ea * m + k, W = Y * ea * m + d * f, O = d * ea * m - Y * f, ca = ea * Y * m - d * f, M = Y * Y * m + k, V = d * Y * m + ea * f, fa = ea * d * m + Y * f, ja = Y * d * m - ea * f, X = d * d * m + k, a[0] = h * C + q * W + v * O, a[1] = g * C + r * W + 
        x * O, a[2] = n * C + t * W + y * O, a[3] = p * C + u * W + z * O, a[4] = h * ca + q * M + v * V, a[5] = g * ca + r * M + x * V, a[6] = n * ca + t * M + y * V, a[7] = p * ca + u * M + z * V, a[8] = h * fa + q * ja + v * X, a[9] = g * fa + r * ja + x * X, a[10] = n * fa + t * ja + y * X, a[11] = p * fa + u * ja + z * X, b !== a && (a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a);
      };
      x.rotateX = function(a, b, c) {
        var e = Math.sin(c);
        c = Math.cos(c);
        var d = b[4], f = b[5], k = b[6], m = b[7], h = b[8], g = b[9], n = b[10], p = b[11];
        return b !== a && (a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[4] = d * c + h * e, a[5] = f * c + g * e, a[6] = k * c + n * e, a[7] = m * c + p * e, a[8] = h * c - d * e, a[9] = g * c - f * e, a[10] = n * c - k * e, a[11] = p * c - m * e, a;
      };
      x.rotateY = function(a, b, c) {
        var e = Math.sin(c);
        c = Math.cos(c);
        var d = b[0], f = b[1], k = b[2], m = b[3], h = b[8], g = b[9], n = b[10], p = b[11];
        return b !== a && (a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[0] = d * c - h * e, a[1] = f * c - g * e, a[2] = k * c - n * e, a[3] = m * c - p * e, a[8] = d * e + h * c, a[9] = f * e + g * c, a[10] = k * e + n * c, a[11] = m * e + p * c, a;
      };
      x.rotateZ = function(a, b, c) {
        var e = Math.sin(c);
        c = Math.cos(c);
        var d = b[0], f = b[1], k = b[2], m = b[3], h = b[4], g = b[5], n = b[6], p = b[7];
        return b !== a && (a[8] = b[8], a[9] = b[9], a[10] = b[10], a[11] = b[11], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[0] = d * c + h * e, a[1] = f * c + g * e, a[2] = k * c + n * e, a[3] = m * c + p * e, a[4] = h * c - d * e, a[5] = g * c - f * e, a[6] = n * c - k * e, a[7] = p * c - m * e, a;
      };
      x.fromRotationTranslation = function(a, b, c) {
        var e = b[0], d = b[1], f = b[2], k = b[3], m = e + e, h = d + d, g = f + f;
        b = e * m;
        var n = e * h;
        e *= g;
        var p = d * h;
        d *= g;
        f *= g;
        m *= k;
        h *= k;
        k *= g;
        return a[0] = 1 - (p + f), a[1] = n + k, a[2] = e - h, a[3] = 0, a[4] = n - k, a[5] = 1 - (b + f), a[6] = d + m, a[7] = 0, a[8] = e + h, a[9] = d - m, a[10] = 1 - (b + p), a[11] = 0, a[12] = c[0], a[13] = c[1], a[14] = c[2], a[15] = 1, a;
      };
      x.fromQuat = function(a, b) {
        var c = b[0], e = b[1], d = b[2];
        b = b[3];
        var f = c + c, k = e + e, m = d + d;
        c *= f;
        var h = e * f;
        e *= k;
        var g = d * f, n = d * k;
        d *= m;
        f *= b;
        k *= b;
        b *= m;
        return a[0] = 1 - e - d, a[1] = h + b, a[2] = g - k, a[3] = 0, a[4] = h - b, a[5] = 1 - c - d, a[6] = n + f, a[7] = 0, a[8] = g + k, a[9] = n - f, a[10] = 1 - c - e, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
      };
      x.frustum = function(a, b, c, e, d, f, k) {
        var m = 1 / (c - b), h = 1 / (d - e), g = 1 / (f - k);
        return a[0] = 2 * f * m, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 * f * h, a[6] = 0, a[7] = 0, a[8] = (c + b) * m, a[9] = (d + e) * h, a[10] = (k + f) * g, a[11] = -1, a[12] = 0, a[13] = 0, a[14] = k * f * 2 * g, a[15] = 0, a;
      };
      x.perspective = function(a, b, c, e, d) {
        b = 1 / Math.tan(b / 2);
        var f = 1 / (e - d);
        return a[0] = b / c, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = b, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = (d + e) * f, a[11] = -1, a[12] = 0, a[13] = 0, a[14] = 2 * d * e * f, a[15] = 0, a;
      };
      x.ortho = function(a, b, c, e, d, f, k) {
        var m = 1 / (b - c), h = 1 / (e - d), g = 1 / (f - k);
        return a[0] = -2 * m, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = -2 * h, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 2 * g, a[11] = 0, a[12] = (b + c) * m, a[13] = (d + e) * h, a[14] = (k + f) * g, a[15] = 1, a;
      };
      x.lookAt = function(a, b, e, d) {
        var f, k, m, h, g, n, p, q, t, r, u = b[0], v = b[1];
        b = b[2];
        var y = d[0], z = d[1];
        d = d[2];
        var C = e[0], R = e[1];
        e = e[2];
        return Math.abs(u - C) < c && Math.abs(v - R) < c && Math.abs(b - e) < c ? x.identity(a) : (p = u - C, q = v - R, t = b - e, r = 1 / Math.sqrt(p * p + q * q + t * t), p *= r, q *= r, t *= r, f = z * t - d * q, k = d * p - y * t, m = y * q - z * p, r = Math.sqrt(f * f + k * k + m * m), r ? (r = 1 / r, f *= r, k *= r, m *= r) : (f = 0, k = 0, m = 0), h = q * m - t * k, g = t * f - p * m, n = p * k - q * f, r = Math.sqrt(h * h + g * g + n * n), r ? (r = 1 / r, h *= r, g *= r, n *= r) : (h = 
        0, g = 0, n = 0), a[0] = f, a[1] = h, a[2] = p, a[3] = 0, a[4] = k, a[5] = g, a[6] = q, a[7] = 0, a[8] = m, a[9] = n, a[10] = t, a[11] = 0, a[12] = -(f * u + k * v + m * b), a[13] = -(h * u + g * v + n * b), a[14] = -(p * u + q * v + t * b), a[15] = 1, a);
      };
      x.str = function(a) {
        return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
      };
      x.frob = function(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
      };
      "undefined" != typeof a && (a.mat4 = x);
      var z = {create:function() {
        var a = new e(4);
        return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a;
      }};
      z.rotationTo = function() {
        var a = m.create(), b = m.fromValues(1, 0, 0), c = m.fromValues(0, 1, 0);
        return function(e, d, f) {
          var k = m.dot(d, f);
          return -.999999 > k ? (m.cross(a, b, d), 1E-6 > m.length(a) && m.cross(a, c, d), m.normalize(a, a), z.setAxisAngle(e, a, Math.PI), e) : .999999 < k ? (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e) : (m.cross(a, d, f), e[0] = a[0], e[1] = a[1], e[2] = a[2], e[3] = 1 + k, z.normalize(e, e));
        };
      }();
      z.setAxes = function() {
        var a = g.create();
        return function(b, c, e, d) {
          return a[0] = e[0], a[3] = e[1], a[6] = e[2], a[1] = d[0], a[4] = d[1], a[7] = d[2], a[2] = -c[0], a[5] = -c[1], a[8] = -c[2], z.normalize(b, z.fromMat3(b, a));
        };
      }();
      z.clone = h.clone;
      z.fromValues = h.fromValues;
      z.copy = h.copy;
      z.set = h.set;
      z.identity = function(a) {
        return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a;
      };
      z.setAxisAngle = function(a, b, c) {
        c *= .5;
        var e = Math.sin(c);
        return a[0] = e * b[0], a[1] = e * b[1], a[2] = e * b[2], a[3] = Math.cos(c), a;
      };
      z.add = h.add;
      z.multiply = function(a, b, c) {
        var e = b[0], d = b[1], f = b[2];
        b = b[3];
        var k = c[0], m = c[1], h = c[2];
        c = c[3];
        return a[0] = e * c + b * k + d * h - f * m, a[1] = d * c + b * m + f * k - e * h, a[2] = f * c + b * h + e * m - d * k, a[3] = b * c - e * k - d * m - f * h, a;
      };
      z.mul = z.multiply;
      z.scale = h.scale;
      z.rotateX = function(a, b, c) {
        c *= .5;
        var e = b[0], d = b[1], f = b[2];
        b = b[3];
        var k = Math.sin(c);
        c = Math.cos(c);
        return a[0] = e * c + b * k, a[1] = d * c + f * k, a[2] = f * c - d * k, a[3] = b * c - e * k, a;
      };
      z.rotateY = function(a, b, c) {
        c *= .5;
        var e = b[0], d = b[1], f = b[2];
        b = b[3];
        var k = Math.sin(c);
        c = Math.cos(c);
        return a[0] = e * c - f * k, a[1] = d * c + b * k, a[2] = f * c + e * k, a[3] = b * c - d * k, a;
      };
      z.rotateZ = function(a, b, c) {
        c *= .5;
        var e = b[0], d = b[1], f = b[2];
        b = b[3];
        var k = Math.sin(c);
        c = Math.cos(c);
        return a[0] = e * c + d * k, a[1] = d * c - e * k, a[2] = f * c + b * k, a[3] = b * c - f * k, a;
      };
      z.calculateW = function(a, b) {
        var c = b[0], e = b[1];
        b = b[2];
        return a[0] = c, a[1] = e, a[2] = b, a[3] = -Math.sqrt(Math.abs(1 - c * c - e * e - b * b)), a;
      };
      z.dot = h.dot;
      z.lerp = h.lerp;
      z.slerp = function(a, b, c, e) {
        var d, f, k, m, h, g = b[0], n = b[1], p = b[2];
        b = b[3];
        var q = c[0], t = c[1], r = c[2];
        c = c[3];
        return f = g * q + n * t + p * r + b * c, 0 > f && (f = -f, q = -q, t = -t, r = -r, c = -c), 1E-6 < 1 - f ? (d = Math.acos(f), k = Math.sin(d), m = Math.sin((1 - e) * d) / k, h = Math.sin(e * d) / k) : (m = 1 - e, h = e), a[0] = m * g + h * q, a[1] = m * n + h * t, a[2] = m * p + h * r, a[3] = m * b + h * c, a;
      };
      z.invert = function(a, b) {
        var c = b[0], e = b[1], d = b[2];
        b = b[3];
        var f = c * c + e * e + d * d + b * b;
        f = f ? 1 / f : 0;
        return a[0] = -c * f, a[1] = -e * f, a[2] = -d * f, a[3] = b * f, a;
      };
      z.conjugate = function(a, b) {
        return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a[3] = b[3], a;
      };
      z.length = h.length;
      z.len = z.length;
      z.squaredLength = h.squaredLength;
      z.sqrLen = z.squaredLength;
      z.normalize = h.normalize;
      z.fromMat3 = function(a, b) {
        var c = b[0] + b[4] + b[8];
        if (0 < c) {
          c = Math.sqrt(c + 1), a[3] = .5 * c, c = .5 / c, a[0] = (b[7] - b[5]) * c, a[1] = (b[2] - b[6]) * c, a[2] = (b[3] - b[1]) * c;
        } else {
          var e = 0;
          b[4] > b[0] && (e = 1);
          b[8] > b[3 * e + e] && (e = 2);
          var d = (e + 1) % 3, f = (e + 2) % 3;
          c = Math.sqrt(b[3 * e + e] - b[3 * d + d] - b[3 * f + f] + 1);
          a[e] = .5 * c;
          c = .5 / c;
          a[3] = (b[3 * f + d] - b[3 * d + f]) * c;
          a[d] = (b[3 * d + e] + b[3 * e + d]) * c;
          a[f] = (b[3 * f + e] + b[3 * e + f]) * c;
        }
        return a;
      };
      z.str = function(a) {
        return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
      };
      "undefined" != typeof a && (a.quat = z);
    })(e);
  }(this);
}, {}], 24:[function(a, d, g) {
  (function() {
    var a = this, e = a._, k = {}, c = Array.prototype, p = Object.prototype, t = c.push, f = c.slice, n = c.concat, b = p.toString, m = p.hasOwnProperty, q = c.forEach, y = c.map, x = c.reduce, z = c.reduceRight, r = c.filter, u = c.every, v = c.some, C = c.indexOf, A = c.lastIndexOf;
    p = Array.isArray;
    var D = Object.keys, F = Function.prototype.bind, B = function(a) {
      return a instanceof B ? a : this instanceof B ? void(this._wrapped = a) : new B(a);
    };
    "undefined" != typeof g ? ("undefined" != typeof d && d.exports && (g = d.exports = B), g._ = B) : a._ = B;
    B.VERSION = "1.4.4";
    var E = B.each = B.forEach = function(a, b, c) {
      if (null != a) {
        if (q && a.forEach === q) {
          a.forEach(b, c);
        } else {
          if (a.length === +a.length) {
            for (var e = 0, d = a.length; d > e && b.call(c, a[e], e, a) !== k; e++) {
            }
          } else {
            for (e in a) {
              if (B.has(a, e) && b.call(c, a[e], e, a) === k) {
                break;
              }
            }
          }
        }
      }
    };
    B.map = B.collect = function(a, b, c) {
      var e = [];
      return null == a ? e : y && a.map === y ? a.map(b, c) : (E(a, function(a, d, f) {
        e[e.length] = b.call(c, a, d, f);
      }), e);
    };
    B.reduce = B.foldl = B.inject = function(a, b, c, e) {
      var d = 2 < arguments.length;
      if (null == a && (a = []), x && a.reduce === x) {
        return e && (b = B.bind(b, e)), d ? a.reduce(b, c) : a.reduce(b);
      }
      if (E(a, function(a, f, k) {
        d ? c = b.call(e, c, a, f, k) : (c = a, d = !0);
      }), !d) {
        throw new TypeError("Reduce of empty array with no initial value");
      }
      return c;
    };
    B.reduceRight = B.foldr = function(a, b, c, e) {
      var d = 2 < arguments.length;
      if (null == a && (a = []), z && a.reduceRight === z) {
        return e && (b = B.bind(b, e)), d ? a.reduceRight(b, c) : a.reduceRight(b);
      }
      var f = a.length;
      if (f !== +f) {
        var k = B.keys(a);
        f = k.length;
      }
      if (E(a, function(m, h, g) {
        h = k ? k[--f] : --f;
        d ? c = b.call(e, c, a[h], h, g) : (c = a[h], d = !0);
      }), !d) {
        throw new TypeError("Reduce of empty array with no initial value");
      }
      return c;
    };
    B.find = B.detect = function(a, b, c) {
      var e;
      return H(a, function(a, d, f) {
        return b.call(c, a, d, f) ? (e = a, !0) : void 0;
      }), e;
    };
    B.filter = B.select = function(a, b, c) {
      var e = [];
      return null == a ? e : r && a.filter === r ? a.filter(b, c) : (E(a, function(a, d, f) {
        b.call(c, a, d, f) && (e[e.length] = a);
      }), e);
    };
    B.reject = function(a, b, c) {
      return B.filter(a, function(a, e, d) {
        return !b.call(c, a, e, d);
      }, c);
    };
    B.every = B.all = function(a, b, c) {
      b || (b = B.identity);
      var e = !0;
      return null == a ? e : u && a.every === u ? a.every(b, c) : (E(a, function(a, d, f) {
        return (e = e && b.call(c, a, d, f)) ? void 0 : k;
      }), !!e);
    };
    var H = B.some = B.any = function(a, b, c) {
      b || (b = B.identity);
      var e = !1;
      return null == a ? e : v && a.some === v ? a.some(b, c) : (E(a, function(a, d, f) {
        return e || (e = b.call(c, a, d, f)) ? k : void 0;
      }), !!e);
    };
    B.contains = B.include = function(a, b) {
      return null == a ? !1 : C && a.indexOf === C ? -1 != a.indexOf(b) : H(a, function(a) {
        return a === b;
      });
    };
    B.invoke = function(a, b) {
      var c = f.call(arguments, 2), e = B.isFunction(b);
      return B.map(a, function(a) {
        return (e ? b : a[b]).apply(a, c);
      });
    };
    B.pluck = function(a, b) {
      return B.map(a, function(a) {
        return a[b];
      });
    };
    B.where = function(a, b, c) {
      return B.isEmpty(b) ? c ? null : [] : B[c ? "find" : "filter"](a, function(a) {
        for (var c in b) {
          if (b[c] !== a[c]) {
            return !1;
          }
        }
        return !0;
      });
    };
    B.findWhere = function(a, b) {
      return B.where(a, b, !0);
    };
    B.max = function(a, b, c) {
      if (!b && B.isArray(a) && a[0] === +a[0] && 65535 > a.length) {
        return Math.max.apply(Math, a);
      }
      if (!b && B.isEmpty(a)) {
        return -1 / 0;
      }
      var e = {computed:-1 / 0, value:-1 / 0};
      return E(a, function(a, d, f) {
        d = b ? b.call(c, a, d, f) : a;
        d >= e.computed && (e = {value:a, computed:d});
      }), e.value;
    };
    B.min = function(a, b, c) {
      if (!b && B.isArray(a) && a[0] === +a[0] && 65535 > a.length) {
        return Math.min.apply(Math, a);
      }
      if (!b && B.isEmpty(a)) {
        return 1 / 0;
      }
      var e = {computed:1 / 0, value:1 / 0};
      return E(a, function(a, d, f) {
        d = b ? b.call(c, a, d, f) : a;
        d < e.computed && (e = {value:a, computed:d});
      }), e.value;
    };
    B.shuffle = function(a) {
      var b, c = 0, e = [];
      return E(a, function(a) {
        b = B.random(c++);
        e[c - 1] = e[b];
        e[b] = a;
      }), e;
    };
    var L = function(a) {
      return B.isFunction(a) ? a : function(b) {
        return b[a];
      };
    };
    B.sortBy = function(a, b, c) {
      var e = L(b);
      return B.pluck(B.map(a, function(a, b, d) {
        return {value:a, index:b, criteria:e.call(c, a, b, d)};
      }).sort(function(a, b) {
        var c = a.criteria, e = b.criteria;
        if (c !== e) {
          if (c > e || void 0 === c) {
            return 1;
          }
          if (e > c || void 0 === e) {
            return -1;
          }
        }
        return a.index < b.index ? -1 : 1;
      }), "value");
    };
    var K = function(a, b, c, e) {
      var d = {}, f = L(b || B.identity);
      return E(a, function(b, k) {
        k = f.call(c, b, k, a);
        e(d, k, b);
      }), d;
    };
    B.groupBy = function(a, b, c) {
      return K(a, b, c, function(a, b, c) {
        (B.has(a, b) ? a[b] : a[b] = []).push(c);
      });
    };
    B.countBy = function(a, b, c) {
      return K(a, b, c, function(a, b) {
        B.has(a, b) || (a[b] = 0);
        a[b]++;
      });
    };
    B.sortedIndex = function(a, b, c, e) {
      c = null == c ? B.identity : L(c);
      b = c.call(e, b);
      for (var d = 0, f = a.length; f > d;) {
        var k = d + f >>> 1;
        c.call(e, a[k]) < b ? d = k + 1 : f = k;
      }
      return d;
    };
    B.toArray = function(a) {
      return a ? B.isArray(a) ? f.call(a) : a.length === +a.length ? B.map(a, B.identity) : B.values(a) : [];
    };
    B.size = function(a) {
      return null == a ? 0 : a.length === +a.length ? a.length : B.keys(a).length;
    };
    B.first = B.head = B.take = function(a, b, c) {
      return null == a ? void 0 : null == b || c ? a[0] : f.call(a, 0, b);
    };
    B.initial = function(a, b, c) {
      return f.call(a, 0, a.length - (null == b || c ? 1 : b));
    };
    B.last = function(a, b, c) {
      return null == a ? void 0 : null == b || c ? a[a.length - 1] : f.call(a, Math.max(a.length - b, 0));
    };
    B.rest = B.tail = B.drop = function(a, b, c) {
      return f.call(a, null == b || c ? 1 : b);
    };
    B.compact = function(a) {
      return B.filter(a, B.identity);
    };
    var P = function(a, b, c) {
      return E(a, function(a) {
        B.isArray(a) ? b ? t.apply(c, a) : P(a, b, c) : c.push(a);
      }), c;
    };
    B.flatten = function(a, b) {
      return P(a, b, []);
    };
    B.without = function(a) {
      return B.difference(a, f.call(arguments, 1));
    };
    B.uniq = B.unique = function(a, b, c, e) {
      B.isFunction(b) && (e = c, c = b, b = !1);
      c = c ? B.map(a, c, e) : a;
      var d = [], f = [];
      return E(c, function(c, e) {
        (b ? e && f[f.length - 1] === c : B.contains(f, c)) || (f.push(c), d.push(a[e]));
      }), d;
    };
    B.union = function() {
      return B.uniq(n.apply(c, arguments));
    };
    B.intersection = function(a) {
      var b = f.call(arguments, 1);
      return B.filter(B.uniq(a), function(a) {
        return B.every(b, function(b) {
          return 0 <= B.indexOf(b, a);
        });
      });
    };
    B.difference = function(a) {
      var b = n.apply(c, f.call(arguments, 1));
      return B.filter(a, function(a) {
        return !B.contains(b, a);
      });
    };
    B.zip = function() {
      for (var a = f.call(arguments), b = B.max(B.pluck(a, "length")), c = Array(b), e = 0; b > e; e++) {
        c[e] = B.pluck(a, "" + e);
      }
      return c;
    };
    B.object = function(a, b) {
      if (null == a) {
        return {};
      }
      for (var c = {}, e = 0, d = a.length; d > e; e++) {
        b ? c[a[e]] = b[e] : c[a[e][0]] = a[e][1];
      }
      return c;
    };
    B.indexOf = function(a, b, c) {
      if (null == a) {
        return -1;
      }
      var e = 0, d = a.length;
      if (c) {
        if ("number" != typeof c) {
          return e = B.sortedIndex(a, b), a[e] === b ? e : -1;
        }
        e = 0 > c ? Math.max(0, d + c) : c;
      }
      if (C && a.indexOf === C) {
        return a.indexOf(b, c);
      }
      for (; d > e; e++) {
        if (a[e] === b) {
          return e;
        }
      }
      return -1;
    };
    B.lastIndexOf = function(a, b, c) {
      if (null == a) {
        return -1;
      }
      var e = null != c;
      if (A && a.lastIndexOf === A) {
        return e ? a.lastIndexOf(b, c) : a.lastIndexOf(b);
      }
      for (c = e ? c : a.length; c--;) {
        if (a[c] === b) {
          return c;
        }
      }
      return -1;
    };
    B.range = function(a, b, c) {
      1 >= arguments.length && (b = a || 0, a = 0);
      c = arguments[2] || 1;
      for (var e = Math.max(Math.ceil((b - a) / c), 0), d = 0, f = Array(e); e > d;) {
        f[d++] = a, a += c;
      }
      return f;
    };
    B.bind = function(a, b) {
      if (a.bind === F && F) {
        return F.apply(a, f.call(arguments, 1));
      }
      var c = f.call(arguments, 2);
      return function() {
        return a.apply(b, c.concat(f.call(arguments)));
      };
    };
    B.partial = function(a) {
      var b = f.call(arguments, 1);
      return function() {
        return a.apply(this, b.concat(f.call(arguments)));
      };
    };
    B.bindAll = function(a) {
      var b = f.call(arguments, 1);
      return 0 === b.length && (b = B.functions(a)), E(b, function(b) {
        a[b] = B.bind(a[b], a);
      }), a;
    };
    B.memoize = function(a, b) {
      var c = {};
      return b || (b = B.identity), function() {
        var e = b.apply(this, arguments);
        return B.has(c, e) ? c[e] : c[e] = a.apply(this, arguments);
      };
    };
    B.delay = function(a, b) {
      var c = f.call(arguments, 2);
      return setTimeout(function() {
        return a.apply(null, c);
      }, b);
    };
    B.defer = function(a) {
      return B.delay.apply(B, [a, 1].concat(f.call(arguments, 1)));
    };
    B.throttle = function(a, b) {
      var c, e, d, f, k = 0, m = function() {
        k = new Date;
        d = null;
        f = a.apply(c, e);
      };
      return function() {
        var h = new Date, g = b - (h - k);
        return c = this, e = arguments, 0 >= g ? (clearTimeout(d), d = null, k = h, f = a.apply(c, e)) : d || (d = setTimeout(m, g)), f;
      };
    };
    B.debounce = function(a, b, c) {
      var e, d;
      return function() {
        var f = this, k = arguments, m = c && !e;
        return clearTimeout(e), e = setTimeout(function() {
          e = null;
          c || (d = a.apply(f, k));
        }, b), m && (d = a.apply(f, k)), d;
      };
    };
    B.once = function(a) {
      var b, c = !1;
      return function() {
        return c ? b : (c = !0, b = a.apply(this, arguments), a = null, b);
      };
    };
    B.wrap = function(a, b) {
      return function() {
        var c = [a];
        return t.apply(c, arguments), b.apply(this, c);
      };
    };
    B.compose = function() {
      var a = arguments;
      return function() {
        for (var b = arguments, c = a.length - 1; 0 <= c; c--) {
          b = [a[c].apply(this, b)];
        }
        return b[0];
      };
    };
    B.after = function(a, b) {
      return 0 >= a ? b() : function() {
        return 1 > --a ? b.apply(this, arguments) : void 0;
      };
    };
    B.keys = D || function(a) {
      if (a !== Object(a)) {
        throw new TypeError("Invalid object");
      }
      var b = [], c;
      for (c in a) {
        B.has(a, c) && (b[b.length] = c);
      }
      return b;
    };
    B.values = function(a) {
      var b = [], c;
      for (c in a) {
        B.has(a, c) && b.push(a[c]);
      }
      return b;
    };
    B.pairs = function(a) {
      var b = [], c;
      for (c in a) {
        B.has(a, c) && b.push([c, a[c]]);
      }
      return b;
    };
    B.invert = function(a) {
      var b = {}, c;
      for (c in a) {
        B.has(a, c) && (b[a[c]] = c);
      }
      return b;
    };
    B.functions = B.methods = function(a) {
      var b = [], c;
      for (c in a) {
        B.isFunction(a[c]) && b.push(c);
      }
      return b.sort();
    };
    B.extend = function(a) {
      return E(f.call(arguments, 1), function(b) {
        if (b) {
          for (var c in b) {
            a[c] = b[c];
          }
        }
      }), a;
    };
    B.pick = function(a) {
      var b = {}, e = n.apply(c, f.call(arguments, 1));
      return E(e, function(c) {
        c in a && (b[c] = a[c]);
      }), b;
    };
    B.omit = function(a) {
      var b = {}, e = n.apply(c, f.call(arguments, 1)), d;
      for (d in a) {
        B.contains(e, d) || (b[d] = a[d]);
      }
      return b;
    };
    B.defaults = function(a) {
      return E(f.call(arguments, 1), function(b) {
        if (b) {
          for (var c in b) {
            null == a[c] && (a[c] = b[c]);
          }
        }
      }), a;
    };
    B.clone = function(a) {
      return B.isObject(a) ? B.isArray(a) ? a.slice() : B.extend({}, a) : a;
    };
    B.tap = function(a, b) {
      return b(a), a;
    };
    var J = function(a, c, e, d) {
      if (a === c) {
        return 0 !== a || 1 / a == 1 / c;
      }
      if (null == a || null == c) {
        return a === c;
      }
      a instanceof B && (a = a._wrapped);
      c instanceof B && (c = c._wrapped);
      var f = b.call(a);
      if (f != b.call(c)) {
        return !1;
      }
      switch(f) {
        case "[object String]":
          return a == String(c);
        case "[object Number]":
          return a != +a ? c != +c : 0 == a ? 1 / a == 1 / c : a == +c;
        case "[object Date]":
        case "[object Boolean]":
          return +a == +c;
        case "[object RegExp]":
          return a.source == c.source && a.global == c.global && a.multiline == c.multiline && a.ignoreCase == c.ignoreCase;
      }
      if ("object" != typeof a || "object" != typeof c) {
        return !1;
      }
      for (var k = e.length; k--;) {
        if (e[k] == a) {
          return d[k] == c;
        }
      }
      e.push(a);
      d.push(c);
      k = 0;
      var m = !0;
      if ("[object Array]" == f) {
        if (k = a.length, m = k == c.length) {
          for (; k-- && (m = J(a[k], c[k], e, d));) {
          }
        }
      } else {
        f = a.constructor;
        var h = c.constructor;
        if (f !== h && !(B.isFunction(f) && f instanceof f && B.isFunction(h) && h instanceof h)) {
          return !1;
        }
        for (var g in a) {
          if (B.has(a, g) && (k++, !(m = B.has(c, g) && J(a[g], c[g], e, d)))) {
            break;
          }
        }
        if (m) {
          for (g in c) {
            if (B.has(c, g) && !k--) {
              break;
            }
          }
          m = !k;
        }
      }
      return e.pop(), d.pop(), m;
    };
    B.isEqual = function(a, b) {
      return J(a, b, [], []);
    };
    B.isEmpty = function(a) {
      if (null == a) {
        return !0;
      }
      if (B.isArray(a) || B.isString(a)) {
        return 0 === a.length;
      }
      for (var b in a) {
        if (B.has(a, b)) {
          return !1;
        }
      }
      return !0;
    };
    B.isElement = function(a) {
      return !(!a || 1 !== a.nodeType);
    };
    B.isArray = p || function(a) {
      return "[object Array]" == b.call(a);
    };
    B.isObject = function(a) {
      return a === Object(a);
    };
    E("Arguments Function String Number Date RegExp".split(" "), function(a) {
      B["is" + a] = function(c) {
        return b.call(c) == "[object " + a + "]";
      };
    });
    B.isArguments(arguments) || (B.isArguments = function(a) {
      return !(!a || !B.has(a, "callee"));
    });
    "function" != typeof/./ && (B.isFunction = function(a) {
      return "function" == typeof a;
    });
    B.isFinite = function(a) {
      return isFinite(a) && !isNaN(parseFloat(a));
    };
    B.isNaN = function(a) {
      return B.isNumber(a) && a != +a;
    };
    B.isBoolean = function(a) {
      return !0 === a || !1 === a || "[object Boolean]" == b.call(a);
    };
    B.isNull = function(a) {
      return null === a;
    };
    B.isUndefined = function(a) {
      return void 0 === a;
    };
    B.has = function(a, b) {
      return m.call(a, b);
    };
    B.noConflict = function() {
      return a._ = e, this;
    };
    B.identity = function(a) {
      return a;
    };
    B.times = function(a, b, c) {
      for (var e = Array(a), d = 0; a > d; d++) {
        e[d] = b.call(c, d);
      }
      return e;
    };
    B.random = function(a, b) {
      return null == b && (b = a, a = 0), a + Math.floor(Math.random() * (b - a + 1));
    };
    var I = {escape:{"&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#x27;", "/":"&#x2F;"}};
    I.unescape = B.invert(I.escape);
    var N = {escape:new RegExp("[" + B.keys(I.escape).join("") + "]", "g"), unescape:new RegExp("(" + B.keys(I.unescape).join("|") + ")", "g")};
    B.each(["escape", "unescape"], function(a) {
      B[a] = function(b) {
        return null == b ? "" : ("" + b).replace(N[a], function(b) {
          return I[a][b];
        });
      };
    });
    B.result = function(a, b) {
      if (null == a) {
        return null;
      }
      b = a[b];
      return B.isFunction(b) ? b.call(a) : b;
    };
    B.mixin = function(a) {
      E(B.functions(a), function(b) {
        var c = B[b] = a[b];
        B.prototype[b] = function() {
          var a = [this._wrapped];
          return t.apply(a, arguments), W.call(this, c.apply(B, a));
        };
      });
    };
    var S = 0;
    B.uniqueId = function(a) {
      var b = ++S + "";
      return a ? a + b : b;
    };
    B.templateSettings = {evaluate:/<%([\s\S]+?)%>/g, interpolate:/<%=([\s\S]+?)%>/g, escape:/<%-([\s\S]+?)%>/g};
    var Q = /(.)^/, Z = {"'":"'", "\\":"\\", "\r":"r", "\n":"n", "\t":"t", "\u2028":"u2028", "\u2029":"u2029"}, R = /\\|'|\r|\n|\t|\u2028|\u2029/g;
    B.template = function(a, b, c) {
      c = B.defaults({}, c, B.templateSettings);
      var e = new RegExp([(c.escape || Q).source, (c.interpolate || Q).source, (c.evaluate || Q).source].join("|") + "|$", "g"), d = 0, f = "__p+='";
      a.replace(e, function(b, c, e, k, m) {
        return f += a.slice(d, m).replace(R, function(a) {
          return "\\" + Z[a];
        }), c && (f += "'+\n((__t=(" + c + "))==null?'':_.escape(__t))+\n'"), e && (f += "'+\n((__t=(" + e + "))==null?'':__t)+\n'"), k && (f += "';\n" + k + "\n__p+='"), d = m + b.length, b;
      });
      f += "';\n";
      c.variable || (f = "with(obj||{}){\n" + f + "}\n");
      f = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + f + "return __p;\n";
      try {
        var k = new Function(c.variable || "obj", "_", f);
      } catch (ea) {
        throw ea.source = f, ea;
      }
      if (b) {
        return k(b, B);
      }
      b = function(a) {
        return k.call(this, a, B);
      };
      return b.source = "function(" + (c.variable || "obj") + "){\n" + f + "}", b;
    };
    B.chain = function(a) {
      return B(a).chain();
    };
    var W = function(a) {
      return this._chain ? B(a).chain() : a;
    };
    B.mixin(B);
    E("pop push reverse shift sort splice unshift".split(" "), function(a) {
      var b = c[a];
      B.prototype[a] = function() {
        var c = this._wrapped;
        return b.apply(c, arguments), "shift" != a && "splice" != a || 0 !== c.length || delete c[0], W.call(this, c);
      };
    });
    E(["concat", "join", "slice"], function(a) {
      var b = c[a];
      B.prototype[a] = function() {
        return W.call(this, b.apply(this._wrapped, arguments));
      };
    });
    B.extend(B.prototype, {chain:function() {
      return this._chain = !0, this;
    }, value:function() {
      return this._wrapped;
    }});
  }).call(this);
}, {}], 25:[function(a) {
  "undefined" != typeof window && "function" != typeof window.requestAnimationFrame && (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a) {
    setTimeout(a, 1E3 / 60);
  });
  Leap = a("../lib/index");
}, {"../lib/index":11}]}, {}, [25]);
var __extends = this && this.__extends || function() {
  var a = function(d, g) {
    a = Object.setPrototypeOf || {__proto__:[]} instanceof Array && function(a, e) {
      a.__proto__ = e;
    } || function(a, e) {
      for (var d in e) {
        e.hasOwnProperty(d) && (a[d] = e[d]);
      }
    };
    return a(d, g);
  };
  return function(d, g) {
    function h() {
      this.constructor = d;
    }
    a(d, g);
    d.prototype = null === g ? Object.create(g) : (h.prototype = g.prototype, new h);
  };
}(), spine;
(function(a) {
  var d = function() {
    function a(a, b, c) {
      if (null == a) {
        throw Error("name cannot be null.");
      }
      if (null == b) {
        throw Error("timelines cannot be null.");
      }
      this.name = a;
      this.timelines = b;
      this.timelineIds = [];
      for (a = 0; a < b.length; a++) {
        this.timelineIds[b[a].getPropertyId()] = !0;
      }
      this.duration = c;
    }
    a.prototype.hasTimeline = function(a) {
      return 1 == this.timelineIds[a];
    };
    a.prototype.apply = function(a, b, c, e, d, f, k, h) {
      if (null == a) {
        throw Error("skeleton cannot be null.");
      }
      e && 0 != this.duration && (c %= this.duration, 0 < b && (b %= this.duration));
      e = this.timelines;
      for (var m = 0, g = e.length; m < g; m++) {
        e[m].apply(a, b, c, d, f, k, h);
      }
    };
    a.binarySearch = function(a, b, c) {
      void 0 === c && (c = 1);
      var e = 0, d = a.length / c - 2;
      if (0 == d) {
        return c;
      }
      for (var f = d >>> 1;;) {
        a[(f + 1) * c] <= b ? e = f + 1 : d = f;
        if (e == d) {
          return (e + 1) * c;
        }
        f = e + d >>> 1;
      }
    };
    a.linearSearch = function(a, b, c) {
      for (var e = 0, d = a.length - c; e <= d; e += c) {
        if (a[e] > b) {
          return e;
        }
      }
      return -1;
    };
    return a;
  }();
  a.Animation = d;
  var g;
  (function(a) {
    a[a.setup = 0] = "setup";
    a[a.first = 1] = "first";
    a[a.replace = 2] = "replace";
    a[a.add = 3] = "add";
  })(g = a.MixBlend || (a.MixBlend = {}));
  var h;
  (function(a) {
    a[a.mixIn = 0] = "mixIn";
    a[a.mixOut = 1] = "mixOut";
  })(h = a.MixDirection || (a.MixDirection = {}));
  var e;
  (function(a) {
    a[a.rotate = 0] = "rotate";
    a[a.translate = 1] = "translate";
    a[a.scale = 2] = "scale";
    a[a.shear = 3] = "shear";
    a[a.attachment = 4] = "attachment";
    a[a.color = 5] = "color";
    a[a.deform = 6] = "deform";
    a[a.event = 7] = "event";
    a[a.drawOrder = 8] = "drawOrder";
    a[a.ikConstraint = 9] = "ikConstraint";
    a[a.transformConstraint = 10] = "transformConstraint";
    a[a.pathConstraintPosition = 11] = "pathConstraintPosition";
    a[a.pathConstraintSpacing = 12] = "pathConstraintSpacing";
    a[a.pathConstraintMix = 13] = "pathConstraintMix";
    a[a.twoColor = 14] = "twoColor";
  })(e = a.TimelineType || (a.TimelineType = {}));
  var k = function() {
    function c(e) {
      if (0 >= e) {
        throw Error("frameCount must be > 0: " + e);
      }
      this.curves = a.Utils.newFloatArray((e - 1) * c.BEZIER_SIZE);
    }
    c.prototype.getFrameCount = function() {
      return this.curves.length / c.BEZIER_SIZE + 1;
    };
    c.prototype.setLinear = function(a) {
      this.curves[a * c.BEZIER_SIZE] = c.LINEAR;
    };
    c.prototype.setStepped = function(a) {
      this.curves[a * c.BEZIER_SIZE] = c.STEPPED;
    };
    c.prototype.getCurveType = function(a) {
      a *= c.BEZIER_SIZE;
      if (a == this.curves.length) {
        return c.LINEAR;
      }
      a = this.curves[a];
      return a == c.LINEAR ? c.LINEAR : a == c.STEPPED ? c.STEPPED : c.BEZIER;
    };
    c.prototype.setCurve = function(a, b, e, d, f) {
      var k = .03 * (2 * -b + d), m = .03 * (2 * -e + f);
      d = .006 * (3 * (b - d) + 1);
      f = .006 * (3 * (e - f) + 1);
      var h = 2 * k + d, g = 2 * m + f;
      b = .3 * b + k + .16666667 * d;
      e = .3 * e + m + .16666667 * f;
      a *= c.BEZIER_SIZE;
      m = this.curves;
      m[a++] = c.BEZIER;
      k = b;
      for (var n = e, p = a + c.BEZIER_SIZE - 1; a < p; a += 2) {
        m[a] = k, m[a + 1] = n, b += h, e += g, h += d, g += f, k += b, n += e;
      }
    };
    c.prototype.getCurvePercent = function(e, b) {
      b = a.MathUtils.clamp(b, 0, 1);
      var d = this.curves;
      e *= c.BEZIER_SIZE;
      var f = d[e];
      if (f == c.LINEAR) {
        return b;
      }
      if (f == c.STEPPED) {
        return 0;
      }
      e++;
      f = 0;
      for (var k = e, h = e + c.BEZIER_SIZE - 1; e < h; e += 2) {
        if (f = d[e], f >= b) {
          return e == k ? h = k = 0 : (k = d[e - 2], h = d[e - 1]), h + (d[e + 1] - h) * (b - k) / (f - k);
        }
      }
      d = d[e - 1];
      return d + (1 - d) * (b - f) / (1 - f);
    };
    c.LINEAR = 0;
    c.STEPPED = 1;
    c.BEZIER = 2;
    c.BEZIER_SIZE = 19;
    return c;
  }();
  a.CurveTimeline = k;
  var c = function(c) {
    function f(b) {
      var e = c.call(this, b) || this;
      e.frames = a.Utils.newFloatArray(b << 1);
      return e;
    }
    __extends(f, c);
    f.prototype.getPropertyId = function() {
      return (e.rotate << 24) + this.boneIndex;
    };
    f.prototype.setFrame = function(a, c, e) {
      a <<= 1;
      this.frames[a] = c;
      this.frames[a + f.ROTATION] = e;
    };
    f.prototype.apply = function(a, c, e, k, h, n, p) {
      c = this.frames;
      a = a.bones[this.boneIndex];
      if (a.active) {
        if (e < c[0]) {
          switch(n) {
            case g.setup:
              a.rotation = a.data.rotation;
              break;
            case g.first:
              n = a.data.rotation - a.rotation, a.rotation += (n - 360 * (16384 - (16384.499999999996 - n / 360 | 0))) * h;
          }
        } else {
          if (e >= c[c.length - f.ENTRIES]) {
            switch(e = c[c.length + f.PREV_ROTATION], n) {
              case g.setup:
                a.rotation = a.data.rotation + e * h;
                break;
              case g.first:
              case g.replace:
                e += a.data.rotation - a.rotation, e -= 360 * (16384 - (16384.499999999996 - e / 360 | 0));
              case g.add:
                a.rotation += e * h;
            }
          } else {
            p = d.binarySearch(c, e, f.ENTRIES);
            k = c[p + f.PREV_ROTATION];
            var b = c[p];
            e = this.getCurvePercent((p >> 1) - 1, 1 - (e - b) / (c[p + f.PREV_TIME] - b));
            c = c[p + f.ROTATION] - k;
            c = k + (c - 360 * (16384 - (16384.499999999996 - c / 360 | 0))) * e;
            switch(n) {
              case g.setup:
                a.rotation = a.data.rotation + (c - 360 * (16384 - (16384.499999999996 - c / 360 | 0))) * h;
                break;
              case g.first:
              case g.replace:
                c += a.data.rotation - a.rotation;
              case g.add:
                a.rotation += (c - 360 * (16384 - (16384.499999999996 - c / 360 | 0))) * h;
            }
          }
        }
      }
    };
    f.ENTRIES = 2;
    f.PREV_TIME = -2;
    f.PREV_ROTATION = -1;
    f.ROTATION = 1;
    return f;
  }(k);
  a.RotateTimeline = c;
  c = function(c) {
    function f(b) {
      var e = c.call(this, b) || this;
      e.frames = a.Utils.newFloatArray(b * f.ENTRIES);
      return e;
    }
    __extends(f, c);
    f.prototype.getPropertyId = function() {
      return (e.translate << 24) + this.boneIndex;
    };
    f.prototype.setFrame = function(a, c, e, d) {
      a *= f.ENTRIES;
      this.frames[a] = c;
      this.frames[a + f.X] = e;
      this.frames[a + f.Y] = d;
    };
    f.prototype.apply = function(a, c, e, k, h, n, p) {
      c = this.frames;
      a = a.bones[this.boneIndex];
      if (a.active) {
        if (e < c[0]) {
          switch(n) {
            case g.setup:
              a.x = a.data.x;
              a.y = a.data.y;
              break;
            case g.first:
              a.x += (a.data.x - a.x) * h, a.y += (a.data.y - a.y) * h;
          }
        } else {
          if (e >= c[c.length - f.ENTRIES]) {
            k = c[c.length + f.PREV_X], p = c[c.length + f.PREV_Y];
          } else {
            var b = d.binarySearch(c, e, f.ENTRIES);
            k = c[b + f.PREV_X];
            p = c[b + f.PREV_Y];
            var m = c[b];
            e = this.getCurvePercent(b / f.ENTRIES - 1, 1 - (e - m) / (c[b + f.PREV_TIME] - m));
            k += (c[b + f.X] - k) * e;
            p += (c[b + f.Y] - p) * e;
          }
          switch(n) {
            case g.setup:
              a.x = a.data.x + k * h;
              a.y = a.data.y + p * h;
              break;
            case g.first:
            case g.replace:
              a.x += (a.data.x + k - a.x) * h;
              a.y += (a.data.y + p - a.y) * h;
              break;
            case g.add:
              a.x += k * h, a.y += p * h;
          }
        }
      }
    };
    f.ENTRIES = 3;
    f.PREV_TIME = -3;
    f.PREV_X = -2;
    f.PREV_Y = -1;
    f.X = 1;
    f.Y = 2;
    return f;
  }(k);
  a.TranslateTimeline = c;
  var p = function(c) {
    function f(a) {
      return c.call(this, a) || this;
    }
    __extends(f, c);
    f.prototype.getPropertyId = function() {
      return (e.scale << 24) + this.boneIndex;
    };
    f.prototype.apply = function(b, c, e, k, n, p, t) {
      var m = this.frames;
      b = b.bones[this.boneIndex];
      if (b.active) {
        if (e < m[0]) {
          switch(p) {
            case g.setup:
              b.scaleX = b.data.scaleX;
              b.scaleY = b.data.scaleY;
              break;
            case g.first:
              b.scaleX += (b.data.scaleX - b.scaleX) * n, b.scaleY += (b.data.scaleY - b.scaleY) * n;
          }
        } else {
          if (e >= m[m.length - f.ENTRIES]) {
            c = m[m.length + f.PREV_X] * b.data.scaleX, k = m[m.length + f.PREV_Y] * b.data.scaleY;
          } else {
            var q = d.binarySearch(m, e, f.ENTRIES);
            c = m[q + f.PREV_X];
            k = m[q + f.PREV_Y];
            var r = m[q];
            e = this.getCurvePercent(q / f.ENTRIES - 1, 1 - (e - r) / (m[q + f.PREV_TIME] - r));
            c = (c + (m[q + f.X] - c) * e) * b.data.scaleX;
            k = (k + (m[q + f.Y] - k) * e) * b.data.scaleY;
          }
          if (1 == n) {
            p == g.add ? (b.scaleX += c - b.data.scaleX, b.scaleY += k - b.data.scaleY) : (b.scaleX = c, b.scaleY = k);
          } else {
            if (t == h.mixOut) {
              switch(p) {
                case g.setup:
                  p = b.data.scaleX;
                  t = b.data.scaleY;
                  b.scaleX = p + (Math.abs(c) * a.MathUtils.signum(p) - p) * n;
                  b.scaleY = t + (Math.abs(k) * a.MathUtils.signum(t) - t) * n;
                  break;
                case g.first:
                case g.replace:
                  p = b.scaleX;
                  t = b.scaleY;
                  b.scaleX = p + (Math.abs(c) * a.MathUtils.signum(p) - p) * n;
                  b.scaleY = t + (Math.abs(k) * a.MathUtils.signum(t) - t) * n;
                  break;
                case g.add:
                  p = b.scaleX, t = b.scaleY, b.scaleX = p + (Math.abs(c) * a.MathUtils.signum(p) - b.data.scaleX) * n, b.scaleY = t + (Math.abs(k) * a.MathUtils.signum(t) - b.data.scaleY) * n;
              }
            } else {
              switch(p) {
                case g.setup:
                  p = Math.abs(b.data.scaleX) * a.MathUtils.signum(c);
                  t = Math.abs(b.data.scaleY) * a.MathUtils.signum(k);
                  b.scaleX = p + (c - p) * n;
                  b.scaleY = t + (k - t) * n;
                  break;
                case g.first:
                case g.replace:
                  p = Math.abs(b.scaleX) * a.MathUtils.signum(c);
                  t = Math.abs(b.scaleY) * a.MathUtils.signum(k);
                  b.scaleX = p + (c - p) * n;
                  b.scaleY = t + (k - t) * n;
                  break;
                case g.add:
                  p = a.MathUtils.signum(c), t = a.MathUtils.signum(k), b.scaleX = Math.abs(b.scaleX) * p + (c - Math.abs(b.data.scaleX) * p) * n, b.scaleY = Math.abs(b.scaleY) * t + (k - Math.abs(b.data.scaleY) * t) * n;
              }
            }
          }
        }
      }
    };
    return f;
  }(c);
  a.ScaleTimeline = p;
  c = function(a) {
    function c(b) {
      return a.call(this, b) || this;
    }
    __extends(c, a);
    c.prototype.getPropertyId = function() {
      return (e.shear << 24) + this.boneIndex;
    };
    c.prototype.apply = function(a, e, f, k, h, n, p) {
      e = this.frames;
      a = a.bones[this.boneIndex];
      if (a.active) {
        if (f < e[0]) {
          switch(n) {
            case g.setup:
              a.shearX = a.data.shearX;
              a.shearY = a.data.shearY;
              break;
            case g.first:
              a.shearX += (a.data.shearX - a.shearX) * h, a.shearY += (a.data.shearY - a.shearY) * h;
          }
        } else {
          if (f >= e[e.length - c.ENTRIES]) {
            k = e[e.length + c.PREV_X], p = e[e.length + c.PREV_Y];
          } else {
            var b = d.binarySearch(e, f, c.ENTRIES);
            k = e[b + c.PREV_X];
            p = e[b + c.PREV_Y];
            var m = e[b];
            f = this.getCurvePercent(b / c.ENTRIES - 1, 1 - (f - m) / (e[b + c.PREV_TIME] - m));
            k += (e[b + c.X] - k) * f;
            p += (e[b + c.Y] - p) * f;
          }
          switch(n) {
            case g.setup:
              a.shearX = a.data.shearX + k * h;
              a.shearY = a.data.shearY + p * h;
              break;
            case g.first:
            case g.replace:
              a.shearX += (a.data.shearX + k - a.shearX) * h;
              a.shearY += (a.data.shearY + p - a.shearY) * h;
              break;
            case g.add:
              a.shearX += k * h, a.shearY += p * h;
          }
        }
      }
    };
    return c;
  }(c);
  a.ShearTimeline = c;
  c = function(c) {
    function f(b) {
      var e = c.call(this, b) || this;
      e.frames = a.Utils.newFloatArray(b * f.ENTRIES);
      return e;
    }
    __extends(f, c);
    f.prototype.getPropertyId = function() {
      return (e.color << 24) + this.slotIndex;
    };
    f.prototype.setFrame = function(a, c, e, d, k, h) {
      a *= f.ENTRIES;
      this.frames[a] = c;
      this.frames[a + f.R] = e;
      this.frames[a + f.G] = d;
      this.frames[a + f.B] = k;
      this.frames[a + f.A] = h;
    };
    f.prototype.apply = function(a, c, e, k, h, n, p) {
      a = a.slots[this.slotIndex];
      if (a.bone.active) {
        var b = this.frames;
        if (e < b[0]) {
          switch(n) {
            case g.setup:
              a.color.setFromColor(a.data.color);
              break;
            case g.first:
              e = a.color, n = a.data.color, e.add((n.r - e.r) * h, (n.g - e.g) * h, (n.b - e.b) * h, (n.a - e.a) * h);
          }
        } else {
          if (e >= b[b.length - f.ENTRIES]) {
            e = b.length;
            c = b[e + f.PREV_R];
            k = b[e + f.PREV_G];
            p = b[e + f.PREV_B];
            var m = b[e + f.PREV_A];
          } else {
            var t = d.binarySearch(b, e, f.ENTRIES);
            c = b[t + f.PREV_R];
            k = b[t + f.PREV_G];
            p = b[t + f.PREV_B];
            m = b[t + f.PREV_A];
            var q = b[t];
            e = this.getCurvePercent(t / f.ENTRIES - 1, 1 - (e - q) / (b[t + f.PREV_TIME] - q));
            c += (b[t + f.R] - c) * e;
            k += (b[t + f.G] - k) * e;
            p += (b[t + f.B] - p) * e;
            m += (b[t + f.A] - m) * e;
          }
          1 == h ? a.color.set(c, k, p, m) : (e = a.color, n == g.setup && e.setFromColor(a.data.color), e.add((c - e.r) * h, (k - e.g) * h, (p - e.b) * h, (m - e.a) * h));
        }
      }
    };
    f.ENTRIES = 5;
    f.PREV_TIME = -5;
    f.PREV_R = -4;
    f.PREV_G = -3;
    f.PREV_B = -2;
    f.PREV_A = -1;
    f.R = 1;
    f.G = 2;
    f.B = 3;
    f.A = 4;
    return f;
  }(k);
  a.ColorTimeline = c;
  c = function(c) {
    function f(b) {
      var e = c.call(this, b) || this;
      e.frames = a.Utils.newFloatArray(b * f.ENTRIES);
      return e;
    }
    __extends(f, c);
    f.prototype.getPropertyId = function() {
      return (e.twoColor << 24) + this.slotIndex;
    };
    f.prototype.setFrame = function(a, c, e, d, k, h, g, n, p) {
      a *= f.ENTRIES;
      this.frames[a] = c;
      this.frames[a + f.R] = e;
      this.frames[a + f.G] = d;
      this.frames[a + f.B] = k;
      this.frames[a + f.A] = h;
      this.frames[a + f.R2] = g;
      this.frames[a + f.G2] = n;
      this.frames[a + f.B2] = p;
    };
    f.prototype.apply = function(a, c, e, k, h, n, p) {
      a = a.slots[this.slotIndex];
      if (a.bone.active) {
        var b = this.frames;
        if (e < b[0]) {
          switch(n) {
            case g.setup:
              a.color.setFromColor(a.data.color);
              a.darkColor.setFromColor(a.data.darkColor);
              break;
            case g.first:
              e = a.color, b = a.darkColor, n = a.data.color, a = a.data.darkColor, e.add((n.r - e.r) * h, (n.g - e.g) * h, (n.b - e.b) * h, (n.a - e.a) * h), b.add((a.r - b.r) * h, (a.g - b.g) * h, (a.b - b.b) * h, 0);
          }
        } else {
          if (e >= b[b.length - f.ENTRIES]) {
            e = b.length;
            c = b[e + f.PREV_R];
            k = b[e + f.PREV_G];
            p = b[e + f.PREV_B];
            var m = b[e + f.PREV_A];
            var t = b[e + f.PREV_R2];
            var q = b[e + f.PREV_G2];
            var r = b[e + f.PREV_B2];
          } else {
            var x = d.binarySearch(b, e, f.ENTRIES);
            c = b[x + f.PREV_R];
            k = b[x + f.PREV_G];
            p = b[x + f.PREV_B];
            m = b[x + f.PREV_A];
            t = b[x + f.PREV_R2];
            q = b[x + f.PREV_G2];
            r = b[x + f.PREV_B2];
            var y = b[x];
            e = this.getCurvePercent(x / f.ENTRIES - 1, 1 - (e - y) / (b[x + f.PREV_TIME] - y));
            c += (b[x + f.R] - c) * e;
            k += (b[x + f.G] - k) * e;
            p += (b[x + f.B] - p) * e;
            m += (b[x + f.A] - m) * e;
            t += (b[x + f.R2] - t) * e;
            q += (b[x + f.G2] - q) * e;
            r += (b[x + f.B2] - r) * e;
          }
          1 == h ? (a.color.set(c, k, p, m), a.darkColor.set(t, q, r, 1)) : (e = a.color, b = a.darkColor, n == g.setup && (e.setFromColor(a.data.color), b.setFromColor(a.data.darkColor)), e.add((c - e.r) * h, (k - e.g) * h, (p - e.b) * h, (m - e.a) * h), b.add((t - b.r) * h, (q - b.g) * h, (r - b.b) * h, 0));
        }
      }
    };
    f.ENTRIES = 8;
    f.PREV_TIME = -8;
    f.PREV_R = -7;
    f.PREV_G = -6;
    f.PREV_B = -5;
    f.PREV_A = -4;
    f.PREV_R2 = -3;
    f.PREV_G2 = -2;
    f.PREV_B2 = -1;
    f.R = 1;
    f.G = 2;
    f.B = 3;
    f.A = 4;
    f.R2 = 5;
    f.G2 = 6;
    f.B2 = 7;
    return f;
  }(k);
  a.TwoColorTimeline = c;
  c = function() {
    function c(c) {
      this.frames = a.Utils.newFloatArray(c);
      this.attachmentNames = Array(c);
    }
    c.prototype.getPropertyId = function() {
      return (e.attachment << 24) + this.slotIndex;
    };
    c.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    c.prototype.setFrame = function(a, b, c) {
      this.frames[a] = b;
      this.attachmentNames[a] = c;
    };
    c.prototype.apply = function(a, b, c, e, f, k, p) {
      b = a.slots[this.slotIndex];
      if (b.bone.active) {
        if (p == h.mixOut && k == g.setup) {
          c = b.data.attachmentName, b.setAttachment(null == c ? null : a.getAttachment(this.slotIndex, c));
        } else {
          if (p = this.frames, c < p[0]) {
            if (k == g.setup || k == g.first) {
              c = b.data.attachmentName, b.setAttachment(null == c ? null : a.getAttachment(this.slotIndex, c));
            }
          } else {
            c = c >= p[p.length - 1] ? p.length - 1 : d.binarySearch(p, c, 1) - 1, c = this.attachmentNames[c], a.slots[this.slotIndex].setAttachment(null == c ? null : a.getAttachment(this.slotIndex, c));
          }
        }
      }
    };
    return c;
  }();
  a.AttachmentTimeline = c;
  var t = null;
  c = function(c) {
    function f(b) {
      var e = c.call(this, b) || this;
      e.frames = a.Utils.newFloatArray(b);
      e.frameVertices = Array(b);
      null == t && (t = a.Utils.newFloatArray(64));
      return e;
    }
    __extends(f, c);
    f.prototype.getPropertyId = function() {
      return (e.deform << 27) + +this.attachment.id + this.slotIndex;
    };
    f.prototype.setFrame = function(a, c, e) {
      this.frames[a] = c;
      this.frameVertices[a] = e;
    };
    f.prototype.apply = function(b, c, e, f, k, h, n) {
      b = b.slots[this.slotIndex];
      if (b.bone.active) {
        var m = b.getAttachment();
        if (m instanceof a.VertexAttachment && m.deformAttachment == this.attachment) {
          c = b.deform;
          0 == c.length && (h = g.setup);
          n = this.frameVertices;
          b = n[0].length;
          var p = this.frames;
          if (e < p[0]) {
            switch(h) {
              case g.setup:
                c.length = 0;
                break;
              case g.first:
                if (1 == k) {
                  c.length = 0;
                } else {
                  if (c = a.Utils.setArraySize(c, b), null == m.bones) {
                    for (h = m.vertices, f = 0; f < b; f++) {
                      c[f] += (h[f] - c[f]) * k;
                    }
                  } else {
                    for (k = 1 - k, f = 0; f < b; f++) {
                      c[f] *= k;
                    }
                  }
                }
            }
          } else {
            if (c = a.Utils.setArraySize(c, b), e >= p[p.length - 1]) {
              if (f = n[p.length - 1], 1 == k) {
                if (h == g.add) {
                  if (null == m.bones) {
                    for (h = m.vertices, k = 0; k < b; k++) {
                      c[k] += f[k] - h[k];
                    }
                  } else {
                    for (k = 0; k < b; k++) {
                      c[k] += f[k];
                    }
                  }
                } else {
                  a.Utils.arrayCopy(f, 0, c, 0, b);
                }
              } else {
                switch(h) {
                  case g.setup:
                    if (null == m.bones) {
                      for (h = m.vertices, n = 0; n < b; n++) {
                        p = h[n], c[n] = p + (f[n] - p) * k;
                      }
                    } else {
                      for (n = 0; n < b; n++) {
                        c[n] = f[n] * k;
                      }
                    }
                    break;
                  case g.first:
                  case g.replace:
                    for (n = 0; n < b; n++) {
                      c[n] += (f[n] - c[n]) * k;
                    }
                    break;
                  case g.add:
                    if (null == m.bones) {
                      for (h = m.vertices, n = 0; n < b; n++) {
                        c[n] += (f[n] - h[n]) * k;
                      }
                    } else {
                      for (n = 0; n < b; n++) {
                        c[n] += f[n] * k;
                      }
                    }
                }
              }
            } else {
              var t = d.binarySearch(p, e);
              f = n[t - 1];
              n = n[t];
              var q = p[t];
              e = this.getCurvePercent(t - 1, 1 - (e - q) / (p[t - 1] - q));
              if (1 == k) {
                if (h == g.add) {
                  if (null == m.bones) {
                    for (h = m.vertices, k = 0; k < b; k++) {
                      m = f[k], c[k] += m + (n[k] - m) * e - h[k];
                    }
                  } else {
                    for (k = 0; k < b; k++) {
                      m = f[k], c[k] += m + (n[k] - m) * e;
                    }
                  }
                } else {
                  for (k = 0; k < b; k++) {
                    m = f[k], c[k] = m + (n[k] - m) * e;
                  }
                }
              } else {
                switch(h) {
                  case g.setup:
                    if (null == m.bones) {
                      for (h = m.vertices, t = 0; t < b; t++) {
                        m = f[t], p = h[t], c[t] = p + (m + (n[t] - m) * e - p) * k;
                      }
                    } else {
                      for (h = 0; h < b; h++) {
                        m = f[h], c[h] = (m + (n[h] - m) * e) * k;
                      }
                    }
                    break;
                  case g.first:
                  case g.replace:
                    for (h = 0; h < b; h++) {
                      m = f[h], c[h] += (m + (n[h] - m) * e - c[h]) * k;
                    }
                    break;
                  case g.add:
                    if (null == m.bones) {
                      for (h = m.vertices, p = 0; p < b; p++) {
                        m = f[p], c[p] += (m + (n[p] - m) * e - h[p]) * k;
                      }
                    } else {
                      for (h = 0; h < b; h++) {
                        m = f[h], c[h] += (m + (n[h] - m) * e) * k;
                      }
                    }
                }
              }
            }
          }
        }
      }
    };
    return f;
  }(k);
  a.DeformTimeline = c;
  c = function() {
    function c(c) {
      this.frames = a.Utils.newFloatArray(c);
      this.events = Array(c);
    }
    c.prototype.getPropertyId = function() {
      return e.event << 24;
    };
    c.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    c.prototype.setFrame = function(a, b) {
      this.frames[a] = b.time;
      this.events[a] = b;
    };
    c.prototype.apply = function(a, b, c, e, f, k, h) {
      if (null != e) {
        var m = this.frames, g = this.frames.length;
        if (b > c) {
          this.apply(a, b, Number.MAX_VALUE, e, f, k, h), b = -1;
        } else {
          if (b >= m[g - 1]) {
            return;
          }
        }
        if (!(c < m[0])) {
          if (b < m[0]) {
            a = 0;
          } else {
            for (a = d.binarySearch(m, b), b = m[a]; 0 < a && m[a - 1] == b;) {
              a--;
            }
          }
          for (; a < g && c >= m[a]; a++) {
            e.push(this.events[a]);
          }
        }
      }
    };
    return c;
  }();
  a.EventTimeline = c;
  c = function() {
    function c(c) {
      this.frames = a.Utils.newFloatArray(c);
      this.drawOrders = Array(c);
    }
    c.prototype.getPropertyId = function() {
      return e.drawOrder << 24;
    };
    c.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    c.prototype.setFrame = function(a, b, c) {
      this.frames[a] = b;
      this.drawOrders[a] = c;
    };
    c.prototype.apply = function(c, b, e, f, k, p, t) {
      b = c.drawOrder;
      f = c.slots;
      if (t == h.mixOut && p == g.setup) {
        a.Utils.arrayCopy(c.slots, 0, c.drawOrder, 0, c.slots.length);
      } else {
        if (t = this.frames, e < t[0]) {
          p != g.setup && p != g.first || a.Utils.arrayCopy(c.slots, 0, c.drawOrder, 0, c.slots.length);
        } else {
          if (c = e >= t[t.length - 1] ? t.length - 1 : d.binarySearch(t, e) - 1, c = this.drawOrders[c], null == c) {
            a.Utils.arrayCopy(f, 0, b, 0, f.length);
          } else {
            for (e = 0, p = c.length; e < p; e++) {
              b[e] = f[c[e]];
            }
          }
        }
      }
    };
    return c;
  }();
  a.DrawOrderTimeline = c;
  c = function(c) {
    function f(b) {
      var e = c.call(this, b) || this;
      e.frames = a.Utils.newFloatArray(b * f.ENTRIES);
      return e;
    }
    __extends(f, c);
    f.prototype.getPropertyId = function() {
      return (e.ikConstraint << 24) + this.ikConstraintIndex;
    };
    f.prototype.setFrame = function(a, c, e, d, k, h, g) {
      a *= f.ENTRIES;
      this.frames[a] = c;
      this.frames[a + f.MIX] = e;
      this.frames[a + f.SOFTNESS] = d;
      this.frames[a + f.BEND_DIRECTION] = k;
      this.frames[a + f.COMPRESS] = h ? 1 : 0;
      this.frames[a + f.STRETCH] = g ? 1 : 0;
    };
    f.prototype.apply = function(a, c, e, k, n, p, t) {
      c = this.frames;
      a = a.ikConstraints[this.ikConstraintIndex];
      if (a.active) {
        if (e < c[0]) {
          switch(p) {
            case g.setup:
              a.mix = a.data.mix;
              a.softness = a.data.softness;
              a.bendDirection = a.data.bendDirection;
              a.compress = a.data.compress;
              a.stretch = a.data.stretch;
              break;
            case g.first:
              a.mix += (a.data.mix - a.mix) * n, a.softness += (a.data.softness - a.softness) * n, a.bendDirection = a.data.bendDirection, a.compress = a.data.compress, a.stretch = a.data.stretch;
          }
        } else {
          if (e >= c[c.length - f.ENTRIES]) {
            p == g.setup ? (a.mix = a.data.mix + (c[c.length + f.PREV_MIX] - a.data.mix) * n, a.softness = a.data.softness + (c[c.length + f.PREV_SOFTNESS] - a.data.softness) * n, t == h.mixOut ? (a.bendDirection = a.data.bendDirection, a.compress = a.data.compress, a.stretch = a.data.stretch) : (a.bendDirection = c[c.length + f.PREV_BEND_DIRECTION], a.compress = 0 != c[c.length + f.PREV_COMPRESS], a.stretch = 0 != c[c.length + f.PREV_STRETCH])) : (a.mix += (c[c.length + f.PREV_MIX] - a.mix) * n, 
            a.softness += (c[c.length + f.PREV_SOFTNESS] - a.softness) * n, t == h.mixIn && (a.bendDirection = c[c.length + f.PREV_BEND_DIRECTION], a.compress = 0 != c[c.length + f.PREV_COMPRESS], a.stretch = 0 != c[c.length + f.PREV_STRETCH]));
          } else {
            k = d.binarySearch(c, e, f.ENTRIES);
            var b = c[k + f.PREV_MIX], m = c[k + f.PREV_SOFTNESS], q = c[k];
            e = this.getCurvePercent(k / f.ENTRIES - 1, 1 - (e - q) / (c[k + f.PREV_TIME] - q));
            p == g.setup ? (a.mix = a.data.mix + (b + (c[k + f.MIX] - b) * e - a.data.mix) * n, a.softness = a.data.softness + (m + (c[k + f.SOFTNESS] - m) * e - a.data.softness) * n, t == h.mixOut ? (a.bendDirection = a.data.bendDirection, a.compress = a.data.compress, a.stretch = a.data.stretch) : (a.bendDirection = c[k + f.PREV_BEND_DIRECTION], a.compress = 0 != c[k + f.PREV_COMPRESS], a.stretch = 0 != c[k + f.PREV_STRETCH])) : (a.mix += (b + (c[k + f.MIX] - b) * e - a.mix) * n, a.softness += 
            (m + (c[k + f.SOFTNESS] - m) * e - a.softness) * n, t == h.mixIn && (a.bendDirection = c[k + f.PREV_BEND_DIRECTION], a.compress = 0 != c[k + f.PREV_COMPRESS], a.stretch = 0 != c[k + f.PREV_STRETCH]));
          }
        }
      }
    };
    f.ENTRIES = 6;
    f.PREV_TIME = -6;
    f.PREV_MIX = -5;
    f.PREV_SOFTNESS = -4;
    f.PREV_BEND_DIRECTION = -3;
    f.PREV_COMPRESS = -2;
    f.PREV_STRETCH = -1;
    f.MIX = 1;
    f.SOFTNESS = 2;
    f.BEND_DIRECTION = 3;
    f.COMPRESS = 4;
    f.STRETCH = 5;
    return f;
  }(k);
  a.IkConstraintTimeline = c;
  c = function(c) {
    function f(b) {
      var e = c.call(this, b) || this;
      e.frames = a.Utils.newFloatArray(b * f.ENTRIES);
      return e;
    }
    __extends(f, c);
    f.prototype.getPropertyId = function() {
      return (e.transformConstraint << 24) + this.transformConstraintIndex;
    };
    f.prototype.setFrame = function(a, c, e, d, k, h) {
      a *= f.ENTRIES;
      this.frames[a] = c;
      this.frames[a + f.ROTATE] = e;
      this.frames[a + f.TRANSLATE] = d;
      this.frames[a + f.SCALE] = k;
      this.frames[a + f.SHEAR] = h;
    };
    f.prototype.apply = function(a, c, e, k, h, n, p) {
      c = this.frames;
      a = a.transformConstraints[this.transformConstraintIndex];
      if (a.active) {
        if (e < c[0]) {
          switch(e = a.data, n) {
            case g.setup:
              a.rotateMix = e.rotateMix;
              a.translateMix = e.translateMix;
              a.scaleMix = e.scaleMix;
              a.shearMix = e.shearMix;
              break;
            case g.first:
              a.rotateMix += (e.rotateMix - a.rotateMix) * h, a.translateMix += (e.translateMix - a.translateMix) * h, a.scaleMix += (e.scaleMix - a.scaleMix) * h, a.shearMix += (e.shearMix - a.shearMix) * h;
          }
        } else {
          if (e >= c[c.length - f.ENTRIES]) {
            e = c.length;
            k = c[e + f.PREV_ROTATE];
            p = c[e + f.PREV_TRANSLATE];
            var b = c[e + f.PREV_SCALE];
            var m = c[e + f.PREV_SHEAR];
          } else {
            var t = d.binarySearch(c, e, f.ENTRIES);
            k = c[t + f.PREV_ROTATE];
            p = c[t + f.PREV_TRANSLATE];
            b = c[t + f.PREV_SCALE];
            m = c[t + f.PREV_SHEAR];
            var q = c[t];
            e = this.getCurvePercent(t / f.ENTRIES - 1, 1 - (e - q) / (c[t + f.PREV_TIME] - q));
            k += (c[t + f.ROTATE] - k) * e;
            p += (c[t + f.TRANSLATE] - p) * e;
            b += (c[t + f.SCALE] - b) * e;
            m += (c[t + f.SHEAR] - m) * e;
          }
          n == g.setup ? (e = a.data, a.rotateMix = e.rotateMix + (k - e.rotateMix) * h, a.translateMix = e.translateMix + (p - e.translateMix) * h, a.scaleMix = e.scaleMix + (b - e.scaleMix) * h, a.shearMix = e.shearMix + (m - e.shearMix) * h) : (a.rotateMix += (k - a.rotateMix) * h, a.translateMix += (p - a.translateMix) * h, a.scaleMix += (b - a.scaleMix) * h, a.shearMix += (m - a.shearMix) * h);
        }
      }
    };
    f.ENTRIES = 5;
    f.PREV_TIME = -5;
    f.PREV_ROTATE = -4;
    f.PREV_TRANSLATE = -3;
    f.PREV_SCALE = -2;
    f.PREV_SHEAR = -1;
    f.ROTATE = 1;
    f.TRANSLATE = 2;
    f.SCALE = 3;
    f.SHEAR = 4;
    return f;
  }(k);
  a.TransformConstraintTimeline = c;
  c = function(c) {
    function f(b) {
      var e = c.call(this, b) || this;
      e.frames = a.Utils.newFloatArray(b * f.ENTRIES);
      return e;
    }
    __extends(f, c);
    f.prototype.getPropertyId = function() {
      return (e.pathConstraintPosition << 24) + this.pathConstraintIndex;
    };
    f.prototype.setFrame = function(a, c, e) {
      a *= f.ENTRIES;
      this.frames[a] = c;
      this.frames[a + f.VALUE] = e;
    };
    f.prototype.apply = function(a, c, e, k, h, n, p) {
      c = this.frames;
      a = a.pathConstraints[this.pathConstraintIndex];
      if (a.active) {
        if (e < c[0]) {
          switch(n) {
            case g.setup:
              a.position = a.data.position;
              break;
            case g.first:
              a.position += (a.data.position - a.position) * h;
          }
        } else {
          if (e >= c[c.length - f.ENTRIES]) {
            k = c[c.length + f.PREV_VALUE];
          } else {
            p = d.binarySearch(c, e, f.ENTRIES);
            k = c[p + f.PREV_VALUE];
            var b = c[p];
            e = this.getCurvePercent(p / f.ENTRIES - 1, 1 - (e - b) / (c[p + f.PREV_TIME] - b));
            k += (c[p + f.VALUE] - k) * e;
          }
          a.position = n == g.setup ? a.data.position + (k - a.data.position) * h : a.position + (k - a.position) * h;
        }
      }
    };
    f.ENTRIES = 2;
    f.PREV_TIME = -2;
    f.PREV_VALUE = -1;
    f.VALUE = 1;
    return f;
  }(k);
  a.PathConstraintPositionTimeline = c;
  c = function(a) {
    function c(b) {
      return a.call(this, b) || this;
    }
    __extends(c, a);
    c.prototype.getPropertyId = function() {
      return (e.pathConstraintSpacing << 24) + this.pathConstraintIndex;
    };
    c.prototype.apply = function(a, e, f, k, h, n, p) {
      e = this.frames;
      a = a.pathConstraints[this.pathConstraintIndex];
      if (a.active) {
        if (f < e[0]) {
          switch(n) {
            case g.setup:
              a.spacing = a.data.spacing;
              break;
            case g.first:
              a.spacing += (a.data.spacing - a.spacing) * h;
          }
        } else {
          if (f >= e[e.length - c.ENTRIES]) {
            k = e[e.length + c.PREV_VALUE];
          } else {
            p = d.binarySearch(e, f, c.ENTRIES);
            k = e[p + c.PREV_VALUE];
            var b = e[p];
            f = this.getCurvePercent(p / c.ENTRIES - 1, 1 - (f - b) / (e[p + c.PREV_TIME] - b));
            k += (e[p + c.VALUE] - k) * f;
          }
          a.spacing = n == g.setup ? a.data.spacing + (k - a.data.spacing) * h : a.spacing + (k - a.spacing) * h;
        }
      }
    };
    return c;
  }(c);
  a.PathConstraintSpacingTimeline = c;
  k = function(c) {
    function f(b) {
      var e = c.call(this, b) || this;
      e.frames = a.Utils.newFloatArray(b * f.ENTRIES);
      return e;
    }
    __extends(f, c);
    f.prototype.getPropertyId = function() {
      return (e.pathConstraintMix << 24) + this.pathConstraintIndex;
    };
    f.prototype.setFrame = function(a, c, e, d) {
      a *= f.ENTRIES;
      this.frames[a] = c;
      this.frames[a + f.ROTATE] = e;
      this.frames[a + f.TRANSLATE] = d;
    };
    f.prototype.apply = function(a, c, e, k, h, n, p) {
      c = this.frames;
      a = a.pathConstraints[this.pathConstraintIndex];
      if (a.active) {
        if (e < c[0]) {
          switch(n) {
            case g.setup:
              a.rotateMix = a.data.rotateMix;
              a.translateMix = a.data.translateMix;
              break;
            case g.first:
              a.rotateMix += (a.data.rotateMix - a.rotateMix) * h, a.translateMix += (a.data.translateMix - a.translateMix) * h;
          }
        } else {
          if (e >= c[c.length - f.ENTRIES]) {
            k = c[c.length + f.PREV_ROTATE], p = c[c.length + f.PREV_TRANSLATE];
          } else {
            var b = d.binarySearch(c, e, f.ENTRIES);
            k = c[b + f.PREV_ROTATE];
            p = c[b + f.PREV_TRANSLATE];
            var m = c[b];
            e = this.getCurvePercent(b / f.ENTRIES - 1, 1 - (e - m) / (c[b + f.PREV_TIME] - m));
            k += (c[b + f.ROTATE] - k) * e;
            p += (c[b + f.TRANSLATE] - p) * e;
          }
          n == g.setup ? (a.rotateMix = a.data.rotateMix + (k - a.data.rotateMix) * h, a.translateMix = a.data.translateMix + (p - a.data.translateMix) * h) : (a.rotateMix += (k - a.rotateMix) * h, a.translateMix += (p - a.translateMix) * h);
        }
      }
    };
    f.ENTRIES = 3;
    f.PREV_TIME = -3;
    f.PREV_ROTATE = -2;
    f.PREV_TRANSLATE = -1;
    f.ROTATE = 1;
    f.TRANSLATE = 2;
    return f;
  }(k);
  a.PathConstraintMixTimeline = k;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function e(c) {
      this.tracks = [];
      this.timeScale = 1;
      this.events = [];
      this.listeners = [];
      this.queue = new h(this);
      this.propertyIDs = new a.IntSet;
      this.animationsChanged = !1;
      this.trackEntryPool = new a.Pool(function() {
        return new g;
      });
      this.data = c;
    }
    e.prototype.update = function(a) {
      a *= this.timeScale;
      for (var c = this.tracks, e = 0, d = c.length; e < d; e++) {
        var k = c[e];
        if (null != k) {
          k.animationLast = k.nextAnimationLast;
          k.trackLast = k.nextTrackLast;
          var b = a * k.timeScale;
          if (0 < k.delay) {
            k.delay -= b;
            if (0 < k.delay) {
              continue;
            }
            b = -k.delay;
            k.delay = 0;
          }
          var h = k.next;
          if (null != h) {
            var g = k.trackLast - h.delay;
            if (0 <= g) {
              h.delay = 0;
              h.trackTime += 0 == k.timeScale ? 0 : (g / k.timeScale + a) * h.timeScale;
              k.trackTime += b;
              for (this.setCurrent(e, h, !0); null != h.mixingFrom;) {
                h.mixTime += a, h = h.mixingFrom;
              }
              continue;
            }
          } else {
            if (k.trackLast >= k.trackEnd && null == k.mixingFrom) {
              c[e] = null;
              this.queue.end(k);
              this.disposeNext(k);
              continue;
            }
          }
          if (null != k.mixingFrom && this.updateMixingFrom(k, a)) {
            for (h = k.mixingFrom, k.mixingFrom = null, null != h && (h.mixingTo = null); null != h;) {
              this.queue.end(h), h = h.mixingFrom;
            }
          }
          k.trackTime += b;
        }
      }
      this.queue.drain();
    };
    e.prototype.updateMixingFrom = function(a, e) {
      var c = a.mixingFrom;
      if (null == c) {
        return !0;
      }
      var d = this.updateMixingFrom(c, e);
      c.animationLast = c.nextAnimationLast;
      c.trackLast = c.nextTrackLast;
      if (0 < a.mixTime && a.mixTime >= a.mixDuration) {
        if (0 == c.totalAlpha || 0 == a.mixDuration) {
          a.mixingFrom = c.mixingFrom, null != c.mixingFrom && (c.mixingFrom.mixingTo = a), a.interruptAlpha = c.interruptAlpha, this.queue.end(c);
        }
        return d;
      }
      c.trackTime += e * c.timeScale;
      a.mixTime += e;
      return !1;
    };
    e.prototype.apply = function(c) {
      if (null == c) {
        throw Error("skeleton cannot be null.");
      }
      this.animationsChanged && this._animationsChanged();
      for (var d = this.events, k = this.tracks, f = !1, h = 0, b = k.length; h < b; h++) {
        var m = k[h];
        if (!(null == m || 0 < m.delay)) {
          f = !0;
          var g = 0 == h ? a.MixBlend.first : m.mixBlend, y = m.alpha;
          null != m.mixingFrom ? y *= this.applyMixingFrom(m, c, g) : m.trackTime >= m.trackEnd && null == m.next && (y = 0);
          var x = m.animationLast, z = m.getAnimationTime(), r = m.animation.timelines.length, u = m.animation.timelines;
          if (0 == h && 1 == y || g == a.MixBlend.add) {
            for (var v = 0; v < r; v++) {
              a.Utils.webkit602BugfixHelper(y, g), u[v].apply(c, x, z, d, y, g, a.MixDirection.mixIn);
            }
          } else {
            var C = m.timelineMode, A = 0 == m.timelinesRotation.length;
            A && a.Utils.setArraySize(m.timelinesRotation, r << 1, null);
            var D = m.timelinesRotation;
            for (v = 0; v < r; v++) {
              var F = u[v], B = (C[v] & e.NOT_LAST - 1) == e.SUBSEQUENT ? g : a.MixBlend.setup;
              F instanceof a.RotateTimeline ? this.applyRotateTimeline(F, c, z, y, B, D, v << 1, A) : (a.Utils.webkit602BugfixHelper(y, g), F.apply(c, x, z, d, y, B, a.MixDirection.mixIn));
            }
          }
          this.queueEvents(m, z);
          d.length = 0;
          m.nextAnimationLast = z;
          m.nextTrackLast = m.trackTime;
        }
      }
      this.queue.drain();
      return f;
    };
    e.prototype.applyMixingFrom = function(c, d, k) {
      var f = c.mixingFrom;
      null != f.mixingFrom && this.applyMixingFrom(f, d, k);
      if (0 == c.mixDuration) {
        var h = 1;
        k == a.MixBlend.first && (k = a.MixBlend.setup);
      } else {
        h = c.mixTime / c.mixDuration, 1 < h && (h = 1), k != a.MixBlend.first && (k = f.mixBlend);
      }
      var b = h < f.eventThreshold ? this.events : null, m = h < f.attachmentThreshold, g = h < f.drawOrderThreshold, p = f.animationLast, t = f.getAnimationTime(), z = f.animation.timelines.length, r = f.animation.timelines, u = f.alpha * c.interruptAlpha, v = u * (1 - h);
      if (k == a.MixBlend.add) {
        for (var C = 0; C < z; C++) {
          r[C].apply(d, p, t, b, v, k, a.MixDirection.mixOut);
        }
      } else {
        var A = f.timelineMode, D = f.timelineHoldMix, F = 0 == f.timelinesRotation.length;
        F && a.Utils.setArraySize(f.timelinesRotation, z << 1, null);
        var B = f.timelinesRotation;
        for (C = f.totalAlpha = 0; C < z; C++) {
          var E = r[C], H = a.MixDirection.mixOut;
          switch(A[C] & e.NOT_LAST - 1) {
            case e.SUBSEQUENT:
              var L = k;
              if (!m && E instanceof a.AttachmentTimeline) {
                if ((A[C] & e.NOT_LAST) == e.NOT_LAST) {
                  continue;
                }
                L = a.MixBlend.setup;
              }
              if (!g && E instanceof a.DrawOrderTimeline) {
                continue;
              }
              var K = v;
              break;
            case e.FIRST:
              L = a.MixBlend.setup;
              K = v;
              break;
            case e.HOLD:
              L = a.MixBlend.setup;
              K = u;
              break;
            default:
              L = a.MixBlend.setup, K = D[C], K = u * Math.max(0, 1 - K.mixTime / K.mixDuration);
          }
          f.totalAlpha += K;
          if (E instanceof a.RotateTimeline) {
            this.applyRotateTimeline(E, d, t, K, L, B, C << 1, F);
          } else {
            a.Utils.webkit602BugfixHelper(K, k);
            if (L == a.MixBlend.setup) {
              if (E instanceof a.AttachmentTimeline) {
                if (m || (A[C] & e.NOT_LAST) == e.NOT_LAST) {
                  H = a.MixDirection.mixIn;
                }
              } else {
                E instanceof a.DrawOrderTimeline && g && (H = a.MixDirection.mixIn);
              }
            }
            E.apply(d, p, t, b, K, L, H);
          }
        }
      }
      0 < c.mixDuration && this.queueEvents(f, t);
      this.events.length = 0;
      f.nextAnimationLast = t;
      f.nextTrackLast = f.trackTime;
      return h;
    };
    e.prototype.applyRotateTimeline = function(c, e, d, f, k, b, h, g) {
      g && (b[h] = 0);
      if (1 == f) {
        c.apply(e, 0, d, null, 1, k, a.MixDirection.mixIn);
      } else {
        var m = c.frames;
        e = e.bones[c.boneIndex];
        if (e.active) {
          if (d < m[0]) {
            switch(k) {
              case a.MixBlend.setup:
                e.rotation = e.data.rotation;
              default:
                return;
              case a.MixBlend.first:
                k = e.rotation, m = e.data.rotation;
            }
          } else {
            if (k = k == a.MixBlend.setup ? e.data.rotation : e.rotation, d >= m[m.length - a.RotateTimeline.ENTRIES]) {
              m = e.data.rotation + m[m.length + a.RotateTimeline.PREV_ROTATION];
            } else {
              var p = a.Animation.binarySearch(m, d, a.RotateTimeline.ENTRIES), n = m[p + a.RotateTimeline.PREV_ROTATION], t = m[p];
              c = c.getCurvePercent((p >> 1) - 1, 1 - (d - t) / (m[p + a.RotateTimeline.PREV_TIME] - t));
              m = m[p + a.RotateTimeline.ROTATION] - n;
              m = n + (m - 360 * (16384 - (16384.499999999996 - m / 360 | 0))) * c + e.data.rotation;
              m -= 360 * (16384 - (16384.499999999996 - m / 360 | 0));
            }
          }
          m -= k;
          m -= 360 * (16384 - (16384.499999999996 - m / 360 | 0));
          0 == m ? n = b[h] : (g ? (g = 0, n = m) : (g = b[h], n = b[h + 1]), c = 0 < m, d = 0 <= g, a.MathUtils.signum(n) != a.MathUtils.signum(m) && 90 >= Math.abs(n) && (180 < Math.abs(g) && (g += 360 * a.MathUtils.signum(g)), d = c), n = m + g - g % 360, d != c && (n += 360 * a.MathUtils.signum(g)), b[h] = n);
          b[h + 1] = m;
          k += n * f;
          e.rotation = k - 360 * (16384 - (16384.499999999996 - k / 360 | 0));
        }
      }
    };
    e.prototype.queueEvents = function(a, e) {
      for (var c = a.animationStart, d = a.animationEnd, k = d - c, b = a.trackLast % k, h = this.events, g = 0, p = h.length; g < p; g++) {
        var x = h[g];
        if (x.time < b) {
          break;
        }
        x.time > d || this.queue.event(a, x);
      }
      for ((a.loop ? 0 == k || b > a.trackTime % k : e >= d && a.animationLast < d) && this.queue.complete(a); g < p; g++) {
        h[g].time < c || this.queue.event(a, h[g]);
      }
    };
    e.prototype.clearTracks = function() {
      var a = this.queue.drainDisabled;
      this.queue.drainDisabled = !0;
      for (var e = 0, d = this.tracks.length; e < d; e++) {
        this.clearTrack(e);
      }
      this.tracks.length = 0;
      this.queue.drainDisabled = a;
      this.queue.drain();
    };
    e.prototype.clearTrack = function(a) {
      if (!(a >= this.tracks.length) && (a = this.tracks[a], null != a)) {
        this.queue.end(a);
        this.disposeNext(a);
        for (var c = a;;) {
          var e = c.mixingFrom;
          if (null == e) {
            break;
          }
          this.queue.end(e);
          c.mixingFrom = null;
          c.mixingTo = null;
          c = e;
        }
        this.tracks[a.trackIndex] = null;
        this.queue.drain();
      }
    };
    e.prototype.setCurrent = function(a, e, d) {
      var c = this.expandToIndex(a);
      this.tracks[a] = e;
      null != c && (d && this.queue.interrupt(c), e.mixingFrom = c, c.mixingTo = e, e.mixTime = 0, null != c.mixingFrom && 0 < c.mixDuration && (e.interruptAlpha *= Math.min(1, c.mixTime / c.mixDuration)), c.timelinesRotation.length = 0);
      this.queue.start(e);
    };
    e.prototype.setAnimation = function(a, e, d) {
      var c = this.data.skeletonData.findAnimation(e);
      if (null == c) {
        throw Error("Animation not found: " + e);
      }
      return this.setAnimationWith(a, c, d);
    };
    e.prototype.setAnimationWith = function(a, e, d) {
      if (null == e) {
        throw Error("animation cannot be null.");
      }
      var c = !0, k = this.expandToIndex(a);
      null != k && (-1 == k.nextTrackLast ? (this.tracks[a] = k.mixingFrom, this.queue.interrupt(k), this.queue.end(k), this.disposeNext(k), k = k.mixingFrom, c = !1) : this.disposeNext(k));
      e = this.trackEntry(a, e, d, k);
      this.setCurrent(a, e, c);
      this.queue.drain();
      return e;
    };
    e.prototype.addAnimation = function(a, e, d, f) {
      var c = this.data.skeletonData.findAnimation(e);
      if (null == c) {
        throw Error("Animation not found: " + e);
      }
      return this.addAnimationWith(a, c, d, f);
    };
    e.prototype.addAnimationWith = function(a, e, d, f) {
      if (null == e) {
        throw Error("animation cannot be null.");
      }
      var c = this.expandToIndex(a);
      if (null != c) {
        for (; null != c.next;) {
          c = c.next;
        }
      }
      d = this.trackEntry(a, e, d, c);
      null == c ? (this.setCurrent(a, d, !0), this.queue.drain()) : (c.next = d, 0 >= f && (a = c.animationEnd - c.animationStart, 0 != a ? (f = c.loop ? f + a * (1 + (c.trackTime / a | 0)) : f + Math.max(a, c.trackTime), f -= this.data.getMix(c.animation, e)) : f = c.trackTime));
      d.delay = f;
      return d;
    };
    e.prototype.setEmptyAnimation = function(a, d) {
      a = this.setAnimationWith(a, e.emptyAnimation, !1);
      a.mixDuration = d;
      a.trackEnd = d;
      return a;
    };
    e.prototype.addEmptyAnimation = function(a, d, k) {
      0 >= k && (k -= d);
      a = this.addAnimationWith(a, e.emptyAnimation, !1, k);
      a.mixDuration = d;
      a.trackEnd = d;
      return a;
    };
    e.prototype.setEmptyAnimations = function(a) {
      var c = this.queue.drainDisabled;
      this.queue.drainDisabled = !0;
      for (var e = 0, d = this.tracks.length; e < d; e++) {
        var k = this.tracks[e];
        null != k && this.setEmptyAnimation(k.trackIndex, a);
      }
      this.queue.drainDisabled = c;
      this.queue.drain();
    };
    e.prototype.expandToIndex = function(c) {
      if (c < this.tracks.length) {
        return this.tracks[c];
      }
      a.Utils.ensureArrayCapacity(this.tracks, c + 1, null);
      this.tracks.length = c + 1;
      return null;
    };
    e.prototype.trackEntry = function(c, e, d, f) {
      var k = this.trackEntryPool.obtain();
      k.trackIndex = c;
      k.animation = e;
      k.loop = d;
      k.holdPrevious = !1;
      k.eventThreshold = 0;
      k.attachmentThreshold = 0;
      k.drawOrderThreshold = 0;
      k.animationStart = 0;
      k.animationEnd = e.duration;
      k.animationLast = -1;
      k.nextAnimationLast = -1;
      k.delay = 0;
      k.trackTime = 0;
      k.trackLast = -1;
      k.nextTrackLast = -1;
      k.trackEnd = Number.MAX_VALUE;
      k.timeScale = 1;
      k.alpha = 1;
      k.interruptAlpha = 1;
      k.mixTime = 0;
      k.mixDuration = null == f ? 0 : this.data.getMix(f.animation, e);
      k.mixBlend = a.MixBlend.replace;
      return k;
    };
    e.prototype.disposeNext = function(a) {
      for (var c = a.next; null != c;) {
        this.queue.dispose(c), c = c.next;
      }
      a.next = null;
    };
    e.prototype._animationsChanged = function() {
      this.animationsChanged = !1;
      this.propertyIDs.clear();
      for (var c = 0, e = this.tracks.length; c < e; c++) {
        var d = this.tracks[c];
        if (null != d) {
          for (; null != d.mixingFrom;) {
            d = d.mixingFrom;
          }
          do {
            null != d.mixingFrom && d.mixBlend == a.MixBlend.add || this.computeHold(d), d = d.mixingTo;
          } while (null != d);
        }
      }
      this.propertyIDs.clear();
      for (c = this.tracks.length - 1; 0 <= c; c--) {
        for (d = this.tracks[c]; null != d;) {
          this.computeNotLast(d), d = d.mixingFrom;
        }
      }
    };
    e.prototype.computeHold = function(c) {
      var d = c.mixingTo, k = c.animation.timelines, f = c.animation.timelines.length, h = a.Utils.setArraySize(c.timelineMode, f);
      c.timelineHoldMix.length = 0;
      var b = a.Utils.setArraySize(c.timelineHoldMix, f), m = this.propertyIDs;
      if (null != d && d.holdPrevious) {
        for (var g = 0; g < f; g++) {
          m.add(k[g].getPropertyId()), h[g] = e.HOLD;
        }
      } else {
        a: for (g = 0; g < f; g++) {
          var y = k[g], x = y.getPropertyId();
          if (m.add(x)) {
            if (null == d || y instanceof a.AttachmentTimeline || y instanceof a.DrawOrderTimeline || y instanceof a.EventTimeline || !d.animation.hasTimeline(x)) {
              h[g] = e.FIRST;
            } else {
              for (y = d.mixingTo; null != y; y = y.mixingTo) {
                if (!y.animation.hasTimeline(x)) {
                  if (0 < c.mixDuration) {
                    h[g] = e.HOLD_MIX;
                    b[g] = y;
                    continue a;
                  }
                  break;
                }
              }
              h[g] = e.HOLD;
            }
          } else {
            h[g] = e.SUBSEQUENT;
          }
        }
      }
    };
    e.prototype.computeNotLast = function(c) {
      var d = c.animation.timelines, k = c.animation.timelines.length;
      c = c.timelineMode;
      for (var f = this.propertyIDs, h = 0; h < k; h++) {
        d[h] instanceof a.AttachmentTimeline && (f.add(d[h].slotIndex) || (c[h] |= e.NOT_LAST));
      }
    };
    e.prototype.getCurrent = function(a) {
      return a >= this.tracks.length ? null : this.tracks[a];
    };
    e.prototype.addListener = function(a) {
      if (null == a) {
        throw Error("listener cannot be null.");
      }
      this.listeners.push(a);
    };
    e.prototype.removeListener = function(a) {
      a = this.listeners.indexOf(a);
      0 <= a && this.listeners.splice(a, 1);
    };
    e.prototype.clearListeners = function() {
      this.listeners.length = 0;
    };
    e.prototype.clearListenerNotifications = function() {
      this.queue.clear();
    };
    e.emptyAnimation = new a.Animation("<empty>", [], 0);
    e.SUBSEQUENT = 0;
    e.FIRST = 1;
    e.HOLD = 2;
    e.HOLD_MIX = 3;
    e.NOT_LAST = 4;
    return e;
  }();
  a.AnimationState = d;
  var g = function() {
    function e() {
      this.mixBlend = a.MixBlend.replace;
      this.timelineMode = [];
      this.timelineHoldMix = [];
      this.timelinesRotation = [];
    }
    e.prototype.reset = function() {
      this.listener = this.animation = this.mixingTo = this.mixingFrom = this.next = null;
      this.timelineMode.length = 0;
      this.timelineHoldMix.length = 0;
      this.timelinesRotation.length = 0;
    };
    e.prototype.getAnimationTime = function() {
      if (this.loop) {
        var a = this.animationEnd - this.animationStart;
        return 0 == a ? this.animationStart : this.trackTime % a + this.animationStart;
      }
      return Math.min(this.trackTime + this.animationStart, this.animationEnd);
    };
    e.prototype.setAnimationLast = function(a) {
      this.nextAnimationLast = this.animationLast = a;
    };
    e.prototype.isComplete = function() {
      return this.trackTime >= this.animationEnd - this.animationStart;
    };
    e.prototype.resetRotationDirections = function() {
      this.timelinesRotation.length = 0;
    };
    return e;
  }();
  a.TrackEntry = g;
  var h = function() {
    function a(a) {
      this.objects = [];
      this.drainDisabled = !1;
      this.animState = a;
    }
    a.prototype.start = function(a) {
      this.objects.push(e.start);
      this.objects.push(a);
      this.animState.animationsChanged = !0;
    };
    a.prototype.interrupt = function(a) {
      this.objects.push(e.interrupt);
      this.objects.push(a);
    };
    a.prototype.end = function(a) {
      this.objects.push(e.end);
      this.objects.push(a);
      this.animState.animationsChanged = !0;
    };
    a.prototype.dispose = function(a) {
      this.objects.push(e.dispose);
      this.objects.push(a);
    };
    a.prototype.complete = function(a) {
      this.objects.push(e.complete);
      this.objects.push(a);
    };
    a.prototype.event = function(a, d) {
      this.objects.push(e.event);
      this.objects.push(a);
      this.objects.push(d);
    };
    a.prototype.drain = function() {
      if (!this.drainDisabled) {
        this.drainDisabled = !0;
        for (var a = this.objects, d = this.animState.listeners, k = 0; k < a.length; k += 2) {
          var f = a[k + 1];
          switch(a[k]) {
            case e.start:
              null != f.listener && f.listener.start && f.listener.start(f);
              for (var h = 0; h < d.length; h++) {
                d[h].start && d[h].start(f);
              }
              break;
            case e.interrupt:
              null != f.listener && f.listener.interrupt && f.listener.interrupt(f);
              for (h = 0; h < d.length; h++) {
                d[h].interrupt && d[h].interrupt(f);
              }
              break;
            case e.end:
              for (null != f.listener && f.listener.end && f.listener.end(f), h = 0; h < d.length; h++) {
                d[h].end && d[h].end(f);
              }
            case e.dispose:
              null != f.listener && f.listener.dispose && f.listener.dispose(f);
              for (h = 0; h < d.length; h++) {
                d[h].dispose && d[h].dispose(f);
              }
              this.animState.trackEntryPool.free(f);
              break;
            case e.complete:
              null != f.listener && f.listener.complete && f.listener.complete(f);
              for (h = 0; h < d.length; h++) {
                d[h].complete && d[h].complete(f);
              }
              break;
            case e.event:
              var b = a[k++ + 2];
              null != f.listener && f.listener.event && f.listener.event(f, b);
              for (h = 0; h < d.length; h++) {
                d[h].event && d[h].event(f, b);
              }
          }
        }
        this.clear();
        this.drainDisabled = !1;
      }
    };
    a.prototype.clear = function() {
      this.objects.length = 0;
    };
    return a;
  }();
  a.EventQueue = h;
  var e;
  (function(a) {
    a[a.start = 0] = "start";
    a[a.interrupt = 1] = "interrupt";
    a[a.end = 2] = "end";
    a[a.dispose = 3] = "dispose";
    a[a.complete = 4] = "complete";
    a[a.event = 5] = "event";
  })(e = a.EventType || (a.EventType = {}));
  d = function() {
    function a() {
    }
    a.prototype.start = function(a) {
    };
    a.prototype.interrupt = function(a) {
    };
    a.prototype.end = function(a) {
    };
    a.prototype.dispose = function(a) {
    };
    a.prototype.complete = function(a) {
    };
    a.prototype.event = function(a, e) {
    };
    return a;
  }();
  a.AnimationStateAdapter = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function a(a) {
      this.animationToMixTime = {};
      this.defaultMix = 0;
      if (null == a) {
        throw Error("skeletonData cannot be null.");
      }
      this.skeletonData = a;
    }
    a.prototype.setMix = function(a, e, d) {
      var c = this.skeletonData.findAnimation(a);
      if (null == c) {
        throw Error("Animation not found: " + a);
      }
      a = this.skeletonData.findAnimation(e);
      if (null == a) {
        throw Error("Animation not found: " + e);
      }
      this.setMixWith(c, a, d);
    };
    a.prototype.setMixWith = function(a, e, d) {
      if (null == a) {
        throw Error("from cannot be null.");
      }
      if (null == e) {
        throw Error("to cannot be null.");
      }
      this.animationToMixTime[a.name + "." + e.name] = d;
    };
    a.prototype.getMix = function(a, e) {
      a = this.animationToMixTime[a.name + "." + e.name];
      return void 0 === a ? this.defaultMix : a;
    };
    return a;
  }();
  a.AnimationStateData = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d(a, e) {
      void 0 === e && (e = "");
      this.assets = {};
      this.errors = {};
      this.loaded = this.toLoad = 0;
      this.rawDataUris = {};
      this.textureLoader = a;
      this.pathPrefix = e;
    }
    d.prototype.downloadText = function(a, e, d) {
      var c = new XMLHttpRequest;
      c.overrideMimeType("text/html");
      this.rawDataUris[a] && (a = this.rawDataUris[a]);
      c.open("GET", a, !0);
      c.onload = function() {
        200 == c.status ? e(c.responseText) : d(c.status, c.responseText);
      };
      c.onerror = function() {
        d(c.status, c.responseText);
      };
      c.send();
    };
    d.prototype.downloadBinary = function(a, e, d) {
      var c = new XMLHttpRequest;
      this.rawDataUris[a] && (a = this.rawDataUris[a]);
      c.open("GET", a, !0);
      c.responseType = "arraybuffer";
      c.onload = function() {
        200 == c.status ? e(new Uint8Array(c.response)) : d(c.status, c.responseText);
      };
      c.onerror = function() {
        d(c.status, c.responseText);
      };
      c.send();
    };
    d.prototype.setRawDataURI = function(a, e) {
      this.rawDataUris[this.pathPrefix + a] = e;
    };
    d.prototype.loadBinary = function(a, e, d) {
      var c = this;
      void 0 === e && (e = null);
      void 0 === d && (d = null);
      a = this.pathPrefix + a;
      this.toLoad++;
      this.downloadBinary(a, function(d) {
        c.assets[a] = d;
        e && e(a, d);
        c.toLoad--;
        c.loaded++;
      }, function(e, k) {
        c.errors[a] = "Couldn't load binary " + a + ": status " + status + ", " + k;
        d && d(a, "Couldn't load binary " + a + ": status " + status + ", " + k);
        c.toLoad--;
        c.loaded++;
      });
    };
    d.prototype.loadText = function(a, e, d) {
      var c = this;
      void 0 === e && (e = null);
      void 0 === d && (d = null);
      a = this.pathPrefix + a;
      this.toLoad++;
      this.downloadText(a, function(d) {
        c.assets[a] = d;
        e && e(a, d);
        c.toLoad--;
        c.loaded++;
      }, function(e, k) {
        c.errors[a] = "Couldn't load text " + a + ": status " + status + ", " + k;
        d && d(a, "Couldn't load text " + a + ": status " + status + ", " + k);
        c.toLoad--;
        c.loaded++;
      });
    };
    d.prototype.loadTexture = function(a, e, d) {
      var c = this;
      void 0 === e && (e = null);
      void 0 === d && (d = null);
      var k = a = this.pathPrefix + a;
      this.toLoad++;
      var h = new Image;
      h.crossOrigin = "anonymous";
      h.onload = function(d) {
        d = c.textureLoader(h);
        c.assets[k] = d;
        c.toLoad--;
        c.loaded++;
        e && e(a, h);
      };
      h.onerror = function(e) {
        c.errors[a] = "Couldn't load image " + a;
        c.toLoad--;
        c.loaded++;
        d && d(a, "Couldn't load image " + a);
      };
      this.rawDataUris[a] && (a = this.rawDataUris[a]);
      h.src = a;
    };
    d.prototype.loadTextureAtlas = function(d, e, k) {
      var c = this;
      void 0 === e && (e = null);
      void 0 === k && (k = null);
      var h = 0 <= d.lastIndexOf("/") ? d.substring(0, d.lastIndexOf("/")) : "";
      d = this.pathPrefix + d;
      this.toLoad++;
      this.downloadText(d, function(g) {
        var f = 0, p = [];
        try {
          new a.TextureAtlas(g, function(b) {
            p.push("" == h ? b : h + "/" + b);
            b = document.createElement("img");
            b.width = 16;
            b.height = 16;
            return new a.FakeTexture(b);
          });
        } catch (q) {
          var b = q;
          c.errors[d] = "Couldn't load texture atlas " + d + ": " + b.message;
          k && k(d, "Couldn't load texture atlas " + d + ": " + b.message);
          c.toLoad--;
          c.loaded++;
          return;
        }
        b = function(b) {
          var m = !1;
          c.loadTexture(b, function(b, n) {
            f++;
            if (f == p.length) {
              if (m) {
                c.errors[d] = "Couldn't load texture atlas page " + b + "} of atlas " + d, k && k(d, "Couldn't load texture atlas page " + b + " of atlas " + d), c.toLoad--, c.loaded++;
              } else {
                try {
                  var t = new a.TextureAtlas(g, function(a) {
                    return c.get("" == h ? a : h + "/" + a);
                  });
                  c.assets[d] = t;
                  e && e(d, t);
                  c.toLoad--;
                  c.loaded++;
                } catch (u) {
                  b = u, c.errors[d] = "Couldn't load texture atlas " + d + ": " + b.message, k && k(d, "Couldn't load texture atlas " + d + ": " + b.message), c.toLoad--, c.loaded++;
                }
              }
            }
          }, function(a, b) {
            m = !0;
            f++;
            f == p.length && (c.errors[d] = "Couldn't load texture atlas page " + a + "} of atlas " + d, k && k(d, "Couldn't load texture atlas page " + a + " of atlas " + d), c.toLoad--, c.loaded++);
          });
        };
        for (var m = 0; m < p.length; m++) {
          b(p[m]);
        }
      }, function(a, e) {
        c.errors[d] = "Couldn't load texture atlas " + d + ": status " + status + ", " + e;
        k && k(d, "Couldn't load texture atlas " + d + ": status " + status + ", " + e);
        c.toLoad--;
        c.loaded++;
      });
    };
    d.prototype.get = function(a) {
      a = this.pathPrefix + a;
      return this.assets[a];
    };
    d.prototype.remove = function(a) {
      a = this.pathPrefix + a;
      var e = this.assets[a];
      e.dispose && e.dispose();
      this.assets[a] = null;
    };
    d.prototype.removeAll = function() {
      for (var a in this.assets) {
        var e = this.assets[a];
        e.dispose && e.dispose();
      }
      this.assets = {};
    };
    d.prototype.isLoadingComplete = function() {
      return 0 == this.toLoad;
    };
    d.prototype.getToLoad = function() {
      return this.toLoad;
    };
    d.prototype.getLoaded = function() {
      return this.loaded;
    };
    d.prototype.dispose = function() {
      this.removeAll();
    };
    d.prototype.hasErrors = function() {
      return 0 < Object.keys(this.errors).length;
    };
    d.prototype.getErrors = function() {
      return this.errors;
    };
    return d;
  }();
  a.AssetManager = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d(a) {
      this.atlas = a;
    }
    d.prototype.newRegionAttachment = function(d, e, k) {
      d = this.atlas.findRegion(k);
      if (null == d) {
        throw Error("Region not found in atlas: " + k + " (region attachment: " + e + ")");
      }
      d.renderObject = d;
      e = new a.RegionAttachment(e);
      e.setRegion(d);
      return e;
    };
    d.prototype.newMeshAttachment = function(d, e, k) {
      d = this.atlas.findRegion(k);
      if (null == d) {
        throw Error("Region not found in atlas: " + k + " (mesh attachment: " + e + ")");
      }
      d.renderObject = d;
      e = new a.MeshAttachment(e);
      e.region = d;
      return e;
    };
    d.prototype.newBoundingBoxAttachment = function(d, e) {
      return new a.BoundingBoxAttachment(e);
    };
    d.prototype.newPathAttachment = function(d, e) {
      return new a.PathAttachment(e);
    };
    d.prototype.newPointAttachment = function(d, e) {
      return new a.PointAttachment(e);
    };
    d.prototype.newClippingAttachment = function(d, e) {
      return new a.ClippingAttachment(e);
    };
    return d;
  }();
  a.AtlasAttachmentLoader = d;
})(spine || (spine = {}));
(function(a) {
  a = a.BlendMode || (a.BlendMode = {});
  a[a.Normal = 0] = "Normal";
  a[a.Additive = 1] = "Additive";
  a[a.Multiply = 2] = "Multiply";
  a[a.Screen = 3] = "Screen";
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d(a, e, d) {
      this.children = [];
      this.ashearY = this.ashearX = this.ascaleY = this.ascaleX = this.arotation = this.ay = this.ax = this.shearY = this.shearX = this.scaleY = this.scaleX = this.rotation = this.y = this.x = 0;
      this.appliedValid = !1;
      this.worldX = this.worldY = this.d = this.c = this.b = this.a = 0;
      this.active = this.sorted = !1;
      if (null == a) {
        throw Error("data cannot be null.");
      }
      if (null == e) {
        throw Error("skeleton cannot be null.");
      }
      this.data = a;
      this.skeleton = e;
      this.parent = d;
      this.setToSetupPose();
    }
    d.prototype.isActive = function() {
      return this.active;
    };
    d.prototype.update = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    d.prototype.updateWorldTransform = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    d.prototype.updateWorldTransformWith = function(d, e, k, c, g, t, f) {
      this.ax = d;
      this.ay = e;
      this.arotation = k;
      this.ascaleX = c;
      this.ascaleY = g;
      this.ashearX = t;
      this.ashearY = f;
      this.appliedValid = !0;
      var h = this.parent;
      if (null == h) {
        var b = this.skeleton;
        f = k + 90 + f;
        var m = b.scaleX, p = b.scaleY;
        this.a = a.MathUtils.cosDeg(k + t) * c * m;
        this.b = a.MathUtils.cosDeg(f) * g * m;
        this.c = a.MathUtils.sinDeg(k + t) * c * p;
        this.d = a.MathUtils.sinDeg(f) * g * p;
        this.worldX = d * m + b.x;
        this.worldY = e * p + b.y;
      } else {
        b = h.a;
        m = h.b;
        p = h.c;
        var y = h.d;
        this.worldX = b * d + m * e + h.worldX;
        this.worldY = p * d + y * e + h.worldY;
        switch(this.data.transformMode) {
          case a.TransformMode.Normal:
            f = k + 90 + f;
            d = a.MathUtils.cosDeg(k + t) * c;
            e = a.MathUtils.cosDeg(f) * g;
            c *= a.MathUtils.sinDeg(k + t);
            g *= a.MathUtils.sinDeg(f);
            this.a = b * d + m * c;
            this.b = b * e + m * g;
            this.c = p * d + y * c;
            this.d = p * e + y * g;
            return;
          case a.TransformMode.OnlyTranslation:
            f = k + 90 + f;
            this.a = a.MathUtils.cosDeg(k + t) * c;
            this.b = a.MathUtils.cosDeg(f) * g;
            this.c = a.MathUtils.sinDeg(k + t) * c;
            this.d = a.MathUtils.sinDeg(f) * g;
            break;
          case a.TransformMode.NoRotationOrReflection:
            d = b * b + p * p;
            1E-4 < d ? (d = Math.abs(b * y - m * p) / d, m = p * d, y = b * d, d = Math.atan2(p, b) * a.MathUtils.radDeg) : (p = b = 0, d = 90 - Math.atan2(y, m) * a.MathUtils.radDeg);
            t = k + t - d;
            f = k + f - d + 90;
            d = a.MathUtils.cosDeg(t) * c;
            e = a.MathUtils.cosDeg(f) * g;
            c *= a.MathUtils.sinDeg(t);
            g *= a.MathUtils.sinDeg(f);
            this.a = b * d - m * c;
            this.b = b * e - m * g;
            this.c = p * d + y * c;
            this.d = p * e + y * g;
            break;
          case a.TransformMode.NoScale:
          case a.TransformMode.NoScaleOrReflection:
            d = a.MathUtils.cosDeg(k), e = a.MathUtils.sinDeg(k), k = (b * d + m * e) / this.skeleton.scaleX, h = (p * d + y * e) / this.skeleton.scaleY, d = Math.sqrt(k * k + h * h), 1E-5 < d && (d = 1 / d), k *= d, h *= d, d = Math.sqrt(k * k + h * h), this.data.transformMode == a.TransformMode.NoScale && 0 > b * y - m * p != (0 > this.skeleton.scaleX != 0 > this.skeleton.scaleY) && (d = -d), m = Math.PI / 2 + Math.atan2(h, k), b = Math.cos(m) * d, m = Math.sin(m) * d, d = a.MathUtils.cosDeg(t) * 
            c, e = a.MathUtils.cosDeg(90 + f) * g, c *= a.MathUtils.sinDeg(t), g *= a.MathUtils.sinDeg(90 + f), this.a = k * d + b * c, this.b = k * e + b * g, this.c = h * d + m * c, this.d = h * e + m * g;
        }
        this.a *= this.skeleton.scaleX;
        this.b *= this.skeleton.scaleX;
        this.c *= this.skeleton.scaleY;
        this.d *= this.skeleton.scaleY;
      }
    };
    d.prototype.setToSetupPose = function() {
      var a = this.data;
      this.x = a.x;
      this.y = a.y;
      this.rotation = a.rotation;
      this.scaleX = a.scaleX;
      this.scaleY = a.scaleY;
      this.shearX = a.shearX;
      this.shearY = a.shearY;
    };
    d.prototype.getWorldRotationX = function() {
      return Math.atan2(this.c, this.a) * a.MathUtils.radDeg;
    };
    d.prototype.getWorldRotationY = function() {
      return Math.atan2(this.d, this.b) * a.MathUtils.radDeg;
    };
    d.prototype.getWorldScaleX = function() {
      return Math.sqrt(this.a * this.a + this.c * this.c);
    };
    d.prototype.getWorldScaleY = function() {
      return Math.sqrt(this.b * this.b + this.d * this.d);
    };
    d.prototype.updateAppliedTransform = function() {
      this.appliedValid = !0;
      var d = this.parent;
      if (null == d) {
        this.ax = this.worldX, this.ay = this.worldY, this.arotation = Math.atan2(this.c, this.a) * a.MathUtils.radDeg, this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c), this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d), this.ashearX = 0, this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * a.MathUtils.radDeg;
      } else {
        var e = d.a, k = d.b, c = d.c, g = d.d, t = 1 / (e * g - k * c), f = this.worldX - d.worldX;
        d = this.worldY - d.worldY;
        this.ax = f * g * t - d * k * t;
        this.ay = d * e * t - f * c * t;
        g *= t;
        e *= t;
        k *= t;
        t *= c;
        c = g * this.a - k * this.c;
        k = g * this.b - k * this.d;
        g = e * this.c - t * this.a;
        t = e * this.d - t * this.b;
        this.ashearX = 0;
        this.ascaleX = Math.sqrt(c * c + g * g);
        1E-4 < this.ascaleX ? (e = c * t - k * g, this.ascaleY = e / this.ascaleX, this.ashearY = Math.atan2(c * k + g * t, e) * a.MathUtils.radDeg, this.arotation = Math.atan2(g, c) * a.MathUtils.radDeg) : (this.ascaleX = 0, this.ascaleY = Math.sqrt(k * k + t * t), this.ashearY = 0, this.arotation = 90 - Math.atan2(t, k) * a.MathUtils.radDeg);
      }
    };
    d.prototype.worldToLocal = function(a) {
      var e = this.a, d = this.b, c = this.c, h = this.d, g = 1 / (e * h - d * c), f = a.x - this.worldX, n = a.y - this.worldY;
      a.x = f * h * g - n * d * g;
      a.y = n * e * g - f * c * g;
      return a;
    };
    d.prototype.localToWorld = function(a) {
      var e = a.x, d = a.y;
      a.x = e * this.a + d * this.b + this.worldX;
      a.y = e * this.c + d * this.d + this.worldY;
      return a;
    };
    d.prototype.worldToLocalRotation = function(d) {
      var e = a.MathUtils.sinDeg(d);
      d = a.MathUtils.cosDeg(d);
      return Math.atan2(this.a * e - this.c * d, this.d * d - this.b * e) * a.MathUtils.radDeg + this.rotation - this.shearX;
    };
    d.prototype.localToWorldRotation = function(d) {
      d -= this.rotation - this.shearX;
      var e = a.MathUtils.sinDeg(d);
      d = a.MathUtils.cosDeg(d);
      return Math.atan2(d * this.c + e * this.d, d * this.a + e * this.b) * a.MathUtils.radDeg;
    };
    d.prototype.rotateWorld = function(d) {
      var e = this.a, k = this.b, c = this.c, h = this.d, g = a.MathUtils.cosDeg(d);
      d = a.MathUtils.sinDeg(d);
      this.a = g * e - d * c;
      this.b = g * k - d * h;
      this.c = d * e + g * c;
      this.d = d * k + g * h;
      this.appliedValid = !1;
    };
    return d;
  }();
  a.Bone = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    return function(d, e, k) {
      this.rotation = this.y = this.x = 0;
      this.scaleY = this.scaleX = 1;
      this.shearY = this.shearX = 0;
      this.transformMode = g.Normal;
      this.skinRequired = !1;
      this.color = new a.Color;
      if (0 > d) {
        throw Error("index must be >= 0.");
      }
      if (null == e) {
        throw Error("name cannot be null.");
      }
      this.index = d;
      this.name = e;
      this.parent = k;
    };
  }();
  a.BoneData = d;
  var g;
  (function(a) {
    a[a.Normal = 0] = "Normal";
    a[a.OnlyTranslation = 1] = "OnlyTranslation";
    a[a.NoRotationOrReflection = 2] = "NoRotationOrReflection";
    a[a.NoScale = 3] = "NoScale";
    a[a.NoScaleOrReflection = 4] = "NoScaleOrReflection";
  })(g = a.TransformMode || (a.TransformMode = {}));
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    return function(a, d, e) {
      this.name = a;
      this.order = d;
      this.skinRequired = e;
    };
  }();
  a.ConstraintData = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    return function(a, d) {
      if (null == d) {
        throw Error("data cannot be null.");
      }
      this.time = a;
      this.data = d;
    };
  }();
  a.Event = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    return function(a) {
      this.name = a;
    };
  }();
  a.EventData = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d(a, e) {
      this.bendDirection = 0;
      this.stretch = this.compress = !1;
      this.mix = 1;
      this.softness = 0;
      this.active = !1;
      if (null == a) {
        throw Error("data cannot be null.");
      }
      if (null == e) {
        throw Error("skeleton cannot be null.");
      }
      this.data = a;
      this.mix = a.mix;
      this.softness = a.softness;
      this.bendDirection = a.bendDirection;
      this.compress = a.compress;
      this.stretch = a.stretch;
      this.bones = [];
      for (var d = 0; d < a.bones.length; d++) {
        this.bones.push(e.findBone(a.bones[d].name));
      }
      this.target = e.findBone(a.target.name);
    }
    d.prototype.isActive = function() {
      return this.active;
    };
    d.prototype.apply = function() {
      this.update();
    };
    d.prototype.update = function() {
      var a = this.target, e = this.bones;
      switch(e.length) {
        case 1:
          this.apply1(e[0], a.worldX, a.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
          break;
        case 2:
          this.apply2(e[0], e[1], a.worldX, a.worldY, this.bendDirection, this.stretch, this.softness, this.mix);
      }
    };
    d.prototype.apply1 = function(d, e, k, c, g, t, f) {
      d.appliedValid || d.updateAppliedTransform();
      var h = d.parent, b = h.a, m = h.b, p = h.c, y = h.d, x = -d.ashearX - d.arotation;
      switch(d.data.transformMode) {
        case a.TransformMode.OnlyTranslation:
          m = e - d.worldX;
          var z = k - d.worldY;
          break;
        case a.TransformMode.NoRotationOrReflection:
          x += Math.atan2(p, b) * a.MathUtils.radDeg, z = Math.abs(b * y - m * p) / (b * b + p * p), m = -p * z, y = b * z;
        default:
          z = e - h.worldX;
          h = k - h.worldY;
          var r = b * y - m * p;
          m = (z * y - h * m) / r - d.ax;
          z = (h * b - z * p) / r - d.ay;
      }
      x += Math.atan2(z, m) * a.MathUtils.radDeg;
      0 > d.ascaleX && (x += 180);
      180 < x ? x -= 360 : -180 > x && (x += 360);
      b = d.ascaleX;
      p = d.ascaleY;
      if (c || g) {
        switch(d.data.transformMode) {
          case a.TransformMode.NoScale:
          case a.TransformMode.NoScaleOrReflection:
            m = e - d.worldX, z = k - d.worldY;
        }
        e = d.data.length * b;
        k = Math.sqrt(m * m + z * z);
        if (c && k < e || g && k > e && 1E-4 < e) {
          c = (k / e - 1) * f + 1, b *= c, t && (p *= c);
        }
      }
      d.updateWorldTransformWith(d.ax, d.ay, d.arotation + x * f, b, p, d.ashearX, d.ashearY);
    };
    d.prototype.apply2 = function(d, e, k, c, g, t, f, n) {
      if (0 == n) {
        e.updateWorldTransform();
      } else {
        d.appliedValid || d.updateAppliedTransform();
        e.appliedValid || e.updateAppliedTransform();
        var b = d.ax, h = d.ay, p = d.ascaleX, y = p, x = d.ascaleY, z = e.ascaleX;
        if (0 > p) {
          p = -p;
          var r = 180;
          var u = -1;
        } else {
          r = 0, u = 1;
        }
        0 > x && (x = -x, u = -u);
        if (0 > z) {
          z = -z;
          var v = 180;
        } else {
          v = 0;
        }
        var C = e.ax, A = d.a, D = d.b, F = d.c, B = d.d, E = 1E-4 >= Math.abs(p - x);
        if (E) {
          var H = e.ay;
          var L = A * C + D * H + d.worldX;
          var K = F * C + B * H + d.worldY;
        } else {
          H = 0, L = A * C + d.worldX, K = F * C + d.worldY;
        }
        var P = d.parent;
        A = P.a;
        D = P.b;
        F = P.c;
        B = P.d;
        var J = 1 / (A * B - D * F), I = L - P.worldX;
        L = K - P.worldY;
        K = (I * B - L * D) * J - b;
        L = (L * A - I * F) * J - h;
        K = Math.sqrt(K * K + L * L);
        var N = e.data.length * z;
        if (1E-4 > K) {
          this.apply1(d, k, c, !1, t, !1, n), e.updateWorldTransformWith(C, H, 0, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY);
        } else {
          I = k - P.worldX;
          L = c - P.worldY;
          B = (I * B - L * D) * J - b;
          F = (L * A - I * F) * J - h;
          J = B * B + F * F;
          0 != f && (f *= p * (z + 1) / 2, A = Math.sqrt(J), D = A - K - N * p + f, 0 < D && (J = Math.min(1, D / (2 * f)) - 1, J = (D - f * (1 - J * J)) / A, B -= J * B, F -= J * F, J = B * B + F * F));
          a: {
            if (E) {
              N *= p, A = (J - K * K - N * N) / (2 * K * N), -1 > A ? A = -1 : 1 < A && (A = 1, t && (y *= (Math.sqrt(J) / (K + N) - 1) * n + 1)), g *= Math.acos(A), A = K + N * A, D = N * Math.sin(g), A = Math.atan2(F * A - B * D, B * A + F * D);
            } else {
              A = p * N;
              D = x * N;
              L = A * A;
              I = D * D;
              t = Math.atan2(F, B);
              F = I * K * K + L * J - L * I;
              f = -2 * I * K;
              E = I - L;
              B = f * f - 4 * E * F;
              if (0 <= B && (B = Math.sqrt(B), 0 > f && (B = -B), B = -(f + B) / 2, f = B / E, F /= B, F = Math.abs(f) < Math.abs(F) ? f : F, F * F <= J)) {
                L = Math.sqrt(J - F * F) * g;
                A = t - Math.atan2(L, F);
                g = Math.atan2(L / x, (F - K) / p);
                break a;
              }
              p = a.MathUtils.PI;
              f = K - A;
              E = f * f;
              x = N = 0;
              z = K + A;
              k = z * z;
              c = 0;
              F = -A * K / (L - I);
              -1 <= F && 1 >= F && (F = Math.acos(F), I = A * Math.cos(F) + K, L = D * Math.sin(F), B = I * I + L * L, B < E && (p = F, E = B, f = I, N = L), B > k && (x = F, k = B, z = I, c = L));
              J <= (E + k) / 2 ? (A = t - Math.atan2(N * g, f), g *= p) : (A = t - Math.atan2(c * g, z), g *= x);
            }
          }
          K = Math.atan2(H, C) * u;
          D = d.arotation;
          A = (A - K) * a.MathUtils.radDeg + r - D;
          180 < A ? A -= 360 : -180 > A && (A += 360);
          d.updateWorldTransformWith(b, h, D + A * n, y, d.ascaleY, 0, 0);
          D = e.arotation;
          g = ((g + K) * a.MathUtils.radDeg - e.ashearX) * u + v - D;
          180 < g ? g -= 360 : -180 > g && (g += 360);
          e.updateWorldTransformWith(C, H, D + g * n, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY);
        }
      }
    };
    return d;
  }();
  a.IkConstraint = d;
})(spine || (spine = {}));
(function(a) {
  var d = function(a) {
    function d(e) {
      e = a.call(this, e, 0, !1) || this;
      e.bones = [];
      e.bendDirection = 1;
      e.compress = !1;
      e.stretch = !1;
      e.uniform = !1;
      e.mix = 1;
      e.softness = 0;
      return e;
    }
    __extends(d, a);
    return d;
  }(a.ConstraintData);
  a.IkConstraintData = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d(a, e) {
      this.translateMix = this.rotateMix = this.spacing = this.position = 0;
      this.spaces = [];
      this.positions = [];
      this.world = [];
      this.curves = [];
      this.lengths = [];
      this.segments = [];
      this.active = !1;
      if (null == a) {
        throw Error("data cannot be null.");
      }
      if (null == e) {
        throw Error("skeleton cannot be null.");
      }
      this.data = a;
      this.bones = [];
      for (var d = 0, c = a.bones.length; d < c; d++) {
        this.bones.push(e.findBone(a.bones[d].name));
      }
      this.target = e.findSlot(a.target.name);
      this.position = a.position;
      this.spacing = a.spacing;
      this.rotateMix = a.rotateMix;
      this.translateMix = a.translateMix;
    }
    d.prototype.isActive = function() {
      return this.active;
    };
    d.prototype.apply = function() {
      this.update();
    };
    d.prototype.update = function() {
      var h = this.target.getAttachment();
      if (h instanceof a.PathAttachment) {
        var e = this.rotateMix, k = this.translateMix, c = 0 < e;
        if (0 < k || c) {
          var g = this.data, t = g.spacingMode == a.SpacingMode.Percent, f = g.rotateMode, n = f == a.RotateMode.Tangent, b = f == a.RotateMode.ChainScale, m = this.bones.length, q = n ? m : m + 1, y = this.bones, x = a.Utils.setArraySize(this.spaces, q), z = null, r = this.spacing;
          if (b || !t) {
            b && (z = a.Utils.setArraySize(this.lengths, m));
            for (var u = g.spacingMode == a.SpacingMode.Length, v = 0, C = q - 1; v < C;) {
              var A = y[v], D = A.data.length;
              if (D < d.epsilon) {
                b && (z[v] = 0), x[++v] = 0;
              } else {
                if (t) {
                  if (b) {
                    var F = D * A.a, B = D * A.c;
                    z[v] = Math.sqrt(F * F + B * B);
                  }
                  x[++v] = r;
                } else {
                  F = D * A.a, B = D * A.c, A = Math.sqrt(F * F + B * B), b && (z[v] = A), x[++v] = (u ? D + r : r) * A / D;
                }
              }
            }
          } else {
            for (v = 1; v < q; v++) {
              x[v] = r;
            }
          }
          h = this.computeWorldPositions(h, q, n, g.positionMode == a.PositionMode.Percent, t);
          t = h[0];
          q = h[1];
          g = g.offsetRotation;
          0 == g ? f = f == a.RotateMode.Chain : (f = !1, r = this.target.bone, g *= 0 < r.a * r.d - r.b * r.c ? a.MathUtils.degRad : -a.MathUtils.degRad);
          v = 0;
          for (r = 3; v < m; v++, r += 3) {
            A = y[v];
            A.worldX += (t - A.worldX) * k;
            A.worldY += (q - A.worldY) * k;
            F = h[r];
            B = h[r + 1];
            u = F - t;
            C = B - q;
            b && (t = z[v], 0 != t && (t = (Math.sqrt(u * u + C * C) / t - 1) * e + 1, A.a *= t, A.c *= t));
            t = F;
            q = B;
            if (c) {
              F = A.a;
              B = A.b;
              D = A.c;
              var E = A.d;
              var H = n ? h[r - 1] : 0 == x[v + 1] ? h[r + 2] : Math.atan2(C, u);
              H -= Math.atan2(D, F);
              if (f) {
                var L = Math.cos(H);
                var K = Math.sin(H);
                var P = A.data.length;
                t += (P * (L * F - K * D) - u) * e;
                q += (P * (K * F + L * D) - C) * e;
              } else {
                H += g;
              }
              H > a.MathUtils.PI ? H -= a.MathUtils.PI2 : H < -a.MathUtils.PI && (H += a.MathUtils.PI2);
              H *= e;
              L = Math.cos(H);
              K = Math.sin(H);
              A.a = L * F - K * D;
              A.b = L * B - K * E;
              A.c = K * F + L * D;
              A.d = K * B + L * E;
            }
            A.appliedValid = !1;
          }
        }
      }
    };
    d.prototype.computeWorldPositions = function(h, e, k, c, g) {
      var p = this.target, f = this.position, n = this.spaces, b = a.Utils.setArraySize(this.positions, 3 * e + 2), m = h.closed, q = h.worldVerticesLength, y = q / 6, x = d.NONE;
      if (!h.constantSpeed) {
        var z = h.lengths;
        y -= m ? 1 : 2;
        var r = z[y];
        c && (f *= r);
        if (g) {
          for (var u = 1; u < e; u++) {
            n[u] *= r;
          }
        }
        var v = a.Utils.setArraySize(this.world, 8);
        for (g = c = u = 0; u < e; u++, c += 3) {
          var C = n[u], A = f += C;
          if (m) {
            A %= r, 0 > A && (A += r), g = 0;
          } else {
            if (0 > A) {
              x != d.BEFORE && (x = d.BEFORE, h.computeWorldVertices(p, 2, 4, v, 0, 2));
              this.addBeforePosition(A, v, 0, b, c);
              continue;
            } else {
              if (A > r) {
                x != d.AFTER && (x = d.AFTER, h.computeWorldVertices(p, q - 6, 4, v, 0, 2));
                this.addAfterPosition(A - r, v, 0, b, c);
                continue;
              }
            }
          }
          for (;; g++) {
            var D = z[g];
            if (!(A > D)) {
              if (0 == g) {
                A /= D;
              } else {
                var F = z[g - 1];
                A = (A - F) / (D - F);
              }
              break;
            }
          }
          g != x && (x = g, m && g == y ? (h.computeWorldVertices(p, q - 4, 4, v, 0, 2), h.computeWorldVertices(p, 0, 4, v, 4, 2)) : h.computeWorldVertices(p, 6 * g + 2, 8, v, 0, 2));
          this.addCurvePosition(A, v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], b, c, k || 0 < u && 0 == C);
        }
        return b;
      }
      m ? (q += 2, v = a.Utils.setArraySize(this.world, q), h.computeWorldVertices(p, 2, q - 4, v, 0, 2), h.computeWorldVertices(p, 0, 2, v, q - 4, 2), v[q - 2] = v[0], v[q - 1] = v[1]) : (y--, q -= 4, v = a.Utils.setArraySize(this.world, q), h.computeWorldVertices(p, 2, q, v, 0, 2));
      p = a.Utils.setArraySize(this.curves, y);
      z = 0;
      r = v[0];
      D = v[1];
      var B = 0, E = 0, H = 0, L = 0, K = 0, P = 0;
      u = 0;
      for (C = 2; u < y; u++, C += 6) {
        B = v[C];
        E = v[C + 1];
        H = v[C + 2];
        L = v[C + 3];
        K = v[C + 4];
        P = v[C + 5];
        var J = .1875 * (r - 2 * B + H);
        var I = .1875 * (D - 2 * E + L);
        F = .09375 * (3 * (B - H) - r + K);
        var N = .09375 * (3 * (E - L) - D + P);
        var S = 2 * J + F;
        var Q = 2 * I + N;
        J = .75 * (B - r) + J + .16666667 * F;
        I = .75 * (E - D) + I + .16666667 * N;
        z += Math.sqrt(J * J + I * I);
        J += S;
        I += Q;
        S += F;
        Q += N;
        z += Math.sqrt(J * J + I * I);
        J += S;
        I += Q;
        z += Math.sqrt(J * J + I * I);
        J += S + F;
        I += Q + N;
        z += Math.sqrt(J * J + I * I);
        p[u] = z;
        r = K;
        D = P;
      }
      f = c ? f * z : z / h.lengths[y - 1] * f;
      if (g) {
        for (u = 1; u < e; u++) {
          n[u] *= z;
        }
      }
      h = this.segments;
      for (N = g = c = u = y = 0; u < e; u++, c += 3) {
        C = n[u];
        A = f += C;
        if (m) {
          A %= z, 0 > A && (A += z), g = 0;
        } else {
          if (0 > A) {
            this.addBeforePosition(A, v, 0, b, c);
            continue;
          } else {
            if (A > z) {
              this.addAfterPosition(A - z, v, q - 4, b, c);
              continue;
            }
          }
        }
        for (;; g++) {
          if (S = p[g], !(A > S)) {
            0 == g ? A /= S : (F = p[g - 1], A = (A - F) / (S - F));
            break;
          }
        }
        if (g != x) {
          x = g;
          var Z = 6 * g;
          r = v[Z];
          D = v[Z + 1];
          B = v[Z + 2];
          E = v[Z + 3];
          H = v[Z + 4];
          L = v[Z + 5];
          K = v[Z + 6];
          P = v[Z + 7];
          J = .03 * (r - 2 * B + H);
          I = .03 * (D - 2 * E + L);
          F = .006 * (3 * (B - H) - r + K);
          N = .006 * (3 * (E - L) - D + P);
          S = 2 * J + F;
          Q = 2 * I + N;
          J = .3 * (B - r) + J + .16666667 * F;
          I = .3 * (E - D) + I + .16666667 * N;
          y = Math.sqrt(J * J + I * I);
          h[0] = y;
          for (Z = 1; 8 > Z; Z++) {
            J += S, I += Q, S += F, Q += N, y += Math.sqrt(J * J + I * I), h[Z] = y;
          }
          J += S;
          I += Q;
          y += Math.sqrt(J * J + I * I);
          h[8] = y;
          J += S + F;
          I += Q + N;
          y += Math.sqrt(J * J + I * I);
          h[9] = y;
          N = 0;
        }
        for (A *= y;; N++) {
          if (S = h[N], !(A > S)) {
            0 == N ? A /= S : (F = h[N - 1], A = N + (A - F) / (S - F));
            break;
          }
        }
        this.addCurvePosition(.1 * A, r, D, B, E, H, L, K, P, b, c, k || 0 < u && 0 == C);
      }
      return b;
    };
    d.prototype.addBeforePosition = function(a, e, d, c, g) {
      var k = e[d], f = e[d + 1];
      e = Math.atan2(e[d + 3] - f, e[d + 2] - k);
      c[g] = k + a * Math.cos(e);
      c[g + 1] = f + a * Math.sin(e);
      c[g + 2] = e;
    };
    d.prototype.addAfterPosition = function(a, e, d, c, g) {
      var k = e[d + 2], f = e[d + 3];
      e = Math.atan2(f - e[d + 1], k - e[d]);
      c[g] = k + a * Math.cos(e);
      c[g + 1] = f + a * Math.sin(e);
      c[g + 2] = e;
    };
    d.prototype.addCurvePosition = function(a, e, d, c, g, t, f, n, b, m, q, y) {
      if (0 == a || isNaN(a)) {
        m[q] = e, m[q + 1] = d, m[q + 2] = Math.atan2(g - d, c - e);
      } else {
        var k = a * a, h = k * a, p = 1 - a, u = p * p, v = u * p, C = p * a, A = 3 * C;
        p *= A;
        A *= a;
        n = e * v + c * p + t * A + n * h;
        b = d * v + g * p + f * A + b * h;
        m[q] = n;
        m[q + 1] = b;
        y && (m[q + 2] = .001 > a ? Math.atan2(g - d, c - e) : Math.atan2(b - (d * u + g * C * 2 + f * k), n - (e * u + c * C * 2 + t * k)));
      }
    };
    d.NONE = -1;
    d.BEFORE = -2;
    d.AFTER = -3;
    d.epsilon = 1E-5;
    return d;
  }();
  a.PathConstraint = d;
})(spine || (spine = {}));
(function(a) {
  var d = function(a) {
    function d(e) {
      e = a.call(this, e, 0, !1) || this;
      e.bones = [];
      return e;
    }
    __extends(d, a);
    return d;
  }(a.ConstraintData);
  a.PathConstraintData = d;
  (function(a) {
    a[a.Fixed = 0] = "Fixed";
    a[a.Percent = 1] = "Percent";
  })(a.PositionMode || (a.PositionMode = {}));
  (function(a) {
    a[a.Length = 0] = "Length";
    a[a.Fixed = 1] = "Fixed";
    a[a.Percent = 2] = "Percent";
  })(a.SpacingMode || (a.SpacingMode = {}));
  (function(a) {
    a[a.Tangent = 0] = "Tangent";
    a[a.Chain = 1] = "Chain";
    a[a.ChainScale = 2] = "ChainScale";
  })(a.RotateMode || (a.RotateMode = {}));
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function a(a) {
      this.toLoad = [];
      this.assets = {};
      this.clientId = a;
    }
    a.prototype.loaded = function() {
      var a = 0, d;
      for (d in this.assets) {
        a++;
      }
      return a;
    };
    return a;
  }(), g = function() {
    function a(a) {
      void 0 === a && (a = "");
      this.clientAssets = {};
      this.queuedAssets = {};
      this.rawAssets = {};
      this.errors = {};
      this.pathPrefix = a;
    }
    a.prototype.queueAsset = function(a, k, c) {
      var e = this.clientAssets[a];
      if (null === e || void 0 === e) {
        e = new d(a), this.clientAssets[a] = e;
      }
      null !== k && (e.textureLoader = k);
      e.toLoad.push(c);
      if (this.queuedAssets[c] === c) {
        return !1;
      }
      this.queuedAssets[c] = c;
      return !0;
    };
    a.prototype.loadText = function(a, d) {
      var c = this;
      d = this.pathPrefix + d;
      if (this.queueAsset(a, null, d)) {
        var e = new XMLHttpRequest;
        e.overrideMimeType("text/html");
        e.onreadystatechange = function() {
          e.readyState == XMLHttpRequest.DONE && (200 <= e.status && 300 > e.status ? c.rawAssets[d] = e.responseText : c.errors[d] = "Couldn't load text " + d + ": status " + e.status + ", " + e.responseText);
        };
        e.open("GET", d, !0);
        e.send();
      }
    };
    a.prototype.loadJson = function(a, d) {
      var c = this;
      d = this.pathPrefix + d;
      if (this.queueAsset(a, null, d)) {
        var e = new XMLHttpRequest;
        e.overrideMimeType("text/html");
        e.onreadystatechange = function() {
          e.readyState == XMLHttpRequest.DONE && (200 <= e.status && 300 > e.status ? c.rawAssets[d] = JSON.parse(e.responseText) : c.errors[d] = "Couldn't load text " + d + ": status " + e.status + ", " + e.responseText);
        };
        e.open("GET", d, !0);
        e.send();
      }
    };
    a.prototype.loadTexture = function(a, d, c) {
      var e = this;
      c = this.pathPrefix + c;
      if (this.queueAsset(a, d, c)) {
        var k = new Image;
        k.crossOrigin = "anonymous";
        k.onload = function(a) {
          e.rawAssets[c] = k;
        };
        k.onerror = function(a) {
          e.errors[c] = "Couldn't load image " + c;
        };
        k.src = c;
      }
    };
    a.prototype.get = function(a, d) {
      d = this.pathPrefix + d;
      a = this.clientAssets[a];
      return null === a || void 0 === a ? !0 : a.assets[d];
    };
    a.prototype.updateClientAssets = function(a) {
      for (var e = 0; e < a.toLoad.length; e++) {
        var c = a.toLoad[e], d = a.assets[c];
        if (null === d || void 0 === d) {
          d = this.rawAssets[c], null !== d && void 0 !== d && (a.assets[c] = d instanceof HTMLImageElement ? a.textureLoader(d) : d);
        }
      }
    };
    a.prototype.isLoadingComplete = function(a) {
      a = this.clientAssets[a];
      if (null === a || void 0 === a) {
        return !0;
      }
      this.updateClientAssets(a);
      return a.toLoad.length == a.loaded();
    };
    a.prototype.dispose = function() {
    };
    a.prototype.hasErrors = function() {
      return 0 < Object.keys(this.errors).length;
    };
    a.prototype.getErrors = function() {
      return this.errors;
    };
    return a;
  }();
  a.SharedAssetManager = g;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d(d) {
      this._updateCache = [];
      this.updateCacheReset = [];
      this.time = 0;
      this.scaleY = this.scaleX = 1;
      this.y = this.x = 0;
      if (null == d) {
        throw Error("data cannot be null.");
      }
      this.data = d;
      this.bones = [];
      for (var e = 0; e < d.bones.length; e++) {
        var k = d.bones[e];
        if (null == k.parent) {
          k = new a.Bone(k, this, null);
        } else {
          var c = this.bones[k.parent.index];
          k = new a.Bone(k, this, c);
          c.children.push(k);
        }
        this.bones.push(k);
      }
      this.slots = [];
      this.drawOrder = [];
      for (e = 0; e < d.slots.length; e++) {
        c = d.slots[e], k = this.bones[c.boneData.index], k = new a.Slot(c, k), this.slots.push(k), this.drawOrder.push(k);
      }
      this.ikConstraints = [];
      for (e = 0; e < d.ikConstraints.length; e++) {
        this.ikConstraints.push(new a.IkConstraint(d.ikConstraints[e], this));
      }
      this.transformConstraints = [];
      for (e = 0; e < d.transformConstraints.length; e++) {
        this.transformConstraints.push(new a.TransformConstraint(d.transformConstraints[e], this));
      }
      this.pathConstraints = [];
      for (e = 0; e < d.pathConstraints.length; e++) {
        this.pathConstraints.push(new a.PathConstraint(d.pathConstraints[e], this));
      }
      this.color = new a.Color(1, 1, 1, 1);
      this.updateCache();
    }
    d.prototype.updateCache = function() {
      this._updateCache.length = 0;
      this.updateCacheReset.length = 0;
      for (var a = this.bones, e = 0, d = a.length; e < d; e++) {
        var c = a[e];
        c.sorted = c.data.skinRequired;
        c.active = !c.sorted;
      }
      if (null != this.skin) {
        var g = this.skin.bones;
        e = 0;
        for (d = this.skin.bones.length; e < d; e++) {
          c = this.bones[g[e].index];
          do {
            c.sorted = !1, c.active = !0, c = c.parent;
          } while (null != c);
        }
      }
      d = this.ikConstraints;
      c = this.transformConstraints;
      g = this.pathConstraints;
      var t = d.length, f = c.length, n = g.length, b = t + f + n;
      e = 0;
      a: for (; e < b; e++) {
        for (var m = 0; m < t; m++) {
          var q = d[m];
          if (q.data.order == e) {
            this.sortIkConstraint(q);
            continue a;
          }
        }
        for (m = 0; m < f; m++) {
          if (q = c[m], q.data.order == e) {
            this.sortTransformConstraint(q);
            continue a;
          }
        }
        for (m = 0; m < n; m++) {
          if (q = g[m], q.data.order == e) {
            this.sortPathConstraint(q);
            continue a;
          }
        }
      }
      e = 0;
      for (d = a.length; e < d; e++) {
        this.sortBone(a[e]);
      }
    };
    d.prototype.sortIkConstraint = function(d) {
      d.active = d.target.isActive() && (!d.data.skinRequired || null != this.skin && a.Utils.contains(this.skin.constraints, d.data, !0));
      if (d.active) {
        this.sortBone(d.target);
        var e = d.bones, k = e[0];
        this.sortBone(k);
        if (1 < e.length) {
          var c = e[e.length - 1];
          -1 < this._updateCache.indexOf(c) || this.updateCacheReset.push(c);
        }
        this._updateCache.push(d);
        this.sortReset(k.children);
        e[e.length - 1].sorted = !0;
      }
    };
    d.prototype.sortPathConstraint = function(d) {
      d.active = d.target.bone.isActive() && (!d.data.skinRequired || null != this.skin && a.Utils.contains(this.skin.constraints, d.data, !0));
      if (d.active) {
        var e = d.target, k = e.data.index, c = e.bone;
        null != this.skin && this.sortPathConstraintAttachment(this.skin, k, c);
        null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, k, c);
        for (var h = 0, g = this.data.skins.length; h < g; h++) {
          this.sortPathConstraintAttachment(this.data.skins[h], k, c);
        }
        h = e.getAttachment();
        h instanceof a.PathAttachment && this.sortPathConstraintAttachmentWith(h, c);
        c = d.bones;
        e = c.length;
        for (h = 0; h < e; h++) {
          this.sortBone(c[h]);
        }
        this._updateCache.push(d);
        for (h = 0; h < e; h++) {
          this.sortReset(c[h].children);
        }
        for (h = 0; h < e; h++) {
          c[h].sorted = !0;
        }
      }
    };
    d.prototype.sortTransformConstraint = function(d) {
      d.active = d.target.isActive() && (!d.data.skinRequired || null != this.skin && a.Utils.contains(this.skin.constraints, d.data, !0));
      if (d.active) {
        this.sortBone(d.target);
        var e = d.bones, k = e.length;
        if (d.data.local) {
          for (var c = 0; c < k; c++) {
            var h = e[c];
            this.sortBone(h.parent);
            -1 < this._updateCache.indexOf(h) || this.updateCacheReset.push(h);
          }
        } else {
          for (c = 0; c < k; c++) {
            this.sortBone(e[c]);
          }
        }
        this._updateCache.push(d);
        for (d = 0; d < k; d++) {
          this.sortReset(e[d].children);
        }
        for (d = 0; d < k; d++) {
          e[d].sorted = !0;
        }
      }
    };
    d.prototype.sortPathConstraintAttachment = function(a, e, d) {
      if (a = a.attachments[e]) {
        for (var c in a) {
          this.sortPathConstraintAttachmentWith(a[c], d);
        }
      }
    };
    d.prototype.sortPathConstraintAttachmentWith = function(d, e) {
      if (d instanceof a.PathAttachment) {
        if (d = d.bones, null == d) {
          this.sortBone(e);
        } else {
          e = this.bones;
          for (var k = 0; k < d.length;) {
            var c = d[k++];
            for (c = k + c; k < c; k++) {
              this.sortBone(e[d[k]]);
            }
          }
        }
      }
    };
    d.prototype.sortBone = function(a) {
      if (!a.sorted) {
        var e = a.parent;
        null != e && this.sortBone(e);
        a.sorted = !0;
        this._updateCache.push(a);
      }
    };
    d.prototype.sortReset = function(a) {
      for (var e = 0, d = a.length; e < d; e++) {
        var c = a[e];
        c.active && (c.sorted && this.sortReset(c.children), c.sorted = !1);
      }
    };
    d.prototype.updateWorldTransform = function() {
      for (var a = this.updateCacheReset, e = 0, d = a.length; e < d; e++) {
        var c = a[e];
        c.ax = c.x;
        c.ay = c.y;
        c.arotation = c.rotation;
        c.ascaleX = c.scaleX;
        c.ascaleY = c.scaleY;
        c.ashearX = c.shearX;
        c.ashearY = c.shearY;
        c.appliedValid = !0;
      }
      a = this._updateCache;
      e = 0;
      for (d = a.length; e < d; e++) {
        a[e].update();
      }
    };
    d.prototype.setToSetupPose = function() {
      this.setBonesToSetupPose();
      this.setSlotsToSetupPose();
    };
    d.prototype.setBonesToSetupPose = function() {
      for (var a = this.bones, e = 0, d = a.length; e < d; e++) {
        a[e].setToSetupPose();
      }
      var c = this.ikConstraints;
      e = 0;
      for (d = c.length; e < d; e++) {
        a = c[e], a.mix = a.data.mix, a.softness = a.data.softness, a.bendDirection = a.data.bendDirection, a.compress = a.data.compress, a.stretch = a.data.stretch;
      }
      var g = this.transformConstraints;
      e = 0;
      for (d = g.length; e < d; e++) {
        a = g[e], c = a.data, a.rotateMix = c.rotateMix, a.translateMix = c.translateMix, a.scaleMix = c.scaleMix, a.shearMix = c.shearMix;
      }
      g = this.pathConstraints;
      e = 0;
      for (d = g.length; e < d; e++) {
        a = g[e], c = a.data, a.position = c.position, a.spacing = c.spacing, a.rotateMix = c.rotateMix, a.translateMix = c.translateMix;
      }
    };
    d.prototype.setSlotsToSetupPose = function() {
      var d = this.slots;
      a.Utils.arrayCopy(d, 0, this.drawOrder, 0, d.length);
      for (var e = 0, k = d.length; e < k; e++) {
        d[e].setToSetupPose();
      }
    };
    d.prototype.getRootBone = function() {
      return 0 == this.bones.length ? null : this.bones[0];
    };
    d.prototype.findBone = function(a) {
      if (null == a) {
        throw Error("boneName cannot be null.");
      }
      for (var e = this.bones, d = 0, c = e.length; d < c; d++) {
        var h = e[d];
        if (h.data.name == a) {
          return h;
        }
      }
      return null;
    };
    d.prototype.findBoneIndex = function(a) {
      if (null == a) {
        throw Error("boneName cannot be null.");
      }
      for (var e = this.bones, d = 0, c = e.length; d < c; d++) {
        if (e[d].data.name == a) {
          return d;
        }
      }
      return -1;
    };
    d.prototype.findSlot = function(a) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var e = this.slots, d = 0, c = e.length; d < c; d++) {
        var h = e[d];
        if (h.data.name == a) {
          return h;
        }
      }
      return null;
    };
    d.prototype.findSlotIndex = function(a) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var e = this.slots, d = 0, c = e.length; d < c; d++) {
        if (e[d].data.name == a) {
          return d;
        }
      }
      return -1;
    };
    d.prototype.setSkinByName = function(a) {
      var e = this.data.findSkin(a);
      if (null == e) {
        throw Error("Skin not found: " + a);
      }
      this.setSkin(e);
    };
    d.prototype.setSkin = function(a) {
      if (a != this.skin) {
        if (null != a) {
          if (null != this.skin) {
            a.attachAll(this, this.skin);
          } else {
            for (var e = this.slots, d = 0, c = e.length; d < c; d++) {
              var h = e[d], g = h.data.attachmentName;
              null != g && (g = a.getAttachment(d, g), null != g && h.setAttachment(g));
            }
          }
        }
        this.skin = a;
        this.updateCache();
      }
    };
    d.prototype.getAttachmentByName = function(a, e) {
      return this.getAttachment(this.data.findSlotIndex(a), e);
    };
    d.prototype.getAttachment = function(a, e) {
      if (null == e) {
        throw Error("attachmentName cannot be null.");
      }
      if (null != this.skin) {
        var d = this.skin.getAttachment(a, e);
        if (null != d) {
          return d;
        }
      }
      return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(a, e) : null;
    };
    d.prototype.setAttachment = function(a, e) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var d = this.slots, c = 0, h = d.length; c < h; c++) {
        var g = d[c];
        if (g.data.name == a) {
          d = null;
          if (null != e && (d = this.getAttachment(c, e), null == d)) {
            throw Error("Attachment not found: " + e + ", for slot: " + a);
          }
          g.setAttachment(d);
          return;
        }
      }
      throw Error("Slot not found: " + a);
    };
    d.prototype.findIkConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var e = this.ikConstraints, d = 0, c = e.length; d < c; d++) {
        var h = e[d];
        if (h.data.name == a) {
          return h;
        }
      }
      return null;
    };
    d.prototype.findTransformConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var e = this.transformConstraints, d = 0, c = e.length; d < c; d++) {
        var h = e[d];
        if (h.data.name == a) {
          return h;
        }
      }
      return null;
    };
    d.prototype.findPathConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var e = this.pathConstraints, d = 0, c = e.length; d < c; d++) {
        var h = e[d];
        if (h.data.name == a) {
          return h;
        }
      }
      return null;
    };
    d.prototype.getBounds = function(d, e, k) {
      void 0 === k && (k = Array(2));
      if (null == d) {
        throw Error("offset cannot be null.");
      }
      if (null == e) {
        throw Error("size cannot be null.");
      }
      for (var c = this.drawOrder, h = Number.POSITIVE_INFINITY, g = Number.POSITIVE_INFINITY, f = Number.NEGATIVE_INFINITY, n = Number.NEGATIVE_INFINITY, b = 0, m = c.length; b < m; b++) {
        var q = c[b];
        if (q.bone.active) {
          var y = null, x = q.getAttachment();
          if (x instanceof a.RegionAttachment) {
            var z = 8;
            y = a.Utils.setArraySize(k, z, 0);
            x.computeWorldVertices(q.bone, y, 0, 2);
          } else {
            x instanceof a.MeshAttachment && (z = x.worldVerticesLength, y = a.Utils.setArraySize(k, z, 0), x.computeWorldVertices(q, 0, z, y, 0, 2));
          }
          if (null != y) {
            for (q = 0, z = y.length; q < z; q += 2) {
              x = y[q];
              var r = y[q + 1];
              h = Math.min(h, x);
              g = Math.min(g, r);
              f = Math.max(f, x);
              n = Math.max(n, r);
            }
          }
        }
      }
      d.set(h, g);
      e.set(f - h, n - g);
    };
    d.prototype.update = function(a) {
      this.time += a;
    };
    return d;
  }();
  a.Skeleton = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d(a) {
      this.scale = 1;
      this.linkedMeshes = [];
      this.attachmentLoader = a;
    }
    d.prototype.readSkeletonData = function(c) {
      var e = this.scale, k = new a.SkeletonData;
      k.name = "";
      c = new g(c);
      k.hash = c.readString();
      k.version = c.readString();
      if ("3.8.75" == k.version) {
        throw Error("Unsupported skeleton data, please export with a newer version of Spine.");
      }
      k.x = c.readFloat();
      k.y = c.readFloat();
      k.width = c.readFloat();
      k.height = c.readFloat();
      var f = c.readBoolean();
      f && (k.fps = c.readFloat(), k.imagesPath = c.readString(), k.audioPath = c.readString());
      var h = c.readInt(!0);
      for (var b = 0; b < h; b++) {
        c.strings.push(c.readString());
      }
      h = c.readInt(!0);
      for (b = 0; b < h; b++) {
        var m = c.readString(), q = 0 == b ? null : k.bones[c.readInt(!0)];
        m = new a.BoneData(b, m, q);
        m.rotation = c.readFloat();
        m.x = c.readFloat() * e;
        m.y = c.readFloat() * e;
        m.scaleX = c.readFloat();
        m.scaleY = c.readFloat();
        m.shearX = c.readFloat();
        m.shearY = c.readFloat();
        m.length = c.readFloat() * e;
        m.transformMode = d.TransformModeValues[c.readInt(!0)];
        m.skinRequired = c.readBoolean();
        f && a.Color.rgba8888ToColor(m.color, c.readInt32());
        k.bones.push(m);
      }
      h = c.readInt(!0);
      for (b = 0; b < h; b++) {
        m = c.readString(), q = k.bones[c.readInt(!0)], m = new a.SlotData(b, m, q), a.Color.rgba8888ToColor(m.color, c.readInt32()), q = c.readInt32(), -1 != q && a.Color.rgb888ToColor(m.darkColor = new a.Color, q), m.attachmentName = c.readStringRef(), m.blendMode = d.BlendModeValues[c.readInt(!0)], k.slots.push(m);
      }
      h = c.readInt(!0);
      for (b = 0; b < h; b++) {
        m = new a.IkConstraintData(c.readString());
        m.order = c.readInt(!0);
        m.skinRequired = c.readBoolean();
        q = c.readInt(!0);
        for (var y = 0; y < q; y++) {
          m.bones.push(k.bones[c.readInt(!0)]);
        }
        m.target = k.bones[c.readInt(!0)];
        m.mix = c.readFloat();
        m.softness = c.readFloat() * e;
        m.bendDirection = c.readByte();
        m.compress = c.readBoolean();
        m.stretch = c.readBoolean();
        m.uniform = c.readBoolean();
        k.ikConstraints.push(m);
      }
      h = c.readInt(!0);
      for (b = 0; b < h; b++) {
        m = new a.TransformConstraintData(c.readString());
        m.order = c.readInt(!0);
        m.skinRequired = c.readBoolean();
        q = c.readInt(!0);
        for (y = 0; y < q; y++) {
          m.bones.push(k.bones[c.readInt(!0)]);
        }
        m.target = k.bones[c.readInt(!0)];
        m.local = c.readBoolean();
        m.relative = c.readBoolean();
        m.offsetRotation = c.readFloat();
        m.offsetX = c.readFloat() * e;
        m.offsetY = c.readFloat() * e;
        m.offsetScaleX = c.readFloat();
        m.offsetScaleY = c.readFloat();
        m.offsetShearY = c.readFloat();
        m.rotateMix = c.readFloat();
        m.translateMix = c.readFloat();
        m.scaleMix = c.readFloat();
        m.shearMix = c.readFloat();
        k.transformConstraints.push(m);
      }
      h = c.readInt(!0);
      for (b = 0; b < h; b++) {
        m = new a.PathConstraintData(c.readString());
        m.order = c.readInt(!0);
        m.skinRequired = c.readBoolean();
        q = c.readInt(!0);
        for (y = 0; y < q; y++) {
          m.bones.push(k.bones[c.readInt(!0)]);
        }
        m.target = k.slots[c.readInt(!0)];
        m.positionMode = d.PositionModeValues[c.readInt(!0)];
        m.spacingMode = d.SpacingModeValues[c.readInt(!0)];
        m.rotateMode = d.RotateModeValues[c.readInt(!0)];
        m.offsetRotation = c.readFloat();
        m.position = c.readFloat();
        m.positionMode == a.PositionMode.Fixed && (m.position *= e);
        m.spacing = c.readFloat();
        if (m.spacingMode == a.SpacingMode.Length || m.spacingMode == a.SpacingMode.Fixed) {
          m.spacing *= e;
        }
        m.rotateMix = c.readFloat();
        m.translateMix = c.readFloat();
        k.pathConstraints.push(m);
      }
      h = this.readSkin(c, k, !0, f);
      null != h && (k.defaultSkin = h, k.skins.push(h));
      b = k.skins.length;
      for (a.Utils.setArraySize(k.skins, h = b + c.readInt(!0)); b < h; b++) {
        k.skins[b] = this.readSkin(c, k, !1, f);
      }
      h = this.linkedMeshes.length;
      for (b = 0; b < h; b++) {
        e = this.linkedMeshes[b];
        f = null == e.skin ? k.defaultSkin : k.findSkin(e.skin);
        if (null == f) {
          throw Error("Skin not found: " + e.skin);
        }
        f = f.getAttachment(e.slotIndex, e.parent);
        if (null == f) {
          throw Error("Parent mesh not found: " + e.parent);
        }
        e.mesh.deformAttachment = e.inheritDeform ? f : e.mesh;
        e.mesh.setParentMesh(f);
        e.mesh.updateUVs();
      }
      this.linkedMeshes.length = 0;
      h = c.readInt(!0);
      for (b = 0; b < h; b++) {
        m = new a.EventData(c.readStringRef()), m.intValue = c.readInt(!1), m.floatValue = c.readFloat(), m.stringValue = c.readString(), m.audioPath = c.readString(), null != m.audioPath && (m.volume = c.readFloat(), m.balance = c.readFloat()), k.events.push(m);
      }
      h = c.readInt(!0);
      for (b = 0; b < h; b++) {
        k.animations.push(this.readAnimation(c, c.readString(), k));
      }
      return k;
    };
    d.prototype.readSkin = function(c, e, d, f) {
      if (d) {
        var k = c.readInt(!0);
        if (0 == k) {
          return null;
        }
        d = new a.Skin("default");
      } else {
        d = new a.Skin(c.readStringRef());
        d.bones.length = c.readInt(!0);
        var b = 0;
        for (k = d.bones.length; b < k; b++) {
          d.bones[b] = e.bones[c.readInt(!0)];
        }
        b = 0;
        for (k = c.readInt(!0); b < k; b++) {
          d.constraints.push(e.ikConstraints[c.readInt(!0)]);
        }
        b = 0;
        for (k = c.readInt(!0); b < k; b++) {
          d.constraints.push(e.transformConstraints[c.readInt(!0)]);
        }
        b = 0;
        for (k = c.readInt(!0); b < k; b++) {
          d.constraints.push(e.pathConstraints[c.readInt(!0)]);
        }
        k = c.readInt(!0);
      }
      for (b = 0; b < k; b++) {
        for (var h = c.readInt(!0), g = 0, p = c.readInt(!0); g < p; g++) {
          var t = c.readStringRef(), z = this.readAttachment(c, e, d, h, t, f);
          null != z && d.setAttachment(h, t, z);
        }
      }
      return d;
    };
    d.prototype.readAttachment = function(c, e, k, f, g, b) {
      var m = this.scale, n = c.readStringRef();
      null == n && (n = g);
      g = c.readByte();
      switch(d.AttachmentTypeValues[g]) {
        case a.AttachmentType.Region:
          e = c.readStringRef();
          f = c.readFloat();
          var p = c.readFloat(), t = c.readFloat();
          b = c.readFloat();
          var z = c.readFloat(), r = c.readFloat(), u = c.readFloat();
          g = c.readInt32();
          null == e && (e = n);
          c = this.attachmentLoader.newRegionAttachment(k, n, e);
          if (null == c) {
            break;
          }
          c.path = e;
          c.x = p * m;
          c.y = t * m;
          c.scaleX = b;
          c.scaleY = z;
          c.rotation = f;
          c.width = r * m;
          c.height = u * m;
          a.Color.rgba8888ToColor(c.color, g);
          c.updateOffset();
          return c;
        case a.AttachmentType.BoundingBox:
          f = c.readInt(!0);
          p = this.readVertices(c, f);
          g = b ? c.readInt32() : 0;
          m = this.attachmentLoader.newBoundingBoxAttachment(k, n);
          if (null == m) {
            break;
          }
          m.worldVerticesLength = f << 1;
          m.vertices = p.vertices;
          m.bones = p.bones;
          b && a.Color.rgba8888ToColor(m.color, g);
          return m;
        case a.AttachmentType.Mesh:
          e = c.readStringRef();
          g = c.readInt32();
          f = c.readInt(!0);
          t = this.readFloatArray(c, f << 1, 1);
          z = this.readShortArray(c);
          p = this.readVertices(c, f);
          var v = c.readInt(!0), C = null;
          u = r = 0;
          b && (C = this.readShortArray(c), r = c.readFloat(), u = c.readFloat());
          null == e && (e = n);
          c = this.attachmentLoader.newMeshAttachment(k, n, e);
          if (null == c) {
            break;
          }
          c.path = e;
          a.Color.rgba8888ToColor(c.color, g);
          c.bones = p.bones;
          c.vertices = p.vertices;
          c.worldVerticesLength = f << 1;
          c.triangles = z;
          c.regionUVs = t;
          c.updateUVs();
          c.hullLength = v << 1;
          b && (c.edges = C, c.width = r * m, c.height = u * m);
          return c;
        case a.AttachmentType.LinkedMesh:
          e = c.readStringRef();
          g = c.readInt32();
          p = c.readStringRef();
          t = c.readStringRef();
          z = c.readBoolean();
          u = r = 0;
          b && (r = c.readFloat(), u = c.readFloat());
          null == e && (e = n);
          c = this.attachmentLoader.newMeshAttachment(k, n, e);
          if (null == c) {
            break;
          }
          c.path = e;
          a.Color.rgba8888ToColor(c.color, g);
          b && (c.width = r * m, c.height = u * m);
          this.linkedMeshes.push(new h(c, p, f, t, z));
          return c;
        case a.AttachmentType.Path:
          r = c.readBoolean();
          u = c.readBoolean();
          f = c.readInt(!0);
          p = this.readVertices(c, f);
          t = a.Utils.newArray(f / 3, 0);
          g = 0;
          for (e = t.length; g < e; g++) {
            t[g] = c.readFloat() * m;
          }
          g = b ? c.readInt32() : 0;
          e = this.attachmentLoader.newPathAttachment(k, n);
          if (null == e) {
            break;
          }
          e.closed = r;
          e.constantSpeed = u;
          e.worldVerticesLength = f << 1;
          e.vertices = p.vertices;
          e.bones = p.bones;
          e.lengths = t;
          b && a.Color.rgba8888ToColor(e.color, g);
          return e;
        case a.AttachmentType.Point:
          f = c.readFloat();
          p = c.readFloat();
          t = c.readFloat();
          g = b ? c.readInt32() : 0;
          c = this.attachmentLoader.newPointAttachment(k, n);
          if (null == c) {
            break;
          }
          c.x = p * m;
          c.y = t * m;
          c.rotation = f;
          b && a.Color.rgba8888ToColor(c.color, g);
          return c;
        case a.AttachmentType.Clipping:
          if (m = c.readInt(!0), f = c.readInt(!0), p = this.readVertices(c, f), g = b ? c.readInt32() : 0, c = this.attachmentLoader.newClippingAttachment(k, n), null != c) {
            return c.endSlot = e.slots[m], c.worldVerticesLength = f << 1, c.vertices = p.vertices, c.bones = p.bones, b && a.Color.rgba8888ToColor(c.color, g), c;
          }
      }
      return null;
    };
    d.prototype.readVertices = function(c, d) {
      var k = d << 1, f = new e, h = this.scale;
      if (!c.readBoolean()) {
        return f.vertices = this.readFloatArray(c, k, h), f;
      }
      k = [];
      for (var b = [], g = 0; g < d; g++) {
        var p = c.readInt(!0);
        b.push(p);
        for (var y = 0; y < p; y++) {
          b.push(c.readInt(!0)), k.push(c.readFloat() * h), k.push(c.readFloat() * h), k.push(c.readFloat());
        }
      }
      f.vertices = a.Utils.toFloatArray(k);
      f.bones = b;
      return f;
    };
    d.prototype.readFloatArray = function(a, e, d) {
      var c = Array(e);
      if (1 == d) {
        for (var k = 0; k < e; k++) {
          c[k] = a.readFloat();
        }
      } else {
        for (k = 0; k < e; k++) {
          c[k] = a.readFloat() * d;
        }
      }
      return c;
    };
    d.prototype.readShortArray = function(a) {
      for (var c = a.readInt(!0), e = Array(c), d = 0; d < c; d++) {
        e[d] = a.readShort();
      }
      return e;
    };
    d.prototype.readAnimation = function(c, e, k) {
      for (var f = [], h = this.scale, b = 0, g = new a.Color, p = new a.Color, t = 0, x = c.readInt(!0); t < x; t++) {
        for (var z = c.readInt(!0), r = 0, u = c.readInt(!0); r < u; r++) {
          var v = c.readByte(), C = c.readInt(!0);
          switch(v) {
            case d.SLOT_ATTACHMENT:
              v = new a.AttachmentTimeline(C);
              v.slotIndex = z;
              for (var A = 0; A < C; A++) {
                v.setFrame(A, c.readFloat(), c.readStringRef());
              }
              f.push(v);
              b = Math.max(b, v.frames[C - 1]);
              break;
            case d.SLOT_COLOR:
              v = new a.ColorTimeline(C);
              v.slotIndex = z;
              for (A = 0; A < C; A++) {
                var D = c.readFloat();
                a.Color.rgba8888ToColor(g, c.readInt32());
                v.setFrame(A, D, g.r, g.g, g.b, g.a);
                A < C - 1 && this.readCurve(c, A, v);
              }
              f.push(v);
              b = Math.max(b, v.frames[(C - 1) * a.ColorTimeline.ENTRIES]);
              break;
            case d.SLOT_TWO_COLOR:
              v = new a.TwoColorTimeline(C);
              v.slotIndex = z;
              for (A = 0; A < C; A++) {
                D = c.readFloat(), a.Color.rgba8888ToColor(g, c.readInt32()), a.Color.rgb888ToColor(p, c.readInt32()), v.setFrame(A, D, g.r, g.g, g.b, g.a, p.r, p.g, p.b), A < C - 1 && this.readCurve(c, A, v);
              }
              f.push(v);
              b = Math.max(b, v.frames[(C - 1) * a.TwoColorTimeline.ENTRIES]);
          }
        }
      }
      t = 0;
      for (x = c.readInt(!0); t < x; t++) {
        for (D = c.readInt(!0), r = 0, u = c.readInt(!0); r < u; r++) {
          switch(v = c.readByte(), C = c.readInt(!0), v) {
            case d.BONE_ROTATE:
              v = new a.RotateTimeline(C);
              v.boneIndex = D;
              for (A = 0; A < C; A++) {
                v.setFrame(A, c.readFloat(), c.readFloat()), A < C - 1 && this.readCurve(c, A, v);
              }
              f.push(v);
              b = Math.max(b, v.frames[(C - 1) * a.RotateTimeline.ENTRIES]);
              break;
            case d.BONE_TRANSLATE:
            case d.BONE_SCALE:
            case d.BONE_SHEAR:
              z = 1;
              v == d.BONE_SCALE ? v = new a.ScaleTimeline(C) : v == d.BONE_SHEAR ? v = new a.ShearTimeline(C) : (v = new a.TranslateTimeline(C), z = h);
              v.boneIndex = D;
              for (A = 0; A < C; A++) {
                v.setFrame(A, c.readFloat(), c.readFloat() * z, c.readFloat() * z), A < C - 1 && this.readCurve(c, A, v);
              }
              f.push(v);
              b = Math.max(b, v.frames[(C - 1) * a.TranslateTimeline.ENTRIES]);
          }
        }
      }
      t = 0;
      for (x = c.readInt(!0); t < x; t++) {
        D = c.readInt(!0);
        C = c.readInt(!0);
        v = new a.IkConstraintTimeline(C);
        v.ikConstraintIndex = D;
        for (A = 0; A < C; A++) {
          v.setFrame(A, c.readFloat(), c.readFloat(), c.readFloat() * h, c.readByte(), c.readBoolean(), c.readBoolean()), A < C - 1 && this.readCurve(c, A, v);
        }
        f.push(v);
        b = Math.max(b, v.frames[(C - 1) * a.IkConstraintTimeline.ENTRIES]);
      }
      t = 0;
      for (x = c.readInt(!0); t < x; t++) {
        D = c.readInt(!0);
        C = c.readInt(!0);
        v = new a.TransformConstraintTimeline(C);
        v.transformConstraintIndex = D;
        for (A = 0; A < C; A++) {
          v.setFrame(A, c.readFloat(), c.readFloat(), c.readFloat(), c.readFloat(), c.readFloat()), A < C - 1 && this.readCurve(c, A, v);
        }
        f.push(v);
        b = Math.max(b, v.frames[(C - 1) * a.TransformConstraintTimeline.ENTRIES]);
      }
      t = 0;
      for (x = c.readInt(!0); t < x; t++) {
        for (D = c.readInt(!0), g = k.pathConstraints[D], r = 0, u = c.readInt(!0); r < u; r++) {
          switch(v = c.readByte(), C = c.readInt(!0), v) {
            case d.PATH_POSITION:
            case d.PATH_SPACING:
              z = 1;
              if (v == d.PATH_SPACING) {
                if (v = new a.PathConstraintSpacingTimeline(C), g.spacingMode == a.SpacingMode.Length || g.spacingMode == a.SpacingMode.Fixed) {
                  z = h;
                }
              } else {
                v = new a.PathConstraintPositionTimeline(C), g.positionMode == a.PositionMode.Fixed && (z = h);
              }
              v.pathConstraintIndex = D;
              for (A = 0; A < C; A++) {
                v.setFrame(A, c.readFloat(), c.readFloat() * z), A < C - 1 && this.readCurve(c, A, v);
              }
              f.push(v);
              b = Math.max(b, v.frames[(C - 1) * a.PathConstraintPositionTimeline.ENTRIES]);
              break;
            case d.PATH_MIX:
              v = new a.PathConstraintMixTimeline(C);
              v.pathConstraintIndex = D;
              for (A = 0; A < C; A++) {
                v.setFrame(A, c.readFloat(), c.readFloat(), c.readFloat()), A < C - 1 && this.readCurve(c, A, v);
              }
              f.push(v);
              b = Math.max(b, v.frames[(C - 1) * a.PathConstraintMixTimeline.ENTRIES]);
          }
        }
      }
      t = 0;
      for (x = c.readInt(!0); t < x; t++) {
        for (g = k.skins[c.readInt(!0)], r = 0, u = c.readInt(!0); r < u; r++) {
          z = c.readInt(!0);
          p = 0;
          for (var F = c.readInt(!0); p < F; p++) {
            D = g.getAttachment(z, c.readStringRef());
            var B = null != D.bones, E = D.vertices, H = B ? E.length / 3 * 2 : E.length;
            C = c.readInt(!0);
            v = new a.DeformTimeline(C);
            v.slotIndex = z;
            v.attachment = D;
            for (A = 0; A < C; A++) {
              D = c.readFloat();
              var L = c.readInt(!0);
              if (0 == L) {
                var K = B ? a.Utils.newFloatArray(H) : E;
              } else {
                K = a.Utils.newFloatArray(H);
                var P = c.readInt(!0);
                L += P;
                if (1 == h) {
                  for (; P < L; P++) {
                    K[P] = c.readFloat();
                  }
                } else {
                  for (; P < L; P++) {
                    K[P] = c.readFloat() * h;
                  }
                }
                if (!B) {
                  for (P = 0, L = K.length; P < L; P++) {
                    K[P] += E[P];
                  }
                }
              }
              v.setFrame(A, D, K);
              A < C - 1 && this.readCurve(c, A, v);
            }
            f.push(v);
            b = Math.max(b, v.frames[C - 1]);
          }
        }
      }
      h = c.readInt(!0);
      if (0 < h) {
        v = new a.DrawOrderTimeline(h);
        x = k.slots.length;
        for (t = 0; t < h; t++) {
          D = c.readFloat();
          u = c.readInt(!0);
          C = a.Utils.newArray(x, 0);
          for (r = x - 1; 0 <= r; r--) {
            C[r] = -1;
          }
          A = a.Utils.newArray(x - u, 0);
          for (r = p = g = 0; r < u; r++) {
            for (z = c.readInt(!0); g != z;) {
              A[p++] = g++;
            }
            C[g + c.readInt(!0)] = g++;
          }
          for (; g < x;) {
            A[p++] = g++;
          }
          for (r = x - 1; 0 <= r; r--) {
            -1 == C[r] && (C[r] = A[--p]);
          }
          v.setFrame(t, D, C);
        }
        f.push(v);
        b = Math.max(b, v.frames[h - 1]);
      }
      r = c.readInt(!0);
      if (0 < r) {
        v = new a.EventTimeline(r);
        for (t = 0; t < r; t++) {
          D = c.readFloat(), z = k.events[c.readInt(!0)], D = new a.Event(D, z), D.intValue = c.readInt(!1), D.floatValue = c.readFloat(), D.stringValue = c.readBoolean() ? c.readString() : z.stringValue, null != D.data.audioPath && (D.volume = c.readFloat(), D.balance = c.readFloat()), v.setFrame(t, D);
        }
        f.push(v);
        b = Math.max(b, v.frames[r - 1]);
      }
      return new a.Animation(e, f, b);
    };
    d.prototype.readCurve = function(a, e, k) {
      switch(a.readByte()) {
        case d.CURVE_STEPPED:
          k.setStepped(e);
          break;
        case d.CURVE_BEZIER:
          this.setCurve(k, e, a.readFloat(), a.readFloat(), a.readFloat(), a.readFloat());
      }
    };
    d.prototype.setCurve = function(a, e, d, f, k, b) {
      a.setCurve(e, d, f, k, b);
    };
    d.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6];
    d.TransformModeValues = [a.TransformMode.Normal, a.TransformMode.OnlyTranslation, a.TransformMode.NoRotationOrReflection, a.TransformMode.NoScale, a.TransformMode.NoScaleOrReflection];
    d.PositionModeValues = [a.PositionMode.Fixed, a.PositionMode.Percent];
    d.SpacingModeValues = [a.SpacingMode.Length, a.SpacingMode.Fixed, a.SpacingMode.Percent];
    d.RotateModeValues = [a.RotateMode.Tangent, a.RotateMode.Chain, a.RotateMode.ChainScale];
    d.BlendModeValues = [a.BlendMode.Normal, a.BlendMode.Additive, a.BlendMode.Multiply, a.BlendMode.Screen];
    d.BONE_ROTATE = 0;
    d.BONE_TRANSLATE = 1;
    d.BONE_SCALE = 2;
    d.BONE_SHEAR = 3;
    d.SLOT_ATTACHMENT = 0;
    d.SLOT_COLOR = 1;
    d.SLOT_TWO_COLOR = 2;
    d.PATH_POSITION = 0;
    d.PATH_SPACING = 1;
    d.PATH_MIX = 2;
    d.CURVE_LINEAR = 0;
    d.CURVE_STEPPED = 1;
    d.CURVE_BEZIER = 2;
    return d;
  }();
  a.SkeletonBinary = d;
  var g = function() {
    function a(a, e, d, f) {
      void 0 === e && (e = []);
      void 0 === d && (d = 0);
      void 0 === f && (f = new DataView(a.buffer));
      this.strings = e;
      this.index = d;
      this.buffer = f;
    }
    a.prototype.readByte = function() {
      return this.buffer.getInt8(this.index++);
    };
    a.prototype.readShort = function() {
      var a = this.buffer.getInt16(this.index);
      this.index += 2;
      return a;
    };
    a.prototype.readInt32 = function() {
      var a = this.buffer.getInt32(this.index);
      this.index += 4;
      return a;
    };
    a.prototype.readInt = function(a) {
      var c = this.readByte(), e = c & 127;
      0 != (c & 128) && (c = this.readByte(), e |= (c & 127) << 7, 0 != (c & 128) && (c = this.readByte(), e |= (c & 127) << 14, 0 != (c & 128) && (c = this.readByte(), e |= (c & 127) << 21, 0 != (c & 128) && (c = this.readByte(), e |= (c & 127) << 28))));
      return a ? e : e >>> 1 ^ -(e & 1);
    };
    a.prototype.readStringRef = function() {
      var a = this.readInt(!0);
      return 0 == a ? null : this.strings[a - 1];
    };
    a.prototype.readString = function() {
      var a = this.readInt(!0);
      switch(a) {
        case 0:
          return null;
        case 1:
          return "";
      }
      a--;
      for (var e = "", d = 0; d < a;) {
        var f = this.readByte();
        switch(f >> 4) {
          case 12:
          case 13:
            e += String.fromCharCode((f & 31) << 6 | this.readByte() & 63);
            d += 2;
            break;
          case 14:
            e += String.fromCharCode((f & 15) << 12 | (this.readByte() & 63) << 6 | this.readByte() & 63);
            d += 3;
            break;
          default:
            e += String.fromCharCode(f), d++;
        }
      }
      return e;
    };
    a.prototype.readFloat = function() {
      var a = this.buffer.getFloat32(this.index);
      this.index += 4;
      return a;
    };
    a.prototype.readBoolean = function() {
      return 0 != this.readByte();
    };
    return a;
  }(), h = function() {
    return function(a, c, e, d, f) {
      this.mesh = a;
      this.skin = c;
      this.slotIndex = e;
      this.parent = d;
      this.inheritDeform = f;
    };
  }(), e = function() {
    return function(a, c) {
      void 0 === a && (a = null);
      void 0 === c && (c = null);
      this.bones = a;
      this.vertices = c;
    };
  }();
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d() {
      this.maxY = this.maxX = this.minY = this.minX = 0;
      this.boundingBoxes = [];
      this.polygons = [];
      this.polygonPool = new a.Pool(function() {
        return a.Utils.newFloatArray(16);
      });
    }
    d.prototype.update = function(d, e) {
      if (null == d) {
        throw Error("skeleton cannot be null.");
      }
      var k = this.boundingBoxes, c = this.polygons, h = this.polygonPool;
      d = d.slots;
      var g = d.length;
      k.length = 0;
      h.freeAll(c);
      for (var f = c.length = 0; f < g; f++) {
        var n = d[f];
        if (n.bone.active) {
          var b = n.getAttachment();
          if (b instanceof a.BoundingBoxAttachment) {
            k.push(b);
            var m = h.obtain();
            m.length != b.worldVerticesLength && (m = a.Utils.newFloatArray(b.worldVerticesLength));
            c.push(m);
            b.computeWorldVertices(n, 0, b.worldVerticesLength, m, 0, 2);
          }
        }
      }
      e ? this.aabbCompute() : (this.minY = this.minX = Number.POSITIVE_INFINITY, this.maxY = this.maxX = Number.NEGATIVE_INFINITY);
    };
    d.prototype.aabbCompute = function() {
      for (var a = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, d = Number.NEGATIVE_INFINITY, c = Number.NEGATIVE_INFINITY, g = this.polygons, t = 0, f = g.length; t < f; t++) {
        var n = g[t], b = n, m = 0;
        for (n = n.length; m < n; m += 2) {
          var q = b[m], y = b[m + 1];
          a = Math.min(a, q);
          e = Math.min(e, y);
          d = Math.max(d, q);
          c = Math.max(c, y);
        }
      }
      this.minX = a;
      this.minY = e;
      this.maxX = d;
      this.maxY = c;
    };
    d.prototype.aabbContainsPoint = function(a, e) {
      return a >= this.minX && a <= this.maxX && e >= this.minY && e <= this.maxY;
    };
    d.prototype.aabbIntersectsSegment = function(a, e, d, c) {
      var k = this.minX, h = this.minY, f = this.maxX, g = this.maxY;
      if (a <= k && d <= k || e <= h && c <= h || a >= f && d >= f || e >= g && c >= g) {
        return !1;
      }
      d = (c - e) / (d - a);
      c = d * (k - a) + e;
      if (c > h && c < g) {
        return !0;
      }
      c = d * (f - a) + e;
      if (c > h && c < g) {
        return !0;
      }
      h = (h - e) / d + a;
      if (h > k && h < f) {
        return !0;
      }
      h = (g - e) / d + a;
      return h > k && h < f ? !0 : !1;
    };
    d.prototype.aabbIntersectsSkeleton = function(a) {
      return this.minX < a.maxX && this.maxX > a.minX && this.minY < a.maxY && this.maxY > a.minY;
    };
    d.prototype.containsPoint = function(a, e) {
      for (var d = this.polygons, c = 0, h = d.length; c < h; c++) {
        if (this.containsPointPolygon(d[c], a, e)) {
          return this.boundingBoxes[c];
        }
      }
      return null;
    };
    d.prototype.containsPointPolygon = function(a, e, d) {
      for (var c = a.length, k = c - 2, h = !1, f = 0; f < c; f += 2) {
        var g = a[f + 1], b = a[k + 1];
        if (g < d && b >= d || b < d && g >= d) {
          var m = a[f];
          m + (d - g) / (b - g) * (a[k] - m) < e && (h = !h);
        }
        k = f;
      }
      return h;
    };
    d.prototype.intersectsSegment = function(a, e, d, c) {
      for (var k = this.polygons, h = 0, f = k.length; h < f; h++) {
        if (this.intersectsSegmentPolygon(k[h], a, e, d, c)) {
          return this.boundingBoxes[h];
        }
      }
      return null;
    };
    d.prototype.intersectsSegmentPolygon = function(a, e, d, c, g) {
      for (var k = a.length, f = e - c, h = d - g, b = e * g - d * c, m = a[k - 2], p = a[k - 1], y = 0; y < k; y += 2) {
        var x = a[y], z = a[y + 1], r = m * z - p * x, u = m - x, v = p - z, C = f * v - h * u;
        u = (b * u - f * r) / C;
        if ((u >= m && u <= x || u >= x && u <= m) && (u >= e && u <= c || u >= c && u <= e) && (m = (b * v - h * r) / C, (m >= p && m <= z || m >= z && m <= p) && (m >= d && m <= g || m >= g && m <= d))) {
          return !0;
        }
        m = x;
        p = z;
      }
      return !1;
    };
    d.prototype.getPolygon = function(a) {
      if (null == a) {
        throw Error("boundingBox cannot be null.");
      }
      a = this.boundingBoxes.indexOf(a);
      return -1 == a ? null : this.polygons[a];
    };
    d.prototype.getWidth = function() {
      return this.maxX - this.minX;
    };
    d.prototype.getHeight = function() {
      return this.maxY - this.minY;
    };
    return d;
  }();
  a.SkeletonBounds = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d() {
      this.triangulator = new a.Triangulator;
      this.clippingPolygon = [];
      this.clipOutput = [];
      this.clippedVertices = [];
      this.clippedTriangles = [];
      this.scratch = [];
    }
    d.prototype.clipStart = function(h, e) {
      if (null != this.clipAttachment) {
        return 0;
      }
      this.clipAttachment = e;
      var k = e.worldVerticesLength, c = a.Utils.setArraySize(this.clippingPolygon, k);
      e.computeWorldVertices(h, 0, k, c, 0, 2);
      h = this.clippingPolygon;
      d.makeClockwise(h);
      h = this.clippingPolygons = this.triangulator.decompose(h, this.triangulator.triangulate(h));
      e = 0;
      for (k = h.length; e < k; e++) {
        c = h[e], d.makeClockwise(c), c.push(c[0]), c.push(c[1]);
      }
      return h.length;
    };
    d.prototype.clipEndWithSlot = function(a) {
      null != this.clipAttachment && this.clipAttachment.endSlot == a.data && this.clipEnd();
    };
    d.prototype.clipEnd = function() {
      null != this.clipAttachment && (this.clippingPolygons = this.clipAttachment = null, this.clippedVertices.length = 0, this.clippedTriangles.length = 0, this.clippingPolygon.length = 0);
    };
    d.prototype.isClipping = function() {
      return null != this.clipAttachment;
    };
    d.prototype.clipTriangles = function(d, e, k, c, g, t, f, n) {
      e = this.clipOutput;
      var b = this.clippedVertices, h = this.clippedTriangles, p = this.clippingPolygons, y = this.clippingPolygons.length, x = n ? 12 : 8, z = 0;
      b.length = 0;
      var r = h.length = 0;
      a: for (; r < c; r += 3) {
        var u = k[r] << 1, v = d[u], C = d[u + 1], A = g[u], D = g[u + 1];
        u = k[r + 1] << 1;
        var F = d[u], B = d[u + 1], E = g[u], H = g[u + 1];
        u = k[r + 2] << 1;
        var L = d[u], K = d[u + 1], P = g[u];
        u = g[u + 1];
        for (var J = 0; J < y; J++) {
          var I = b.length;
          if (this.clip(v, C, F, B, L, K, p[J], e)) {
            var N = e.length;
            if (0 != N) {
              for (var S = B - K, Q = L - F, Z = v - L, R = K - C, W = 1 / (S * Z + Q * (C - K)), O = N >> 1, ca = this.clipOutput, M = a.Utils.setArraySize(b, I + O * x), V = 0; V < N; V += 2) {
                var fa = ca[V], ja = ca[V + 1];
                M[I] = fa;
                M[I + 1] = ja;
                M[I + 2] = t.r;
                M[I + 3] = t.g;
                M[I + 4] = t.b;
                M[I + 5] = t.a;
                fa -= L;
                var X = ja - K;
                ja = (S * fa + Q * X) * W;
                fa = (R * fa + Z * X) * W;
                X = 1 - ja - fa;
                M[I + 6] = A * ja + E * fa + P * X;
                M[I + 7] = D * ja + H * fa + u * X;
                n && (M[I + 8] = f.r, M[I + 9] = f.g, M[I + 10] = f.b, M[I + 11] = f.a);
                I += x;
              }
              I = h.length;
              N = a.Utils.setArraySize(h, I + 3 * (O - 2));
              O--;
              for (V = 1; V < O; V++) {
                N[I] = z, N[I + 1] = z + V, N[I + 2] = z + V + 1, I += 3;
              }
              z += O + 1;
            }
          } else {
            M = a.Utils.setArraySize(b, I + 3 * x);
            M[I] = v;
            M[I + 1] = C;
            M[I + 2] = t.r;
            M[I + 3] = t.g;
            M[I + 4] = t.b;
            M[I + 5] = t.a;
            n ? (M[I + 6] = A, M[I + 7] = D, M[I + 8] = f.r, M[I + 9] = f.g, M[I + 10] = f.b, M[I + 11] = f.a, M[I + 12] = F, M[I + 13] = B, M[I + 14] = t.r, M[I + 15] = t.g, M[I + 16] = t.b, M[I + 17] = t.a, M[I + 18] = E, M[I + 19] = H, M[I + 20] = f.r, M[I + 21] = f.g, M[I + 22] = f.b, M[I + 23] = f.a, M[I + 24] = L, M[I + 25] = K, M[I + 26] = t.r, M[I + 27] = t.g, M[I + 28] = t.b, M[I + 29] = t.a, M[I + 30] = P, M[I + 31] = u, M[I + 32] = f.r, M[I + 33] = f.g, M[I + 34] = f.b, M[I + 35] = f.a) : 
            (M[I + 6] = A, M[I + 7] = D, M[I + 8] = F, M[I + 9] = B, M[I + 10] = t.r, M[I + 11] = t.g, M[I + 12] = t.b, M[I + 13] = t.a, M[I + 14] = E, M[I + 15] = H, M[I + 16] = L, M[I + 17] = K, M[I + 18] = t.r, M[I + 19] = t.g, M[I + 20] = t.b, M[I + 21] = t.a, M[I + 22] = P, M[I + 23] = u);
            I = h.length;
            N = a.Utils.setArraySize(h, I + 3);
            N[I] = z;
            N[I + 1] = z + 1;
            N[I + 2] = z + 2;
            z += 3;
            continue a;
          }
        }
      }
    };
    d.prototype.clip = function(a, e, d, c, g, t, f, n) {
      var b = n, k = !1;
      if (2 <= f.length % 4) {
        var h = n;
        n = this.scratch;
      } else {
        h = this.scratch;
      }
      h.length = 0;
      h.push(a);
      h.push(e);
      h.push(d);
      h.push(c);
      h.push(g);
      h.push(t);
      h.push(a);
      h.push(e);
      n.length = 0;
      e = f.length - 4;
      for (a = 0;; a += 2) {
        d = f[a];
        c = f[a + 1];
        g = f[a + 2];
        t = f[a + 3];
        for (var p = d - g, x = c - t, z = h, r = h.length - 2, u = n.length, v = 0; v < r; v += 2) {
          var C = z[v], A = z[v + 1], D = z[v + 2], F = z[v + 3], B = 0 < p * (F - t) - x * (D - g);
          if (0 < p * (A - t) - x * (C - g)) {
            if (B) {
              n.push(D);
              n.push(F);
              continue;
            }
            k = F - A;
            B = D - C;
            var E = k * (g - d) - B * (t - c);
            1E-6 < Math.abs(E) ? (k = (B * (c - A) - k * (d - C)) / E, n.push(d + (g - d) * k), n.push(c + (t - c) * k)) : (n.push(d), n.push(c));
          } else {
            B && (k = F - A, B = D - C, E = k * (g - d) - B * (t - c), 1E-6 < Math.abs(E) ? (k = (B * (c - A) - k * (d - C)) / E, n.push(d + (g - d) * k), n.push(c + (t - c) * k)) : (n.push(d), n.push(c)), n.push(D), n.push(F));
          }
          k = !0;
        }
        if (u == n.length) {
          return b.length = 0, !0;
        }
        n.push(n[0]);
        n.push(n[1]);
        if (a == e) {
          break;
        }
        d = n;
        n = h;
        n.length = 0;
        h = d;
      }
      if (b != n) {
        for (a = b.length = 0, f = n.length - 2; a < f; a++) {
          b[a] = n[a];
        }
      } else {
        b.length -= 2;
      }
      return k;
    };
    d.makeClockwise = function(a) {
      for (var e = a.length, d = a[e - 2] * a[1] - a[0] * a[e - 1], c, h, g, f, n = 0, b = e - 3; n < b; n += 2) {
        c = a[n], h = a[n + 1], g = a[n + 2], f = a[n + 3], d += c * f - g * h;
      }
      if (!(0 > d)) {
        for (n = 0, d = e - 2, b = e >> 1; n < b; n += 2) {
          e = a[n], c = a[n + 1], h = d - n, a[n] = a[h], a[n + 1] = a[h + 1], a[h] = e, a[h + 1] = c;
        }
      }
    };
    return d;
  }();
  a.SkeletonClipping = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function a() {
      this.bones = [];
      this.slots = [];
      this.skins = [];
      this.events = [];
      this.animations = [];
      this.ikConstraints = [];
      this.transformConstraints = [];
      this.pathConstraints = [];
      this.fps = 0;
    }
    a.prototype.findBone = function(a) {
      if (null == a) {
        throw Error("boneName cannot be null.");
      }
      for (var e = this.bones, d = 0, c = e.length; d < c; d++) {
        var h = e[d];
        if (h.name == a) {
          return h;
        }
      }
      return null;
    };
    a.prototype.findBoneIndex = function(a) {
      if (null == a) {
        throw Error("boneName cannot be null.");
      }
      for (var e = this.bones, d = 0, c = e.length; d < c; d++) {
        if (e[d].name == a) {
          return d;
        }
      }
      return -1;
    };
    a.prototype.findSlot = function(a) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var e = this.slots, d = 0, c = e.length; d < c; d++) {
        var h = e[d];
        if (h.name == a) {
          return h;
        }
      }
      return null;
    };
    a.prototype.findSlotIndex = function(a) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var e = this.slots, d = 0, c = e.length; d < c; d++) {
        if (e[d].name == a) {
          return d;
        }
      }
      return -1;
    };
    a.prototype.findSkin = function(a) {
      if (null == a) {
        throw Error("skinName cannot be null.");
      }
      for (var e = this.skins, d = 0, c = e.length; d < c; d++) {
        var h = e[d];
        if (h.name == a) {
          return h;
        }
      }
      return null;
    };
    a.prototype.findEvent = function(a) {
      if (null == a) {
        throw Error("eventDataName cannot be null.");
      }
      for (var e = this.events, d = 0, c = e.length; d < c; d++) {
        var h = e[d];
        if (h.name == a) {
          return h;
        }
      }
      return null;
    };
    a.prototype.findAnimation = function(a) {
      if (null == a) {
        throw Error("animationName cannot be null.");
      }
      for (var e = this.animations, d = 0, c = e.length; d < c; d++) {
        var h = e[d];
        if (h.name == a) {
          return h;
        }
      }
      return null;
    };
    a.prototype.findIkConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var e = this.ikConstraints, d = 0, c = e.length; d < c; d++) {
        var h = e[d];
        if (h.name == a) {
          return h;
        }
      }
      return null;
    };
    a.prototype.findTransformConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var e = this.transformConstraints, d = 0, c = e.length; d < c; d++) {
        var h = e[d];
        if (h.name == a) {
          return h;
        }
      }
      return null;
    };
    a.prototype.findPathConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var e = this.pathConstraints, d = 0, c = e.length; d < c; d++) {
        var h = e[d];
        if (h.name == a) {
          return h;
        }
      }
      return null;
    };
    a.prototype.findPathConstraintIndex = function(a) {
      if (null == a) {
        throw Error("pathConstraintName cannot be null.");
      }
      for (var e = this.pathConstraints, d = 0, c = e.length; d < c; d++) {
        if (e[d].name == a) {
          return d;
        }
      }
      return -1;
    };
    return a;
  }();
  a.SkeletonData = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d(a) {
      this.scale = 1;
      this.linkedMeshes = [];
      this.attachmentLoader = a;
    }
    d.prototype.readSkeletonData = function(e) {
      var k = this.scale, c = new a.SkeletonData;
      e = "string" === typeof e ? JSON.parse(e) : e;
      var g = e.skeleton;
      if (null != g) {
        c.hash = g.hash;
        c.version = g.spine;
        if ("3.8.75" == c.version) {
          throw Error("Unsupported skeleton data, please export with a newer version of Spine.");
        }
        c.x = g.x;
        c.y = g.y;
        c.width = g.width;
        c.height = g.height;
        c.fps = g.fps;
        c.imagesPath = g.images;
      }
      if (e.bones) {
        for (g = 0; g < e.bones.length; g++) {
          var h = e.bones[g], f = null, n = this.getValue(h, "parent", null);
          if (null != n && (f = c.findBone(n), null == f)) {
            throw Error("Parent bone not found: " + n);
          }
          f = new a.BoneData(c.bones.length, h.name, f);
          f.length = this.getValue(h, "length", 0) * k;
          f.x = this.getValue(h, "x", 0) * k;
          f.y = this.getValue(h, "y", 0) * k;
          f.rotation = this.getValue(h, "rotation", 0);
          f.scaleX = this.getValue(h, "scaleX", 1);
          f.scaleY = this.getValue(h, "scaleY", 1);
          f.shearX = this.getValue(h, "shearX", 0);
          f.shearY = this.getValue(h, "shearY", 0);
          f.transformMode = d.transformModeFromString(this.getValue(h, "transform", "normal"));
          f.skinRequired = this.getValue(h, "skin", !1);
          c.bones.push(f);
        }
      }
      if (e.slots) {
        for (g = 0; g < e.slots.length; g++) {
          h = e.slots[g];
          var b = h.name;
          n = h.bone;
          f = c.findBone(n);
          if (null == f) {
            throw Error("Slot bone not found: " + n);
          }
          f = new a.SlotData(c.slots.length, b, f);
          n = this.getValue(h, "color", null);
          null != n && f.color.setFromString(n);
          n = this.getValue(h, "dark", null);
          null != n && (f.darkColor = new a.Color(1, 1, 1, 1), f.darkColor.setFromString(n));
          f.attachmentName = this.getValue(h, "attachment", null);
          f.blendMode = d.blendModeFromString(this.getValue(h, "blend", "normal"));
          c.slots.push(f);
        }
      }
      if (e.ik) {
        for (g = 0; g < e.ik.length; g++) {
          var m = e.ik[g];
          f = new a.IkConstraintData(m.name);
          f.order = this.getValue(m, "order", 0);
          f.skinRequired = this.getValue(m, "skin", !1);
          for (var q = 0; q < m.bones.length; q++) {
            n = m.bones[q];
            h = c.findBone(n);
            if (null == h) {
              throw Error("IK bone not found: " + n);
            }
            f.bones.push(h);
          }
          h = m.target;
          f.target = c.findBone(h);
          if (null == f.target) {
            throw Error("IK target bone not found: " + h);
          }
          f.mix = this.getValue(m, "mix", 1);
          f.softness = this.getValue(m, "softness", 0) * k;
          f.bendDirection = this.getValue(m, "bendPositive", !0) ? 1 : -1;
          f.compress = this.getValue(m, "compress", !1);
          f.stretch = this.getValue(m, "stretch", !1);
          f.uniform = this.getValue(m, "uniform", !1);
          c.ikConstraints.push(f);
        }
      }
      if (e.transform) {
        for (g = 0; g < e.transform.length; g++) {
          m = e.transform[g];
          f = new a.TransformConstraintData(m.name);
          f.order = this.getValue(m, "order", 0);
          f.skinRequired = this.getValue(m, "skin", !1);
          for (q = 0; q < m.bones.length; q++) {
            n = m.bones[q];
            h = c.findBone(n);
            if (null == h) {
              throw Error("Transform constraint bone not found: " + n);
            }
            f.bones.push(h);
          }
          h = m.target;
          f.target = c.findBone(h);
          if (null == f.target) {
            throw Error("Transform constraint target bone not found: " + h);
          }
          f.local = this.getValue(m, "local", !1);
          f.relative = this.getValue(m, "relative", !1);
          f.offsetRotation = this.getValue(m, "rotation", 0);
          f.offsetX = this.getValue(m, "x", 0) * k;
          f.offsetY = this.getValue(m, "y", 0) * k;
          f.offsetScaleX = this.getValue(m, "scaleX", 0);
          f.offsetScaleY = this.getValue(m, "scaleY", 0);
          f.offsetShearY = this.getValue(m, "shearY", 0);
          f.rotateMix = this.getValue(m, "rotateMix", 1);
          f.translateMix = this.getValue(m, "translateMix", 1);
          f.scaleMix = this.getValue(m, "scaleMix", 1);
          f.shearMix = this.getValue(m, "shearMix", 1);
          c.transformConstraints.push(f);
        }
      }
      if (e.path) {
        for (g = 0; g < e.path.length; g++) {
          m = e.path[g];
          f = new a.PathConstraintData(m.name);
          f.order = this.getValue(m, "order", 0);
          f.skinRequired = this.getValue(m, "skin", !1);
          for (q = 0; q < m.bones.length; q++) {
            n = m.bones[q];
            h = c.findBone(n);
            if (null == h) {
              throw Error("Transform constraint bone not found: " + n);
            }
            f.bones.push(h);
          }
          h = m.target;
          f.target = c.findSlot(h);
          if (null == f.target) {
            throw Error("Path target slot not found: " + h);
          }
          f.positionMode = d.positionModeFromString(this.getValue(m, "positionMode", "percent"));
          f.spacingMode = d.spacingModeFromString(this.getValue(m, "spacingMode", "length"));
          f.rotateMode = d.rotateModeFromString(this.getValue(m, "rotateMode", "tangent"));
          f.offsetRotation = this.getValue(m, "rotation", 0);
          f.position = this.getValue(m, "position", 0);
          f.positionMode == a.PositionMode.Fixed && (f.position *= k);
          f.spacing = this.getValue(m, "spacing", 0);
          if (f.spacingMode == a.SpacingMode.Length || f.spacingMode == a.SpacingMode.Fixed) {
            f.spacing *= k;
          }
          f.rotateMix = this.getValue(m, "rotateMix", 1);
          f.translateMix = this.getValue(m, "translateMix", 1);
          c.pathConstraints.push(f);
        }
      }
      if (e.skins) {
        for (g = 0; g < e.skins.length; g++) {
          f = e.skins[g];
          k = new a.Skin(f.name);
          if (f.bones) {
            for (n = 0; n < f.bones.length; n++) {
              h = c.findBone(f.bones[n]);
              if (null == h) {
                throw Error("Skin bone not found: " + f.bones[g]);
              }
              k.bones.push(h);
            }
          }
          if (f.ik) {
            for (n = 0; n < f.ik.length; n++) {
              h = c.findIkConstraint(f.ik[n]);
              if (null == h) {
                throw Error("Skin IK constraint not found: " + f.ik[g]);
              }
              k.constraints.push(h);
            }
          }
          if (f.transform) {
            for (n = 0; n < f.transform.length; n++) {
              h = c.findTransformConstraint(f.transform[n]);
              if (null == h) {
                throw Error("Skin transform constraint not found: " + f.transform[g]);
              }
              k.constraints.push(h);
            }
          }
          if (f.path) {
            for (n = 0; n < f.path.length; n++) {
              h = c.findPathConstraint(f.path[n]);
              if (null == h) {
                throw Error("Skin path constraint not found: " + f.path[g]);
              }
              k.constraints.push(h);
            }
          }
          for (b in f.attachments) {
            n = c.findSlot(b);
            if (null == n) {
              throw Error("Slot not found: " + b);
            }
            h = f.attachments[b];
            for (var y in h) {
              m = this.readAttachment(h[y], k, n.index, y, c), null != m && k.setAttachment(n.index, y, m);
            }
          }
          c.skins.push(k);
          "default" == k.name && (c.defaultSkin = k);
        }
      }
      g = 0;
      for (b = this.linkedMeshes.length; g < b; g++) {
        y = this.linkedMeshes[g];
        k = null == y.skin ? c.defaultSkin : c.findSkin(y.skin);
        if (null == k) {
          throw Error("Skin not found: " + y.skin);
        }
        k = k.getAttachment(y.slotIndex, y.parent);
        if (null == k) {
          throw Error("Parent mesh not found: " + y.parent);
        }
        y.mesh.deformAttachment = y.inheritDeform ? k : y.mesh;
        y.mesh.setParentMesh(k);
        y.mesh.updateUVs();
      }
      this.linkedMeshes.length = 0;
      if (e.events) {
        for (var x in e.events) {
          g = e.events[x], f = new a.EventData(x), f.intValue = this.getValue(g, "int", 0), f.floatValue = this.getValue(g, "float", 0), f.stringValue = this.getValue(g, "string", ""), f.audioPath = this.getValue(g, "audio", null), null != f.audioPath && (f.volume = this.getValue(g, "volume", 1), f.balance = this.getValue(g, "balance", 0)), c.events.push(f);
        }
      }
      if (e.animations) {
        for (var z in e.animations) {
          this.readAnimation(e.animations[z], z, c);
        }
      }
      return c;
    };
    d.prototype.readAttachment = function(e, d, c, h, t) {
      var f = this.scale;
      h = this.getValue(e, "name", h);
      switch(this.getValue(e, "type", "region")) {
        case "region":
          t = this.getValue(e, "path", h);
          c = this.attachmentLoader.newRegionAttachment(d, h, t);
          if (null == c) {
            break;
          }
          c.path = t;
          c.x = this.getValue(e, "x", 0) * f;
          c.y = this.getValue(e, "y", 0) * f;
          c.scaleX = this.getValue(e, "scaleX", 1);
          c.scaleY = this.getValue(e, "scaleY", 1);
          c.rotation = this.getValue(e, "rotation", 0);
          c.width = e.width * f;
          c.height = e.height * f;
          d = this.getValue(e, "color", null);
          null != d && c.color.setFromString(d);
          c.updateOffset();
          return c;
        case "boundingbox":
          f = this.attachmentLoader.newBoundingBoxAttachment(d, h);
          if (null == f) {
            break;
          }
          this.readVertices(e, f, e.vertexCount << 1);
          d = this.getValue(e, "color", null);
          null != d && f.color.setFromString(d);
          return f;
        case "mesh":
        case "linkedmesh":
          t = this.getValue(e, "path", h);
          h = this.attachmentLoader.newMeshAttachment(d, h, t);
          if (null == h) {
            break;
          }
          h.path = t;
          d = this.getValue(e, "color", null);
          null != d && h.color.setFromString(d);
          h.width = this.getValue(e, "width", 0) * f;
          h.height = this.getValue(e, "height", 0) * f;
          f = this.getValue(e, "parent", null);
          if (null != f) {
            return this.linkedMeshes.push(new g(h, this.getValue(e, "skin", null), c, f, this.getValue(e, "deform", !0))), h;
          }
          f = e.uvs;
          this.readVertices(e, h, f.length);
          h.triangles = e.triangles;
          h.regionUVs = f;
          h.updateUVs();
          h.edges = this.getValue(e, "edges", null);
          h.hullLength = 2 * this.getValue(e, "hull", 0);
          return h;
        case "path":
          t = this.attachmentLoader.newPathAttachment(d, h);
          if (null == t) {
            break;
          }
          t.closed = this.getValue(e, "closed", !1);
          t.constantSpeed = this.getValue(e, "constantSpeed", !0);
          c = e.vertexCount;
          this.readVertices(e, t, c << 1);
          c = a.Utils.newArray(c / 3, 0);
          for (d = 0; d < e.lengths.length; d++) {
            c[d] = e.lengths[d] * f;
          }
          t.lengths = c;
          d = this.getValue(e, "color", null);
          null != d && t.color.setFromString(d);
          return t;
        case "point":
          t = this.attachmentLoader.newPointAttachment(d, h);
          if (null == t) {
            break;
          }
          t.x = this.getValue(e, "x", 0) * f;
          t.y = this.getValue(e, "y", 0) * f;
          t.rotation = this.getValue(e, "rotation", 0);
          d = this.getValue(e, "color", null);
          null != d && t.color.setFromString(d);
          return t;
        case "clipping":
          if (f = this.attachmentLoader.newClippingAttachment(d, h), null != f) {
            c = this.getValue(e, "end", null);
            if (null != c) {
              t = t.findSlot(c);
              if (null == t) {
                throw Error("Clipping end slot not found: " + c);
              }
              f.endSlot = t;
            }
            c = e.vertexCount;
            this.readVertices(e, f, c << 1);
            d = this.getValue(e, "color", null);
            null != d && f.color.setFromString(d);
            return f;
          }
      }
      return null;
    };
    d.prototype.readVertices = function(e, d, c) {
      var k = this.scale;
      d.worldVerticesLength = c;
      e = e.vertices;
      if (c == e.length) {
        var h = a.Utils.toFloatArray(e);
        if (1 != k) {
          c = 0;
          for (var f = e.length; c < f; c++) {
            h[c] *= k;
          }
        }
        d.vertices = h;
      } else {
        h = [];
        var g = [];
        c = 0;
        for (f = e.length; c < f;) {
          var b = e[c++];
          g.push(b);
          for (b = c + 4 * b; c < b; c += 4) {
            g.push(e[c]), h.push(e[c + 1] * k), h.push(e[c + 2] * k), h.push(e[c + 3]);
          }
        }
        d.bones = g;
        d.vertices = a.Utils.toFloatArray(h);
      }
    };
    d.prototype.readAnimation = function(e, d, c) {
      var k = this.scale, h = [], f = 0;
      if (e.slots) {
        for (var g in e.slots) {
          var b = e.slots[g], m = c.findSlotIndex(g);
          if (-1 == m) {
            throw Error("Slot not found: " + g);
          }
          for (var q in b) {
            var y = b[q];
            if ("attachment" == q) {
              var x = new a.AttachmentTimeline(y.length);
              x.slotIndex = m;
              for (var z = 0, r = 0; r < y.length; r++) {
                var u = y[r];
                x.setFrame(z++, this.getValue(u, "time", 0), u.name);
              }
              h.push(x);
              f = Math.max(f, x.frames[x.getFrameCount() - 1]);
            } else {
              if ("color" == q) {
                x = new a.ColorTimeline(y.length);
                x.slotIndex = m;
                for (r = z = 0; r < y.length; r++) {
                  u = y[r];
                  var v = new a.Color;
                  v.setFromString(u.color);
                  x.setFrame(z, this.getValue(u, "time", 0), v.r, v.g, v.b, v.a);
                  this.readCurve(u, x, z);
                  z++;
                }
                h.push(x);
                f = Math.max(f, x.frames[(x.getFrameCount() - 1) * a.ColorTimeline.ENTRIES]);
              } else {
                if ("twoColor" == q) {
                  x = new a.TwoColorTimeline(y.length);
                  x.slotIndex = m;
                  for (r = z = 0; r < y.length; r++) {
                    u = y[r];
                    v = new a.Color;
                    var C = new a.Color;
                    v.setFromString(u.light);
                    C.setFromString(u.dark);
                    x.setFrame(z, this.getValue(u, "time", 0), v.r, v.g, v.b, v.a, C.r, C.g, C.b);
                    this.readCurve(u, x, z);
                    z++;
                  }
                  h.push(x);
                  f = Math.max(f, x.frames[(x.getFrameCount() - 1) * a.TwoColorTimeline.ENTRIES]);
                } else {
                  throw Error("Invalid timeline type for a slot: " + q + " (" + g + ")");
                }
              }
            }
          }
        }
      }
      if (e.bones) {
        for (var A in e.bones) {
          b = e.bones[A];
          v = c.findBoneIndex(A);
          if (-1 == v) {
            throw Error("Bone not found: " + A);
          }
          for (q in b) {
            if (y = b[q], "rotate" === q) {
              x = new a.RotateTimeline(y.length);
              x.boneIndex = v;
              for (r = z = 0; r < y.length; r++) {
                u = y[r], x.setFrame(z, this.getValue(u, "time", 0), this.getValue(u, "angle", 0)), this.readCurve(u, x, z), z++;
              }
              h.push(x);
              f = Math.max(f, x.frames[(x.getFrameCount() - 1) * a.RotateTimeline.ENTRIES]);
            } else {
              if ("translate" === q || "scale" === q || "shear" === q) {
                m = 1;
                C = 0;
                "scale" === q ? (x = new a.ScaleTimeline(y.length), C = 1) : "shear" === q ? x = new a.ShearTimeline(y.length) : (x = new a.TranslateTimeline(y.length), m = k);
                x.boneIndex = v;
                for (r = z = 0; r < y.length; r++) {
                  u = y[r];
                  var D = this.getValue(u, "x", C), F = this.getValue(u, "y", C);
                  x.setFrame(z, this.getValue(u, "time", 0), D * m, F * m);
                  this.readCurve(u, x, z);
                  z++;
                }
                h.push(x);
                f = Math.max(f, x.frames[(x.getFrameCount() - 1) * a.TranslateTimeline.ENTRIES]);
              } else {
                throw Error("Invalid timeline type for a bone: " + q + " (" + A + ")");
              }
            }
          }
        }
      }
      if (e.ik) {
        for (var B in e.ik) {
          b = e.ik[B];
          z = c.findIkConstraint(B);
          x = new a.IkConstraintTimeline(b.length);
          x.ikConstraintIndex = c.ikConstraints.indexOf(z);
          for (r = z = 0; r < b.length; r++) {
            u = b[r], x.setFrame(z, this.getValue(u, "time", 0), this.getValue(u, "mix", 1), this.getValue(u, "softness", 0) * k, this.getValue(u, "bendPositive", !0) ? 1 : -1, this.getValue(u, "compress", !1), this.getValue(u, "stretch", !1)), this.readCurve(u, x, z), z++;
          }
          h.push(x);
          f = Math.max(f, x.frames[(x.getFrameCount() - 1) * a.IkConstraintTimeline.ENTRIES]);
        }
      }
      if (e.transform) {
        for (B in e.transform) {
          b = e.transform[B];
          z = c.findTransformConstraint(B);
          x = new a.TransformConstraintTimeline(b.length);
          x.transformConstraintIndex = c.transformConstraints.indexOf(z);
          for (r = z = 0; r < b.length; r++) {
            u = b[r], x.setFrame(z, this.getValue(u, "time", 0), this.getValue(u, "rotateMix", 1), this.getValue(u, "translateMix", 1), this.getValue(u, "scaleMix", 1), this.getValue(u, "shearMix", 1)), this.readCurve(u, x, z), z++;
          }
          h.push(x);
          f = Math.max(f, x.frames[(x.getFrameCount() - 1) * a.TransformConstraintTimeline.ENTRIES]);
        }
      }
      if (e.path) {
        for (B in e.path) {
          b = e.path[B];
          A = c.findPathConstraintIndex(B);
          if (-1 == A) {
            throw Error("Path constraint not found: " + B);
          }
          v = c.pathConstraints[A];
          for (q in b) {
            if (y = b[q], "position" === q || "spacing" === q) {
              m = 1;
              if ("spacing" === q) {
                if (x = new a.PathConstraintSpacingTimeline(y.length), v.spacingMode == a.SpacingMode.Length || v.spacingMode == a.SpacingMode.Fixed) {
                  m = k;
                }
              } else {
                x = new a.PathConstraintPositionTimeline(y.length), v.positionMode == a.PositionMode.Fixed && (m = k);
              }
              x.pathConstraintIndex = A;
              for (r = z = 0; r < y.length; r++) {
                u = y[r], x.setFrame(z, this.getValue(u, "time", 0), this.getValue(u, q, 0) * m), this.readCurve(u, x, z), z++;
              }
              h.push(x);
              f = Math.max(f, x.frames[(x.getFrameCount() - 1) * a.PathConstraintPositionTimeline.ENTRIES]);
            } else {
              if ("mix" === q) {
                x = new a.PathConstraintMixTimeline(y.length);
                x.pathConstraintIndex = A;
                for (r = z = 0; r < y.length; r++) {
                  u = y[r], x.setFrame(z, this.getValue(u, "time", 0), this.getValue(u, "rotateMix", 1), this.getValue(u, "translateMix", 1)), this.readCurve(u, x, z), z++;
                }
                h.push(x);
                f = Math.max(f, x.frames[(x.getFrameCount() - 1) * a.PathConstraintMixTimeline.ENTRIES]);
              }
            }
          }
        }
      }
      if (e.deform) {
        for (var E in e.deform) {
          A = e.deform[E];
          v = c.findSkin(E);
          if (null == v) {
            throw Error("Skin not found: " + E);
          }
          for (g in A) {
            b = A[g];
            m = c.findSlotIndex(g);
            if (-1 == m) {
              throw Error("Slot not found: " + b.name);
            }
            for (q in b) {
              y = b[q];
              z = v.getAttachment(m, q);
              if (null == z) {
                throw Error("Deform attachment not found: " + y.name);
              }
              C = null != z.bones;
              D = z.vertices;
              F = C ? D.length / 3 * 2 : D.length;
              x = new a.DeformTimeline(y.length);
              x.slotIndex = m;
              x.attachment = z;
              for (B = z = 0; B < y.length; B++) {
                u = y[B];
                var H = this.getValue(u, "vertices", null);
                if (null == H) {
                  var L = C ? a.Utils.newFloatArray(F) : D;
                } else {
                  L = a.Utils.newFloatArray(F);
                  r = this.getValue(u, "offset", 0);
                  a.Utils.arrayCopy(H, 0, L, r, H.length);
                  if (1 != k) {
                    for (H = r + H.length; r < H; r++) {
                      L[r] *= k;
                    }
                  }
                  if (!C) {
                    for (r = 0; r < F; r++) {
                      L[r] += D[r];
                    }
                  }
                }
                x.setFrame(z, this.getValue(u, "time", 0), L);
                this.readCurve(u, x, z);
                z++;
              }
              h.push(x);
              f = Math.max(f, x.frames[x.getFrameCount() - 1]);
            }
          }
        }
      }
      k = e.drawOrder;
      null == k && (k = e.draworder);
      if (null != k) {
        x = new a.DrawOrderTimeline(k.length);
        g = c.slots.length;
        for (B = z = 0; B < k.length; B++) {
          q = k[B];
          E = null;
          y = this.getValue(q, "offsets", null);
          if (null != y) {
            E = a.Utils.newArray(g, -1);
            u = a.Utils.newArray(g - y.length, 0);
            for (r = A = b = 0; r < y.length; r++) {
              v = y[r];
              m = c.findSlotIndex(v.slot);
              if (-1 == m) {
                throw Error("Slot not found: " + v.slot);
              }
              for (; b != m;) {
                u[A++] = b++;
              }
              E[b + v.offset] = b++;
            }
            for (; b < g;) {
              u[A++] = b++;
            }
            for (r = g - 1; 0 <= r; r--) {
              -1 == E[r] && (E[r] = u[--A]);
            }
          }
          x.setFrame(z++, this.getValue(q, "time", 0), E);
        }
        h.push(x);
        f = Math.max(f, x.frames[x.getFrameCount() - 1]);
      }
      if (e.events) {
        x = new a.EventTimeline(e.events.length);
        for (r = z = 0; r < e.events.length; r++) {
          k = e.events[r];
          g = c.findEvent(k.name);
          if (null == g) {
            throw Error("Event not found: " + k.name);
          }
          q = new a.Event(a.Utils.toSinglePrecision(this.getValue(k, "time", 0)), g);
          q.intValue = this.getValue(k, "int", g.intValue);
          q.floatValue = this.getValue(k, "float", g.floatValue);
          q.stringValue = this.getValue(k, "string", g.stringValue);
          null != q.data.audioPath && (q.volume = this.getValue(k, "volume", 1), q.balance = this.getValue(k, "balance", 0));
          x.setFrame(z++, q);
        }
        h.push(x);
        f = Math.max(f, x.frames[x.getFrameCount() - 1]);
      }
      if (isNaN(f)) {
        throw Error("Error while parsing animation, duration is NaN");
      }
      c.animations.push(new a.Animation(d, h, f));
    };
    d.prototype.readCurve = function(a, d, c) {
      a.hasOwnProperty("curve") && ("stepped" == a.curve ? d.setStepped(c) : d.setCurve(c, a.curve, this.getValue(a, "c2", 0), this.getValue(a, "c3", 1), this.getValue(a, "c4", 1)));
    };
    d.prototype.getValue = function(a, d, c) {
      return void 0 !== a[d] ? a[d] : c;
    };
    d.blendModeFromString = function(e) {
      e = e.toLowerCase();
      if ("normal" == e) {
        return a.BlendMode.Normal;
      }
      if ("additive" == e) {
        return a.BlendMode.Additive;
      }
      if ("multiply" == e) {
        return a.BlendMode.Multiply;
      }
      if ("screen" == e) {
        return a.BlendMode.Screen;
      }
      throw Error("Unknown blend mode: " + e);
    };
    d.positionModeFromString = function(e) {
      e = e.toLowerCase();
      if ("fixed" == e) {
        return a.PositionMode.Fixed;
      }
      if ("percent" == e) {
        return a.PositionMode.Percent;
      }
      throw Error("Unknown position mode: " + e);
    };
    d.spacingModeFromString = function(e) {
      e = e.toLowerCase();
      if ("length" == e) {
        return a.SpacingMode.Length;
      }
      if ("fixed" == e) {
        return a.SpacingMode.Fixed;
      }
      if ("percent" == e) {
        return a.SpacingMode.Percent;
      }
      throw Error("Unknown position mode: " + e);
    };
    d.rotateModeFromString = function(e) {
      e = e.toLowerCase();
      if ("tangent" == e) {
        return a.RotateMode.Tangent;
      }
      if ("chain" == e) {
        return a.RotateMode.Chain;
      }
      if ("chainscale" == e) {
        return a.RotateMode.ChainScale;
      }
      throw Error("Unknown rotate mode: " + e);
    };
    d.transformModeFromString = function(e) {
      e = e.toLowerCase();
      if ("normal" == e) {
        return a.TransformMode.Normal;
      }
      if ("onlytranslation" == e) {
        return a.TransformMode.OnlyTranslation;
      }
      if ("norotationorreflection" == e) {
        return a.TransformMode.NoRotationOrReflection;
      }
      if ("noscale" == e) {
        return a.TransformMode.NoScale;
      }
      if ("noscaleorreflection" == e) {
        return a.TransformMode.NoScaleOrReflection;
      }
      throw Error("Unknown transform mode: " + e);
    };
    return d;
  }();
  a.SkeletonJson = d;
  var g = function() {
    return function(a, e, d, c, g) {
      this.mesh = a;
      this.skin = e;
      this.slotIndex = d;
      this.parent = c;
      this.inheritDeform = g;
    };
  }();
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    return function(a, e, d) {
      this.slotIndex = a;
      this.name = e;
      this.attachment = d;
    };
  }();
  a.SkinEntry = d;
  var g = function() {
    function h(a) {
      this.attachments = [];
      this.bones = [];
      this.constraints = [];
      if (null == a) {
        throw Error("name cannot be null.");
      }
      this.name = a;
    }
    h.prototype.setAttachment = function(a, d, c) {
      if (null == c) {
        throw Error("attachment cannot be null.");
      }
      var e = this.attachments;
      a >= e.length && (e.length = a + 1);
      e[a] || (e[a] = {});
      e[a][d] = c;
    };
    h.prototype.addSkin = function(a) {
      for (var e = 0; e < a.bones.length; e++) {
        for (var c = a.bones[e], d = !1, h = 0; h < this.bones.length; h++) {
          if (this.bones[h] == c) {
            d = !0;
            break;
          }
        }
        d || this.bones.push(c);
      }
      for (e = 0; e < a.constraints.length; e++) {
        c = a.constraints[e];
        d = !1;
        for (h = 0; h < this.constraints.length; h++) {
          if (this.constraints[h] == c) {
            d = !0;
            break;
          }
        }
        d || this.constraints.push(c);
      }
      a = a.getAttachments();
      for (e = 0; e < a.length; e++) {
        d = a[e], this.setAttachment(d.slotIndex, d.name, d.attachment);
      }
    };
    h.prototype.copySkin = function(e) {
      for (var d = 0; d < e.bones.length; d++) {
        for (var c = e.bones[d], h = !1, g = 0; g < this.bones.length; g++) {
          if (this.bones[g] == c) {
            h = !0;
            break;
          }
        }
        h || this.bones.push(c);
      }
      for (d = 0; d < e.constraints.length; d++) {
        c = e.constraints[d];
        h = !1;
        for (g = 0; g < this.constraints.length; g++) {
          if (this.constraints[g] == c) {
            h = !0;
            break;
          }
        }
        h || this.constraints.push(c);
      }
      e = e.getAttachments();
      for (d = 0; d < e.length; d++) {
        h = e[d], null != h.attachment && (h.attachment = h.attachment instanceof a.MeshAttachment ? h.attachment.newLinkedMesh() : h.attachment.copy(), this.setAttachment(h.slotIndex, h.name, h.attachment));
      }
    };
    h.prototype.getAttachment = function(a, d) {
      return (a = this.attachments[a]) ? a[d] : null;
    };
    h.prototype.removeAttachment = function(a, d) {
      (a = this.attachments[a]) && (a[d] = null);
    };
    h.prototype.getAttachments = function() {
      for (var a = [], k = 0; k < this.attachments.length; k++) {
        var c = this.attachments[k];
        if (c) {
          for (var h in c) {
            var g = c[h];
            g && a.push(new d(k, h, g));
          }
        }
      }
      return a;
    };
    h.prototype.getAttachmentsForSlot = function(a, k) {
      var c = this.attachments[a];
      if (c) {
        for (var e in c) {
          var h = c[e];
          h && k.push(new d(a, e, h));
        }
      }
    };
    h.prototype.clear = function() {
      this.attachments.length = 0;
      this.bones.length = 0;
      this.constraints.length = 0;
    };
    h.prototype.attachAll = function(a, d) {
      for (var c = 0, e = 0; e < a.slots.length; e++) {
        var k = a.slots[e], f = k.getAttachment();
        if (f && c < d.attachments.length) {
          var h = d.attachments[c], b;
          for (b in h) {
            if (f == h[b]) {
              f = this.getAttachment(c, b);
              null != f && k.setAttachment(f);
              break;
            }
          }
        }
        c++;
      }
    };
    return h;
  }();
  a.Skin = g;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d(d, e) {
      this.deform = [];
      if (null == d) {
        throw Error("data cannot be null.");
      }
      if (null == e) {
        throw Error("bone cannot be null.");
      }
      this.data = d;
      this.bone = e;
      this.color = new a.Color;
      this.darkColor = null == d.darkColor ? null : new a.Color;
      this.setToSetupPose();
    }
    d.prototype.getSkeleton = function() {
      return this.bone.skeleton;
    };
    d.prototype.getAttachment = function() {
      return this.attachment;
    };
    d.prototype.setAttachment = function(a) {
      this.attachment != a && (this.attachment = a, this.attachmentTime = this.bone.skeleton.time, this.deform.length = 0);
    };
    d.prototype.setAttachmentTime = function(a) {
      this.attachmentTime = this.bone.skeleton.time - a;
    };
    d.prototype.getAttachmentTime = function() {
      return this.bone.skeleton.time - this.attachmentTime;
    };
    d.prototype.setToSetupPose = function() {
      this.color.setFromColor(this.data.color);
      null != this.darkColor && this.darkColor.setFromColor(this.data.darkColor);
      null == this.data.attachmentName ? this.attachment = null : (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)));
    };
    return d;
  }();
  a.Slot = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    return function(d, h, e) {
      this.color = new a.Color(1, 1, 1, 1);
      if (0 > d) {
        throw Error("index must be >= 0.");
      }
      if (null == h) {
        throw Error("name cannot be null.");
      }
      if (null == e) {
        throw Error("boneData cannot be null.");
      }
      this.index = d;
      this.name = h;
      this.boneData = e;
    };
  }();
  a.SlotData = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function a(a) {
      this._image = a;
    }
    a.prototype.getImage = function() {
      return this._image;
    };
    a.filterFromString = function(a) {
      switch(a.toLowerCase()) {
        case "nearest":
          return g.Nearest;
        case "linear":
          return g.Linear;
        case "mipmap":
          return g.MipMap;
        case "mipmapnearestnearest":
          return g.MipMapNearestNearest;
        case "mipmaplinearnearest":
          return g.MipMapLinearNearest;
        case "mipmapnearestlinear":
          return g.MipMapNearestLinear;
        case "mipmaplinearlinear":
          return g.MipMapLinearLinear;
        default:
          throw Error("Unknown texture filter " + a);
      }
    };
    a.wrapFromString = function(a) {
      switch(a.toLowerCase()) {
        case "mirroredtepeat":
          return h.MirroredRepeat;
        case "clamptoedge":
          return h.ClampToEdge;
        case "repeat":
          return h.Repeat;
        default:
          throw Error("Unknown texture wrap " + a);
      }
    };
    return a;
  }();
  a.Texture = d;
  var g;
  (function(a) {
    a[a.Nearest = 9728] = "Nearest";
    a[a.Linear = 9729] = "Linear";
    a[a.MipMap = 9987] = "MipMap";
    a[a.MipMapNearestNearest = 9984] = "MipMapNearestNearest";
    a[a.MipMapLinearNearest = 9985] = "MipMapLinearNearest";
    a[a.MipMapNearestLinear = 9986] = "MipMapNearestLinear";
    a[a.MipMapLinearLinear = 9987] = "MipMapLinearLinear";
  })(g = a.TextureFilter || (a.TextureFilter = {}));
  var h;
  (function(a) {
    a[a.MirroredRepeat = 33648] = "MirroredRepeat";
    a[a.ClampToEdge = 33071] = "ClampToEdge";
    a[a.Repeat = 10497] = "Repeat";
  })(h = a.TextureWrap || (a.TextureWrap = {}));
  var e = function() {
    return function() {
      this.height = this.width = this.v2 = this.u2 = this.v = this.u = 0;
      this.rotate = !1;
      this.originalHeight = this.originalWidth = this.offsetY = this.offsetX = 0;
    };
  }();
  a.TextureRegion = e;
  d = function(a) {
    function c() {
      return null !== a && a.apply(this, arguments) || this;
    }
    __extends(c, a);
    c.prototype.setFilters = function(a, c) {
    };
    c.prototype.setWraps = function(a, c) {
    };
    c.prototype.dispose = function() {
    };
    return c;
  }(d);
  a.FakeTexture = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d(a, e) {
      this.pages = [];
      this.regions = [];
      this.load(a, e);
    }
    d.prototype.load = function(c, d) {
      if (null == d) {
        throw Error("textureLoader cannot be null.");
      }
      c = new g(c);
      for (var k = Array(4), f = null;;) {
        var n = c.readLine();
        if (null == n) {
          break;
        }
        n = n.trim();
        if (0 == n.length) {
          f = null;
        } else {
          if (f) {
            var b = new e;
            b.name = n;
            b.page = f;
            n = c.readValue();
            "true" == n.toLocaleLowerCase() ? b.degrees = 90 : "false" == n.toLocaleLowerCase() ? b.degrees = 0 : b.degrees = parseFloat(n);
            b.rotate = 90 == b.degrees;
            c.readTuple(k);
            n = parseInt(k[0]);
            var m = parseInt(k[1]);
            c.readTuple(k);
            var p = parseInt(k[0]), y = parseInt(k[1]);
            b.u = n / f.width;
            b.v = m / f.height;
            b.rotate ? (b.u2 = (n + y) / f.width, b.v2 = (m + p) / f.height) : (b.u2 = (n + p) / f.width, b.v2 = (m + y) / f.height);
            b.x = n;
            b.y = m;
            b.width = Math.abs(p);
            b.height = Math.abs(y);
            4 == c.readTuple(k) && 4 == c.readTuple(k) && c.readTuple(k);
            b.originalWidth = parseInt(k[0]);
            b.originalHeight = parseInt(k[1]);
            c.readTuple(k);
            b.offsetX = parseInt(k[0]);
            b.offsetY = parseInt(k[1]);
            b.index = parseInt(c.readValue());
            b.texture = f.texture;
            this.regions.push(b);
          } else {
            f = new h, f.name = n, 2 == c.readTuple(k) && (f.width = parseInt(k[0]), f.height = parseInt(k[1]), c.readTuple(k)), c.readTuple(k), f.minFilter = a.Texture.filterFromString(k[0]), f.magFilter = a.Texture.filterFromString(k[1]), b = c.readValue(), f.uWrap = a.TextureWrap.ClampToEdge, f.vWrap = a.TextureWrap.ClampToEdge, "x" == b ? f.uWrap = a.TextureWrap.Repeat : "y" == b ? f.vWrap = a.TextureWrap.Repeat : "xy" == b && (f.uWrap = f.vWrap = a.TextureWrap.Repeat), f.texture = d(n), f.texture.setFilters(f.minFilter, 
            f.magFilter), f.texture.setWraps(f.uWrap, f.vWrap), f.width = f.texture.getImage().width, f.height = f.texture.getImage().height, this.pages.push(f);
          }
        }
      }
    };
    d.prototype.findRegion = function(a) {
      for (var c = 0; c < this.regions.length; c++) {
        if (this.regions[c].name == a) {
          return this.regions[c];
        }
      }
      return null;
    };
    d.prototype.dispose = function() {
      for (var a = 0; a < this.pages.length; a++) {
        this.pages[a].texture.dispose();
      }
    };
    return d;
  }();
  a.TextureAtlas = d;
  var g = function() {
    function a(a) {
      this.index = 0;
      this.lines = a.split(/\r\n|\r|\n/);
    }
    a.prototype.readLine = function() {
      return this.index >= this.lines.length ? null : this.lines[this.index++];
    };
    a.prototype.readValue = function() {
      var a = this.readLine(), e = a.indexOf(":");
      if (-1 == e) {
        throw Error("Invalid line: " + a);
      }
      return a.substring(e + 1).trim();
    };
    a.prototype.readTuple = function(a) {
      var c = this.readLine(), e = c.indexOf(":");
      if (-1 == e) {
        throw Error("Invalid line: " + c);
      }
      var d = 0;
      for (e += 1; 3 > d; d++) {
        var k = c.indexOf(",", e);
        if (-1 == k) {
          break;
        }
        a[d] = c.substr(e, k - e).trim();
        e = k + 1;
      }
      a[d] = c.substring(e).trim();
      return d + 1;
    };
    return a;
  }(), h = function() {
    return function() {
    };
  }();
  a.TextureAtlasPage = h;
  var e = function(a) {
    function c() {
      return null !== a && a.apply(this, arguments) || this;
    }
    __extends(c, a);
    return c;
  }(a.TextureRegion);
  a.TextureAtlasRegion = e;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d(d, e) {
      this.shearMix = this.scaleMix = this.translateMix = this.rotateMix = 0;
      this.temp = new a.Vector2;
      this.active = !1;
      if (null == d) {
        throw Error("data cannot be null.");
      }
      if (null == e) {
        throw Error("skeleton cannot be null.");
      }
      this.data = d;
      this.rotateMix = d.rotateMix;
      this.translateMix = d.translateMix;
      this.scaleMix = d.scaleMix;
      this.shearMix = d.shearMix;
      this.bones = [];
      for (var k = 0; k < d.bones.length; k++) {
        this.bones.push(e.findBone(d.bones[k].name));
      }
      this.target = e.findBone(d.target.name);
    }
    d.prototype.isActive = function() {
      return this.active;
    };
    d.prototype.apply = function() {
      this.update();
    };
    d.prototype.update = function() {
      this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld();
    };
    d.prototype.applyAbsoluteWorld = function() {
      var d = this.rotateMix, e = this.translateMix, k = this.scaleMix, c = this.shearMix, g = this.target, t = g.a, f = g.b, n = g.c, b = g.d, m = 0 < t * b - f * n ? a.MathUtils.degRad : -a.MathUtils.degRad, q = this.data.offsetRotation * m;
      m *= this.data.offsetShearY;
      for (var y = this.bones, x = 0, z = y.length; x < z; x++) {
        var r = y[x], u = !1;
        if (0 != d) {
          var v = r.a;
          u = r.b;
          var C = r.c, A = r.d, D = Math.atan2(n, t) - Math.atan2(C, v) + q;
          D > a.MathUtils.PI ? D -= a.MathUtils.PI2 : D < -a.MathUtils.PI && (D += a.MathUtils.PI2);
          D *= d;
          var F = Math.cos(D);
          D = Math.sin(D);
          r.a = F * v - D * C;
          r.b = F * u - D * A;
          r.c = D * v + F * C;
          r.d = D * u + F * A;
          u = !0;
        }
        0 != e && (u = this.temp, g.localToWorld(u.set(this.data.offsetX, this.data.offsetY)), r.worldX += (u.x - r.worldX) * e, r.worldY += (u.y - r.worldY) * e, u = !0);
        0 < k && (u = Math.sqrt(r.a * r.a + r.c * r.c), A = Math.sqrt(t * t + n * n), 1E-5 < u && (u = (u + (A - u + this.data.offsetScaleX) * k) / u), r.a *= u, r.c *= u, u = Math.sqrt(r.b * r.b + r.d * r.d), A = Math.sqrt(f * f + b * b), 1E-5 < u && (u = (u + (A - u + this.data.offsetScaleY) * k) / u), r.b *= u, r.d *= u, u = !0);
        0 < c && (u = r.b, A = r.d, v = Math.atan2(A, u), D = Math.atan2(b, f) - Math.atan2(n, t) - (v - Math.atan2(r.c, r.a)), D > a.MathUtils.PI ? D -= a.MathUtils.PI2 : D < -a.MathUtils.PI && (D += a.MathUtils.PI2), D = v + (D + m) * c, u = Math.sqrt(u * u + A * A), r.b = Math.cos(D) * u, r.d = Math.sin(D) * u, u = !0);
        u && (r.appliedValid = !1);
      }
    };
    d.prototype.applyRelativeWorld = function() {
      var d = this.rotateMix, e = this.translateMix, k = this.scaleMix, c = this.shearMix, g = this.target, t = g.a, f = g.b, n = g.c, b = g.d, m = 0 < t * b - f * n ? a.MathUtils.degRad : -a.MathUtils.degRad, q = this.data.offsetRotation * m;
      m *= this.data.offsetShearY;
      for (var y = this.bones, x = 0, z = y.length; x < z; x++) {
        var r = y[x], u = !1;
        if (0 != d) {
          u = r.a;
          var v = r.b, C = r.c, A = r.d, D = Math.atan2(n, t) + q;
          D > a.MathUtils.PI ? D -= a.MathUtils.PI2 : D < -a.MathUtils.PI && (D += a.MathUtils.PI2);
          D *= d;
          var F = Math.cos(D);
          D = Math.sin(D);
          r.a = F * u - D * C;
          r.b = F * v - D * A;
          r.c = D * u + F * C;
          r.d = D * v + F * A;
          u = !0;
        }
        0 != e && (u = this.temp, g.localToWorld(u.set(this.data.offsetX, this.data.offsetY)), r.worldX += u.x * e, r.worldY += u.y * e, u = !0);
        0 < k && (u = (Math.sqrt(t * t + n * n) - 1 + this.data.offsetScaleX) * k + 1, r.a *= u, r.c *= u, u = (Math.sqrt(f * f + b * b) - 1 + this.data.offsetScaleY) * k + 1, r.b *= u, r.d *= u, u = !0);
        0 < c && (D = Math.atan2(b, f) - Math.atan2(n, t), D > a.MathUtils.PI ? D -= a.MathUtils.PI2 : D < -a.MathUtils.PI && (D += a.MathUtils.PI2), v = r.b, A = r.d, D = Math.atan2(A, v) + (D - a.MathUtils.PI / 2 + m) * c, u = Math.sqrt(v * v + A * A), r.b = Math.cos(D) * u, r.d = Math.sin(D) * u, u = !0);
        u && (r.appliedValid = !1);
      }
    };
    d.prototype.applyAbsoluteLocal = function() {
      var a = this.rotateMix, e = this.translateMix, d = this.scaleMix, c = this.shearMix, g = this.target;
      g.appliedValid || g.updateAppliedTransform();
      for (var t = this.bones, f = 0, n = t.length; f < n; f++) {
        var b = t[f];
        b.appliedValid || b.updateAppliedTransform();
        var m = b.arotation;
        if (0 != a) {
          var q = g.arotation - m + this.data.offsetRotation;
          q -= 360 * (16384 - (16384.499999999996 - q / 360 | 0));
          m += q * a;
        }
        var y = b.ax, x = b.ay;
        0 != e && (y += (g.ax - y + this.data.offsetX) * e, x += (g.ay - x + this.data.offsetY) * e);
        var z = b.ascaleX, r = b.ascaleY;
        0 != d && (1E-5 < z && (z = (z + (g.ascaleX - z + this.data.offsetScaleX) * d) / z), 1E-5 < r && (r = (r + (g.ascaleY - r + this.data.offsetScaleY) * d) / r));
        var u = b.ashearY;
        0 != c && (q = g.ashearY - u + this.data.offsetShearY, q -= 360 * (16384 - (16384.499999999996 - q / 360 | 0)), b.shearY += q * c);
        b.updateWorldTransformWith(y, x, m, z, r, b.ashearX, u);
      }
    };
    d.prototype.applyRelativeLocal = function() {
      var a = this.rotateMix, e = this.translateMix, d = this.scaleMix, c = this.shearMix, g = this.target;
      g.appliedValid || g.updateAppliedTransform();
      for (var t = this.bones, f = 0, n = t.length; f < n; f++) {
        var b = t[f];
        b.appliedValid || b.updateAppliedTransform();
        var m = b.arotation;
        0 != a && (m += (g.arotation + this.data.offsetRotation) * a);
        var q = b.ax, y = b.ay;
        0 != e && (q += (g.ax + this.data.offsetX) * e, y += (g.ay + this.data.offsetY) * e);
        var x = b.ascaleX, z = b.ascaleY;
        0 != d && (1E-5 < x && (x *= (g.ascaleX - 1 + this.data.offsetScaleX) * d + 1), 1E-5 < z && (z *= (g.ascaleY - 1 + this.data.offsetScaleY) * d + 1));
        var r = b.ashearY;
        0 != c && (r += (g.ashearY + this.data.offsetShearY) * c);
        b.updateWorldTransformWith(q, y, m, x, z, b.ashearX, r);
      }
    };
    return d;
  }();
  a.TransformConstraint = d;
})(spine || (spine = {}));
(function(a) {
  var d = function(a) {
    function d(e) {
      e = a.call(this, e, 0, !1) || this;
      e.bones = [];
      e.rotateMix = 0;
      e.translateMix = 0;
      e.scaleMix = 0;
      e.shearMix = 0;
      e.offsetRotation = 0;
      e.offsetX = 0;
      e.offsetY = 0;
      e.offsetScaleX = 0;
      e.offsetScaleY = 0;
      e.offsetShearY = 0;
      e.relative = !1;
      e.local = !1;
      return e;
    }
    __extends(d, a);
    return d;
  }(a.ConstraintData);
  a.TransformConstraintData = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d() {
      this.convexPolygons = [];
      this.convexPolygonsIndices = [];
      this.indicesArray = [];
      this.isConcaveArray = [];
      this.triangles = [];
      this.polygonPool = new a.Pool(function() {
        return [];
      });
      this.polygonIndicesPool = new a.Pool(function() {
        return [];
      });
    }
    d.prototype.triangulate = function(a) {
      for (var e = a.length >> 1, k = this.indicesArray, c = k.length = 0; c < e; c++) {
        k[c] = c;
      }
      var h = this.isConcaveArray;
      c = h.length = 0;
      for (var g = e; c < g; ++c) {
        h[c] = d.isConcave(c, e, a, k);
      }
      g = this.triangles;
      for (g.length = 0; 3 < e;) {
        var f = e - 1;
        c = 0;
        for (var n = 1;;) {
          a: {
            if (!h[c]) {
              var b = k[f] << 1, m = k[c] << 1, q = k[n] << 1, y = a[b];
              b = a[b + 1];
              var x = a[m];
              m = a[m + 1];
              var z = a[q];
              q = a[q + 1];
              for (var r = (n + 1) % e; r != f; r = (r + 1) % e) {
                if (h[r]) {
                  var u = k[r] << 1, v = a[u];
                  u = a[u + 1];
                  if (d.positiveArea(z, q, y, b, v, u) && d.positiveArea(y, b, x, m, v, u) && d.positiveArea(x, m, z, q, v, u)) {
                    break a;
                  }
                }
              }
              break;
            }
          }
          if (0 == n) {
            do {
              if (!h[c]) {
                break;
              }
              c--;
            } while (0 < c);
            break;
          }
          f = c;
          c = n;
          n = (n + 1) % e;
        }
        g.push(k[(e + c - 1) % e]);
        g.push(k[c]);
        g.push(k[(c + 1) % e]);
        k.splice(c, 1);
        h.splice(c, 1);
        e--;
        f = (e + c - 1) % e;
        c = c == e ? 0 : c;
        h[f] = d.isConcave(f, e, a, k);
        h[c] = d.isConcave(c, e, a, k);
      }
      3 == e && (g.push(k[2]), g.push(k[0]), g.push(k[1]));
      return g;
    };
    d.prototype.decompose = function(a, e) {
      var k = this.convexPolygons;
      this.polygonPool.freeAll(k);
      k.length = 0;
      var c = this.convexPolygonsIndices;
      this.polygonIndicesPool.freeAll(c);
      c.length = 0;
      var g = this.polygonIndicesPool.obtain();
      g.length = 0;
      var h = this.polygonPool.obtain();
      h.length = 0;
      for (var f = -1, n = 0, b = 0, m = e.length; b < m; b += 3) {
        var q = e[b] << 1, y = e[b + 1] << 1, x = e[b + 2] << 1, z = a[q], r = a[q + 1], u = a[y], v = a[y + 1], C = a[x], A = a[x + 1], D = !1;
        if (f == q) {
          var F = h.length - 4;
          F = d.winding(h[F], h[F + 1], h[F + 2], h[F + 3], C, A);
          var B = d.winding(C, A, h[0], h[1], h[2], h[3]);
          F == n && B == n && (h.push(C), h.push(A), g.push(x), D = !0);
        }
        D || (0 < h.length ? (k.push(h), c.push(g)) : (this.polygonPool.free(h), this.polygonIndicesPool.free(g)), h = this.polygonPool.obtain(), h.length = 0, h.push(z), h.push(r), h.push(u), h.push(v), h.push(C), h.push(A), g = this.polygonIndicesPool.obtain(), g.length = 0, g.push(q), g.push(y), g.push(x), n = d.winding(z, r, u, v, C, A), f = q);
      }
      0 < h.length && (k.push(h), c.push(g));
      b = 0;
      for (m = k.length; b < m; b++) {
        if (g = c[b], 0 != g.length) {
          for (a = g[0], e = g[g.length - 1], h = k[b], F = h.length - 4, f = h[F], n = h[F + 1], q = h[F + 2], y = h[F + 3], x = h[0], z = h[1], r = h[2], u = h[3], v = d.winding(f, n, q, y, x, z), D = 0; D < m; D++) {
            if (D != b) {
              var E = c[D];
              if (3 == E.length) {
                F = E[0];
                B = E[1];
                var H = E[2], L = k[D];
                C = L[L.length - 2];
                A = L[L.length - 1];
                F == a && B == e && (F = d.winding(f, n, q, y, C, A), B = d.winding(C, A, x, z, r, u), F == v && B == v && (L.length = 0, E.length = 0, h.push(C), h.push(A), g.push(H), f = q, n = y, q = C, y = A, D = 0));
              }
            }
          }
        }
      }
      for (b = k.length - 1; 0 <= b; b--) {
        h = k[b], 0 == h.length && (k.splice(b, 1), this.polygonPool.free(h), g = c[b], c.splice(b, 1), this.polygonIndicesPool.free(g));
      }
      return k;
    };
    d.isConcave = function(a, e, d, c) {
      var k = c[(e + a - 1) % e] << 1, h = c[a] << 1;
      a = c[(a + 1) % e] << 1;
      return !this.positiveArea(d[k], d[k + 1], d[h], d[h + 1], d[a], d[a + 1]);
    };
    d.positiveArea = function(a, e, d, c, g, t) {
      return 0 <= a * (t - c) + d * (e - t) + g * (c - e);
    };
    d.winding = function(a, e, d, c, g, t) {
      d -= a;
      c -= e;
      return 0 <= g * c - t * d + d * e - a * c ? 1 : -1;
    };
    return d;
  }();
  a.Triangulator = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function a() {
      this.array = [];
    }
    a.prototype.add = function(a) {
      var e = this.contains(a);
      this.array[a | 0] = a | 0;
      return !e;
    };
    a.prototype.contains = function(a) {
      return void 0 != this.array[a | 0];
    };
    a.prototype.remove = function(a) {
      this.array[a | 0] = void 0;
    };
    a.prototype.clear = function() {
      this.array.length = 0;
    };
    return a;
  }();
  a.IntSet = d;
  d = function() {
    function a(a, e, d, c) {
      void 0 === a && (a = 0);
      void 0 === e && (e = 0);
      void 0 === d && (d = 0);
      void 0 === c && (c = 0);
      this.r = a;
      this.g = e;
      this.b = d;
      this.a = c;
    }
    a.prototype.set = function(a, e, d, c) {
      this.r = a;
      this.g = e;
      this.b = d;
      this.a = c;
      this.clamp();
      return this;
    };
    a.prototype.setFromColor = function(a) {
      this.r = a.r;
      this.g = a.g;
      this.b = a.b;
      this.a = a.a;
      return this;
    };
    a.prototype.setFromString = function(a) {
      a = "#" == a.charAt(0) ? a.substr(1) : a;
      this.r = parseInt(a.substr(0, 2), 16) / 255;
      this.g = parseInt(a.substr(2, 2), 16) / 255;
      this.b = parseInt(a.substr(4, 2), 16) / 255;
      this.a = (8 != a.length ? 255 : parseInt(a.substr(6, 2), 16)) / 255;
      return this;
    };
    a.prototype.add = function(a, e, d, c) {
      this.r += a;
      this.g += e;
      this.b += d;
      this.a += c;
      this.clamp();
      return this;
    };
    a.prototype.clamp = function() {
      0 > this.r ? this.r = 0 : 1 < this.r && (this.r = 1);
      0 > this.g ? this.g = 0 : 1 < this.g && (this.g = 1);
      0 > this.b ? this.b = 0 : 1 < this.b && (this.b = 1);
      0 > this.a ? this.a = 0 : 1 < this.a && (this.a = 1);
      return this;
    };
    a.rgba8888ToColor = function(a, e) {
      a.r = ((e & 4278190080) >>> 24) / 255;
      a.g = ((e & 16711680) >>> 16) / 255;
      a.b = ((e & 65280) >>> 8) / 255;
      a.a = (e & 255) / 255;
    };
    a.rgb888ToColor = function(a, e) {
      a.r = ((e & 16711680) >>> 16) / 255;
      a.g = ((e & 65280) >>> 8) / 255;
      a.b = (e & 255) / 255;
    };
    a.WHITE = new a(1, 1, 1, 1);
    a.RED = new a(1, 0, 0, 1);
    a.GREEN = new a(0, 1, 0, 1);
    a.BLUE = new a(0, 0, 1, 1);
    a.MAGENTA = new a(1, 0, 1, 1);
    return a;
  }();
  a.Color = d;
  d = function() {
    function a() {
    }
    a.clamp = function(a, e, d) {
      return a < e ? e : a > d ? d : a;
    };
    a.cosDeg = function(d) {
      return Math.cos(d * a.degRad);
    };
    a.sinDeg = function(d) {
      return Math.sin(d * a.degRad);
    };
    a.signum = function(a) {
      return 0 < a ? 1 : 0 > a ? -1 : 0;
    };
    a.toInt = function(a) {
      return 0 < a ? Math.floor(a) : Math.ceil(a);
    };
    a.cbrt = function(a) {
      var e = Math.pow(Math.abs(a), 1 / 3);
      return 0 > a ? -e : e;
    };
    a.randomTriangular = function(d, e) {
      return a.randomTriangularWith(d, e, .5 * (d + e));
    };
    a.randomTriangularWith = function(a, e, d) {
      var c = Math.random(), k = e - a;
      return c <= (d - a) / k ? a + Math.sqrt(c * k * (d - a)) : e - Math.sqrt((1 - c) * k * (e - d));
    };
    a.PI = 3.1415927;
    a.PI2 = 2 * a.PI;
    a.radiansToDegrees = 180 / a.PI;
    a.radDeg = a.radiansToDegrees;
    a.degreesToRadians = a.PI / 180;
    a.degRad = a.degreesToRadians;
    return a;
  }();
  a.MathUtils = d;
  d = function() {
    function a() {
    }
    a.prototype.apply = function(a, e, d) {
      return a + (e - a) * this.applyInternal(d);
    };
    return a;
  }();
  a.Interpolation = d;
  d = function(a) {
    function d(e) {
      var d = a.call(this) || this;
      d.power = 2;
      d.power = e;
      return d;
    }
    __extends(d, a);
    d.prototype.applyInternal = function(a) {
      return .5 >= a ? Math.pow(2 * a, this.power) / 2 : Math.pow(2 * (a - 1), this.power) / (0 == this.power % 2 ? -2 : 2) + 1;
    };
    return d;
  }(d);
  a.Pow = d;
  d = function(a) {
    function d(e) {
      return a.call(this, e) || this;
    }
    __extends(d, a);
    d.prototype.applyInternal = function(a) {
      return Math.pow(a - 1, this.power) * (0 == this.power % 2 ? -1 : 1) + 1;
    };
    return d;
  }(d);
  a.PowOut = d;
  d = function() {
    function a() {
    }
    a.arrayCopy = function(a, e, d, c, g) {
      for (var k = e; k < e + g; k++, c++) {
        d[c] = a[k];
      }
    };
    a.setArraySize = function(a, e, d) {
      void 0 === d && (d = 0);
      var c = a.length;
      if (c == e) {
        return a;
      }
      a.length = e;
      if (c < e) {
        for (; c < e; c++) {
          a[c] = d;
        }
      }
      return a;
    };
    a.ensureArrayCapacity = function(d, e, k) {
      void 0 === k && (k = 0);
      return d.length >= e ? d : a.setArraySize(d, e, k);
    };
    a.newArray = function(a, e) {
      for (var d = Array(a), c = 0; c < a; c++) {
        d[c] = e;
      }
      return d;
    };
    a.newFloatArray = function(d) {
      if (a.SUPPORTS_TYPED_ARRAYS) {
        return new Float32Array(d);
      }
      d = Array(d);
      for (var e = 0; e < d.length; e++) {
        d[e] = 0;
      }
      return d;
    };
    a.newShortArray = function(d) {
      if (a.SUPPORTS_TYPED_ARRAYS) {
        return new Int16Array(d);
      }
      d = Array(d);
      for (var e = 0; e < d.length; e++) {
        d[e] = 0;
      }
      return d;
    };
    a.toFloatArray = function(d) {
      return a.SUPPORTS_TYPED_ARRAYS ? new Float32Array(d) : d;
    };
    a.toSinglePrecision = function(d) {
      return a.SUPPORTS_TYPED_ARRAYS ? Math.fround(d) : d;
    };
    a.webkit602BugfixHelper = function(a, e) {
    };
    a.contains = function(a, e, d) {
      for (d = 0; d < a.length; d++) {
        if (a[d] == e) {
          return !0;
        }
      }
      return !1;
    };
    a.SUPPORTS_TYPED_ARRAYS = "undefined" !== typeof Float32Array;
    return a;
  }();
  a.Utils = d;
  d = function() {
    function a() {
    }
    a.logBones = function(a) {
      for (var e = 0; e < a.bones.length; e++) {
        var d = a.bones[e];
        console.log(d.data.name + ", " + d.a + ", " + d.b + ", " + d.c + ", " + d.d + ", " + d.worldX + ", " + d.worldY);
      }
    };
    return a;
  }();
  a.DebugUtils = d;
  d = function() {
    function a(a) {
      this.items = [];
      this.instantiator = a;
    }
    a.prototype.obtain = function() {
      return 0 < this.items.length ? this.items.pop() : this.instantiator();
    };
    a.prototype.free = function(a) {
      a.reset && a.reset();
      this.items.push(a);
    };
    a.prototype.freeAll = function(a) {
      for (var e = 0; e < a.length; e++) {
        a[e].reset && a[e].reset(), this.items[e] = a[e];
      }
    };
    a.prototype.clear = function() {
      this.items.length = 0;
    };
    return a;
  }();
  a.Pool = d;
  d = function() {
    function a(a, e) {
      void 0 === a && (a = 0);
      void 0 === e && (e = 0);
      this.x = a;
      this.y = e;
    }
    a.prototype.set = function(a, e) {
      this.x = a;
      this.y = e;
      return this;
    };
    a.prototype.length = function() {
      var a = this.x, e = this.y;
      return Math.sqrt(a * a + e * e);
    };
    a.prototype.normalize = function() {
      var a = this.length();
      0 != a && (this.x /= a, this.y /= a);
      return this;
    };
    return a;
  }();
  a.Vector2 = d;
  d = function() {
    function a() {
      this.maxDelta = .064;
      this.totalTime = this.delta = this.framesPerSecond = 0;
      this.lastTime = Date.now() / 1E3;
      this.frameTime = this.frameCount = 0;
    }
    a.prototype.update = function() {
      var a = Date.now() / 1E3;
      this.delta = a - this.lastTime;
      this.frameTime += this.delta;
      this.totalTime += this.delta;
      this.delta > this.maxDelta && (this.delta = this.maxDelta);
      this.lastTime = a;
      this.frameCount++;
      1 < this.frameTime && (this.framesPerSecond = this.frameCount / this.frameTime, this.frameCount = this.frameTime = 0);
    };
    return a;
  }();
  a.TimeKeeper = d;
  d = function() {
    function a(a) {
      void 0 === a && (a = 32);
      this.mean = this.lastValue = this.addedValues = 0;
      this.dirty = !0;
      this.values = Array(a);
    }
    a.prototype.hasEnoughData = function() {
      return this.addedValues >= this.values.length;
    };
    a.prototype.addValue = function(a) {
      this.addedValues < this.values.length && this.addedValues++;
      this.values[this.lastValue++] = a;
      this.lastValue > this.values.length - 1 && (this.lastValue = 0);
      this.dirty = !0;
    };
    a.prototype.getMean = function() {
      if (this.hasEnoughData()) {
        if (this.dirty) {
          for (var a = 0, e = 0; e < this.values.length; e++) {
            a += this.values[e];
          }
          this.mean = a / this.values.length;
          this.dirty = !1;
        }
        return this.mean;
      }
      return 0;
    };
    return a;
  }();
  a.WindowedMean = d;
})(spine || (spine = {}));
(function() {
  Math.fround || (Math.fround = function(a) {
    return function(d) {
      return a[0] = d, a[0];
    };
  }(new Float32Array(1)));
})();
(function(a) {
  var d = function() {
    return function(a) {
      if (null == a) {
        throw Error("name cannot be null.");
      }
      this.name = a;
    };
  }();
  a.Attachment = d;
  d = function(d) {
    function g(a) {
      a = d.call(this, a) || this;
      a.id = (g.nextID++ & 65535) << 11;
      a.worldVerticesLength = 0;
      return a.deformAttachment = a;
    }
    __extends(g, d);
    g.prototype.computeWorldVertices = function(a, d, c, g, h, f) {
      c = h + (c >> 1) * f;
      var e = a.bone.skeleton, b = a.deform, k = this.vertices, p = this.bones;
      if (null == p) {
        0 < b.length && (k = b);
        a = a.bone;
        b = a.worldX;
        p = a.worldY;
        var t = a.a;
        e = a.b;
        var x = a.c;
        a = a.d;
        for (var z = d; h < c; z += 2, h += f) {
          d = k[z];
          var r = k[z + 1];
          g[h] = d * t + r * e + b;
          g[h + 1] = d * x + r * a + p;
        }
      } else {
        for (r = a = t = 0; r < d; r += 2) {
          x = p[t], t += x + 1, a += x;
        }
        z = e.bones;
        if (0 == b.length) {
          for (e = 3 * a; h < c; h += f) {
            var u = 0, v = 0;
            x = p[t++];
            for (x += t; t < x; t++, e += 3) {
              a = z[p[t]];
              d = k[e];
              r = k[e + 1];
              var C = k[e + 2];
              u += (d * a.a + r * a.b + a.worldX) * C;
              v += (d * a.c + r * a.d + a.worldY) * C;
            }
            g[h] = u;
            g[h + 1] = v;
          }
        } else {
          e = 3 * a;
          for (var A = a << 1; h < c; h += f) {
            v = u = 0;
            x = p[t++];
            for (x += t; t < x; t++, e += 3, A += 2) {
              a = z[p[t]], d = k[e] + b[A], r = k[e + 1] + b[A + 1], C = k[e + 2], u += (d * a.a + r * a.b + a.worldX) * C, v += (d * a.c + r * a.d + a.worldY) * C;
            }
            g[h] = u;
            g[h + 1] = v;
          }
        }
      }
    };
    g.prototype.copyTo = function(e) {
      null != this.bones ? (e.bones = Array(this.bones.length), a.Utils.arrayCopy(this.bones, 0, e.bones, 0, this.bones.length)) : e.bones = null;
      null != this.vertices ? (e.vertices = a.Utils.newFloatArray(this.vertices.length), a.Utils.arrayCopy(this.vertices, 0, e.vertices, 0, this.vertices.length)) : e.vertices = null;
      e.worldVerticesLength = this.worldVerticesLength;
      e.deformAttachment = this.deformAttachment;
    };
    g.nextID = 0;
    return g;
  }(d);
  a.VertexAttachment = d;
})(spine || (spine = {}));
(function(a) {
  a = a.AttachmentType || (a.AttachmentType = {});
  a[a.Region = 0] = "Region";
  a[a.BoundingBox = 1] = "BoundingBox";
  a[a.Mesh = 2] = "Mesh";
  a[a.LinkedMesh = 3] = "LinkedMesh";
  a[a.Path = 4] = "Path";
  a[a.Point = 5] = "Point";
  a[a.Clipping = 6] = "Clipping";
})(spine || (spine = {}));
(function(a) {
  var d = function(d) {
    function g(e) {
      e = d.call(this, e) || this;
      e.color = new a.Color(1, 1, 1, 1);
      return e;
    }
    __extends(g, d);
    g.prototype.copy = function() {
      var a = new g(name);
      this.copyTo(a);
      a.color.setFromColor(this.color);
      return a;
    };
    return g;
  }(a.VertexAttachment);
  a.BoundingBoxAttachment = d;
})(spine || (spine = {}));
(function(a) {
  var d = function(d) {
    function g(e) {
      e = d.call(this, e) || this;
      e.color = new a.Color(.2275, .2275, .8078, 1);
      return e;
    }
    __extends(g, d);
    g.prototype.copy = function() {
      var a = new g(name);
      this.copyTo(a);
      a.endSlot = this.endSlot;
      a.color.setFromColor(this.color);
      return a;
    };
    return g;
  }(a.VertexAttachment);
  a.ClippingAttachment = d;
})(spine || (spine = {}));
(function(a) {
  var d = function(d) {
    function g(e) {
      e = d.call(this, e) || this;
      e.color = new a.Color(1, 1, 1, 1);
      e.tempColor = new a.Color(0, 0, 0, 0);
      return e;
    }
    __extends(g, d);
    g.prototype.updateUVs = function() {
      var e = this.regionUVs;
      if (null == this.uvs || this.uvs.length != e.length) {
        this.uvs = a.Utils.newFloatArray(e.length);
      }
      var d = this.uvs, c = this.uvs.length, g = this.region.u, h = this.region.v;
      if (this.region instanceof a.TextureAtlasRegion) {
        var f = this.region;
        var n = f.texture.getImage().width;
        var b = f.texture.getImage().height;
        switch(f.degrees) {
          case 90:
            g -= (f.originalHeight - f.offsetY - f.height) / n;
            h -= (f.originalWidth - f.offsetX - f.width) / b;
            n = f.originalHeight / n;
            f = f.originalWidth / b;
            for (b = 0; b < c; b += 2) {
              d[b] = g + e[b + 1] * n, d[b + 1] = h + (1 - e[b]) * f;
            }
            return;
          case 180:
            g -= (f.originalWidth - f.offsetX - f.width) / n;
            h -= f.offsetY / b;
            n = f.originalWidth / n;
            f = f.originalHeight / b;
            for (b = 0; b < c; b += 2) {
              d[b] = g + (1 - e[b]) * n, d[b + 1] = h + (1 - e[b + 1]) * f;
            }
            return;
          case 270:
            g -= f.offsetY / n;
            h -= f.offsetX / b;
            n = f.originalHeight / n;
            f = f.originalWidth / b;
            for (b = 0; b < c; b += 2) {
              d[b] = g + (1 - e[b + 1]) * n, d[b + 1] = h + e[b] * f;
            }
            return;
        }
        g -= f.offsetX / n;
        h -= (f.originalHeight - f.offsetY - f.height) / b;
        n = f.originalWidth / n;
        f = f.originalHeight / b;
      } else {
        null == this.region ? (g = h = 0, n = f = 1) : (n = this.region.u2 - g, f = this.region.v2 - h);
      }
      for (b = 0; b < c; b += 2) {
        d[b] = g + e[b] * n, d[b + 1] = h + e[b + 1] * f;
      }
    };
    g.prototype.getParentMesh = function() {
      return this.parentMesh;
    };
    g.prototype.setParentMesh = function(a) {
      this.parentMesh = a;
      null != a && (this.bones = a.bones, this.vertices = a.vertices, this.worldVerticesLength = a.worldVerticesLength, this.regionUVs = a.regionUVs, this.triangles = a.triangles, this.hullLength = a.hullLength, this.worldVerticesLength = a.worldVerticesLength);
    };
    g.prototype.copy = function() {
      if (null != this.parentMesh) {
        return this.newLinkedMesh();
      }
      var e = new g(this.name);
      e.region = this.region;
      e.path = this.path;
      e.color.setFromColor(this.color);
      this.copyTo(e);
      e.regionUVs = Array(this.regionUVs.length);
      a.Utils.arrayCopy(this.regionUVs, 0, e.regionUVs, 0, this.regionUVs.length);
      e.uvs = Array(this.uvs.length);
      a.Utils.arrayCopy(this.uvs, 0, e.uvs, 0, this.uvs.length);
      e.triangles = Array(this.triangles.length);
      a.Utils.arrayCopy(this.triangles, 0, e.triangles, 0, this.triangles.length);
      e.hullLength = this.hullLength;
      null != this.edges && (e.edges = Array(this.edges.length), a.Utils.arrayCopy(this.edges, 0, e.edges, 0, this.edges.length));
      e.width = this.width;
      e.height = this.height;
      return e;
    };
    g.prototype.newLinkedMesh = function() {
      var a = new g(this.name);
      a.region = this.region;
      a.path = this.path;
      a.color.setFromColor(this.color);
      a.deformAttachment = this.deformAttachment;
      a.setParentMesh(null != this.parentMesh ? this.parentMesh : this);
      a.updateUVs();
      return a;
    };
    return g;
  }(a.VertexAttachment);
  a.MeshAttachment = d;
})(spine || (spine = {}));
(function(a) {
  var d = function(d) {
    function g(e) {
      e = d.call(this, e) || this;
      e.closed = !1;
      e.constantSpeed = !1;
      e.color = new a.Color(1, 1, 1, 1);
      return e;
    }
    __extends(g, d);
    g.prototype.copy = function() {
      var e = new g(name);
      this.copyTo(e);
      e.lengths = Array(this.lengths.length);
      a.Utils.arrayCopy(this.lengths, 0, e.lengths, 0, this.lengths.length);
      e.closed = closed;
      e.constantSpeed = this.constantSpeed;
      e.color.setFromColor(this.color);
      return e;
    };
    return g;
  }(a.VertexAttachment);
  a.PathAttachment = d;
})(spine || (spine = {}));
(function(a) {
  var d = function(d) {
    function g(e) {
      e = d.call(this, e) || this;
      e.color = new a.Color(.38, .94, 0, 1);
      return e;
    }
    __extends(g, d);
    g.prototype.computeWorldPosition = function(a, d) {
      d.x = this.x * a.a + this.y * a.b + a.worldX;
      d.y = this.x * a.c + this.y * a.d + a.worldY;
      return d;
    };
    g.prototype.computeWorldRotation = function(e) {
      var d = a.MathUtils.cosDeg(this.rotation), c = a.MathUtils.sinDeg(this.rotation);
      return Math.atan2(d * e.c + c * e.d, d * e.a + c * e.b) * a.MathUtils.radDeg;
    };
    g.prototype.copy = function() {
      var a = new g(name);
      a.x = this.x;
      a.y = this.y;
      a.rotation = this.rotation;
      a.color.setFromColor(this.color);
      return a;
    };
    return g;
  }(a.VertexAttachment);
  a.PointAttachment = d;
})(spine || (spine = {}));
(function(a) {
  var d = function(d) {
    function g(e) {
      e = d.call(this, e) || this;
      e.x = 0;
      e.y = 0;
      e.scaleX = 1;
      e.scaleY = 1;
      e.rotation = 0;
      e.width = 0;
      e.height = 0;
      e.color = new a.Color(1, 1, 1, 1);
      e.offset = a.Utils.newFloatArray(8);
      e.uvs = a.Utils.newFloatArray(8);
      e.tempColor = new a.Color(1, 1, 1, 1);
      return e;
    }
    __extends(g, d);
    g.prototype.updateOffset = function() {
      var a = this.width / this.region.originalWidth * this.scaleX, d = this.height / this.region.originalHeight * this.scaleY, c = -this.width / 2 * this.scaleX + this.region.offsetX * a, h = -this.height / 2 * this.scaleY + this.region.offsetY * d, t = c + this.region.width * a;
      a = h + this.region.height * d;
      d = this.rotation * Math.PI / 180;
      var f = Math.cos(d), n = Math.sin(d);
      d = c * f + this.x;
      c *= n;
      var b = h * f + this.y;
      h *= n;
      var m = t * f + this.x;
      t *= n;
      f = a * f + this.y;
      a *= n;
      n = this.offset;
      n[g.OX1] = d - h;
      n[g.OY1] = b + c;
      n[g.OX2] = d - a;
      n[g.OY2] = f + c;
      n[g.OX3] = m - a;
      n[g.OY3] = f + t;
      n[g.OX4] = m - h;
      n[g.OY4] = b + t;
    };
    g.prototype.setRegion = function(a) {
      this.region = a;
      var d = this.uvs;
      a.rotate ? (d[2] = a.u, d[3] = a.v2, d[4] = a.u, d[5] = a.v, d[6] = a.u2, d[7] = a.v, d[0] = a.u2, d[1] = a.v2) : (d[0] = a.u, d[1] = a.v2, d[2] = a.u, d[3] = a.v, d[4] = a.u2, d[5] = a.v, d[6] = a.u2, d[7] = a.v2);
    };
    g.prototype.computeWorldVertices = function(a, d, c, h) {
      var e = this.offset, f = a.worldX, k = a.worldY, b = a.a, m = a.b, p = a.c;
      a = a.d;
      var y = e[g.OX1];
      var x = e[g.OY1];
      d[c] = y * b + x * m + f;
      d[c + 1] = y * p + x * a + k;
      c += h;
      y = e[g.OX2];
      x = e[g.OY2];
      d[c] = y * b + x * m + f;
      d[c + 1] = y * p + x * a + k;
      c += h;
      y = e[g.OX3];
      x = e[g.OY3];
      d[c] = y * b + x * m + f;
      d[c + 1] = y * p + x * a + k;
      c += h;
      y = e[g.OX4];
      x = e[g.OY4];
      d[c] = y * b + x * m + f;
      d[c + 1] = y * p + x * a + k;
    };
    g.prototype.copy = function() {
      var d = new g(name);
      d.region = this.region;
      d.rendererObject = this.rendererObject;
      d.path = this.path;
      d.x = this.x;
      d.y = this.y;
      d.scaleX = this.scaleX;
      d.scaleY = this.scaleY;
      d.rotation = this.rotation;
      d.width = this.width;
      d.height = this.height;
      a.Utils.arrayCopy(this.uvs, 0, d.uvs, 0, 8);
      a.Utils.arrayCopy(this.offset, 0, d.offset, 0, 8);
      d.color.setFromColor(this.color);
      return d;
    };
    g.OX1 = 0;
    g.OY1 = 1;
    g.OX2 = 2;
    g.OY2 = 3;
    g.OX3 = 4;
    g.OY3 = 5;
    g.OX4 = 6;
    g.OY4 = 7;
    g.X1 = 0;
    g.Y1 = 1;
    g.C1R = 2;
    g.C1G = 3;
    g.C1B = 4;
    g.C1A = 5;
    g.U1 = 6;
    g.V1 = 7;
    g.X2 = 8;
    g.Y2 = 9;
    g.C2R = 10;
    g.C2G = 11;
    g.C2B = 12;
    g.C2A = 13;
    g.U2 = 14;
    g.V2 = 15;
    g.X3 = 16;
    g.Y3 = 17;
    g.C3R = 18;
    g.C3G = 19;
    g.C3B = 20;
    g.C3A = 21;
    g.U3 = 22;
    g.V3 = 23;
    g.X4 = 24;
    g.Y4 = 25;
    g.C4R = 26;
    g.C4G = 27;
    g.C4B = 28;
    g.C4A = 29;
    g.U4 = 30;
    g.V4 = 31;
    return g;
  }(a.Attachment);
  a.RegionAttachment = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d(a, d) {
      this.jitterY = this.jitterX = 0;
      this.jitterX = a;
      this.jitterY = d;
    }
    d.prototype.begin = function(a) {
    };
    d.prototype.transform = function(d, e, k, c) {
      d.x += a.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
      d.y += a.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
    };
    d.prototype.end = function() {
    };
    return d;
  }();
  a.JitterEffect = d;
})(spine || (spine = {}));
(function(a) {
  var d = function() {
    function d(a) {
      this.worldY = this.worldX = this.angle = this.radius = this.centerY = this.centerX = 0;
      this.radius = a;
    }
    d.prototype.begin = function(a) {
      this.worldX = a.x + this.centerX;
      this.worldY = a.y + this.centerY;
    };
    d.prototype.transform = function(g, e, k, c) {
      c = this.angle * a.MathUtils.degreesToRadians;
      e = g.x - this.worldX;
      k = g.y - this.worldY;
      var h = Math.sqrt(e * e + k * k);
      h < this.radius && (h = d.interpolation.apply(0, c, (this.radius - h) / this.radius), c = Math.cos(h), h = Math.sin(h), g.x = c * e - h * k + this.worldX, g.y = h * e + c * k + this.worldY);
    };
    d.prototype.end = function() {
    };
    d.interpolation = new a.PowOut(2);
    return d;
  }();
  a.SwirlEffect = d;
})(spine || (spine = {}));
(function(a) {
  (function(d) {
    var g = function(a) {
      function e(e) {
        void 0 === e && (e = "");
        return a.call(this, function(a) {
          return new d.ThreeJsTexture(a);
        }, e) || this;
      }
      __extends(e, a);
      return e;
    }(a.AssetManager);
    d.AssetManager = g;
  })(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
  (function(a) {
    var d = function(d) {
      function e(k, c) {
        void 0 === k && (k = 10920);
        void 0 === c && (c = function(a) {
        });
        var g = d.call(this) || this;
        g.verticesLength = 0;
        g.indicesLength = 0;
        if (10920 < k) {
          throw Error("Can't have more than 10920 triangles per batch: " + k);
        }
        var h = g.vertices = new Float32Array(k * e.VERTEX_SIZE);
        k = g.indices = new Uint16Array(3 * k);
        var f = new THREE.BufferGeometry;
        h = g.vertexBuffer = new THREE.InterleavedBuffer(h, e.VERTEX_SIZE);
        h.usage = WebGLRenderingContext.DYNAMIC_DRAW;
        f.setAttribute("position", new THREE.InterleavedBufferAttribute(h, 3, 0, !1));
        f.setAttribute("color", new THREE.InterleavedBufferAttribute(h, 4, 3, !1));
        f.setAttribute("uv", new THREE.InterleavedBufferAttribute(h, 2, 7, !1));
        f.setIndex(new THREE.BufferAttribute(k, 1));
        f.getIndex().usage = WebGLRenderingContext.DYNAMIC_DRAW;
        f.drawRange.start = 0;
        f.drawRange.count = 0;
        g.geometry = f;
        g.material = new a.SkeletonMeshMaterial(c);
        return g;
      }
      __extends(e, d);
      e.prototype.dispose = function() {
        this.geometry.dispose();
        if (this.material instanceof THREE.Material) {
          this.material.dispose();
        } else {
          if (this.material) {
            for (var a = 0; a < this.material.length; a++) {
              var c = this.material[a];
              c instanceof THREE.Material && c.dispose();
            }
          }
        }
      };
      e.prototype.clear = function() {
        var a = this.geometry;
        a.drawRange.start = 0;
        a.drawRange.count = 0;
        this.material.uniforms.map.value = null;
      };
      e.prototype.begin = function() {
        this.indicesLength = this.verticesLength = 0;
      };
      e.prototype.canBatch = function(a, c) {
        return this.indicesLength + c >= this.indices.byteLength / 2 || this.verticesLength + a >= this.vertices.byteLength / 2 ? !1 : !0;
      };
      e.prototype.batch = function(a, c, d, g, f) {
        void 0 === f && (f = 0);
        for (var k = this.verticesLength / e.VERTEX_SIZE, b = this.vertices, m = this.verticesLength, h = 0; h < c;) {
          b[m++] = a[h++], b[m++] = a[h++], b[m++] = f, b[m++] = a[h++], b[m++] = a[h++], b[m++] = a[h++], b[m++] = a[h++], b[m++] = a[h++], b[m++] = a[h++];
        }
        this.verticesLength = m;
        a = this.indices;
        m = this.indicesLength;
        for (h = 0; h < g; m++, h++) {
          a[m] = d[h] + k;
        }
        this.indicesLength += g;
      };
      e.prototype.end = function() {
        this.vertexBuffer.needsUpdate = 0 < this.verticesLength;
        this.vertexBuffer.updateRange.offset = 0;
        this.vertexBuffer.updateRange.count = this.verticesLength;
        var a = this.geometry;
        a.getIndex().needsUpdate = 0 < this.indicesLength;
        a.getIndex().updateRange.offset = 0;
        a.getIndex().updateRange.count = this.indicesLength;
        a.drawRange.start = 0;
        a.drawRange.count = this.indicesLength;
      };
      e.VERTEX_SIZE = 9;
      return e;
    }(THREE.Mesh);
    a.MeshBatcher = d;
  })(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
  (function(d) {
    var g = function(a) {
      function d(d) {
        var c = {uniforms:{map:{type:"t", value:null}}, vertexShader:"\n\t\t\t\tattribute vec4 color;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvarying vec4 vColor;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tvColor = color;\n\t\t\t\t\tgl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0);\n\t\t\t\t}\n\t\t\t", fragmentShader:"\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvarying vec4 vColor;\n\t\t\t\tvoid main(void) {\n\t\t\t\t\tgl_FragColor = texture2D(map, vUv)*vColor;\n\t\t\t\t}\n\t\t\t", 
        side:THREE.DoubleSide, transparent:!0, alphaTest:.5};
        d(c);
        return a.call(this, c) || this;
      }
      __extends(d, a);
      return d;
    }(THREE.ShaderMaterial);
    d.SkeletonMeshMaterial = g;
    g = function(g) {
      function e(d, c) {
        void 0 === c && (c = function(a) {
        });
        var e = g.call(this) || this;
        e.tempPos = new a.Vector2;
        e.tempUv = new a.Vector2;
        e.tempLight = new a.Color;
        e.tempDark = new a.Color;
        e.zOffset = .1;
        e.batches = [];
        e.nextBatchIndex = 0;
        e.clipper = new a.SkeletonClipping;
        e.vertices = a.Utils.newFloatArray(1024);
        e.tempColor = new a.Color;
        e.materialCustomizer = c;
        e.skeleton = new a.Skeleton(d);
        d = new a.AnimationStateData(d);
        e.state = new a.AnimationState(d);
        return e;
      }
      __extends(e, g);
      e.prototype.update = function(a) {
        var c = this.state, d = this.skeleton;
        c.update(a);
        c.apply(d);
        d.updateWorldTransform();
        this.updateGeometry();
      };
      e.prototype.dispose = function() {
        for (var a = 0; a < this.batches.length; a++) {
          this.batches[a].dispose();
        }
      };
      e.prototype.clearBatches = function() {
        for (var a = 0; a < this.batches.length; a++) {
          this.batches[a].clear(), this.batches[a].visible = !1;
        }
        this.nextBatchIndex = 0;
      };
      e.prototype.nextBatch = function() {
        if (this.batches.length == this.nextBatchIndex) {
          var a = new d.MeshBatcher(10920, this.materialCustomizer);
          this.add(a);
          this.batches.push(a);
        }
        a = this.batches[this.nextBatchIndex++];
        a.visible = !0;
        return a;
      };
      e.prototype.updateGeometry = function() {
        this.clearBatches();
        var d = this.tempPos, c = this.tempUv, g = this.tempLight, h = this.tempDark, f = this.clipper, n = this.skeleton.drawOrder, b = this.nextBatch();
        b.begin();
        for (var m = 0, q = this.zOffset, y = 0, x = n.length; y < x; y++) {
          var z = f.isClipping() ? 2 : e.VERTEX_SIZE, r = n[y];
          if (r.bone.active) {
            var u = r.getAttachment();
            if (u instanceof a.RegionAttachment) {
              var v = u.color;
              var C = this.vertices;
              var A = 4 * z;
              u.computeWorldVertices(r.bone, C, 0, z);
              var D = e.QUAD_TRIANGLES;
              var F = u.uvs;
              u = u.region.renderObject.texture;
            } else {
              if (u instanceof a.MeshAttachment) {
                v = u.color, C = this.vertices, A = (u.worldVerticesLength >> 1) * z, A > C.length && (C = this.vertices = a.Utils.newFloatArray(A)), u.computeWorldVertices(r, 0, u.worldVerticesLength, C, 0, z), D = u.triangles, F = u.uvs, u = u.region.renderObject.texture;
              } else {
                u instanceof a.ClippingAttachment && f.clipStart(r, u);
                continue;
              }
            }
            if (null != u) {
              var B = r.bone.skeleton.color, E = r.color, H = this.tempColor;
              H.set(B.r * E.r * v.r, B.g * E.g * v.g, B.b * E.b * v.b, B.a * E.a * v.a);
              if (f.isClipping()) {
                f.clipTriangles(C, A, D, D.length, F, H, null, !1);
                A = f.clippedVertices;
                D = f.clippedTriangles;
                if (null != this.vertexEffect) {
                  for (E = this.vertexEffect, v = A, B = 0, C = A.length; B < C; B += z) {
                    d.x = v[B], d.y = v[B + 1], g.setFromColor(H), h.set(0, 0, 0, 0), c.x = v[B + 6], c.y = v[B + 7], E.transform(d, c, g, h), v[B] = d.x, v[B + 1] = d.y, v[B + 2] = g.r, v[B + 3] = g.g, v[B + 4] = g.b, v[B + 5] = g.a, v[B + 6] = c.x, v[B + 7] = c.y;
                  }
                }
                z = A;
                A = A.length;
                H = D;
                D = D.length;
              } else {
                v = C;
                if (null != this.vertexEffect) {
                  E = this.vertexEffect;
                  for (var L = B = 0, K = A; B < K; B += z, L += 2) {
                    d.x = v[B], d.y = v[B + 1], g.setFromColor(H), h.set(0, 0, 0, 0), c.x = F[L], c.y = F[L + 1], E.transform(d, c, g, h), v[B] = d.x, v[B + 1] = d.y, v[B + 2] = g.r, v[B + 3] = g.g, v[B + 4] = g.b, v[B + 5] = g.a, v[B + 6] = c.x, v[B + 7] = c.y;
                  }
                } else {
                  for (B = 2, L = 0, E = A; B < E; B += z, L += 2) {
                    v[B] = H.r, v[B + 1] = H.g, v[B + 2] = H.b, v[B + 3] = H.a, v[B + 4] = F[L], v[B + 5] = F[L + 1];
                  }
                }
                z = C;
                H = D;
                D = D.length;
              }
              if (0 == A || 0 == D) {
                continue;
              }
              b.canBatch(A, D) || (b.end(), b = this.nextBatch(), b.begin());
              C = b.material;
              null == C.uniforms.map.value && (C.uniforms.map.value = u.texture);
              C.uniforms.map.value != u.texture && (b.end(), b = this.nextBatch(), b.begin(), C = b.material, C.uniforms.map.value = u.texture);
              C.needsUpdate = !0;
              b.batch(z, A, H, D, m);
              m += q;
            }
            f.clipEndWithSlot(r);
          }
        }
        f.clipEnd();
        b.end();
      };
      e.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
      e.VERTEX_SIZE = 8;
      return e;
    }(THREE.Object3D);
    d.SkeletonMesh = g;
  })(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
  (function(d) {
    var g = function(d) {
      function e(a) {
        var c = d.call(this, a) || this;
        c.texture = new THREE.Texture(a);
        c.texture.flipY = !1;
        c.texture.needsUpdate = !0;
        return c;
      }
      __extends(e, d);
      e.prototype.setFilters = function(a, c) {
        this.texture.minFilter = e.toThreeJsTextureFilter(a);
        this.texture.magFilter = e.toThreeJsTextureFilter(c);
      };
      e.prototype.setWraps = function(a, c) {
        this.texture.wrapS = e.toThreeJsTextureWrap(a);
        this.texture.wrapT = e.toThreeJsTextureWrap(c);
      };
      e.prototype.dispose = function() {
        this.texture.dispose();
      };
      e.toThreeJsTextureFilter = function(d) {
        if (d === a.TextureFilter.Linear) {
          return THREE.LinearFilter;
        }
        if (d === a.TextureFilter.MipMap) {
          return THREE.LinearMipMapLinearFilter;
        }
        if (d === a.TextureFilter.MipMapLinearNearest) {
          return THREE.LinearMipMapNearestFilter;
        }
        if (d === a.TextureFilter.MipMapNearestLinear) {
          return THREE.NearestMipMapLinearFilter;
        }
        if (d === a.TextureFilter.MipMapNearestNearest) {
          return THREE.NearestMipMapNearestFilter;
        }
        if (d === a.TextureFilter.Nearest) {
          return THREE.NearestFilter;
        }
        throw Error("Unknown texture filter: " + d);
      };
      e.toThreeJsTextureWrap = function(d) {
        if (d === a.TextureWrap.ClampToEdge) {
          return THREE.ClampToEdgeWrapping;
        }
        if (d === a.TextureWrap.MirroredRepeat) {
          return THREE.MirroredRepeatWrapping;
        }
        if (d === a.TextureWrap.Repeat) {
          return THREE.RepeatWrapping;
        }
        throw Error("Unknown texture wrap: " + d);
      };
      return e;
    }(a.Texture);
    d.ThreeJsTexture = g;
  })(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
  "object" === typeof exports && "undefined" !== typeof module ? module.exports = a() : "function" === typeof define && define.amd ? define([], a) : ("undefined" !== typeof window ? window : "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : this).opentype = a();
})(function() {
  return function e(d, g, h) {
    function k(p, f) {
      if (!g[p]) {
        if (!d[p]) {
          var n = "function" == typeof require && require;
          if (!f && n) {
            return n(p, !0);
          }
          if (c) {
            return c(p, !0);
          }
          f = Error("Cannot find module '" + p + "'");
          throw f.code = "MODULE_NOT_FOUND", f;
        }
        f = g[p] = {exports:{}};
        d[p][0].call(f.exports, function(b) {
          var c = d[p][1][b];
          return k(c ? c : b);
        }, f, f.exports, e, d, g, h);
      }
      return g[p].exports;
    }
    for (var c = "function" == typeof require && require, p = 0; p < h.length; p++) {
      k(h[p]);
    }
    return k;
  }({1:[function(d, g, h) {
    function e() {
      this.table = new Uint16Array(16);
      this.trans = new Uint16Array(288);
    }
    function k(b, c) {
      this.source = b;
      this.bitcount = this.tag = this.sourceIndex = 0;
      this.dest = c;
      this.destLen = 0;
      this.ltree = new e;
      this.dtree = new e;
    }
    function c(b, c, d, e) {
      var f;
      for (f = 0; d > f; ++f) {
        b[f] = 0;
      }
      for (f = 0; 30 - d > f; ++f) {
        b[f + d] = f / d | 0;
      }
      d = e;
      for (f = 0; 30 > f; ++f) {
        c[f] = d, d += 1 << b[f];
      }
    }
    function p(b, c, d, e) {
      var f, g;
      for (f = 0; 16 > f; ++f) {
        b.table[f] = 0;
      }
      for (f = 0; e > f; ++f) {
        b.table[c[d + f]]++;
      }
      for (f = g = b.table[0] = 0; 16 > f; ++f) {
        A[f] = g, g += b.table[f];
      }
      for (f = 0; e > f; ++f) {
        c[d + f] && (b.trans[A[c[d + f]]++] = f);
      }
    }
    function t(b, c, d) {
      if (!c) {
        return d;
      }
      for (; 24 > b.bitcount;) {
        b.tag |= b.source[b.sourceIndex++] << b.bitcount, b.bitcount += 8;
      }
      var e = b.tag & 65535 >>> 16 - c;
      return b.tag >>>= c, b.bitcount -= c, e + d;
    }
    function f(b, c) {
      for (; 24 > b.bitcount;) {
        b.tag |= b.source[b.sourceIndex++] << b.bitcount, b.bitcount += 8;
      }
      var d = 0, e = 0, f = 0, g = b.tag;
      do {
        e = 2 * e + (1 & g), g >>>= 1, ++f, d += c.table[f], e -= c.table[f];
      } while (0 <= e);
      return b.tag = g, b.bitcount -= f, c.trans[d + e];
    }
    function n(c, d, e) {
      for (;;) {
        var g = f(c, d);
        if (256 === g) {
          return b;
        }
        if (256 > g) {
          c.dest[c.destLen++] = g;
        } else {
          var k;
          g -= 257;
          g = t(c, y[g], x[g]);
          var m = f(c, e);
          for (k = m = c.destLen - t(c, z[m], r[m]); m + g > k; ++k) {
            c.dest[c.destLen++] = c.dest[k];
          }
        }
      }
    }
    var b = 0, m = new e, q = new e, y = new Uint8Array(30), x = new Uint16Array(30), z = new Uint8Array(30), r = new Uint16Array(30), u = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), v = new e, C = new Uint8Array(320), A = new Uint16Array(16);
    (function(b, c) {
      var d;
      for (d = 0; 7 > d; ++d) {
        b.table[d] = 0;
      }
      b.table[7] = 24;
      b.table[8] = 152;
      b.table[9] = 112;
      for (d = 0; 24 > d; ++d) {
        b.trans[d] = 256 + d;
      }
      for (d = 0; 144 > d; ++d) {
        b.trans[24 + d] = d;
      }
      for (d = 0; 8 > d; ++d) {
        b.trans[168 + d] = 280 + d;
      }
      for (d = 0; 112 > d; ++d) {
        b.trans[176 + d] = 144 + d;
      }
      for (d = 0; 5 > d; ++d) {
        c.table[d] = 0;
      }
      c.table[5] = 32;
      for (d = 0; 32 > d; ++d) {
        c.trans[d] = d;
      }
    })(m, q);
    c(y, x, 4, 3);
    c(z, r, 2, 1);
    y[28] = 0;
    x[28] = 258;
    g.exports = function(c, d) {
      c = new k(c, d);
      do {
        d = c;
        d.bitcount-- || (d.tag = d.source[d.sourceIndex++], d.bitcount = 7);
        var e = 1 & d.tag;
        switch(d = (d.tag >>>= 1, e), t(c, 2, 0)) {
          case 0:
            var g, h = g = void 0;
            for (e = c; 8 < e.bitcount;) {
              e.sourceIndex--, e.bitcount -= 8;
            }
            if (h = e.source[e.sourceIndex + 1], h = 256 * h + e.source[e.sourceIndex], g = e.source[e.sourceIndex + 3], g = 256 * g + e.source[e.sourceIndex + 2], h !== (65535 & ~g)) {
              e = -3;
            } else {
              e.sourceIndex += 4;
              for (g = h; g; --g) {
                e.dest[e.destLen++] = e.source[e.sourceIndex++];
              }
              e = (e.bitcount = 0, b);
            }
            break;
          case 1:
            e = n(c, m, q);
            break;
          case 2:
            var r;
            h = c;
            var x = c.ltree, y = c.dtree;
            g = t(h, 5, 257);
            e = t(h, 5, 1);
            var z = t(h, 4, 4);
            for (r = 0; 19 > r; ++r) {
              C[r] = 0;
            }
            for (r = 0; z > r; ++r) {
              var A = t(h, 3, 0);
              C[u[r]] = A;
            }
            p(v, C, 0, 19);
            for (r = 0; g + e > r;) {
              switch(z = f(h, v), z) {
                case 16:
                  A = C[r - 1];
                  for (z = t(h, 2, 3); z; --z) {
                    C[r++] = A;
                  }
                  break;
                case 17:
                  for (z = t(h, 3, 3); z; --z) {
                    C[r++] = 0;
                  }
                  break;
                case 18:
                  for (z = t(h, 7, 11); z; --z) {
                    C[r++] = 0;
                  }
                  break;
                default:
                  C[r++] = z;
              }
            }
            p(x, C, 0, g);
            p(y, C, g, e);
            e = n(c, c.ltree, c.dtree);
            break;
          default:
            e = -3;
        }
        if (e !== b) {
          throw Error("Data error");
        }
      } while (!d);
      return c.destLen < c.dest.length ? "function" == typeof c.dest.slice ? c.dest.slice(0, c.destLen) : c.dest.subarray(0, c.destLen) : c.dest;
    };
  }, {}], 2:[function(d, g, h) {
    h.fail = function(d) {
      throw Error(d);
    };
    h.argument = function(d, g) {
      d || h.fail(g);
    };
    h.assert = h.argument;
  }, {}], 3:[function(d, g, h) {
    h.line = function(d, g, c, h, t) {
      d.beginPath();
      d.moveTo(g, c);
      d.lineTo(h, t);
      d.stroke();
    };
  }, {}], 4:[function(d, g, h) {
    function e(c) {
      this.font = c;
    }
    function k(c) {
      this.cmap = c;
    }
    function c(c, d) {
      this.encoding = c;
      this.charset = d;
    }
    function p(c) {
      var d;
      switch(c.version) {
        case 1:
          this.names = h.standardNames.slice();
          break;
        case 2:
          this.names = Array(c.numberOfGlyphs);
          for (d = 0; d < c.numberOfGlyphs; d++) {
            this.names[d] = c.glyphNameIndex[d] < h.standardNames.length ? h.standardNames[c.glyphNameIndex[d]] : c.names[c.glyphNameIndex[d] - h.standardNames.length];
          }
          break;
        case 2.5:
          this.names = Array(c.numberOfGlyphs);
          for (d = 0; d < c.numberOfGlyphs; d++) {
            this.names[d] = h.standardNames[d + c.glyphNameIndex[d]];
          }
          break;
        case 3:
          this.names = [];
      }
    }
    e.prototype.charToGlyphIndex = function(c) {
      c = c.charCodeAt(0);
      var d = this.font.glyphs;
      if (!d) {
        return null;
      }
      for (var e = 0; e < d.length; e += 1) {
        for (var b = d.get(e), g = 0; g < b.unicodes.length; g += 1) {
          if (b.unicodes[g] === c) {
            return e;
          }
        }
      }
    };
    k.prototype.charToGlyphIndex = function(c) {
      return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;
    };
    c.prototype.charToGlyphIndex = function(c) {
      c = c.charCodeAt(0);
      return this.charset.indexOf(this.encoding[c]);
    };
    p.prototype.nameToGlyphIndex = function(c) {
      return this.names.indexOf(c);
    };
    p.prototype.glyphIndexToName = function(c) {
      return this.names[c];
    };
    h.cffStandardStrings = ".notdef;space;exclam;quotedbl;numbersign;dollar;percent;ampersand;quoteright;parenleft;parenright;asterisk;plus;comma;hyphen;period;slash;zero;one;two;three;four;five;six;seven;eight;nine;colon;semicolon;less;equal;greater;question;at;A;B;C;D;E;F;G;H;I;J;K;L;M;N;O;P;Q;R;S;T;U;V;W;X;Y;Z;bracketleft;backslash;bracketright;asciicircum;underscore;quoteleft;a;b;c;d;e;f;g;h;i;j;k;l;m;n;o;p;q;r;s;t;u;v;w;x;y;z;braceleft;bar;braceright;asciitilde;exclamdown;cent;sterling;fraction;yen;florin;section;currency;quotesingle;quotedblleft;guillemotleft;guilsinglleft;guilsinglright;fi;fl;endash;dagger;daggerdbl;periodcentered;paragraph;bullet;quotesinglbase;quotedblbase;quotedblright;guillemotright;ellipsis;perthousand;questiondown;grave;acute;circumflex;tilde;macron;breve;dotaccent;dieresis;ring;cedilla;hungarumlaut;ogonek;caron;emdash;AE;ordfeminine;Lslash;Oslash;OE;ordmasculine;ae;dotlessi;lslash;oslash;oe;germandbls;onesuperior;logicalnot;mu;trademark;Eth;onehalf;plusminus;Thorn;onequarter;divide;brokenbar;degree;thorn;threequarters;twosuperior;registered;minus;eth;multiply;threesuperior;copyright;Aacute;Acircumflex;Adieresis;Agrave;Aring;Atilde;Ccedilla;Eacute;Ecircumflex;Edieresis;Egrave;Iacute;Icircumflex;Idieresis;Igrave;Ntilde;Oacute;Ocircumflex;Odieresis;Ograve;Otilde;Scaron;Uacute;Ucircumflex;Udieresis;Ugrave;Yacute;Ydieresis;Zcaron;aacute;acircumflex;adieresis;agrave;aring;atilde;ccedilla;eacute;ecircumflex;edieresis;egrave;iacute;icircumflex;idieresis;igrave;ntilde;oacute;ocircumflex;odieresis;ograve;otilde;scaron;uacute;ucircumflex;udieresis;ugrave;yacute;ydieresis;zcaron;exclamsmall;Hungarumlautsmall;dollaroldstyle;dollarsuperior;ampersandsmall;Acutesmall;parenleftsuperior;parenrightsuperior;266 ff;onedotenleader;zerooldstyle;oneoldstyle;twooldstyle;threeoldstyle;fouroldstyle;fiveoldstyle;sixoldstyle;sevenoldstyle;eightoldstyle;nineoldstyle;commasuperior;threequartersemdash;periodsuperior;questionsmall;asuperior;bsuperior;centsuperior;dsuperior;esuperior;isuperior;lsuperior;msuperior;nsuperior;osuperior;rsuperior;ssuperior;tsuperior;ff;ffi;ffl;parenleftinferior;parenrightinferior;Circumflexsmall;hyphensuperior;Gravesmall;Asmall;Bsmall;Csmall;Dsmall;Esmall;Fsmall;Gsmall;Hsmall;Ismall;Jsmall;Ksmall;Lsmall;Msmall;Nsmall;Osmall;Psmall;Qsmall;Rsmall;Ssmall;Tsmall;Usmall;Vsmall;Wsmall;Xsmall;Ysmall;Zsmall;colonmonetary;onefitted;rupiah;Tildesmall;exclamdownsmall;centoldstyle;Lslashsmall;Scaronsmall;Zcaronsmall;Dieresissmall;Brevesmall;Caronsmall;Dotaccentsmall;Macronsmall;figuredash;hypheninferior;Ogoneksmall;Ringsmall;Cedillasmall;questiondownsmall;oneeighth;threeeighths;fiveeighths;seveneighths;onethird;twothirds;zerosuperior;foursuperior;fivesuperior;sixsuperior;sevensuperior;eightsuperior;ninesuperior;zeroinferior;oneinferior;twoinferior;threeinferior;fourinferior;fiveinferior;sixinferior;seveninferior;eightinferior;nineinferior;centinferior;dollarinferior;periodinferior;commainferior;Agravesmall;Aacutesmall;Acircumflexsmall;Atildesmall;Adieresissmall;Aringsmall;AEsmall;Ccedillasmall;Egravesmall;Eacutesmall;Ecircumflexsmall;Edieresissmall;Igravesmall;Iacutesmall;Icircumflexsmall;Idieresissmall;Ethsmall;Ntildesmall;Ogravesmall;Oacutesmall;Ocircumflexsmall;Otildesmall;Odieresissmall;OEsmall;Oslashsmall;Ugravesmall;Uacutesmall;Ucircumflexsmall;Udieresissmall;Yacutesmall;Thornsmall;Ydieresissmall;001.000;001.001;001.002;001.003;Black;Bold;Book;Light;Medium;Regular;Roman;Semibold".split(";");
    h.cffStandardEncoding = "                                space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk plus comma hyphen period slash zero one two three four five six seven eight nine colon semicolon less equal greater question at A B C D E F G H I J K L M N O P Q R S T U V W X Y Z bracketleft backslash bracketright asciicircum underscore quoteleft a b c d e f g h i j k l m n o p q r s t u v w x y z braceleft bar braceright asciitilde                                   exclamdown cent sterling fraction yen florin section currency quotesingle quotedblleft guillemotleft guilsinglleft guilsinglright fi fl  endash dagger daggerdbl periodcentered  paragraph bullet quotesinglbase quotedblbase quotedblright guillemotright ellipsis perthousand  questiondown  grave acute circumflex tilde macron breve dotaccent dieresis  ring cedilla  hungarumlaut ogonek caron emdash                 AE  ordfeminine     Lslash Oslash OE ordmasculine      ae    dotlessi   lslash oslash oe germandbls".split(" ");
    h.cffExpertEncoding = "                                space exclamsmall Hungarumlautsmall  dollaroldstyle dollarsuperior ampersandsmall Acutesmall parenleftsuperior parenrightsuperior twodotenleader onedotenleader comma hyphen period fraction zerooldstyle oneoldstyle twooldstyle threeoldstyle fouroldstyle fiveoldstyle sixoldstyle sevenoldstyle eightoldstyle nineoldstyle colon semicolon commasuperior threequartersemdash periodsuperior questionsmall  asuperior bsuperior centsuperior dsuperior esuperior   isuperior   lsuperior msuperior nsuperior osuperior   rsuperior ssuperior tsuperior  ff fi fl ffi ffl parenleftinferior  parenrightinferior Circumflexsmall hyphensuperior Gravesmall Asmall Bsmall Csmall Dsmall Esmall Fsmall Gsmall Hsmall Ismall Jsmall Ksmall Lsmall Msmall Nsmall Osmall Psmall Qsmall Rsmall Ssmall Tsmall Usmall Vsmall Wsmall Xsmall Ysmall Zsmall colonmonetary onefitted rupiah Tildesmall                                   exclamdownsmall centoldstyle Lslashsmall   Scaronsmall Zcaronsmall Dieresissmall Brevesmall Caronsmall  Dotaccentsmall   Macronsmall   figuredash hypheninferior   Ogoneksmall Ringsmall Cedillasmall    onequarter onehalf threequarters questiondownsmall oneeighth threeeighths fiveeighths seveneighths onethird twothirds   zerosuperior onesuperior twosuperior threesuperior foursuperior fivesuperior sixsuperior sevensuperior eightsuperior ninesuperior zeroinferior oneinferior twoinferior threeinferior fourinferior fiveinferior sixinferior seveninferior eightinferior nineinferior centinferior dollarinferior periodinferior commainferior Agravesmall Aacutesmall Acircumflexsmall Atildesmall Adieresissmall Aringsmall AEsmall Ccedillasmall Egravesmall Eacutesmall Ecircumflexsmall Edieresissmall Igravesmall Iacutesmall Icircumflexsmall Idieresissmall Ethsmall Ntildesmall Ogravesmall Oacutesmall Ocircumflexsmall Otildesmall Odieresissmall OEsmall Oslashsmall Ugravesmall Uacutesmall Ucircumflexsmall Udieresissmall Yacutesmall Thornsmall Ydieresissmall".split(" ");
    h.standardNames = ".notdef .null nonmarkingreturn space exclam quotedbl numbersign dollar percent ampersand quotesingle parenleft parenright asterisk plus comma hyphen period slash zero one two three four five six seven eight nine colon semicolon less equal greater question at A B C D E F G H I J K L M N O P Q R S T U V W X Y Z bracketleft backslash bracketright asciicircum underscore grave a b c d e f g h i j k l m n o p q r s t u v w x y z braceleft bar braceright asciitilde Adieresis Aring Ccedilla Eacute Ntilde Odieresis Udieresis aacute agrave acircumflex adieresis atilde aring ccedilla eacute egrave ecircumflex edieresis iacute igrave icircumflex idieresis ntilde oacute ograve ocircumflex odieresis otilde uacute ugrave ucircumflex udieresis dagger degree cent sterling section bullet paragraph germandbls registered copyright trademark acute dieresis notequal AE Oslash infinity plusminus lessequal greaterequal yen mu partialdiff summation product pi integral ordfeminine ordmasculine Omega ae oslash questiondown exclamdown logicalnot radical florin approxequal Delta guillemotleft guillemotright ellipsis nonbreakingspace Agrave Atilde Otilde OE oe endash emdash quotedblleft quotedblright quoteleft quoteright divide lozenge ydieresis Ydieresis fraction currency guilsinglleft guilsinglright fi fl daggerdbl periodcentered quotesinglbase quotedblbase perthousand Acircumflex Ecircumflex Aacute Edieresis Egrave Iacute Icircumflex Idieresis Igrave Oacute Ocircumflex apple Ograve Uacute Ucircumflex Ugrave dotlessi circumflex tilde macron breve dotaccent ring cedilla hungarumlaut ogonek caron Lslash lslash Scaron scaron Zcaron zcaron brokenbar Eth eth Yacute yacute Thorn thorn minus multiply onesuperior twosuperior threesuperior onehalf onequarter threequarters franc Gbreve gbreve Idotaccent Scedilla scedilla Cacute cacute Ccaron ccaron dcroat".split(" ");
    h.DefaultEncoding = e;
    h.CmapEncoding = k;
    h.CffEncoding = c;
    h.GlyphNames = p;
    h.addGlyphNames = function(c) {
      for (var d, e = c.tables.cmap.glyphIndexMap, b = Object.keys(e), g = 0; g < b.length; g += 1) {
        var k = b[g];
        d = c.glyphs.get(e[k]);
        d.addUnicode(parseInt(k));
      }
      for (g = 0; g < c.glyphs.length; g += 1) {
        d = c.glyphs.get(g), c.cffEncoding ? d.name = c.cffEncoding.charset[g] : c.glyphNames.names && (d.name = c.glyphNames.glyphIndexToName(g));
      }
    };
  }, {}], 5:[function(d, g, h) {
    function e(b) {
      b = b || {};
      b.empty || (n.checkArgument(b.familyName, "When creating a new Font object, familyName is required."), n.checkArgument(b.styleName, "When creating a new Font object, styleName is required."), n.checkArgument(b.unitsPerEm, "When creating a new Font object, unitsPerEm is required."), n.checkArgument(b.ascender, "When creating a new Font object, ascender is required."), n.checkArgument(b.descender, "When creating a new Font object, descender is required."), n.checkArgument(0 > b.descender, "Descender should be negative (e.g. -512)."), 
      this.names = {fontFamily:{en:b.familyName || " "}, fontSubfamily:{en:b.styleName || " "}, fullName:{en:b.fullName || b.familyName + " " + b.styleName}, postScriptName:{en:b.postScriptName || b.familyName + b.styleName}, designer:{en:b.designer || " "}, designerURL:{en:b.designerURL || " "}, manufacturer:{en:b.manufacturer || " "}, manufacturerURL:{en:b.manufacturerURL || " "}, license:{en:b.license || " "}, licenseURL:{en:b.licenseURL || " "}, version:{en:b.version || "Version 0.1"}, description:{en:b.description || 
      " "}, copyright:{en:b.copyright || " "}, trademark:{en:b.trademark || " "}}, this.unitsPerEm = b.unitsPerEm || 1E3, this.ascender = b.ascender, this.descender = b.descender, this.createdTimestamp = b.createdTimestamp, this.tables = {os2:{usWeightClass:b.weightClass || this.usWeightClasses.MEDIUM, usWidthClass:b.widthClass || this.usWidthClasses.MEDIUM, fsSelection:b.fsSelection || this.fsSelectionValues.REGULAR}});
      this.supported = !0;
      this.glyphs = new t.GlyphSet(this, b.glyphs || []);
      this.encoding = new p.DefaultEncoding(this);
      this.substitution = new f(this);
      this.tables = this.tables || {};
    }
    var k = d("./path"), c = d("./tables/sfnt"), p = d("./encoding"), t = d("./glyphset"), f = d("./substitution"), n = d("./util");
    e.prototype.hasChar = function(b) {
      return null !== this.encoding.charToGlyphIndex(b);
    };
    e.prototype.charToGlyphIndex = function(b) {
      return this.encoding.charToGlyphIndex(b);
    };
    e.prototype.charToGlyph = function(b) {
      b = this.charToGlyphIndex(b);
      b = this.glyphs.get(b);
      return b || (b = this.glyphs.get(0)), b;
    };
    e.prototype.stringToGlyphs = function(b) {
      for (var c = [], d = 0; d < b.length; d += 1) {
        c.push(this.charToGlyph(b[d]));
      }
      return c;
    };
    e.prototype.nameToGlyphIndex = function(b) {
      return this.glyphNames.nameToGlyphIndex(b);
    };
    e.prototype.nameToGlyph = function(b) {
      b = this.nametoGlyphIndex(b);
      b = this.glyphs.get(b);
      return b || (b = this.glyphs.get(0)), b;
    };
    e.prototype.glyphIndexToName = function(b) {
      return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(b) : "";
    };
    e.prototype.getKerningValue = function(b, c) {
      b = b.index || b;
      c = c.index || c;
      var d = this.getGposKerningValue;
      return d ? d(b, c) : this.kerningPairs[b + "," + c] || 0;
    };
    e.prototype.forEachGlyph = function(b, c, d, e, f, g) {
      c = void 0 !== c ? c : 0;
      d = void 0 !== d ? d : 0;
      e = void 0 !== e ? e : 72;
      f = f || {};
      var k = void 0 === f.kerning ? !0 : f.kerning, h = 1 / this.unitsPerEm * e;
      b = this.stringToGlyphs(b);
      for (var m = 0; m < b.length; m += 1) {
        var n = b[m];
        if (g(n, c, d, e, f), n.advanceWidth && (c += n.advanceWidth * h), k && m < b.length - 1) {
          n = this.getKerningValue(n, b[m + 1]), c += n * h;
        }
      }
    };
    e.prototype.getPath = function(b, c, d, e, f) {
      var g = new k.Path;
      return this.forEachGlyph(b, c, d, e, f, function(b, c, d, e) {
        b = b.getPath(c, d, e);
        g.extend(b);
      }), g;
    };
    e.prototype.getPaths = function(b, c, d, e, f) {
      var g = [];
      return this.forEachGlyph(b, c, d, e, f, function(b, c, d, e) {
        b = b.getPath(c, d, e);
        g.push(b);
      }), g;
    };
    e.prototype.draw = function(b, c, d, e, f, g) {
      this.getPath(c, d, e, f, g).draw(b);
    };
    e.prototype.drawPoints = function(b, c, d, e, f, g) {
      this.forEachGlyph(c, d, e, f, g, function(c, d, e, f) {
        c.drawPoints(b, d, e, f);
      });
    };
    e.prototype.drawMetrics = function(b, c, d, e, f, g) {
      this.forEachGlyph(c, d, e, f, g, function(c, d, e, f) {
        c.drawMetrics(b, d, e, f);
      });
    };
    e.prototype.getEnglishName = function(b) {
      return (b = this.names[b]) ? b.en : void 0;
    };
    e.prototype.validate = function() {
      function b(b) {
        var e = d.getEnglishName(b);
        e && 0 < e.trim().length || c.push("No English " + b + " specified.");
      }
      var c = [], d = this;
      b("fontFamily");
      b("weightName");
      b("manufacturer");
      b("copyright");
      b("version");
      0 < this.unitsPerEm || c.push("No unitsPerEm specified.");
    };
    e.prototype.toTables = function() {
      return c.fontToTable(this);
    };
    e.prototype.toBuffer = function() {
      return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."), this.toArrayBuffer();
    };
    e.prototype.toArrayBuffer = function() {
      for (var b = this.toTables().encode(), c = new ArrayBuffer(b.length), d = new Uint8Array(c), e = 0; e < b.length; e++) {
        d[e] = b[e];
      }
      return c;
    };
    e.prototype.download = function() {
      var b = this.getEnglishName("fontFamily"), c = this.getEnglishName("fontSubfamily"), e = b.replace(/\s/g, "") + "-" + c + ".otf", f = this.toArrayBuffer();
      n.isBrowser() ? (window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem, window.requestFileSystem(window.TEMPORARY, f.byteLength, function(b) {
        b.root.getFile(e, {create:!0}, function(b) {
          b.createWriter(function(c) {
            var d = new DataView(f);
            d = new Blob([d], {type:"font/opentype"});
            c.write(d);
            c.addEventListener("writeend", function() {
              location.href = b.toURL();
            }, !1);
          });
        });
      }, function(b) {
        throw Error(b.name + ": " + b.message);
      })) : (b = d("fs"), c = n.arrayBufferToNodeBuffer(f), b.writeFileSync(e, c));
    };
    e.prototype.fsSelectionValues = {ITALIC:1, UNDERSCORE:2, NEGATIVE:4, OUTLINED:8, STRIKEOUT:16, BOLD:32, REGULAR:64, USER_TYPO_METRICS:128, WWS:256, OBLIQUE:512};
    e.prototype.usWidthClasses = {ULTRA_CONDENSED:1, EXTRA_CONDENSED:2, CONDENSED:3, SEMI_CONDENSED:4, MEDIUM:5, SEMI_EXPANDED:6, EXPANDED:7, EXTRA_EXPANDED:8, ULTRA_EXPANDED:9};
    e.prototype.usWeightClasses = {THIN:100, EXTRA_LIGHT:200, LIGHT:300, NORMAL:400, MEDIUM:500, SEMI_BOLD:600, BOLD:700, EXTRA_BOLD:800, BLACK:900};
    h.Font = e;
  }, {"./encoding":4, "./glyphset":7, "./path":11, "./substitution":12, "./tables/sfnt":31, "./util":33, fs:void 0}], 6:[function(d, g, h) {
    function e(c, d) {
      var b = d || {commands:[]};
      return {configurable:!0, get:function() {
        return "function" == typeof b && (b = b()), b;
      }, set:function(c) {
        b = c;
      }};
    }
    function k(c) {
      this.bindConstructorValues(c);
    }
    var c = d("./check"), p = d("./draw"), t = d("./path");
    k.prototype.bindConstructorValues = function(c) {
      this.index = c.index || 0;
      this.name = c.name || null;
      this.unicode = c.unicode || void 0;
      this.unicodes = c.unicodes || void 0 !== c.unicode ? [c.unicode] : [];
      c.xMin && (this.xMin = c.xMin);
      c.yMin && (this.yMin = c.yMin);
      c.xMax && (this.xMax = c.xMax);
      c.yMax && (this.yMax = c.yMax);
      c.advanceWidth && (this.advanceWidth = c.advanceWidth);
      Object.defineProperty(this, "path", e(this, c.path));
    };
    k.prototype.addUnicode = function(c) {
      0 === this.unicodes.length && (this.unicode = c);
      this.unicodes.push(c);
    };
    k.prototype.getPath = function(c, d, b, e) {
      c = void 0 !== c ? c : 0;
      d = void 0 !== d ? d : 0;
      e = void 0 !== e ? e : {xScale:1, yScale:1};
      var f = 1 / this.path.unitsPerEm * (void 0 !== b ? b : 72);
      b = e.xScale * f;
      e = e.yScale * f;
      f = new t.Path;
      for (var g = this.path.commands, k = 0; k < g.length; k += 1) {
        var h = g[k];
        "M" === h.type ? f.moveTo(c + h.x * b, d + -h.y * e) : "L" === h.type ? f.lineTo(c + h.x * b, d + -h.y * e) : "Q" === h.type ? f.quadraticCurveTo(c + h.x1 * b, d + -h.y1 * e, c + h.x * b, d + -h.y * e) : "C" === h.type ? f.curveTo(c + h.x1 * b, d + -h.y1 * e, c + h.x2 * b, d + -h.y2 * e, c + h.x * b, d + -h.y * e) : "Z" === h.type && f.closePath();
      }
      return f;
    };
    k.prototype.getContours = function() {
      if (void 0 === this.points) {
        return [];
      }
      for (var d = [], e = [], b = 0; b < this.points.length; b += 1) {
        var g = this.points[b];
        e.push(g);
        g.lastPointOfContour && (d.push(e), e = []);
      }
      return c.argument(0 === e.length, "There are still points left in the current contour."), d;
    };
    k.prototype.getMetrics = function() {
      for (var c = this.path.commands, d = [], b = [], e = 0; e < c.length; e += 1) {
        var g = c[e];
        "Z" !== g.type && (d.push(g.x), b.push(g.y));
        "Q" !== g.type && "C" !== g.type || (d.push(g.x1), b.push(g.y1));
        "C" === g.type && (d.push(g.x2), b.push(g.y2));
      }
      c = {xMin:Math.min.apply(null, d), yMin:Math.min.apply(null, b), xMax:Math.max.apply(null, d), yMax:Math.max.apply(null, b), leftSideBearing:this.leftSideBearing};
      return isFinite(c.xMin) || (c.xMin = 0), isFinite(c.xMax) || (c.xMax = this.advanceWidth), isFinite(c.yMin) || (c.yMin = 0), isFinite(c.yMax) || (c.yMax = 0), c.rightSideBearing = this.advanceWidth - c.leftSideBearing - (c.xMax - c.xMin), c;
    };
    k.prototype.draw = function(c, d, b, e, g) {
      this.getPath(d, b, e, g).draw(c);
    };
    k.prototype.drawPoints = function(c, d, b, e) {
      function f(b, d, e, f) {
        var g = 2 * Math.PI;
        c.beginPath();
        for (var k = 0; k < b.length; k += 1) {
          c.moveTo(d + b[k].x * f, e + b[k].y * f), c.arc(d + b[k].x * f, e + b[k].y * f, 2, 0, g, !1);
        }
        c.closePath();
        c.fill();
      }
      d = void 0 !== d ? d : 0;
      b = void 0 !== b ? b : 0;
      e = 1 / this.path.unitsPerEm * (void 0 !== e ? e : 24);
      for (var g = [], k = [], h = this.path, m = 0; m < h.commands.length; m += 1) {
        var n = h.commands[m];
        void 0 !== n.x && g.push({x:n.x, y:-n.y});
        void 0 !== n.x1 && k.push({x:n.x1, y:-n.y1});
        void 0 !== n.x2 && k.push({x:n.x2, y:-n.y2});
      }
      c.fillStyle = "blue";
      f(g, d, b, e);
      c.fillStyle = "red";
      f(k, d, b, e);
    };
    k.prototype.drawMetrics = function(c, d, b, e) {
      d = void 0 !== d ? d : 0;
      b = void 0 !== b ? b : 0;
      e = 1 / this.path.unitsPerEm * (void 0 !== e ? e : 24);
      c.lineWidth = 1;
      c.strokeStyle = "black";
      p.line(c, d, -1E4, d, 1E4);
      p.line(c, -1E4, b, 1E4, b);
      var f = this.xMin || 0, g = this.yMin || 0, k = this.xMax || 0, h = this.yMax || 0, m = this.advanceWidth || 0;
      c.strokeStyle = "blue";
      p.line(c, d + f * e, -1E4, d + f * e, 1E4);
      p.line(c, d + k * e, -1E4, d + k * e, 1E4);
      p.line(c, -1E4, b + -g * e, 1E4, b + -g * e);
      p.line(c, -1E4, b + -h * e, 1E4, b + -h * e);
      c.strokeStyle = "green";
      p.line(c, d + m * e, -1E4, d + m * e, 1E4);
    };
    h.Glyph = k;
  }, {"./check":2, "./draw":3, "./path":11}], 7:[function(d, g, h) {
    function e(c, d, e) {
      Object.defineProperty(c, d, {get:function() {
        return c.path, c[e];
      }, set:function(d) {
        c[e] = d;
      }, enumerable:!0, configurable:!0});
    }
    function k(c, d) {
      if (this.font = c, this.glyphs = {}, Array.isArray(d)) {
        for (c = 0; c < d.length; c++) {
          this.glyphs[c] = d[c];
        }
      }
      this.length = d && d.length || 0;
    }
    var c = d("./glyph");
    k.prototype.get = function(c) {
      return "function" == typeof this.glyphs[c] && (this.glyphs[c] = this.glyphs[c]()), this.glyphs[c];
    };
    k.prototype.push = function(c, d) {
      this.glyphs[c] = d;
      this.length++;
    };
    h.GlyphSet = k;
    h.glyphLoader = function(d, e) {
      return new c.Glyph({index:e, font:d});
    };
    h.ttfGlyphLoader = function(d, g, f, k, b, h) {
      return function() {
        var m = new c.Glyph({index:g, font:d});
        return m.path = function() {
          f(m, k, b);
          var c = h(d.glyphs, m);
          return c.unitsPerEm = d.unitsPerEm, c;
        }, e(m, "xMin", "_xMin"), e(m, "xMax", "_xMax"), e(m, "yMin", "_yMin"), e(m, "yMax", "_yMax"), m;
      };
    };
    h.cffGlyphLoader = function(d, e, f, g) {
      return function() {
        var b = new c.Glyph({index:e, font:d});
        return b.path = function() {
          var c = f(d, b, g);
          return c.unitsPerEm = d.unitsPerEm, c;
        }, b;
      };
    };
  }, {"./glyph":6}], 8:[function(d, g, h) {
    function e(c, d) {
      for (var e = 0, f = c.length - 1; f >= e;) {
        var g = e + f >>> 1, b = c[g].tag;
        if (b === d) {
          return g;
        }
        d > b ? e = g + 1 : f = g - 1;
      }
      return -e - 1;
    }
    var k = d("./check");
    g.exports = {searchTag:e, binSearch:function(c, d) {
      for (var e = 0, f = c.length - 1; f >= e;) {
        var g = e + f >>> 1, b = c[g];
        if (b === d) {
          return g;
        }
        d > b ? e = g + 1 : f = g - 1;
      }
      return -e - 1;
    }, getScriptNames:function() {
      var c = this.getGsubTable();
      return c ? c.scripts.map(function(c) {
        return c.tag;
      }) : [];
    }, getScriptTable:function(c, d) {
      var g = this.getGsubTable(d);
      if (g) {
        d = g.scripts;
        g = e(g.scripts, c);
        if (0 <= g) {
          return d[g].script;
        }
        c = {tag:c, script:{defaultLangSys:{reserved:0, reqFeatureIndex:65535, featureIndexes:[]}, langSysRecords:[]}};
        return d.splice(-1 - g, 0, c.script), c;
      }
    }, getLangSysTable:function(c, d, g) {
      if (c = this.getScriptTable(c, g)) {
        if ("DFLT" === d) {
          return c.defaultLangSys;
        }
        var f = e(c.langSysRecords, d);
        if (0 <= f) {
          return c.langSysRecords[f].langSys;
        }
        if (g) {
          return d = {tag:d, langSys:{reserved:0, reqFeatureIndex:65535, featureIndexes:[]}}, c.langSysRecords.splice(-1 - f, 0, d), d.langSys;
        }
      }
    }, getFeatureTable:function(c, d, e, f) {
      if (c = this.getLangSysTable(c, d, f)) {
        var g;
        c = c.featureIndexes;
        d = this.font.tables.gsub.features;
        for (var b = 0; b < c.length; b++) {
          if (g = d[c[b]], g.tag === e) {
            return g.feature;
          }
        }
        if (f) {
          return f = d.length, k.assert(0 === f || e >= d[f - 1].tag, "Features must be added in alphabetical order."), g = {tag:e, feature:{params:0, lookupListIndexes:[]}}, d.push(g), c.push(f), g.feature;
        }
      }
    }, getLookupTable:function(c, d, e, f, g) {
      if (c = this.getFeatureTable(c, d, e, g)) {
        var b;
        c = c.lookupListIndexes;
        d = this.font.tables.gsub.lookups;
        for (e = 0; e < c.length; e++) {
          if (b = d[c[e]], b.lookupType === f) {
            return b;
          }
        }
        if (g) {
          return b = {lookupType:f, lookupFlag:0, subtables:[], markFilteringSet:void 0}, f = d.length, d.push(b), c.push(f), b;
        }
      }
    }, expandCoverage:function(c) {
      if (1 === c.format) {
        return c.glyphs;
      }
      var d = [];
      c = c.ranges;
      for (var e = 0; c > e; e++) {
        var f = c[e], g = f.end;
        for (f = f.start; g >= f; f++) {
          d.push(f);
        }
      }
      return d;
    }};
  }, {"./check":2}], 9:[function(d, g, h) {
    function e(b, c) {
      d("fs").readFile(b, function(b, d) {
        return b ? c(b.message) : void c(null, y.nodeBufferToArrayBuffer(d));
      });
    }
    function k(b, c) {
      var d = new XMLHttpRequest;
      d.open("get", b, !0);
      d.responseType = "arraybuffer";
      d.onload = function() {
        return 200 !== d.status ? c("Font could not be loaded: " + d.statusText) : c(null, d.response);
      };
      d.send();
    }
    function c(b, c) {
      for (var d = [], e = 12, f = 0; c > f; f += 1) {
        var g = m.getTag(b, e), k = m.getULong(b, e + 4), h = m.getULong(b, e + 8), n = m.getULong(b, e + 12);
        d.push({tag:g, checksum:k, offset:h, length:n, compression:!1});
        e += 16;
      }
      return d;
    }
    function p(b, c) {
      if ("WOFF" === c.compression) {
        b = new Uint8Array(b.buffer, c.offset + 2, c.compressedLength - 2);
        var d = new Uint8Array(c.originalLength);
        if (f(b, d), d.byteLength !== c.originalLength) {
          throw Error("Decompression error: " + c.tag + " decompressed length doesn't match recorded length");
        }
        return {data:new DataView(d.buffer, 0), offset:0};
      }
      return {data:b, offset:c.offset};
    }
    function t(d) {
      var e = new b.Font({empty:!0});
      d = new DataView(d, 0);
      var f = m.getTag(d, 0);
      if (f === String.fromCharCode(0, 1, 0, 0)) {
        e.outlinesFormat = "truetype";
        f = m.getUShort(d, 4);
        var g = c(d, f);
      } else {
        if ("OTTO" === f) {
          e.outlinesFormat = "cff", f = m.getUShort(d, 4), g = c(d, f);
        } else {
          if ("wOFF" !== f) {
            throw Error("Unsupported OpenType signature " + f);
          }
          g = m.getTag(d, 4);
          if (g === String.fromCharCode(0, 1, 0, 0)) {
            e.outlinesFormat = "truetype";
          } else {
            if ("OTTO" !== g) {
              throw Error("Unsupported OpenType flavor " + f);
            }
            e.outlinesFormat = "cff";
          }
          g = f = m.getUShort(d, 12);
          for (var k = [], h = 44, q = 0; g > q; q += 1) {
            var t = m.getTag(d, h), y = m.getULong(d, h + 4), N = m.getULong(d, h + 8), fa = m.getULong(d, h + 12);
            k.push({tag:t, offset:y, compression:fa > N ? "WOFF" : !1, compressedLength:N, originalLength:fa});
            h += 20;
          }
          g = k;
        }
      }
      for (k = 0; f > k; k += 1) {
        switch(h = g[k], h.tag) {
          case "cmap":
            h = p(d, h);
            e.tables.cmap = x.parse(h.data, h.offset);
            e.encoding = new n.CmapEncoding(e.tables.cmap);
            break;
          case "fvar":
            var ja = h;
            break;
          case "head":
            h = p(d, h);
            e.tables.head = A.parse(h.data, h.offset);
            e.unitsPerEm = e.tables.head.unitsPerEm;
            var X = e.tables.head.indexToLocFormat;
            break;
          case "hhea":
            h = p(d, h);
            e.tables.hhea = D.parse(h.data, h.offset);
            e.ascender = e.tables.hhea.ascender;
            e.descender = e.tables.hhea.descender;
            e.numberOfHMetrics = e.tables.hhea.numberOfHMetrics;
            break;
          case "hmtx":
            var ea = h;
            break;
          case "ltag":
            h = p(d, h);
            var Y = E.parse(h.data, h.offset);
            break;
          case "maxp":
            h = p(d, h);
            e.tables.maxp = L.parse(h.data, h.offset);
            e.numGlyphs = e.tables.maxp.numGlyphs;
            break;
          case "name":
            var T = h;
            break;
          case "OS/2":
            h = p(d, h);
            e.tables.os2 = P.parse(h.data, h.offset);
            break;
          case "post":
            h = p(d, h);
            e.tables.post = J.parse(h.data, h.offset);
            e.glyphNames = new n.GlyphNames(e.tables.post);
            break;
          case "glyf":
            var ma = h;
            break;
          case "loca":
            var ka = h;
            break;
          case "CFF ":
            var ua = h;
            break;
          case "kern":
            var Aa = h;
            break;
          case "GPOS":
            var Ia = h;
            break;
          case "GSUB":
            var Ga = h;
            break;
          case "meta":
            var sa = h;
        }
      }
      T = p(d, T);
      if (e.tables.name = K.parse(T.data, T.offset, Y), e.names = e.tables.name, ma && ka) {
        X = 0 === X, ka = p(d, ka), ka = H.parse(ka.data, ka.offset, e.numGlyphs, X), ma = p(d, ma), e.glyphs = u.parse(ma.data, ma.offset, ka, e);
      } else {
        if (!ua) {
          throw Error("Font doesn't contain TrueType or CFF outlines.");
        }
        ma = p(d, ua);
        z.parse(ma.data, ma.offset, e);
      }
      ea = p(d, ea);
      (F.parse(ea.data, ea.offset, e.numberOfHMetrics, e.numGlyphs, e.glyphs), n.addGlyphNames(e), Aa) ? (Aa = p(d, Aa), e.kerningPairs = B.parse(Aa.data, Aa.offset)) : e.kerningPairs = {};
      Ia && (Ia = p(d, Ia), v.parse(Ia.data, Ia.offset, e));
      Ga && (Ga = p(d, Ga), e.tables.gsub = C.parse(Ga.data, Ga.offset));
      ja && (ja = p(d, ja), e.tables.fvar = r.parse(ja.data, ja.offset, e.names));
      sa && (sa = p(d, sa), e.tables.meta = I.parse(sa.data, sa.offset), e.metas = e.tables.meta);
      return e;
    }
    var f = d("tiny-inflate"), n = d("./encoding"), b = d("./font");
    g = d("./glyph");
    var m = d("./parse"), q = d("./path"), y = d("./util"), x = d("./tables/cmap"), z = d("./tables/cff"), r = d("./tables/fvar"), u = d("./tables/glyf"), v = d("./tables/gpos"), C = d("./tables/gsub"), A = d("./tables/head"), D = d("./tables/hhea"), F = d("./tables/hmtx"), B = d("./tables/kern"), E = d("./tables/ltag"), H = d("./tables/loca"), L = d("./tables/maxp"), K = d("./tables/name"), P = d("./tables/os2"), J = d("./tables/post"), I = d("./tables/meta");
    h._parse = m;
    h.Font = b.Font;
    h.Glyph = g.Glyph;
    h.Path = q.Path;
    h.parse = t;
    h.load = function(b, c) {
      ("undefined" == typeof window ? e : k)(b, function(b, d) {
        if (b) {
          return c(b);
        }
        try {
          var e = t(d);
        } catch (W) {
          return c(W, null);
        }
        return c(null, e);
      });
    };
    h.loadSync = function(b) {
      b = d("fs").readFileSync(b);
      return t(y.nodeBufferToArrayBuffer(b));
    };
  }, {"./encoding":4, "./font":5, "./glyph":6, "./parse":10, "./path":11, "./tables/cff":14, "./tables/cmap":15, "./tables/fvar":16, "./tables/glyf":17, "./tables/gpos":18, "./tables/gsub":19, "./tables/head":20, "./tables/hhea":21, "./tables/hmtx":22, "./tables/kern":23, "./tables/loca":24, "./tables/ltag":25, "./tables/maxp":26, "./tables/meta":27, "./tables/name":28, "./tables/os2":29, "./tables/post":30, "./util":33, fs:void 0, "tiny-inflate":1}], 10:[function(d, g, h) {
    function e(c, d) {
      return c.getUint16(d, !1);
    }
    function k(c, d) {
      this.data = c;
      this.offset = d;
      this.relativeOffset = 0;
    }
    var c = d("./check");
    h.getByte = function(c, d) {
      return c.getUint8(d);
    };
    h.getCard8 = h.getByte;
    h.getUShort = h.getCard16 = e;
    h.getShort = function(c, d) {
      return c.getInt16(d, !1);
    };
    h.getULong = function(c, d) {
      return c.getUint32(d, !1);
    };
    h.getFixed = function(c, d) {
      var b = c.getInt16(d, !1);
      c = c.getUint16(d + 2, !1);
      return b + c / 65535;
    };
    h.getTag = function(c, d) {
      for (var b = "", e = d; d + 4 > e; e += 1) {
        b += String.fromCharCode(c.getInt8(e));
      }
      return b;
    };
    h.getOffset = function(c, d, b) {
      for (var e = 0, f = 0; b > f; f += 1) {
        e <<= 8, e += c.getUint8(d + f);
      }
      return e;
    };
    h.getBytes = function(c, d, b) {
      for (var e = []; b > d; d += 1) {
        e.push(c.getUint8(d));
      }
      return e;
    };
    h.bytesToString = function(c) {
      for (var d = "", b = 0; b < c.length; b += 1) {
        d += String.fromCharCode(c[b]);
      }
      return d;
    };
    var p = {"byte":1, uShort:2, "short":2, uLong:4, fixed:4, longDateTime:8, tag:4};
    k.prototype.parseByte = function() {
      var c = this.data.getUint8(this.offset + this.relativeOffset);
      return this.relativeOffset += 1, c;
    };
    k.prototype.parseChar = function() {
      var c = this.data.getInt8(this.offset + this.relativeOffset);
      return this.relativeOffset += 1, c;
    };
    k.prototype.parseCard8 = k.prototype.parseByte;
    k.prototype.parseUShort = function() {
      var c = this.data.getUint16(this.offset + this.relativeOffset);
      return this.relativeOffset += 2, c;
    };
    k.prototype.parseCard16 = k.prototype.parseUShort;
    k.prototype.parseSID = k.prototype.parseUShort;
    k.prototype.parseOffset16 = k.prototype.parseUShort;
    k.prototype.parseShort = function() {
      var c = this.data.getInt16(this.offset + this.relativeOffset);
      return this.relativeOffset += 2, c;
    };
    k.prototype.parseF2Dot14 = function() {
      var c = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
      return this.relativeOffset += 2, c;
    };
    k.prototype.parseULong = function() {
      var c = h.getULong(this.data, this.offset + this.relativeOffset);
      return this.relativeOffset += 4, c;
    };
    k.prototype.parseFixed = function() {
      var c = h.getFixed(this.data, this.offset + this.relativeOffset);
      return this.relativeOffset += 4, c;
    };
    k.prototype.parseString = function(c) {
      var d = this.data, b = this.offset + this.relativeOffset, e = "";
      this.relativeOffset += c;
      for (var f = 0; c > f; f++) {
        e += String.fromCharCode(d.getUint8(b + f));
      }
      return e;
    };
    k.prototype.parseTag = function() {
      return this.parseString(4);
    };
    k.prototype.parseLongDateTime = function() {
      var c = h.getULong(this.data, this.offset + this.relativeOffset + 4);
      return c -= 2082844800, this.relativeOffset += 8, c;
    };
    k.prototype.parseVersion = function() {
      var c = e(this.data, this.offset + this.relativeOffset), d = e(this.data, this.offset + this.relativeOffset + 2);
      return this.relativeOffset += 4, c + d / 4096 / 10;
    };
    k.prototype.skip = function(c, d) {
      void 0 === d && (d = 1);
      this.relativeOffset += p[c] * d;
    };
    k.prototype.parseOffset16List = k.prototype.parseUShortList = function(c) {
      void 0 === c && (c = this.parseUShort());
      for (var d = Array(c), b = this.data, e = this.offset + this.relativeOffset, f = 0; c > f; f++) {
        d[f] = b.getUint16(e), e += 2;
      }
      return this.relativeOffset += 2 * c, d;
    };
    k.prototype.parseList = function(c, d) {
      d || (d = c, c = this.parseUShort());
      for (var b = Array(c), e = 0; c > e; e++) {
        b[e] = d.call(this);
      }
      return b;
    };
    k.prototype.parseRecordList = function(c, d) {
      d || (d = c, c = this.parseUShort());
      for (var b = Array(c), e = Object.keys(d), f = 0; c > f; f++) {
        for (var g = {}, k = 0; k < e.length; k++) {
          var h = e[k];
          g[h] = d[h].call(this);
        }
        b[f] = g;
      }
      return b;
    };
    k.prototype.parseStruct = function(c) {
      if ("function" == typeof c) {
        return c.call(this);
      }
      for (var d = Object.keys(c), b = {}, e = 0; e < d.length; e++) {
        var f = d[e];
        b[f] = c[f].call(this);
      }
      return b;
    };
    k.prototype.parsePointer = function(c) {
      var d = this.parseOffset16();
      return 0 < d ? (new k(this.data, this.offset + d)).parseStruct(c) : void 0;
    };
    k.prototype.parseListOfLists = function(c) {
      for (var d = this.parseOffset16List(), b = d.length, e = this.relativeOffset, f = Array(b), g = 0; b > g; g++) {
        var k = d[g];
        if (0 !== k) {
          if (this.relativeOffset = k, c) {
            for (var h = this.parseOffset16List(), p = Array(h.length), t = 0; t < h.length; t++) {
              this.relativeOffset = k + h[t], p[t] = c.call(this);
            }
            f[g] = p;
          } else {
            f[g] = this.parseUShortList();
          }
        } else {
          f[g] = void 0;
        }
      }
      return this.relativeOffset = e, f;
    };
    k.prototype.parseCoverage = function() {
      var d = this.offset + this.relativeOffset, e = this.parseUShort(), b = this.parseUShort();
      if (1 === e) {
        return {format:1, glyphs:this.parseUShortList(b)};
      }
      if (2 === e) {
        d = Array(b);
        for (e = 0; b > e; e++) {
          d[e] = {start:this.parseUShort(), end:this.parseUShort(), index:this.parseUShort()};
        }
        return {format:2, ranges:d};
      }
      c.assert(!1, "0x" + d.toString(16) + ": Coverage format must be 1 or 2.");
    };
    k.prototype.parseClassDef = function() {
      var d = this.offset + this.relativeOffset, e = this.parseUShort();
      return 1 === e ? {format:1, startGlyph:this.parseUShort(), classes:this.parseUShortList()} : 2 === e ? {format:2, ranges:this.parseRecordList({start:k.uShort, end:k.uShort, classId:k.uShort})} : void c.assert(!1, "0x" + d.toString(16) + ": ClassDef format must be 1 or 2.");
    };
    k.list = function(c, d) {
      return function() {
        return this.parseList(c, d);
      };
    };
    k.recordList = function(c, d) {
      return function() {
        return this.parseRecordList(c, d);
      };
    };
    k.pointer = function(c) {
      return function() {
        return this.parsePointer(c);
      };
    };
    k.tag = k.prototype.parseTag;
    k.byte = k.prototype.parseByte;
    k.uShort = k.offset16 = k.prototype.parseUShort;
    k.uShortList = k.prototype.parseUShortList;
    k.struct = k.prototype.parseStruct;
    k.coverage = k.prototype.parseCoverage;
    k.classDef = k.prototype.parseClassDef;
    var t = {reserved:k.uShort, reqFeatureIndex:k.uShort, featureIndexes:k.uShortList};
    k.prototype.parseScriptList = function() {
      return this.parsePointer(k.recordList({tag:k.tag, script:k.pointer({defaultLangSys:k.pointer(t), langSysRecords:k.recordList({tag:k.tag, langSys:k.pointer(t)})})}));
    };
    k.prototype.parseFeatureList = function() {
      return this.parsePointer(k.recordList({tag:k.tag, feature:k.pointer({featureParams:k.offset16, lookupListIndexes:k.uShortList})}));
    };
    k.prototype.parseLookupList = function(d) {
      return this.parsePointer(k.list(k.pointer(function() {
        var e = this.parseUShort();
        c.argument(1 <= e && 8 >= e, "GSUB lookup type " + e + " unknown.");
        var b = this.parseUShort(), f = 16 & b;
        return {lookupType:e, lookupFlag:b, subtables:this.parseList(k.pointer(d[e])), markFilteringSet:f ? this.parseUShort() : void 0};
      })));
    };
    h.Parser = k;
  }, {"./check":2}], 11:[function(d, g, h) {
    function e() {
      this.commands = [];
      this.fill = "black";
      this.stroke = null;
      this.strokeWidth = 1;
    }
    e.prototype.moveTo = function(d, c) {
      this.commands.push({type:"M", x:d, y:c});
    };
    e.prototype.lineTo = function(d, c) {
      this.commands.push({type:"L", x:d, y:c});
    };
    e.prototype.curveTo = e.prototype.bezierCurveTo = function(d, c, e, g, f, h) {
      this.commands.push({type:"C", x1:d, y1:c, x2:e, y2:g, x:f, y:h});
    };
    e.prototype.quadTo = e.prototype.quadraticCurveTo = function(d, c, e, g) {
      this.commands.push({type:"Q", x1:d, y1:c, x:e, y:g});
    };
    e.prototype.close = e.prototype.closePath = function() {
      this.commands.push({type:"Z"});
    };
    e.prototype.extend = function(d) {
      d.commands && (d = d.commands);
      Array.prototype.push.apply(this.commands, d);
    };
    e.prototype.draw = function(d) {
      d.beginPath();
      for (var c = 0; c < this.commands.length; c += 1) {
        var e = this.commands[c];
        "M" === e.type ? d.moveTo(e.x, e.y) : "L" === e.type ? d.lineTo(e.x, e.y) : "C" === e.type ? d.bezierCurveTo(e.x1, e.y1, e.x2, e.y2, e.x, e.y) : "Q" === e.type ? d.quadraticCurveTo(e.x1, e.y1, e.x, e.y) : "Z" === e.type && d.closePath();
      }
      this.fill && (d.fillStyle = this.fill, d.fill());
      this.stroke && (d.strokeStyle = this.stroke, d.lineWidth = this.strokeWidth, d.stroke());
    };
    e.prototype.toPathData = function(d) {
      function c() {
        for (var c = "", b = 0; b < arguments.length; b += 1) {
          var e = arguments[b];
          0 <= e && 0 < b && (c += " ");
          c += Math.round(e) === e ? "" + Math.round(e) : e.toFixed(d);
        }
        return c;
      }
      d = void 0 !== d ? d : 2;
      for (var e = "", g = 0; g < this.commands.length; g += 1) {
        var f = this.commands[g];
        "M" === f.type ? e += "M" + c(f.x, f.y) : "L" === f.type ? e += "L" + c(f.x, f.y) : "C" === f.type ? e += "C" + c(f.x1, f.y1, f.x2, f.y2, f.x, f.y) : "Q" === f.type ? e += "Q" + c(f.x1, f.y1, f.x, f.y) : "Z" === f.type && (e += "Z");
      }
      return e;
    };
    e.prototype.toSVG = function(d) {
      var c = '<path d="';
      return c += this.toPathData(d), c += '"', this.fill && "black" !== this.fill && (c += null === this.fill ? ' fill="none"' : ' fill="' + this.fill + '"'), this.stroke && (c += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"'), c + "/>";
    };
    h.Path = e;
  }, {}], 12:[function(d, g, h) {
    function e(c, d, e) {
      c = c.subtables;
      for (var f = 0; f < c.length; f++) {
        var g = c[f];
        if (g.substFormat === d) {
          return g;
        }
      }
      return e ? (c.push(e), e) : void 0;
    }
    var k = d("./check");
    d = d("./layout");
    h = function(c) {
      this.font = c;
    };
    h.prototype = d;
    h.prototype.getGsubTable = function(c) {
      var d = this.font.tables.gsub;
      return !d && c && (this.font.tables.gsub = d = {version:1, scripts:[{tag:"DFLT", script:{defaultLangSys:{reserved:0, reqFeatureIndex:65535, featureIndexes:[]}, langSysRecords:[]}}], features:[], lookups:[]}), d;
    };
    h.prototype.getSingle = function(c, d, e) {
      var f = [];
      c = this.getLookupTable(d, e, c, 1);
      if (!c) {
        return f;
      }
      c = c.subtables;
      for (d = 0; d < c.length; d++) {
        var g = c[d];
        e = this.expandCoverage(g.coverage);
        if (1 === g.substFormat) {
          var b = g.deltaGlyphId;
          for (g = 0; g < e.length; g++) {
            var k = e[g];
            f.push({sub:k, by:k + b});
          }
        } else {
          for (b = g.substitute, g = 0; g < e.length; g++) {
            f.push({sub:e[g], by:b[g]});
          }
        }
      }
      return f;
    };
    h.prototype.getAlternates = function(c, d, e) {
      var f = [];
      c = this.getLookupTable(d, e, c, 3);
      if (!c) {
        return f;
      }
      c = c.subtables;
      for (d = 0; d < c.length; d++) {
        var g = c[d];
        e = this.expandCoverage(g.coverage);
        g = g.alternateSets;
        for (var b = 0; b < e.length; b++) {
          f.push({sub:e[b], by:g[b]});
        }
      }
      return f;
    };
    h.prototype.getLigatures = function(c, d, e) {
      var f = [];
      c = this.getLookupTable(d, e, c, 4);
      if (!c) {
        return [];
      }
      c = c.subtables;
      for (d = 0; d < c.length; d++) {
        var g = c[d];
        e = this.expandCoverage(g.coverage);
        g = g.ligatureSets;
        for (var b = 0; b < e.length; b++) {
          for (var k = e[b], h = g[b], p = 0; p < h.length; p++) {
            var t = h[p];
            f.push({sub:[k].concat(t.components), by:t.ligGlyph});
          }
        }
      }
      return f;
    };
    h.prototype.addSingle = function(c, d, g, f) {
      c = this.getLookupTable(g, f, c, 1, !0);
      c = e(c, 2, {substFormat:2, coverage:{format:1, glyphs:[]}, substitute:[]});
      k.assert(1 === c.coverage.format, "Ligature: unable to modify coverage table format " + c.coverage.format);
      g = d.sub;
      f = this.binSearch(c.coverage.glyphs, g);
      0 > f && (f = -1 - f, c.coverage.glyphs.splice(f, 0, g), c.substitute.splice(f, 0, 0));
      c.substitute[f] = d.by;
    };
    h.prototype.addAlternate = function(c, d, g, f) {
      c = this.getLookupTable(g, f, c, 3, !0);
      c = e(c, 1, {substFormat:1, coverage:{format:1, glyphs:[]}, alternateSets:[]});
      k.assert(1 === c.coverage.format, "Ligature: unable to modify coverage table format " + c.coverage.format);
      g = d.sub;
      f = this.binSearch(c.coverage.glyphs, g);
      0 > f && (f = -1 - f, c.coverage.glyphs.splice(f, 0, g), c.alternateSets.splice(f, 0, 0));
      c.alternateSets[f] = d.by;
    };
    h.prototype.addLigature = function(c, d, e, f) {
      c = this.getLookupTable(e || "DFLT", f || "DFLT", c, 4, !0);
      (e = c.subtables[0]) || (e = {substFormat:1, coverage:{format:1, glyphs:[]}, ligatureSets:[]}, c.subtables[0] = e);
      k.assert(1 === e.coverage.format, "Ligature: unable to modify coverage table format " + e.coverage.format);
      f = d.sub[0];
      c = d.sub.slice(1);
      d = {ligGlyph:d.by, components:c};
      var g = this.binSearch(e.coverage.glyphs, f);
      if (0 <= g) {
        e = e.ligatureSets[g];
        for (f = 0; f < e.length; f++) {
          a: {
            g = e[f].components;
            var b = g.length;
            if (b !== c.length) {
              g = !1;
            } else {
              for (var h = 0; b > h; h++) {
                if (g[h] !== c[h]) {
                  g = !1;
                  break a;
                }
              }
              g = !0;
            }
          }
          if (g) {
            return;
          }
        }
        e.push(d);
      } else {
        g = -1 - g, e.coverage.glyphs.splice(g, 0, f), e.ligatureSets.splice(g, 0, [d]);
      }
    };
    h.prototype.getFeature = function(c, d, e) {
      if (d = d || "DFLT", e = e || "DFLT", /ss\d\d/.test(c)) {
        return this.getSingle(c, d, e);
      }
      switch(c) {
        case "aalt":
        case "salt":
          return this.getSingle(c, d, e).concat(this.getAlternates(c, d, e));
        case "dlig":
        case "liga":
        case "rlig":
          return this.getLigatures(c, d, e);
      }
    };
    h.prototype.add = function(c, d, e, f) {
      if (e = e || "DFLT", f = f || "DFLT", /ss\d\d/.test(c)) {
        return this.addSingle(c, d, e, f);
      }
      switch(c) {
        case "aalt":
        case "salt":
          return "number" == typeof d.by ? this.addSingle(c, d, e, f) : this.addAlternate(c, d, e, f);
        case "dlig":
        case "liga":
        case "rlig":
          return this.addLigature(c, d, e, f);
      }
    };
    g.exports = h;
  }, {"./check":2, "./layout":8}], 13:[function(d, g, h) {
    function e(b, c, d) {
      var e;
      for (e = 0; e < c.length; e += 1) {
        var f = c[e];
        this[f.name] = f.value;
      }
      if (this.tableName = b, this.fields = c, d) {
        for (b = Object.keys(d), e = 0; e < b.length; e += 1) {
          c = b[e], f = d[c], void 0 !== this[c] && (this[c] = f);
        }
      }
    }
    function k(b, c, d) {
      void 0 === d && (d = c.length);
      var e = Array(c.length + 1);
      e[0] = {name:b + "Count", type:"USHORT", value:d};
      for (d = 0; d < c.length; d++) {
        e[d + 1] = {name:b + d, type:"USHORT", value:c[d]};
      }
      return e;
    }
    function c(b, c, d) {
      var e = c.length, f = Array(e + 1);
      f[0] = {name:b + "Count", type:"USHORT", value:e};
      for (var g = 0; e > g; g++) {
        f[g + 1] = {name:b + g, type:"TABLE", value:d(c[g], g)};
      }
      return f;
    }
    function p(b, c, d) {
      var e = c.length, f = [];
      f[0] = {name:b + "Count", type:"USHORT", value:e};
      for (b = 0; e > b; b++) {
        f = f.concat(d(c[b], b));
      }
      return f;
    }
    function t(b) {
      1 === b.format ? e.call(this, "coverageTable", [{name:"coverageFormat", type:"USHORT", value:1}].concat(k("glyph", b.glyphs))) : m.assert(!1, "Can't create coverage table format 2 yet.");
    }
    function f(b) {
      e.call(this, "scriptListTable", p("scriptRecord", b, function(b, c) {
        var d = b.script, f = d.defaultLangSys;
        return m.assert(!!f, "Unable to write GSUB: script " + b.tag + " has no default language system."), [{name:"scriptTag" + c, type:"TAG", value:b.tag}, {name:"script" + c, type:"TABLE", value:new e("scriptTable", [{name:"defaultLangSys", type:"TABLE", value:new e("defaultLangSys", [{name:"lookupOrder", type:"USHORT", value:0}, {name:"reqFeatureIndex", type:"USHORT", value:f.reqFeatureIndex}].concat(k("featureIndex", f.featureIndexes)))}].concat(p("langSys", d.langSysRecords, function(b, c) {
          var d = b.langSys;
          return [{name:"langSysTag" + c, type:"TAG", value:b.tag}, {name:"langSys" + c, type:"TABLE", value:new e("langSys", [{name:"lookupOrder", type:"USHORT", value:0}, {name:"reqFeatureIndex", type:"USHORT", value:d.reqFeatureIndex}].concat(k("featureIndex", d.featureIndexes)))}];
        })))}];
      }));
    }
    function n(b) {
      e.call(this, "featureListTable", p("featureRecord", b, function(b, c) {
        var d = b.feature;
        return [{name:"featureTag" + c, type:"TAG", value:b.tag}, {name:"feature" + c, type:"TABLE", value:new e("featureTable", [{name:"featureParams", type:"USHORT", value:d.featureParams}].concat(k("lookupListIndex", d.lookupListIndexes)))}];
      }));
    }
    function b(b, d) {
      e.call(this, "lookupListTable", c("lookup", b, function(b) {
        var f = d[b.lookupType];
        return m.assert(!!f, "Unable to write GSUB lookup type " + b.lookupType + " tables."), new e("lookupTable", [{name:"lookupType", type:"USHORT", value:b.lookupType}, {name:"lookupFlag", type:"USHORT", value:b.lookupFlag}].concat(c("subtable", b.subtables, f)));
      }));
    }
    var m = d("./check"), q = d("./types").encode, y = d("./types").sizeOf;
    e.prototype.encode = function() {
      return q.TABLE(this);
    };
    e.prototype.sizeOf = function() {
      return y.TABLE(this);
    };
    t.prototype = Object.create(e.prototype);
    t.prototype.constructor = t;
    f.prototype = Object.create(e.prototype);
    f.prototype.constructor = f;
    n.prototype = Object.create(e.prototype);
    n.prototype.constructor = n;
    b.prototype = Object.create(e.prototype);
    b.prototype.constructor = b;
    h.Record = h.Table = e;
    h.Coverage = t;
    h.ScriptList = f;
    h.FeatureList = n;
    h.LookupList = b;
    h.ushortList = k;
    h.tableList = c;
    h.recordList = p;
  }, {"./check":2, "./types":32}], 14:[function(d, g, h) {
    function e(b, c) {
      if (b === c) {
        return !0;
      }
      if (Array.isArray(b) && Array.isArray(c)) {
        if (b.length !== c.length) {
          return !1;
        }
        for (var d = 0; d < b.length; d += 1) {
          if (!e(b[d], c[d])) {
            return !1;
          }
        }
        return !0;
      }
      return !1;
    }
    function k(b, c, d) {
      var e, f = [], g = [];
      var k = u.getCard16(b, c);
      if (0 !== k) {
        var h = u.getByte(b, c + 2);
        var m = c + (k + 1) * h + 2;
        var n = c + 3;
        for (e = 0; k + 1 > e; e += 1) {
          f.push(u.getOffset(b, n, h)), n += h;
        }
        k = m + f[k];
      } else {
        k = c + 2;
      }
      for (e = 0; e < f.length - 1; e += 1) {
        h = u.getBytes(b, m + f[e], m + f[e + 1]), d && (h = d(h)), g.push(h);
      }
      return {objects:g, startOffset:c, endOffset:k};
    }
    function c(b, c) {
      var d, e, f, g;
      if (28 === c) {
        return d = b.parseByte(), e = b.parseByte(), d << 8 | e;
      }
      if (29 === c) {
        return d = b.parseByte(), e = b.parseByte(), f = b.parseByte(), g = b.parseByte(), d << 24 | e << 16 | f << 8 | g;
      }
      if (30 === c) {
        c = "";
        for (d = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];;) {
          f = b.parseByte();
          e = f >> 4;
          f &= 15;
          if (15 === e) {
            break;
          }
          if (c += d[e], 15 === f) {
            break;
          }
          c += d[f];
        }
        return parseFloat(c);
      }
      if (32 <= c && 246 >= c) {
        return c - 139;
      }
      if (247 <= c && 250 >= c) {
        return d = b.parseByte(), 256 * (c - 247) + d + 108;
      }
      if (251 <= c && 254 >= c) {
        return d = b.parseByte(), 256 * -(c - 251) - d - 108;
      }
      throw Error("Invalid b0 " + c);
    }
    function p(b, d, e) {
      var f = new u.Parser(b, void 0 !== d ? d : 0);
      d = [];
      var g = [];
      for (e = void 0 !== e ? e : b.length; f.relativeOffset < e;) {
        b = f.parseByte(), 21 >= b ? (12 === b && (b = 1200 + f.parseByte()), d.push([b, g]), g = []) : g.push(c(f, b));
      }
      e = {};
      for (b = 0; b < d.length; b += 1) {
        f = d[b][0];
        g = d[b][1];
        if (g = 1 === g.length ? g[0] : g, e.hasOwnProperty(f)) {
          throw Error("Object " + e + " already has key " + f);
        }
        e[f] = g;
      }
      return e;
    }
    function t(b, c) {
      return 390 >= c ? z.cffStandardStrings[c] : b[c - 391];
    }
    function f(b, c, d) {
      for (var e = {}, f = 0; f < c.length; f += 1) {
        var g = c[f], k = b[g.op];
        void 0 === k && (k = void 0 !== g.value ? g.value : null);
        "SID" === g.type && (k = t(d, k));
        e[g.name] = k;
      }
      return e;
    }
    function n(b, c, d) {
      function e(b, c) {
        x && p.closePath();
        p.moveTo(b, c);
        x = !0;
      }
      function f() {
        0 !== q.length % 2 && !t && (u = q.shift() + b.nominalWidthX);
        r += q.length >> 1;
        q.length = 0;
        t = !0;
      }
      function g(d) {
        for (var v, A, C, B, D, F, I, E, J, N, H = 0; H < d.length;) {
          switch(D = d[H], H += 1, D) {
            case 1:
              f();
              break;
            case 3:
              f();
              break;
            case 4:
              1 < q.length && !t && (u = q.shift() + b.nominalWidthX, t = !0);
              z += q.pop();
              e(y, z);
              break;
            case 5:
              for (; 0 < q.length;) {
                y += q.shift(), z += q.shift(), p.lineTo(y, z);
              }
              break;
            case 6:
              for (; 0 < q.length && (y += q.shift(), p.lineTo(y, z), 0 !== q.length);) {
                z += q.shift(), p.lineTo(y, z);
              }
              break;
            case 7:
              for (; 0 < q.length && (z += q.shift(), p.lineTo(y, z), 0 !== q.length);) {
                y += q.shift(), p.lineTo(y, z);
              }
              break;
            case 8:
              for (; 0 < q.length;) {
                k = y + q.shift(), h = z + q.shift(), m = k + q.shift(), n = h + q.shift(), y = m + q.shift(), z = n + q.shift(), p.curveTo(k, h, m, n, y, z);
              }
              break;
            case 10:
              D = q.pop() + b.subrsBias;
              (D = b.subrs[D]) && g(D);
              break;
            case 11:
              return;
            case 12:
              switch(D = d[H], H += 1, D) {
                case 35:
                  k = y + q.shift();
                  h = z + q.shift();
                  m = k + q.shift();
                  n = h + q.shift();
                  D = m + q.shift();
                  F = n + q.shift();
                  I = D + q.shift();
                  E = F + q.shift();
                  J = I + q.shift();
                  N = E + q.shift();
                  y = J + q.shift();
                  z = N + q.shift();
                  q.shift();
                  p.curveTo(k, h, m, n, D, F);
                  p.curveTo(I, E, J, N, y, z);
                  break;
                case 34:
                  k = y + q.shift();
                  h = z;
                  m = k + q.shift();
                  n = h + q.shift();
                  D = m + q.shift();
                  F = n;
                  I = D + q.shift();
                  E = n;
                  J = I + q.shift();
                  N = z;
                  y = J + q.shift();
                  p.curveTo(k, h, m, n, D, F);
                  p.curveTo(I, E, J, N, y, z);
                  break;
                case 36:
                  k = y + q.shift();
                  h = z + q.shift();
                  m = k + q.shift();
                  n = h + q.shift();
                  D = m + q.shift();
                  F = n;
                  I = D + q.shift();
                  E = n;
                  J = I + q.shift();
                  N = E + q.shift();
                  y = J + q.shift();
                  p.curveTo(k, h, m, n, D, F);
                  p.curveTo(I, E, J, N, y, z);
                  break;
                case 37:
                  k = y + q.shift();
                  h = z + q.shift();
                  m = k + q.shift();
                  n = h + q.shift();
                  D = m + q.shift();
                  F = n + q.shift();
                  I = D + q.shift();
                  E = F + q.shift();
                  J = I + q.shift();
                  N = E + q.shift();
                  Math.abs(J - y) > Math.abs(N - z) ? y = J + q.shift() : z = N + q.shift();
                  p.curveTo(k, h, m, n, D, F);
                  p.curveTo(I, E, J, N, y, z);
                  break;
                default:
                  console.log("Glyph " + c.index + ": unknown operator 1200" + D), q.length = 0;
              }break;
            case 14:
              0 < q.length && !t && (u = q.shift() + b.nominalWidthX, t = !0);
              x && (p.closePath(), x = !1);
              break;
            case 18:
              f();
              break;
            case 19:
            case 20:
              f();
              H += r + 7 >> 3;
              break;
            case 21:
              2 < q.length && !t && (u = q.shift() + b.nominalWidthX, t = !0);
              z += q.pop();
              y += q.pop();
              e(y, z);
              break;
            case 22:
              1 < q.length && !t && (u = q.shift() + b.nominalWidthX, t = !0);
              y += q.pop();
              e(y, z);
              break;
            case 23:
              f();
              break;
            case 24:
              for (; 2 < q.length;) {
                k = y + q.shift(), h = z + q.shift(), m = k + q.shift(), n = h + q.shift(), y = m + q.shift(), z = n + q.shift(), p.curveTo(k, h, m, n, y, z);
              }
              y += q.shift();
              z += q.shift();
              p.lineTo(y, z);
              break;
            case 25:
              for (; 6 < q.length;) {
                y += q.shift(), z += q.shift(), p.lineTo(y, z);
              }
              k = y + q.shift();
              h = z + q.shift();
              m = k + q.shift();
              n = h + q.shift();
              y = m + q.shift();
              z = n + q.shift();
              p.curveTo(k, h, m, n, y, z);
              break;
            case 26:
              for (q.length % 2 && (y += q.shift()); 0 < q.length;) {
                k = y, h = z + q.shift(), m = k + q.shift(), n = h + q.shift(), y = m, z = n + q.shift(), p.curveTo(k, h, m, n, y, z);
              }
              break;
            case 27:
              for (q.length % 2 && (z += q.shift()); 0 < q.length;) {
                k = y + q.shift(), h = z, m = k + q.shift(), n = h + q.shift(), y = m + q.shift(), z = n, p.curveTo(k, h, m, n, y, z);
              }
              break;
            case 28:
              v = d[H];
              A = d[H + 1];
              q.push((v << 24 | A << 16) >> 16);
              H += 2;
              break;
            case 29:
              D = q.pop() + b.gsubrsBias;
              (D = b.gsubrs[D]) && g(D);
              break;
            case 30:
              for (; 0 < q.length && (k = y, h = z + q.shift(), m = k + q.shift(), n = h + q.shift(), y = m + q.shift(), z = n + (1 === q.length ? q.shift() : 0), p.curveTo(k, h, m, n, y, z), 0 !== q.length);) {
                k = y + q.shift(), h = z, m = k + q.shift(), n = h + q.shift(), z = n + q.shift(), y = m + (1 === q.length ? q.shift() : 0), p.curveTo(k, h, m, n, y, z);
              }
              break;
            case 31:
              for (; 0 < q.length && (k = y + q.shift(), h = z, m = k + q.shift(), n = h + q.shift(), z = n + q.shift(), y = m + (1 === q.length ? q.shift() : 0), p.curveTo(k, h, m, n, y, z), 0 !== q.length);) {
                k = y, h = z + q.shift(), m = k + q.shift(), n = h + q.shift(), y = m + q.shift(), z = n + (1 === q.length ? q.shift() : 0), p.curveTo(k, h, m, n, y, z);
              }
              break;
            default:
              32 > D ? console.log("Glyph " + c.index + ": unknown operator " + D) : 247 > D ? q.push(D - 139) : 251 > D ? (v = d[H], H += 1, q.push(256 * (D - 247) + v + 108)) : 255 > D ? (v = d[H], H += 1, q.push(256 * -(D - 251) - v - 108)) : (v = d[H], A = d[H + 1], C = d[H + 2], B = d[H + 3], H += 4, q.push((v << 24 | A << 16 | C << 8 | B) / 65536));
          }
        }
      }
      var k, h, m, n, p = new v.Path, q = [], r = 0, t = !1, u = b.defaultWidthX, x = !1, y = 0, z = 0;
      return g(d), c.advanceWidth = u, p;
    }
    function b(b) {
      return 1240 > b.length ? 107 : 33900 > b.length ? 1131 : 32768;
    }
    function m(b, c) {
      var d, e = z.cffStandardStrings.indexOf(b);
      return e = c.indexOf(b), 0 <= e ? d = e + z.cffStandardStrings.length : (d = z.cffStandardStrings.length + c.length, c.push(b)), d;
    }
    function q(b, c, d) {
      for (var f = {}, g = 0; g < b.length; g += 1) {
        var k = b[g], h = c[k.name];
        void 0 === h || e(h, k.value) || ("SID" === k.type && (h = m(h, d)), f[k.op] = {name:k.name, type:k.type, value:h});
      }
      return f;
    }
    function y(b, c) {
      var d = new C.Record("Top DICT", [{name:"dict", type:"DICT", value:{}}]);
      return d.dict = q(A, b, c), d;
    }
    function x(b) {
      var c = new C.Record("Top DICT INDEX", [{name:"topDicts", type:"INDEX", value:[]}]);
      return c.topDicts = [{name:"topDict_0", type:"TABLE", value:b}], c;
    }
    var z = d("../encoding"), r = d("../glyphset"), u = d("../parse"), v = d("../path"), C = d("../table"), A = [{name:"version", op:0, type:"SID"}, {name:"notice", op:1, type:"SID"}, {name:"copyright", op:1200, type:"SID"}, {name:"fullName", op:2, type:"SID"}, {name:"familyName", op:3, type:"SID"}, {name:"weight", op:4, type:"SID"}, {name:"isFixedPitch", op:1201, type:"number", value:0}, {name:"italicAngle", op:1202, type:"number", value:0}, {name:"underlinePosition", op:1203, type:"number", value:-100}, 
    {name:"underlineThickness", op:1204, type:"number", value:50}, {name:"paintType", op:1205, type:"number", value:0}, {name:"charstringType", op:1206, type:"number", value:2}, {name:"fontMatrix", op:1207, type:"real real real real real real".split(" "), value:[.001, 0, 0, .001, 0, 0]}, {name:"uniqueId", op:13, type:"number"}, {name:"fontBBox", op:5, type:["number", "number", "number", "number"], value:[0, 0, 0, 0]}, {name:"strokeWidth", op:1208, type:"number", value:0}, {name:"xuid", op:14, type:[], 
    value:null}, {name:"charset", op:15, type:"offset", value:0}, {name:"encoding", op:16, type:"offset", value:0}, {name:"charStrings", op:17, type:"offset", value:0}, {name:"private", op:18, type:["number", "offset"], value:[0, 0]}], D = [{name:"subrs", op:19, type:"offset", value:0}, {name:"defaultWidthX", op:20, type:"number", value:0}, {name:"nominalWidthX", op:21, type:"number", value:0}];
    h.parse = function(c, d, e) {
      e.tables.cff = {};
      var g = {};
      g = (g.formatMajor = u.getCard8(c, d), g.formatMinor = u.getCard8(c, d + 1), g.size = u.getCard8(c, d + 2), g.offsetSize = u.getCard8(c, d + 3), g.startOffset = d, g.endOffset = d + 4, g);
      g = k(c, g.endOffset, u.bytesToString);
      g = k(c, g.endOffset);
      var h = k(c, g.endOffset, u.bytesToString), m = k(c, h.endOffset);
      e.gsubrs = m.objects;
      e.gsubrsBias = b(e.gsubrs);
      m = new DataView((new Uint8Array(g.objects[0])).buffer);
      g = h.objects;
      m = p(m, 0, m.byteLength);
      m = f(m, A, g);
      e.tables.cff.topDict = m;
      g = d + m["private"][1];
      var q = h.objects;
      var v = p(c, g, m["private"][0]);
      q = f(v, D, q);
      (e.defaultWidthX = q.defaultWidthX, e.nominalWidthX = q.nominalWidthX, 0 !== q.subrs) ? (g = k(c, g + q.subrs), e.subrs = g.objects, e.subrsBias = b(e.subrs)) : (e.subrs = [], e.subrsBias = 0);
      g = k(c, d + m.charStrings);
      e.nGlyphs = g.objects.length;
      q = e.nGlyphs;
      v = h.objects;
      var x = new u.Parser(c, d + m.charset);
      --q;
      h = [".notdef"];
      var y = x.parseCard8();
      if (0 === y) {
        for (y = 0; q > y; y += 1) {
          var C = x.parseSID();
          h.push(t(v, C));
        }
      } else {
        if (1 === y) {
          for (; h.length <= q;) {
            C = x.parseSID();
            var B = x.parseCard8();
            for (y = 0; B >= y; y += 1) {
              h.push(t(v, C)), C += 1;
            }
          }
        } else {
          if (2 !== y) {
            throw Error("Unknown charset format " + y);
          }
          for (; h.length <= q;) {
            for (C = x.parseSID(), B = x.parseCard16(), y = 0; B >= y; y += 1) {
              h.push(t(v, C)), C += 1;
            }
          }
        }
      }
      if (0 === m.encoding) {
        c = new z.CffEncoding(z.cffStandardEncoding, h);
      } else {
        if (1 === m.encoding) {
          c = new z.CffEncoding(z.cffExpertEncoding, h);
        } else {
          q = {};
          c = new u.Parser(c, d + m.encoding);
          d = c.parseCard8();
          if (0 === d) {
            for (v = c.parseCard8(), d = 0; v > d; d += 1) {
              m = c.parseCard8(), q[m] = d;
            }
          } else {
            if (1 !== d) {
              throw Error("Unknown encoding format " + d);
            }
            v = c.parseCard8();
            m = 1;
            for (d = 0; v > d; d += 1) {
              for (x = c.parseCard8(), y = c.parseCard8(), C = x; x + y >= C; C += 1) {
                q[C] = m, m += 1;
              }
            }
          }
          c = new z.CffEncoding(q, h);
        }
      }
      e.cffEncoding = c;
      e.encoding = e.encoding || e.cffEncoding;
      e.glyphs = new r.GlyphSet(e);
      for (c = 0; c < e.nGlyphs; c += 1) {
        e.glyphs.push(c, r.cffGlyphLoader(e, c, n, g.objects[c]));
      }
    };
    h.make = function(b, c) {
      var d = new C.Table("CFF ", [{name:"header", type:"RECORD"}, {name:"nameIndex", type:"RECORD"}, {name:"topDictIndex", type:"RECORD"}, {name:"stringIndex", type:"RECORD"}, {name:"globalSubrIndex", type:"RECORD"}, {name:"charsets", type:"RECORD"}, {name:"charStringsIndex", type:"RECORD"}, {name:"privateDict", type:"RECORD"}]), e = 1 / c.unitsPerEm;
      e = {version:c.version, fullName:c.fullName, familyName:c.familyName, weight:c.weightName, fontBBox:c.fontBBox || [0, 0, 0, 0], fontMatrix:[e, 0, 0, e, 0, 0], charset:999, encoding:0, charStrings:999, "private":[0, 999]};
      for (var f = [], g = 1; g < b.length; g += 1) {
        var k = b.get(g);
        f.push(k.name);
      }
      k = [];
      d.header = new C.Record("Header", [{name:"major", type:"Card8", value:1}, {name:"minor", type:"Card8", value:0}, {name:"hdrSize", type:"Card8", value:4}, {name:"major", type:"Card8", value:1}]);
      c = [c.postScriptName];
      g = new C.Record("Name INDEX", [{name:"names", type:"INDEX", value:[]}]);
      g.names = [];
      for (var h = 0; h < c.length; h += 1) {
        g.names.push({name:"name_" + h, type:"NAME", value:c[h]});
      }
      d.nameIndex = g;
      c = y(e, k);
      d.topDictIndex = x(c);
      d.globalSubrIndex = new C.Record("Global Subr INDEX", [{name:"subrs", type:"INDEX", value:[]}]);
      g = new C.Record("Charsets", [{name:"format", type:"Card8", value:0}]);
      for (h = 0; h < f.length; h += 1) {
        var n = m(f[h], k);
        g.fields.push({name:"glyph_" + h, type:"SID", value:n});
      }
      d.charsets = g;
      f = new C.Record("CharStrings INDEX", [{name:"charStrings", type:"INDEX", value:[]}]);
      for (g = 0; g < b.length; g += 1) {
        h = b.get(g);
        n = [];
        var p = h.path;
        n.push({name:"width", type:"NUMBER", value:h.advanceWidth});
        for (var r = 0, t = 0, u = 0; u < p.commands.length; u += 1) {
          var v = p.commands[u];
          if ("Q" === v.type) {
            var z = 1 / 3, A = 2 / 3;
            v = {type:"C", x:v.x, y:v.y, x1:z * r + A * v.x1, y1:z * t + A * v.y1, x2:z * v.x + A * v.x1, y2:z * v.y + A * v.y1};
          }
          if ("M" === v.type) {
            r = Math.round(v.x - r), t = Math.round(v.y - t), n.push({name:"dx", type:"NUMBER", value:r}), n.push({name:"dy", type:"NUMBER", value:t}), n.push({name:"rmoveto", type:"OP", value:21}), r = Math.round(v.x), t = Math.round(v.y);
          } else {
            if ("L" === v.type) {
              r = Math.round(v.x - r), t = Math.round(v.y - t), n.push({name:"dx", type:"NUMBER", value:r}), n.push({name:"dy", type:"NUMBER", value:t}), n.push({name:"rlineto", type:"OP", value:5}), r = Math.round(v.x), t = Math.round(v.y);
            } else {
              if ("C" === v.type) {
                z = Math.round(v.x1 - r);
                A = Math.round(v.y1 - t);
                var B = Math.round(v.x2 - v.x1), F = Math.round(v.y2 - v.y1);
                r = Math.round(v.x - v.x2);
                t = Math.round(v.y - v.y2);
                n.push({name:"dx1", type:"NUMBER", value:z});
                n.push({name:"dy1", type:"NUMBER", value:A});
                n.push({name:"dx2", type:"NUMBER", value:B});
                n.push({name:"dy2", type:"NUMBER", value:F});
                n.push({name:"dx", type:"NUMBER", value:r});
                n.push({name:"dy", type:"NUMBER", value:t});
                n.push({name:"rrcurveto", type:"OP", value:8});
                r = Math.round(v.x);
                t = Math.round(v.y);
              }
            }
          }
        }
        n = (n.push({name:"endchar", type:"OP", value:14}), n);
        f.charStrings.push({name:h.name, type:"CHARSTRING", value:n});
      }
      d.charStringsIndex = f;
      b = new C.Record("Private DICT", [{name:"dict", type:"DICT", value:{}}]);
      b = (b.dict = q(D, {}, k), b);
      d.privateDict = b;
      b = new C.Record("String INDEX", [{name:"strings", type:"INDEX", value:[]}]);
      b.strings = [];
      for (f = 0; f < k.length; f += 1) {
        b.strings.push({name:"string_" + f, type:"STRING", value:k[f]});
      }
      d.stringIndex = b;
      b = d.header.sizeOf() + d.nameIndex.sizeOf() + d.topDictIndex.sizeOf() + d.stringIndex.sizeOf() + d.globalSubrIndex.sizeOf();
      return e.charset = b, e.encoding = 0, e.charStrings = e.charset + d.charsets.sizeOf(), e.private[1] = e.charStrings + d.charStringsIndex.sizeOf(), c = y(e, k), d.topDictIndex = x(c), d;
    };
  }, {"../encoding":4, "../glyphset":7, "../parse":10, "../path":11, "../table":13}], 15:[function(d, g, h) {
    function e(c, d, e) {
      c.segments.push({end:d, start:d, delta:-(d - e), offset:0});
    }
    var k = d("../check"), c = d("../parse"), p = d("../table");
    h.parse = function(d, e) {
      var f, b = {};
      b.version = c.getUShort(d, e);
      k.argument(0 === b.version, "cmap table version should be 0.");
      b.numTables = c.getUShort(d, e + 2);
      var g = -1;
      for (f = b.numTables - 1; 0 <= f; --f) {
        var h = c.getUShort(d, e + 4 + 8 * f), p = c.getUShort(d, e + 4 + 8 * f + 2);
        if (3 === h && (0 === p || 1 === p || 10 === p)) {
          g = c.getULong(d, e + 4 + 8 * f + 4);
          break;
        }
      }
      if (-1 === g) {
        return null;
      }
      f = new c.Parser(d, e + g);
      if (b.format = f.parseUShort(), 12 === b.format) {
        f.parseUShort();
        b.length = f.parseULong();
        b.language = f.parseULong();
        var t;
        b.groupCount = t = f.parseULong();
        b.glyphIndexMap = {};
        for (d = 0; t > d; d += 1) {
          for (p = f.parseULong(), g = f.parseULong(), h = f.parseULong(); g >= p; p += 1) {
            b.glyphIndexMap[p] = h, h++;
          }
        }
      } else {
        if (4 !== b.format) {
          throw Error("Only format 4 and 12 cmap tables are supported.");
        }
        var z = g;
        b.length = f.parseUShort();
        b.language = f.parseUShort();
        b.segCount = g = f.parseUShort() >> 1;
        f.skip("uShort", 3);
        b.glyphIndexMap = {};
        f = new c.Parser(d, e + z + 14);
        h = new c.Parser(d, e + z + 16 + 2 * g);
        p = new c.Parser(d, e + z + 16 + 4 * g);
        var r = new c.Parser(d, e + z + 16 + 6 * g);
        z = e + z + 16 + 8 * g;
        for (e = 0; g - 1 > e; e += 1) {
          for (var u = f.parseUShort(), v = h.parseUShort(), C = p.parseShort(), A = r.parseUShort(), D = v; u >= D; D += 1) {
            0 !== A ? (z = r.offset + r.relativeOffset - 2, z += A, z += 2 * (D - v), t = c.getUShort(d, z), 0 !== t && (t = t + C & 65535)) : t = D + C & 65535, b.glyphIndexMap[D] = t;
          }
        }
      }
      return b;
    };
    h.make = function(c) {
      var d, g = new p.Table("cmap", [{name:"version", type:"USHORT", value:0}, {name:"numTables", type:"USHORT", value:1}, {name:"platformID", type:"USHORT", value:3}, {name:"encodingID", type:"USHORT", value:1}, {name:"offset", type:"ULONG", value:12}, {name:"format", type:"USHORT", value:4}, {name:"length", type:"USHORT", value:0}, {name:"language", type:"USHORT", value:0}, {name:"segCountX2", type:"USHORT", value:0}, {name:"searchRange", type:"USHORT", value:0}, {name:"entrySelector", type:"USHORT", 
      value:0}, {name:"rangeShift", type:"USHORT", value:0}]);
      g.segments = [];
      for (d = 0; d < c.length; d += 1) {
        for (var b = c.get(d), k = 0; k < b.unicodes.length; k += 1) {
          e(g, b.unicodes[k], d);
        }
        g.segments = g.segments.sort(function(b, c) {
          return b.start - c.start;
        });
      }
      g.segments.push({end:65535, start:65535, delta:1, offset:0});
      c = g.segments.length;
      g.segCountX2 = 2 * c;
      g.searchRange = 2 * Math.pow(2, Math.floor(Math.log(c) / Math.log(2)));
      g.entrySelector = Math.log(g.searchRange / 2) / Math.log(2);
      g.rangeShift = g.segCountX2 - g.searchRange;
      b = [];
      k = [];
      var h = [], t = [], x = [];
      for (d = 0; c > d; d += 1) {
        var z = g.segments[d];
        b = b.concat({name:"end_" + d, type:"USHORT", value:z.end});
        k = k.concat({name:"start_" + d, type:"USHORT", value:z.start});
        h = h.concat({name:"idDelta_" + d, type:"SHORT", value:z.delta});
        t = t.concat({name:"idRangeOffset_" + d, type:"USHORT", value:z.offset});
        void 0 !== z.glyphId && (x = x.concat({name:"glyph_" + d, type:"USHORT", value:z.glyphId}));
      }
      return g.fields = g.fields.concat(b), g.fields.push({name:"reservedPad", type:"USHORT", value:0}), g.fields = g.fields.concat(k), g.fields = g.fields.concat(h), g.fields = g.fields.concat(t), g.fields = g.fields.concat(x), g.length = 2 * b.length + 16 + 2 * k.length + 2 * h.length + 2 * t.length + 2 * x.length, g;
    };
  }, {"../check":2, "../parse":10, "../table":13}], 16:[function(d, g, h) {
    function e(b, c) {
      var d = JSON.stringify(b), e = 256, f;
      for (f in c) {
        var g = parseInt(f);
        if (g && !(256 > g)) {
          if (JSON.stringify(c[f]) === d) {
            return g;
          }
          g >= e && (e = g + 1);
        }
      }
      return c[e] = b, e;
    }
    function k(b, c, d) {
      d = e(c.name, d);
      return [{name:"tag_" + b, type:"TAG", value:c.tag}, {name:"minValue_" + b, type:"FIXED", value:c.minValue << 16}, {name:"defaultValue_" + b, type:"FIXED", value:c.defaultValue << 16}, {name:"maxValue_" + b, type:"FIXED", value:c.maxValue << 16}, {name:"flags_" + b, type:"USHORT", value:0}, {name:"nameID_" + b, type:"USHORT", value:d}];
    }
    function c(b, c, d) {
      var e = {};
      b = new n.Parser(b, c);
      return e.tag = b.parseTag(), e.minValue = b.parseFixed(), e.defaultValue = b.parseFixed(), e.maxValue = b.parseFixed(), b.skip("uShort", 1), e.name = d[b.parseUShort()] || {}, e;
    }
    function p(b, c, d, f) {
      f = e(c.name, f);
      f = [{name:"nameID_" + b, type:"USHORT", value:f}, {name:"flags_" + b, type:"USHORT", value:0}];
      for (var g = 0; g < d.length; ++g) {
        var k = d[g].tag;
        f.push({name:"axis_" + b + " " + k, type:"FIXED", value:c.coordinates[k] << 16});
      }
      return f;
    }
    function t(b, c, d, e) {
      var f = {};
      b = new n.Parser(b, c);
      f.name = e[b.parseUShort()] || {};
      b.skip("uShort", 1);
      f.coordinates = {};
      for (e = 0; e < d.length; ++e) {
        f.coordinates[d[e].tag] = b.parseFixed();
      }
      return f;
    }
    var f = d("../check"), n = d("../parse"), b = d("../table");
    h.make = function(c, d) {
      var e = new b.Table("fvar", [{name:"version", type:"ULONG", value:65536}, {name:"offsetToData", type:"USHORT", value:0}, {name:"countSizePairs", type:"USHORT", value:2}, {name:"axisCount", type:"USHORT", value:c.axes.length}, {name:"axisSize", type:"USHORT", value:20}, {name:"instanceCount", type:"USHORT", value:c.instances.length}, {name:"instanceSize", type:"USHORT", value:4 + 4 * c.axes.length}]);
      e.offsetToData = e.sizeOf();
      for (var f = 0; f < c.axes.length; f++) {
        e.fields = e.fields.concat(k(f, c.axes[f], d));
      }
      for (f = 0; f < c.instances.length; f++) {
        e.fields = e.fields.concat(p(f, c.instances[f], c.axes, d));
      }
      return e;
    };
    h.parse = function(b, d, e) {
      var g = new n.Parser(b, d), k = g.parseULong();
      f.argument(65536 === k, "Unsupported fvar table version.");
      var h = g.parseOffset16();
      g.skip("uShort", 1);
      var m = g.parseUShort(), p = g.parseUShort();
      k = g.parseUShort();
      g = g.parseUShort();
      for (var q = [], y = 0; m > y; y++) {
        q.push(c(b, d + h + y * p, e));
      }
      y = [];
      d = d + h + m * p;
      for (h = 0; k > h; h++) {
        y.push(t(b, d + h * g, q, e));
      }
      return {axes:q, instances:y};
    };
  }, {"../check":2, "../parse":10, "../table":13}], 17:[function(d, g, h) {
    function e(b, c, d, e, f) {
      var g;
      return 0 < (c & e) ? (g = b.parseByte(), 0 === (c & f) && (g = -g), g = d + g) : g = 0 < (c & f) ? d : d + b.parseShort(), g;
    }
    function k(b, c, d) {
      c = new n.Parser(c, d);
      b.numberOfContours = c.parseShort();
      b._xMin = c.parseShort();
      b._yMin = c.parseShort();
      b._xMax = c.parseShort();
      b._yMax = c.parseShort();
      var f;
      if (0 < b.numberOfContours) {
        var g, k = b.endPointIndices = [];
        for (g = 0; g < b.numberOfContours; g += 1) {
          k.push(c.parseUShort());
        }
        b.instructionLength = c.parseUShort();
        b.instructions = [];
        for (g = 0; g < b.instructionLength; g += 1) {
          b.instructions.push(c.parseByte());
        }
        var h = k[k.length - 1] + 1;
        d = [];
        for (g = 0; h > g; g += 1) {
          if (f = c.parseByte(), d.push(f), 0 < (8 & f)) {
            for (var m = c.parseByte(), p = 0; m > p; p += 1) {
              d.push(f), g += 1;
            }
          }
        }
        if (t.argument(d.length === h, "Bad flags."), 0 < k.length) {
          p = [];
          if (0 < h) {
            for (g = 0; h > g; g += 1) {
              f = d[g], m = {}, m.onCurve = !!(1 & f), m.lastPointOfContour = 0 <= k.indexOf(g), p.push(m);
            }
            for (g = k = 0; h > g; g += 1) {
              f = d[g], m = p[g], m.x = e(c, f, k, 2, 16), k = m.x;
            }
            for (g = k = 0; h > g; g += 1) {
              f = d[g], m = p[g], m.y = e(c, f, k, 4, 32), k = m.y;
            }
          }
          b.points = p;
        } else {
          b.points = [];
        }
      } else {
        if (0 === b.numberOfContours) {
          b.points = [];
        } else {
          for (b.isComposite = !0, b.points = [], b.components = [], f = !0; f;) {
            d = c.parseUShort(), f = {glyphIndex:c.parseUShort(), xScale:1, scale01:0, scale10:0, yScale:1, dx:0, dy:0}, 0 < (1 & d) ? 0 < (2 & d) ? (f.dx = c.parseShort(), f.dy = c.parseShort()) : f.matchedPoints = [c.parseUShort(), c.parseUShort()] : 0 < (2 & d) ? (f.dx = c.parseChar(), f.dy = c.parseChar()) : f.matchedPoints = [c.parseByte(), c.parseByte()], 0 < (8 & d) ? f.xScale = f.yScale = c.parseF2Dot14() : 0 < (64 & d) ? (f.xScale = c.parseF2Dot14(), f.yScale = c.parseF2Dot14()) : 0 < (128 & 
            d) && (f.xScale = c.parseF2Dot14(), f.scale01 = c.parseF2Dot14(), f.scale10 = c.parseF2Dot14(), f.yScale = c.parseF2Dot14()), b.components.push(f), f = !!(32 & d);
          }
        }
      }
    }
    function c(b, c) {
      for (var d = [], e = 0; e < b.length; e += 1) {
        var f = b[e];
        d.push({x:c.xScale * f.x + c.scale01 * f.y + c.dx, y:c.scale10 * f.x + c.yScale * f.y + c.dy, onCurve:f.onCurve, lastPointOfContour:f.lastPointOfContour});
      }
      return d;
    }
    function p(d, e) {
      if (e.isComposite) {
        for (var f = 0; f < e.components.length; f += 1) {
          var g = e.components[f], k = d.get(g.glyphIndex);
          if (k.getPath(), k.points) {
            if (void 0 === g.matchedPoints) {
              k = c(k.points, g);
            } else {
              if (g.matchedPoints[0] > e.points.length - 1 || g.matchedPoints[1] > k.points.length - 1) {
                throw Error("Matched points out of range in " + e.name);
              }
              var h = e.points[g.matchedPoints[0]], m = k.points[g.matchedPoints[1]];
              g = {xScale:g.xScale, scale01:g.scale01, scale10:g.scale10, yScale:g.yScale, dx:0, dy:0};
              m = c([m], g)[0];
              g.dx = h.x - m.x;
              g.dy = h.y - m.y;
              k = c(k.points, g);
            }
            e.points = e.points.concat(k);
          }
        }
      }
      var n;
      e = e.points;
      d = new b.Path;
      if (e) {
        f = [];
        k = [];
        for (h = 0; h < e.length; h += 1) {
          m = e[h], k.push(m), m.lastPointOfContour && (f.push(k), k = []);
        }
        e = (t.argument(0 === k.length, "There are still points left in the current contour."), f);
        for (f = 0; f < e.length; f += 1) {
          var p;
          k = e[f];
          h = k[0];
          m = k[k.length - 1];
          h.onCurve ? (n = null, p = !0) : (h = m.onCurve ? m : {x:(h.x + m.x) / 2, y:(h.y + m.y) / 2}, n = h, p = !1);
          d.moveTo(h.x, h.y);
          for (g = p ? 1 : 0; g < k.length; g += 1) {
            var q = k[g], D = 0 === g ? h : k[g - 1];
            if (D.onCurve && q.onCurve) {
              d.lineTo(q.x, q.y);
            } else {
              if (D.onCurve && !q.onCurve) {
                n = q;
              } else {
                if (D.onCurve || q.onCurve) {
                  if (D.onCurve || !q.onCurve) {
                    throw Error("Invalid state.");
                  }
                  d.quadraticCurveTo(n.x, n.y, q.x, q.y);
                  n = null;
                } else {
                  d.quadraticCurveTo(D.x, D.y, (D.x + q.x) / 2, (D.y + q.y) / 2), n = q;
                }
              }
            }
          }
          h !== m && (n ? d.quadraticCurveTo(n.x, n.y, h.x, h.y) : d.lineTo(h.x, h.y));
        }
        n = (d.closePath(), d);
      } else {
        n = d;
      }
      return n;
    }
    var t = d("../check"), f = d("../glyphset"), n = d("../parse"), b = d("../path");
    h.parse = function(b, c, d, e) {
      var g, h = new f.GlyphSet(e);
      for (g = 0; g < d.length - 1; g += 1) {
        var m = d[g];
        m !== d[g + 1] ? h.push(g, f.ttfGlyphLoader(e, g, k, b, c + m, p)) : h.push(g, f.glyphLoader(e, g));
      }
      return h;
    };
  }, {"../check":2, "../glyphset":7, "../parse":10, "../path":11}], 18:[function(d, g, h) {
    function e(b, c) {
      b = new n.Parser(b, c);
      c = b.parseUShort();
      for (var d = [], e = 0; c > e; e++) {
        d[b.parseTag()] = {offset:b.parseUShort()};
      }
      return d;
    }
    function k(b, c) {
      b = new n.Parser(b, c);
      var d = b.parseUShort();
      c = b.parseUShort();
      if (1 === d) {
        return b.parseUShortList(c);
      }
      if (2 === d) {
        for (d = []; c--;) {
          for (var e = b.parseUShort(), f = b.parseUShort(), g = b.parseUShort(); f >= e; e++) {
            d[g++] = e;
          }
        }
        return d;
      }
    }
    function c(b, c) {
      b = new n.Parser(b, c);
      c = b.parseUShort();
      if (1 === c) {
        var d = b.parseUShort();
        c = b.parseUShort();
        var e = b.parseUShortList(c);
        return function(b) {
          return e[b - d] || 0;
        };
      }
      if (2 === c) {
        c = b.parseUShort();
        for (var f = [], g = [], k = [], h = 0; c > h; h++) {
          f[h] = b.parseUShort(), g[h] = b.parseUShort(), k[h] = b.parseUShort();
        }
        return function(b) {
          for (var c = 0, d = f.length - 1; d > c;) {
            var e = c + d + 1 >> 1;
            b < f[e] ? d = e - 1 : c = e;
          }
          return f[c] <= b && b <= g[c] ? k[c] || 0 : 0;
        };
      }
    }
    function p(b, d) {
      var e, f = new n.Parser(b, d), g = f.parseUShort(), h = f.parseUShort();
      h = k(b, d + h);
      var m = f.parseUShort(), p = f.parseUShort();
      if (4 === m && 0 === p) {
        var t = {};
        if (1 === g) {
          b = f.parseUShort();
          var C = [];
          d = f.parseOffset16List(b);
          for (g = 0; b > g; g++) {
            var A = d[g], D = t[A];
            if (!D) {
              for (D = {}, f.relativeOffset = A, A = f.parseUShort(); A--;) {
                var F = f.parseUShort();
                m && (e = f.parseShort());
                p && f.parseShort();
                D[F] = e;
              }
            }
            C[h[g]] = D;
          }
          return function(b, c) {
            return (b = C[b]) ? b[c] : void 0;
          };
        }
        if (2 === g) {
          D = f.parseUShort();
          A = f.parseUShort();
          t = f.parseUShort();
          g = f.parseUShort();
          var B = c(b, d + D), E = c(b, d + A), H = [];
          for (b = 0; t > b; b++) {
            for (d = H[b] = [], D = 0; g > D; D++) {
              m && (e = f.parseShort()), p && f.parseShort(), d[D] = e;
            }
          }
          var L = {};
          for (b = 0; b < h.length; b++) {
            L[h[b]] = 1;
          }
          return function(b, c) {
            if (L[b]) {
              return b = B(b), c = E(c), (b = H[b]) ? b[c] : void 0;
            }
          };
        }
      }
    }
    function t(b, c) {
      var d = new n.Parser(b, c), e = d.parseUShort(), f = d.parseUShort(), g = 16 & f, k = d.parseUShort(), h = d.parseOffset16List(k);
      d = {lookupType:e, lookupFlag:f, markFilteringSet:g ? d.parseUShort() : -1};
      if (2 === e) {
        var m = [];
        for (e = 0; k > e; e++) {
          m.push(p(b, c + h[e]));
        }
        d.getKerningValue = function(b, c) {
          for (var d = m.length; d--;) {
            var e = m[d](b, c);
            if (void 0 !== e) {
              return e;
            }
          }
          return 0;
        };
      }
      return d;
    }
    var f = d("../check"), n = d("../parse");
    h.parse = function(b, c, d) {
      var g = new n.Parser(b, c), k = g.parseFixed();
      f.argument(1 === k, "Unsupported GPOS table version.");
      e(b, c + g.parseUShort());
      e(b, c + g.parseUShort());
      var h = g.parseUShort();
      g.relativeOffset = h;
      k = g.parseUShort();
      g = g.parseOffset16List(k);
      c += h;
      for (h = 0; k > h; h++) {
        var m = t(b, c + g[h]);
        2 !== m.lookupType || d.getGposKerningValue || (d.getGposKerningValue = m.getKerningValue);
      }
    };
  }, {"../check":2, "../parse":10}], 19:[function(d, g, h) {
    var e = d("../check"), k = d("../parse").Parser, c = Array(9), p = d("../table");
    c[1] = function() {
      var c = this.offset + this.relativeOffset, b = this.parseUShort();
      return 1 === b ? {substFormat:1, coverage:this.parsePointer(k.coverage), deltaGlyphId:this.parseUShort()} : 2 === b ? {substFormat:2, coverage:this.parsePointer(k.coverage), substitute:this.parseOffset16List()} : void e.assert(!1, "0x" + c.toString(16) + ": lookup type 1 format must be 1 or 2.");
    };
    c[2] = function() {
      var c = this.parseUShort();
      return e.argument(1 === c, "GSUB Multiple Substitution Subtable identifier-format must be 1"), {substFormat:c, coverage:this.parsePointer(k.coverage), sequences:this.parseListOfLists()};
    };
    c[3] = function() {
      var c = this.parseUShort();
      return e.argument(1 === c, "GSUB Alternate Substitution Subtable identifier-format must be 1"), {substFormat:c, coverage:this.parsePointer(k.coverage), alternateSets:this.parseListOfLists()};
    };
    c[4] = function() {
      var c = this.parseUShort();
      return e.argument(1 === c, "GSUB ligature table identifier-format must be 1"), {substFormat:c, coverage:this.parsePointer(k.coverage), ligatureSets:this.parseListOfLists(function() {
        return {ligGlyph:this.parseUShort(), components:this.parseUShortList(this.parseUShort() - 1)};
      })};
    };
    var t = {sequenceIndex:k.uShort, lookupListIndex:k.uShort};
    c[5] = function() {
      var c = this.offset + this.relativeOffset, b = this.parseUShort();
      if (1 === b) {
        return {substFormat:b, coverage:this.parsePointer(k.coverage), ruleSets:this.parseListOfLists(function() {
          var b = this.parseUShort(), c = this.parseUShort();
          return {input:this.parseUShortList(b - 1), lookupRecords:this.parseRecordList(c, t)};
        })};
      }
      if (2 === b) {
        return {substFormat:b, coverage:this.parsePointer(k.coverage), classDef:this.parsePointer(k.classDef), classSets:this.parseListOfLists(function() {
          var b = this.parseUShort(), c = this.parseUShort();
          return {classes:this.parseUShortList(b - 1), lookupRecords:this.parseRecordList(c, t)};
        })};
      }
      if (3 === b) {
        c = this.parseUShort();
        var d = this.parseUShort();
        return {substFormat:b, coverages:this.parseList(c, k.pointer(k.coverage)), lookupRecords:this.parseRecordList(d, t)};
      }
      e.assert(!1, "0x" + c.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
    };
    c[6] = function() {
      var c = this.offset + this.relativeOffset, b = this.parseUShort();
      return 1 === b ? {substFormat:1, coverage:this.parsePointer(k.coverage), chainRuleSets:this.parseListOfLists(function() {
        return {backtrack:this.parseUShortList(), input:this.parseUShortList(this.parseShort() - 1), lookahead:this.parseUShortList(), lookupRecords:this.parseRecordList(t)};
      })} : 2 === b ? {substFormat:2, coverage:this.parsePointer(k.coverage), backtrackClassDef:this.parsePointer(k.classDef), inputClassDef:this.parsePointer(k.classDef), lookaheadClassDef:this.parsePointer(k.classDef), chainClassSet:this.parseListOfLists(function() {
        return {backtrack:this.parseUShortList(), input:this.parseUShortList(this.parseShort() - 1), lookahead:this.parseUShortList(), lookupRecords:this.parseRecordList(t)};
      })} : 3 === b ? {substFormat:3, backtrackCoverage:this.parseList(k.pointer(k.coverage)), inputCoverage:this.parseList(k.pointer(k.coverage)), lookaheadCoverage:this.parseList(k.pointer(k.coverage)), lookupRecords:this.parseRecordList(t)} : void e.assert(!1, "0x" + c.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
    };
    c[7] = function() {
      var d = this.parseUShort();
      e.argument(1 === d, "GSUB Extension Substitution subtable identifier-format must be 1");
      d = this.parseUShort();
      var b = new k(this.data, this.offset + this.parseULong());
      return {substFormat:1, lookupType:d, extension:c[d].call(b)};
    };
    c[8] = function() {
      var c = this.parseUShort();
      return e.argument(1 === c, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), {substFormat:c, coverage:this.parsePointer(k.coverage), backtrackCoverage:this.parseList(k.pointer(k.coverage)), lookaheadCoverage:this.parseList(k.pointer(k.coverage)), substitutes:this.parseUShortList()};
    };
    var f = Array(9);
    f[1] = function(c) {
      return 1 === c.substFormat ? new p.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:1}, {name:"coverage", type:"TABLE", value:new p.Coverage(c.coverage)}, {name:"deltaGlyphID", type:"USHORT", value:c.deltaGlyphId}]) : new p.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:2}, {name:"coverage", type:"TABLE", value:new p.Coverage(c.coverage)}].concat(p.ushortList("substitute", c.substitute)));
    };
    f[3] = function(c) {
      return e.assert(1 === c.substFormat, "Lookup type 3 substFormat must be 1."), new p.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:1}, {name:"coverage", type:"TABLE", value:new p.Coverage(c.coverage)}].concat(p.tableList("altSet", c.alternateSets, function(b) {
        return new p.Table("alternateSetTable", p.ushortList("alternate", b));
      })));
    };
    f[4] = function(c) {
      return e.assert(1 === c.substFormat, "Lookup type 4 substFormat must be 1."), new p.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:1}, {name:"coverage", type:"TABLE", value:new p.Coverage(c.coverage)}].concat(p.tableList("ligSet", c.ligatureSets, function(b) {
        return new p.Table("ligatureSetTable", p.tableList("ligature", b, function(b) {
          return new p.Table("ligatureTable", [{name:"ligGlyph", type:"USHORT", value:b.ligGlyph}].concat(p.ushortList("component", b.components, b.components.length + 1)));
        }));
      })));
    };
    h.parse = function(d, b) {
      d = new k(d, b || 0);
      b = d.parseVersion();
      return e.argument(1 === b, "Unsupported GSUB table version."), {version:b, scripts:d.parseScriptList(), features:d.parseFeatureList(), lookups:d.parseLookupList(c)};
    };
    h.make = function(c) {
      return new p.Table("GSUB", [{name:"version", type:"ULONG", value:65536}, {name:"scripts", type:"TABLE", value:new p.ScriptList(c.scripts)}, {name:"features", type:"TABLE", value:new p.FeatureList(c.features)}, {name:"lookups", type:"TABLE", value:new p.LookupList(c.lookups, f)}]);
    };
  }, {"../check":2, "../parse":10, "../table":13}], 20:[function(d, g, h) {
    var e = d("../check"), k = d("../parse"), c = d("../table");
    h.parse = function(c, d) {
      var f = {};
      c = new k.Parser(c, d);
      return f.version = c.parseVersion(), f.fontRevision = Math.round(1E3 * c.parseFixed()) / 1E3, f.checkSumAdjustment = c.parseULong(), f.magicNumber = c.parseULong(), e.argument(1594834165 === f.magicNumber, "Font header has wrong magic number."), f.flags = c.parseUShort(), f.unitsPerEm = c.parseUShort(), f.created = c.parseLongDateTime(), f.modified = c.parseLongDateTime(), f.xMin = c.parseShort(), f.yMin = c.parseShort(), f.xMax = c.parseShort(), f.yMax = c.parseShort(), f.macStyle = c.parseUShort(), 
      f.lowestRecPPEM = c.parseUShort(), f.fontDirectionHint = c.parseShort(), f.indexToLocFormat = c.parseShort(), f.glyphDataFormat = c.parseShort(), f;
    };
    h.make = function(d) {
      var e = Math.round((new Date).getTime() / 1E3) + 2082844800, f = e;
      return d.createdTimestamp && (f = d.createdTimestamp + 2082844800), new c.Table("head", [{name:"version", type:"FIXED", value:65536}, {name:"fontRevision", type:"FIXED", value:65536}, {name:"checkSumAdjustment", type:"ULONG", value:0}, {name:"magicNumber", type:"ULONG", value:1594834165}, {name:"flags", type:"USHORT", value:0}, {name:"unitsPerEm", type:"USHORT", value:1E3}, {name:"created", type:"LONGDATETIME", value:f}, {name:"modified", type:"LONGDATETIME", value:e}, {name:"xMin", type:"SHORT", 
      value:0}, {name:"yMin", type:"SHORT", value:0}, {name:"xMax", type:"SHORT", value:0}, {name:"yMax", type:"SHORT", value:0}, {name:"macStyle", type:"USHORT", value:0}, {name:"lowestRecPPEM", type:"USHORT", value:0}, {name:"fontDirectionHint", type:"SHORT", value:2}, {name:"indexToLocFormat", type:"SHORT", value:0}, {name:"glyphDataFormat", type:"SHORT", value:0}], d);
    };
  }, {"../check":2, "../parse":10, "../table":13}], 21:[function(d, g, h) {
    var e = d("../parse"), k = d("../table");
    h.parse = function(c, d) {
      var g = {};
      c = new e.Parser(c, d);
      return g.version = c.parseVersion(), g.ascender = c.parseShort(), g.descender = c.parseShort(), g.lineGap = c.parseShort(), g.advanceWidthMax = c.parseUShort(), g.minLeftSideBearing = c.parseShort(), g.minRightSideBearing = c.parseShort(), g.xMaxExtent = c.parseShort(), g.caretSlopeRise = c.parseShort(), g.caretSlopeRun = c.parseShort(), g.caretOffset = c.parseShort(), c.relativeOffset += 8, g.metricDataFormat = c.parseShort(), g.numberOfHMetrics = c.parseUShort(), g;
    };
    h.make = function(c) {
      return new k.Table("hhea", [{name:"version", type:"FIXED", value:65536}, {name:"ascender", type:"FWORD", value:0}, {name:"descender", type:"FWORD", value:0}, {name:"lineGap", type:"FWORD", value:0}, {name:"advanceWidthMax", type:"UFWORD", value:0}, {name:"minLeftSideBearing", type:"FWORD", value:0}, {name:"minRightSideBearing", type:"FWORD", value:0}, {name:"xMaxExtent", type:"FWORD", value:0}, {name:"caretSlopeRise", type:"SHORT", value:1}, {name:"caretSlopeRun", type:"SHORT", value:0}, {name:"caretOffset", 
      type:"SHORT", value:0}, {name:"reserved1", type:"SHORT", value:0}, {name:"reserved2", type:"SHORT", value:0}, {name:"reserved3", type:"SHORT", value:0}, {name:"reserved4", type:"SHORT", value:0}, {name:"metricDataFormat", type:"SHORT", value:0}, {name:"numberOfHMetrics", type:"USHORT", value:0}], c);
    };
  }, {"../parse":10, "../table":13}], 22:[function(d, g, h) {
    var e = d("../parse"), k = d("../table");
    h.parse = function(c, d, g, f, k) {
      var b, h;
      c = new e.Parser(c, d);
      for (d = 0; f > d; d += 1) {
        g > d && (b = c.parseUShort(), h = c.parseShort());
        var n = k.get(d);
        n.advanceWidth = b;
        n.leftSideBearing = h;
      }
    };
    h.make = function(c) {
      for (var d = new k.Table("hmtx", []), e = 0; e < c.length; e += 1) {
        var f = c.get(e), g = f.leftSideBearing || 0;
        d.fields.push({name:"advanceWidth_" + e, type:"USHORT", value:f.advanceWidth || 0});
        d.fields.push({name:"leftSideBearing_" + e, type:"SHORT", value:g});
      }
      return d;
    };
  }, {"../parse":10, "../table":13}], 23:[function(d, g, h) {
    var e = d("../check"), k = d("../parse");
    h.parse = function(c, d) {
      var g = {};
      c = new k.Parser(c, d);
      d = c.parseUShort();
      e.argument(0 === d, "Unsupported kern table version.");
      c.skip("uShort", 1);
      d = c.parseUShort();
      e.argument(0 === d, "Unsupported kern sub-table version.");
      c.skip("uShort", 2);
      d = c.parseUShort();
      c.skip("uShort", 3);
      for (var f = 0; d > f; f += 1) {
        var h = c.parseUShort(), b = c.parseUShort(), m = c.parseShort();
        g[h + "," + b] = m;
      }
      return g;
    };
  }, {"../check":2, "../parse":10}], 24:[function(d, g, h) {
    var e = d("../parse");
    h.parse = function(d, c, g, h) {
      d = new e.Parser(d, c);
      c = h ? d.parseUShort : d.parseULong;
      for (var f = [], k = 0; g + 1 > k; k += 1) {
        var b = c.call(d);
        h && (b *= 2);
        f.push(b);
      }
      return f;
    };
  }, {"../parse":10}], 25:[function(d, g, h) {
    var e = d("../check"), k = d("../parse"), c = d("../table");
    h.make = function(d) {
      for (var e = new c.Table("ltag", [{name:"version", type:"ULONG", value:1}, {name:"flags", type:"ULONG", value:0}, {name:"numTags", type:"ULONG", value:d.length}]), f = "", g = 12 + 4 * d.length, b = 0; b < d.length; ++b) {
        var k = f.indexOf(d[b]);
        0 > k && (k = f.length, f += d[b]);
        e.fields.push({name:"offset " + b, type:"USHORT", value:g + k});
        e.fields.push({name:"length " + b, type:"USHORT", value:d[b].length});
      }
      return e.fields.push({name:"stringPool", type:"CHARARRAY", value:f}), e;
    };
    h.parse = function(c, d) {
      var f = new k.Parser(c, d), g = f.parseULong();
      e.argument(1 === g, "Unsupported ltag table version.");
      f.skip("uLong", 1);
      g = f.parseULong();
      for (var b = [], h = 0; g > h; h++) {
        for (var p = "", t = d + f.parseUShort(), x = f.parseUShort(), z = t; t + x > z; ++z) {
          p += String.fromCharCode(c.getInt8(z));
        }
        b.push(p);
      }
      return b;
    };
  }, {"../check":2, "../parse":10, "../table":13}], 26:[function(d, g, h) {
    var e = d("../parse"), k = d("../table");
    h.parse = function(c, d) {
      var g = {};
      c = new e.Parser(c, d);
      return g.version = c.parseVersion(), g.numGlyphs = c.parseUShort(), 1 === g.version && (g.maxPoints = c.parseUShort(), g.maxContours = c.parseUShort(), g.maxCompositePoints = c.parseUShort(), g.maxCompositeContours = c.parseUShort(), g.maxZones = c.parseUShort(), g.maxTwilightPoints = c.parseUShort(), g.maxStorage = c.parseUShort(), g.maxFunctionDefs = c.parseUShort(), g.maxInstructionDefs = c.parseUShort(), g.maxStackElements = c.parseUShort(), g.maxSizeOfInstructions = c.parseUShort(), g.maxComponentElements = 
      c.parseUShort(), g.maxComponentDepth = c.parseUShort()), g;
    };
    h.make = function(c) {
      return new k.Table("maxp", [{name:"version", type:"FIXED", value:20480}, {name:"numGlyphs", type:"USHORT", value:c}]);
    };
  }, {"../parse":10, "../table":13}], 27:[function(d, g, h) {
    var e = d("../types").decode, k = d("../check"), c = d("../parse"), p = d("../table");
    h.parse = function(d, f) {
      var g = new c.Parser(d, f), b = g.parseULong();
      k.argument(1 === b, "Unsupported META table version.");
      g.parseULong();
      g.parseULong();
      b = g.parseULong();
      for (var h = {}, p = 0; b > p; p++) {
        var t = g.parseTag(), x = g.parseULong(), z = g.parseULong();
        x = e.UTF8(d, f + x, z);
        h[t] = x;
      }
      return h;
    };
    h.make = function(c) {
      var d = Object.keys(c).length, e = "", b = 16 + 12 * d;
      d = new p.Table("meta", [{name:"version", type:"ULONG", value:1}, {name:"flags", type:"ULONG", value:0}, {name:"offset", type:"ULONG", value:b}, {name:"numTags", type:"ULONG", value:d}]);
      for (var g in c) {
        var k = e.length;
        e += c[g];
        d.fields.push({name:"tag " + g, type:"TAG", value:g});
        d.fields.push({name:"offset " + g, type:"ULONG", value:b + k});
        d.fields.push({name:"length " + g, type:"ULONG", value:c[g].length});
      }
      return d.fields.push({name:"stringPool", type:"CHARARRAY", value:e}), d;
    };
  }, {"../check":2, "../parse":10, "../table":13, "../types":32}], 28:[function(d, g, h) {
    function e(b, c, d) {
      switch(b) {
        case 0:
          return z;
        case 1:
          return u[d] || r[c];
        case 3:
          if (1 === c || 10 === c) {
            return z;
          }
      }
    }
    function k(b) {
      var c = {}, d;
      for (d in b) {
        c[b[d]] = parseInt(d);
      }
      return c;
    }
    function c(c, d, e, f, g, k) {
      return new b.Record("NameRecord", [{name:"platformID", type:"USHORT", value:c}, {name:"encodingID", type:"USHORT", value:d}, {name:"languageID", type:"USHORT", value:e}, {name:"nameID", type:"USHORT", value:f}, {name:"length", type:"USHORT", value:g}, {name:"offset", type:"USHORT", value:k}]);
    }
    function p(b, c) {
      a: {
        var d = b.length;
        var e = c.length - d + 1, f = 0;
        b: for (; e > f; f++) {
          for (; e > f;) {
            for (var g = 0; d > g; g++) {
              if (c[f + g] !== b[g]) {
                continue b;
              }
            }
            d = f;
            break a;
          }
        }
        d = -1;
      }
      if (0 > d) {
        for (d = c.length, e = 0, f = b.length; f > e; ++e) {
          c.push(b[e]);
        }
      }
      return d;
    }
    g = d("../types");
    var t = g.decode, f = g.encode, n = d("../parse"), b = d("../table"), m = "copyright fontFamily fontSubfamily uniqueID fullName version postScriptName trademark manufacturer designer description manufacturerURL designerURL license licenseURL reserved preferredFamily preferredSubfamily compatibleFullName sampleText postScriptFindFontName wwsFamily wwsSubfamily".split(" "), q = {0:"en", 1:"fr", 2:"de", 3:"it", 4:"nl", 5:"sv", 6:"es", 7:"da", 8:"pt", 9:"no", 10:"he", 11:"ja", 12:"ar", 13:"fi", 14:"el", 
    15:"is", 16:"mt", 17:"tr", 18:"hr", 19:"zh-Hant", 20:"ur", 21:"hi", 22:"th", 23:"ko", 24:"lt", 25:"pl", 26:"hu", 27:"es", 28:"lv", 29:"se", 30:"fo", 31:"fa", 32:"ru", 33:"zh", 34:"nl-BE", 35:"ga", 36:"sq", 37:"ro", 38:"cz", 39:"sk", 40:"si", 41:"yi", 42:"sr", 43:"mk", 44:"bg", 45:"uk", 46:"be", 47:"uz", 48:"kk", 49:"az-Cyrl", 50:"az-Arab", 51:"hy", 52:"ka", 53:"mo", 54:"ky", 55:"tg", 56:"tk", 57:"mn-CN", 58:"mn", 59:"ps", 60:"ks", 61:"ku", 62:"sd", 63:"bo", 64:"ne", 65:"sa", 66:"mr", 67:"bn", 
    68:"as", 69:"gu", 70:"pa", 71:"or", 72:"ml", 73:"kn", 74:"ta", 75:"te", 76:"si", 77:"my", 78:"km", 79:"lo", 80:"vi", 81:"id", 82:"tl", 83:"ms", 84:"ms-Arab", 85:"am", 86:"ti", 87:"om", 88:"so", 89:"sw", 90:"rw", 91:"rn", 92:"ny", 93:"mg", 94:"eo", 128:"cy", 129:"eu", 130:"ca", 131:"la", 132:"qu", 133:"gn", 134:"ay", 135:"tt", 136:"ug", 137:"dz", 138:"jv", 139:"su", 140:"gl", 141:"af", 142:"br", 143:"iu", 144:"gd", 145:"gv", 146:"ga", 147:"to", 148:"el-polyton", 149:"kl", 150:"az", 151:"nn"}, 
    y = {0:0, 1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0, 8:0, 9:0, 10:5, 11:1, 12:4, 13:0, 14:6, 15:0, 16:0, 17:0, 18:0, 19:2, 20:4, 21:9, 22:21, 23:3, 24:29, 25:29, 26:29, 27:29, 28:29, 29:0, 30:0, 31:4, 32:7, 33:25, 34:0, 35:0, 36:0, 37:0, 38:29, 39:29, 40:0, 41:5, 42:7, 43:7, 44:7, 45:7, 46:7, 47:7, 48:7, 49:7, 50:4, 51:24, 52:23, 53:7, 54:7, 55:7, 56:7, 57:27, 58:7, 59:4, 60:4, 61:4, 62:4, 63:26, 64:9, 65:9, 66:9, 67:13, 68:13, 69:11, 70:10, 71:12, 72:17, 73:16, 74:14, 75:15, 76:18, 77:19, 78:20, 79:22, 
    80:30, 81:0, 82:0, 83:0, 84:4, 85:28, 86:28, 87:28, 88:0, 89:0, 90:0, 91:0, 92:0, 93:0, 94:0, 128:0, 129:0, 130:0, 131:0, 132:0, 133:0, 134:0, 135:7, 136:4, 137:26, 138:0, 139:0, 140:0, 141:0, 142:0, 143:28, 144:0, 145:0, 146:0, 147:0, 148:6, 149:0, 150:0, 151:0}, x = {1078:"af", 1052:"sq", 1156:"gsw", 1118:"am", 5121:"ar-DZ", 15361:"ar-BH", 3073:"ar", 2049:"ar-IQ", 11265:"ar-JO", 13313:"ar-KW", 12289:"ar-LB", 4097:"ar-LY", 6145:"ary", 8193:"ar-OM", 16385:"ar-QA", 1025:"ar-SA", 10241:"ar-SY", 
    7169:"aeb", 14337:"ar-AE", 9217:"ar-YE", 1067:"hy", 1101:"as", 2092:"az-Cyrl", 1068:"az", 1133:"ba", 1069:"eu", 1059:"be", 2117:"bn", 1093:"bn-IN", 8218:"bs-Cyrl", 5146:"bs", 1150:"br", 1026:"bg", 1027:"ca", 3076:"zh-HK", 5124:"zh-MO", 2052:"zh", 4100:"zh-SG", 1028:"zh-TW", 1155:"co", 1050:"hr", 4122:"hr-BA", 1029:"cs", 1030:"da", 1164:"prs", 1125:"dv", 2067:"nl-BE", 1043:"nl", 3081:"en-AU", 10249:"en-BZ", 4105:"en-CA", 9225:"en-029", 16393:"en-IN", 6153:"en-IE", 8201:"en-JM", 17417:"en-MY", 
    5129:"en-NZ", 13321:"en-PH", 18441:"en-SG", 7177:"en-ZA", 11273:"en-TT", 2057:"en-GB", 1033:"en", 12297:"en-ZW", 1061:"et", 1080:"fo", 1124:"fil", 1035:"fi", 2060:"fr-BE", 3084:"fr-CA", 1036:"fr", 5132:"fr-LU", 6156:"fr-MC", 4108:"fr-CH", 1122:"fy", 1110:"gl", 1079:"ka", 3079:"de-AT", 1031:"de", 5127:"de-LI", 4103:"de-LU", 2055:"de-CH", 1032:"el", 1135:"kl", 1095:"gu", 1128:"ha", 1037:"he", 1081:"hi", 1038:"hu", 1039:"is", 1136:"ig", 1057:"id", 1117:"iu", 2141:"iu-Latn", 2108:"ga", 1076:"xh", 
    1077:"zu", 1040:"it", 2064:"it-CH", 1041:"ja", 1099:"kn", 1087:"kk", 1107:"km", 1158:"quc", 1159:"rw", 1089:"sw", 1111:"kok", 1042:"ko", 1088:"ky", 1108:"lo", 1062:"lv", 1063:"lt", 2094:"dsb", 1134:"lb", 1071:"mk", 2110:"ms-BN", 1086:"ms", 1100:"ml", 1082:"mt", 1153:"mi", 1146:"arn", 1102:"mr", 1148:"moh", 1104:"mn", 2128:"mn-CN", 1121:"ne", 1044:"nb", 2068:"nn", 1154:"oc", 1096:"or", 1123:"ps", 1045:"pl", 1046:"pt", 2070:"pt-PT", 1094:"pa", 1131:"qu-BO", 2155:"qu-EC", 3179:"qu", 1048:"ro", 1047:"rm", 
    1049:"ru", 9275:"smn", 4155:"smj-NO", 5179:"smj", 3131:"se-FI", 1083:"se", 2107:"se-SE", 8251:"sms", 6203:"sma-NO", 7227:"sms", 1103:"sa", 7194:"sr-Cyrl-BA", 3098:"sr", 6170:"sr-Latn-BA", 2074:"sr-Latn", 1132:"nso", 1074:"tn", 1115:"si", 1051:"sk", 1060:"sl", 11274:"es-AR", 16394:"es-BO", 13322:"es-CL", 9226:"es-CO", 5130:"es-CR", 7178:"es-DO", 12298:"es-EC", 17418:"es-SV", 4106:"es-GT", 18442:"es-HN", 2058:"es-MX", 19466:"es-NI", 6154:"es-PA", 15370:"es-PY", 10250:"es-PE", 20490:"es-PR", 3082:"es", 
    1034:"es", 21514:"es-US", 14346:"es-UY", 8202:"es-VE", 2077:"sv-FI", 1053:"sv", 1114:"syr", 1064:"tg", 2143:"tzm", 1097:"ta", 1092:"tt", 1098:"te", 1054:"th", 1105:"bo", 1055:"tr", 1090:"tk", 1152:"ug", 1058:"uk", 1070:"hsb", 1056:"ur", 2115:"uz-Cyrl", 1091:"uz", 1066:"vi", 1106:"cy", 1160:"wo", 1157:"sah", 1144:"ii", 1130:"yo"}, z = "utf-16", r = {0:"macintosh", 1:"x-mac-japanese", 2:"x-mac-chinesetrad", 3:"x-mac-korean", 6:"x-mac-greek", 7:"x-mac-cyrillic", 9:"x-mac-devanagai", 10:"x-mac-gurmukhi", 
    11:"x-mac-gujarati", 12:"x-mac-oriya", 13:"x-mac-bengali", 14:"x-mac-tamil", 15:"x-mac-telugu", 16:"x-mac-kannada", 17:"x-mac-malayalam", 18:"x-mac-sinhalese", 19:"x-mac-burmese", 20:"x-mac-khmer", 21:"x-mac-thai", 22:"x-mac-lao", 23:"x-mac-georgian", 24:"x-mac-armenian", 25:"x-mac-chinesesimp", 26:"x-mac-tibetan", 27:"x-mac-mongolian", 28:"x-mac-ethiopic", 29:"x-mac-ce", 30:"x-mac-vietnamese", 31:"x-mac-extarabic"}, u = {15:"x-mac-icelandic", 17:"x-mac-turkish", 18:"x-mac-croatian", 24:"x-mac-ce", 
    25:"x-mac-ce", 26:"x-mac-ce", 27:"x-mac-ce", 28:"x-mac-ce", 30:"x-mac-icelandic", 37:"x-mac-romanian", 38:"x-mac-ce", 39:"x-mac-ce", 40:"x-mac-ce", 143:"x-mac-inuit", 146:"x-mac-gaelic"};
    h.parse = function(b, c, d) {
      var f = {};
      c = new n.Parser(b, c);
      for (var g = c.parseUShort(), k = c.parseUShort(), h = c.offset + c.parseUShort(), p = 0; k > p; p++) {
        var r = c.parseUShort(), u = c.parseUShort(), v = c.parseUShort(), y = c.parseUShort();
        y = m[y] || y;
        var A = c.parseUShort(), C = c.parseUShort();
        a: {
          switch(r) {
            case 0:
              if (65535 === v) {
                var S = "und";
                break a;
              }
              if (d) {
                S = d[v];
                break a;
              }
              break;
            case 1:
              S = q[v];
              break a;
            case 3:
              S = x[v];
              break a;
          }
          S = void 0;
        }
        r = e(r, u, v);
        void 0 !== r && void 0 !== S && (r = r === z ? t.UTF16(b, h + C, A) : t.MACSTRING(b, h + C, A, r)) && (u = f[y], void 0 === u && (u = f[y] = {}), u[S] = r);
      }
      return 1 === g && c.parseUShort(), f;
    };
    h.make = function(d, g) {
      var h, n = [], r = {}, t = k(m);
      for (v in d) {
        var u = t[v];
        if (void 0 === u && (u = v), h = parseInt(u), isNaN(h)) {
          throw Error('Name table entry "' + v + '" does not exist, see nameTableNames for complete list.');
        }
        r[h] = d[v];
        n.push(h);
      }
      var v = k(q);
      u = k(x);
      d = [];
      t = [];
      for (var z = 0; z < n.length; z++) {
        h = n[z];
        var C = r[h], P;
        for (P in C) {
          var J = C[P], I = 1, N = v[P], S = y[N], Q = e(I, S, N);
          Q = f.MACSTRING(J, Q);
          void 0 === Q && (I = 0, N = g.indexOf(P), 0 > N && (N = g.length, g.push(P)), S = 4, Q = f.UTF16(J));
          var Z = p(Q, t);
          d.push(c(I, S, N, h, Q.length, Z));
          I = u[P];
          void 0 !== I && (J = f.UTF16(J), N = p(J, t), d.push(c(3, 1, I, h, J.length, N)));
        }
      }
      d.sort(function(b, c) {
        return b.platformID - c.platformID || b.encodingID - c.encodingID || b.languageID - c.languageID || b.nameID - c.nameID;
      });
      g = new b.Table("name", [{name:"format", type:"USHORT", value:0}, {name:"count", type:"USHORT", value:d.length}, {name:"stringOffset", type:"USHORT", value:6 + 12 * d.length}]);
      for (h = 0; h < d.length; h++) {
        g.fields.push({name:"record_" + h, type:"RECORD", value:d[h]});
      }
      return g.fields.push({name:"strings", type:"LITERAL", value:t}), g;
    };
  }, {"../parse":10, "../table":13, "../types":32}], 29:[function(d, g, h) {
    var e = d("../parse"), k = d("../table"), c = [{begin:0, end:127}, {begin:128, end:255}, {begin:256, end:383}, {begin:384, end:591}, {begin:592, end:687}, {begin:688, end:767}, {begin:768, end:879}, {begin:880, end:1023}, {begin:11392, end:11519}, {begin:1024, end:1279}, {begin:1328, end:1423}, {begin:1424, end:1535}, {begin:42240, end:42559}, {begin:1536, end:1791}, {begin:1984, end:2047}, {begin:2304, end:2431}, {begin:2432, end:2559}, {begin:2560, end:2687}, {begin:2688, end:2815}, {begin:2816, 
    end:2943}, {begin:2944, end:3071}, {begin:3072, end:3199}, {begin:3200, end:3327}, {begin:3328, end:3455}, {begin:3584, end:3711}, {begin:3712, end:3839}, {begin:4256, end:4351}, {begin:6912, end:7039}, {begin:4352, end:4607}, {begin:7680, end:7935}, {begin:7936, end:8191}, {begin:8192, end:8303}, {begin:8304, end:8351}, {begin:8352, end:8399}, {begin:8400, end:8447}, {begin:8448, end:8527}, {begin:8528, end:8591}, {begin:8592, end:8703}, {begin:8704, end:8959}, {begin:8960, end:9215}, {begin:9216, 
    end:9279}, {begin:9280, end:9311}, {begin:9312, end:9471}, {begin:9472, end:9599}, {begin:9600, end:9631}, {begin:9632, end:9727}, {begin:9728, end:9983}, {begin:9984, end:10175}, {begin:12288, end:12351}, {begin:12352, end:12447}, {begin:12448, end:12543}, {begin:12544, end:12591}, {begin:12592, end:12687}, {begin:43072, end:43135}, {begin:12800, end:13055}, {begin:13056, end:13311}, {begin:44032, end:55215}, {begin:55296, end:57343}, {begin:67840, end:67871}, {begin:19968, end:40959}, {begin:57344, 
    end:63743}, {begin:12736, end:12783}, {begin:64256, end:64335}, {begin:64336, end:65023}, {begin:65056, end:65071}, {begin:65040, end:65055}, {begin:65104, end:65135}, {begin:65136, end:65279}, {begin:65280, end:65519}, {begin:65520, end:65535}, {begin:3840, end:4095}, {begin:1792, end:1871}, {begin:1920, end:1983}, {begin:3456, end:3583}, {begin:4096, end:4255}, {begin:4608, end:4991}, {begin:5024, end:5119}, {begin:5120, end:5759}, {begin:5760, end:5791}, {begin:5792, end:5887}, {begin:6016, 
    end:6143}, {begin:6144, end:6319}, {begin:10240, end:10495}, {begin:40960, end:42127}, {begin:5888, end:5919}, {begin:66304, end:66351}, {begin:66352, end:66383}, {begin:66560, end:66639}, {begin:118784, end:119039}, {begin:119808, end:120831}, {begin:1044480, end:1048573}, {begin:65024, end:65039}, {begin:917504, end:917631}, {begin:6400, end:6479}, {begin:6480, end:6527}, {begin:6528, end:6623}, {begin:6656, end:6687}, {begin:11264, end:11359}, {begin:11568, end:11647}, {begin:19904, end:19967}, 
    {begin:43008, end:43055}, {begin:65536, end:65663}, {begin:65856, end:65935}, {begin:66432, end:66463}, {begin:66464, end:66527}, {begin:66640, end:66687}, {begin:66688, end:66735}, {begin:67584, end:67647}, {begin:68096, end:68191}, {begin:119552, end:119647}, {begin:73728, end:74751}, {begin:119648, end:119679}, {begin:7040, end:7103}, {begin:7168, end:7247}, {begin:7248, end:7295}, {begin:43136, end:43231}, {begin:43264, end:43311}, {begin:43312, end:43359}, {begin:43520, end:43615}, {begin:65936, 
    end:65999}, {begin:66E3, end:66047}, {begin:66208, end:66271}, {begin:127024, end:127135}];
    h.unicodeRanges = c;
    h.getUnicodeRange = function(d) {
      for (var e = 0; e < c.length; e += 1) {
        var f = c[e];
        if (d >= f.begin && d < f.end) {
          return e;
        }
      }
      return -1;
    };
    h.parse = function(c, d) {
      var f = {};
      c = new e.Parser(c, d);
      f.version = c.parseUShort();
      f.xAvgCharWidth = c.parseShort();
      f.usWeightClass = c.parseUShort();
      f.usWidthClass = c.parseUShort();
      f.fsType = c.parseUShort();
      f.ySubscriptXSize = c.parseShort();
      f.ySubscriptYSize = c.parseShort();
      f.ySubscriptXOffset = c.parseShort();
      f.ySubscriptYOffset = c.parseShort();
      f.ySuperscriptXSize = c.parseShort();
      f.ySuperscriptYSize = c.parseShort();
      f.ySuperscriptXOffset = c.parseShort();
      f.ySuperscriptYOffset = c.parseShort();
      f.yStrikeoutSize = c.parseShort();
      f.yStrikeoutPosition = c.parseShort();
      f.sFamilyClass = c.parseShort();
      f.panose = [];
      for (d = 0; 10 > d; d++) {
        f.panose[d] = c.parseByte();
      }
      return f.ulUnicodeRange1 = c.parseULong(), f.ulUnicodeRange2 = c.parseULong(), f.ulUnicodeRange3 = c.parseULong(), f.ulUnicodeRange4 = c.parseULong(), f.achVendID = String.fromCharCode(c.parseByte(), c.parseByte(), c.parseByte(), c.parseByte()), f.fsSelection = c.parseUShort(), f.usFirstCharIndex = c.parseUShort(), f.usLastCharIndex = c.parseUShort(), f.sTypoAscender = c.parseShort(), f.sTypoDescender = c.parseShort(), f.sTypoLineGap = c.parseShort(), f.usWinAscent = c.parseUShort(), f.usWinDescent = 
      c.parseUShort(), 1 <= f.version && (f.ulCodePageRange1 = c.parseULong(), f.ulCodePageRange2 = c.parseULong()), 2 <= f.version && (f.sxHeight = c.parseShort(), f.sCapHeight = c.parseShort(), f.usDefaultChar = c.parseUShort(), f.usBreakChar = c.parseUShort(), f.usMaxContent = c.parseUShort()), f;
    };
    h.make = function(c) {
      return new k.Table("OS/2", [{name:"version", type:"USHORT", value:3}, {name:"xAvgCharWidth", type:"SHORT", value:0}, {name:"usWeightClass", type:"USHORT", value:0}, {name:"usWidthClass", type:"USHORT", value:0}, {name:"fsType", type:"USHORT", value:0}, {name:"ySubscriptXSize", type:"SHORT", value:650}, {name:"ySubscriptYSize", type:"SHORT", value:699}, {name:"ySubscriptXOffset", type:"SHORT", value:0}, {name:"ySubscriptYOffset", type:"SHORT", value:140}, {name:"ySuperscriptXSize", type:"SHORT", 
      value:650}, {name:"ySuperscriptYSize", type:"SHORT", value:699}, {name:"ySuperscriptXOffset", type:"SHORT", value:0}, {name:"ySuperscriptYOffset", type:"SHORT", value:479}, {name:"yStrikeoutSize", type:"SHORT", value:49}, {name:"yStrikeoutPosition", type:"SHORT", value:258}, {name:"sFamilyClass", type:"SHORT", value:0}, {name:"bFamilyType", type:"BYTE", value:0}, {name:"bSerifStyle", type:"BYTE", value:0}, {name:"bWeight", type:"BYTE", value:0}, {name:"bProportion", type:"BYTE", value:0}, {name:"bContrast", 
      type:"BYTE", value:0}, {name:"bStrokeVariation", type:"BYTE", value:0}, {name:"bArmStyle", type:"BYTE", value:0}, {name:"bLetterform", type:"BYTE", value:0}, {name:"bMidline", type:"BYTE", value:0}, {name:"bXHeight", type:"BYTE", value:0}, {name:"ulUnicodeRange1", type:"ULONG", value:0}, {name:"ulUnicodeRange2", type:"ULONG", value:0}, {name:"ulUnicodeRange3", type:"ULONG", value:0}, {name:"ulUnicodeRange4", type:"ULONG", value:0}, {name:"achVendID", type:"CHARARRAY", value:"XXXX"}, {name:"fsSelection", 
      type:"USHORT", value:0}, {name:"usFirstCharIndex", type:"USHORT", value:0}, {name:"usLastCharIndex", type:"USHORT", value:0}, {name:"sTypoAscender", type:"SHORT", value:0}, {name:"sTypoDescender", type:"SHORT", value:0}, {name:"sTypoLineGap", type:"SHORT", value:0}, {name:"usWinAscent", type:"USHORT", value:0}, {name:"usWinDescent", type:"USHORT", value:0}, {name:"ulCodePageRange1", type:"ULONG", value:0}, {name:"ulCodePageRange2", type:"ULONG", value:0}, {name:"sxHeight", type:"SHORT", value:0}, 
      {name:"sCapHeight", type:"SHORT", value:0}, {name:"usDefaultChar", type:"USHORT", value:0}, {name:"usBreakChar", type:"USHORT", value:0}, {name:"usMaxContext", type:"USHORT", value:0}], c);
    };
  }, {"../parse":10, "../table":13}], 30:[function(d, g, h) {
    var e = d("../encoding"), k = d("../parse"), c = d("../table");
    h.parse = function(c, d) {
      var f = {};
      d = new k.Parser(c, d);
      switch(f.version = d.parseVersion(), f.italicAngle = d.parseFixed(), f.underlinePosition = d.parseShort(), f.underlineThickness = d.parseShort(), f.isFixedPitch = d.parseULong(), f.minMemType42 = d.parseULong(), f.maxMemType42 = d.parseULong(), f.minMemType1 = d.parseULong(), f.maxMemType1 = d.parseULong(), f.version) {
        case 1:
          f.names = e.standardNames.slice();
          break;
        case 2:
          f.numberOfGlyphs = d.parseUShort();
          f.glyphNameIndex = Array(f.numberOfGlyphs);
          for (c = 0; c < f.numberOfGlyphs; c++) {
            f.glyphNameIndex[c] = d.parseUShort();
          }
          f.names = [];
          for (c = 0; c < f.numberOfGlyphs; c++) {
            if (f.glyphNameIndex[c] >= e.standardNames.length) {
              var g = d.parseChar();
              f.names.push(d.parseString(g));
            }
          }
          break;
        case 2.5:
          for (f.numberOfGlyphs = d.parseUShort(), f.offset = Array(f.numberOfGlyphs), c = 0; c < f.numberOfGlyphs; c++) {
            f.offset[c] = d.parseChar();
          }
      }
      return f;
    };
    h.make = function() {
      return new c.Table("post", [{name:"version", type:"FIXED", value:196608}, {name:"italicAngle", type:"FIXED", value:0}, {name:"underlinePosition", type:"FWORD", value:0}, {name:"underlineThickness", type:"FWORD", value:0}, {name:"isFixedPitch", type:"ULONG", value:0}, {name:"minMemType42", type:"ULONG", value:0}, {name:"maxMemType42", type:"ULONG", value:0}, {name:"minMemType1", type:"ULONG", value:0}, {name:"maxMemType1", type:"ULONG", value:0}]);
    };
  }, {"../encoding":4, "../parse":10, "../table":13}], 31:[function(d, g, h) {
    function e(b) {
      for (; 0 !== b.length % 4;) {
        b.push(0);
      }
      for (var c = 0, d = 0; d < b.length; d += 4) {
        c += (b[d] << 24) + (b[d + 1] << 16) + (b[d + 2] << 8) + b[d + 3];
      }
      return c % Math.pow(2, 32);
    }
    function k(b, c, d, e) {
      return new f.Record("Table Record", [{name:"tag", type:"TAG", value:void 0 !== b ? b : ""}, {name:"checkSum", type:"ULONG", value:void 0 !== c ? c : 0}, {name:"offset", type:"ULONG", value:void 0 !== d ? d : 0}, {name:"length", type:"ULONG", value:void 0 !== e ? e : 0}]);
    }
    function c(b) {
      var c = new f.Table("sfnt", [{name:"version", type:"TAG", value:"OTTO"}, {name:"numTables", type:"USHORT", value:0}, {name:"searchRange", type:"USHORT", value:0}, {name:"entrySelector", type:"USHORT", value:0}, {name:"rangeShift", type:"USHORT", value:0}]);
      c.tables = b;
      c.numTables = b.length;
      var d = Math.pow(2, Math.log(c.numTables) / Math.log(2) | 0);
      c.searchRange = 16 * d;
      c.entrySelector = Math.log(d) / Math.log(2) | 0;
      c.rangeShift = 16 * c.numTables - c.searchRange;
      d = [];
      for (var g = [], h = c.sizeOf() + k().sizeOf() * c.numTables; 0 !== h % 4;) {
        h += 1, g.push({name:"padding", type:"BYTE", value:0});
      }
      for (var m = 0; m < b.length; m += 1) {
        var n = b[m];
        t.argument(4 === n.tableName.length, "Table name" + n.tableName + " is invalid.");
        var p = n.sizeOf(), q = k(n.tableName, e(n.encode()), h, p);
        d.push({name:q.tag + " Table Record", type:"RECORD", value:q});
        g.push({name:n.tableName + " table", type:"RECORD", value:n});
        h += p;
        for (t.argument(!isNaN(h), "Something went wrong calculating the offset."); 0 !== h % 4;) {
          h += 1, g.push({name:"padding", type:"BYTE", value:0});
        }
      }
      return d.sort(function(b, c) {
        return b.value.tag > c.value.tag ? 1 : -1;
      }), c.fields = c.fields.concat(d), c.fields = c.fields.concat(g), c;
    }
    function p(b, c, d) {
      for (var e = 0; e < c.length; e += 1) {
        var f = b.charToGlyphIndex(c[e]);
        if (0 < f) {
          return b.glyphs.get(f).getMetrics();
        }
      }
      return d;
    }
    var t = d("../check"), f = d("../table"), n = d("./cmap"), b = d("./cff"), m = d("./head"), q = d("./hhea"), y = d("./hmtx"), x = d("./ltag"), z = d("./maxp"), r = d("./name"), u = d("./os2"), v = d("./post"), C = d("./gsub"), A = d("./meta");
    h.computeCheckSum = e;
    h.make = c;
    h.fontToTable = function(d) {
      for (var f, g = [], k = [], h = [], t = [], D = [], P = [], J = [], I = 0, N = 0, S = 0, Q = 0, Z = 0, R = 0; R < d.glyphs.length; R += 1) {
        var W = d.glyphs.get(R), O = 0 | W.unicode;
        if (isNaN(W.advanceWidth)) {
          throw Error("Glyph " + W.name + " (" + R + "): advanceWidth is not a number.");
        }
        (f > O || void 0 === f) && 0 < O && (f = O);
        O > I && (I = O);
        O = u.getUnicodeRange(O);
        if (32 > O) {
          N |= 1 << O;
        } else {
          if (64 > O) {
            S |= 1 << O - 32;
          } else {
            if (96 > O) {
              Q |= 1 << O - 64;
            } else {
              if (!(123 > O)) {
                throw Error("Unicode ranges bits > 123 are reserved for internal usage");
              }
              Z |= 1 << O - 96;
            }
          }
        }
        ".notdef" !== W.name && (O = W.getMetrics(), g.push(O.xMin), k.push(O.yMin), h.push(O.xMax), t.push(O.yMax), P.push(O.leftSideBearing), J.push(O.rightSideBearing), D.push(W.advanceWidth));
      }
      R = Math.min.apply(null, g);
      k = Math.min.apply(null, k);
      h = Math.max.apply(null, h);
      t = Math.max.apply(null, t);
      g = Math.max.apply(null, D);
      for (O = W = 0; O < D.length; O += 1) {
        W += D[O];
      }
      R = {xMin:R, yMin:k, xMax:h, yMax:t, advanceWidthMax:g, advanceWidthAvg:W / D.length, minLeftSideBearing:Math.min.apply(null, P), maxLeftSideBearing:Math.max.apply(null, P), minRightSideBearing:Math.min.apply(null, J)};
      R.ascender = d.ascender;
      R.descender = d.descender;
      D = m.make({flags:3, unitsPerEm:d.unitsPerEm, xMin:R.xMin, yMin:R.yMin, xMax:R.xMax, yMax:R.yMax, lowestRecPPEM:3, createdTimestamp:d.createdTimestamp});
      P = q.make({ascender:R.ascender, descender:R.descender, advanceWidthMax:R.advanceWidthMax, minLeftSideBearing:R.minLeftSideBearing, minRightSideBearing:R.minRightSideBearing, xMaxExtent:R.maxLeftSideBearing + (R.xMax - R.xMin), numberOfHMetrics:d.glyphs.length});
      J = z.make(d.glyphs.length);
      f = u.make({xAvgCharWidth:Math.round(R.advanceWidthAvg), usWeightClass:d.tables.os2.usWeightClass, usWidthClass:d.tables.os2.usWidthClass, usFirstCharIndex:f, usLastCharIndex:I, ulUnicodeRange1:N, ulUnicodeRange2:S, ulUnicodeRange3:Q, ulUnicodeRange4:Z, fsSelection:d.tables.os2.fsSelection, sTypoAscender:R.ascender, sTypoDescender:R.descender, sTypoLineGap:0, usWinAscent:R.yMax, usWinDescent:Math.abs(R.yMin), ulCodePageRange1:1, sxHeight:p(d, "xyvw", {yMax:Math.round(R.ascender / 2)}).yMax, 
      sCapHeight:p(d, "HIKLEFJMNTZBDPRAGOQSUVWXY", R).yMax, usDefaultChar:d.hasChar(" ") ? 32 : 0, usBreakChar:d.hasChar(" ") ? 32 : 0});
      I = y.make(d.glyphs);
      N = n.make(d.glyphs);
      S = d.getEnglishName("fontFamily");
      Q = d.getEnglishName("fontSubfamily");
      Z = S + " " + Q;
      (t = d.getEnglishName("postScriptName")) || (t = S.replace(/\s/g, "") + "-" + Q);
      h = {};
      for (var ca in d.names) {
        h[ca] = d.names[ca];
      }
      h.uniqueID || (h.uniqueID = {en:d.getEnglishName("manufacturer") + ":" + Z});
      h.postScriptName || (h.postScriptName = {en:t});
      h.preferredFamily || (h.preferredFamily = d.names.fontFamily);
      h.preferredSubfamily || (h.preferredSubfamily = d.names.fontSubfamily);
      k = [];
      ca = r.make(h, k);
      h = 0 < k.length ? x.make(k) : void 0;
      k = v.make();
      Q = b.make(d.glyphs, {version:d.getEnglishName("version"), fullName:Z, familyName:S, weightName:Q, postScriptName:t, unitsPerEm:d.unitsPerEm, fontBBox:[0, R.yMin, R.ascender, R.advanceWidthMax]});
      S = d.metas && 0 < Object.keys(d.metas).length ? A.make(d.metas) : void 0;
      ca = [D, P, J, f, ca, N, k, Q, I];
      h && ca.push(h);
      d.tables.gsub && ca.push(C.make(d.tables.gsub));
      S && ca.push(S);
      d = c(ca);
      ca = d.encode();
      ca = e(ca);
      f = d.fields;
      I = !1;
      for (R = 0; R < f.length; R += 1) {
        if ("head table" === f[R].name) {
          f[R].value.checkSumAdjustment = 2981146554 - ca;
          I = !0;
          break;
        }
      }
      if (!I) {
        throw Error("Could not find head table with checkSum to adjust.");
      }
      return d;
    };
  }, {"../check":2, "../table":13, "./cff":14, "./cmap":15, "./gsub":19, "./head":20, "./hhea":21, "./hmtx":22, "./ltag":25, "./maxp":26, "./meta":27, "./name":28, "./os2":29, "./post":30}], 32:[function(d, g, h) {
    function e(b) {
      return function() {
        return b;
      };
    }
    var k = d("./check");
    d = {};
    var c = {}, p = {};
    c.BYTE = function(b) {
      return k.argument(0 <= b && 255 >= b, "Byte value should be between 0 and 255."), [b];
    };
    p.BYTE = e(1);
    c.CHAR = function(b) {
      return [b.charCodeAt(0)];
    };
    p.CHAR = e(1);
    c.CHARARRAY = function(b) {
      for (var c = [], d = 0; d < b.length; d += 1) {
        c[d] = b.charCodeAt(d);
      }
      return c;
    };
    p.CHARARRAY = function(b) {
      return b.length;
    };
    c.USHORT = function(b) {
      return [b >> 8 & 255, 255 & b];
    };
    p.USHORT = e(2);
    c.SHORT = function(b) {
      return 32768 <= b && (b = -(65536 - b)), [b >> 8 & 255, 255 & b];
    };
    p.SHORT = e(2);
    c.UINT24 = function(b) {
      return [b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    p.UINT24 = e(3);
    c.ULONG = function(b) {
      return [b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    p.ULONG = e(4);
    c.LONG = function(b) {
      return 2147483648 <= b && (b = -(4294967296 - b)), [b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    p.LONG = e(4);
    c.FIXED = c.ULONG;
    p.FIXED = p.ULONG;
    c.FWORD = c.SHORT;
    p.FWORD = p.SHORT;
    c.UFWORD = c.USHORT;
    p.UFWORD = p.USHORT;
    c.LONGDATETIME = function(b) {
      return [0, 0, 0, 0, b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    p.LONGDATETIME = e(8);
    c.TAG = function(b) {
      return k.argument(4 === b.length, "Tag should be exactly 4 ASCII characters."), [b.charCodeAt(0), b.charCodeAt(1), b.charCodeAt(2), b.charCodeAt(3)];
    };
    p.TAG = e(4);
    c.Card8 = c.BYTE;
    p.Card8 = p.BYTE;
    c.Card16 = c.USHORT;
    p.Card16 = p.USHORT;
    c.OffSize = c.BYTE;
    p.OffSize = p.BYTE;
    c.SID = c.USHORT;
    p.SID = p.USHORT;
    c.NUMBER = function(b) {
      return -107 <= b && 107 >= b ? [b + 139] : 108 <= b && 1131 >= b ? (b -= 108, [(b >> 8) + 247, 255 & b]) : -1131 <= b && -108 >= b ? (b = -b - 108, [(b >> 8) + 251, 255 & b]) : -32768 <= b && 32767 >= b ? c.NUMBER16(b) : c.NUMBER32(b);
    };
    p.NUMBER = function(b) {
      return c.NUMBER(b).length;
    };
    c.NUMBER16 = function(b) {
      return [28, b >> 8 & 255, 255 & b];
    };
    p.NUMBER16 = e(3);
    c.NUMBER32 = function(b) {
      return [29, b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    p.NUMBER32 = e(5);
    c.REAL = function(b) {
      var c = b.toString(), d = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(c);
      d && (c = parseFloat("1e" + ((d[2] ? +d[2] : 0) + d[1].length)), c = (Math.round(b * c) / c).toString());
      var e = "";
      b = 0;
      for (d = c.length; d > b; b += 1) {
        var f = c[b];
        e += "e" === f ? "-" === c[++b] ? "c" : "b" : "." === f ? "a" : "-" === f ? "e" : f;
      }
      e += 1 & e.length ? "f" : "ff";
      c = [30];
      b = 0;
      for (d = e.length; d > b; b += 2) {
        c.push(parseInt(e.substr(b, 2), 16));
      }
      return c;
    };
    p.REAL = function(b) {
      return c.REAL(b).length;
    };
    c.NAME = c.CHARARRAY;
    p.NAME = p.CHARARRAY;
    c.STRING = c.CHARARRAY;
    p.STRING = p.CHARARRAY;
    d.UTF8 = function(b, c, d) {
      for (var e = [], f = 0; d > f; f++, c += 1) {
        e[f] = b.getUint8(c);
      }
      return String.fromCharCode.apply(null, e);
    };
    d.UTF16 = function(b, c, d) {
      var e = [];
      d /= 2;
      for (var f = 0; d > f; f++, c += 2) {
        e[f] = b.getUint16(c);
      }
      return String.fromCharCode.apply(null, e);
    };
    c.UTF16 = function(b) {
      for (var c = [], d = 0; d < b.length; d += 1) {
        var e = b.charCodeAt(d);
        c[c.length] = e >> 8 & 255;
        c[c.length] = 255 & e;
      }
      return c;
    };
    p.UTF16 = function(b) {
      return 2 * b.length;
    };
    var t = {"x-mac-croatian":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u0160\u2122\u00b4\u00a8\u2260\u017d\u00d8\u221e\u00b1\u2264\u2265\u2206\u00b5\u2202\u2211\u220f\u0161\u222b\u00aa\u00ba\u03a9\u017e\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u0106\u00ab\u010c\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u0110\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\uf8ff\u00a9\u2044\u20ac\u2039\u203a\u00c6\u00bb\u2013\u00b7\u201a\u201e\u2030\u00c2\u0107\u00c1\u010d\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\u0111\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u03c0\u00cb\u02da\u00b8\u00ca\u00e6\u02c7", 
    "x-mac-cyrillic":"\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\u2020\u00b0\u0490\u00a3\u00a7\u2022\u00b6\u0406\u00ae\u00a9\u2122\u0402\u0452\u2260\u0403\u0453\u221e\u00b1\u2264\u2265\u0456\u00b5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040a\u045a\u0458\u0405\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u040b\u045b\u040c\u045c\u0455\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u201e\u040e\u045e\u040f\u045f\u2116\u0401\u0451\u044f\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e", 
    "x-mac-gaelic":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u1e02\u00b1\u2264\u2265\u1e03\u010a\u010b\u1e0a\u1e0b\u1e1e\u1e1f\u0120\u0121\u1e40\u00e6\u00f8\u1e41\u1e56\u1e57\u027c\u0192\u017f\u1e60\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u1e61\u1e9b\u00ff\u0178\u1e6a\u20ac\u2039\u203a\u0176\u0177\u1e6b\u00b7\u1ef2\u1ef3\u204a\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\u2663\u00d2\u00da\u00db\u00d9\u0131\u00dd\u00fd\u0174\u0175\u1e84\u1e85\u1e80\u1e81\u1e82\u1e83", 
    "x-mac-greek":"\u00c4\u00b9\u00b2\u00c9\u00b3\u00d6\u00dc\u0385\u00e0\u00e2\u00e4\u0384\u00a8\u00e7\u00e9\u00e8\u00ea\u00eb\u00a3\u2122\u00ee\u00ef\u2022\u00bd\u2030\u00f4\u00f6\u00a6\u20ac\u00f9\u00fb\u00fc\u2020\u0393\u0394\u0398\u039b\u039e\u03a0\u00df\u00ae\u00a9\u03a3\u03aa\u00a7\u2260\u00b0\u00b7\u0391\u00b1\u2264\u2265\u00a5\u0392\u0395\u0396\u0397\u0399\u039a\u039c\u03a6\u03ab\u03a8\u03a9\u03ac\u039d\u00ac\u039f\u03a1\u2248\u03a4\u00ab\u00bb\u2026\u00a0\u03a5\u03a7\u0386\u0388\u0153\u2013\u2015\u201c\u201d\u2018\u2019\u00f7\u0389\u038a\u038c\u038e\u03ad\u03ae\u03af\u03cc\u038f\u03cd\u03b1\u03b2\u03c8\u03b4\u03b5\u03c6\u03b3\u03b7\u03b9\u03be\u03ba\u03bb\u03bc\u03bd\u03bf\u03c0\u03ce\u03c1\u03c3\u03c4\u03b8\u03c9\u03c2\u03c7\u03c5\u03b6\u03ca\u03cb\u0390\u03b0\u00ad", 
    "x-mac-icelandic":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u00dd\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u00e6\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u2044\u20ac\u00d0\u00f0\u00de\u00fe\u00fd\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7", 
    "x-mac-inuit":"\u1403\u1404\u1405\u1406\u140a\u140b\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144e\u144f\u1450\u1451\u1455\u1456\u1466\u146d\u146e\u146f\u1470\u1472\u1473\u1483\u148b\u148c\u148d\u148e\u1490\u1491\u00b0\u14a1\u14a5\u14a6\u2022\u00b6\u14a7\u00ae\u00a9\u2122\u14a8\u14aa\u14ab\u14bb\u14c2\u14c3\u14c4\u14c5\u14c7\u14c8\u14d0\u14ef\u14f0\u14f1\u14f2\u14f4\u14f5\u1505\u14d5\u14d6\u14d7\u14d8\u14da\u14db\u14ea\u1528\u1529\u152a\u152b\u152d\u2026\u00a0\u152e\u153e\u1555\u1556\u1557\u2013\u2014\u201c\u201d\u2018\u2019\u1558\u1559\u155a\u155d\u1546\u1547\u1548\u1549\u154b\u154c\u1550\u157f\u1580\u1581\u1582\u1583\u1584\u1585\u158f\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15a0\u15a1\u15a2\u15a3\u15a4\u15a5\u15a6\u157c\u0141\u0142", 
    "x-mac-ce":"\u00c4\u0100\u0101\u00c9\u0104\u00d6\u00dc\u00e1\u0105\u010c\u00e4\u010d\u0106\u0107\u00e9\u0179\u017a\u010e\u00ed\u010f\u0112\u0113\u0116\u00f3\u0117\u00f4\u00f6\u00f5\u00fa\u011a\u011b\u00fc\u2020\u00b0\u0118\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u0119\u00a8\u2260\u0123\u012e\u012f\u012a\u2264\u2265\u012b\u0136\u2202\u2211\u0142\u013b\u013c\u013d\u013e\u0139\u013a\u0145\u0146\u0143\u00ac\u221a\u0144\u0147\u2206\u00ab\u00bb\u2026\u00a0\u0148\u0150\u00d5\u0151\u014c\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u014d\u0154\u0155\u0158\u2039\u203a\u0159\u0156\u0157\u0160\u201a\u201e\u0161\u015a\u015b\u00c1\u0164\u0165\u00cd\u017d\u017e\u016a\u00d3\u00d4\u016b\u016e\u00da\u016f\u0170\u0171\u0172\u0173\u00dd\u00fd\u0137\u017b\u0141\u017c\u0122\u02c7", 
    macintosh:"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u00e6\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u2044\u20ac\u2039\u203a\ufb01\ufb02\u2021\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7", 
    "x-mac-romanian":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u0102\u0218\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u0103\u0219\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u2044\u20ac\u2039\u203a\u021a\u021b\u2021\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7", 
    "x-mac-turkish":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u00e6\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u011e\u011f\u0130\u0131\u015e\u015f\u2021\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\uf8a0\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7"};
    d.MACSTRING = function(b, c, d, e) {
      e = t[e];
      if (void 0 !== e) {
        for (var f = "", g = 0; d > g; g++) {
          var k = b.getUint8(c + g);
          f += 127 >= k ? String.fromCharCode(k) : e[127 & k];
        }
        return f;
      }
    };
    var f = "function" == typeof WeakMap && new WeakMap, n;
    c.MACSTRING = function(b, c) {
      a: {
        if (!n) {
          for (d in n = {}, t) {
            n[d] = new String(d);
          }
        }
        var d = n[c];
        if (void 0 !== d) {
          if (f) {
            var e = f.get(d);
            if (void 0 !== e) {
              d = e;
              break a;
            }
          }
          c = t[c];
          if (void 0 !== c) {
            e = {};
            for (var g = 0; g < c.length; g++) {
              e[c.charCodeAt(g)] = g + 128;
            }
            d = (f && f.set(d, e), e);
            break a;
          }
        }
        d = void 0;
      }
      if (void 0 !== d) {
        c = [];
        for (e = 0; e < b.length; e++) {
          g = b.charCodeAt(e);
          if (128 <= g && (g = d[g], void 0 === g)) {
            return;
          }
          c[e] = g;
        }
        return c;
      }
    };
    p.MACSTRING = function(b, d) {
      b = c.MACSTRING(b, d);
      return void 0 !== b ? b.length : 0;
    };
    c.INDEX = function(b) {
      var d, e = 1, f = [e], g = [];
      for (d = 0; d < b.length; d += 1) {
        var k = c.OBJECT(b[d]);
        Array.prototype.push.apply(g, k);
        e += k.length;
        f.push(e);
      }
      if (0 === g.length) {
        return [0, 0];
      }
      k = [];
      e = 1 + Math.floor(Math.log(e) / Math.log(2)) / 8 | 0;
      var h = [void 0, c.BYTE, c.USHORT, c.UINT24, c.ULONG][e];
      for (d = 0; d < f.length; d += 1) {
        var m = h(f[d]);
        Array.prototype.push.apply(k, m);
      }
      return Array.prototype.concat(c.Card16(b.length), c.OffSize(e), k, g);
    };
    p.INDEX = function(b) {
      return c.INDEX(b).length;
    };
    c.DICT = function(b) {
      for (var d = [], e = Object.keys(b), f = e.length, g = 0; f > g; g += 1) {
        var k = parseInt(e[g], 0), h = b[k];
        d = d.concat(c.OPERAND(h.value, h.type));
        d = d.concat(c.OPERATOR(k));
      }
      return d;
    };
    p.DICT = function(b) {
      return c.DICT(b).length;
    };
    c.OPERATOR = function(b) {
      return 1200 > b ? [b] : [12, b - 1200];
    };
    c.OPERAND = function(b, d) {
      var e = [];
      if (Array.isArray(d)) {
        for (var f = 0; f < d.length; f += 1) {
          k.argument(b.length === d.length, "Not enough arguments given for type" + d), e = e.concat(c.OPERAND(b[f], d[f]));
        }
      } else {
        if ("SID" === d) {
          e = e.concat(c.NUMBER(b));
        } else {
          if ("offset" === d) {
            e = e.concat(c.NUMBER32(b));
          } else {
            if ("number" === d) {
              e = e.concat(c.NUMBER(b));
            } else {
              if ("real" !== d) {
                throw Error("Unknown operand type " + d);
              }
              e = e.concat(c.REAL(b));
            }
          }
        }
      }
      return e;
    };
    c.OP = c.BYTE;
    p.OP = p.BYTE;
    var b = "function" == typeof WeakMap && new WeakMap;
    c.CHARSTRING = function(d) {
      if (b) {
        var e = b.get(d);
        if (void 0 !== e) {
          return e;
        }
      }
      e = [];
      for (var f = d.length, g = 0; f > g; g += 1) {
        var k = d[g];
        e = e.concat(c[k.type](k.value));
      }
      return b && b.set(d, e), e;
    };
    p.CHARSTRING = function(b) {
      return c.CHARSTRING(b).length;
    };
    c.OBJECT = function(b) {
      var d = c[b.type];
      return k.argument(void 0 !== d, "No encoding function for type " + b.type), d(b.value);
    };
    p.OBJECT = function(b) {
      var c = p[b.type];
      return k.argument(void 0 !== c, "No sizeOf function for type " + b.type), c(b.value);
    };
    c.TABLE = function(b) {
      var d, e = [], f = b.fields.length, g = [], h = [];
      for (d = 0; f > d; d += 1) {
        var m = b.fields[d], n = c[m.type];
        k.argument(void 0 !== n, "No encoding function for field type " + m.type + " (" + m.name + ")");
        var p = b[m.name];
        void 0 === p && (p = m.value);
        n = n(p);
        "TABLE" === m.type ? (h.push(e.length), e = e.concat([0, 0]), g.push(n)) : e = e.concat(n);
      }
      for (d = 0; d < g.length; d += 1) {
        f = h[d], m = e.length, k.argument(65536 > m, "Table " + b.tableName + " too big."), e[f] = m >> 8, e[f + 1] = 255 & m, e = e.concat(g[d]);
      }
      return e;
    };
    p.TABLE = function(b) {
      for (var c = 0, d = b.fields.length, e = 0; d > e; e += 1) {
        var f = b.fields[e], g = p[f.type];
        k.argument(void 0 !== g, "No sizeOf function for field type " + f.type + " (" + f.name + ")");
        var h = b[f.name];
        void 0 === h && (h = f.value);
        c += g(h);
        "TABLE" === f.type && (c += 2);
      }
      return c;
    };
    c.RECORD = c.TABLE;
    p.RECORD = p.TABLE;
    c.LITERAL = function(b) {
      return b;
    };
    p.LITERAL = function(b) {
      return b.length;
    };
    h.decode = d;
    h.encode = c;
    h.sizeOf = p;
  }, {"./check":2}], 33:[function(d, g, h) {
    h.isBrowser = function() {
      return "undefined" != typeof window;
    };
    h.isNode = function() {
      return "undefined" == typeof window;
    };
    h.nodeBufferToArrayBuffer = function(d) {
      for (var e = new ArrayBuffer(d.length), c = new Uint8Array(e), g = 0; g < d.length; ++g) {
        c[g] = d[g];
      }
      return e;
    };
    h.arrayBufferToNodeBuffer = function(d) {
      var e = new Buffer(d.byteLength);
      d = new Uint8Array(d);
      for (var c = 0; c < e.length; ++c) {
        e[c] = d[c];
      }
      return e;
    };
    h.checkArgument = function(d, g) {
      if (!d) {
        throw g;
      }
    };
  }, {}]}, {}, [9])(9);
});
!function(a, d) {
  "object" == typeof exports && "object" == typeof module ? module.exports = d() : "function" == typeof define && define.amd ? define("chevrotain", [], d) : "object" == typeof exports ? exports.chevrotain = d() : a.chevrotain = d();
}("undefined" != typeof self ? self : this, function() {
  return function(a) {
    function d(h) {
      if (g[h]) {
        return g[h].exports;
      }
      var e = g[h] = {i:h, l:!1, exports:{}};
      return a[h].call(e.exports, e, e.exports, d), e.l = !0, e.exports;
    }
    var g = {};
    return d.m = a, d.c = g, d.d = function(a, e, g) {
      d.o(a, e) || Object.defineProperty(a, e, {enumerable:!0, get:g});
    }, d.r = function(a) {
      $jscomp.initSymbol();
      $jscomp.initSymbol();
      $jscomp.initSymbol();
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(a, Symbol.toStringTag, {value:"Module"});
      Object.defineProperty(a, "__esModule", {value:!0});
    }, d.t = function(a, e) {
      if ((1 & e && (a = d(a)), 8 & e) || 4 & e && "object" == typeof a && a && a.__esModule) {
        return a;
      }
      var g = Object.create(null);
      if (d.r(g), Object.defineProperty(g, "default", {enumerable:!0, value:a}), 2 & e && "string" != typeof a) {
        for (var c in a) {
          d.d(g, c, function(c) {
            return a[c];
          }.bind(null, c));
        }
      }
      return g;
    }, d.n = function(a) {
      var e = a && a.__esModule ? function() {
        return a.default;
      } : function() {
        return a;
      };
      return d.d(e, "a", e), e;
    }, d.o = function(a, d) {
      return Object.prototype.hasOwnProperty.call(a, d);
    }, d.p = "", d(d.s = 18);
  }([function(a, d, g) {
    function h(a) {
      return a && 0 === a.length;
    }
    function e(a) {
      return null == a ? [] : Object.keys(a);
    }
    function k(a) {
      for (var b = [], c = Object.keys(a), d = 0; d < c.length; d++) {
        b.push(a[c[d]]);
      }
      return b;
    }
    function c(a) {
      for (var b = [], d = 0; d < a.length; d++) {
        var e = a[d];
        Array.isArray(e) ? b = b.concat(c(e)) : b.push(e);
      }
      return b;
    }
    function p(a, b) {
      if (Array.isArray(a)) {
        for (var c = 0; c < a.length; c++) {
          b.call(null, a[c], c);
        }
      } else {
        if (!r(a)) {
          throw Error("non exhaustive match");
        }
        var d = e(a);
        for (c = 0; c < d.length; c++) {
          var f = d[c];
          b.call(null, a[f], f);
        }
      }
    }
    function t(a) {
      return void 0 === a;
    }
    function f(a, b) {
      var c = [];
      if (Array.isArray(a)) {
        for (var d = 0; d < a.length; d++) {
          var e = a[d];
          b.call(null, e) && c.push(e);
        }
      }
      return c;
    }
    function n(a, b) {
      return f(a, function(a) {
        return !b(a);
      });
    }
    function b(a, b) {
      return !!r(a) && a.hasOwnProperty(b);
    }
    function m(a, b) {
      return void 0 !== x(a, function(a) {
        return a === b;
      });
    }
    function q(a) {
      for (var b = [], c = 0; c < a.length; c++) {
        b.push(a[c]);
      }
      return b;
    }
    function y(a) {
      var b = {}, c;
      for (c in a) {
        Object.prototype.hasOwnProperty.call(a, c) && (b[c] = a[c]);
      }
      return b;
    }
    function x(a, b) {
      for (var c = 0; c < a.length; c++) {
        var d = a[c];
        if (b.call(null, d)) {
          return d;
        }
      }
    }
    function z(a, b, c) {
      var d = Array.isArray(a), f = d ? a : k(a);
      a = d ? [] : e(a);
      for (var g = 0; g < f.length; g++) {
        c = b.call(null, c, f[g], d ? g : a[g]);
      }
      return c;
    }
    function r(a) {
      return a instanceof Object;
    }
    function u(a) {
      for (var c = [], d = 1; d < arguments.length; d++) {
        c[d - 1] = arguments[d];
      }
      for (d = 0; d < c.length; d++) {
        var f = c[d];
        if (!t(f)) {
          for (var g = e(f), k = 0; k < g.length; k++) {
            var h = g[k];
            b(a, h) || (a[h] = f[h]);
          }
        }
      }
      return a;
    }
    Object.defineProperty(d, "__esModule", {value:!0});
    d.isEmpty = h;
    d.keys = e;
    d.values = k;
    d.mapValues = function(a, b) {
      for (var c = [], d = e(a), f = 0; f < d.length; f++) {
        var g = d[f];
        c.push(b.call(null, a[g], g));
      }
      return c;
    };
    d.map = function(a, b) {
      for (var c = [], d = 0; d < a.length; d++) {
        c.push(b.call(null, a[d], d));
      }
      return c;
    };
    d.flatten = c;
    d.first = function(a) {
      return h(a) ? void 0 : a[0];
    };
    d.last = function(a) {
      var b = a && a.length;
      return b ? a[b - 1] : void 0;
    };
    d.forEach = p;
    d.isString = function(a) {
      return "string" == typeof a;
    };
    d.isUndefined = t;
    d.isFunction = function(a) {
      return a instanceof Function;
    };
    d.drop = function(a, b) {
      return void 0 === b && (b = 1), a.slice(b, a.length);
    };
    d.dropRight = function(a, b) {
      return void 0 === b && (b = 1), a.slice(0, a.length - b);
    };
    d.filter = f;
    d.reject = n;
    d.pick = function(a, b) {
      for (var c = Object.keys(a), d = {}, e = 0; e < c.length; e++) {
        var f = c[e], g = a[f];
        b(g) && (d[f] = g);
      }
      return d;
    };
    d.has = b;
    d.contains = m;
    d.cloneArr = q;
    d.cloneObj = y;
    d.find = x;
    d.findAll = function(a, b) {
      for (var c = [], d = 0; d < a.length; d++) {
        var e = a[d];
        b.call(null, e) && c.push(e);
      }
      return c;
    };
    d.reduce = z;
    d.compact = function(a) {
      return n(a, function(a) {
        return null == a;
      });
    };
    d.uniq = function(a, b) {
      void 0 === b && (b = function(a) {
        return a;
      });
      var c = [];
      return z(a, function(a, d) {
        var e = b(d);
        return m(c, e) ? a : (c.push(e), a.concat(d));
      }, []);
    };
    d.partial = function(a) {
      for (var b = [], c = 1; c < arguments.length; c++) {
        b[c - 1] = arguments[c];
      }
      b = [null].concat(b);
      return Function.bind.apply(a, b);
    };
    d.isArray = function(a) {
      return Array.isArray(a);
    };
    d.isRegExp = function(a) {
      return a instanceof RegExp;
    };
    d.isObject = r;
    d.every = function(a, b) {
      for (var c = 0; c < a.length; c++) {
        if (!b(a[c], c)) {
          return !1;
        }
      }
      return !0;
    };
    d.difference = function(a, b) {
      return n(a, function(a) {
        return m(b, a);
      });
    };
    d.some = function(a, b) {
      for (var c = 0; c < a.length; c++) {
        if (b(a[c])) {
          return !0;
        }
      }
      return !1;
    };
    d.indexOf = function(a, b) {
      for (var c = 0; c < a.length; c++) {
        if (a[c] === b) {
          return c;
        }
      }
      return -1;
    };
    d.sortBy = function(a, b) {
      a = q(a);
      return a.sort(function(a, c) {
        return b(a) - b(c);
      }), a;
    };
    d.zipObject = function(a, b) {
      if (a.length !== b.length) {
        throw Error("can't zipObject with different number of keys and values!");
      }
      for (var c = {}, d = 0; d < a.length; d++) {
        c[a[d]] = b[d];
      }
      return c;
    };
    d.assign = function(a) {
      for (var b = [], c = 1; c < arguments.length; c++) {
        b[c - 1] = arguments[c];
      }
      for (c = 0; c < b.length; c++) {
        for (var d = b[c], f = e(d), g = 0; g < f.length; g++) {
          var k = f[g];
          a[k] = d[k];
        }
      }
      return a;
    };
    d.assignNoOverwrite = u;
    d.defaults = function() {
      for (var a = [], b = 0; b < arguments.length; b++) {
        a[b] = arguments[b];
      }
      return u.apply(null, [{}].concat(a));
    };
    d.groupBy = function(a, b) {
      var c = {};
      return p(a, function(a) {
        var d = b(a), e = c[d];
        e ? e.push(a) : c[d] = [a];
      }), c;
    };
    d.merge = function(a, b) {
      a = y(a);
      for (var c = e(b), d = 0; d < c.length; d++) {
        var f = c[d];
        a[f] = b[f];
      }
      return a;
    };
    d.NOOP = function() {
    };
    d.IDENTITY = function(a) {
      return a;
    };
    d.packArray = function(a) {
      for (var b = [], c = 0; c < a.length; c++) {
        var d = a[c];
        b.push(void 0 !== d ? d : void 0);
      }
      return b;
    };
    d.PRINT_ERROR = function(a) {
      console && console.error && console.error("Error: " + a);
    };
    d.PRINT_WARNING = function(a) {
      console && console.warn && console.warn("Warning: " + a);
    };
    d.isES2015MapSupported = function() {
      return "function" == typeof Map;
    };
    d.applyMixins = function(a, b) {
      b.forEach(function(b) {
        var c = b.prototype;
        Object.getOwnPropertyNames(c).forEach(function(d) {
          if ("constructor" !== d) {
            var e = Object.getOwnPropertyDescriptor(c, d);
            e && (e.get || e.set) ? Object.defineProperty(a.prototype, d, e) : a.prototype[d] = b.prototype[d];
          }
        });
      });
    };
    d.toFastProperties = function(a) {
      function b() {
      }
      b.prototype = a;
      new b;
      return a;
    };
  }, function(a, d, g) {
    function h(a) {
      function d(a) {
        return c.map(a, h);
      }
      if (a instanceof t) {
        return {type:"NonTerminal", name:a.nonTerminalName, idx:a.idx};
      }
      if (a instanceof n) {
        return {type:"Flat", definition:d(a.definition)};
      }
      if (a instanceof b) {
        return {type:"Option", idx:a.idx, definition:d(a.definition)};
      }
      if (a instanceof m) {
        return {type:"RepetitionMandatory", name:a.name, idx:a.idx, definition:d(a.definition)};
      }
      if (a instanceof q) {
        return {type:"RepetitionMandatoryWithSeparator", name:a.name, idx:a.idx, separator:h(new r({terminalType:a.separator})), definition:d(a.definition)};
      }
      if (a instanceof x) {
        return {type:"RepetitionWithSeparator", name:a.name, idx:a.idx, separator:h(new r({terminalType:a.separator})), definition:d(a.definition)};
      }
      if (a instanceof y) {
        return {type:"Repetition", name:a.name, idx:a.idx, definition:d(a.definition)};
      }
      if (a instanceof z) {
        return {type:"Alternation", name:a.name, idx:a.idx, definition:d(a.definition)};
      }
      if (a instanceof r) {
        var e = {type:"Terminal", name:p.tokenName(a.terminalType), label:p.tokenLabel(a.terminalType), idx:a.idx}, g = a.terminalType.PATTERN;
        return a.terminalType.PATTERN && (e.pattern = c.isRegExp(g) ? g.source : g), e;
      }
      if (a instanceof f) {
        return {type:"Rule", name:a.name, orgText:a.orgText, definition:d(a.definition)};
      }
      throw Error("non exhaustive match");
    }
    var e, k = this && this.__extends || (e = function(a, b) {
      return (e = Object.setPrototypeOf || {__proto__:[]} instanceof Array && function(a, b) {
        a.__proto__ = b;
      } || function(a, b) {
        for (var c in b) {
          b.hasOwnProperty(c) && (a[c] = b[c]);
        }
      })(a, b);
    }, function(a, b) {
      function c() {
        this.constructor = a;
      }
      e(a, b);
      a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c);
    });
    Object.defineProperty(d, "__esModule", {value:!0});
    var c = g(0), p = g(2);
    a = function() {
      function a(a) {
        this.definition = a;
      }
      return a.prototype.accept = function(a) {
        a.visit(this);
        c.forEach(this.definition, function(b) {
          b.accept(a);
        });
      }, a;
    }();
    d.AbstractProduction = a;
    var t = function(a) {
      function b(b) {
        var d = a.call(this, []) || this;
        return d.idx = 1, c.assign(d, c.pick(b, function(a) {
          return void 0 !== a;
        })), d;
      }
      return k(b, a), Object.defineProperty(b.prototype, "definition", {get:function() {
        return void 0 !== this.referencedRule ? this.referencedRule.definition : [];
      }, set:function(a) {
      }, enumerable:!0, configurable:!0}), b.prototype.accept = function(a) {
        a.visit(this);
      }, b;
    }(a);
    d.NonTerminal = t;
    var f = function(a) {
      function b(b) {
        var d = a.call(this, b.definition) || this;
        return d.orgText = "", c.assign(d, c.pick(b, function(a) {
          return void 0 !== a;
        })), d;
      }
      return k(b, a), b;
    }(a);
    d.Rule = f;
    var n = function(a) {
      function b(b) {
        var d = a.call(this, b.definition) || this;
        return c.assign(d, c.pick(b, function(a) {
          return void 0 !== a;
        })), d;
      }
      return k(b, a), b;
    }(a);
    d.Flat = n;
    var b = function(a) {
      function b(b) {
        var d = a.call(this, b.definition) || this;
        return d.idx = 1, c.assign(d, c.pick(b, function(a) {
          return void 0 !== a;
        })), d;
      }
      return k(b, a), b;
    }(a);
    d.Option = b;
    var m = function(a) {
      function b(b) {
        var d = a.call(this, b.definition) || this;
        return d.idx = 1, c.assign(d, c.pick(b, function(a) {
          return void 0 !== a;
        })), d;
      }
      return k(b, a), b;
    }(a);
    d.RepetitionMandatory = m;
    var q = function(a) {
      function b(b) {
        var d = a.call(this, b.definition) || this;
        return d.idx = 1, c.assign(d, c.pick(b, function(a) {
          return void 0 !== a;
        })), d;
      }
      return k(b, a), b;
    }(a);
    d.RepetitionMandatoryWithSeparator = q;
    var y = function(a) {
      function b(b) {
        var d = a.call(this, b.definition) || this;
        return d.idx = 1, c.assign(d, c.pick(b, function(a) {
          return void 0 !== a;
        })), d;
      }
      return k(b, a), b;
    }(a);
    d.Repetition = y;
    var x = function(a) {
      function b(b) {
        var d = a.call(this, b.definition) || this;
        return d.idx = 1, c.assign(d, c.pick(b, function(a) {
          return void 0 !== a;
        })), d;
      }
      return k(b, a), b;
    }(a);
    d.RepetitionWithSeparator = x;
    var z = function(a) {
      function b(b) {
        var d = a.call(this, b.definition) || this;
        return d.idx = 1, c.assign(d, c.pick(b, function(a) {
          return void 0 !== a;
        })), d;
      }
      return k(b, a), b;
    }(a);
    d.Alternation = z;
    var r = function() {
      function a(a) {
        this.idx = 1;
        c.assign(this, c.pick(a, function(a) {
          return void 0 !== a;
        }));
      }
      return a.prototype.accept = function(a) {
        a.visit(this);
      }, a;
    }();
    d.Terminal = r;
    d.serializeGrammar = function(a) {
      return c.map(a, h);
    };
    d.serializeProduction = h;
  }, function(a, d, g) {
    function h(a) {
      return c.isString(a.LABEL) && "" !== a.LABEL;
    }
    function e(a) {
      return c.isObject(a) && a.hasOwnProperty("tokenName") && c.isString(a.tokenName) ? a.tokenName : p.functionName(a);
    }
    function k(a) {
      var d = a.name, b = a.pattern, e = {};
      p.defineNameProp(e, d) || (e.tokenName = d);
      c.isUndefined(b) || (e.PATTERN = b);
      if (c.has(a, "parent")) {
        throw "The parent property is no longer supported.\nSee: https://github.com/SAP/chevrotain/issues/564#issuecomment-349062346 for details.";
      }
      c.has(a, "categories") && (e.CATEGORIES = a.categories);
      t.augmentTokenTypes([e]);
      c.has(a, "label") && (e.LABEL = a.label);
      c.has(a, "group") && (e.GROUP = a.group);
      c.has(a, "pop_mode") && (e.POP_MODE = a.pop_mode);
      c.has(a, "push_mode") && (e.PUSH_MODE = a.push_mode);
      c.has(a, "longer_alt") && (e.LONGER_ALT = a.longer_alt);
      c.has(a, "line_breaks") && (e.LINE_BREAKS = a.line_breaks);
      c.has(a, "start_chars_hint") && (e.START_CHARS_HINT = a.start_chars_hint);
      return e;
    }
    Object.defineProperty(d, "__esModule", {value:!0});
    var c = g(0), p = g(4);
    a = g(15);
    var t = g(7);
    d.tokenLabel = function(a) {
      return h(a) ? a.LABEL : e(a);
    };
    d.hasTokenLabel = h;
    d.tokenName = e;
    d.createToken = k;
    d.EOF = k({name:"EOF", pattern:a.Lexer.NA});
    t.augmentTokenTypes([d.EOF]);
    d.createTokenInstance = function(a, c, b, d, e, g, k, h) {
      return {image:c, startOffset:b, endOffset:d, startLine:e, endLine:g, startColumn:k, endColumn:h, tokenTypeIdx:a.tokenTypeIdx, tokenType:a};
    };
    d.tokenMatcher = function(a, c) {
      return t.tokenStructuredMatcher(a, c);
    };
  }, function(a, d, g) {
    var h, e = this && this.__extends || (h = function(a, b) {
      return (h = Object.setPrototypeOf || {__proto__:[]} instanceof Array && function(a, b) {
        a.__proto__ = b;
      } || function(a, b) {
        for (var c in b) {
          b.hasOwnProperty(c) && (a[c] = b[c]);
        }
      })(a, b);
    }, function(a, b) {
      function c() {
        this.constructor = a;
      }
      h(a, b);
      a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c);
    });
    Object.defineProperty(d, "__esModule", {value:!0});
    var k = g(4), c = g(0), p = g(26), t = g(2), f = g(23), n = g(16), b = g(10), m = g(24);
    a = g(25);
    var q = g(31), y = g(32), x = g(34), z = g(35), r = g(36), u = g(37);
    g = g(38);
    d.END_OF_FILE = t.createTokenInstance(t.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
    Object.freeze(d.END_OF_FILE);
    d.DEFAULT_PARSER_CONFIG = Object.freeze({recoveryEnabled:!1, maxLookahead:4, ignoredIssues:{}, dynamicTokensEnabled:!1, outputCst:!0, errorMessageProvider:b.defaultParserErrorProvider, serializedGrammar:null});
    d.DEFAULT_RULE_CONFIG = Object.freeze({recoveryValueFunc:function() {
    }, resyncEnabled:!0});
    (function(a) {
      a[a.INVALID_RULE_NAME = 0] = "INVALID_RULE_NAME";
      a[a.DUPLICATE_RULE_NAME = 1] = "DUPLICATE_RULE_NAME";
      a[a.INVALID_RULE_OVERRIDE = 2] = "INVALID_RULE_OVERRIDE";
      a[a.DUPLICATE_PRODUCTIONS = 3] = "DUPLICATE_PRODUCTIONS";
      a[a.UNRESOLVED_SUBRULE_REF = 4] = "UNRESOLVED_SUBRULE_REF";
      a[a.LEFT_RECURSION = 5] = "LEFT_RECURSION";
      a[a.NONE_LAST_EMPTY_ALT = 6] = "NONE_LAST_EMPTY_ALT";
      a[a.AMBIGUOUS_ALTS = 7] = "AMBIGUOUS_ALTS";
      a[a.CONFLICT_TOKENS_RULES_NAMESPACE = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
      a[a.INVALID_TOKEN_NAME = 9] = "INVALID_TOKEN_NAME";
      a[a.INVALID_NESTED_RULE_NAME = 10] = "INVALID_NESTED_RULE_NAME";
      a[a.DUPLICATE_NESTED_NAME = 11] = "DUPLICATE_NESTED_NAME";
      a[a.NO_NON_EMPTY_LOOKAHEAD = 12] = "NO_NON_EMPTY_LOOKAHEAD";
      a[a.AMBIGUOUS_PREFIX_ALTS = 13] = "AMBIGUOUS_PREFIX_ALTS";
      a[a.TOO_MANY_ALTS = 14] = "TOO_MANY_ALTS";
    })(d.ParserDefinitionErrorType || (d.ParserDefinitionErrorType = {}));
    d.EMPTY_ALT = function(a) {
      return void 0 === a && (a = void 0), function() {
        return a;
      };
    };
    t = function() {
      function a(a, b) {
        void 0 === b && (b = d.DEFAULT_PARSER_CONFIG);
        this.ignoredIssues = d.DEFAULT_PARSER_CONFIG.ignoredIssues;
        this.definitionErrors = [];
        this.selfAnalysisDone = !1;
        this.initErrorHandler(b);
        this.initLexerAdapter();
        this.initLooksAhead(b);
        this.initRecognizerEngine(a, b);
        this.initRecoverable(b);
        this.initTreeBuilder(b);
        this.initContentAssist();
        this.ignoredIssues = c.has(b, "ignoredIssues") ? b.ignoredIssues : d.DEFAULT_PARSER_CONFIG.ignoredIssues;
        c.toFastProperties(this);
      }
      return a.performSelfAnalysis = function(a) {
        a.performSelfAnalysis();
      }, a.prototype.performSelfAnalysis = function() {
        var d, e = this;
        this.selfAnalysisDone = !0;
        var g = k.classNameFromInstance(this), h = this.gastProductionsCache;
        if (this.serializedGrammar) {
          var q = f.deserializeGrammar(this.serializedGrammar, this.tokensMap);
          c.forEach(q, function(a) {
            e.gastProductionsCache.put(a.name, a);
          });
        }
        q = m.resolveGrammar({rules:h.values()});
        if (this.definitionErrors.push.apply(this.definitionErrors, q), c.isEmpty(q)) {
          g = m.validateGrammar({rules:h.values(), maxLookahead:this.maxLookahead, tokenTypes:c.values(this.tokensMap), ignoredIssues:this.ignoredIssues, errMsgProvider:b.defaultGrammarValidatorErrorProvider, grammarName:g}), this.definitionErrors.push.apply(this.definitionErrors, g);
        }
        c.isEmpty(this.definitionErrors) && (this.resyncFollows = p.computeAllProdsFollows(h.values()));
        if (this.allRuleNames = n.analyzeCst(h.values(), this.fullRuleNameToShort).allRuleNames, !a.DEFER_DEFINITION_ERRORS_HANDLING && !c.isEmpty(this.definitionErrors)) {
          throw d = c.map(this.definitionErrors, function(a) {
            return a.message;
          }), Error("Parser Definition Errors detected:\n " + d.join("\n-------------------------------\n"));
        }
      }, a.DEFER_DEFINITION_ERRORS_HANDLING = !1, a;
    }();
    d.Parser = t;
    c.applyMixins(t, [a.Recoverable, q.LooksAhead, y.TreeBuilder, x.LexerAdapter, r.RecognizerEngine, z.RecognizerApi, u.ErrorHandler, g.ContentAssist]);
    a = function(a) {
      function b(b, e) {
        void 0 === e && (e = d.DEFAULT_PARSER_CONFIG);
        e = c.cloneObj(e);
        return e.outputCst = !0, a.call(this, b, e) || this;
      }
      return e(b, a), b;
    }(t);
    d.CstParser = a;
    a = function(a) {
      function b(b, e) {
        void 0 === e && (e = d.DEFAULT_PARSER_CONFIG);
        e = c.cloneObj(e);
        return e.outputCst = !1, a.call(this, b, e) || this;
      }
      return e(b, a), b;
    }(t);
    d.EmbeddedActionsParser = a;
  }, function(a, d, g) {
    function h(a) {
      return a.name || a.toString().match(k)[1];
    }
    Object.defineProperty(d, "__esModule", {value:!0});
    var e = g(0);
    d.classNameFromInstance = function(a) {
      return h(a.constructor);
    };
    var k = /^\s*function\s*(\S*)\s*\(/;
    d.functionName = h;
    d.defineNameProp = function(a, d) {
      var c = Object.getOwnPropertyDescriptor(a, "name");
      return !(!e.isUndefined(c) && !c.configurable || (Object.defineProperty(a, "name", {enumerable:!1, configurable:!0, writable:!1, value:d}), 0));
    };
    a = function() {
      function a() {
        this._state = {};
      }
      return a.prototype.keys = function() {
        return e.keys(this._state);
      }, a.prototype.values = function() {
        return e.values(this._state);
      }, a.prototype.put = function(a, c) {
        this._state[a] = c;
      }, a.prototype.putAll = function(a) {
        this._state = e.assign(this._state, a._state);
      }, a.prototype.get = function(a) {
        return this._state[a];
      }, a.prototype.containsKey = function(a) {
        return e.has(this._state, a);
      }, a.prototype.clear = function() {
        this._state = {};
      }, a;
    }();
    d.HashTable = a;
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    var h = g(1);
    a = function() {
      function a() {
      }
      return a.prototype.visit = function(a) {
        if (a instanceof h.NonTerminal) {
          return this.visitNonTerminal(a);
        }
        if (a instanceof h.Flat) {
          return this.visitFlat(a);
        }
        if (a instanceof h.Option) {
          return this.visitOption(a);
        }
        if (a instanceof h.RepetitionMandatory) {
          return this.visitRepetitionMandatory(a);
        }
        if (a instanceof h.RepetitionMandatoryWithSeparator) {
          return this.visitRepetitionMandatoryWithSeparator(a);
        }
        if (a instanceof h.RepetitionWithSeparator) {
          return this.visitRepetitionWithSeparator(a);
        }
        if (a instanceof h.Repetition) {
          return this.visitRepetition(a);
        }
        if (a instanceof h.Alternation) {
          return this.visitAlternation(a);
        }
        if (a instanceof h.Terminal) {
          return this.visitTerminal(a);
        }
        if (a instanceof h.Rule) {
          return this.visitRule(a);
        }
        throw Error("non exhaustive match");
      }, a.prototype.visitNonTerminal = function(a) {
      }, a.prototype.visitFlat = function(a) {
      }, a.prototype.visitOption = function(a) {
      }, a.prototype.visitRepetition = function(a) {
      }, a.prototype.visitRepetitionMandatory = function(a) {
      }, a.prototype.visitRepetitionMandatoryWithSeparator = function(a) {
      }, a.prototype.visitRepetitionWithSeparator = function(a) {
      }, a.prototype.visitAlternation = function(a) {
      }, a.prototype.visitTerminal = function(a) {
      }, a.prototype.visitRule = function(a) {
      }, a;
    }();
    d.GAstVisitor = a;
  }, function(a, d, g) {
    function h(a, c, b) {
      this.name = "MismatchedTokenException";
      this.message = a;
      this.token = c;
      this.previousToken = b;
      this.resyncedTokens = [];
    }
    function e(a, c, b) {
      this.name = "NoViableAltException";
      this.message = a;
      this.token = c;
      this.previousToken = b;
      this.resyncedTokens = [];
    }
    function k(a, c) {
      this.name = "NotAllInputParsedException";
      this.message = a;
      this.token = c;
      this.resyncedTokens = [];
    }
    function c(a, c, b) {
      this.name = "EarlyExitException";
      this.message = a;
      this.token = c;
      this.previousToken = b;
      this.resyncedTokens = [];
    }
    Object.defineProperty(d, "__esModule", {value:!0});
    var p = g(0), t = ["MismatchedTokenException", "NoViableAltException", "EarlyExitException", "NotAllInputParsedException"];
    Object.freeze(t);
    d.isRecognitionException = function(a) {
      return p.contains(t, a.name);
    };
    d.MismatchedTokenException = h;
    h.prototype = Error.prototype;
    d.NoViableAltException = e;
    e.prototype = Error.prototype;
    d.NotAllInputParsedException = k;
    k.prototype = Error.prototype;
    d.EarlyExitException = c;
    c.prototype = Error.prototype;
  }, function(a, d, g) {
    function h(a) {
      for (var b = q.cloneArr(a), c = !0; c;) {
        a = q.compact(q.flatten(q.map(a, function(a) {
          return a.CATEGORIES;
        })));
        var d = q.difference(a, b);
        b = b.concat(d);
        q.isEmpty(d) ? c = !1 : a = d;
      }
      return b;
    }
    function e(a) {
      q.forEach(a, function(a) {
        t(a) || (d.tokenIdxToClass.put(d.tokenShortNameIdx, a), a.tokenTypeIdx = d.tokenShortNameIdx++);
        f(a) && !q.isArray(a.CATEGORIES) && (a.CATEGORIES = [a.CATEGORIES]);
        f(a) || (a.CATEGORIES = []);
        n(a) || (a.categoryMatches = []);
        b(a) || (a.categoryMatchesMap = {});
        m(a) || (a.tokenName = y.tokenName(a));
      });
    }
    function k(a) {
      q.forEach(a, function(a) {
        a.categoryMatches = [];
        q.forEach(a.categoryMatchesMap, function(b, c) {
          a.categoryMatches.push(d.tokenIdxToClass.get(c).tokenTypeIdx);
        });
      });
    }
    function c(a) {
      q.forEach(a, function(a) {
        p([], a);
      });
    }
    function p(a, b) {
      q.forEach(a, function(a) {
        b.categoryMatchesMap[a.tokenTypeIdx] = !0;
      });
      q.forEach(b.CATEGORIES, function(c) {
        var d = a.concat(b);
        q.contains(d, c) || p(d, c);
      });
    }
    function t(a) {
      return q.has(a, "tokenTypeIdx");
    }
    function f(a) {
      return q.has(a, "CATEGORIES");
    }
    function n(a) {
      return q.has(a, "categoryMatches");
    }
    function b(a) {
      return q.has(a, "categoryMatchesMap");
    }
    function m(a) {
      return q.has(a, "tokenName");
    }
    Object.defineProperty(d, "__esModule", {value:!0});
    var q = g(0);
    a = g(4);
    var y = g(2);
    d.tokenStructuredMatcher = function(a, b) {
      a = a.tokenTypeIdx;
      return a === b.tokenTypeIdx || !0 === b.isParent && !0 === b.categoryMatchesMap[a];
    };
    d.tokenStructuredMatcherNoCategories = function(a, b) {
      return a.tokenTypeIdx === b.tokenTypeIdx;
    };
    d.tokenShortNameIdx = 1;
    d.tokenIdxToClass = new a.HashTable;
    d.augmentTokenTypes = function(a) {
      a = h(a);
      e(a);
      c(a);
      k(a);
      q.forEach(a, function(a) {
        a.isParent = 0 < a.categoryMatches.length;
      });
    };
    d.expandCategories = h;
    d.assignTokenDefaultProps = e;
    d.assignCategoriesTokensProp = k;
    d.assignCategoriesMapProp = c;
    d.singleAssignCategoriesToksMap = p;
    d.hasShortKeyProperty = t;
    d.hasCategoriesProperty = f;
    d.hasExtendingTokensTypesProperty = n;
    d.hasExtendingTokensTypesMapProperty = b;
    d.hasTokenNameProperty = m;
    d.isTokenType = function(a) {
      return q.has(a, "tokenTypeIdx");
    };
  }, function(a, d, g) {
    var h, e = this && this.__extends || (h = function(a, c) {
      return (h = Object.setPrototypeOf || {__proto__:[]} instanceof Array && function(a, b) {
        a.__proto__ = b;
      } || function(a, b) {
        for (var c in b) {
          b.hasOwnProperty(c) && (a[c] = b[c]);
        }
      })(a, c);
    }, function(a, c) {
      function d() {
        this.constructor = a;
      }
      h(a, c);
      a.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d);
    });
    Object.defineProperty(d, "__esModule", {value:!0});
    var k = g(0), c = g(1);
    a = g(5);
    var p = g(2);
    d.isSequenceProd = function(a) {
      return a instanceof c.Flat || a instanceof c.Option || a instanceof c.Repetition || a instanceof c.RepetitionMandatory || a instanceof c.RepetitionMandatoryWithSeparator || a instanceof c.RepetitionWithSeparator || a instanceof c.Terminal || a instanceof c.Rule;
    };
    d.isOptionalProd = function b(a, d) {
      return void 0 === d && (d = []), !!(a instanceof c.Option || a instanceof c.Repetition || a instanceof c.RepetitionWithSeparator) || (a instanceof c.Alternation ? k.some(a.definition, function(a) {
        return b(a, d);
      }) : !(a instanceof c.NonTerminal && k.contains(d, a)) && a instanceof c.AbstractProduction && (a instanceof c.NonTerminal && d.push(a), k.every(a.definition, function(a) {
        return b(a, d);
      })));
    };
    d.isBranchingProd = function(a) {
      return a instanceof c.Alternation;
    };
    d.getProductionDslName = function(a) {
      if (a instanceof c.NonTerminal) {
        return "SUBRULE";
      }
      if (a instanceof c.Option) {
        return "OPTION";
      }
      if (a instanceof c.Alternation) {
        return "OR";
      }
      if (a instanceof c.RepetitionMandatory) {
        return "AT_LEAST_ONE";
      }
      if (a instanceof c.RepetitionMandatoryWithSeparator) {
        return "AT_LEAST_ONE_SEP";
      }
      if (a instanceof c.RepetitionWithSeparator) {
        return "MANY_SEP";
      }
      if (a instanceof c.Repetition) {
        return "MANY";
      }
      if (a instanceof c.Terminal) {
        return "CONSUME";
      }
      throw Error("non exhaustive match");
    };
    g = function(a) {
      function c() {
        var b = null !== a && a.apply(this, arguments) || this;
        return b.separator = "-", b.dslMethods = {option:[], alternation:[], repetition:[], repetitionWithSeparator:[], repetitionMandatory:[], repetitionMandatoryWithSeparator:[]}, b;
      }
      return e(c, a), c.prototype.visitTerminal = function(a) {
        var b = p.tokenName(a.terminalType) + this.separator + "Terminal";
        k.has(this.dslMethods, b) || (this.dslMethods[b] = []);
        this.dslMethods[b].push(a);
      }, c.prototype.visitNonTerminal = function(a) {
        var b = a.nonTerminalName + this.separator + "Terminal";
        k.has(this.dslMethods, b) || (this.dslMethods[b] = []);
        this.dslMethods[b].push(a);
      }, c.prototype.visitOption = function(a) {
        this.dslMethods.option.push(a);
      }, c.prototype.visitRepetitionWithSeparator = function(a) {
        this.dslMethods.repetitionWithSeparator.push(a);
      }, c.prototype.visitRepetitionMandatory = function(a) {
        this.dslMethods.repetitionMandatory.push(a);
      }, c.prototype.visitRepetitionMandatoryWithSeparator = function(a) {
        this.dslMethods.repetitionMandatoryWithSeparator.push(a);
      }, c.prototype.visitRepetition = function(a) {
        this.dslMethods.repetition.push(a);
      }, c.prototype.visitAlternation = function(a) {
        this.dslMethods.alternation.push(a);
      }, c;
    }(a.GAstVisitor);
    d.DslMethodsCollectorVisitor = g;
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    d.BITS_FOR_METHOD_IDX = 4;
    d.BITS_FOR_OCCURRENCE_IDX = 4;
    d.BITS_FOR_RULE_IDX = 24;
    d.BITS_FOR_ALT_IDX = 8;
    d.OR_IDX = 1 << d.BITS_FOR_METHOD_IDX;
    d.OPTION_IDX = 2 << d.BITS_FOR_METHOD_IDX;
    d.MANY_IDX = 3 << d.BITS_FOR_METHOD_IDX;
    d.AT_LEAST_ONE_IDX = 4 << d.BITS_FOR_METHOD_IDX;
    d.MANY_SEP_IDX = 5 << d.BITS_FOR_METHOD_IDX;
    d.AT_LEAST_ONE_SEP_IDX = 6 << d.BITS_FOR_METHOD_IDX;
    d.getKeyForAutomaticLookahead = function(a, d, c) {
      return c | d | a;
    };
    var h = 32 - d.BITS_FOR_ALT_IDX;
    d.getKeyForAltIndex = function(a, d, c, g) {
      return c | d | a | g + 1 << h;
    };
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    var h = g(2), e = g(0), k = g(0), c = g(1), p = g(8), t = g(11), f = g(17), n = g(3);
    d.defaultParserErrorProvider = {buildMismatchTokenMessage:function(a) {
      var b = a.expected, c = a.actual;
      a.previous;
      a.ruleName;
      return "Expecting " + (h.hasTokenLabel(b) ? "--\x3e " + h.tokenLabel(b) + " <--" : "token of type --\x3e " + h.tokenName(b) + " <--") + " but found --\x3e '" + c.image + "' <--";
    }, buildNotAllInputParsedMessage:function(a) {
      var b = a.firstRedundant;
      a.ruleName;
      return "Redundant input, expecting EOF but found: " + b.image;
    }, buildNoViableAltMessage:function(a) {
      var b = a.expectedPathsPerAlt, c = a.actual, d = (a.previous, a.customUserDescription);
      a = (a.ruleName, "\nbut found: '" + k.first(c).image + "'");
      if (d) {
        return "Expecting: " + d + a;
      }
      b = k.reduce(b, function(a, b) {
        return a.concat(b);
      }, []);
      b = k.map(b, function(a) {
        return "[" + k.map(a, function(a) {
          return h.tokenLabel(a);
        }).join(", ") + "]";
      });
      return "Expecting: one of these possible Token sequences:\n" + k.map(b, function(a, b) {
        return "  " + (b + 1) + ". " + a;
      }).join("\n") + a;
    }, buildEarlyExitMessage:function(a) {
      var b = a.expectedIterationPaths, c = a.actual, d = a.customUserDescription;
      a = (a.ruleName, "\nbut found: '" + k.first(c).image + "'");
      return d ? "Expecting: " + d + a : "Expecting: " + ("expecting at least one iteration which starts with one of these possible Token sequences::\n  <" + k.map(b, function(a) {
        return "[" + k.map(a, function(a) {
          return h.tokenLabel(a);
        }).join(",") + "]";
      }).join(" ,") + ">") + a;
    }};
    Object.freeze(d.defaultParserErrorProvider);
    d.defaultGrammarResolverErrorProvider = {buildRuleNotFoundError:function(a, c) {
      return "Invalid grammar, reference to a rule which is not defined: ->" + c.nonTerminalName + "<-\ninside top level rule: ->" + a.name + "<-";
    }};
    d.defaultGrammarValidatorErrorProvider = {buildDuplicateFoundError:function(a, d) {
      a = a.name;
      var b = k.first(d), e = b.idx, f = p.getProductionDslName(b);
      b = b instanceof c.Terminal ? h.tokenName(b.terminalType) : b instanceof c.NonTerminal ? b.nonTerminalName : "";
      return ("->" + f + "<- with numerical suffix: ->" + e + "<-\n                  " + (b ? "and argument: ->" + b + "<-" : "") + "\n                  appears more than once (" + d.length + " times) in the top level rule: ->" + a + "<-.\n                  " + (0 === e ? "Also note that numerical suffix 0 means " + f + " without any suffix." : "") + "\n                  To fix this make sure each usage of " + f + " " + (b ? "with the argument: ->" + b + "<-" : "") + "\n                  in the rule ->" + 
      a + "<- has a different occurrence index (0-5), as that combination acts as a unique\n                  position key in the grammar, which is needed by the parsing engine.\n                  \n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ").replace(/[ \t]+/g, " ").replace(/\s\s+/g, "\n");
    }, buildInvalidNestedRuleNameError:function(a, c) {
      return "Invalid nested rule name: ->" + c.name + "<- inside rule: ->" + a.name + "<-\nit must match the pattern: ->" + t.validNestedRuleName.toString() + "<-.\nNote that this means a nested rule name must start with the '$'(dollar) sign.";
    }, buildDuplicateNestedRuleNameError:function(a, c) {
      return "Duplicate nested rule name: ->" + k.first(c).name + "<- inside rule: ->" + a.name + "<-\nA nested name must be unique in the scope of a top level grammar rule.";
    }, buildNamespaceConflictError:function(a) {
      return "Namespace conflict found in grammar.\nThe grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <" + a.name + ">.\nTo resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.";
    }, buildAlternationPrefixAmbiguityError:function(a) {
      var b = k.map(a.prefixPath, function(a) {
        return h.tokenLabel(a);
      }).join(", "), c = 0 === a.alternation.idx ? "" : a.alternation.idx;
      return "Ambiguous alternatives: <" + a.ambiguityIndices.join(" ,") + "> due to common lookahead prefix\nin <OR" + c + "> inside <" + a.topLevelRule.name + "> Rule,\n<" + b + "> may appears as a prefix path in all these alternatives.\nhttps://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.";
    }, buildAlternationAmbiguityError:function(a) {
      var b = k.map(a.prefixPath, function(a) {
        return h.tokenLabel(a);
      }).join(", "), c = 0 === a.alternation.idx ? "" : a.alternation.idx;
      a = "Ambiguous alternatives: <" + a.ambiguityIndices.join(" ,") + "> in <OR" + c + "> inside <" + a.topLevelRule.name + "> Rule,\n<" + b + "> may appears as a prefix path in all these alternatives.\n";
      b = f.VERSION.replace(/\./g, "_");
      return a = a + "To Resolve this, try one of of the following: \n1. Refactor your grammar to be LL(K) for the current value of k (by default k=" + n.DEFAULT_PARSER_CONFIG.maxLookahead + "})\n2. Increase the value of K for your grammar by providing a larger 'maxLookahead' value in the parser's config\n3. This issue can be ignored (if you know what you are doing...), see https://sap.github.io/chevrotain/documentation/" + b + "/interfaces/iparserconfig.html#ignoredissues for more details\n";
    }, buildEmptyRepetitionError:function(a) {
      var b = p.getProductionDslName(a.repetition);
      return 0 !== a.repetition.idx && (b += a.repetition.idx), "The repetition <" + b + "> within Rule <" + a.topLevelRule.name + "> can never consume any tokens.\nThis could lead to an infinite loop.";
    }, buildTokenNameError:function(a) {
      return "Invalid Grammar Token name: ->" + h.tokenName(a.tokenType) + "<- it must match the pattern: ->" + a.expectedPattern.toString() + "<-";
    }, buildEmptyAlternationError:function(a) {
      return "Ambiguous empty alternative: <" + (a.emptyChoiceIdx + 1) + "> in <OR" + a.alternation.idx + "> inside <" + a.topLevelRule.name + "> Rule.\nOnly the last alternative may be an empty alternative.";
    }, buildTooManyAlternativesError:function(a) {
      return "An Alternation cannot have more than 256 alternatives:\n<OR" + a.alternation.idx + "> inside <" + a.topLevelRule.name + "> Rule.\n has " + (a.alternation.definition.length + 1) + " alternatives.";
    }, buildLeftRecursionError:function(a) {
      var b = a.topLevelRule.name;
      return "Left Recursion found in grammar.\nrule: <" + b + "> can be invoked from itself (directly or indirectly)\nwithout consuming any Tokens. The grammar path that causes this is: \n " + (b + " --\x3e " + e.map(a.leftRecursionPath, function(a) {
        return a.name;
      }).concat([b]).join(" --\x3e ")) + "\n To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.";
    }, buildInvalidRuleNameError:function(a) {
      return "Invalid grammar rule name: ->" + a.topLevelRule.name + "<- it must match the pattern: ->" + a.expectedPattern.toString() + "<-";
    }, buildDuplicateRuleNameError:function(a) {
      return "Duplicate definition, rule: ->" + (a.topLevelRule instanceof c.Rule ? a.topLevelRule.name : a.topLevelRule) + "<- is already defined in the grammar: ->" + a.grammarName + "<-";
    }};
  }, function(a, d, g) {
    function h(a) {
      return A.getProductionDslName(a) + "_#_" + a.idx + "_#_" + e(a);
    }
    function e(a) {
      return a instanceof H.Terminal ? D.tokenName(a.terminalType) : a instanceof H.NonTerminal ? a.nonTerminalName : "";
    }
    function k(a, b) {
      var c = [], e = a.name;
      return e.match(d.validTermsPattern) || c.push({message:b.buildInvalidRuleNameError({topLevelRule:a, expectedPattern:d.validTermsPattern}), type:C.ParserDefinitionErrorType.INVALID_RULE_NAME, ruleName:e}), c;
    }
    function c(a, b, c) {
      var e, f = [];
      return b.name.match(d.validNestedRuleName) || (e = c.buildInvalidNestedRuleNameError(a, b), f.push({message:e, type:C.ParserDefinitionErrorType.INVALID_NESTED_RULE_NAME, ruleName:a.name})), f;
    }
    function p(a, b) {
      var c = [];
      return D.tokenName(a).match(d.validTermsPattern) || c.push({message:b.buildTokenNameError({tokenType:a, expectedPattern:d.validTermsPattern}), type:C.ParserDefinitionErrorType.INVALID_TOKEN_NAME}), c;
    }
    function t(a, b, c, d) {
      var e = [];
      1 < v.reduce(b, function(b, c) {
        return c.name === a.name ? b + 1 : b;
      }, 0) && (b = d.buildDuplicateRuleNameError({topLevelRule:a, grammarName:c}), e.push({message:b, type:C.ParserDefinitionErrorType.DUPLICATE_RULE_NAME, ruleName:a.name}));
      return e;
    }
    function f(a, b, c, d) {
      void 0 === d && (d = []);
      var e = [];
      b = n(b.definition);
      if (u.isEmpty(b)) {
        return [];
      }
      var g = a.name;
      u.contains(b, a) && e.push({message:c.buildLeftRecursionError({topLevelRule:a, leftRecursionPath:d}), type:C.ParserDefinitionErrorType.LEFT_RECURSION, ruleName:g});
      b = u.difference(b, d.concat([a]));
      b = u.map(b, function(b) {
        var e = u.cloneArr(d);
        return e.push(b), f(a, b, c, e);
      });
      return e.concat(u.flatten(b));
    }
    function n(a) {
      var b = [];
      if (u.isEmpty(a)) {
        return b;
      }
      var c = u.first(a);
      if (c instanceof H.NonTerminal) {
        b.push(c.referencedRule);
      } else {
        if (c instanceof H.Flat || c instanceof H.Option || c instanceof H.RepetitionMandatory || c instanceof H.RepetitionMandatoryWithSeparator || c instanceof H.RepetitionWithSeparator || c instanceof H.Repetition) {
          b = b.concat(n(c.definition));
        } else {
          if (c instanceof H.Alternation) {
            b = u.flatten(u.map(c.definition, function(a) {
              return n(a.definition);
            }));
          } else {
            if (!(c instanceof H.Terminal)) {
              throw Error("non exhaustive match");
            }
          }
        }
      }
      c = A.isOptionalProd(c);
      var d = 1 < a.length;
      return c && d ? (a = u.drop(a), b.concat(n(a))) : b;
    }
    function b(a, b) {
      var c = new K;
      a.accept(c);
      return u.reduce(c.alternations, function(c, d) {
        var e = u.dropRight(d.definition);
        e = u.map(e, function(c, e) {
          c = E.nextPossibleTokensAfter([c], [], null, 1);
          return u.isEmpty(c) ? {message:b.buildEmptyAlternationError({topLevelRule:a, alternation:d, emptyChoiceIdx:e}), type:C.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT, ruleName:a.name, occurrence:d.idx, alternative:e + 1} : null;
        });
        return c.concat(u.compact(e));
      }, []);
    }
    function m(a, b, c, d) {
      var e = new K;
      a.accept(e);
      e = e.alternations;
      var f = c[a.name];
      return f && (e = v.reject(e, function(a) {
        return f[A.getProductionDslName(a) + (0 === a.idx ? "" : a.idx)];
      })), u.reduce(e, function(c, e) {
        var f = F.getLookaheadPathsForOr(e.idx, a, b), g = function(a, b, c, d) {
          var e = [], f = v.reduce(a, function(b, c, d) {
            return v.forEach(c, function(c) {
              var f = [d];
              v.forEach(a, function(a, b) {
                d !== b && F.containsPath(a, c) && f.push(b);
              });
              1 < f.length && !F.containsPath(e, c) && (e.push(c), b.push({alts:f, path:c}));
            }), b;
          }, []);
          return u.map(f, function(a) {
            var e = v.map(a.alts, function(a) {
              return a + 1;
            });
            return {message:d.buildAlternationAmbiguityError({topLevelRule:c, alternation:b, ambiguityIndices:e, prefixPath:a.path}), type:C.ParserDefinitionErrorType.AMBIGUOUS_ALTS, ruleName:c.name, occurrence:b.idx, alternatives:[a.alts]};
          });
        }(f, e, a, d);
        e = x(f, e, a, d);
        return c.concat(g, e);
      }, []);
    }
    function q(a, b) {
      var c = new K;
      a.accept(c);
      return u.reduce(c.alternations, function(c, d) {
        return 255 < d.definition.length && c.push({message:b.buildTooManyAlternativesError({topLevelRule:a, alternation:d}), type:C.ParserDefinitionErrorType.TOO_MANY_ALTS, ruleName:a.name, occurrence:d.idx}), c;
      }, []);
    }
    function y(a, b, c) {
      var d = [];
      return v.forEach(a, function(a) {
        var e = new P;
        a.accept(e);
        v.forEach(e.allProductions, function(e) {
          var f = F.getProdType(e);
          f = F.getLookaheadPathsForOptionalProd(e.idx, a, f, b)[0];
          v.isEmpty(v.flatten(f)) && (e = c.buildEmptyRepetitionError({topLevelRule:a, repetition:e}), d.push({message:e, type:C.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD, ruleName:a.name}));
        });
      }), d;
    }
    function x(a, b, c, d) {
      var e = [], f = v.reduce(a, function(a, b, c) {
        b = v.map(b, function(a) {
          return {idx:c, path:a};
        });
        return a.concat(b);
      }, []);
      return v.forEach(f, function(a) {
        var g = a.idx, k = a.path;
        a = v.findAll(f, function(a) {
          return a.idx < g && F.isStrictPrefixOfPath(a.path, k);
        });
        a = v.map(a, function(a) {
          var e = [a.idx + 1, g + 1], f = 0 === b.idx ? "" : b.idx;
          return {message:d.buildAlternationPrefixAmbiguityError({topLevelRule:c, alternation:b, ambiguityIndices:e, prefixPath:a.path}), type:C.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS, ruleName:c.name, occurrence:f, alternatives:e};
        });
        e = e.concat(a);
      }), e;
    }
    var z, r = this && this.__extends || (z = function(a, b) {
      return (z = Object.setPrototypeOf || {__proto__:[]} instanceof Array && function(a, b) {
        a.__proto__ = b;
      } || function(a, b) {
        for (var c in b) {
          b.hasOwnProperty(c) && (a[c] = b[c]);
        }
      })(a, b);
    }, function(a, b) {
      function c() {
        this.constructor = a;
      }
      z(a, b);
      a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c);
    });
    Object.defineProperty(d, "__esModule", {value:!0});
    var u = g(0), v = g(0), C = g(3), A = g(8), D = g(2), F = g(12), B = g(16), E = g(13), H = g(1);
    a = g(5);
    d.validateGrammar = function(a, d, g, n, r, x) {
      var z = u.map(a, function(a) {
        return function(a, b) {
          var c = new L;
          a.accept(c);
          c = u.groupBy(c.allProductions, h);
          c = u.pick(c, function(a) {
            return 1 < a.length;
          });
          return u.map(u.values(c), function(c) {
            var d = u.first(c);
            c = b.buildDuplicateFoundError(a, c);
            var f = A.getProductionDslName(d);
            c = {message:c, type:C.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS, ruleName:a.name, dslName:f, occurrence:d.idx};
            d = e(d);
            return d && (c.parameter = d), c;
          });
        }(a, r);
      }), I = u.map(a, function(a) {
        return f(a, a, r);
      }), E = [], J = [], F = [];
      v.every(I, v.isEmpty) && (E = v.map(a, function(a) {
        return b(a, r);
      }), J = v.map(a, function(a) {
        return m(a, d, n, r);
      }), F = y(a, d, r));
      var N = function(a, b, c) {
        var d = [], e = v.map(b, function(a) {
          return D.tokenName(a);
        });
        return v.forEach(a, function(a) {
          var b = a.name;
          v.contains(e, b) && (a = c.buildNamespaceConflictError(a), d.push({message:a, type:C.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE, ruleName:b}));
        }), d;
      }(a, g, r);
      g = u.map(g, function(a) {
        return p(a, r);
      });
      var H = function(a, b) {
        var d = [];
        return v.forEach(a, function(a) {
          var e = new B.NamedDSLMethodsCollectorVisitor("");
          a.accept(e);
          e = v.map(e.result, function(a) {
            return a.orgProd;
          });
          d.push(v.map(e, function(d) {
            return c(a, d, b);
          }));
        }), v.flatten(d);
      }(a, r), K = function(a, b) {
        var c = [];
        return v.forEach(a, function(a) {
          var d = new B.NamedDSLMethodsCollectorVisitor("");
          a.accept(d);
          d = v.groupBy(d.result, function(a) {
            return a.name;
          });
          d = v.pick(d, function(a) {
            return 1 < a.length;
          });
          v.forEach(v.values(d), function(d) {
            d = v.map(d, function(a) {
              return a.orgProd;
            });
            d = b.buildDuplicateNestedRuleNameError(a, d);
            c.push({message:d, type:C.ParserDefinitionErrorType.DUPLICATE_NESTED_NAME, ruleName:a.name});
          });
        }), c;
      }(a, r), Q = v.map(a, function(a) {
        return q(a, r);
      }), S = v.map(a, function(a) {
        return k(a, r);
      }), P = v.map(a, function(b) {
        return t(b, a, x, r);
      });
      return u.flatten(z.concat(g, H, K, F, I, E, J, N, Q, S, P));
    };
    d.identifyProductionForDuplicates = h;
    var L = function(a) {
      function b() {
        var b = null !== a && a.apply(this, arguments) || this;
        return b.allProductions = [], b;
      }
      return r(b, a), b.prototype.visitNonTerminal = function(a) {
        this.allProductions.push(a);
      }, b.prototype.visitOption = function(a) {
        this.allProductions.push(a);
      }, b.prototype.visitRepetitionWithSeparator = function(a) {
        this.allProductions.push(a);
      }, b.prototype.visitRepetitionMandatory = function(a) {
        this.allProductions.push(a);
      }, b.prototype.visitRepetitionMandatoryWithSeparator = function(a) {
        this.allProductions.push(a);
      }, b.prototype.visitRepetition = function(a) {
        this.allProductions.push(a);
      }, b.prototype.visitAlternation = function(a) {
        this.allProductions.push(a);
      }, b.prototype.visitTerminal = function(a) {
        this.allProductions.push(a);
      }, b;
    }(a.GAstVisitor);
    d.OccurrenceValidationCollector = L;
    d.validTermsPattern = /^[a-zA-Z_]\w*$/;
    d.validNestedRuleName = new RegExp(d.validTermsPattern.source.replace("^", "^\\$"));
    d.validateRuleName = k;
    d.validateNestedRuleName = c;
    d.validateTokenName = p;
    d.validateRuleDoesNotAlreadyExist = t;
    d.validateRuleIsOverridden = function(a, b, c) {
      var d, e = [];
      return u.contains(b, a) || (d = "Invalid rule override, rule: ->" + a + "<- cannot be overridden in the grammar: ->" + c + "<-as it is not defined in any of the super grammars ", e.push({message:d, type:C.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE, ruleName:a})), e;
    };
    d.validateNoLeftRecursion = f;
    d.getFirstNoneTerminal = n;
    var K = function(a) {
      function b() {
        var b = null !== a && a.apply(this, arguments) || this;
        return b.alternations = [], b;
      }
      return r(b, a), b.prototype.visitAlternation = function(a) {
        this.alternations.push(a);
      }, b;
    }(a.GAstVisitor);
    d.validateEmptyOrAlternative = b;
    d.validateAmbiguousAlternationAlternatives = m;
    var P = function(a) {
      function b() {
        var b = null !== a && a.apply(this, arguments) || this;
        return b.allProductions = [], b;
      }
      return r(b, a), b.prototype.visitRepetitionWithSeparator = function(a) {
        this.allProductions.push(a);
      }, b.prototype.visitRepetitionMandatory = function(a) {
        this.allProductions.push(a);
      }, b.prototype.visitRepetitionMandatoryWithSeparator = function(a) {
        this.allProductions.push(a);
      }, b.prototype.visitRepetition = function(a) {
        this.allProductions.push(a);
      }, b;
    }(a.GAstVisitor);
    d.RepetionCollector = P;
    d.validateTooManyAlts = q;
    d.validateSomeNonEmptyLookaheadPath = y;
    d.checkPrefixAlternativesAmbiguities = x;
  }, function(a, d, g) {
    function h(a, d) {
      function e(a, c) {
        return b.reduce(a, function(a, d, e) {
          return e !== c ? (d = b.map(d, function(a) {
            return a.partialPath;
          }), a.concat(d)) : a;
        }, []);
      }
      function f(a, c) {
        return void 0 === b.find(a, function(a) {
          return b.every(c, function(b, c) {
            return d = b, e = a[c], d === e || d && e && (d.categoryMatchesMap[e.tokenTypeIdx] || e.categoryMatchesMap[d.tokenTypeIdx]);
            var d, e;
          });
        });
      }
      function g(a) {
        for (var b = [], c = 0; c < a; c++) {
          b.push([]);
        }
        return b;
      }
      var k = b.map(a, function(a) {
        return m.possiblePathsFrom([a], 1);
      });
      a = g(k.length);
      for (var h = 1; h <= d; h++) {
        var n = k;
        k = g(n.length);
        for (var p = 0; p < n.length; p++) {
          for (var q = n[p], r = e(n, p), t = 0; t < q.length; t++) {
            var u = q[t].partialPath, y = q[t].suffixDef;
            f(r, u) || b.isEmpty(y) || u.length === d ? (y = a[p], c(y, u) || y.push(u)) : (u = m.possiblePathsFrom(y, h + 1, u), k[p] = k[p].concat(u));
          }
        }
      }
      return a;
    }
    function e(a, b, c) {
      a = new z(a, n.ALTERNATION);
      return b.accept(a), h(a.result, c);
    }
    function k(a, b, c, d) {
      var e = new z(a, c);
      b.accept(e);
      e = e.result;
      a = (new x(b, a, c)).startWalking();
      return h([new y.Flat({definition:e}), new y.Flat({definition:a})], d);
    }
    function c(a, c) {
      return void 0 !== b.find(a, function(a) {
        return c.length === a.length && b.every(c, function(b, c) {
          return b === a[c] || a[c].categoryMatchesMap[b.tokenTypeIdx];
        });
      });
    }
    function p(a) {
      return b.every(a, function(a) {
        return b.every(a, function(a) {
          return b.every(a, function(a) {
            return b.isEmpty(a.categoryMatches);
          });
        });
      });
    }
    var t, f = this && this.__extends || (t = function(a, b) {
      return (t = Object.setPrototypeOf || {__proto__:[]} instanceof Array && function(a, b) {
        a.__proto__ = b;
      } || function(a, b) {
        for (var c in b) {
          b.hasOwnProperty(c) && (a[c] = b[c]);
        }
      })(a, b);
    }, function(a, b) {
      function c() {
        this.constructor = a;
      }
      t(a, b);
      a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c);
    });
    Object.defineProperty(d, "__esModule", {value:!0});
    var n, b = g(0), m = g(13);
    a = g(14);
    var q = g(7), y = g(1);
    g = g(5);
    !function(a) {
      a[a.OPTION = 0] = "OPTION";
      a[a.REPETITION = 1] = "REPETITION";
      a[a.REPETITION_MANDATORY = 2] = "REPETITION_MANDATORY";
      a[a.REPETITION_MANDATORY_WITH_SEPARATOR = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
      a[a.REPETITION_WITH_SEPARATOR = 4] = "REPETITION_WITH_SEPARATOR";
      a[a.ALTERNATION = 5] = "ALTERNATION";
    }(n = d.PROD_TYPE || (d.PROD_TYPE = {}));
    d.getProdType = function(a) {
      if (a instanceof y.Option) {
        return n.OPTION;
      }
      if (a instanceof y.Repetition) {
        return n.REPETITION;
      }
      if (a instanceof y.RepetitionMandatory) {
        return n.REPETITION_MANDATORY;
      }
      if (a instanceof y.RepetitionMandatoryWithSeparator) {
        return n.REPETITION_MANDATORY_WITH_SEPARATOR;
      }
      if (a instanceof y.RepetitionWithSeparator) {
        return n.REPETITION_WITH_SEPARATOR;
      }
      if (a instanceof y.Alternation) {
        return n.ALTERNATION;
      }
      throw Error("non exhaustive match");
    };
    d.buildLookaheadFuncForOr = function(a, b, c, d, f, g) {
      a = e(a, b, c);
      return g(a, d, p(a) ? q.tokenStructuredMatcherNoCategories : q.tokenStructuredMatcher, f);
    };
    d.buildLookaheadFuncForOptionalProd = function(a, b, c, d, e, f) {
      a = k(a, b, e, c);
      b = p(a) ? q.tokenStructuredMatcherNoCategories : q.tokenStructuredMatcher;
      return f(a[0], b, d);
    };
    d.buildAlternativesLookAheadFunc = function(a, c, d, e) {
      var f = a.length, g = b.every(a, function(a) {
        return b.every(a, function(a) {
          return 1 === a.length;
        });
      });
      if (c) {
        return function(c) {
          c = b.map(c, function(a) {
            return a.GATE;
          });
          for (var e = 0; e < f; e++) {
            var g = a[e], k = g.length, h = c[e];
            if (void 0 === h || !1 !== h.call(this)) {
              a: for (h = 0; h < k; h++) {
                for (var m = g[h], n = m.length, p = 0; p < n; p++) {
                  var q = this.LA(p + 1);
                  if (!1 === d(q, m[p])) {
                    continue a;
                  }
                }
                return e;
              }
            }
          }
        };
      }
      if (g && !e) {
        c = b.map(a, function(a) {
          return b.flatten(a);
        });
        var k = b.reduce(c, function(a, c, d) {
          return b.forEach(c, function(c) {
            b.has(a, c.tokenTypeIdx) || (a[c.tokenTypeIdx] = d);
            b.forEach(c.categoryMatches, function(c) {
              b.has(a, c) || (a[c] = d);
            });
          }), a;
        }, []);
        return function() {
          var a = this.LA(1);
          return k[a.tokenTypeIdx];
        };
      }
      return function() {
        for (var b = 0; b < f; b++) {
          var c = a[b], e = c.length, g = 0;
          a: for (; g < e; g++) {
            for (var k = c[g], h = k.length, m = 0; m < h; m++) {
              var n = this.LA(m + 1);
              if (!1 === d(n, k[m])) {
                continue a;
              }
            }
            return b;
          }
        }
      };
    };
    d.buildSingleAlternativeLookaheadFunction = function(a, c, d) {
      var e = b.every(a, function(a) {
        return 1 === a.length;
      }), f = a.length;
      if (e && !d) {
        d = b.flatten(a);
        if (1 === d.length && b.isEmpty(d[0].categoryMatches)) {
          var g = d[0].tokenTypeIdx;
          return function() {
            return this.LA(1).tokenTypeIdx === g;
          };
        }
        var k = b.reduce(d, function(a, c, d) {
          return a[c.tokenTypeIdx] = !0, b.forEach(c.categoryMatches, function(b) {
            a[b] = !0;
          }), a;
        }, []);
        return function() {
          var a = this.LA(1);
          return !0 === k[a.tokenTypeIdx];
        };
      }
      return function() {
        var b = 0;
        a: for (; b < f; b++) {
          for (var d = a[b], e = d.length, g = 0; g < e; g++) {
            var k = this.LA(g + 1);
            if (!1 === c(k, d[g])) {
              continue a;
            }
          }
          return !0;
        }
        return !1;
      };
    };
    var x = function(a) {
      function b(b, c, d) {
        var e = a.call(this) || this;
        return e.topProd = b, e.targetOccurrence = c, e.targetProdType = d, e;
      }
      return f(b, a), b.prototype.startWalking = function() {
        return this.walk(this.topProd), this.restDef;
      }, b.prototype.checkIsTarget = function(a, b, c, d) {
        return a.idx === this.targetOccurrence && this.targetProdType === b && (this.restDef = c.concat(d), !0);
      }, b.prototype.walkOption = function(b, c, d) {
        this.checkIsTarget(b, n.OPTION, c, d) || a.prototype.walkOption.call(this, b, c, d);
      }, b.prototype.walkAtLeastOne = function(b, c, d) {
        this.checkIsTarget(b, n.REPETITION_MANDATORY, c, d) || a.prototype.walkOption.call(this, b, c, d);
      }, b.prototype.walkAtLeastOneSep = function(b, c, d) {
        this.checkIsTarget(b, n.REPETITION_MANDATORY_WITH_SEPARATOR, c, d) || a.prototype.walkOption.call(this, b, c, d);
      }, b.prototype.walkMany = function(b, c, d) {
        this.checkIsTarget(b, n.REPETITION, c, d) || a.prototype.walkOption.call(this, b, c, d);
      }, b.prototype.walkManySep = function(b, c, d) {
        this.checkIsTarget(b, n.REPETITION_WITH_SEPARATOR, c, d) || a.prototype.walkOption.call(this, b, c, d);
      }, b;
    }(a.RestWalker), z = function(a) {
      function b(b, c) {
        var d = a.call(this) || this;
        return d.targetOccurrence = b, d.targetProdType = c, d.result = [], d;
      }
      return f(b, a), b.prototype.checkIsTarget = function(a, b) {
        a.idx === this.targetOccurrence && this.targetProdType === b && (this.result = a.definition);
      }, b.prototype.visitOption = function(a) {
        this.checkIsTarget(a, n.OPTION);
      }, b.prototype.visitRepetition = function(a) {
        this.checkIsTarget(a, n.REPETITION);
      }, b.prototype.visitRepetitionMandatory = function(a) {
        this.checkIsTarget(a, n.REPETITION_MANDATORY);
      }, b.prototype.visitRepetitionMandatoryWithSeparator = function(a) {
        this.checkIsTarget(a, n.REPETITION_MANDATORY_WITH_SEPARATOR);
      }, b.prototype.visitRepetitionWithSeparator = function(a) {
        this.checkIsTarget(a, n.REPETITION_WITH_SEPARATOR);
      }, b.prototype.visitAlternation = function(a) {
        this.checkIsTarget(a, n.ALTERNATION);
      }, b;
    }(g.GAstVisitor);
    d.lookAheadSequenceFromAlternatives = h;
    d.getLookaheadPathsForOr = e;
    d.getLookaheadPathsForOptionalProd = k;
    d.containsPath = c;
    d.isStrictPrefixOfPath = function(a, c) {
      return a.length < c.length && b.every(a, function(a, b) {
        b = c[b];
        return a === b || b.categoryMatchesMap[a.tokenTypeIdx];
      });
    };
    d.areTokenCategoriesNotUsed = p;
  }, function(a, d, g) {
    function h(a, b, d, e) {
      d = c.cloneArr(d);
      d.push(a.name);
      e = c.cloneArr(e);
      return e.push(1), {idx:b, def:a.definition, ruleStack:d, occurrenceStack:e};
    }
    var e, k = this && this.__extends || (e = function(a, b) {
      return (e = Object.setPrototypeOf || {__proto__:[]} instanceof Array && function(a, b) {
        a.__proto__ = b;
      } || function(a, b) {
        for (var c in b) {
          b.hasOwnProperty(c) && (a[c] = b[c]);
        }
      })(a, b);
    }, function(a, b) {
      function c() {
        this.constructor = a;
      }
      e(a, b);
      a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c);
    });
    Object.defineProperty(d, "__esModule", {value:!0});
    a = g(14);
    var c = g(0), p = g(2), t = g(21), f = g(1);
    g = function(a) {
      function b(b, c) {
        var d = a.call(this) || this;
        return d.topProd = b, d.path = c, d.possibleTokTypes = [], d.nextProductionName = "", d.nextProductionOccurrence = 0, d.found = !1, d.isAtEndOfPath = !1, d;
      }
      return k(b, a), b.prototype.startWalking = function() {
        if (this.found = !1, this.path.ruleStack[0] !== this.topProd.name) {
          throw Error("The path does not start with the walker's top Rule!");
        }
        return this.ruleStack = c.cloneArr(this.path.ruleStack).reverse(), this.occurrenceStack = c.cloneArr(this.path.occurrenceStack).reverse(), this.ruleStack.pop(), this.occurrenceStack.pop(), this.updateExpectedNext(), this.walk(this.topProd), this.possibleTokTypes;
      }, b.prototype.walk = function(b, c) {
        void 0 === c && (c = []);
        this.found || a.prototype.walk.call(this, b, c);
      }, b.prototype.walkProdRef = function(a, b, c) {
        a.referencedRule.name === this.nextProductionName && a.idx === this.nextProductionOccurrence && (b = b.concat(c), this.updateExpectedNext(), this.walk(a.referencedRule, b));
      }, b.prototype.updateExpectedNext = function() {
        c.isEmpty(this.ruleStack) ? (this.nextProductionName = "", this.nextProductionOccurrence = 0, this.isAtEndOfPath = !0) : (this.nextProductionName = this.ruleStack.pop(), this.nextProductionOccurrence = this.occurrenceStack.pop());
      }, b;
    }(a.RestWalker);
    d.AbstractNextPossibleTokensWalker = g;
    g = function(a) {
      function b(b, c) {
        b = a.call(this, b, c) || this;
        return b.path = c, b.nextTerminalName = "", b.nextTerminalOccurrence = 0, b.nextTerminalName = p.tokenName(b.path.lastTok), b.nextTerminalOccurrence = b.path.lastTokOccurrence, b;
      }
      return k(b, a), b.prototype.walkTerminal = function(a, b, c) {
        this.isAtEndOfPath && p.tokenName(a.terminalType) === this.nextTerminalName && a.idx === this.nextTerminalOccurrence && !this.found && (a = b.concat(c), a = new f.Flat({definition:a}), this.possibleTokTypes = t.first(a), this.found = !0);
      }, b;
    }(g);
    d.NextAfterTokenWalker = g;
    a = function(a) {
      function b(b, c) {
        var d = a.call(this) || this;
        return d.topRule = b, d.occurrence = c, d.result = {token:void 0, occurrence:void 0, isEndOfRule:void 0}, d;
      }
      return k(b, a), b.prototype.startWalking = function() {
        return this.walk(this.topRule), this.result;
      }, b;
    }(a.RestWalker);
    d.AbstractNextTerminalAfterProductionWalker = a;
    g = function(a) {
      function b() {
        return null !== a && a.apply(this, arguments) || this;
      }
      return k(b, a), b.prototype.walkMany = function(b, d, e) {
        b.idx === this.occurrence ? (b = c.first(d.concat(e)), this.result.isEndOfRule = void 0 === b, b instanceof f.Terminal && (this.result.token = b.terminalType, this.result.occurrence = b.idx)) : a.prototype.walkMany.call(this, b, d, e);
      }, b;
    }(a);
    d.NextTerminalAfterManyWalker = g;
    g = function(a) {
      function b() {
        return null !== a && a.apply(this, arguments) || this;
      }
      return k(b, a), b.prototype.walkManySep = function(b, d, e) {
        b.idx === this.occurrence ? (b = c.first(d.concat(e)), this.result.isEndOfRule = void 0 === b, b instanceof f.Terminal && (this.result.token = b.terminalType, this.result.occurrence = b.idx)) : a.prototype.walkManySep.call(this, b, d, e);
      }, b;
    }(a);
    d.NextTerminalAfterManySepWalker = g;
    g = function(a) {
      function b() {
        return null !== a && a.apply(this, arguments) || this;
      }
      return k(b, a), b.prototype.walkAtLeastOne = function(b, d, e) {
        b.idx === this.occurrence ? (b = c.first(d.concat(e)), this.result.isEndOfRule = void 0 === b, b instanceof f.Terminal && (this.result.token = b.terminalType, this.result.occurrence = b.idx)) : a.prototype.walkAtLeastOne.call(this, b, d, e);
      }, b;
    }(a);
    d.NextTerminalAfterAtLeastOneWalker = g;
    a = function(a) {
      function b() {
        return null !== a && a.apply(this, arguments) || this;
      }
      return k(b, a), b.prototype.walkAtLeastOneSep = function(b, d, e) {
        b.idx === this.occurrence ? (b = c.first(d.concat(e)), this.result.isEndOfRule = void 0 === b, b instanceof f.Terminal && (this.result.token = b.terminalType, this.result.occurrence = b.idx)) : a.prototype.walkAtLeastOneSep.call(this, b, d, e);
      }, b;
    }(a);
    d.NextTerminalAfterAtLeastOneSepWalker = a;
    d.possiblePathsFrom = function y(a, d, e) {
      function b(b) {
        b = y(b.concat(c.drop(a, k + 1)), d, e);
        return g.concat(b);
      }
      void 0 === e && (e = []);
      e = c.cloneArr(e);
      for (var g = [], k = 0; e.length < d && k < a.length;) {
        var h = a[k];
        if (h instanceof f.Flat || h instanceof f.NonTerminal) {
          return b(h.definition);
        }
        if (h instanceof f.Option) {
          g = b(h.definition);
        } else {
          if (h instanceof f.RepetitionMandatory) {
            return b(h = h.definition.concat([new f.Repetition({definition:h.definition})]));
          }
          if (h instanceof f.RepetitionMandatoryWithSeparator) {
            return b(h = [new f.Flat({definition:h.definition}), new f.Repetition({definition:[new f.Terminal({terminalType:h.separator})].concat(h.definition)})]);
          }
          if (h instanceof f.RepetitionWithSeparator) {
            h = h.definition.concat([new f.Repetition({definition:[new f.Terminal({terminalType:h.separator})].concat(h.definition)})]), g = b(h);
          } else {
            if (h instanceof f.Repetition) {
              h = h.definition.concat([new f.Repetition({definition:h.definition})]), g = b(h);
            } else {
              if (h instanceof f.Alternation) {
                return c.forEach(h.definition, function(a) {
                  g = b(a.definition);
                }), g;
              }
              if (!(h instanceof f.Terminal)) {
                throw Error("non exhaustive match");
              }
              e.push(h.terminalType);
            }
          }
        }
        k++;
      }
      return g.push({partialPath:e, suffixDef:c.drop(a, k)}), g;
    };
    d.nextPossibleTokensAfter = function(a, d, e, g) {
      var b = ["EXIT_NONE_TERMINAL"], k = !1, m = d.length;
      g = m - g - 1;
      var p = [], q = [];
      for (q.push({idx:-1, def:a, ruleStack:[], occurrenceStack:[]}); !c.isEmpty(q);) {
        var t = q.pop();
        if ("EXIT_ALTERNATIVE" !== t) {
          a = t.def;
          var y = t.idx, D = t.ruleStack, F = t.occurrenceStack;
          if (!c.isEmpty(a)) {
            if (t = a[0], "EXIT_NONE_TERMINAL" === t) {
              var B = {idx:y, def:c.drop(a), ruleStack:c.dropRight(D), occurrenceStack:c.dropRight(F)};
              q.push(B);
            } else {
              if (t instanceof f.Terminal) {
                if (y < m - 1) {
                  y += 1, e(d[y], t.terminalType) && (B = {idx:y, def:c.drop(a), ruleStack:D, occurrenceStack:F}, q.push(B));
                } else {
                  if (y !== m - 1) {
                    throw Error("non exhaustive match");
                  }
                  p.push({nextTokenType:t.terminalType, nextTokenOccurrence:t.idx, ruleStack:D, occurrenceStack:F});
                  k = !0;
                }
              } else {
                if (t instanceof f.NonTerminal) {
                  B = c.cloneArr(D), B.push(t.nonTerminalName), D = c.cloneArr(F), D.push(t.idx), B = {idx:y, def:t.definition.concat(b, c.drop(a)), ruleStack:B, occurrenceStack:D}, q.push(B);
                } else {
                  if (t instanceof f.Option) {
                    var E = {idx:y, def:c.drop(a), ruleStack:D, occurrenceStack:F};
                    q.push(E);
                    q.push("EXIT_ALTERNATIVE");
                    a = {idx:y, def:t.definition.concat(c.drop(a)), ruleStack:D, occurrenceStack:F};
                    q.push(a);
                  } else {
                    if (t instanceof f.RepetitionMandatory) {
                      B = new f.Repetition({definition:t.definition, idx:t.idx}), B = {idx:y, def:t.definition.concat([B], c.drop(a)), ruleStack:D, occurrenceStack:F}, q.push(B);
                    } else {
                      if (t instanceof f.RepetitionMandatoryWithSeparator) {
                        E = new f.Terminal({terminalType:t.separator}), B = new f.Repetition({definition:[E].concat(t.definition), idx:t.idx}), B = {idx:y, def:t.definition.concat([B], c.drop(a)), ruleStack:D, occurrenceStack:F}, q.push(B);
                      } else {
                        if (t instanceof f.RepetitionWithSeparator) {
                          E = {idx:y, def:c.drop(a), ruleStack:D, occurrenceStack:F}, q.push(E), q.push("EXIT_ALTERNATIVE"), E = new f.Terminal({terminalType:t.separator}), E = new f.Repetition({definition:[E].concat(t.definition), idx:t.idx}), a = {idx:y, def:t.definition.concat([E], c.drop(a)), ruleStack:D, occurrenceStack:F}, q.push(a);
                        } else {
                          if (t instanceof f.Repetition) {
                            E = {idx:y, def:c.drop(a), ruleStack:D, occurrenceStack:F}, q.push(E), q.push("EXIT_ALTERNATIVE"), E = new f.Repetition({definition:t.definition, idx:t.idx}), a = {idx:y, def:t.definition.concat([E], c.drop(a)), ruleStack:D, occurrenceStack:F}, q.push(a);
                          } else {
                            if (t instanceof f.Alternation) {
                              for (E = t.definition.length - 1; 0 <= E; E--) {
                                var H = {idx:y, def:t.definition[E].definition.concat(c.drop(a)), ruleStack:D, occurrenceStack:F};
                                q.push(H);
                                q.push("EXIT_ALTERNATIVE");
                              }
                            } else {
                              if (t instanceof f.Flat) {
                                q.push({idx:y, def:t.definition.concat(c.drop(a)), ruleStack:D, occurrenceStack:F});
                              } else {
                                if (!(t instanceof f.Rule)) {
                                  throw Error("non exhaustive match");
                                }
                                q.push(h(t, y, D, F));
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          k && c.last(q).idx <= g && q.pop();
        }
      }
      return p;
    };
  }, function(a, d, g) {
    function h(a, d, e) {
      return [new k.Option({definition:[new k.Terminal({terminalType:a.separator})].concat(a.definition)})].concat(d, e);
    }
    Object.defineProperty(d, "__esModule", {value:!0});
    var e = g(0), k = g(1);
    a = function() {
      function a() {
      }
      return a.prototype.walk = function(a, c) {
        var d = this;
        void 0 === c && (c = []);
        e.forEach(a.definition, function(f, b) {
          b = e.drop(a.definition, b + 1);
          if (f instanceof k.NonTerminal) {
            d.walkProdRef(f, b, c);
          } else {
            if (f instanceof k.Terminal) {
              d.walkTerminal(f, b, c);
            } else {
              if (f instanceof k.Flat) {
                d.walkFlat(f, b, c);
              } else {
                if (f instanceof k.Option) {
                  d.walkOption(f, b, c);
                } else {
                  if (f instanceof k.RepetitionMandatory) {
                    d.walkAtLeastOne(f, b, c);
                  } else {
                    if (f instanceof k.RepetitionMandatoryWithSeparator) {
                      d.walkAtLeastOneSep(f, b, c);
                    } else {
                      if (f instanceof k.RepetitionWithSeparator) {
                        d.walkManySep(f, b, c);
                      } else {
                        if (f instanceof k.Repetition) {
                          d.walkMany(f, b, c);
                        } else {
                          if (!(f instanceof k.Alternation)) {
                            throw Error("non exhaustive match");
                          }
                          d.walkOr(f, b, c);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        });
      }, a.prototype.walkTerminal = function(a, c, d) {
      }, a.prototype.walkProdRef = function(a, c, d) {
      }, a.prototype.walkFlat = function(a, c, d) {
        c = c.concat(d);
        this.walk(a, c);
      }, a.prototype.walkOption = function(a, c, d) {
        c = c.concat(d);
        this.walk(a, c);
      }, a.prototype.walkAtLeastOne = function(a, c, d) {
        c = [new k.Option({definition:a.definition})].concat(c, d);
        this.walk(a, c);
      }, a.prototype.walkAtLeastOneSep = function(a, c, d) {
        c = h(a, c, d);
        this.walk(a, c);
      }, a.prototype.walkMany = function(a, c, d) {
        c = [new k.Option({definition:a.definition})].concat(c, d);
        this.walk(a, c);
      }, a.prototype.walkManySep = function(a, c, d) {
        c = h(a, c, d);
        this.walk(a, c);
      }, a.prototype.walkOr = function(a, c, d) {
        var f = this, b = c.concat(d);
        e.forEach(a.definition, function(a) {
          a = new k.Flat({definition:[a]});
          f.walk(a, b);
        });
      }, a;
    }();
    d.RestWalker = a;
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    var h = g(27), e = g(0), k = g(7);
    a = g(20);
    !function(a) {
      a[a.MISSING_PATTERN = 0] = "MISSING_PATTERN";
      a[a.INVALID_PATTERN = 1] = "INVALID_PATTERN";
      a[a.EOI_ANCHOR_FOUND = 2] = "EOI_ANCHOR_FOUND";
      a[a.UNSUPPORTED_FLAGS_FOUND = 3] = "UNSUPPORTED_FLAGS_FOUND";
      a[a.DUPLICATE_PATTERNS_FOUND = 4] = "DUPLICATE_PATTERNS_FOUND";
      a[a.INVALID_GROUP_TYPE_FOUND = 5] = "INVALID_GROUP_TYPE_FOUND";
      a[a.PUSH_MODE_DOES_NOT_EXIST = 6] = "PUSH_MODE_DOES_NOT_EXIST";
      a[a.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
      a[a.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
      a[a.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
      a[a.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
      a[a.SOI_ANCHOR_FOUND = 11] = "SOI_ANCHOR_FOUND";
      a[a.EMPTY_MATCH_PATTERN = 12] = "EMPTY_MATCH_PATTERN";
      a[a.NO_LINE_BREAKS_FLAGS = 13] = "NO_LINE_BREAKS_FLAGS";
      a[a.UNREACHABLE_PATTERN = 14] = "UNREACHABLE_PATTERN";
      a[a.IDENTIFY_TERMINATOR = 15] = "IDENTIFY_TERMINATOR";
      a[a.CUSTOM_LINE_BREAK = 16] = "CUSTOM_LINE_BREAK";
    }(d.LexerDefinitionErrorType || (d.LexerDefinitionErrorType = {}));
    var c = {deferDefinitionErrorsHandling:!1, positionTracking:"full", lineTerminatorsPattern:/\n|\r\n?/g, lineTerminatorCharacters:["\n", "\r"], ensureOptimizations:!1, safeMode:!1, errorMessageProvider:a.defaultLexerErrorProvider};
    Object.freeze(c);
    a = function() {
      function a(a, d) {
        var f = this;
        if (void 0 === d && (d = c), this.lexerDefinition = a, this.lexerDefinitionErrors = [], this.lexerDefinitionWarning = [], this.patternIdxToConfig = {}, this.charCodeToPatternIdxToConfig = {}, this.modes = [], this.emptyGroups = {}, this.config = void 0, this.trackStartLines = !0, this.trackEndLines = !0, this.hasCustom = !1, this.canModeBeOptimized = {}, "boolean" == typeof d) {
          throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");
        }
        if (this.config = e.merge(c, d), this.config.lineTerminatorsPattern === c.lineTerminatorsPattern) {
          this.config.lineTerminatorsPattern = h.LineTerminatorOptimizedTester;
        } else {
          if (this.config.lineTerminatorCharacters === c.lineTerminatorCharacters) {
            throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
          }
        }
        if (d.safeMode && d.ensureOptimizations) {
          throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
        }
        this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking);
        this.trackEndLines = /full/i.test(this.config.positionTracking);
        var b, g = !0;
        e.isArray(a) ? ((b = {modes:{}}).modes[h.DEFAULT_MODE] = e.cloneArr(a), b[h.DEFAULT_MODE] = h.DEFAULT_MODE) : (g = !1, b = e.cloneObj(a));
        this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(h.performRuntimeChecks(b, this.trackStartLines, this.config.lineTerminatorCharacters));
        this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(h.performWarningRuntimeChecks(b, this.trackStartLines, this.config.lineTerminatorCharacters));
        b.modes = b.modes ? b.modes : {};
        e.forEach(b.modes, function(a, c) {
          b.modes[c] = e.reject(a, function(a) {
            return e.isUndefined(a);
          });
        });
        var p = e.keys(b.modes);
        if (e.forEach(b.modes, function(a, b) {
          if (f.modes.push(b), f.lexerDefinitionErrors = f.lexerDefinitionErrors.concat(h.validatePatterns(a, p)), e.isEmpty(f.lexerDefinitionErrors)) {
            k.augmentTokenTypes(a), a = h.analyzeTokenTypes(a, {lineTerminatorCharacters:f.config.lineTerminatorCharacters, positionTracking:d.positionTracking, ensureOptimizations:d.ensureOptimizations, safeMode:d.safeMode}), f.patternIdxToConfig[b] = a.patternIdxToConfig, f.charCodeToPatternIdxToConfig[b] = a.charCodeToPatternIdxToConfig, f.emptyGroups = e.merge(f.emptyGroups, a.emptyGroups), f.hasCustom = a.hasCustom || f.hasCustom, f.canModeBeOptimized[b] = a.canBeOptimized;
          }
        }), this.defaultMode = b.defaultMode, !e.isEmpty(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {
          throw a = e.map(this.lexerDefinitionErrors, function(a) {
            return a.message;
          }).join("-----------------------\n"), Error("Errors detected in definition of Lexer:\n" + a);
        }
        if (e.forEach(this.lexerDefinitionWarning, function(a) {
          e.PRINT_WARNING(a.message);
        }), h.SUPPORT_STICKY ? (this.chopInput = e.IDENTITY, this.match = this.matchWithTest) : (this.updateLastIndex = e.NOOP, this.match = this.matchWithExec), g && (this.handleModes = e.NOOP), !1 === this.trackStartLines && (this.computeNewColumn = e.IDENTITY), !1 === this.trackEndLines && (this.updateTokenEndLineColumnLocation = e.NOOP), /full/i.test(this.config.positionTracking)) {
          this.createTokenInstance = this.createFullToken;
        } else {
          if (/onlyStart/i.test(this.config.positionTracking)) {
            this.createTokenInstance = this.createStartOnlyToken;
          } else {
            if (!/onlyOffset/i.test(this.config.positionTracking)) {
              throw Error('Invalid <positionTracking> config option: "' + this.config.positionTracking + '"');
            }
            this.createTokenInstance = this.createOffsetOnlyToken;
          }
        }
        this.hasCustom ? this.addToken = this.addTokenUsingPush : this.addToken = this.addTokenUsingMemberAccess;
        a = e.reduce(this.canModeBeOptimized, function(a, b, c) {
          return !1 === b && a.push(c), a;
        }, []);
        if (d.ensureOptimizations && !e.isEmpty(a)) {
          throw Error("Lexer Modes: < " + a.join(", ") + ' > cannot be optimized.\n\t Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n\t Or inspect the console log for details on how to resolve these issues.');
        }
      }
      return a.prototype.tokenize = function(a, c) {
        if (void 0 === c && (c = this.defaultMode), !e.isEmpty(this.lexerDefinitionErrors)) {
          throw a = e.map(this.lexerDefinitionErrors, function(a) {
            return a.message;
          }).join("-----------------------\n"), Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + a);
        }
        return this.tokenizeInternal(a, c);
      }, a.prototype.tokenizeInternal = function(a, c) {
        function d(a) {
          S.push(a);
          N = this.charCodeToPatternIdxToConfig[a];
          I = this.patternIdxToConfig[a];
          J = J = I.length;
          a = this.canModeBeOptimized[a] && !1 === this.config.safeMode;
          R = N && a ? function(a) {
            a = N[a];
            return void 0 === a ? Q : a;
          } : function() {
            return I;
          };
        }
        var b, f, g, k, p, t, r, u = this, v = a, C = v.length, A = 0, D = 0, F = Array(this.hasCustom ? 0 : Math.floor(a.length / 10)), B = [], E = this.trackStartLines ? 1 : void 0, H = this.trackStartLines ? 1 : void 0, L = h.cloneEmptyGroups(this.emptyGroups), K = this.trackStartLines, P = this.config.lineTerminatorsPattern, J = 0, I = [], N = [], S = [], Q = [];
        Object.freeze(Q);
        var Z, R = void 0, W = function(a) {
          if (1 === S.length && void 0 === a.tokenType.PUSH_MODE) {
            var b = u.config.errorMessageProvider.buildUnableToPopLexerModeMessage(a);
            B.push({offset:a.startOffset, line:void 0 !== a.startLine ? a.startLine : void 0, column:void 0 !== a.startColumn ? a.startColumn : void 0, length:a.image.length, message:b});
          } else {
            S.pop(), a = e.last(S), I = u.patternIdxToConfig[a], N = u.charCodeToPatternIdxToConfig[a], J = I.length, a = u.canModeBeOptimized[a] && !1 === u.config.safeMode, R = N && a ? function(a) {
              a = N[a];
              return void 0 === a ? Q : a;
            } : function() {
              return I;
            };
          }
        };
        for (d.call(this, c); A < C;) {
          c = null;
          var O = v.charCodeAt(A);
          var ca = R(O);
          var M = ca.length;
          for (b = 0; b < M; b++) {
            var V = (Z = ca[b]).pattern;
            if (!1 !== (fa = Z.short) ? O === fa && (c = V) : !0 === Z.isCustom ? c = null !== (r = V.exec(v, A, F, L)) ? r[0] : r : (this.updateLastIndex(V, A), c = this.match(V, a, A)), null !== c) {
              void 0 !== (V = Z.longerAlt) && (V = I[V], b = V.pattern, !0 === V.isCustom ? f = null !== (r = b.exec(v, A, F, L)) ? r[0] : r : (this.updateLastIndex(b, A), f = this.match(b, a, A)), f && f.length > c.length && (c = f, Z = V));
              break;
            }
          }
          if (null !== c) {
            if (g = c.length, void 0 !== (k = Z.group) && (p = Z.tokenTypeIdx, t = this.createTokenInstance(c, A, p, Z.tokenType, E, H, g), !1 === k ? D = this.addToken(F, D, t) : L[k].push(t)), a = this.chopInput(a, g), A += g, H = this.computeNewColumn(H, g), !0 === K && !0 === Z.canLineTerminator) {
              V = 0;
              O = b = void 0;
              P.lastIndex = 0;
              do {
                !0 === (b = P.test(c)) && (O = P.lastIndex - 1, V++);
              } while (b);
              0 !== V && (E += V, H = g - O, this.updateTokenEndLineColumnLocation(t, k, O, V, E, H, g));
            }
            this.handleModes(Z, W, d, t);
          } else {
            c = A;
            b = E;
            O = H;
            for (M = !1; !M && A < C;) {
              for (v.charCodeAt(A), a = this.chopInput(a, 1), A++, ca = 0; ca < J; ca++) {
                var fa, ja = I[ca];
                V = ja.pattern;
                if (!1 !== (fa = ja.short) ? v.charCodeAt(A) === fa && (M = !0) : !0 === ja.isCustom ? M = null !== V.exec(v, A, F, L) : (this.updateLastIndex(V, A), M = null !== V.exec(a)), !0 === M) {
                  break;
                }
              }
            }
            V = A - c;
            ca = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(v, c, V, b, O);
            B.push({offset:c, line:b, column:O, length:V, message:ca});
          }
        }
        return this.hasCustom || (F.length = D), {tokens:F, groups:L, errors:B};
      }, a.prototype.handleModes = function(a, c, d, b) {
        !0 === a.pop ? (a = a.push, c(b), void 0 !== a && d.call(this, a)) : void 0 !== a.push && d.call(this, a.push);
      }, a.prototype.chopInput = function(a, c) {
        return a.substring(c);
      }, a.prototype.updateLastIndex = function(a, c) {
        a.lastIndex = c;
      }, a.prototype.updateTokenEndLineColumnLocation = function(a, c, d, b, e, g, h) {
        var f, k;
        void 0 !== c && (k = (f = d === h - 1) ? -1 : 0, 1 === b && !0 === f || (a.endLine = e + k, a.endColumn = g - 1 - k));
      }, a.prototype.computeNewColumn = function(a, c) {
        return a + c;
      }, a.prototype.createTokenInstance = function() {
        for (var a = 0; a < arguments.length; a++) {
        }
        return null;
      }, a.prototype.createOffsetOnlyToken = function(a, c, d, b) {
        return {image:a, startOffset:c, tokenTypeIdx:d, tokenType:b};
      }, a.prototype.createStartOnlyToken = function(a, c, d, b, e, g) {
        return {image:a, startOffset:c, startLine:e, startColumn:g, tokenTypeIdx:d, tokenType:b};
      }, a.prototype.createFullToken = function(a, c, d, b, e, g, h) {
        return {image:a, startOffset:c, endOffset:c + h - 1, startLine:e, endLine:e, startColumn:g, endColumn:g + h - 1, tokenTypeIdx:d, tokenType:b};
      }, a.prototype.addToken = function(a, c, d) {
        return 666;
      }, a.prototype.addTokenUsingPush = function(a, c, d) {
        return a.push(d), c;
      }, a.prototype.addTokenUsingMemberAccess = function(a, c, d) {
        return a[c] = d, ++c;
      }, a.prototype.match = function(a, c, d) {
        return null;
      }, a.prototype.matchWithTest = function(a, c, d) {
        return !0 === a.test(c) ? c.substring(d, a.lastIndex) : null;
      }, a.prototype.matchWithExec = function(a, c) {
        a = a.exec(c);
        return null !== a ? a[0] : a;
      }, a.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.", a.NA = /NOT_APPLICABLE/, a;
    }();
    d.Lexer = a;
  }, function(a, d, g) {
    var h, e = this && this.__extends || (h = function(a, b) {
      return (h = Object.setPrototypeOf || {__proto__:[]} instanceof Array && function(a, b) {
        a.__proto__ = b;
      } || function(a, b) {
        for (var c in b) {
          b.hasOwnProperty(c) && (a[c] = b[c]);
        }
      })(a, b);
    }, function(a, b) {
      function c() {
        this.constructor = a;
      }
      h(a, b);
      a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c);
    });
    Object.defineProperty(d, "__esModule", {value:!0});
    var k = g(0), c = g(4), p = g(9), t = g(1);
    a = g(5);
    d.addTerminalToCst = function(a, b, c) {
      void 0 === a.children[c] ? a.children[c] = [b] : a.children[c].push(b);
    };
    d.addNoneTerminalToCst = function(a, b, c) {
      void 0 === a.children[b] ? a.children[b] = [c] : a.children[b].push(c);
    };
    var f = function(a) {
      function b(b) {
        var c = a.call(this) || this;
        return c.result = [], c.ruleIdx = b, c;
      }
      return e(b, a), b.prototype.collectNamedDSLMethod = function(a, b, c) {
        if (!k.isUndefined(a.name)) {
          if (a instanceof t.Option || a instanceof t.Repetition || a instanceof t.RepetitionMandatory || a instanceof t.Alternation) {
            b = new b({definition:a.definition, idx:a.idx});
          } else {
            if (!(a instanceof t.RepetitionMandatoryWithSeparator || a instanceof t.RepetitionWithSeparator)) {
              throw Error("non exhaustive match");
            }
            b = new b({definition:a.definition, idx:a.idx, separator:a.separator});
          }
          b = [b];
          c = p.getKeyForAutomaticLookahead(this.ruleIdx, c, a.idx);
          this.result.push({def:b, key:c, name:a.name, orgProd:a});
        }
      }, b.prototype.visitOption = function(a) {
        this.collectNamedDSLMethod(a, t.Option, p.OPTION_IDX);
      }, b.prototype.visitRepetition = function(a) {
        this.collectNamedDSLMethod(a, t.Repetition, p.MANY_IDX);
      }, b.prototype.visitRepetitionMandatory = function(a) {
        this.collectNamedDSLMethod(a, t.RepetitionMandatory, p.AT_LEAST_ONE_IDX);
      }, b.prototype.visitRepetitionMandatoryWithSeparator = function(a) {
        this.collectNamedDSLMethod(a, t.RepetitionMandatoryWithSeparator, p.AT_LEAST_ONE_SEP_IDX);
      }, b.prototype.visitRepetitionWithSeparator = function(a) {
        this.collectNamedDSLMethod(a, t.RepetitionWithSeparator, p.MANY_SEP_IDX);
      }, b.prototype.visitAlternation = function(a) {
        var b = this;
        this.collectNamedDSLMethod(a, t.Alternation, p.OR_IDX);
        var c = 1 < a.definition.length;
        k.forEach(a.definition, function(d, e) {
          if (!k.isUndefined(d.name)) {
            var f = c ? [new t.Option({definition:d.definition})] : d.definition;
            e = p.getKeyForAltIndex(b.ruleIdx, p.OR_IDX, a.idx, e);
            b.result.push({def:f, key:e, name:d.name, orgProd:d});
          }
        });
      }, b;
    }(a.GAstVisitor);
    d.NamedDSLMethodsCollectorVisitor = f;
    d.analyzeCst = function(a, b) {
      var d = {dictDef:new c.HashTable, allRuleNames:[]};
      return k.forEach(a, function(a) {
        var c = b.get(a.name);
        d.allRuleNames.push(a.name);
        c = new f(c);
        a.accept(c);
        k.forEach(c.result, function(b) {
          b.def;
          b.key;
          d.allRuleNames.push(a.name + b.name);
        });
      }), d;
    };
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    d.VERSION = "4.6.0";
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    d = g(3);
    var h = g(15), e = g(2), k = g(6), c = g(17), p = g(10), t = g(39), f = g(5), n = g(1), b = g(24), m = g(40);
    g = g(20);
    var q = {};
    q.VERSION = c.VERSION;
    q.Parser = d.Parser;
    q.CstParser = d.CstParser;
    q.EmbeddedActionsParser = d.EmbeddedActionsParser;
    q.ParserDefinitionErrorType = d.ParserDefinitionErrorType;
    q.Lexer = h.Lexer;
    q.LexerDefinitionErrorType = h.LexerDefinitionErrorType;
    q.EOF = e.EOF;
    q.tokenName = e.tokenName;
    q.tokenLabel = e.tokenLabel;
    q.tokenMatcher = e.tokenMatcher;
    q.createToken = e.createToken;
    q.createTokenInstance = e.createTokenInstance;
    q.EMPTY_ALT = d.EMPTY_ALT;
    q.defaultParserErrorProvider = p.defaultParserErrorProvider;
    q.isRecognitionException = k.isRecognitionException;
    q.EarlyExitException = k.EarlyExitException;
    q.MismatchedTokenException = k.MismatchedTokenException;
    q.NotAllInputParsedException = k.NotAllInputParsedException;
    q.NoViableAltException = k.NoViableAltException;
    q.defaultLexerErrorProvider = g.defaultLexerErrorProvider;
    q.Flat = n.Flat;
    q.Repetition = n.Repetition;
    q.RepetitionWithSeparator = n.RepetitionWithSeparator;
    q.RepetitionMandatory = n.RepetitionMandatory;
    q.RepetitionMandatoryWithSeparator = n.RepetitionMandatoryWithSeparator;
    q.Option = n.Option;
    q.Alternation = n.Alternation;
    q.NonTerminal = n.NonTerminal;
    q.Terminal = n.Terminal;
    q.Rule = n.Rule;
    q.GAstVisitor = f.GAstVisitor;
    q.serializeGrammar = n.serializeGrammar;
    q.serializeProduction = n.serializeProduction;
    q.resolveGrammar = b.resolveGrammar;
    q.defaultGrammarResolverErrorProvider = p.defaultGrammarResolverErrorProvider;
    q.validateGrammar = b.validateGrammar;
    q.defaultGrammarValidatorErrorProvider = p.defaultGrammarValidatorErrorProvider;
    q.assignOccurrenceIndices = b.assignOccurrenceIndices;
    q.clearCache = function() {
      console.warn("The clearCache function was 'soft' removed from the Chevrotain API.\n\t It performs no action other than printing this message.\n\t Please avoid using it as it will be completely removed in the future");
    };
    q.createSyntaxDiagramsCode = t.createSyntaxDiagramsCode;
    q.generateParserFactory = m.generateParserFactory;
    q.generateParserModule = m.generateParserModule;
    a.exports = q;
  }, function(a, d, g) {
    var h, e;
    "undefined" != typeof self && self;
    g = [];
    void 0 === (e = "function" == typeof(h = function() {
      function a() {
      }
      function c(a) {
        return a.charCodeAt(0);
      }
      function d(a, b) {
        void 0 !== a.length ? a.forEach(function(a) {
          b.push(a);
        }) : b.push(a);
      }
      function e(a, b) {
        if (!0 === a[b]) {
          throw "duplicate flag " + b;
        }
        a[b] = !0;
      }
      function f(a) {
        if (void 0 === a) {
          throw Error("Internal Error - Should never get here!");
        }
      }
      function g() {
      }
      a.prototype.saveState = function() {
        return {idx:this.idx, input:this.input, groupIdx:this.groupIdx};
      };
      a.prototype.restoreState = function(a) {
        this.idx = a.idx;
        this.input = a.input;
        this.groupIdx = a.groupIdx;
      };
      a.prototype.pattern = function(a) {
        this.idx = 0;
        this.input = a;
        this.groupIdx = 0;
        this.consumeChar("/");
        a = this.disjunction();
        this.consumeChar("/");
        for (var b = {type:"Flags", global:!1, ignoreCase:!1, multiLine:!1, unicode:!1, sticky:!1}; this.isRegExpFlag();) {
          switch(this.popChar()) {
            case "g":
              e(b, "global");
              break;
            case "i":
              e(b, "ignoreCase");
              break;
            case "m":
              e(b, "multiLine");
              break;
            case "u":
              e(b, "unicode");
              break;
            case "y":
              e(b, "sticky");
          }
        }
        if (this.idx !== this.input.length) {
          throw Error("Redundant input: " + this.input.substring(this.idx));
        }
        return {type:"Pattern", flags:b, value:a};
      };
      a.prototype.disjunction = function() {
        var a = [];
        for (a.push(this.alternative()); "|" === this.peekChar();) {
          this.consumeChar("|"), a.push(this.alternative());
        }
        return {type:"Disjunction", value:a};
      };
      a.prototype.alternative = function() {
        for (var a = []; this.isTerm();) {
          a.push(this.term());
        }
        return {type:"Alternative", value:a};
      };
      a.prototype.term = function() {
        return this.isAssertion() ? this.assertion() : this.atom();
      };
      a.prototype.assertion = function() {
        switch(this.popChar()) {
          case "^":
            return {type:"StartAnchor"};
          case "$":
            return {type:"EndAnchor"};
          case "\\":
            switch(this.popChar()) {
              case "b":
                return {type:"WordBoundary"};
              case "B":
                return {type:"NonWordBoundary"};
            }throw Error("Invalid Assertion Escape");
          case "(":
            switch(this.consumeChar("?"), this.popChar()) {
              case "=":
                var a = "Lookahead";
                break;
              case "!":
                a = "NegativeLookahead";
            }f(a);
            var b = this.disjunction();
            return this.consumeChar(")"), {type:a, value:b};
        }
        throw Error("Internal Error - Should never get here!");
      };
      a.prototype.quantifier = function(a) {
        switch(this.popChar()) {
          case "*":
            var b = {atLeast:0, atMost:1 / 0};
            break;
          case "+":
            b = {atLeast:1, atMost:1 / 0};
            break;
          case "?":
            b = {atLeast:0, atMost:1};
            break;
          case "{":
            var c = this.integerIncludingZero();
            switch(this.popChar()) {
              case "}":
                b = {atLeast:c, atMost:c};
                break;
              case ",":
                var d;
                this.isDigit() ? (d = this.integerIncludingZero(), b = {atLeast:c, atMost:d}) : b = {atLeast:c, atMost:1 / 0};
                this.consumeChar("}");
            }if (!0 === a && void 0 === b) {
              return;
            }
            f(b);
        }
        if (!0 !== a || void 0 !== b) {
          return f(b), "?" === this.peekChar(0) ? (this.consumeChar("?"), b.greedy = !1) : b.greedy = !0, b.type = "Quantifier", b;
        }
      };
      a.prototype.atom = function() {
        switch(this.peekChar()) {
          case ".":
            var a = this.dotAll();
            break;
          case "\\":
            a = this.atomEscape();
            break;
          case "[":
            a = this.characterClass();
            break;
          case "(":
            a = this.group();
        }
        return void 0 === a && this.isPatternCharacter() && (a = this.patternCharacter()), f(a), this.isQuantifier() && (a.quantifier = this.quantifier()), a;
      };
      a.prototype.dotAll = function() {
        return this.consumeChar("."), {type:"Set", complement:!0, value:[c("\n"), c("\r"), c("\u2028"), c("\u2029")]};
      };
      a.prototype.atomEscape = function() {
        switch(this.consumeChar("\\"), this.peekChar()) {
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            return this.decimalEscapeAtom();
          case "d":
          case "D":
          case "s":
          case "S":
          case "w":
          case "W":
            return this.characterClassEscape();
          case "f":
          case "n":
          case "r":
          case "t":
          case "v":
            return this.controlEscapeAtom();
          case "c":
            return this.controlLetterEscapeAtom();
          case "0":
            return this.nulCharacterAtom();
          case "x":
            return this.hexEscapeSequenceAtom();
          case "u":
            return this.regExpUnicodeEscapeSequenceAtom();
          default:
            return this.identityEscapeAtom();
        }
      };
      a.prototype.decimalEscapeAtom = function() {
        return {type:"GroupBackReference", value:this.positiveInteger()};
      };
      a.prototype.characterClassEscape = function() {
        var a = !1;
        switch(this.popChar()) {
          case "d":
            var b = x;
            break;
          case "D":
            b = x;
            a = !0;
            break;
          case "s":
            b = r;
            break;
          case "S":
            b = r;
            a = !0;
            break;
          case "w":
            b = z;
            break;
          case "W":
            b = z, a = !0;
        }
        return f(b), {type:"Set", value:b, complement:a};
      };
      a.prototype.controlEscapeAtom = function() {
        switch(this.popChar()) {
          case "f":
            var a = c("\f");
            break;
          case "n":
            a = c("\n");
            break;
          case "r":
            a = c("\r");
            break;
          case "t":
            a = c("\t");
            break;
          case "v":
            a = c("\v");
        }
        return f(a), {type:"Character", value:a};
      };
      a.prototype.controlLetterEscapeAtom = function() {
        this.consumeChar("c");
        var a = this.popChar();
        if (!1 === /[a-zA-Z]/.test(a)) {
          throw Error("Invalid ");
        }
        return {type:"Character", value:a.toUpperCase().charCodeAt(0) - 64};
      };
      a.prototype.nulCharacterAtom = function() {
        return this.consumeChar("0"), {type:"Character", value:c("\x00")};
      };
      a.prototype.hexEscapeSequenceAtom = function() {
        return this.consumeChar("x"), this.parseHexDigits(2);
      };
      a.prototype.regExpUnicodeEscapeSequenceAtom = function() {
        return this.consumeChar("u"), this.parseHexDigits(4);
      };
      a.prototype.identityEscapeAtom = function() {
        var a = this.popChar();
        return {type:"Character", value:c(a)};
      };
      a.prototype.classPatternCharacterAtom = function() {
        switch(this.peekChar()) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
          case "\\":
          case "]":
            throw Error("TBD");
          default:
            var a = this.popChar();
            return {type:"Character", value:c(a)};
        }
      };
      a.prototype.characterClass = function() {
        var a = [], b = !1;
        this.consumeChar("[");
        for ("^" === this.peekChar(0) && (this.consumeChar("^"), b = !0); this.isClassAtom();) {
          var e = this.classAtom();
          if ("Character" === e.type && this.isRangeDash()) {
            this.consumeChar("-");
            var f = this.classAtom();
            if ("Character" === f.type) {
              if (f.value < e.value) {
                throw Error("Range out of order in character class");
              }
              a.push({from:e.value, to:f.value});
            } else {
              d(e.value, a), a.push(c("-")), d(f.value, a);
            }
          } else {
            d(e.value, a);
          }
        }
        return this.consumeChar("]"), {type:"Set", complement:b, value:a};
      };
      a.prototype.classAtom = function() {
        switch(this.peekChar()) {
          case "]":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            throw Error("TBD");
          case "\\":
            return this.classEscape();
          default:
            return this.classPatternCharacterAtom();
        }
      };
      a.prototype.classEscape = function() {
        switch(this.consumeChar("\\"), this.peekChar()) {
          case "b":
            return this.consumeChar("b"), {type:"Character", value:c("\b")};
          case "d":
          case "D":
          case "s":
          case "S":
          case "w":
          case "W":
            return this.characterClassEscape();
          case "f":
          case "n":
          case "r":
          case "t":
          case "v":
            return this.controlEscapeAtom();
          case "c":
            return this.controlLetterEscapeAtom();
          case "0":
            return this.nulCharacterAtom();
          case "x":
            return this.hexEscapeSequenceAtom();
          case "u":
            return this.regExpUnicodeEscapeSequenceAtom();
          default:
            return this.identityEscapeAtom();
        }
      };
      a.prototype.group = function() {
        var a = !0;
        switch(this.consumeChar("("), this.peekChar(0)) {
          case "?":
            this.consumeChar("?");
            this.consumeChar(":");
            a = !1;
            break;
          default:
            this.groupIdx++;
        }
        var b = this.disjunction();
        this.consumeChar(")");
        b = {type:"Group", capturing:a, value:b};
        return a && (b.idx = this.groupIdx), b;
      };
      a.prototype.positiveInteger = function() {
        var a = this.popChar();
        if (!1 === y.test(a)) {
          throw Error("Expecting a positive integer");
        }
        for (; q.test(this.peekChar(0));) {
          a += this.popChar();
        }
        return parseInt(a, 10);
      };
      a.prototype.integerIncludingZero = function() {
        var a = this.popChar();
        if (!1 === q.test(a)) {
          throw Error("Expecting an integer");
        }
        for (; q.test(this.peekChar(0));) {
          a += this.popChar();
        }
        return parseInt(a, 10);
      };
      a.prototype.patternCharacter = function() {
        var a = this.popChar();
        switch(a) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
          case "^":
          case "$":
          case "\\":
          case ".":
          case "*":
          case "+":
          case "?":
          case "(":
          case ")":
          case "[":
          case "|":
            throw Error("TBD");
          default:
            return {type:"Character", value:c(a)};
        }
      };
      a.prototype.isRegExpFlag = function() {
        switch(this.peekChar(0)) {
          case "g":
          case "i":
          case "m":
          case "u":
          case "y":
            return !0;
          default:
            return !1;
        }
      };
      a.prototype.isRangeDash = function() {
        return "-" === this.peekChar() && this.isClassAtom(1);
      };
      a.prototype.isDigit = function() {
        return q.test(this.peekChar(0));
      };
      a.prototype.isClassAtom = function(a) {
        switch(void 0 === a && (a = 0), this.peekChar(a)) {
          case "]":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            return !1;
          default:
            return !0;
        }
      };
      a.prototype.isTerm = function() {
        return this.isAtom() || this.isAssertion();
      };
      a.prototype.isAtom = function() {
        if (this.isPatternCharacter()) {
          return !0;
        }
        switch(this.peekChar(0)) {
          case ".":
          case "\\":
          case "[":
          case "(":
            return !0;
          default:
            return !1;
        }
      };
      a.prototype.isAssertion = function() {
        switch(this.peekChar(0)) {
          case "^":
          case "$":
            return !0;
          case "\\":
            switch(this.peekChar(1)) {
              case "b":
              case "B":
                return !0;
              default:
                return !1;
            }case "(":
            return "?" === this.peekChar(1) && ("=" === this.peekChar(2) || "!" === this.peekChar(2));
          default:
            return !1;
        }
      };
      a.prototype.isQuantifier = function() {
        var a = this.saveState();
        try {
          return void 0 !== this.quantifier(!0);
        } catch (v) {
          return !1;
        } finally {
          this.restoreState(a);
        }
      };
      a.prototype.isPatternCharacter = function() {
        switch(this.peekChar()) {
          case "^":
          case "$":
          case "\\":
          case ".":
          case "*":
          case "+":
          case "?":
          case "(":
          case ")":
          case "[":
          case "|":
          case "/":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            return !1;
          default:
            return !0;
        }
      };
      a.prototype.parseHexDigits = function(a) {
        for (var b = "", c = 0; c < a; c++) {
          var d = this.popChar();
          if (!1 === h.test(d)) {
            throw Error("Expecting a HexDecimal digits");
          }
          b += d;
        }
        return {type:"Character", value:parseInt(b, 16)};
      };
      a.prototype.peekChar = function(a) {
        return void 0 === a && (a = 0), this.input[this.idx + a];
      };
      a.prototype.popChar = function() {
        var a = this.peekChar(0);
        return this.consumeChar(), a;
      };
      a.prototype.consumeChar = function(a) {
        if (void 0 !== a && this.input[this.idx] !== a) {
          throw Error("Expected: '" + a + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
        }
        if (this.idx >= this.input.length) {
          throw Error("Unexpected end of input");
        }
        this.idx++;
      };
      var b, h = /[0-9a-fA-F]/, q = /[0-9]/, y = /[1-9]/, x = [];
      for (b = c("0"); b <= c("9"); b++) {
        x.push(b);
      }
      var z = [c("_")].concat(x);
      for (b = c("a"); b <= c("z"); b++) {
        z.push(b);
      }
      for (b = c("A"); b <= c("Z"); b++) {
        z.push(b);
      }
      var r = [c(" "), c("\f"), c("\n"), c("\r"), c("\t"), c("\v"), c("\t"), c("\u00a0"), c("\u1680"), c("\u2000"), c("\u2001"), c("\u2002"), c("\u2003"), c("\u2004"), c("\u2005"), c("\u2006"), c("\u2007"), c("\u2008"), c("\u2009"), c("\u200a"), c("\u2028"), c("\u2029"), c("\u202f"), c("\u205f"), c("\u3000"), c("\ufeff")];
      return g.prototype.visitChildren = function(a) {
        for (var b in a) {
          var c = a[b];
          a.hasOwnProperty(b) && (void 0 !== c.type ? this.visit(c) : Array.isArray(c) && c.forEach(function(a) {
            this.visit(a);
          }, this));
        }
      }, g.prototype.visit = function(a) {
        switch(a.type) {
          case "Pattern":
            this.visitPattern(a);
            break;
          case "Flags":
            this.visitFlags(a);
            break;
          case "Disjunction":
            this.visitDisjunction(a);
            break;
          case "Alternative":
            this.visitAlternative(a);
            break;
          case "StartAnchor":
            this.visitStartAnchor(a);
            break;
          case "EndAnchor":
            this.visitEndAnchor(a);
            break;
          case "WordBoundary":
            this.visitWordBoundary(a);
            break;
          case "NonWordBoundary":
            this.visitNonWordBoundary(a);
            break;
          case "Lookahead":
            this.visitLookahead(a);
            break;
          case "NegativeLookahead":
            this.visitNegativeLookahead(a);
            break;
          case "Character":
            this.visitCharacter(a);
            break;
          case "Set":
            this.visitSet(a);
            break;
          case "Group":
            this.visitGroup(a);
            break;
          case "GroupBackReference":
            this.visitGroupBackReference(a);
            break;
          case "Quantifier":
            this.visitQuantifier(a);
        }
        this.visitChildren(a);
      }, g.prototype.visitPattern = function(a) {
      }, g.prototype.visitFlags = function(a) {
      }, g.prototype.visitDisjunction = function(a) {
      }, g.prototype.visitAlternative = function(a) {
      }, g.prototype.visitStartAnchor = function(a) {
      }, g.prototype.visitEndAnchor = function(a) {
      }, g.prototype.visitWordBoundary = function(a) {
      }, g.prototype.visitNonWordBoundary = function(a) {
      }, g.prototype.visitLookahead = function(a) {
      }, g.prototype.visitNegativeLookahead = function(a) {
      }, g.prototype.visitCharacter = function(a) {
      }, g.prototype.visitSet = function(a) {
      }, g.prototype.visitGroup = function(a) {
      }, g.prototype.visitGroupBackReference = function(a) {
      }, g.prototype.visitQuantifier = function(a) {
      }, {RegExpParser:a, BaseRegExpVisitor:g, VERSION:"0.4.0"};
    }) ? h.apply(d, g) : h) || (a.exports = e);
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    d.defaultLexerErrorProvider = {buildUnableToPopLexerModeMessage:function(a) {
      return "Unable to pop Lexer Mode after encountering Token ->" + a.image + "<- The Mode Stack is empty";
    }, buildUnexpectedCharactersMessage:function(a, d, g, c, p) {
      return "unexpected character: ->" + a.charAt(d) + "<- at offset: " + d + ", skipped " + g + " characters.";
    }};
  }, function(a, d, g) {
    function h(a) {
      if (a instanceof p.NonTerminal) {
        return h(a.referencedRule);
      }
      if (a instanceof p.Terminal) {
        return [a.terminalType];
      }
      if (t.isSequenceProd(a)) {
        return e(a);
      }
      if (t.isBranchingProd(a)) {
        return k(a);
      }
      throw Error("non exhaustive match");
    }
    function e(a) {
      var d = [];
      a = a.definition;
      var b = 0;
      var e = a.length > b;
      for (var f = !0; e && f;) {
        e = a[b], f = t.isOptionalProd(e), d = d.concat(h(e)), b += 1, e = a.length > b;
      }
      return c.uniq(d);
    }
    function k(a) {
      a = c.map(a.definition, function(a) {
        return h(a);
      });
      return c.uniq(c.flatten(a));
    }
    Object.defineProperty(d, "__esModule", {value:!0});
    var c = g(0), p = g(1), t = g(8);
    d.first = h;
    d.firstForSequence = e;
    d.firstForBranching = k;
    d.firstForTerminal = function(a) {
      return [a.terminalType];
    };
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    d.IN = "_~IN~_";
  }, function(a, d, g) {
    function h(a, b, f) {
      switch(a.type) {
        case H.AT_LEAST_ONE:
          return function(a, b, c) {
            return e(ja, new P.RepetitionMandatory({definition:[]}), a, b, c);
          }(a, b, f);
        case H.AT_LEAST_ONE_SEP:
          return k(a, b, P.RepetitionMandatoryWithSeparator, V, f);
        case H.MANY_SEP:
          return k(a, b, P.RepetitionWithSeparator, ca, f);
        case H.MANY:
          return function(a, b, c) {
            return e(W, new P.Repetition({definition:[]}), a, b, c);
          }(a, b, f);
        case H.OPTION:
          return function(a, b, c) {
            return e(Z, new P.Option({definition:[]}), a, b, c);
          }(a, b, f);
        case H.OR:
          return function(a, b, c) {
            return e(ea, new P.Alternation({definition:[]}), a, b, c);
          }(a, b, f);
        case H.FLAT:
          return function(a, b, d) {
            var e = new P.Flat({definition:[]}), f = T.exec(a.text)[1];
            K.isUndefined(f) || (e.name = f);
            return c(e, a.range, b, d);
          }(a, b, f);
        case H.REF:
          return function(a) {
            a = N.exec(a.text);
            var b = void 0 === a[1] ? 0 : parseInt(a[1], 10);
            return new P.NonTerminal({nonTerminalName:a[2], idx:b});
          }(a);
        case H.TERMINAL:
          return function(a, b) {
            var c = J.exec(a.text);
            a = void 0 === c[1] ? 0 : parseInt(c[1], 10);
            c = c[2];
            var e = d.terminalNameToConstructor[c];
            if (!e) {
              throw Error("Terminal Token name: <" + c + "> not found in rule: <" + b + ">  \n\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#TERMINAL_NAME_NOT_FOUND\n\tFor Further details.");
            }
            return new P.Terminal({terminalType:e, idx:a});
          }(a, f);
        default:
          throw Error("non exhaustive match");
      }
    }
    function e(a, b, d, e, f) {
      a = a.exec(d.text);
      b.idx = void 0 === a[1] ? 0 : parseInt(a[1], 10);
      a = a[2];
      return K.isUndefined(a) || (b.name = a), c(b, d.range, e, f);
    }
    function k(a, b, e, f, g) {
      f = f.exec(a.text);
      var h = void 0 === f[1] ? 0 : parseInt(f[1], 10), k = f[3], m = d.terminalNameToConstructor[k];
      if (!m) {
        throw Error("Separator Terminal Token name: " + k + " not found");
      }
      e = new e({definition:[], separator:m, idx:h});
      f = f[2];
      return K.isUndefined(f) || (e.name = f), c(e, a.range, b, g);
    }
    function c(a, b, c, d) {
      b = p(b, c);
      b = K.sortBy(b, function(a) {
        return a.range.start;
      });
      var e = [];
      return K.forEach(b, function(a) {
        e.push(h(a, c, d));
      }), a.definition = e, a;
    }
    function p(a, b) {
      return K.filter(b, function(c) {
        var d = a.strictlyContainsRange(c.range), e = K.every(b, function(b) {
          var d = b.range.strictlyContainsRange(c.range);
          b = b.range.isStrictlyContainedInRange(a);
          return !(d && b);
        });
        return d && e;
      });
    }
    function t(a) {
      return a.replace(ka, "").replace(ua, "");
    }
    function f(a, b) {
      return void 0 !== b ? a : "";
    }
    function n(a) {
      return a.replace(Aa, f).replace(Ia, f);
    }
    function b(a) {
      var b = m(a), c = q(a), d = y(a), e = x(a), f = z(a), g = r(a), h = u(a);
      a = v(a);
      return [].concat(b, c, d, e, f, g, h, a);
    }
    function m(a) {
      return A(a, H.TERMINAL, I);
    }
    function q(a) {
      return A(a, H.REF, S);
    }
    function y(a) {
      return D(a, H.AT_LEAST_ONE, X, sa);
    }
    function x(a) {
      return D(a, H.AT_LEAST_ONE_SEP, fa, sa);
    }
    function z(a) {
      return D(a, H.MANY, O, sa);
    }
    function r(a) {
      return D(a, H.MANY_SEP, M, sa);
    }
    function u(a) {
      return D(a, H.OPTION, R, sa);
    }
    function v(a) {
      a = D(a, H.OR, Y, sa);
      var b = C(a);
      return a.concat(b);
    }
    function C(a) {
      var b = [];
      return K.forEach(a, function(a) {
        var c = D(a.text, H.FLAT, ma, Ga), d = a.range.start;
        K.forEach(c, function(a) {
          a.range.start += d;
          a.range.end += d;
        });
        b = b.concat(c);
      }), K.uniq(b, function(a) {
        return a.type + "~" + a.range.start + "~" + a.range.end + "~" + a.text;
      });
    }
    function A(a, b, c) {
      for (var d, e = []; d = c.exec(a);) {
        var f = new L.Range(d.index, c.lastIndex);
        e.push({range:f, text:d[0], type:b});
      }
      return e;
    }
    function D(a, b, c, d) {
      for (var e, f = []; e = c.exec(a);) {
        var g = e.index, h = d(g + e[0].length, a);
        e = new L.Range(g, h);
        g = a.substr(g, h - g + 1);
        f.push({range:e, text:g, type:b});
      }
      return f;
    }
    function F(a, b, c, d) {
      for (var e = [1], f = -1; !K.isEmpty(e) && f + c < d.length;) {
        f++;
        var g = d.charAt(c + f);
        g === a ? e.push(1) : g === b && e.pop();
      }
      if (K.isEmpty(e)) {
        return f + c;
      }
      throw Error("INVALID INPUT TEXT, UNTERMINATED PARENTHESIS");
    }
    function B(a, b) {
      return K.map(a, function(a) {
        return E(a, b);
      });
    }
    function E(a, b) {
      switch(a.type) {
        case "NonTerminal":
          return new P.NonTerminal({nonTerminalName:a.name, idx:a.idx});
        case "Flat":
          return new P.Flat({name:a.name, definition:B(a.definition, b)});
        case "Option":
          return new P.Option({name:a.name, idx:a.idx, definition:B(a.definition, b)});
        case "RepetitionMandatory":
          return new P.RepetitionMandatory({name:a.name, idx:a.idx, definition:B(a.definition, b)});
        case "RepetitionMandatoryWithSeparator":
          return new P.RepetitionMandatoryWithSeparator({name:a.name, idx:a.idx, separator:b[a.separator.name], definition:B(a.definition, b)});
        case "RepetitionWithSeparator":
          return new P.RepetitionWithSeparator({name:a.name, idx:a.idx, separator:b[a.separator.name], definition:B(a.definition, b)});
        case "Repetition":
          return new P.Repetition({name:a.name, idx:a.idx, definition:B(a.definition, b)});
        case "Alternation":
          return new P.Alternation({name:a.name, idx:a.idx, definition:B(a.definition, b)});
        case "Terminal":
          return new P.Terminal({terminalType:b[a.name], idx:a.idx});
        case "Rule":
          return new P.Rule({name:a.name, orgText:a.orgText, definition:B(a.definition, b)});
      }
    }
    Object.defineProperty(d, "__esModule", {value:!0});
    var H, L = g(29), K = g(0), P = g(1);
    !function(a) {
      a[a.OPTION = 0] = "OPTION";
      a[a.OR = 1] = "OR";
      a[a.MANY = 2] = "MANY";
      a[a.MANY_SEP = 3] = "MANY_SEP";
      a[a.AT_LEAST_ONE = 4] = "AT_LEAST_ONE";
      a[a.AT_LEAST_ONE_SEP = 5] = "AT_LEAST_ONE_SEP";
      a[a.REF = 6] = "REF";
      a[a.TERMINAL = 7] = "TERMINAL";
      a[a.FLAT = 8] = "FLAT";
    }(H = d.ProdType || (d.ProdType = {}));
    a = /(?:\s*{\s*NAME\s*:\s*["'`]([\w$]*)["'`])?/;
    g = new RegExp(a.source.replace("{", "").replace(")?", "\\s*,)?"));
    var J = /\.\s*CONSUME(\d+)?\s*\(\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/, I = new RegExp(J.source, "g"), N = /\.\s*SUBRULE(\d+)?\s*\(\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/, S = new RegExp(N.source, "g"), Q = /\.\s*OPTION(\d+)?\s*\(/, Z = new RegExp(Q.source + a.source), R = new RegExp(Q.source, "g");
    Q = /\.\s*MANY(\d+)?\s*\(/;
    var W = new RegExp(Q.source + a.source), O = new RegExp(Q.source, "g");
    Q = /\s*SEP\s*:\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/;
    var ca = new RegExp(/\.\s*MANY_SEP(\d+)?\s*\(\s*{/.source + g.source + Q.source), M = new RegExp(ca.source, "g"), V = new RegExp(/\.\s*AT_LEAST_ONE_SEP(\d+)?\s*\(\s*{/.source + g.source + Q.source), fa = new RegExp(V.source, "g");
    Q = /\.\s*AT_LEAST_ONE(\d+)?\s*\(/;
    var ja = new RegExp(Q.source + a.source), X = new RegExp(Q.source, "g");
    Q = /\.\s*OR(\d+)?\s*\(/;
    var ea = new RegExp(Q.source + a.source), Y = new RegExp(Q.source, "g"), T = new RegExp(g.source + /\s*(ALT)\s*:/.source), ma = new RegExp(T.source, "g");
    d.terminalNameToConstructor = {};
    d.buildTopProduction = function(a, e, f) {
      d.terminalNameToConstructor = f;
      f = b(n(t("  " + a)));
      var g = new L.Range(0, a.length + 2);
      return c(new P.Rule({name:e, definition:[], orgText:a}), g, f, e);
    };
    d.buildProdGast = h;
    d.getDirectlyContainedRanges = p;
    var ka = /\/\/.*/g, ua = /\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\//g, Aa = /(NAME\s*:\s*)?"([^\\"]|\\([bfnrtv"\\\/]|u[0-9a-fA-F]{4}))*"/g, Ia = /(NAME\s*:\s*)?'([^\\']|\\([bfnrtv'\\\/]|u[0-9a-fA-F]{4}))*'/g;
    d.removeComments = t;
    d.removeStringLiterals = n;
    d.createRanges = b;
    d.createTerminalRanges = m;
    d.createRefsRanges = q;
    d.createAtLeastOneRanges = y;
    d.createAtLeastOneSepRanges = x;
    d.createManyRanges = z;
    d.createManySepRanges = r;
    d.createOptionRanges = u;
    d.createOrRanges = v;
    var Ga = K.partial(F, "{", "}"), sa = K.partial(F, "(", ")");
    d.createOrPartRanges = C;
    d.findClosingOffset = F;
    d.deserializeGrammar = B;
    d.deserializeProduction = E;
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    var h = g(0), e = g(4), k = g(30), c = g(11), p = g(10), t = g(8);
    d.resolveGrammar = function(a) {
      a = h.defaults(a, {errMsgProvider:p.defaultGrammarResolverErrorProvider});
      var c = new e.HashTable;
      return h.forEach(a.rules, function(a) {
        c.put(a.name, a);
      }), k.resolveGrammar(c, a.errMsgProvider);
    };
    d.validateGrammar = function(a) {
      return a = h.defaults(a, {errMsgProvider:p.defaultGrammarValidatorErrorProvider, ignoredIssues:{}}), c.validateGrammar(a.rules, a.maxLookahead, a.tokenTypes, a.ignoredIssues, a.errMsgProvider, a.grammarName);
    };
    d.assignOccurrenceIndices = function(a) {
      h.forEach(a.rules, function(a) {
        var b = new t.DslMethodsCollectorVisitor;
        a.accept(b);
        h.forEach(b.dslMethods, function(a) {
          h.forEach(a, function(a, b) {
            a.idx = b + 1;
          });
        });
      });
    };
  }, function(a, d, g) {
    function h(a) {
      this.name = d.IN_RULE_RECOVERY_EXCEPTION;
      this.message = a;
    }
    function e(a, c, d, e, f, g) {
      var b = this.getKeyForAutomaticLookahead(e, f);
      e = this.firstAfterRepMap.get(b);
      void 0 === e && (e = this.getCurrRuleFullName(), e = (new g(this.getGAstProductions().get(e), f)).startWalking(), this.firstAfterRepMap.put(b, e));
      f = e.token;
      g = e.occurrence;
      e = e.isEndOfRule;
      1 === this.RULE_STACK.length && e && void 0 === f && (f = k.EOF, g = 1);
      this.shouldInRepetitionRecoveryBeTried(f, g) && this.tryInRepetitionRecovery(a, c, d, f);
    }
    Object.defineProperty(d, "__esModule", {value:!0});
    var k = g(2), c = g(0), p = g(6), t = g(22), f = g(4), n = g(3);
    d.EOF_FOLLOW_KEY = {};
    d.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
    d.InRuleRecoveryException = h;
    h.prototype = Error.prototype;
    a = function() {
      function a() {
      }
      return a.prototype.initRecoverable = function(a) {
        this.firstAfterRepMap = new f.HashTable;
        this.resyncFollows = new f.HashTable;
        (this.recoveryEnabled = c.has(a, "recoveryEnabled") ? a.recoveryEnabled : n.DEFAULT_PARSER_CONFIG.recoveryEnabled) && (this.attemptInRepetitionRecovery = e);
      }, a.prototype.getTokenToInsert = function(a) {
        a = k.createTokenInstance(a, "", NaN, NaN, NaN, NaN, NaN, NaN);
        return a.isInsertedInRecovery = !0, a;
      }, a.prototype.canTokenTypeBeInsertedInRecovery = function(a) {
        return !0;
      }, a.prototype.tryInRepetitionRecovery = function(a, b, d, e) {
        for (var f = this, g = this.findReSyncTokenType(), h = this.exportLexerState(), k = [], m = !1, n = this.LA(1), q = this.LA(1), t = function() {
          var a = f.LA(0);
          a = f.errorMessageProvider.buildMismatchTokenMessage({expected:e, actual:n, previous:a, ruleName:f.getCurrRuleFullName()});
          a = new p.MismatchedTokenException(a, n, f.LA(0));
          a.resyncedTokens = c.dropRight(k);
          f.SAVE_ERROR(a);
        }; !m;) {
          if (this.tokenMatcher(q, e)) {
            return void t();
          }
          if (d.call(this)) {
            return t(), void a.apply(this, b);
          }
          this.tokenMatcher(q, g) ? m = !0 : (q = this.SKIP_TOKEN(), this.addToResyncTokens(q, k));
        }
        this.importLexerState(h);
      }, a.prototype.shouldInRepetitionRecoveryBeTried = function(a, b) {
        return void 0 !== a && void 0 !== b && !this.tokenMatcher(this.LA(1), a) && !this.isBackTracking() && !this.canPerformInRuleRecovery(a, this.getFollowsForInRuleRecovery(a, b));
      }, a.prototype.getFollowsForInRuleRecovery = function(a, b) {
        a = this.getCurrentGrammarPath(a, b);
        return this.getNextPossibleTokenTypes(a);
      }, a.prototype.tryInRuleRecovery = function(a, b) {
        if (this.canRecoverWithSingleTokenInsertion(a, b)) {
          return this.getTokenToInsert(a);
        }
        if (this.canRecoverWithSingleTokenDeletion(a)) {
          return a = this.SKIP_TOKEN(), this.consumeToken(), a;
        }
        throw new h("sad sad panda");
      }, a.prototype.canPerformInRuleRecovery = function(a, b) {
        return this.canRecoverWithSingleTokenInsertion(a, b) || this.canRecoverWithSingleTokenDeletion(a);
      }, a.prototype.canRecoverWithSingleTokenInsertion = function(a, b) {
        var d = this;
        if (!this.canTokenTypeBeInsertedInRecovery(a) || c.isEmpty(b)) {
          return !1;
        }
        var e = this.LA(1);
        return void 0 !== c.find(b, function(a) {
          return d.tokenMatcher(e, a);
        });
      }, a.prototype.canRecoverWithSingleTokenDeletion = function(a) {
        return this.tokenMatcher(this.LA(2), a);
      }, a.prototype.isInCurrentRuleReSyncSet = function(a) {
        var b = this.getCurrFollowKey();
        b = this.getFollowSetFromFollowKey(b);
        return c.contains(b, a);
      }, a.prototype.findReSyncTokenType = function() {
        for (var a = this.flattenFollowSet(), b = this.LA(1), d = 2;;) {
          b = b.tokenType;
          if (c.contains(a, b)) {
            return b;
          }
          b = this.LA(d);
          d++;
        }
      }, a.prototype.getCurrFollowKey = function() {
        if (1 === this.RULE_STACK.length) {
          return d.EOF_FOLLOW_KEY;
        }
        var a = this.getLastExplicitRuleShortName(), b = this.getLastExplicitRuleOccurrenceIndex(), c = this.getPreviousExplicitRuleShortName();
        return {ruleName:this.shortRuleNameToFullName(a), idxInCallingRule:b, inRule:this.shortRuleNameToFullName(c)};
      }, a.prototype.buildFullFollowKeyStack = function() {
        var a = this, b = this.RULE_STACK, e = this.RULE_OCCURRENCE_STACK;
        return c.isEmpty(this.LAST_EXPLICIT_RULE_STACK) || (b = c.map(this.LAST_EXPLICIT_RULE_STACK, function(b) {
          return a.RULE_STACK[b];
        }), e = c.map(this.LAST_EXPLICIT_RULE_STACK, function(b) {
          return a.RULE_OCCURRENCE_STACK[b];
        })), c.map(b, function(c, f) {
          return 0 === f ? d.EOF_FOLLOW_KEY : {ruleName:a.shortRuleNameToFullName(c), idxInCallingRule:e[f], inRule:a.shortRuleNameToFullName(b[f - 1])};
        });
      }, a.prototype.flattenFollowSet = function() {
        var a = this, b = c.map(this.buildFullFollowKeyStack(), function(b) {
          return a.getFollowSetFromFollowKey(b);
        });
        return c.flatten(b);
      }, a.prototype.getFollowSetFromFollowKey = function(a) {
        return a === d.EOF_FOLLOW_KEY ? [k.EOF] : this.resyncFollows.get(a.ruleName + a.idxInCallingRule + t.IN + a.inRule);
      }, a.prototype.addToResyncTokens = function(a, b) {
        return this.tokenMatcher(a, k.EOF) || b.push(a), b;
      }, a.prototype.reSyncTo = function(a) {
        for (var b = [], d = this.LA(1); !1 === this.tokenMatcher(d, a);) {
          d = this.SKIP_TOKEN(), this.addToResyncTokens(d, b);
        }
        return c.dropRight(b);
      }, a.prototype.attemptInRepetitionRecovery = function(a, b, c, d, e, f) {
      }, a.prototype.getCurrentGrammarPath = function(a, b) {
        return {ruleStack:this.getHumanReadableRuleStack(), occurrenceStack:c.cloneArr(this.RULE_OCCURRENCE_STACK), lastTok:a, lastTokOccurrence:b};
      }, a.prototype.getHumanReadableRuleStack = function() {
        var a = this;
        return c.isEmpty(this.LAST_EXPLICIT_RULE_STACK) ? c.map(this.RULE_STACK, function(b) {
          return a.shortRuleNameToFullName(b);
        }) : c.map(this.LAST_EXPLICIT_RULE_STACK, function(b) {
          return a.shortRuleNameToFullName(a.RULE_STACK[b]);
        });
      }, a;
    }();
    d.Recoverable = a;
    d.attemptInRepetitionRecovery = e;
  }, function(a, d, g) {
    function h(a, b) {
      return a.name + b + f.IN;
    }
    var e, k = this && this.__extends || (e = function(a, b) {
      return (e = Object.setPrototypeOf || {__proto__:[]} instanceof Array && function(a, b) {
        a.__proto__ = b;
      } || function(a, b) {
        for (var c in b) {
          b.hasOwnProperty(c) && (a[c] = b[c]);
        }
      })(a, b);
    }, function(a, b) {
      function c() {
        this.constructor = a;
      }
      e(a, b);
      a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c);
    });
    Object.defineProperty(d, "__esModule", {value:!0});
    a = g(14);
    var c = g(4), p = g(21), t = g(0), f = g(22), n = g(2), b = g(1), m = function(a) {
      function d(b) {
        var d = a.call(this) || this;
        return d.topProd = b, d.follows = new c.HashTable, d;
      }
      return k(d, a), d.prototype.startWalking = function() {
        return this.walk(this.topProd), this.follows;
      }, d.prototype.walkTerminal = function(a, b, c) {
      }, d.prototype.walkProdRef = function(a, c, d) {
        a = h(a.referencedRule, a.idx) + this.topProd.name;
        c = c.concat(d);
        c = new b.Flat({definition:c});
        c = p.first(c);
        this.follows.put(a, c);
      }, d;
    }(a.RestWalker);
    d.ResyncFollowsWalker = m;
    d.computeAllProdsFollows = function(a) {
      var b = new c.HashTable;
      return t.forEach(a, function(a) {
        a = (new m(a)).startWalking();
        b.putAll(a);
      }), b;
    };
    d.buildBetweenProdsFollowPrefix = h;
    d.buildInProdFollowPrefix = function(a) {
      return n.tokenName(a.terminalType) + a.idx + f.IN;
    };
  }, function(a, d, g) {
    function h(a) {
      var b = E.filter(a, function(a) {
        return !E.has(a, "PATTERN");
      });
      return {errors:E.map(b, function(a) {
        return {message:"Token Type: ->" + F.tokenName(a) + "<- missing static 'PATTERN' property", type:B.LexerDefinitionErrorType.MISSING_PATTERN, tokenTypes:[a]};
      }), valid:E.difference(a, b)};
    }
    function e(a) {
      var b = E.filter(a, function(a) {
        a = a.PATTERN;
        return !(E.isRegExp(a) || E.isFunction(a) || E.has(a, "exec") || E.isString(a));
      });
      return {errors:E.map(b, function(a) {
        return {message:"Token Type: ->" + F.tokenName(a) + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.", type:B.LexerDefinitionErrorType.INVALID_PATTERN, tokenTypes:[a]};
      }), valid:E.difference(a, b)};
    }
    function k(a) {
      var b = function(a) {
        function b() {
          var b = null !== a && a.apply(this, arguments) || this;
          return b.found = !1, b;
        }
        return A(b, a), b.prototype.visitEndAnchor = function(a) {
          this.found = !0;
        }, b;
      }(D.BaseRegExpVisitor);
      a = E.filter(a, function(a) {
        a = a.PATTERN;
        try {
          var c = L.pattern(a.toString()), d = new b;
          return d.visit(c), d.found;
        } catch (Z) {
          return K.test(a.source);
        }
      });
      return E.map(a, function(a) {
        return {message:"Unexpected RegExp Anchor Error:\n\tToken Type: ->" + F.tokenName(a) + "<- static 'PATTERN' cannot contain end of input anchor '$'\n\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.", type:B.LexerDefinitionErrorType.EOI_ANCHOR_FOUND, tokenTypes:[a]};
      });
    }
    function c(a) {
      a = E.filter(a, function(a) {
        return a.PATTERN.test("");
      });
      return E.map(a, function(a) {
        return {message:"Token Type: ->" + F.tokenName(a) + "<- static 'PATTERN' must not match an empty string", type:B.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN, tokenTypes:[a]};
      });
    }
    function p(a) {
      var b = function(a) {
        function b() {
          var b = null !== a && a.apply(this, arguments) || this;
          return b.found = !1, b;
        }
        return A(b, a), b.prototype.visitStartAnchor = function(a) {
          this.found = !0;
        }, b;
      }(D.BaseRegExpVisitor);
      a = E.filter(a, function(a) {
        a = a.PATTERN;
        try {
          var c = L.pattern(a.toString()), d = new b;
          return d.visit(c), d.found;
        } catch (Z) {
          return P.test(a.source);
        }
      });
      return E.map(a, function(a) {
        return {message:"Unexpected RegExp Anchor Error:\n\tToken Type: ->" + F.tokenName(a) + "<- static 'PATTERN' cannot contain start of input anchor '^'\n\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.", type:B.LexerDefinitionErrorType.SOI_ANCHOR_FOUND, tokenTypes:[a]};
      });
    }
    function t(a) {
      a = E.filter(a, function(a) {
        a = a.PATTERN;
        return a instanceof RegExp && (a.multiline || a.global);
      });
      return E.map(a, function(a) {
        return {message:"Token Type: ->" + F.tokenName(a) + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')", type:B.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND, tokenTypes:[a]};
      });
    }
    function f(a) {
      var b = [], c = E.map(a, function(c) {
        return E.reduce(a, function(a, d) {
          return c.PATTERN.source !== d.PATTERN.source || E.contains(b, d) || d.PATTERN === B.Lexer.NA ? a : (b.push(d), a.push(d), a);
        }, []);
      });
      c = E.compact(c);
      c = E.filter(c, function(a) {
        return 1 < a.length;
      });
      return E.map(c, function(a) {
        var b = E.map(a, function(a) {
          return F.tokenName(a);
        });
        return {message:"The same RegExp pattern ->" + E.first(a).PATTERN + "<-has been used in all of the following Token Types: " + b.join(", ") + " <-", type:B.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND, tokenTypes:a};
      });
    }
    function n(a) {
      a = E.filter(a, function(a) {
        if (!E.has(a, "GROUP")) {
          return !1;
        }
        a = a.GROUP;
        return a !== B.Lexer.SKIPPED && a !== B.Lexer.NA && !E.isString(a);
      });
      return E.map(a, function(a) {
        return {message:"Token Type: ->" + F.tokenName(a) + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String", type:B.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND, tokenTypes:[a]};
      });
    }
    function b(a, b) {
      a = E.filter(a, function(a) {
        return void 0 !== a.PUSH_MODE && !E.contains(b, a.PUSH_MODE);
      });
      return E.map(a, function(a) {
        return {message:"Token Type: ->" + F.tokenName(a) + "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->" + a.PUSH_MODE + "<-which does not exist", type:B.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST, tokenTypes:[a]};
      });
    }
    function m(a) {
      var b = [], c = E.reduce(a, function(a, b, c) {
        var d = b.PATTERN;
        return d === B.Lexer.NA ? a : (E.isString(d) ? a.push({str:d, idx:c, tokenType:b}) : E.isRegExp(d) && void 0 === E.find(".\\[]|^$()?*+{".split(""), function(a) {
          return -1 !== d.source.indexOf(a);
        }) && a.push({str:d.source, idx:c, tokenType:b}), a);
      }, []);
      return E.forEach(a, function(a, d) {
        E.forEach(c, function(c) {
          var e = c.str, f = c.tokenType;
          d < c.idx && function(a, b) {
            if (E.isRegExp(b)) {
              return a = b.exec(a), null !== a && 0 === a.index;
            }
            if (E.isFunction(b)) {
              return b(a, 0, [], {});
            }
            if (E.has(b, "exec")) {
              return b.exec(a, 0, [], {});
            }
            if ("string" == typeof b) {
              return b === a;
            }
            throw Error("non exhaustive match");
          }(e, a.PATTERN) && (c = "Token: ->" + F.tokenName(f) + "<- can never be matched.\nBecause it appears AFTER the Token Type ->" + F.tokenName(a) + "<-in the lexer's definition.\nSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE", b.push({message:c, type:B.LexerDefinitionErrorType.UNREACHABLE_PATTERN, tokenTypes:[a, f]}));
        });
      }), b;
    }
    function q(a) {
      return new RegExp("^(?:" + a.source + ")", a.ignoreCase ? "i" : "");
    }
    function y(a) {
      return new RegExp("" + a.source, a.ignoreCase ? "iy" : "y");
    }
    function x(a) {
      a = a.PATTERN;
      if (E.isRegExp(a)) {
        return !1;
      }
      if (E.isFunction(a) || E.has(a, "exec")) {
        return !0;
      }
      if (E.isString(a)) {
        return !1;
      }
      throw Error("non exhaustive match");
    }
    function z(a) {
      return !(!E.isString(a) || 1 !== a.length) && a.charCodeAt(0);
    }
    function r(a, b) {
      if (E.has(a, "LINE_BREAKS")) {
        return !1;
      }
      if (E.isRegExp(a.PATTERN)) {
        try {
          H.canMatchCharCode(b, a.PATTERN);
        } catch (N) {
          return {issue:B.LexerDefinitionErrorType.IDENTIFY_TERMINATOR, errMsg:N.message};
        }
        return !1;
      }
      if (E.isString(a.PATTERN)) {
        return !1;
      }
      if (x(a)) {
        return {issue:B.LexerDefinitionErrorType.CUSTOM_LINE_BREAK};
      }
      throw Error("non exhaustive match");
    }
    function u(a, b) {
      if (b.issue === B.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
        return "Warning: unable to identify line terminator usage in pattern.\n\tThe problem is in the <" + a.name + "> Token Type\n\t Root cause: " + b.errMsg + ".\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
      }
      if (b.issue === B.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
        return "Warning: A Custom Token Pattern should specify the <line_breaks> option.\n\tThe problem is in the <" + a.name + "> Token Type\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
      }
      throw Error("non exhaustive match");
    }
    function v(a) {
      return E.map(a, function(a) {
        return E.isString(a) && 0 < a.length ? a.charCodeAt(0) : a;
      });
    }
    var C, A = this && this.__extends || (C = function(a, b) {
      return (C = Object.setPrototypeOf || {__proto__:[]} instanceof Array && function(a, b) {
        a.__proto__ = b;
      } || function(a, b) {
        for (var c in b) {
          b.hasOwnProperty(c) && (a[c] = b[c]);
        }
      })(a, b);
    }, function(a, b) {
      function c() {
        this.constructor = a;
      }
      C(a, b);
      a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c);
    });
    Object.defineProperty(d, "__esModule", {value:!0});
    var D = g(19), F = g(2), B = g(15), E = g(0), H = g(28), L = new D.RegExpParser;
    d.DEFAULT_MODE = "defaultMode";
    d.MODES = "modes";
    d.SUPPORT_STICKY = "boolean" == typeof/(?:)/.sticky;
    d.disableSticky = function() {
      d.SUPPORT_STICKY = !1;
    };
    d.enableSticky = function() {
      d.SUPPORT_STICKY = !0;
    };
    d.analyzeTokenTypes = function(a, b) {
      function c(a, b, c) {
        void 0 === a[b] && (a[b] = []);
        a[b].push(c);
      }
      b = E.defaults(b, {useSticky:d.SUPPORT_STICKY, debug:!1, safeMode:!1, positionTracking:"full", lineTerminatorCharacters:["\r", "\n"]});
      var e = E.reject(a, function(a) {
        return a.PATTERN === B.Lexer.NA;
      }), f = !1, g = E.map(e, function(a) {
        a = a.PATTERN;
        if (E.isRegExp(a)) {
          var c = a.source;
          return 1 === c.length && "^" !== c && "$" !== c && "." !== c ? c : 2 !== c.length || "\\" !== c[0] || E.contains("dDsStrnt0cbBfvwW".split(""), c[1]) ? b.useSticky ? y(a) : q(a) : c[1];
        }
        if (E.isFunction(a)) {
          return f = !0, {exec:a};
        }
        if (E.has(a, "exec")) {
          return f = !0, a;
        }
        if ("string" == typeof a) {
          if (1 === a.length) {
            return a;
          }
          a = a.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
          a = new RegExp(a);
          return b.useSticky ? y(a) : q(a);
        }
        throw Error("non exhaustive match");
      }), h = E.map(e, function(a) {
        return a.tokenTypeIdx;
      }), k = E.map(e, function(a) {
        a = a.GROUP;
        if (a !== B.Lexer.SKIPPED) {
          if (E.isString(a)) {
            return a;
          }
          if (E.isUndefined(a)) {
            return !1;
          }
          throw Error("non exhaustive match");
        }
      }), m = E.map(e, function(a) {
        if (a = a.LONGER_ALT) {
          return E.indexOf(e, a);
        }
      }), n = E.map(e, function(a) {
        return a.PUSH_MODE;
      }), p = E.map(e, function(a) {
        return E.has(a, "POP_MODE");
      }), t = v(b.lineTerminatorCharacters), u = E.map(e, function(a) {
        return !1;
      });
      "onlyOffset" !== b.positionTracking && (u = E.map(e, function(a) {
        return E.has(a, "LINE_BREAKS") ? a.LINE_BREAKS : !1 === r(a, t) ? H.canMatchCharCode(t, a.PATTERN) : void 0;
      }));
      var A = E.map(e, x), C = E.map(g, z);
      a = E.reduce(e, function(a, b) {
        b = b.GROUP;
        return E.isString(b) && b !== B.Lexer.SKIPPED && (a[b] = []), a;
      }, {});
      var D = E.map(g, function(a, b) {
        return {pattern:g[b], longerAlt:m[b], canLineTerminator:u[b], isCustom:A[b], short:C[b], group:k[b], push:n[b], pop:p[b], tokenTypeIdx:h[b], tokenType:e[b]};
      }), I = !0, J = [];
      return b.safeMode || (J = E.reduce(e, function(a, d, e) {
        "string" == typeof d.PATTERN ? (d = d.PATTERN.charCodeAt(0), c(a, d, D[e])) : E.isArray(d.START_CHARS_HINT) ? E.forEach(d.START_CHARS_HINT, function(b) {
          b = "string" == typeof b ? b.charCodeAt(0) : b;
          c(a, b, D[e]);
        }) : E.isRegExp(d.PATTERN) ? d.PATTERN.unicode ? (I = !1, b.ensureOptimizations && E.PRINT_ERROR(H.failedOptimizationPrefixMsg + "\tUnable to analyze < " + d.PATTERN.toString() + " > pattern.\n\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE")) : (d = H.getStartCodes(d.PATTERN, b.ensureOptimizations), 
        E.isEmpty(d) && (I = !1), E.forEach(d, function(b) {
          c(a, b, D[e]);
        })) : (b.ensureOptimizations && E.PRINT_ERROR(H.failedOptimizationPrefixMsg + "\tTokenType: <" + F.tokenName(d) + "> is using a custom token pattern without providing <start_chars_hint> parameter.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE"), I = !1);
        return a;
      }, [])), I && 65536 > J.length && (J = E.packArray(J)), {emptyGroups:a, patternIdxToConfig:D, charCodeToPatternIdxToConfig:J, hasCustom:f, canBeOptimized:I};
    };
    d.validatePatterns = function(a, d) {
      var g = [];
      a = h(a);
      g = g.concat(a.errors);
      a = e(a.valid);
      var q = a.valid;
      return g = (g = (g = (g = (g = g.concat(a.errors)).concat(function(a) {
        var b = [];
        a = E.filter(a, function(a) {
          return E.isRegExp(a.PATTERN);
        });
        return b = (b = (b = (b = (b = b.concat(k(a))).concat(p(a))).concat(t(a))).concat(f(a))).concat(c(a));
      }(q))).concat(n(q))).concat(b(q, d))).concat(m(q));
    };
    d.findMissingPatterns = h;
    d.findInvalidPatterns = e;
    var K = /[^\\][\$]/;
    d.findEndOfInputAnchor = k;
    d.findEmptyMatchRegExps = c;
    var P = /[^\\[][\^]|^\^/;
    d.findStartOfInputAnchor = p;
    d.findUnsupportedFlags = t;
    d.findDuplicatePatterns = f;
    d.findInvalidGroupType = n;
    d.findModesThatDoNotExist = b;
    d.findUnreachablePatterns = m;
    d.addStartOfInput = q;
    d.addStickyFlag = y;
    d.performRuntimeChecks = function(a, b, c) {
      var e = [];
      return E.has(a, d.DEFAULT_MODE) || e.push({message:"A MultiMode Lexer cannot be initialized without a <" + d.DEFAULT_MODE + "> property in its definition\n", type:B.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE}), E.has(a, d.MODES) || e.push({message:"A MultiMode Lexer cannot be initialized without a <" + d.MODES + "> property in its definition\n", type:B.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY}), E.has(a, d.MODES) && E.has(a, d.DEFAULT_MODE) && !E.has(a.modes, 
      a.defaultMode) && e.push({message:"A MultiMode Lexer cannot be initialized with a " + d.DEFAULT_MODE + ": <" + a.defaultMode + ">which does not exist\n", type:B.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST}), E.has(a, d.MODES) && E.forEach(a.modes, function(a, b) {
        E.forEach(a, function(a, c) {
          E.isUndefined(a) && e.push({message:"A Lexer cannot be initialized using an undefined Token Type. Mode:<" + b + "> at index: <" + c + ">\n", type:B.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED});
        });
      }), e;
    };
    d.performWarningRuntimeChecks = function(a, b, c) {
      var d = [], e = !1;
      a = E.compact(E.flatten(E.mapValues(a.modes, function(a) {
        return a;
      })));
      a = E.reject(a, function(a) {
        return a.PATTERN === B.Lexer.NA;
      });
      var f = v(c);
      return b && E.forEach(a, function(a) {
        var b = r(a, f);
        !1 !== b ? (a = {message:u(a, b), type:b.issue, tokenType:a}, d.push(a)) : E.has(a, "LINE_BREAKS") ? !0 === a.LINE_BREAKS && (e = !0) : H.canMatchCharCode(f, a.PATTERN) && (e = !0);
      }), b && !e && d.push({message:"Warning: No LINE_BREAKS Found.\n\tThis Lexer has been defined to track line and column information,\n\tBut none of the Token Types can be identified as matching a line terminator.\n\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n\tfor details.", type:B.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS}), d;
    };
    d.cloneEmptyGroups = function(a) {
      var b = {}, c = E.keys(a);
      return E.forEach(c, function(c) {
        if (!E.isArray(a[c])) {
          throw Error("non exhaustive match");
        }
        b[c] = [];
      }), b;
    };
    d.isCustomPattern = x;
    d.isShortPattern = z;
    d.LineTerminatorOptimizedTester = {test:function(a) {
      for (var b = a.length, c = this.lastIndex; c < b; c++) {
        var d = a.charCodeAt(c);
        if (10 === d) {
          return this.lastIndex = c + 1, !0;
        }
        if (13 === d) {
          return 10 === a.charCodeAt(c + 1) ? this.lastIndex = c + 2 : this.lastIndex = c + 1, !0;
        }
      }
      return !1;
    }, lastIndex:0};
    d.buildLineBreakIssueMessage = u;
  }, function(a, d, g) {
    function h(a) {
      switch(a.type) {
        case "Disjunction":
          return n.flatten(n.map(a.value, h));
        case "Alternative":
          var b = [];
          a = a.value;
          for (var d = 0; d < a.length; d++) {
            var e = a[d];
            if (!n.contains("GroupBackReference Lookahead NegativeLookahead StartAnchor EndAnchor WordBoundary NonWordBoundary".split(" "), e.type)) {
              switch(e.type) {
                case "Character":
                  b.push(e.value);
                  break;
                case "Set":
                  if (!0 === e.complement) {
                    throw Error("Complement Sets are not supported for first char optimization");
                  }
                  n.forEach(e.value, function(a) {
                    if ("number" == typeof a) {
                      b.push(a);
                    } else {
                      for (var c = a.from; c <= a.to; c++) {
                        b.push(c);
                      }
                    }
                  });
                  break;
                case "Group":
                  var f = h(e.value);
                  n.forEach(f, function(a) {
                    return b.push(a);
                  });
                  break;
                default:
                  throw Error("Non Exhaustive Match");
              }
              f = void 0 !== e.quantifier && 0 === e.quantifier.atLeast;
              if ("Group" === e.type && !1 === c(e) || "Group" !== e.type && !1 === f) {
                break;
              }
            }
          }
          return b;
        default:
          throw Error("non exhaustive match!");
      }
    }
    function e(a) {
      var b = [];
      return n.forEach(a, function(a) {
        b.push(a);
        a = String.fromCharCode(a);
        a.toUpperCase() !== a ? b.push(a.toUpperCase().charCodeAt(0)) : a.toLowerCase() !== a && b.push(a.toLowerCase().charCodeAt(0));
      }), b;
    }
    function k(a, b) {
      return n.find(a.value, function(a) {
        return "number" == typeof a ? n.contains(b, a) : void 0 !== n.find(b, function(b) {
          return a.from <= b && b <= a.to;
        });
      });
    }
    function c(a) {
      return !(!a.quantifier || 0 !== a.quantifier.atLeast) || !!a.value && (n.isArray(a.value) ? n.every(a.value, c) : c(a.value));
    }
    var p, t = this && this.__extends || (p = function(a, b) {
      return (p = Object.setPrototypeOf || {__proto__:[]} instanceof Array && function(a, b) {
        a.__proto__ = b;
      } || function(a, b) {
        for (var c in b) {
          b.hasOwnProperty(c) && (a[c] = b[c]);
        }
      })(a, b);
    }, function(a, b) {
      function c() {
        this.constructor = a;
      }
      p(a, b);
      a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c);
    });
    Object.defineProperty(d, "__esModule", {value:!0});
    var f = g(19), n = g(0), b = new f.RegExpParser;
    d.failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
    d.getStartCodes = function(a, c) {
      void 0 === c && (c = !1);
      try {
        var g = b.pattern(a.toString()), k = h(g.value);
        return g.flags.ignoreCase && (k = e(k)), k;
      } catch (r) {
        "Complement Sets are not supported for first char optimization" === r.message ? c && n.PRINT_WARNING(d.failedOptimizationPrefixMsg + "\tUnable to optimize: < " + a.toString() + " >\n\tComplement Sets cannot be automatically optimized.\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.") : (g = "", c && (g = "\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details."), 
        n.PRINT_ERROR(d.failedOptimizationPrefixMsg + "\n\tFailed parsing: < " + a.toString() + " >\n\tUsing the regexp-to-ast library version: " + f.VERSION + "\n\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues" + g));
      }
      return [];
    };
    d.firstChar = h;
    d.applyIgnoreCase = e;
    var m = function(a) {
      function b(b) {
        var c = a.call(this) || this;
        return c.targetCharCodes = b, c.found = !1, c;
      }
      return t(b, a), b.prototype.visitChildren = function(b) {
        switch(b.type) {
          case "Lookahead":
            return void this.visitLookahead(b);
          case "NegativeLookahead":
            return void this.visitNegativeLookahead(b);
        }
        a.prototype.visitChildren.call(this, b);
      }, b.prototype.visitCharacter = function(a) {
        n.contains(this.targetCharCodes, a.value) && (this.found = !0);
      }, b.prototype.visitSet = function(a) {
        a.complement ? void 0 === k(a, this.targetCharCodes) && (this.found = !0) : void 0 !== k(a, this.targetCharCodes) && (this.found = !0);
      }, b;
    }(f.BaseRegExpVisitor);
    d.canMatchCharCode = function(a, c) {
      if (c instanceof RegExp) {
        c = b.pattern(c.toString());
        var d = new m(a);
        return d.visit(c), d.found;
      }
      return void 0 !== n.find(c, function(b) {
        return n.contains(a, b.charCodeAt(0));
      });
    };
  }, function(a, d, g) {
    function h(a, d) {
      return !(0 > a || d < a);
    }
    Object.defineProperty(d, "__esModule", {value:!0});
    a = function() {
      function a(a, c) {
        if (this.start = a, this.end = c, !h(a, c)) {
          throw Error("INVALID RANGE");
        }
      }
      return a.prototype.contains = function(a) {
        return this.start <= a && this.end >= a;
      }, a.prototype.containsRange = function(a) {
        return this.start <= a.start && this.end >= a.end;
      }, a.prototype.isContainedInRange = function(a) {
        return a.containsRange(this);
      }, a.prototype.strictlyContainsRange = function(a) {
        return this.start < a.start && this.end > a.end;
      }, a.prototype.isStrictlyContainedInRange = function(a) {
        return a.strictlyContainsRange(this);
      }, a;
    }();
    d.Range = a;
    d.isValidRange = h;
  }, function(a, d, g) {
    var h, e = this && this.__extends || (h = function(a, c) {
      return (h = Object.setPrototypeOf || {__proto__:[]} instanceof Array && function(a, b) {
        a.__proto__ = b;
      } || function(a, b) {
        for (var c in b) {
          b.hasOwnProperty(c) && (a[c] = b[c]);
        }
      })(a, c);
    }, function(a, c) {
      function d() {
        this.constructor = a;
      }
      h(a, c);
      a.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d);
    });
    Object.defineProperty(d, "__esModule", {value:!0});
    var k = g(3), c = g(0);
    a = g(5);
    d.resolveGrammar = function(a, c) {
      a = new p(a, c);
      return a.resolveRefs(), a.errors;
    };
    var p = function(a) {
      function d(c, b) {
        var d = a.call(this) || this;
        return d.nameToTopRule = c, d.errMsgProvider = b, d.errors = [], d;
      }
      return e(d, a), d.prototype.resolveRefs = function() {
        var a = this;
        c.forEach(this.nameToTopRule.values(), function(b) {
          a.currTopLevel = b;
          b.accept(a);
        });
      }, d.prototype.visitNonTerminal = function(a) {
        var b = this.nameToTopRule.get(a.nonTerminalName);
        b ? a.referencedRule = b : (b = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, a), this.errors.push({message:b, type:k.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF, ruleName:this.currTopLevel.name, unresolvedRefName:a.nonTerminalName}));
      }, d;
    }(a.GAstVisitor);
    d.GastRefResolverVisitor = p;
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    var h = g(12), e = g(0), k = g(3), c = g(9);
    a = function() {
      function a() {
      }
      return a.prototype.initLooksAhead = function(a) {
        this.dynamicTokensEnabled = e.has(a, "dynamicTokensEnabled") ? a.dynamicTokensEnabled : k.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
        this.maxLookahead = e.has(a, "maxLookahead") ? a.maxLookahead : k.DEFAULT_PARSER_CONFIG.maxLookahead;
        this.lookAheadFuncsCache = e.isES2015MapSupported() ? new Map : [];
        e.isES2015MapSupported() ? (this.getLaFuncFromCache = this.getLaFuncFromMap, this.setLaFuncCache = this.setLaFuncCacheUsingMap) : (this.getLaFuncFromCache = this.getLaFuncFromObj, this.setLaFuncCache = this.setLaFuncUsingObj);
      }, a.prototype.lookAheadBuilderForOptional = function(a, c, d) {
        return h.buildSingleAlternativeLookaheadFunction(a, c, d);
      }, a.prototype.lookAheadBuilderForAlternatives = function(a, c, d, b) {
        return h.buildAlternativesLookAheadFunc(a, c, d, b);
      }, a.prototype.getKeyForAutomaticLookahead = function(a, d) {
        var e = this.getLastExplicitRuleShortName();
        return c.getKeyForAutomaticLookahead(e, a, d);
      }, a.prototype.getLookaheadFuncForOr = function(a, d) {
        var f = this.getKeyForAutomaticLookahead(c.OR_IDX, a), b = this.getLaFuncFromCache(f);
        if (void 0 === b) {
          var g = this.getCurrRuleFullName();
          g = this.getGAstProductions().get(g);
          d = e.some(d, function(a) {
            return e.isFunction(a.GATE);
          });
          return b = h.buildLookaheadFuncForOr(a, g, this.maxLookahead, d, this.dynamicTokensEnabled, this.lookAheadBuilderForAlternatives), this.setLaFuncCache(f, b), b;
        }
        return b;
      }, a.prototype.getLookaheadFuncForOption = function(a, c) {
        return this.getLookaheadFuncFor(a, c, this.maxLookahead, h.PROD_TYPE.OPTION);
      }, a.prototype.getLookaheadFuncForMany = function(a, c) {
        return this.getLookaheadFuncFor(a, c, this.maxLookahead, h.PROD_TYPE.REPETITION);
      }, a.prototype.getLookaheadFuncForManySep = function(a, c) {
        return this.getLookaheadFuncFor(a, c, this.maxLookahead, h.PROD_TYPE.REPETITION_WITH_SEPARATOR);
      }, a.prototype.getLookaheadFuncForAtLeastOne = function(a, c) {
        return this.getLookaheadFuncFor(a, c, this.maxLookahead, h.PROD_TYPE.REPETITION_MANDATORY);
      }, a.prototype.getLookaheadFuncForAtLeastOneSep = function(a, c) {
        return this.getLookaheadFuncFor(a, c, this.maxLookahead, h.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
      }, a.prototype.getLookaheadFuncFor = function(a, c, d, b) {
        var e = this.getLaFuncFromCache(a);
        if (void 0 === e) {
          var f = this.getCurrRuleFullName();
          f = this.getGAstProductions().get(f);
          return e = h.buildLookaheadFuncForOptionalProd(c, f, d, this.dynamicTokensEnabled, b, this.lookAheadBuilderForOptional), this.setLaFuncCache(a, e), e;
        }
        return e;
      }, a.prototype.getLaFuncFromCache = function(a) {
      }, a.prototype.getLaFuncFromMap = function(a) {
        return this.lookAheadFuncsCache.get(a);
      }, a.prototype.getLaFuncFromObj = function(a) {
        return this.lookAheadFuncsCache[a];
      }, a.prototype.setLaFuncCache = function(a, c) {
      }, a.prototype.setLaFuncCacheUsingMap = function(a, c) {
        this.lookAheadFuncsCache.set(a, c);
      }, a.prototype.setLaFuncUsingObj = function(a, c) {
        this.lookAheadFuncsCache[a] = c;
      }, a;
    }();
    d.LooksAhead = a;
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    var h = g(16), e = g(0), k = g(33), c = g(9), p = g(3);
    a = function() {
      function a() {
      }
      return a.prototype.initTreeBuilder = function(a) {
        this.LAST_EXPLICIT_RULE_STACK = [];
        this.CST_STACK = [];
        (this.outputCst = e.has(a, "outputCst") ? a.outputCst : p.DEFAULT_PARSER_CONFIG.outputCst) || (this.cstInvocationStateUpdate = e.NOOP, this.cstFinallyStateUpdate = e.NOOP, this.cstPostTerminal = e.NOOP, this.cstPostNonTerminal = e.NOOP, this.getLastExplicitRuleShortName = this.getLastExplicitRuleShortNameNoCst, this.getPreviousExplicitRuleShortName = this.getPreviousExplicitRuleShortNameNoCst, this.getLastExplicitRuleOccurrenceIndex = this.getLastExplicitRuleOccurrenceIndexNoCst, this.manyInternal = 
        this.manyInternalNoCst, this.orInternal = this.orInternalNoCst, this.optionInternal = this.optionInternalNoCst, this.atLeastOneInternal = this.atLeastOneInternalNoCst, this.manySepFirstInternal = this.manySepFirstInternalNoCst, this.atLeastOneSepFirstInternal = this.atLeastOneSepFirstInternalNoCst);
      }, a.prototype.cstNestedInvocationStateUpdate = function(a, c) {
        this.CST_STACK.push({name:a, fullName:this.shortRuleNameToFull.get(this.getLastExplicitRuleShortName()) + a, children:{}});
      }, a.prototype.cstInvocationStateUpdate = function(a, c) {
        this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length - 1);
        this.CST_STACK.push({name:a, children:{}});
      }, a.prototype.cstFinallyStateUpdate = function() {
        this.LAST_EXPLICIT_RULE_STACK.pop();
        this.CST_STACK.pop();
      }, a.prototype.cstNestedFinallyStateUpdate = function() {
        this.CST_STACK.pop();
      }, a.prototype.cstPostTerminal = function(a, c) {
        h.addTerminalToCst(this.CST_STACK[this.CST_STACK.length - 1], c, a);
      }, a.prototype.cstPostNonTerminal = function(a, c) {
        h.addNoneTerminalToCst(this.CST_STACK[this.CST_STACK.length - 1], c, a);
      }, a.prototype.getBaseCstVisitorConstructor = function() {
        if (e.isUndefined(this.baseCstVisitorConstructor)) {
          var a = k.createBaseSemanticVisitorConstructor(this.className, this.allRuleNames);
          return this.baseCstVisitorConstructor = a, a;
        }
        return this.baseCstVisitorConstructor;
      }, a.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
        if (e.isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {
          var a = k.createBaseVisitorConstructorWithDefaults(this.className, this.allRuleNames, this.getBaseCstVisitorConstructor());
          return this.baseCstVisitorWithDefaultsConstructor = a, a;
        }
        return this.baseCstVisitorWithDefaultsConstructor;
      }, a.prototype.nestedRuleBeforeClause = function(a, c) {
        var b;
        return void 0 !== a.NAME ? (b = a.NAME, this.nestedRuleInvocationStateUpdate(b, c), b) : void 0;
      }, a.prototype.nestedAltBeforeClause = function(a, d, b, e) {
        var f, g = this.getLastExplicitRuleShortName();
        d = c.getKeyForAltIndex(g, b, d, e);
        return void 0 !== a.NAME ? (f = a.NAME, this.nestedRuleInvocationStateUpdate(f, d), {shortName:d, nestedName:f}) : void 0;
      }, a.prototype.nestedRuleFinallyClause = function(a, c) {
        a = this.CST_STACK;
        var b = a[a.length - 1];
        this.nestedRuleFinallyStateUpdate();
        h.addNoneTerminalToCst(a[a.length - 1], c, b);
      }, a.prototype.getLastExplicitRuleShortName = function() {
        return this.RULE_STACK[this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1]];
      }, a.prototype.getLastExplicitRuleShortNameNoCst = function() {
        var a = this.RULE_STACK;
        return a[a.length - 1];
      }, a.prototype.getPreviousExplicitRuleShortName = function() {
        return this.RULE_STACK[this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 2]];
      }, a.prototype.getPreviousExplicitRuleShortNameNoCst = function() {
        var a = this.RULE_STACK;
        return a[a.length - 2];
      }, a.prototype.getLastExplicitRuleOccurrenceIndex = function() {
        return this.RULE_OCCURRENCE_STACK[this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1]];
      }, a.prototype.getLastExplicitRuleOccurrenceIndexNoCst = function() {
        var a = this.RULE_OCCURRENCE_STACK;
        return a[a.length - 1];
      }, a.prototype.nestedRuleInvocationStateUpdate = function(a, c) {
        this.RULE_OCCURRENCE_STACK.push(1);
        this.RULE_STACK.push(c);
        this.cstNestedInvocationStateUpdate(a, c);
      }, a.prototype.nestedRuleFinallyStateUpdate = function() {
        this.RULE_STACK.pop();
        this.RULE_OCCURRENCE_STACK.pop();
        this.cstNestedFinallyStateUpdate();
      }, a;
    }();
    d.TreeBuilder = a;
  }, function(a, d, g) {
    function h(a, b) {
      for (var c = t.keys(a), d = c.length, e = 0; e < d; e++) {
        for (var f = a[c[e]], g = f.length, h = 0; h < g; h++) {
          var k = f[h];
          void 0 === k.tokenTypeIdx && (void 0 !== k.fullName ? this[k.fullName](k.children, b) : this[k.name](k.children, b));
        }
      }
    }
    function e(a, b) {
      var d = k(a, b);
      a = c(a, b);
      return d.concat(a);
    }
    function k(a, b) {
      b = t.map(b, function(b) {
        if (!t.isFunction(a[b])) {
          return {msg:"Missing visitor method: <" + b + "> on " + f.functionName(a.constructor) + " CST Visitor.", type:p.MISSING_METHOD, methodName:b};
        }
      });
      return t.compact(b);
    }
    function c(a, c) {
      var d = [], e;
      for (e in a) {
        n.validTermsPattern.test(e) && t.isFunction(a[e]) && !t.contains(b, e) && !t.contains(c, e) && d.push({msg:"Redundant visitor method: <" + e + "> on " + f.functionName(a.constructor) + " CST Visitor\nThere is no Grammar Rule corresponding to this method's name.\nFor utility methods on visitor classes use methods names that do not match /" + n.validTermsPattern.source + "/.", type:p.REDUNDANT_METHOD, methodName:e});
      }
      return d;
    }
    Object.defineProperty(d, "__esModule", {value:!0});
    var p, t = g(0), f = g(4), n = g(11);
    d.defaultVisit = h;
    d.createBaseSemanticVisitorConstructor = function(a, b) {
      var c = function() {
      };
      return f.defineNameProp(c, a + "BaseSemantics"), (c.prototype = {visit:function(a, b) {
        if (t.isArray(a) && (a = a[0]), !t.isUndefined(a)) {
          return void 0 !== a.fullName ? this[a.fullName](a.children, b) : this[a.name](a.children, b);
        }
      }, validateVisitor:function() {
        var a = e(this, b);
        if (!t.isEmpty(a)) {
          throw a = t.map(a, function(a) {
            return a.msg;
          }), Error("Errors Detected in CST Visitor <" + f.functionName(this.constructor) + ">:\n\t" + a.join("\n\n").replace(/\n/g, "\n\t"));
        }
      }}).constructor = c, c._RULE_NAMES = b, c;
    };
    d.createBaseVisitorConstructorWithDefaults = function(a, b, c) {
      var d = function() {
      };
      f.defineNameProp(d, a + "BaseSemanticsWithDefaults");
      var e = Object.create(c.prototype);
      return t.forEach(b, function(a) {
        e[a] = h;
      }), (d.prototype = e).constructor = d, d;
    };
    (function(a) {
      a[a.REDUNDANT_METHOD = 0] = "REDUNDANT_METHOD";
      a[a.MISSING_METHOD = 1] = "MISSING_METHOD";
    })(p = d.CstVisitorDefinitionError || (d.CstVisitorDefinitionError = {}));
    d.validateVisitor = e;
    d.validateMissingCstMethods = k;
    var b = ["constructor", "visit", "validateVisitor"];
    d.validateRedundantMethods = c;
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    var h = g(3);
    a = function() {
      function a() {
      }
      return a.prototype.initLexerAdapter = function() {
        this.tokVector = [];
        this.tokVectorLength = 0;
        this.currIdx = -1;
      }, Object.defineProperty(a.prototype, "input", {get:function() {
        return this.tokVector;
      }, set:function(a) {
        this.reset();
        this.tokVector = a;
        this.tokVectorLength = a.length;
      }, enumerable:!0, configurable:!0}), a.prototype.SKIP_TOKEN = function() {
        return this.currIdx <= this.tokVector.length - 2 ? (this.consumeToken(), this.LA(1)) : h.END_OF_FILE;
      }, a.prototype.LA = function(a) {
        return 0 > this.currIdx + a || this.tokVectorLength <= this.currIdx + a ? h.END_OF_FILE : this.tokVector[this.currIdx + a];
      }, a.prototype.consumeToken = function() {
        this.currIdx++;
      }, a.prototype.exportLexerState = function() {
        return this.currIdx;
      }, a.prototype.importLexerState = function(a) {
        this.currIdx = a;
      }, a.prototype.resetLexerState = function() {
        this.currIdx = -1;
      }, a.prototype.moveToTerminatedState = function() {
        this.currIdx = this.tokVector.length - 1;
      }, a.prototype.getLexerPosition = function() {
        return this.exportLexerState();
      }, a;
    }();
    d.LexerAdapter = a;
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    var h = g(0), e = g(6), k = g(3), c = g(10), p = g(23), t = g(11), f = g(1);
    a = function() {
      function a() {
      }
      return a.prototype.CONSUME = function(a, c) {
        return this.consumeInternal(a, 0, c);
      }, a.prototype.CONSUME1 = function(a, c) {
        return this.consumeInternal(a, 1, c);
      }, a.prototype.CONSUME2 = function(a, c) {
        return this.consumeInternal(a, 2, c);
      }, a.prototype.CONSUME3 = function(a, c) {
        return this.consumeInternal(a, 3, c);
      }, a.prototype.CONSUME4 = function(a, c) {
        return this.consumeInternal(a, 4, c);
      }, a.prototype.CONSUME5 = function(a, c) {
        return this.consumeInternal(a, 5, c);
      }, a.prototype.CONSUME6 = function(a, c) {
        return this.consumeInternal(a, 6, c);
      }, a.prototype.CONSUME7 = function(a, c) {
        return this.consumeInternal(a, 7, c);
      }, a.prototype.CONSUME8 = function(a, c) {
        return this.consumeInternal(a, 8, c);
      }, a.prototype.CONSUME9 = function(a, c) {
        return this.consumeInternal(a, 9, c);
      }, a.prototype.SUBRULE = function(a, c) {
        return this.subruleInternal(a, 0, c);
      }, a.prototype.SUBRULE1 = function(a, c) {
        return this.subruleInternal(a, 1, c);
      }, a.prototype.SUBRULE2 = function(a, c) {
        return this.subruleInternal(a, 2, c);
      }, a.prototype.SUBRULE3 = function(a, c) {
        return this.subruleInternal(a, 3, c);
      }, a.prototype.SUBRULE4 = function(a, c) {
        return this.subruleInternal(a, 4, c);
      }, a.prototype.SUBRULE5 = function(a, c) {
        return this.subruleInternal(a, 5, c);
      }, a.prototype.SUBRULE6 = function(a, c) {
        return this.subruleInternal(a, 6, c);
      }, a.prototype.SUBRULE7 = function(a, c) {
        return this.subruleInternal(a, 7, c);
      }, a.prototype.SUBRULE8 = function(a, c) {
        return this.subruleInternal(a, 8, c);
      }, a.prototype.SUBRULE9 = function(a, c) {
        return this.subruleInternal(a, 9, c);
      }, a.prototype.OPTION = function(a) {
        return this.optionInternal(a, 0);
      }, a.prototype.OPTION1 = function(a) {
        return this.optionInternal(a, 1);
      }, a.prototype.OPTION2 = function(a) {
        return this.optionInternal(a, 2);
      }, a.prototype.OPTION3 = function(a) {
        return this.optionInternal(a, 3);
      }, a.prototype.OPTION4 = function(a) {
        return this.optionInternal(a, 4);
      }, a.prototype.OPTION5 = function(a) {
        return this.optionInternal(a, 5);
      }, a.prototype.OPTION6 = function(a) {
        return this.optionInternal(a, 6);
      }, a.prototype.OPTION7 = function(a) {
        return this.optionInternal(a, 7);
      }, a.prototype.OPTION8 = function(a) {
        return this.optionInternal(a, 8);
      }, a.prototype.OPTION9 = function(a) {
        return this.optionInternal(a, 9);
      }, a.prototype.OR = function(a) {
        return this.orInternal(a, 0);
      }, a.prototype.OR1 = function(a) {
        return this.orInternal(a, 1);
      }, a.prototype.OR2 = function(a) {
        return this.orInternal(a, 2);
      }, a.prototype.OR3 = function(a) {
        return this.orInternal(a, 3);
      }, a.prototype.OR4 = function(a) {
        return this.orInternal(a, 4);
      }, a.prototype.OR5 = function(a) {
        return this.orInternal(a, 5);
      }, a.prototype.OR6 = function(a) {
        return this.orInternal(a, 6);
      }, a.prototype.OR7 = function(a) {
        return this.orInternal(a, 7);
      }, a.prototype.OR8 = function(a) {
        return this.orInternal(a, 8);
      }, a.prototype.OR9 = function(a) {
        return this.orInternal(a, 9);
      }, a.prototype.MANY = function(a) {
        this.manyInternal(0, a);
      }, a.prototype.MANY1 = function(a) {
        this.manyInternal(1, a);
      }, a.prototype.MANY2 = function(a) {
        this.manyInternal(2, a);
      }, a.prototype.MANY3 = function(a) {
        this.manyInternal(3, a);
      }, a.prototype.MANY4 = function(a) {
        this.manyInternal(4, a);
      }, a.prototype.MANY5 = function(a) {
        this.manyInternal(5, a);
      }, a.prototype.MANY6 = function(a) {
        this.manyInternal(6, a);
      }, a.prototype.MANY7 = function(a) {
        this.manyInternal(7, a);
      }, a.prototype.MANY8 = function(a) {
        this.manyInternal(8, a);
      }, a.prototype.MANY9 = function(a) {
        this.manyInternal(9, a);
      }, a.prototype.MANY_SEP = function(a) {
        this.manySepFirstInternal(0, a);
      }, a.prototype.MANY_SEP1 = function(a) {
        this.manySepFirstInternal(1, a);
      }, a.prototype.MANY_SEP2 = function(a) {
        this.manySepFirstInternal(2, a);
      }, a.prototype.MANY_SEP3 = function(a) {
        this.manySepFirstInternal(3, a);
      }, a.prototype.MANY_SEP4 = function(a) {
        this.manySepFirstInternal(4, a);
      }, a.prototype.MANY_SEP5 = function(a) {
        this.manySepFirstInternal(5, a);
      }, a.prototype.MANY_SEP6 = function(a) {
        this.manySepFirstInternal(6, a);
      }, a.prototype.MANY_SEP7 = function(a) {
        this.manySepFirstInternal(7, a);
      }, a.prototype.MANY_SEP8 = function(a) {
        this.manySepFirstInternal(8, a);
      }, a.prototype.MANY_SEP9 = function(a) {
        this.manySepFirstInternal(9, a);
      }, a.prototype.AT_LEAST_ONE = function(a) {
        this.atLeastOneInternal(0, a);
      }, a.prototype.AT_LEAST_ONE1 = function(a) {
        return this.atLeastOneInternal(1, a);
      }, a.prototype.AT_LEAST_ONE2 = function(a) {
        this.atLeastOneInternal(2, a);
      }, a.prototype.AT_LEAST_ONE3 = function(a) {
        this.atLeastOneInternal(3, a);
      }, a.prototype.AT_LEAST_ONE4 = function(a) {
        this.atLeastOneInternal(4, a);
      }, a.prototype.AT_LEAST_ONE5 = function(a) {
        this.atLeastOneInternal(5, a);
      }, a.prototype.AT_LEAST_ONE6 = function(a) {
        this.atLeastOneInternal(6, a);
      }, a.prototype.AT_LEAST_ONE7 = function(a) {
        this.atLeastOneInternal(7, a);
      }, a.prototype.AT_LEAST_ONE8 = function(a) {
        this.atLeastOneInternal(8, a);
      }, a.prototype.AT_LEAST_ONE9 = function(a) {
        this.atLeastOneInternal(9, a);
      }, a.prototype.AT_LEAST_ONE_SEP = function(a) {
        this.atLeastOneSepFirstInternal(0, a);
      }, a.prototype.AT_LEAST_ONE_SEP1 = function(a) {
        this.atLeastOneSepFirstInternal(1, a);
      }, a.prototype.AT_LEAST_ONE_SEP2 = function(a) {
        this.atLeastOneSepFirstInternal(2, a);
      }, a.prototype.AT_LEAST_ONE_SEP3 = function(a) {
        this.atLeastOneSepFirstInternal(3, a);
      }, a.prototype.AT_LEAST_ONE_SEP4 = function(a) {
        this.atLeastOneSepFirstInternal(4, a);
      }, a.prototype.AT_LEAST_ONE_SEP5 = function(a) {
        this.atLeastOneSepFirstInternal(5, a);
      }, a.prototype.AT_LEAST_ONE_SEP6 = function(a) {
        this.atLeastOneSepFirstInternal(6, a);
      }, a.prototype.AT_LEAST_ONE_SEP7 = function(a) {
        this.atLeastOneSepFirstInternal(7, a);
      }, a.prototype.AT_LEAST_ONE_SEP8 = function(a) {
        this.atLeastOneSepFirstInternal(8, a);
      }, a.prototype.AT_LEAST_ONE_SEP9 = function(a) {
        this.atLeastOneSepFirstInternal(9, a);
      }, a.prototype.RULE = function(a, d, e) {
        if (void 0 === e && (e = k.DEFAULT_RULE_CONFIG), h.contains(this.definedRulesNames, a)) {
          var b = {message:c.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({topLevelRule:a, grammarName:this.className}), type:k.ParserDefinitionErrorType.DUPLICATE_RULE_NAME, ruleName:a};
          this.definitionErrors.push(b);
        }
        (this.definedRulesNames.push(a), this.gastProductionsCache.containsKey(a) || this.serializedGrammar) || (b = p.buildTopProduction(d.toString(), a, this.tokensMap), this.gastProductionsCache.put(a, b));
        d = this.defineRule(a, d, e);
        return this[a] = d, d;
      }, a.prototype.OVERRIDE_RULE = function(a, c, d) {
        void 0 === d && (d = k.DEFAULT_RULE_CONFIG);
        var b = [];
        (b = b.concat(t.validateRuleIsOverridden(a, this.definedRulesNames, this.className)), this.definitionErrors.push.apply(this.definitionErrors, b), this.serializedGrammar) || (b = p.buildTopProduction(c.toString(), a, this.tokensMap), this.gastProductionsCache.put(a, b));
        c = this.defineRule(a, c, d);
        return this[a] = c, c;
      }, a.prototype.BACKTRACK = function(a, c) {
        return function() {
          this.isBackTrackingStack.push(1);
          var b = this.saveRecogState();
          try {
            return a.apply(this, c), !0;
          } catch (y) {
            if (e.isRecognitionException(y)) {
              return !1;
            }
            throw y;
          } finally {
            this.reloadRecogState(b), this.isBackTrackingStack.pop();
          }
        };
      }, a.prototype.getGAstProductions = function() {
        return this.gastProductionsCache;
      }, a.prototype.getSerializedGastProductions = function() {
        return f.serializeGrammar(this.gastProductionsCache.values());
      }, a;
    }();
    d.RecognizerApi = a;
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    var h = g(0), e = g(9), k = g(6), c = g(12), p = g(13), t = g(3), f = g(25), n = g(2), b = g(7), m = g(4);
    a = function() {
      function a() {
      }
      return a.prototype.initRecognizerEngine = function(a, c) {
        if (this.className = m.classNameFromInstance(this), this.shortRuleNameToFull = new m.HashTable, this.fullRuleNameToShort = new m.HashTable, this.ruleShortNameIdx = 256, this.tokenMatcher = b.tokenStructuredMatcherNoCategories, this.definedRulesNames = [], this.tokensMap = {}, this.allRuleNames = [], this.isBackTrackingStack = [], this.RULE_STACK = [], this.RULE_OCCURRENCE_STACK = [], this.gastProductionsCache = new m.HashTable, this.serializedGrammar = h.has(c, "serializedGrammar") ? c.serializedGrammar : 
        t.DEFAULT_PARSER_CONFIG.serializedGrammar, h.isArray(a)) {
          if (h.isEmpty(a)) {
            throw Error("A Token Vocabulary cannot be empty.\n\tNote that the first argument for the parser constructor\n\tis no longer a Token vector (since v4.0).");
          }
          if ("number" == typeof a[0].startOffset) {
            throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\n\tFor Further details.");
          }
        }
        if (h.isArray(a)) {
          this.tokensMap = h.reduce(a, function(a, b) {
            return a[n.tokenName(b)] = b, a;
          }, {});
        } else {
          if (h.has(a, "modes") && h.every(h.flatten(h.values(a.modes)), b.isTokenType)) {
            c = h.flatten(h.values(a.modes)), c = h.uniq(c), this.tokensMap = h.reduce(c, function(a, b) {
              return a[n.tokenName(b)] = b, a;
            }, {});
          } else {
            if (!h.isObject(a)) {
              throw Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
            }
            this.tokensMap = h.cloneObj(a);
          }
        }
        this.tokensMap.EOF = n.EOF;
        this.tokenMatcher = h.every(h.values(a), function(a) {
          return h.isEmpty(a.categoryMatches);
        }) ? b.tokenStructuredMatcherNoCategories : b.tokenStructuredMatcher;
        b.augmentTokenTypes(h.values(this.tokensMap));
      }, a.prototype.defineRule = function(a, b, c) {
        if (this.selfAnalysisDone) {
          throw Error("Grammar rule <" + a + "> may not be defined after the 'performSelfAnalysis' method has been called'\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
        }
        var d, f = h.has(c, "resyncEnabled") ? c.resyncEnabled : t.DEFAULT_RULE_CONFIG.resyncEnabled, g = h.has(c, "recoveryValueFunc") ? c.recoveryValueFunc : t.DEFAULT_RULE_CONFIG.recoveryValueFunc, m = this.ruleShortNameIdx << e.BITS_FOR_METHOD_IDX + e.BITS_FOR_OCCURRENCE_IDX;
        this.ruleShortNameIdx++;
        this.shortRuleNameToFull.put(m, a);
        this.fullRuleNameToShort.put(a, m);
        return (d = function(c, d) {
          void 0 === c && (c = 0);
          this.ruleInvocationStateUpdate(m, a, c);
          a: {
            try {
              var e = !0 === this.outputCst ? (b.apply(this, d), this.CST_STACK[this.CST_STACK.length - 1]) : b.apply(this, d);
              break a;
            } catch (K) {
              var h = 1 === this.RULE_STACK.length, n = f && !this.isBackTracking() && this.recoveryEnabled;
              if (k.isRecognitionException(K)) {
                if (n) {
                  var p, r = this.findReSyncTokenType();
                  if (this.isInCurrentRuleReSyncSet(r)) {
                    e = (K.resyncedTokens = this.reSyncTo(r), this.outputCst ? ((p = this.CST_STACK[this.CST_STACK.length - 1]).recoveredNode = !0, p) : g());
                    break a;
                  }
                  throw this.outputCst && ((p = this.CST_STACK[this.CST_STACK.length - 1]).recoveredNode = !0, K.partialCstResult = p), K;
                }
                if (h) {
                  e = (this.moveToTerminatedState(), g());
                  break a;
                }
              }
              throw K;
            } finally {
              this.ruleFinallyStateUpdate();
            }
            e = void 0;
          }
          return e;
        }).ruleName = a, d;
      }, a.prototype.optionInternal = function(a, b) {
        var c = this.getKeyForAutomaticLookahead(e.OPTION_IDX, b), d = this.nestedRuleBeforeClause(a, c);
        try {
          return this.optionInternalLogic(a, b, c);
        } finally {
          void 0 !== d && this.nestedRuleFinallyClause(c, d);
        }
      }, a.prototype.optionInternalNoCst = function(a, b) {
        var c = this.getKeyForAutomaticLookahead(e.OPTION_IDX, b);
        return this.optionInternalLogic(a, b, c);
      }, a.prototype.optionInternalLogic = function(a, b, c) {
        var d, e = this;
        c = this.getLookaheadFuncForOption(c, b);
        if (void 0 !== a.DEF) {
          if (b = a.DEF, void 0 !== (d = a.GATE)) {
            var f = c;
            c = function() {
              return d.call(e) && f.call(e);
            };
          }
        } else {
          b = a;
        }
        if (!0 === c.call(this)) {
          return b.call(this);
        }
      }, a.prototype.atLeastOneInternal = function(a, b) {
        var c = this.getKeyForAutomaticLookahead(e.AT_LEAST_ONE_IDX, a), d = this.nestedRuleBeforeClause(b, c);
        try {
          return this.atLeastOneInternalLogic(a, b, c);
        } finally {
          void 0 !== d && this.nestedRuleFinallyClause(c, d);
        }
      }, a.prototype.atLeastOneInternalNoCst = function(a, b) {
        var c = this.getKeyForAutomaticLookahead(e.AT_LEAST_ONE_IDX, a);
        this.atLeastOneInternalLogic(a, b, c);
      }, a.prototype.atLeastOneInternalLogic = function(a, b, d) {
        var f, g = this, h = this.getLookaheadFuncForAtLeastOne(d, a);
        if (void 0 !== b.DEF) {
          if (d = b.DEF, void 0 !== (f = b.GATE)) {
            var k = h;
            h = function() {
              return f.call(g) && k.call(g);
            };
          }
        } else {
          d = b;
        }
        if (!0 !== h.call(this)) {
          throw this.raiseEarlyExitException(a, c.PROD_TYPE.REPETITION_MANDATORY, b.ERR_MSG);
        }
        for (var m = this.doSingleRepetition(d); !0 === h.call(this) && !0 === m;) {
          m = this.doSingleRepetition(d);
        }
        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [a, b], h, e.AT_LEAST_ONE_IDX, a, p.NextTerminalAfterAtLeastOneWalker);
      }, a.prototype.atLeastOneSepFirstInternal = function(a, b) {
        var c = this.getKeyForAutomaticLookahead(e.AT_LEAST_ONE_SEP_IDX, a), d = this.nestedRuleBeforeClause(b, c);
        try {
          this.atLeastOneSepFirstInternalLogic(a, b, c);
        } finally {
          void 0 !== d && this.nestedRuleFinallyClause(c, d);
        }
      }, a.prototype.atLeastOneSepFirstInternalNoCst = function(a, b) {
        var c = this.getKeyForAutomaticLookahead(e.AT_LEAST_ONE_SEP_IDX, a);
        this.atLeastOneSepFirstInternalLogic(a, b, c);
      }, a.prototype.atLeastOneSepFirstInternalLogic = function(a, b, d) {
        var f = this, g = b.DEF, h = b.SEP;
        if (!0 !== this.getLookaheadFuncForAtLeastOneSep(d, a).call(this)) {
          throw this.raiseEarlyExitException(a, c.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, b.ERR_MSG);
        }
        g.call(this);
        for (b = function() {
          return f.tokenMatcher(f.LA(1), h);
        }; !0 === this.tokenMatcher(this.LA(1), h);) {
          this.CONSUME(h), g.call(this);
        }
        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [a, h, b, g, p.NextTerminalAfterAtLeastOneSepWalker], b, e.AT_LEAST_ONE_SEP_IDX, a, p.NextTerminalAfterAtLeastOneSepWalker);
      }, a.prototype.manyInternal = function(a, b) {
        var c = this.getKeyForAutomaticLookahead(e.MANY_IDX, a), d = this.nestedRuleBeforeClause(b, c);
        try {
          return this.manyInternalLogic(a, b, c);
        } finally {
          void 0 !== d && this.nestedRuleFinallyClause(c, d);
        }
      }, a.prototype.manyInternalNoCst = function(a, b) {
        var c = this.getKeyForAutomaticLookahead(e.MANY_IDX, a);
        return this.manyInternalLogic(a, b, c);
      }, a.prototype.manyInternalLogic = function(a, b, c) {
        var d, f = this, g = this.getLookaheadFuncForMany(c, a);
        if (void 0 !== b.DEF) {
          if (c = b.DEF, void 0 !== (d = b.GATE)) {
            var h = g;
            g = function() {
              return d.call(f) && h.call(f);
            };
          }
        } else {
          c = b;
        }
        for (var k = !0; !0 === g.call(this) && !0 === k;) {
          k = this.doSingleRepetition(c);
        }
        this.attemptInRepetitionRecovery(this.manyInternal, [a, b], g, e.MANY_IDX, a, p.NextTerminalAfterManyWalker);
      }, a.prototype.manySepFirstInternal = function(a, b) {
        var c = this.getKeyForAutomaticLookahead(e.MANY_SEP_IDX, a), d = this.nestedRuleBeforeClause(b, c);
        try {
          this.manySepFirstInternalLogic(a, b, c);
        } finally {
          void 0 !== d && this.nestedRuleFinallyClause(c, d);
        }
      }, a.prototype.manySepFirstInternalNoCst = function(a, b) {
        var c = this.getKeyForAutomaticLookahead(e.MANY_SEP_IDX, a);
        this.manySepFirstInternalLogic(a, b, c);
      }, a.prototype.manySepFirstInternalLogic = function(a, b, c) {
        var d = this, f = b.DEF, g = b.SEP;
        if (!0 === this.getLookaheadFuncForManySep(c, a).call(this)) {
          f.call(this);
          for (b = function() {
            return d.tokenMatcher(d.LA(1), g);
          }; !0 === this.tokenMatcher(this.LA(1), g);) {
            this.CONSUME(g), f.call(this);
          }
          this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [a, g, b, f, p.NextTerminalAfterManySepWalker], b, e.MANY_SEP_IDX, a, p.NextTerminalAfterManySepWalker);
        }
      }, a.prototype.repetitionSepSecondInternal = function(a, b, c, d, f) {
        for (; c();) {
          this.CONSUME(b), d.call(this);
        }
        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [a, b, c, d, f], c, e.AT_LEAST_ONE_SEP_IDX, a, f);
      }, a.prototype.doSingleRepetition = function(a) {
        var b = this.getLexerPosition();
        return a.call(this), this.getLexerPosition() > b;
      }, a.prototype.orInternalNoCst = function(a, b) {
        var c = h.isArray(a) ? a : a.DEF, d = this.getLookaheadFuncForOr(b, c).call(this, c);
        if (void 0 !== d) {
          return c[d].ALT.call(this);
        }
        this.raiseNoAltException(b, a.ERR_MSG);
      }, a.prototype.orInternal = function(a, b) {
        var c = this.getKeyForAutomaticLookahead(e.OR_IDX, b), d = this.nestedRuleBeforeClause(a, c);
        try {
          var f = h.isArray(a) ? a : a.DEF, g = this.getLookaheadFuncForOr(b, f).call(this, f);
          if (void 0 !== g) {
            var k = f[g], m = this.nestedAltBeforeClause(k, b, e.OR_IDX, g);
            try {
              return k.ALT.call(this);
            } finally {
              void 0 !== m && this.nestedRuleFinallyClause(m.shortName, m.nestedName);
            }
          }
          this.raiseNoAltException(b, a.ERR_MSG);
        } finally {
          void 0 !== d && this.nestedRuleFinallyClause(c, d);
        }
      }, a.prototype.ruleFinallyStateUpdate = function() {
        if (this.RULE_STACK.pop(), this.RULE_OCCURRENCE_STACK.pop(), this.cstFinallyStateUpdate(), 0 === this.RULE_STACK.length && !this.isAtEndOfInput()) {
          var a = this.LA(1), b = this.errorMessageProvider.buildNotAllInputParsedMessage({firstRedundant:a, ruleName:this.getCurrRuleFullName()});
          this.SAVE_ERROR(new k.NotAllInputParsedException(b, a));
        }
      }, a.prototype.subruleInternal = function(a, b, c) {
        var d;
        try {
          return d = a.call(this, b, void 0 !== c ? c.ARGS : void 0), this.cstPostNonTerminal(d, void 0 !== c && void 0 !== c.LABEL ? c.LABEL : a.ruleName), d;
        } catch (u) {
          throw k.isRecognitionException(u) && void 0 !== u.partialCstResult && (this.cstPostNonTerminal(u.partialCstResult, void 0 !== c && void 0 !== c.LABEL ? c.LABEL : a.ruleName), delete u.partialCstResult), u;
        }
      }, a.prototype.consumeInternal = function(a, b, c) {
        try {
          var d = this.LA(1);
          if (!0 !== this.tokenMatcher(d, a)) {
            var e = void 0, g = this.LA(0);
            throw e = void 0 !== c && c.ERR_MSG ? c.ERR_MSG : this.errorMessageProvider.buildMismatchTokenMessage({expected:a, actual:d, previous:g, ruleName:this.getCurrRuleFullName()}), this.SAVE_ERROR(new k.MismatchedTokenException(e, d, g));
          }
          this.consumeToken();
          var h = d;
        } catch (A) {
          if (!this.recoveryEnabled || "MismatchedTokenException" !== A.name || this.isBackTracking()) {
            throw A;
          }
          b = this.getFollowsForInRuleRecovery(a, b);
          try {
            h = this.tryInRuleRecovery(a, b);
          } catch (D) {
            throw D.name === f.IN_RULE_RECOVERY_EXCEPTION ? A : D;
          }
        }
        return this.cstPostTerminal(void 0 !== c && void 0 !== c.LABEL ? c.LABEL : a.tokenName, h), h;
      }, a.prototype.saveRecogState = function() {
        var a = this.errors, b = h.cloneArr(this.RULE_STACK);
        return {errors:a, lexerState:this.exportLexerState(), RULE_STACK:b, CST_STACK:this.CST_STACK, LAST_EXPLICIT_RULE_STACK:this.LAST_EXPLICIT_RULE_STACK};
      }, a.prototype.reloadRecogState = function(a) {
        this.errors = a.errors;
        this.importLexerState(a.lexerState);
        this.RULE_STACK = a.RULE_STACK;
      }, a.prototype.ruleInvocationStateUpdate = function(a, b, c) {
        this.RULE_OCCURRENCE_STACK.push(c);
        this.RULE_STACK.push(a);
        this.cstInvocationStateUpdate(b, a);
      }, a.prototype.isBackTracking = function() {
        return !h.isEmpty(this.isBackTrackingStack);
      }, a.prototype.getCurrRuleFullName = function() {
        var a = this.getLastExplicitRuleShortName();
        return this.shortRuleNameToFull.get(a);
      }, a.prototype.shortRuleNameToFullName = function(a) {
        return this.shortRuleNameToFull.get(a);
      }, a.prototype.isAtEndOfInput = function() {
        return this.tokenMatcher(this.LA(1), n.EOF);
      }, a.prototype.reset = function() {
        this.resetLexerState();
        this.isBackTrackingStack = [];
        this.errors = [];
        this.RULE_STACK = [];
        this.LAST_EXPLICIT_RULE_STACK = [];
        this.CST_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
      }, a;
    }();
    d.RecognizerEngine = a;
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    var h = g(6), e = g(0), k = g(12), c = g(3);
    a = function() {
      function a() {
      }
      return a.prototype.initErrorHandler = function(a) {
        this._errors = [];
        this.errorMessageProvider = e.defaults(a.errorMessageProvider, c.DEFAULT_PARSER_CONFIG.errorMessageProvider);
      }, a.prototype.SAVE_ERROR = function(a) {
        if (h.isRecognitionException(a)) {
          return a.context = {ruleStack:this.getHumanReadableRuleStack(), ruleOccurrenceStack:e.cloneArr(this.RULE_OCCURRENCE_STACK)}, this._errors.push(a), a;
        }
        throw Error("Trying to save an Error which is not a RecognitionException");
      }, Object.defineProperty(a.prototype, "errors", {get:function() {
        return e.cloneArr(this._errors);
      }, set:function(a) {
        this._errors = a;
      }, enumerable:!0, configurable:!0}), a.prototype.raiseEarlyExitException = function(a, c, d) {
        var b = this.getCurrRuleFullName(), e = this.getGAstProductions().get(b);
        a = k.getLookaheadPathsForOptionalProd(a, e, c, this.maxLookahead)[0];
        c = [];
        for (e = 1; e < this.maxLookahead; e++) {
          c.push(this.LA(e));
        }
        d = this.errorMessageProvider.buildEarlyExitMessage({expectedIterationPaths:a, actual:c, previous:this.LA(0), customUserDescription:d, ruleName:b});
        throw this.SAVE_ERROR(new h.EarlyExitException(d, this.LA(1), this.LA(0)));
      }, a.prototype.raiseNoAltException = function(a, c) {
        var d = this.getCurrRuleFullName();
        d = this.getGAstProductions().get(d);
        a = k.getLookaheadPathsForOr(a, d, this.maxLookahead);
        d = [];
        for (var b = 1; b <= this.maxLookahead; b++) {
          d.push(this.LA(b));
        }
        b = this.LA(0);
        c = this.errorMessageProvider.buildNoViableAltMessage({expectedPathsPerAlt:a, actual:d, previous:b, customUserDescription:c, ruleName:this.getCurrRuleFullName()});
        throw this.SAVE_ERROR(new h.NoViableAltException(c, this.LA(1), b));
      }, a;
    }();
    d.ErrorHandler = a;
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    var h = g(13), e = g(0);
    a = function() {
      function a() {
      }
      return a.prototype.initContentAssist = function() {
      }, a.prototype.computeContentAssist = function(a, d) {
        var c = this.gastProductionsCache.get(a);
        if (e.isUndefined(c)) {
          throw Error("Rule ->" + a + "<- does not exist in this grammar.");
        }
        return h.nextPossibleTokensAfter([c], d, this.tokenMatcher, this.maxLookahead);
      }, a.prototype.getNextPossibleTokenTypes = function(a) {
        var c = e.first(a.ruleStack);
        c = this.getGAstProductions().get(c);
        return (new h.NextAfterTokenWalker(c, a)).startWalking();
      }, a;
    }();
    d.ContentAssist = a;
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    var h = g(17);
    d.createSyntaxDiagramsCode = function(a, d) {
      d = void 0 === d ? {} : d;
      var c = d.resourceBase;
      c = void 0 === c ? "https://unpkg.com/chevrotain@" + h.VERSION + "/diagrams/" : c;
      d = d.css;
      return "\n\x3c!-- This is a generated file --\x3e\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n\n<link rel='stylesheet' href='" + (void 0 === d ? "https://unpkg.com/chevrotain@" + h.VERSION + "/diagrams/diagrams.css" : d) + "'>\n\n<script src='" + c + "vendor/railroad-diagrams.js'>\x3c/script>\n<script src='" + c + "src/diagrams_builder.js'>\x3c/script>\n<script src='" + c + "src/diagrams_behavior.js'>\x3c/script>\n<script src='" + 
      c + 'src/main.js\'>\x3c/script>\n\n<div id="diagrams" align="center"></div>    \n\n<script>\n    window.serializedGrammar = ' + JSON.stringify(a, null, "  ") + ';\n\x3c/script>\n\n<script>\n    var diagramsDiv = document.getElementById("diagrams");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n\x3c/script>\n';
    };
  }, function(a, d, g) {
    Object.defineProperty(d, "__esModule", {value:!0});
    var h = g(41);
    d.generateParserFactory = function(a) {
      var d = h.genWrapperFunction({name:a.name, rules:a.rules}), c = new Function("tokenVocabulary", "config", "chevrotain", d);
      return function(d) {
        return c(a.tokenVocabulary, d, g(18));
      };
    };
    d.generateParserModule = function(a) {
      return h.genUmdModule({name:a.name, rules:a.rules});
    };
  }, function(a, d, g) {
    function h(a) {
      return "\nfunction " + a.name + "(tokenVocabulary, config) {\n    // invoke super constructor\n    // No support for embedded actions currently, so we can 'hardcode'\n    // The use of CstParser.\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\n\n    const $ = this\n\n    " + e(a.rules) + "\n\n    // very important to call this after all the rules have been defined.\n    // otherwise the parser may not work correctly as it will lack information\n    // derived during the self analysis phase.\n    this.performSelfAnalysis(this)\n}\n\n// inheritance as implemented in javascript in the previous decade... :(\n" + 
      a.name + ".prototype = Object.create(chevrotain.CstParser.prototype)\n" + a.name + ".prototype.constructor = " + a.name + "    \n    ";
    }
    function e(a) {
      return y.map(a, function(a) {
        return k(a, 1);
      }).join("\n");
    }
    function k(a, b) {
      var c = q(b, '$.RULE("' + a.name + '", function() {') + "\n";
      return c += m(a.definition, b + 1), c + (q(b + 1, "})") + "\n");
    }
    function c(a, b) {
      var c = x.tokenName(a.terminalType);
      return q(b, "$.CONSUME" + a.idx + "(this.tokensMap." + c + ")\n");
    }
    function p(a, b) {
      return q(b, "$.SUBRULE" + a.idx + "($." + a.nonTerminalName + ")\n");
    }
    function t(a, b) {
      var c = q(b, "$.OR" + a.idx + "([") + "\n";
      return c += y.map(a.definition, function(a) {
        return f(a, b + 1);
      }).join(",\n"), c += "\n" + q(b, "])\n");
    }
    function f(a, b) {
      var c = q(b, "{") + "\n";
      return a.name && (c += q(b + 1, 'NAME: "' + a.name + '",') + "\n"), c += q(b + 1, "ALT: function() {") + "\n", c += m(a.definition, b + 1), c += q(b + 1, "}") + "\n", c + q(b, "}");
    }
    function n(a, c, d) {
      a = q(d, "$." + (a + c.idx) + "(");
      return c.name || c.separator ? (a += "{\n", c.name && (a += q(d + 1, 'NAME: "' + c.name + '"') + ",\n"), c.separator && (a += q(d + 1, "SEP: this.tokensMap." + x.tokenName(c.separator)) + ",\n"), a += "DEF: " + b(c.definition, d + 2) + "\n", a += q(d, "}") + "\n") : a += b(c.definition, d + 1), a + (q(d, ")") + "\n");
    }
    function b(a, b) {
      var c = "function() {\n";
      return c += m(a, b), c + (q(b, "}") + "\n");
    }
    function m(a, b) {
      var d = "";
      return y.forEach(a, function(a) {
        d += function(a, b) {
          if (a instanceof z.NonTerminal) {
            return p(a, b);
          }
          if (a instanceof z.Option) {
            return n("OPTION", a, b);
          }
          if (a instanceof z.RepetitionMandatory) {
            return n("AT_LEAST_ONE", a, b);
          }
          if (a instanceof z.RepetitionMandatoryWithSeparator) {
            return n("AT_LEAST_ONE_SEP", a, b);
          }
          if (a instanceof z.RepetitionWithSeparator) {
            return n("MANY_SEP", a, b);
          }
          if (a instanceof z.Repetition) {
            return n("MANY", a, b);
          }
          if (a instanceof z.Alternation) {
            return t(a, b);
          }
          if (a instanceof z.Terminal) {
            return c(a, b);
          }
          if (a instanceof z.Flat) {
            return m(a.definition, b);
          }
          throw Error("non exhaustive match");
        }(a, b + 1);
      }), d;
    }
    function q(a, b) {
      return Array(4 * a + 1).join(" ") + b;
    }
    Object.defineProperty(d, "__esModule", {value:!0});
    var y = g(0), x = g(2), z = g(1);
    d.genUmdModule = function(a) {
      return "\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['chevrotain'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require('chevrotain'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.b);\n    }\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\n\n" + 
      h(a) + "\n    \nreturn {\n    " + a.name + ": " + a.name + " \n}\n}));\n";
    };
    d.genWrapperFunction = function(a) {
      return "    \n" + h(a) + "\nreturn new " + a.name + "(tokenVocabulary, config)    \n";
    };
    d.genClass = h;
    d.genAllRules = e;
    d.genRule = k;
    d.genTerminal = c;
    d.genNonTerminal = p;
    d.genAlternation = t;
    d.genSingleAlt = f;
  }]);
});
"use strict";
THREE.KeyframeTrack.prototype.color = "#FF0000";
THREE.KeyframeTrack.prototype.setColor = function(a) {
  this.color = a;
};
THREE.KeyframeTrack.prototype.sort = function() {
  for (var a = 0; a < this.times.length; a++) {
    for (var d = a + 1; d < this.times.length; d++) {
      if (this.times[a] > this.times[d]) {
        var g = this.times[d];
        this.times[d] = this.times[a];
        this.times[a] = g;
        for (var h = this.getValueSize(), e = d * h, k = a * h, c = 0; c < h; c++) {
          g = this.values[e + c], this.values[e + c] = this.values[k + c], this.values[k + c] = g;
        }
      }
    }
  }
};
THREE.KeyframeTrack._toJSON = THREE.KeyframeTrack.toJSON;
THREE.KeyframeTrack.toJSON = function(a) {
  var d = THREE.KeyframeTrack._toJSON.call(this, a);
  d.color = a.color;
  return d;
};
THREE.KeyframeTrack._parse = THREE.KeyframeTrack.parse;
THREE.KeyframeTrack.parse = function(a) {
  var d = THREE.KeyframeTrack._parse.call(this, a);
  void 0 !== a.color && (d.color = a.color);
  return d;
};
"use strict";
THREE.AnimationClip.prototype.enabled = !0;
THREE.AnimationClip.prototype.loop = THREE.LoopRepeat;
THREE.AnimationClip.prototype.timeScale = 1;
THREE.AnimationClip.prototype.weight = 1;
THREE.AnimationClip._toJSON = THREE.AnimationClip.toJSON;
THREE.AnimationClip.toJSON = function(a) {
  var d = THREE.AnimationClip._toJSON.call(this, a);
  d.enabled = a.enabled;
  d.loop = a.loop;
  d.timeScale = a.timeScale;
  d.weight = a.weight;
  return d;
};
THREE.AnimationClip._parse = THREE.AnimationClip.parse;
THREE.AnimationClip.parse = function(a) {
  var d = THREE.AnimationClip._parse.call(this, a);
  void 0 !== a.enabled && (d.enabled = a.enabled, d.loop = a.loop, d.timeScale = a.timeScale, d.weight = a.weight);
  return d;
};
"use strict";
THREE.Object3D.prototype.folded = !1;
THREE.Object3D.prototype.locked = !1;
THREE.Object3D.prototype.contains = function(a) {
  for (var d = 0; d < this.children.length; d++) {
    if (this.children[d].uuid === a.uuid || this.children[d].contains(a)) {
      return !0;
    }
  }
  return !1;
};
THREE.Object3D.prototype.playAnimation = function() {
  void 0 !== this.mixer && this.mixer.play();
};
THREE.Object3D.prototype.stopAnimation = function() {
  void 0 !== this.mixer && this.mixer.stop();
};
THREE.Object3D.prototype.initialize = function() {
  void 0 !== this.animations && (this.mixer = new AnimationMixer(this), this.mixer.createActions(this.animations), this.mixer.play());
};
THREE.Object3D.prototype.update = function(a) {
  void 0 !== this.mixer && this.mixer.update(a);
};
THREE.Object3D.prototype.resize = function(a, d) {
};
THREE.Object3D.prototype.dispose = function() {
  void 0 !== this.mixer && this.mixer.dispose();
};
THREE.Object3D.prototype.addAbove = function(a, d) {
  if (a === this) {
    return console.error("Object3D.add: object can't be added as a child of itself.", a), this;
  }
  a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({type:"added"}), d = this.children.indexOf(d), this.children.splice(d, 0, a)) : console.error("Object3D.add: object not an instance of THREE.Object3D.", a);
  return this;
};
THREE.Object3D.prototype.addBellow = function(a, d) {
  if (a === this) {
    return console.error("Object3D.add: object can't be added as a child of itself.", a), this;
  }
  a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({type:"added"}), d = this.children.indexOf(d) + 1, this.children.splice(d, 0, a)) : console.error("Object3D.add: object not an instance of THREE.Object3D.", a);
  return this;
};
THREE.Object3D.prototype.getScene = function() {
  for (var a = this; null !== a.parent;) {
    if (a = a.parent, a instanceof Scene) {
      return a;
    }
  }
  return null;
};
THREE.Object3D.prototype.removeAll = function() {
  for (; 0 < this.children.length;) {
    this.remove(this.children[0]);
  }
};
THREE.Object3D.prototype.isEmpty = function() {
  return 0 === this.children.length;
};
THREE.Object3D.prototype.destroy = function() {
  for (; 0 < this.children.length;) {
    this.children[0].destroy();
  }
  null !== this.parent && (this.dispose && this.dispose(), this.parent.remove(this), this.parent = null);
};
THREE.Object3D.prototype.toJSON = function(a, d, g) {
  function h(b, c) {
    void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a));
    return c.uuid;
  }
  function e(a) {
    var b = [], c;
    for (c in a) {
      var d = a[c];
      delete d.metadata;
      b.push(d);
    }
    return b;
  }
  var k = void 0 === a, c = {};
  k && (a = new ResourceContainer, c.metadata = {version:Nunu.VERSION, type:"Object3D"});
  var p = {};
  p.uuid = this.uuid;
  p.type = this.type;
  p.name = this.name;
  p.folded = this.folded;
  p.locked = this.locked;
  p.castShadow = this.castShadow;
  p.receiveShadow = this.receiveShadow;
  p.visible = this.visible;
  p.matrixAutoUpdate = this.matrixAutoUpdate;
  p.frustumCulled = this.frustumCulled;
  p.renderOrder = this.renderOrder;
  p.position = this.position.toArray();
  p.quaternion = this.quaternion.toArray();
  p.scale = this.scale.toArray();
  p.layers = this.layers.mask;
  p.userData = this.userData;
  if (void 0 !== this.geometry) {
    p.geometry = h(a.geometries, this.geometry);
    var t = this.geometry.parameters;
    if (void 0 !== t && void 0 !== t.shapes) {
      var f = t.shapes;
      if (Array.isArray(f)) {
        t = 0;
        for (var n = f.length; t < n; t++) {
          h(a.shapes, f[t]);
        }
      } else {
        h(a.shapes, f);
      }
    }
  }
  if (void 0 !== this.material) {
    if (this.material instanceof THREE.Material) {
      p.material = h(a.materials, this.material);
    } else {
      if (this.material instanceof Array) {
        f = [];
        for (t = 0; t < this.material.length; t++) {
          f.push(h(a.materials, this.material[t]));
        }
        p.material = f;
      }
    }
  }
  if (void 0 !== this.animations && 0 < this.animations.length) {
    for (p.animations = [], t = 0; t < this.animations.length; t++) {
      p.animations.push(THREE.AnimationClip.toJSON(this.animations[t]));
    }
  }
  c.object = p;
  void 0 !== d && d(a, p, c);
  if (!1 !== g && 0 < this.children.length) {
    for (p.children = [], t = 0; t < this.children.length; t++) {
      this.children[t].locked || p.children.push(this.children[t].toJSON(a).object);
    }
  }
  k && (c.geometries = e(a.geometries), c.materials = e(a.materials), c.textures = e(a.textures), c.images = e(a.images), c.videos = e(a.videos), c.audio = e(a.audio), c.fonts = e(a.fonts), c.skeletons = e(a.skeletons), c.resources = e(a.resources), c.shapes = e(a.shapes));
  return c;
};
"use strict";
THREE.BufferAttribute.prototype.toJSON = function() {
  return {type:"BufferAttribute", typedArray:{type:this.array.constructor.name, array:Array.prototype.slice.call(this.array)}, itemSize:this.itemSize, normalized:this.normalized};
};
"use strict";
THREE.InterleavedBufferAttribute.prototype.toJSON = function() {
  return {type:"InterleavedBufferAttribute", data:this.data.toJSON(), itemSize:this.itemSize, offset:this.offset, normalized:this.normalized};
};
"use strict";
THREE.InterleavedBuffer.prototype.toJSON = function() {
  return {typedArray:{type:this.array.constructor.name, array:Array.prototype.slice.call(this.array)}, stride:this.stride, count:this.count, usage:this.usage};
};
"use strict";
THREE.InstancedBufferAttribute.prototype.toJSON = function() {
  var a = THREE.BufferAttribute.prototype.toJSON.call(this);
  a.type = "InstancedBufferAttribute";
  a.meshPerAttribute = this.meshPerAttribute;
  return a;
};
var TYPED_ARRAYS = {Int8Array:Int8Array, Uint8Array:Uint8Array, Uint8ClampedArray:Uint8ClampedArray, Int16Array:Int16Array, Uint16Array:Uint16Array, Int32Array:Int32Array, Uint32Array:Uint32Array, Float32Array:Float32Array, Float64Array:Float64Array}, parseBufferAttribute = function(a) {
  if (void 0 !== a.array) {
    var d = new TYPED_ARRAYS[a.type](a.array);
    d = new (a.isInstancedBufferAttribute ? THREE.InstancedBufferAttribute : THREE.BufferAttribute)(d, a.itemSize, a.normalized);
    void 0 !== a.name && (d.name = a.name);
    return d;
  }
  "BufferAttribute" === a.type ? (d = new TYPED_ARRAYS[a.typedArray.type](a.typedArray.array), d = new THREE.BufferAttribute(d, a.itemSize, a.normalized)) : "InstancedBufferAttribute" === a.type ? (d = new TYPED_ARRAYS[a.typedArray.type](a.typedArray.array), d = new THREE.InstancedBufferAttribute(d, a.itemSize, a.normalized, a.meshPerAttribute)) : "InterleavedBufferAttribute" === a.type && (d = new TYPED_ARRAYS[a.data.typedArray.type](a.data.typedArray.array), d = new THREE.InterleavedBuffer(d, a.data.stride), 
  d.setUsage(a.data.usage), d.count = a.data.count, d = new THREE.InterleavedBufferAttribute(d, a.itemSize, a.offset, a.normalized));
  void 0 !== a.name && (d.name = a.name);
  return d;
};
THREE.BufferGeometryLoader.prototype.parse = function(a) {
  var d = a.isInstancedBufferGeometry ? new InstancedBufferGeometry : new BufferGeometry, g = a.data.index;
  void 0 !== g && (g = new TYPED_ARRAYS[g.type](g.array), d.setIndex(new THREE.BufferAttribute(g, 1)));
  g = a.data.attributes;
  for (var h in g) {
    d.setAttribute(h, parseBufferAttribute(g[h]));
  }
  var e = a.data.morphAttributes;
  if (e) {
    for (h in e) {
      var k = e[h], c = [];
      g = 0;
      for (var p = k.length; g < p; g++) {
        c.push(parseBufferAttribute(k[g]));
      }
      d.morphAttributes[h] = c;
    }
  }
  a.data.morphTargetsRelative && (d.morphTargetsRelative = !0);
  h = a.data.groups || a.data.drawcalls || a.data.offsets;
  if (void 0 !== h) {
    for (g = 0, e = h.length; g !== e; ++g) {
      k = h[g], d.addGroup(k.start, k.count, k.materialIndex);
    }
  }
  h = a.data.boundingSphere;
  void 0 !== h && (g = new THREE.Vector3, void 0 !== h.center && g.fromArray(h.center), d.boundingSphere = new THREE.Sphere(g, h.radius));
  a.name && (d.name = a.name);
  a.userData && (d.userData = a.userData);
  return d;
};
"use strict";
THREE.Camera.prototype.render = function(a, d) {
  a.render(d, this);
};
"use strict";
THREE.Material.prototype.dispose = function() {
  function a(a) {
    void 0 !== a && null !== a && a.dispose();
  }
  this.dispatchEvent({type:"dispose"});
  a(this.map);
  a(this.bumpMap);
  a(this.normalMap);
  a(this.displacementMap);
  a(this.specularMap);
  a(this.emissiveMap);
  a(this.alphaMap);
  a(this.roughnessMap);
  a(this.metalnessMap);
  a(this.envMap);
};
THREE.Material.prototype.toJSON = function(a) {
  function d(a) {
    var c = [], d;
    for (d in a) {
      var e = a[d];
      delete e.metadata;
      c.push(e);
    }
    return c;
  }
  void 0 === a && (a = {textures:{}, images:{}, videos:{}});
  var g = {};
  g.uuid = this.uuid;
  g.type = this.type;
  g.name = this.name;
  g.toneMapped = this.toneMapped;
  g.depthFunc = this.depthFunc;
  g.depthTest = this.depthTest;
  g.depthWrite = this.depthWrite;
  this.color && this.color.isColor && (g.color = this.color.getHex());
  void 0 !== this.roughness && (g.roughness = this.roughness);
  void 0 !== this.metalness && (g.metalness = this.metalness);
  this.specular && this.specular.isColor && (g.specular = this.specular.getHex());
  void 0 !== this.shininess && (g.shininess = this.shininess);
  void 0 !== this.clearcoat && (g.clearcoat = this.clearcoat);
  void 0 !== this.clearcoatRoughness && (g.clearcoatRoughness = this.clearcoatRoughness);
  void 0 !== this.transparency && (g.transparency = this.transparency);
  this.map && this.map.isTexture && (g.map = this.map.toJSON(a).uuid);
  this.alphaMap && this.alphaMap.isTexture && (g.alphaMap = this.alphaMap.toJSON(a).uuid);
  this.lightMap && this.lightMap.isTexture && (g.lightMap = this.lightMap.toJSON(a).uuid);
  this.bumpMap && this.bumpMap.isTexture && (g.bumpMap = this.bumpMap.toJSON(a).uuid, g.bumpScale = this.bumpScale);
  this.normalMap && this.normalMap.isTexture && (g.normalMap = this.normalMap.toJSON(a).uuid, g.normalMapType = this.normalMapType, g.normalScale = this.normalScale.toArray());
  this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (g.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(a).uuid, g.clearcoatNormalScale = this.clearcoatNormalScale.toArray());
  this.displacementMap && this.displacementMap.isTexture && (g.displacementMap = this.displacementMap.toJSON(a).uuid, g.displacementScale = this.displacementScale, g.displacementBias = this.displacementBias);
  this.roughnessMap && this.roughnessMap.isTexture && (g.roughnessMap = this.roughnessMap.toJSON(a).uuid);
  this.metalnessMap && this.metalnessMap.isTexture && (g.metalnessMap = this.metalnessMap.toJSON(a).uuid);
  this.emissive && this.emissive.isColor && (g.emissive = this.emissive.getHex());
  1 !== this.emissiveIntensity && (g.emissiveIntensity = this.emissiveIntensity);
  this.matcap && this.matcap.isTexture && (g.matcap = this.matcap.toJSON(a).uuid);
  this.emissiveMap && this.emissiveMap.isTexture && (g.emissiveMap = this.emissiveMap.toJSON(a).uuid);
  this.aoMap && this.aoMap.isTexture && (g.aoMap = this.aoMap.toJSON(a).uuid);
  this.aoMapIntensity && (g.aoMapIntensity = this.aoMapIntensity);
  this.specularMap && this.specularMap.isTexture && (g.specularMap = this.specularMap.toJSON(a).uuid);
  this.envMap && this.envMap.isTexture && (g.envMap = this.envMap.toJSON(a).uuid, g.reflectivity = this.reflectivity, this.combine && (g.combine = this.combine), this.envMapIntensity && (g.envMapIntensity = this.envMapIntensity), this.refractionRatio && (g.refractionRatio = this.refractionRatio));
  this.gradientMap && this.gradientMap.isTexture && (g.gradientMap = this.gradientMap.toJSON(a).uuid);
  void 0 !== this.size && (g.size = this.size);
  void 0 !== this.sizeAttenuation && (g.sizeAttenuation = this.sizeAttenuation);
  void 0 !== this.rotation && (g.rotation = this.rotation);
  void 0 !== this.linewidth && (g.linewidth = this.linewidth);
  void 0 !== this.dashSize && (g.dashSize = this.dashSize);
  void 0 !== this.gapSize && (g.gapSize = this.gapSize);
  void 0 !== this.scale && (g.scale = this.scale);
  this.blending !== THREE.NormalBlending && (g.blending = this.blending);
  this.side !== THREE.FrontSide && (g.side = this.side);
  this.vertexColors !== THREE.NoColors && (g.vertexColors = this.vertexColors);
  g.flatShading = this.flatShading;
  1 > this.opacity && (g.opacity = this.opacity);
  !0 === this.transparent && (g.transparent = this.transparent);
  !0 === this.dithering && (g.dithering = !0);
  0 < this.alphaTest && (g.alphaTest = this.alphaTest);
  !0 === this.premultipliedAlpha && (g.premultipliedAlpha = this.premultipliedAlpha);
  !0 === this.wireframe && (g.wireframe = this.wireframe);
  1 < this.wireframeLinewidth && (g.wireframeLinewidth = this.wireframeLinewidth);
  "round" !== this.wireframeLinecap && (g.wireframeLinecap = this.wireframeLinecap);
  "round" !== this.wireframeLinejoin && (g.wireframeLinejoin = this.wireframeLinejoin);
  g.skinning = this.skinning;
  g.morphTargets = this.morphTargets;
  void 0 !== this.morphNormals && (g.morphNormals = this.morphNormals);
  if (void 0 === a) {
    var h = d(a.textures), e = d(a.images);
    a = d(a.videos);
    0 < h.length && (g.textures = h);
    0 < e.length && (g.images = e);
    0 < a.length && (g.videos = a);
  }
  return g;
};
"use strict";
THREE.Texture.prototype.toJSON = function(a) {
  if (void 0 !== a.textures[this.uuid]) {
    return a.textures[this.uuid];
  }
  var d = {metadata:{version:Nunu.VERSION, type:"Texture"}, uuid:this.uuid, name:this.name, category:this.category, mapping:this.mapping, repeat:[this.repeat.x, this.repeat.y], offset:[this.offset.x, this.offset.y], center:[this.center.x, this.center.y], rotation:this.rotation, wrap:[this.wrapS, this.wrapT], format:this.format, type:this.type, encoding:this.encoding, minFilter:this.minFilter, magFilter:this.magFilter, anisotropy:this.anisotropy, flipY:this.flipY, premultiplyAlpha:this.premultiplyAlpha, 
  unpackAlignment:this.unpackAlignment};
  return a.textures[this.uuid] = d;
};
"use strict";
THREE.LightShadow.prototype.toJSON = function() {
  var a = {};
  a.bias = this.bias;
  a.radius = this.radius;
  a.mapSize = {x:this.mapSize.x, y:this.mapSize.y};
  a.camera = {top:this.camera.top, bottom:this.camera.bottom, far:this.camera.far, near:this.camera.near, left:this.camera.left, right:this.camera.right};
  return a;
};
THREE.LightShadow.prototype.fromJSON = function(a) {
  void 0 !== a.bias && (this.bias = a.bias);
  void 0 !== a.radius && (this.radius = a.radius);
  if (void 0 !== a.mapSize) {
    var d = a.mapSize;
    this.mapSize.set(d.x, d.y);
  }
  void 0 !== a.camera && (a = a.camera, this.camera.top = a.top, this.camera.bottom = a.bottom, this.camera.left = a.left, this.camera.right = a.right, this.camera.near = a.near, this.camera.far = a.far);
};
"use strict";
THREE.Fog.NONE = 0;
THREE.Fog.LINEAR = 1;
THREE.Fog.EXPONENTIAL = 2;
"use strict";
THREE.Points.prototype.raycast = function(a, d) {
  null === this.geometry.boundingBox && this.geometry.computeBoundingBox();
  var g = new THREE.Box3;
  g.copy(this.geometry.boundingBox);
  g.applyMatrix4(this.matrixWorld);
  null !== a.ray.intersectBox(g, new THREE.Vector3) && d.push({object:this});
};
"use strict";
THREE.Skeleton.prototype.toJSON = function(a) {
  a = {};
  void 0 === this.uuid && (this.uuid = THREE.Math.generateUUID());
  a.uuid = this.uuid;
  a.bones = [];
  for (var d = 0; d < this.bones.length; d++) {
    a.bones.push(this.bones[d].uuid);
  }
  a.boneInverses = [];
  for (d = 0; d < this.boneInverses.length; d++) {
    a.boneInverses.push(this.boneInverses[d].toArray());
  }
  return a;
};
THREE.Skeleton.fromJSON = function(a, d, g) {
  g = [];
  for (var h = [], e = 0; e < a.bones.length; e++) {
    var k = d.getObjectByProperty("uuid", a.bones[e]);
    void 0 === k && (console.warn("Skeleton.fromJSON: Not found Bone with uuid " + a.bones[e]), k = new THREE.Bone);
    g.push(k);
    h.push((new THREE.Matrix4).fromArray(a.boneInverses[e]));
  }
  d = new THREE.Skeleton(g, h);
  d.uuid = a.uuid;
  return d;
};
"use strict";
function Nunu() {
}
Nunu.NAME = "nunuStudio";
Nunu.VERSION = "<PLACEHOLDER_VERSION>";
Nunu.TIMESTAMP = "<PLACEHOLDER_TIMESTAMP>";
Nunu.REPOSITORY_BRANCH = "<PLACEHOLDER_REPOSITORY_BRANCH>";
Nunu.REPOSITORY_COMMIT = "<PLACEHOLDER_REPOSITORY_COMMIT>";
Nunu.NWJS = 200;
Nunu.BROWSER = 201;
Nunu.CORDOVA = 202;
Nunu.importFrom = function(a, d) {
  void 0 === d && (d = window);
  for (var g in a) {
    g in d || (d[g] = a[g]);
  }
};
Nunu.importFrom(THREE);
Nunu.importFrom(CANNON);
Nunu.developmentMode = function() {
  return "<PLACEHOLDER_TIMESTAMP>" === Nunu.TIMESTAMP;
};
Nunu.vrAvailable = function() {
  return Nunu.webVRAvailable() || Nunu.webXRAvailable();
};
Nunu.enterVR = function(a, d) {
  Nunu.webXRAvailable() ? Nunu.getXRSession(function(g) {
    a.xr.enabled = !0;
    a.xr.setSession(g);
    void 0 !== d && d();
  }) : Nunu.webVRAvailable() ? Nunu.getVRDisplay(function(g) {
    g.isPresenting || (a.xr.enabled = !0, a.xr.setDevice(g), g.requestPresent([{source:a.domElement}]), void 0 !== d && d());
  }) : console.warn("nunuStudio: VR support is not available.");
};
Nunu.exitVR = function(a) {
  Nunu.webXRAvailable() ? Nunu.getXRSession(function(d) {
    a.xr.enabled = !1;
    a.xr.setSession(null);
  }) : Nunu.webVRAvailable() && Nunu.getVRDisplay(function(d) {
    d.isPresenting && (a.xr.enabled = !1, a.xr.setDevice(null), device.exitPresent());
  });
};
Nunu.webXRSession = null;
Nunu.webXRSupported = null;
void 0 !== navigator.xr && void 0 !== navigator.xr.isSessionSupported && navigator.xr.isSessionSupported("immersive-vr").then(function(a) {
  Nunu.webXRSupported = a;
});
Nunu.webXRAvailable = function() {
  return void 0 !== navigator.xr && void 0 !== navigator.xr.isSessionSupported && !1 !== Nunu.webXRSupported;
};
Nunu.getXRSession = function(a) {
  Nunu.webXRAvailable() ? null !== Nunu.webXRSession ? a(Nunu.webXRSession) : navigator.xr.requestSession("immersive-vr", {optionalFeatures:["local-floor", "bounded-floor"]}).then(function(d) {
    Nunu.webXRSession = d;
    a(d);
  }) : console.warn("nunuStudio: WebXR support is not available.");
};
Nunu.webVRDisplay = null;
Nunu.webVRHasDisplay = null;
void 0 !== navigator.getVRDisplays && navigator.getVRDisplays().then(function(a) {
  Nunu.webVRHasDisplay = 0 < a.length;
});
Nunu.webVRAvailable = function() {
  return void 0 !== navigator.getVRDisplays && !1 !== Nunu.webVRHasDisplay;
};
Nunu.getVRDisplay = function(a) {
  Nunu.webVRAvailable() ? null !== Nunu.webVRDisplay ? a(Nunu.webVRDisplay) : navigator.getVRDisplays().then(function(d) {
    0 < d.length ? (Nunu.webVRDisplay = d[0], a(d[0])) : console.warn("nunuStudio: WebVR supported but no display is available.");
  }) : console.warn("nunuStudio: WebVR support is not available.");
};
Nunu.getQueryParameters = function() {
  for (var a = location.search.substring(1).split("&"), d = {}, g = 0; g < a.length; g++) {
    var h = a[g].split("=");
    if (1 < h.length) {
      var e = unescape(h[0]).replace(/"/g, "");
      h = unescape(h[1]).replace(/"/g, "");
      d[e] = h;
    }
  }
  return d;
};
Nunu.createWorker = function(a, d) {
  a = new Blob([a], {type:"application/javascript"});
  a = new Worker(URL.createObjectURL(a));
  void 0 !== d && (a.onmessage = d);
  return a;
};
Nunu.webAudioAvailable = function() {
  return void 0 !== window.AudioContext || void 0 !== window.webkitAudioContext;
};
Nunu.webGLAvailable = function() {
  try {
    var a = document.createElement("canvas");
    (a.getContext("webgl") || a.getContext("experimental-webgl")).getSupportedExtensions();
    return !0;
  } catch (d) {
  }
  return !1;
};
Nunu.getPlatform = function() {
  return void 0 !== window.nw ? Nunu.NWJS : void 0 !== window.cordova ? Nunu.CORDOVA : Nunu.BROWSER;
};
Nunu.runningOnDesktop = function() {
  return void 0 !== window.nw;
};
Nunu.openWebpage = function(a) {
  Nunu.runningOnDesktop() ? require("nw.gui").Shell.openExternal(a) : window.open(a);
};
Nunu.isFullscreen = function() {
  return !0 === document.webkitIsFullScreen || !0 === document.mozFullScreen || !0 === document.webkitIsFullScreen || !0 === document.webkitIsFullScreen || !0 === document.fullscreen || !1;
};
Nunu.setFullscreen = function(a, d) {
  var g = Nunu.isFullscreen();
  void 0 === a && (a = !g);
  !0 === a ? (void 0 === d && (d = document.body), !1 === g && (d.requestFullscreen = d.requestFullscreen || d.mozRequestFullScreen || d.webkitRequestFullscreen || d.msRequestFullscreen, void 0 !== d.requestFullscreen && d.requestFullscreen())) : !0 === g && (document.exitFullscreen = document.exitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen, void 0 !== document.exitFullscreen && document.exitFullscreen());
};
"use strict";
function FileSystem() {
}
try {
  FileSystem.fs = require("fs");
} catch (a) {
}
FileSystem.isLocalFile = function(a) {
  return !(a.startsWith("http") || a.startsWith("blob") || a.startsWith("data"));
};
FileSystem.readFile = function(a, d, g, h, e) {
  void 0 === d && (d = !0);
  if (void 0 !== FileSystem.fs && FileSystem.isLocalFile(a)) {
    if (!0 === d) {
      return a = FileSystem.fs.readFileSync(a, "utf8"), void 0 !== g && g(a), a;
    }
    FileSystem.fs.readFile(a, "utf8", function(a, d) {
      null !== a ? void 0 !== e && e(a) : void 0 !== g && g(d);
    });
    return null;
  }
  var k = new XMLHttpRequest;
  k.overrideMimeType("text/plain");
  k.open("GET", a, !d);
  void 0 !== g && (k.onload = function() {
    g(k.response);
  });
  void 0 !== h && (k.onprogress = h);
  void 0 !== e && (k.onerror = e);
  k.send(null);
  return !0 === d ? k.response : null;
};
FileSystem.readFileArrayBuffer = function(a, d, g, h, e) {
  void 0 === d && (d = !0);
  if (void 0 !== FileSystem.fs && FileSystem.isLocalFile(a)) {
    if (!0 === d) {
      return a = FileSystem.fs.readFileSync(a), ArraybufferUtils.fromBuffer(a);
    }
    FileSystem.fs.readFile(a, function(a, d) {
      null !== a ? void 0 !== e && e(a) : void 0 !== g && g(ArraybufferUtils.fromBuffer(d));
    });
    return null;
  }
  var k = new XMLHttpRequest;
  k.open("GET", a, !d);
  k.overrideMimeType("text/plain; charset=x-user-defined");
  void 0 !== g && (k.onload = function() {
    g(ArraybufferUtils.fromBinaryString(k.response));
  });
  void 0 !== h && (k.onprogress = h);
  void 0 !== e && (k.onerror = e);
  k.send(null);
  return !0 === d ? ArraybufferUtils.fromBinaryString(k.response) : null;
};
FileSystem.readFileBase64 = function(a, d, g, h, e) {
  void 0 === d && (d = !0);
  if (void 0 !== FileSystem.fs && FileSystem.isLocalFile(a)) {
    if (!0 === d) {
      return a = FileSystem.fs.readFileSync(a), (new Buffer(a)).toString("base64");
    }
    FileSystem.fs.readFile(a, function(a, d) {
      null !== a ? void 0 !== e && e(a) : void 0 !== g && g((new Buffer(d)).toString("base64"));
    });
    return null;
  }
  var k = new XMLHttpRequest;
  k.open("GET", a, !d);
  k.overrideMimeType("text/plain; charset=x-user-defined");
  void 0 !== g && (k.onload = function() {
    g(Base64Utils.fromBinaryString(k.response));
  });
  void 0 !== h && (k.onprogress = h);
  void 0 !== e && (k.onerror = e);
  k.send(null);
  return !0 === d ? Base64Utils.fromBinaryString(k.response) : null;
};
FileSystem.writeFile = function(a, d, g, h) {
  void 0 !== FileSystem.fs ? void 0 !== FileSystem.fs.writeFileSync ? !1 !== g ? (FileSystem.fs.writeFileSync(a, d, "utf8"), void 0 !== h && h()) : FileSystem.fs.writeFile(a, d, "utf8", h) : (a = FileSystem.fs.createWriteStream(a, "utf8"), a.write(d), a.end()) : (d = new Blob([d], {type:"octet/stream"}), g = document.createElement("a"), g.download = a, g.href = window.URL.createObjectURL(d), g.style.display = "none", g.onclick = function() {
    document.body.removeChild(this);
  }, document.body.appendChild(g), g.click(), void 0 !== h && h());
};
FileSystem.writeFileBase64 = function(a, d, g, h) {
  void 0 !== FileSystem.fs ? (d = Buffer.from(Base64Utils.removeHeader(d), "base64"), void 0 !== FileSystem.fs.writeFile ? !1 !== g ? (FileSystem.fs.writeFileSync(a, d), void 0 !== h && h()) : FileSystem.fs.writeFile(a, d, h) : (a = FileSystem.fs.createWriteStream(a), a.write(d), a.end())) : (g = ArraybufferUtils.fromBase64(Base64Utils.removeHeader(d)), g = new Blob([g]), d = document.createElement("a"), d.download = a, d.href = window.URL.createObjectURL(g), d.onclick = function() {
    document.body.removeChild(this);
  }, d.style.display = "none", document.body.appendChild(d), d.click(), void 0 !== h && h());
};
FileSystem.writeFileArrayBuffer = function(a, d, g, h) {
  void 0 !== FileSystem.fs ? (d = BufferUtils.fromArrayBuffer(d), void 0 !== FileSystem.fs.writeFileSync ? !1 !== g ? (FileSystem.fs.writeFileSync(a, d), void 0 !== h && h()) : FileSystem.fs.writeFile(a, d, h) : (a = FileSystem.fs.createWriteStream(a), a.write(d), a.end())) : (g = new Blob([d]), d = document.createElement("a"), d.download = a, d.href = window.URL.createObjectURL(g), d.onclick = function() {
    document.body.removeChild(this);
  }, d.style.display = "none", document.body.appendChild(d), d.click(), void 0 !== h && h());
};
FileSystem.chooseFile = function(a, d, g, h) {
  var e = document.createElement("input");
  e.type = "file";
  e.style.display = "none";
  document.body.appendChild(e);
  void 0 !== d && (e.accept = d);
  !0 === h && (e.multiple = !0);
  e.onchange = function(d) {
    void 0 !== a && a(e.files);
    document.body.removeChild(e);
  };
  void 0 !== g && (e.nwsaveas = !0 !== g ? g : "file");
  e.click();
};
FileSystem.chooseFileName = function(a, d, g) {
  g = prompt("Save As", void 0 !== g ? g : "file");
  null !== g && (void 0 === d || g.endsWith(d) || (g += d), void 0 !== a && a(g));
};
FileSystem.copyFile = function(a, d) {
  void 0 !== FileSystem.fs && (void 0 !== FileSystem.fs.copyFileSync ? FileSystem.fs.copyFileSync(a, d) : (a.replace(/\//g, "\\"), d.replace(/\//g, "\\"), FileSystem.fs.createReadStream(a).pipe(FileSystem.fs.createWriteStream(d))));
};
FileSystem.makeDirectory = function(a) {
  void 0 !== FileSystem.fs && (a.replace(/\//g, "\\"), FileSystem.fs.mkdirSync(a, {recursive:!0}));
};
FileSystem.getFilesDirectory = function(a) {
  if (void 0 !== FileSystem.fs) {
    try {
      return a.replace(/\//g, "\\"), FileSystem.fs.readdirSync(a);
    } catch (d) {
    }
  }
  return [];
};
FileSystem.deleteFolder = function(a) {
  void 0 !== FileSystem.fs && FileSystem.fs.existsSync(a) && (FileSystem.fs.readdirSync(a).forEach(function(d, g) {
    d = a + "/" + d;
    FileSystem.fs.lstatSync(d).isDirectory() ? FileSystem.deleteFolder(d) : FileSystem.fs.unlinkSync(d);
  }), FileSystem.fs.rmdirSync(a));
};
FileSystem.copyFolder = function(a, d) {
  if (void 0 !== FileSystem.fs) {
    a.replace(/\//g, "\\");
    d.replace(/\//g, "\\");
    FileSystem.makeDirectory(d);
    for (var g = FileSystem.fs.readdirSync(a), h = 0; h < g.length; h++) {
      var e = a + "\\" + g[h], k = d + "\\" + g[h], c = FileSystem.fs.statSync(e);
      c.isDirectory() ? FileSystem.copyFolder(e, k) : c.isSymbolicLink() ? FileSystem.fs.symlinkSync(FileSystem.fs.readlinkSync(e), k) : FileSystem.copyFile(e, k);
    }
  }
};
FileSystem.fileExists = function(a) {
  return void 0 !== FileSystem.fs ? (a.replace(/\//g, "\\"), FileSystem.fs.existsSync(a)) : !1;
};
FileSystem.getFileName = function(a) {
  if (void 0 !== a) {
    var d = a.lastIndexOf("\\"), g = a.lastIndexOf("/");
    return a.substring(d > g ? d + 1 : g + 1, a.lastIndexOf("."));
  }
  return "";
};
FileSystem.getFileNameWithExtension = function(a) {
  if (void 0 !== a) {
    var d = a.lastIndexOf("\\"), g = a.lastIndexOf("/");
    return a.substring(d > g ? d + 1 : g + 1, a.length);
  }
  return "";
};
FileSystem.getNameWithoutExtension = function(a) {
  return void 0 !== a ? a.substring(0, a.lastIndexOf(".")) : "";
};
FileSystem.getFilePath = function(a) {
  if (void 0 !== a) {
    var d = a.lastIndexOf("\\"), g = a.lastIndexOf("/");
    return a.substring(0, d > g ? d + 1 : g + 1);
  }
  return "";
};
FileSystem.getFileExtension = function(a) {
  return void 0 !== a ? a.substring(a.lastIndexOf(".") + 1, a.length).toLowerCase() : "";
};
"use strict";
function TargetConfig() {
  this.desktop = {fullscreen:!1, frame:!0, resizable:!0};
}
"use strict";
function AnimationMixer(a) {
  THREE.AnimationMixer.call(this, a);
  this.playing = !1;
}
AnimationMixer.prototype = Object.create(THREE.AnimationMixer.prototype);
AnimationMixer.prototype.createActions = function(a) {
  for (var d = 0; d < a.length; d++) {
    var g = this.clipAction(a[d]);
    g.setLoop(a[d].loop);
    g.weight = a[d].weight;
    g.timeScale = a[d].timeScale;
    g.enabled = a[d].enabled;
    g.play();
  }
  return this._actions;
};
AnimationMixer.prototype.setTime = function(a) {
  this.time = a;
  for (var d = 0; d < this._actions.length; d++) {
    this._actions[d].time = a;
  }
  this.update(0, !0);
};
AnimationMixer.prototype.play = function() {
  this.playing = !0;
};
AnimationMixer.prototype.stop = function() {
  this.setTime(0);
  this.playing = !1;
};
AnimationMixer.prototype.pause = function() {
  this.playing = !1;
};
AnimationMixer.prototype.dispose = function() {
  this.stopAllAction();
  this.uncacheRoot(this._root);
};
AnimationMixer.prototype.update = function(a, d) {
  if (this.playing || d) {
    this.time += a;
    d = Math.sign(a);
    for (var g = 0; g < this._actions.length; g++) {
      this._actions[g]._update(this.time, a, d, this._accuIndex);
    }
    for (g = 0; g < this._bindings.length; g++) {
      this._bindings[g].apply(this._accuIndex);
    }
  }
  return this;
};
"use strict";
function Key() {
  this.justReleased = this.justPressed = this.pressed = !1;
}
Key.DOWN = -1;
Key.UP = 1;
Key.RESET = 0;
Key.prototype.constructor = Key;
Key.prototype.update = function(a) {
  this.justReleased = this.justPressed = !1;
  a === Key.DOWN ? (!1 === this.pressed && (this.justPressed = !0), this.pressed = !0) : a === Key.UP ? (this.pressed && (this.justReleased = !0), this.pressed = !1) : a === Key.RESET && (this.justPressed = this.justReleased = !1);
};
Key.prototype.set = function(a, d, g) {
  this.justPressed = a;
  this.pressed = d;
  this.justReleased = g;
};
Key.prototype.reset = function() {
  this.justReleased = this.pressed = this.justPressed = !1;
};
"use strict";
function Keyboard(a) {
  this.keys = [];
  this.actions = [];
  var d = this, g = this.actions;
  this.events = new EventManager;
  this.events.add(window, "keydown", function(a) {
    g.push(a.keyCode);
    g.push(Key.DOWN);
  });
  this.events.add(window, "keyup", function(a) {
    g.push(a.keyCode);
    g.push(Key.UP);
  });
  this.events.add(window, "focus", function(a) {
    d.reset();
  });
  !0 !== a && this.create();
}
Keyboard.prototype = Keyboard;
Keyboard.prototype.constructor = Keyboard;
Keyboard.update = function() {
  for (var a = 0; this.actions.length > a;) {
    var d = this.actions.shift(), g = this.actions.shift();
    void 0 === this.keys[d] && (this.keys[d] = new Key);
    this.keys[d].update(g);
    if (this.keys[d].justReleased || this.keys[d].justPressed) {
      this.actions.push(d), this.actions.push(Key.RESET), a += 2;
    }
  }
};
Keyboard.reset = function() {
  for (var a = 0; a < this.keys.length; a++) {
    void 0 !== this.keys[a] && this.keys[a].reset();
  }
};
Keyboard.keyPressed = function(a) {
  return void 0 !== this.keys[a] && this.keys[a].pressed;
};
Keyboard.keyJustPressed = function(a) {
  return void 0 !== this.keys[a] && this.keys[a].justPressed;
};
Keyboard.keyJustReleased = function(a) {
  return void 0 !== this.keys[a] && this.keys[a].justReleased;
};
Keyboard.create = function() {
  this.events.create();
};
Keyboard.dispose = function() {
  this.events.destroy();
};
Keyboard.TAB = 9;
Keyboard.ENTER = 13;
Keyboard.SHIFT = 16;
Keyboard.CTRL = 17;
Keyboard.ALT = 18;
Keyboard.CAPS_LOCK = 20;
Keyboard.ESC = 27;
Keyboard.SPACEBAR = 32;
Keyboard.PAGE_UP = 33;
Keyboard.PAGE_DOWN = 34;
Keyboard.END = 35;
Keyboard.HOME = 36;
Keyboard.INSERT = 45;
Keyboard.DEL = 46;
Keyboard.LEFT = 37;
Keyboard.RIGHT = 39;
Keyboard.UP = 38;
Keyboard.DOWN = 40;
Keyboard.NUM0 = 48;
Keyboard.NUM1 = 49;
Keyboard.NUM2 = 50;
Keyboard.NUM3 = 51;
Keyboard.NUM4 = 52;
Keyboard.NUM5 = 53;
Keyboard.NUM6 = 54;
Keyboard.NUM7 = 55;
Keyboard.NUM8 = 56;
Keyboard.NUM9 = 57;
Keyboard.A = 65;
Keyboard.B = 66;
Keyboard.C = 67;
Keyboard.D = 68;
Keyboard.E = 69;
Keyboard.F = 70;
Keyboard.G = 71;
Keyboard.H = 72;
Keyboard.I = 73;
Keyboard.J = 74;
Keyboard.K = 75;
Keyboard.L = 76;
Keyboard.M = 77;
Keyboard.N = 78;
Keyboard.O = 79;
Keyboard.P = 80;
Keyboard.Q = 81;
Keyboard.R = 82;
Keyboard.S = 83;
Keyboard.T = 84;
Keyboard.U = 85;
Keyboard.V = 86;
Keyboard.W = 87;
Keyboard.X = 88;
Keyboard.Y = 89;
Keyboard.Z = 90;
Keyboard.F1 = 112;
Keyboard.F2 = 113;
Keyboard.F3 = 114;
Keyboard.F4 = 115;
Keyboard.F5 = 116;
Keyboard.F6 = 117;
Keyboard.F7 = 118;
Keyboard.F8 = 119;
Keyboard.F9 = 120;
Keyboard.F10 = 121;
Keyboard.F11 = 122;
Keyboard.F12 = 123;
"use strict";
function TizenKeyboard() {
}
TizenKeyboard.ARROW_LEFT = 37;
TizenKeyboard.ARROW_UP = 38;
TizenKeyboard.ARROW_RIGHT = 39;
TizenKeyboard.ARROW_DOWN = 40;
TizenKeyboard.ENTER = 13;
TizenKeyboard.BACK = 10009;
TizenKeyboard.VOLUME_UP = 447;
TizenKeyboard.VOLUME_DOWN = 448;
TizenKeyboard.VOLUME_MUTE = 449;
TizenKeyboard.CHANNEL_UP = 427;
TizenKeyboard.CHANNEL_DOWN = 428;
TizenKeyboard.F0_RED = 403;
TizenKeyboard.F1_GREEN = 404;
TizenKeyboard.F2_YELLOW = 405;
TizenKeyboard.F3_BLUE = 406;
TizenKeyboard.NUM_0 = 48;
TizenKeyboard.NUM_1 = 49;
TizenKeyboard.NUM_2 = 50;
TizenKeyboard.NUM_3 = 51;
TizenKeyboard.NUM_4 = 52;
TizenKeyboard.NUM_5 = 53;
TizenKeyboard.NUM_6 = 54;
TizenKeyboard.NUM_7 = 55;
TizenKeyboard.NUM_8 = 56;
TizenKeyboard.NUM_9 = 57;
TizenKeyboard.MINUS = 189;
TizenKeyboard.E_MANUAL = 10146;
TizenKeyboard.PREVIOUS_CHANNEL = 10190;
TizenKeyboard.PICTURE_SIZE = 10140;
TizenKeyboard.SOCCER = 10228;
TizenKeyboard.TELETEXT = 10200;
TizenKeyboard.SEARCH = 10225;
TizenKeyboard.GUIDE = 458;
TizenKeyboard.SOURCE = 10072;
TizenKeyboard.EXTRA = 10253;
TizenKeyboard.MTS = 10195;
TizenKeyboard.MEDIA_PLAY_PAUSE = 10252;
TizenKeyboard.MENU = 18;
TizenKeyboard.MEDIA_REWIND = 412;
TizenKeyboard.TOOLS = 10135;
TizenKeyboard.MEDIA_FAST_FORWARD = 417;
TizenKeyboard.INFO = 457;
TizenKeyboard.MEDIA_PLAY = 415;
TizenKeyboard.EXIT = 10182;
TizenKeyboard.MEDIA_PAUSE = 19;
TizenKeyboard.MEDIA_STOP = 413;
TizenKeyboard.CAPTION = 10221;
TizenKeyboard.MEDIA_RECORD = 416;
TizenKeyboard.CHANNEL_LIST = 10073;
TizenKeyboard.MEDIA_TRACK_PREVIOUS = 10232;
TizenKeyboard.MEDIA_TRACK_NEXT = 10233;
TizenKeyboard.MEDIA_3D = 10199;
"use strict";
function Mouse(a, d) {
  this._keys = Array(5);
  this._position = new THREE.Vector2(0, 0);
  this._positionUpdated = !1;
  this._delta = new THREE.Vector2(0, 0);
  this._wheel = 0;
  this._wheelUpdated = !1;
  this._doubleClicked = Array(5);
  this.keys = Array(5);
  this.position = new THREE.Vector2(0, 0);
  this.delta = new THREE.Vector2(0, 0);
  this.wheel = 0;
  this.doubleClicked = Array(5);
  this.domElement = void 0 !== a ? a : window;
  this.canvas = null;
  this.events = new EventManager;
  for (a = 0; 5 > a; a++) {
    this._doubleClicked[a] = !1, this.doubleClicked[a] = !1, this._keys[a] = new Key, this.keys[a] = new Key;
  }
  var g = this;
  void 0 !== window.onmousewheel ? this.events.add(this.domElement, "mousewheel", function(a) {
    g._wheel = a.deltaY;
    g._wheelUpdated = !0;
  }) : void 0 !== window.addEventListener ? this.events.add(this.domElement, "DOMMouseScroll", function(a) {
    g._wheel = 30 * a.detail;
    g._wheelUpdated = !0;
  }) : this.events.add(this.domElement, "wheel", function(a) {
    g._wheel = a.deltaY;
    g._wheelUpdated = !0;
  });
  if (void 0 !== window.ontouchstart || 0 < navigator.msMaxTouchPoints) {
    var h = new Vector2(0, 0);
    this.events.add(this.domElement, "touchstart", function(a) {
      a = a.touches[0];
      g.updatePosition(a.clientX, a.clientY, 0, 0);
      g.updateKey(Mouse.LEFT, Key.DOWN);
      h.set(a.clientX, a.clientY);
    });
    this.events.add(this.domElement, "touchend", function(a) {
      g.updateKey(Mouse.LEFT, Key.UP);
    });
    this.events.add(this.domElement, "touchcancel", function(a) {
      g.updateKey(Mouse.LEFT, Key.UP);
    });
    this.events.add(document.body, "touchmove", function(a) {
      a = a.touches[0];
      g.updatePosition(a.clientX, a.clientY, a.clientX - h.x, a.clientY - h.y);
      h.set(a.clientX, a.clientY);
    });
  }
  this.events.add(this.domElement, "mousemove", function(a) {
    g.updatePosition(a.clientX, a.clientY, a.movementX, a.movementY);
  });
  this.events.add(this.domElement, "mousedown", function(a) {
    g.updateKey(a.which - 1, Key.DOWN);
  });
  this.events.add(this.domElement, "mouseup", function(a) {
    g.updateKey(a.which - 1, Key.UP);
  });
  this.events.add(this.domElement, "dragstart", function(a) {
    g.updateKey(a.which - 1, Key.UP);
  });
  this.events.add(this.domElement, "dblclick", function(a) {
    g._doubleClicked[a.which - 1] = !0;
  });
  !0 !== d && this.create();
}
Mouse.prototype = Mouse;
Mouse.prototype.constructor = Mouse;
Mouse.LEFT = 0;
Mouse.MIDDLE = 1;
Mouse.RIGHT = 2;
Mouse.BACK = 3;
Mouse.FORWARD = 4;
Mouse.setCanvas = function(a) {
  this.canvas = a;
  a.mouseInside = !1;
  a.addEventListener("mouseenter", function() {
    this.mouseInside = !0;
  });
  a.addEventListener("mouseleave", function() {
    this.mouseInside = !1;
  });
};
Mouse.insideCanvas = function() {
  return null !== this.canvas && this.canvas.mouseInside;
};
Mouse.setLock = function(a) {
  null !== this.canvas && (a ? this.canvas.requestPointerLock ? this.canvas.requestPointerLock() : this.canvas.mozRequestPointerLock ? this.canvas.mozRequestPointerLock() : this.canvas.webkitRequestPointerLock && this.canvas.webkitRequestPointerLock() : document.exitPointerLock ? document.exitPointerLock() : document.mozExitPointerLock ? document.mozExitPointerLock() : document.webkitExitPointerLock && document.webkitExitPointerLock());
};
Mouse.buttonPressed = function(a) {
  return this.keys[a].pressed;
};
Mouse.buttonDoubleClicked = function(a) {
  return this.doubleClicked[a];
};
Mouse.buttonJustPressed = function(a) {
  return this.keys[a].justPressed;
};
Mouse.buttonJustReleased = function(a) {
  return this.keys[a].justReleased;
};
Mouse.updatePosition = function(a, d, g, h) {
  if (null !== this.canvas) {
    var e = this.canvas.getBoundingClientRect();
    a -= e.left;
    d -= e.top;
  }
  this._position.set(a, d);
  this._delta.x += g;
  this._delta.y += h;
  this._positionUpdated = !0;
};
Mouse.updateKey = function(a, d) {
  -1 < a && this._keys[a].update(d);
};
Mouse.update = function() {
  for (var a = 0; 5 > a; a++) {
    this._keys[a].justPressed && this.keys[a].justPressed && (this._keys[a].justPressed = !1), this._keys[a].justReleased && this.keys[a].justReleased && (this._keys[a].justReleased = !1), this.keys[a].set(this._keys[a].justPressed, this._keys[a].pressed, this._keys[a].justReleased), !0 === this._doubleClicked[a] ? (this.doubleClicked[a] = !0, this._doubleClicked[a] = !1) : this.doubleClicked[a] = !1;
  }
  this._wheelUpdated ? (this.wheel = this._wheel, this._wheelUpdated = !1) : this.wheel = 0;
  this._positionUpdated ? (this.delta.copy(this._delta), this.position.copy(this._position), this._delta.set(0, 0), this._positionUpdated = !1) : (this.delta.x = 0, this.delta.y = 0);
};
Mouse.create = function() {
  this.events.create();
};
Mouse.dispose = function() {
  this.events.destroy();
};
"use strict";
function Gamepad() {
  this.product = this.vendor = -1;
  this.connected = !1;
  this.gamepad = null;
  this.buttons = [];
  for (var a = navigator.getGamepads(), d = 0; d < a.length; d++) {
    if (null !== a[d]) {
      this.setGamepad(a[d]);
      break;
    }
  }
  null === this.gamepad && console.warn("nunuStudio: No gamepad found");
}
Gamepad.prototype.setGamepad = function(a) {
  if (void 0 !== a && null !== a) {
    this.index = a.index;
    this.gamepad = a;
    this.buttons = [];
    for (var d = 0; d < a.buttons.length; d++) {
      this.buttons.push(new Key);
    }
    this.setProductVendor(a);
    this.connected = !0;
  } else {
    console.warn("nunuStudio: No gamepad found"), this.disconnect();
  }
};
Gamepad.prototype.disconnect = function() {
  this.product = this.vendor = -1;
  this.connected = !1;
  this.gamepad = null;
  this.buttons = [];
};
Gamepad.prototype.setProductVendor = function(a) {
  try {
    var d = a.id.split(":");
    this.vendor = d[1].split(" ")[1];
    this.product = d[2].replace(" ", "").replace(")", "");
    return;
  } catch (g) {
  }
  try {
    d = a.id.split("-"), this.vendor = d[0], this.product = d[1];
  } catch (g) {
  }
};
Gamepad.prototype.update = function(a) {
  this.gamepad = navigator.getGamepads()[this.index];
  if (void 0 !== this.gamepad) {
    for (a = 0; a < this.buttons.length; a++) {
      this.buttons[a].update(this.gamepad.buttons[a].pressed ? Key.DOWN : Key.UP);
    }
  }
};
Gamepad.prototype.getAnalogueButton = function(a) {
  return a > this.buttons.length || 0 > a ? 0 : this.gamepad.buttons[a].value;
};
Gamepad.prototype.getAxis = function(a) {
  return a > this.gamepad.axes.length || 0 > a ? 0 : this.gamepad.axes[a];
};
Gamepad.prototype.buttonExists = function(a) {
  return 0 <= a && a < this.buttons.length;
};
Gamepad.prototype.buttonPressed = function(a) {
  return this.buttons[a] ? this.buttons[a].pressed : !1;
};
Gamepad.prototype.buttonJustPressed = function(a) {
  return this.buttons[a] ? this.buttons[a].justPressed : !1;
};
Gamepad.prototype.buttonJustReleased = function(a) {
  return this.buttons[a] ? this.buttons[a].justReleased : !1;
};
Gamepad.LEFT = 14;
Gamepad.RIGHT = 15;
Gamepad.DOWN = 13;
Gamepad.UP = 12;
Gamepad.SELECT = 8;
Gamepad.START = 9;
Gamepad.HOME = 16;
Gamepad.LEFT_TRIGGER_A = 4;
Gamepad.LEFT_TRIGGER_B = 6;
Gamepad.RIGHT_TRIGGER_A = 5;
Gamepad.RIGHT_TRIGGER_B = 7;
Gamepad.L1 = 4;
Gamepad.L2 = 6;
Gamepad.L3 = 6;
Gamepad.R1 = 5;
Gamepad.R2 = 7;
Gamepad.R3 = 11;
Gamepad.A = 0;
Gamepad.B = 1;
Gamepad.C = 2;
Gamepad.D = 3;
Gamepad.X = 2;
Gamepad.Y = 3;
Gamepad.LEFT_ANALOGUE_BUT = 10;
Gamepad.LEFT_ANALOGUE_HOR = 0;
Gamepad.LEFT_ANALOGUE_VERT = 1;
Gamepad.RIGHT_ANALOGUE_BUT = 11;
Gamepad.RIGHT_ANALOGUE_HOR = 2;
Gamepad.RIGHT_ANALOGUE_VERT = 3;
"use strict";
function Gyroscope() {
  this.orientation = this.gamma = this.beta = this.alpha = 0;
  this.events = new EventManager;
  var a = this;
  this.events.add(window, "orientationchange", function(d) {
    a.orientation = THREE.Math.degToRad(window.orientation);
  });
  this.events.add(window, "deviceorientation", function(d) {
    a.alpha = THREE.Math.degToRad(d.alpha);
    a.beta = THREE.Math.degToRad(d.beta);
    a.gamma = THREE.Math.degToRad(d.gamma);
  });
  this.events.create();
}
Gyroscope.prototype.setObjectQuaternion = function() {
  var a = new THREE.Euler, d = new THREE.Quaternion, g = new THREE.Vector3(0, 0, 1), h = new THREE.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5));
  return function(e) {
    a.set(this.beta, this.alpha, -this.gamma, "YXZ");
    e.quaternion.setFromEuler(a);
    e.quaternion.multiply(h);
    e.quaternion.multiply(d.setFromAxisAngle(g, -this.orientation));
  };
}();
Gyroscope.prototype.dispose = function() {
  this.events.destroy();
};
"use strict";
function RendererState() {
  this.autoClearDepth = this.autoClearStencil = this.autoClearColor = this.autoClear = !1;
  this.sortObjects = !0;
  this.clearColor = new THREE.Color;
  this.clearAlpha = 1;
}
RendererState.prototype.backup = function(a) {
  this.autoClear = a.autoClear;
  this.autoClearColor = a.autoClearColor;
  this.autoClearStencil = a.autoClearStencil;
  this.autoClearDepth = a.autoClearDepth;
  this.sortObjects = a.sortObjects;
  this.clearColor.copy(a.getClearColor());
  this.clearAlpha = a.getClearAlpha();
};
RendererState.prototype.restore = function(a) {
  a.autoClear = this.autoClear;
  a.autoClearColor = this.autoClearColor;
  a.autoClearStencil = this.autoClearStencil;
  a.autoClearDepth = this.autoClearDepth;
  a.sortObjects = this.sortObjects;
  a.setClearColor(this.clearColor);
  a.setClearAlpha(this.clearAlpha);
};
"use strict";
function RendererConfiguration(a) {
  this.backgroundColor = null;
  this.backend = RendererConfiguration.WEBGL2;
  this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !1;
  this.stencil = this.shadows = this.antialiasing = !0;
  this.shadowsType = THREE.PCFSoftShadowMap;
  this.shadowsAutoUpdate = !0;
  this.toneMapping = THREE.NoToneMapping;
  this.toneMappingWhitePoint = this.toneMappingExposure = 1;
  this.sortObjects = !0;
  this.gammaFactor = 2;
  this.precision = "highp";
  this.alpha = !1;
  this.premultipliedAlpha = !0;
  this.preserveDrawingBuffer = !1;
  this.powerPreference = "high-performance";
  this.physicallyCorrectLights = this.logarithmicDepthBuffer = !1;
  this.checkShaderErrors = !0;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  if (void 0 !== a) {
    for (var d in this) {
      void 0 !== a[d] && (this[d] = a[d]);
    }
  }
}
RendererConfiguration.WEBGL = 1;
RendererConfiguration.WEBGL2 = 2;
RendererConfiguration.prototype.createRenderer = function(a) {
  var d = null;
  if (this.backend === RendererConfiguration.WEBGL2) {
    try {
      d = a.getContext("webgl2");
    } catch (g) {
    }
  }
  d = new THREE.WebGLRenderer({canvas:a, context:d, precision:this.precision, alpha:this.alpha, premultipliedAlpha:this.premultipliedAlpha, antialias:this.antialiasing, stencil:this.stencil, preserveDrawingBuffer:this.preserveDrawingBuffer, powerPreference:this.powerPreference, logarithmicDepthBuffer:this.logarithmicDepthBuffer});
  this.apply(d);
  null !== this.backgroundColor && (a.style.backgroundColor = this.backgroundColor);
  return d;
};
RendererConfiguration.prototype.apply = function(a) {
  a.autoClear = this.autoClear;
  a.autoClearColor = this.autoClearColor;
  a.autoClearDepth = this.autoClearDepth;
  a.autoClearStencil = this.autoClearStencil;
  a.shadowMap.enabled = this.shadows;
  a.shadowMap.type = this.shadowsType;
  a.shadowMap.autoUpdate = this.shadowsAutoUpdate;
  a.shadowMap.needsUpdate = !0;
  a.toneMapping = this.toneMapping;
  a.toneMappingExposure = this.toneMappingExposure;
  a.toneMappingWhitePoint = this.toneMappingWhitePoint;
  a.debug.checkShaderErrors = this.checkShaderErrors;
  a.sortObjects = this.sortObjects;
  a.gammaFactor = this.gammaFactor;
  a.physicallyCorrectLights = this.physicallyCorrectLights;
  a.maxMorphTargets = this.maxMorphTargets;
  a.maxMorphNormals = this.maxMorphNormals;
};
RendererConfiguration.prototype.toJSON = function() {
  return {backgroundColor:this.backgroundColor, backend:this.backend, autoClear:this.autoClear, autoClearColor:this.autoClearColor, autoClearDepth:this.autoClearDepth, autoClearStencil:this.autoClearStencil, antialiasing:this.antialiasing, shadows:this.shadows, stencil:this.stencil, shadowsType:this.shadowsType, shadowsAutoUpdate:this.shadowsAutoUpdate, toneMapping:this.toneMapping, toneMappingExposure:this.toneMappingExposure, toneMappingWhitePoint:this.toneMappingWhitePoint, sortObjects:this.sortObjects, 
  checkShaderErrors:this.checkShaderErrors, gammaFactor:this.gammaFactor, precision:this.precision, alpha:this.alpha, premultipliedAlpha:this.premultipliedAlpha, preserveDrawingBuffer:this.preserveDrawingBuffer, powerPreference:this.powerPreference, logarithmicDepthBuffer:this.logarithmicDepthBuffer, physicallyCorrectLights:this.physicallyCorrectLights, maxMorphTargets:this.maxMorphTargets, maxMorphNormals:this.maxMorphNormals};
};
RendererConfiguration.prototype.fromJSON = function(a) {
  this.backgroundColor = a.backgroundColor;
  this.backend = a.backend;
  this.autoClear = a.autoClear;
  this.autoClearColor = a.autoClearColor;
  this.autoClearDepth = a.autoClearDepth;
  this.autoClearStencil = a.autoClearStencil;
  this.antialiasing = a.antialiasing;
  this.shadows = a.shadows;
  this.stencil = a.stencil;
  this.shadowsType = a.shadowsType;
  this.shadowsAutoUpdate = a.shadowsAutoUpdate;
  this.toneMapping = a.toneMapping;
  this.toneMappingExposure = a.toneMappingExposure;
  this.toneMappingWhitePoint = a.toneMappingWhitePoint;
  this.sortObjects = a.sortObjects;
  this.checkShaderErrors = a.checkShaderErrors;
  this.gammaFactor = a.gammaFactor;
  this.precision = a.precision;
  this.alpha = a.alpha;
  this.premultipliedAlpha = a.premultipliedAlpha;
  this.preserveDrawingBuffer = a.preserveDrawingBuffer;
  this.powerPreference = a.powerPreference;
  this.logarithmicDepthBuffer = a.logarithmicDepthBuffer;
  this.physicallyCorrectLights = a.physicallyCorrectLights;
  this.maxMorphTargets = a.maxMorphTargets;
  this.maxMorphNormals = a.maxMorphNormals;
};
"use strict";
function CSS3DRenderer(a) {
  this.size = new THREE.Vector2(2, 2);
  this.halfSize = new THREE.Vector2(1, 1);
  this.matrix = new THREE.Matrix4;
  this.cache = {camera:{fov:0, style:""}, objects:new WeakMap};
  this.domElement = void 0 !== a ? a : document.createElement("div");
  this.domElement.style.overflow = "hidden";
  this.domElement.style.pointerEvents = "none";
  this.cameraElement = document.createElement("div");
  this.cameraElement.style.WebkitTransformStyle = "preserve-3d";
  this.cameraElement.style.transformStyle = "preserve-3d";
  this.domElement.appendChild(this.cameraElement);
}
CSS3DRenderer.prototype.getSize = function() {
  return {width:this.size.x, height:this.size.y};
};
CSS3DRenderer.prototype.setSize = function(a, d) {
  this.size.set(a, d);
  this.halfSize.set(a / 2, d / 2);
  this.domElement.style.width = a + "px";
  this.domElement.style.height = d + "px";
  this.cameraElement.style.width = a + "px";
  this.cameraElement.style.height = d + "px";
};
CSS3DRenderer.prototype.render = function(a, d) {
  function g(a) {
    a = a.elements;
    return "matrix3d(" + a[0] + "," + -a[1] + "," + a[2] + "," + a[3] + "," + a[4] + "," + -a[5] + "," + a[6] + "," + a[7] + "," + a[8] + "," + -a[9] + "," + a[10] + "," + a[11] + "," + a[12] + "," + -a[13] + "," + a[14] + "," + a[15] + ")";
  }
  function h(a, c) {
    a = a.elements;
    return "translate(-50%,-50%)matrix3d(" + a[0] + "," + a[1] + "," + a[2] + "," + a[3] + "," + -a[4] + "," + -a[5] + "," + -a[6] + "," + -a[7] + "," + a[8] + "," + a[9] + "," + a[10] + "," + a[11] + "," + a[12] + "," + a[13] + "," + a[14] + "," + a[15] + ")";
  }
  function e(a, c, d) {
    if (!0 === a.isCSS3DObject) {
      if (!0 === a.isCSS3DSprite) {
        matrix.copy(c.matrixWorldInverse);
        matrix.transpose();
        matrix.copyPosition(a.matrixWorld);
        matrix.scale(a.scale);
        matrix.elements[3] = 0;
        matrix.elements[7] = 0;
        matrix.elements[11] = 0;
        matrix.elements[15] = 1;
        var b = h(matrix, d);
      } else {
        b = h(a.matrixWorld, d);
      }
      var f = a.element, g = k.cache.objects.get(a);
      if (void 0 === g || g.style !== b) {
        f.style.WebkitTransform = b, f.style.transform = b, k.cache.objects.set(a, {style:b});
      }
      f.parentNode !== k.cameraElement && k.cameraElement.appendChild(f);
    }
    b = 0;
    for (f = a.children.length; b < f; b++) {
      e(a.children[b], c, d);
    }
  }
  var k = this, c = d.projectionMatrix.elements[5] * this.halfSize.y;
  this.cache.camera.fov !== c && (d.isPerspectiveCamera && (this.domElement.style.WebkitPerspective = c + "px", this.domElement.style.perspective = c + "px"), this.cache.camera.fov = c);
  a.updateMatrixWorld();
  null === d.parent && d.updateMatrixWorld();
  c = d.isOrthographicCamera ? "scale(" + c + ")translate(" + -(d.right + d.left) / 2 + "px," + (d.top + d.bottom) / 2 + "px)" + g(d.matrixWorldInverse) : "translateZ(" + c + "px)" + g(d.matrixWorldInverse);
  var p = c + "translate(" + this.halfSize.x + "px," + this.halfSize.y + "px)";
  this.cache.camera.style !== p && (this.cameraElement.style.WebkitTransform = p, this.cameraElement.style.transform = p, this.cache.camera.style = p);
  e(a, d, c);
};
"use strict";
function CSS3DObject(a) {
  THREE.Object3D.call(this);
  this.element = a;
  this.element.style.position = "absolute";
  this.addEventListener("removed", function() {
    null !== this.element.parentNode && this.element.parentNode.removeChild(this.element);
  });
  var d = this, g = !0;
  Object.defineProperties(this, {visible:{get:function() {
    return g;
  }, set:function(a) {
    g = a;
    d.element.style.display = a ? "block" : "none";
  }}});
}
CSS3DObject.prototype = Object.create(THREE.Object3D.prototype);
CSS3DObject.prototype.constructor = CSS3DObject;
CSS3DObject.prototype.isCSS3DObject = !0;
"use strict";
function CSS3DSprite(a) {
  CSS3DObject.call(this, a);
}
CSS3DSprite.prototype = Object.create(CSS3DObject.prototype);
CSS3DSprite.prototype.constructor = CSS3DSprite;
CSS3DSprite.prototype.isCSS3DSprite = !0;
"use strict";
function Pass() {
  this.uuid = THREE.Math.generateUUID();
  this.type = "Pass";
  this.needsSwap = this.enabled = !0;
  this.copyToScreen = this.renderToScreen = this.clear = !1;
}
Pass.RGBALinear = {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBAFormat};
Pass.RGBLinear = {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBFormat};
Pass.RGBANearest = {minFilter:THREE.NearestFilter, magFilter:THREE.NearestFilter, format:THREE.RGBAFormat};
Pass.prototype.createQuadScene = function() {
  this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  this.scene = new THREE.Scene;
  this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
  this.quad.frustumCulled = !1;
  this.scene.add(this.quad);
};
Pass.prototype.setSize = function(a, d) {
};
Pass.prototype.render = function(a, d, g, h, e, k, c) {
};
Pass.prototype.dispose = function() {
};
Pass.prototype.toJSON = function(a) {
  a = {};
  a.uuid = this.uuid;
  a.type = this.type;
  a.clear = this.clear;
  a.enabled = this.enabled;
  a.needsSwap = this.needsSwap;
  a.renderToScreen = this.renderToScreen;
  a.copyToScreen = this.copyToScreen;
  return a;
};
"use strict";
function ShaderPass(a, d) {
  Pass.call(this);
  this.type = "Shader";
  this.textureID = void 0 !== d ? d : "tDiffuse";
  a instanceof THREE.ShaderMaterial ? (this.uniforms = a.uniforms, this.material = a) : a && (this.uniforms = THREE.UniformsUtils.clone(a.uniforms), this.material = new THREE.ShaderMaterial({defines:Object.assign({}, a.defines), uniforms:this.uniforms, vertexShader:a.vertexShader, fragmentShader:a.fragmentShader}));
  this.createQuadScene();
}
ShaderPass.prototype = Object.create(Pass.prototype);
ShaderPass.prototype.render = function(a, d, g, h, e, k, c) {
  this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = g.texture);
  this.quad.material = this.material;
  a.setRenderTarget(this.renderToScreen ? null : d);
  this.clear && a.clear();
  a.render(this.scene, this.camera);
};
"use strict";
function EffectComposer() {
  void 0 === THREE.CopyShader && console.error("EffectComposer relies on THREE.CopyShader");
  this.uuid = THREE.Math.generateUUID();
  this.height = this.width = 1;
  this.passes = [];
  this.writeBuffer = new THREE.WebGLRenderTarget(this.width, this.height, EffectComposer.bufferParameters);
  this.readBuffer = new THREE.WebGLRenderTarget(this.width, this.height, EffectComposer.bufferParameters);
  this.copyPass = new ShaderPass(THREE.CopyShader);
  this.rendererState = new RendererState;
}
EffectComposer.bufferParameters = {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBAFormat, stencilBuffer:!1};
EffectComposer.prototype.swapBuffers = function() {
  var a = this.readBuffer;
  this.readBuffer = this.writeBuffer;
  this.writeBuffer = a;
};
EffectComposer.prototype.addPass = function(a) {
  this.passes.push(a);
};
EffectComposer.prototype.moveBack = function(a) {
  var d = this.passes.indexOf(a);
  if (0 < d) {
    for (var g = d; g !== d - 1; --g) {
      this.passes[g] = this.passes[g - 1];
    }
    this.passes[d - 1] = a;
    return !0;
  }
  return !1;
};
EffectComposer.prototype.moveForward = function(a) {
  var d = this.passes.indexOf(a);
  if (-1 !== d && d < this.passes.length - 1) {
    for (var g = d; g !== d + 1; g += 1) {
      this.passes[g] = this.passes[g + 1];
    }
    this.passes[d + 1] = a;
    return !0;
  }
  return !1;
};
EffectComposer.prototype.removePass = function(a) {
  a = this.passes.indexOf(a);
  -1 !== a && this.passes.splice(a, 1);
};
EffectComposer.prototype.insertPass = function(a, d) {
  this.passes.splice(d, 0, a);
};
EffectComposer.prototype.render = function(a, d, g, h) {
  var e = !1;
  this.rendererState.backup(a);
  for (var k = 0; k < this.passes.length; k++) {
    var c = this.passes[k];
    if (c.enabled) {
      c.render(a, this.writeBuffer, this.readBuffer, h, e, d, g);
      if (c.renderToScreen) {
        c.copyToScreen && (this.copyPass.renderToScreen = !0, this.copyPass.render(a, this.readBuffer, this.writeBuffer, h));
        break;
      }
      c.needsSwap && (e && (a.context.stencilFunc(a.context.NOTEQUAL, 1, 4294967295), this.copyPass.renderToScreen = !1, this.copyPass.render(a, this.writeBuffer, this.readBuffer, h), a.context.stencilFunc(a.context.EQUAL, 1, 4294967295)), this.swapBuffers());
      void 0 !== THREE.MaskPass && (c instanceof THREE.MaskPass ? e = !0 : c instanceof THREE.ClearMaskPass && (e = !1));
    }
  }
  this.rendererState.restore(a);
};
EffectComposer.prototype.setSize = function(a, d) {
  a = Math.floor(a);
  d = Math.floor(d);
  this.width = a;
  this.height = d;
  this.writeBuffer.setSize(a, d);
  this.readBuffer.setSize(a, d);
  for (var g = 0; g < this.passes.length; g++) {
    this.passes[g].setSize(a, d);
  }
};
EffectComposer.prototype.reset = function() {
  this.dispose();
  this.writeBuffer = new THREE.WebGLRenderTarget(this.width, this.height, EffectComposer.bufferParameters);
  this.readBuffer = new THREE.WebGLRenderTarget(this.width, this.height, EffectComposer.bufferParameters);
};
EffectComposer.prototype.dispose = function() {
  this.writeBuffer.dispose();
  this.readBuffer.dispose();
  this.readBuffer = this.writeBuffer = null;
};
EffectComposer.prototype.toJSON = function() {
  var a = {};
  a.uuid = this.uuid;
  a.passes = [];
  for (var d = 0; d < this.passes.length; d++) {
    a.passes.push(this.passes[d].toJSON());
  }
  return a;
};
EffectComposer.fromJSON = function(a) {
  var d = new EffectComposer;
  d.uuid = a.uuid;
  for (var g = 0; g < a.passes.length; g++) {
    var h = a.passes[g];
    if ("Render" === h.type) {
      var e = new RenderPass;
    } else {
      if ("UnrealBloom" === h.type) {
        for (e = new UnrealBloomPass, e.strength = h.strength, e.radius = h.radius, e.threshold = h.threshold, e.bloomFactors = h.bloomFactors, g = 0; g < e.bloomTintColors.length; g++) {
          e.bloomTintColors[g].fromArray(h.bloomTintColors[g]);
        }
      } else {
        "Bloom" === h.type ? e = new BloomPass(h.strength, h.kernelSize, h.sigma, h.resolution) : "SSAONOH" === h.type ? (e = new SSAONOHPass, e.kernelRadius = h.kernelRadius, e.minDistance = h.minDistance, e.maxDistance = h.maxDistance, e.kernelSize = h.kernelSize) : "SSAO" === h.type ? (e = new SSAOPass, e.onlyAO = h.onlyAO, e.radius = h.radius, e.aoClamp = h.aoClamp, e.lumInfluence = h.lumInfluence) : "Bokeh" === h.type ? e = new BokehPass(h.focus, h.aperture, h.maxblur) : "FXAA" === h.type ? 
        e = new FXAAPass : "Copy" === h.type ? e = new CopyPass : "Film" === h.type ? (e = new FilmPass, e.grayscale = h.grayscale, e.noiseIntensity = h.noiseIntensity, e.scanlinesIntensity = h.scanlinesIntensity, e.scanlinesCount = h.scanlinesCount) : "DotScreen" === h.type ? (e = new DotScreenPass, e.center.fromArray(h.center), e.angle = h.angle, e.scale = h.scale) : "Colorify" === h.type ? (e = new ColorifyPass, e.color.setHex(h.color)) : "Sobel" === h.type ? e = new SobelPass : "Technicolor" === 
        h.type ? e = new TechnicolorPass : "HueSaturation" === h.type ? (e = new HueSaturationPass, e.hue = h.hue, e.saturation = h.saturation) : "AdaptiveToneMapping" === h.type ? (e = new AdaptiveToneMappingPass(h.adaptive), e.tau = h.tau, e.minLuminance = h.minLuminance) : "Afterimage" === h.type ? (e = new AfterimagePass, e.damp = h.damp) : e = new RenderPass;
      }
    }
    e.uuid = h.uuid;
    e.enabled = h.enabled;
    e.needsSwap = h.needsSwap;
    e.renderToScreen = h.renderToScreen;
    e.clear = h.clear;
    e.copyToScreen = !0 === h.copyToScreen;
    d.addPass(e);
  }
  return d;
};
"use strict";
function RenderPass() {
  Pass.call(this);
  this.type = "Render";
  this.clear = !0;
}
RenderPass.prototype = Object.create(Pass.prototype);
RenderPass.prototype.render = function(a, d, g, h, e, k, c) {
  this.clear ? (a.autoClear = !0, a.autoClearColor = !0, a.autoClearDepth = !0, a.autoClearStencil = !0) : a.autoClear = !1;
  a.setRenderTarget(this.renderToScreen ? null : d);
  a.render(k, c);
};
"use strict";
function FXAAPass() {
  ShaderPass.call(this, THREE.FXAAShader);
  this.type = "FXAA";
}
FXAAPass.prototype = Object.create(ShaderPass.prototype);
FXAAPass.prototype.setSize = function(a, d) {
  this.uniforms.resolution.value.set(1 / a, 1 / d);
};
"use strict";
function AfterimagePass(a) {
  void 0 === THREE.AfterimageShader && console.error("AfterimagePass relies on THREE.AfterimageShader");
  Pass.call(this);
  this.type = "Afterimage";
  this.uniforms = THREE.UniformsUtils.clone(THREE.AfterimageShader.uniforms);
  this.textureComp = new THREE.WebGLRenderTarget(1, 1, {minFilter:THREE.LinearFilter, magFilter:THREE.NearestFilter, format:THREE.RGBAFormat});
  this.textureOld = new THREE.WebGLRenderTarget(1, 1, {minFilter:THREE.LinearFilter, magFilter:THREE.NearestFilter, format:THREE.RGBAFormat});
  this.shaderMaterial = new THREE.ShaderMaterial({uniforms:this.uniforms, vertexShader:THREE.AfterimageShader.vertexShader, fragmentShader:THREE.AfterimageShader.fragmentShader});
  this.basicMaterial = new THREE.MeshBasicMaterial;
  this.createQuadScene();
  Object.defineProperties(this, {damp:{get:function() {
    return this.uniforms.damp.value;
  }, set:function(a) {
    this.uniforms.damp.value = a;
  }}});
  this.damp = void 0 !== a ? a : .96;
}
AfterimagePass.prototype = Object.create(Pass.prototype);
AfterimagePass.prototype.render = function(a, d, g, h, e, k, c) {
  h = this.textureOld;
  this.textureOld = this.textureComp;
  this.textureComp = h;
  this.uniforms.tNew.value = g.texture;
  this.uniforms.tOld.value = this.textureOld.texture;
  this.quad.material = this.shaderMaterial;
  a.autoClear = !1;
  a.setRenderTarget(this.textureComp);
  a.render(this.scene, this.camera);
  this.basicMaterial.map = this.textureComp.texture;
  this.clear ? (a.autoClear = !0, a.autoClearColor = !0, a.autoClearDepth = !0, a.autoClearStencil = !0) : a.autoClear = !1;
  this.quad.material = this.basicMaterial;
  a.setRenderTarget(this.renderToScreen ? null : d);
  a.render(this.scene, this.camera);
};
AfterimagePass.prototype.setSize = function(a, d) {
  this.textureComp.setSize(a, d);
  this.textureOld.setSize(a, d);
};
AfterimagePass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.damp = this.damp;
  return a;
};
"use strict";
function UnrealBloomPass(a, d, g) {
  void 0 === THREE.LuminosityHighPassShader && console.error("UnrealBloomPass relies on THREE.LuminosityHighPassShader");
  void 0 === THREE.CopyShader && console.error("UnrealBloomPass relies on THREE.CopyShader");
  Pass.call(this);
  this.type = "UnrealBloom";
  this.renderTargetsHorizontal = [];
  this.renderTargetsVertical = [];
  this.nMips = 5;
  for (var h = 0; h < this.nMips; h++) {
    var e = new THREE.WebGLRenderTarget(0, 0, Pass.RGBALinear);
    e.texture.generateMipmaps = !1;
    this.renderTargetsHorizontal.push(e);
    e = new THREE.WebGLRenderTarget(0, 0, Pass.RGBALinear);
    e.texture.generateMipmaps = !1;
    this.renderTargetsVertical.push(e);
  }
  this.renderTargetBright = new THREE.WebGLRenderTarget(0, 0, Pass.RGBALinear);
  this.renderTargetBright.texture.generateMipmaps = !1;
  h = THREE.LuminosityHighPassShader;
  this.highPassUniforms = THREE.UniformsUtils.clone(h.uniforms);
  this.materialHighPassFilter = new THREE.ShaderMaterial({uniforms:this.highPassUniforms, vertexShader:h.vertexShader, fragmentShader:h.fragmentShader, defines:{}});
  this.separableBlurMaterials = [];
  e = [3, 5, 7, 9, 11];
  for (h = 0; h < this.nMips; h++) {
    this.separableBlurMaterials.push(UnrealBloomPass.getSeperableBlurMaterial(e[h])), this.separableBlurMaterials[h].uniforms.texSize.value = new THREE.Vector2(0, 0);
  }
  this.compositeMaterial = UnrealBloomPass.getCompositeMaterial(this.nMips);
  this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture;
  this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture;
  this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture;
  this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture;
  this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture;
  this.highPassUniforms.luminosityThreshold.value = void 0 !== g ? g : .7;
  this.highPassUniforms.smoothWidth.value = .01;
  this.compositeMaterial.uniforms.bloomStrength.value = void 0 !== a ? a : .8;
  this.compositeMaterial.uniforms.bloomRadius.value = void 0 !== d ? d : .3;
  this.compositeMaterial.uniforms.bloomFactors.value = [1, .8, .6, .4, .2];
  this.compositeMaterial.uniforms.bloomTintColors.value = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)];
  this.compositeMaterial.needsUpdate = !0;
  this.copyUniforms = THREE.UniformsUtils.clone(THREE.CopyShader.uniforms);
  this.copyUniforms.opacity.value = 1;
  this.materialCopy = new THREE.ShaderMaterial({uniforms:this.copyUniforms, vertexShader:THREE.CopyShader.vertexShader, fragmentShader:THREE.CopyShader.fragmentShader, blending:THREE.AdditiveBlending, depthTest:!1, depthWrite:!1, transparent:!0});
  this.createQuadScene();
  this.basic = new THREE.MeshBasicMaterial;
  Object.defineProperties(this, {strength:{get:function() {
    return this.compositeMaterial.uniforms.bloomStrength.value;
  }, set:function(a) {
    this.compositeMaterial.uniforms.bloomStrength.value = a;
  }}, radius:{get:function() {
    return this.compositeMaterial.uniforms.bloomRadius.value;
  }, set:function(a) {
    this.compositeMaterial.uniforms.bloomRadius.value = a;
  }}, threshold:{get:function() {
    return this.highPassUniforms.luminosityThreshold.value;
  }, set:function(a) {
    this.highPassUniforms.luminosityThreshold.value;
  }}, smooth:{get:function() {
    return this.highPassUniforms.smoothWidth.value;
  }, set:function(a) {
    this.highPassUniforms.smoothWidth.value;
  }}, bloomFactors:{get:function() {
    return this.compositeMaterial.uniforms.bloomFactors.value;
  }, set:function(a) {
    this.compositeMaterial.uniforms.bloomFactors.value;
  }}, bloomTintColors:{get:function() {
    return this.compositeMaterial.uniforms.bloomTintColors.value;
  }, set:function(a) {
    this.compositeMaterial.uniforms.bloomTintColors.value = a;
  }}});
}
UnrealBloomPass.prototype = Object.create(Pass.prototype);
UnrealBloomPass.BlurDirectionX = new THREE.Vector2(1, 0);
UnrealBloomPass.BlurDirectionY = new THREE.Vector2(0, 1);
UnrealBloomPass.prototype.dispose = function() {
  for (var a = 0; a < this.renderTargetsHorizontal.length; a++) {
    this.renderTargetsHorizontal[a].dispose();
  }
  for (a = 0; a < this.renderTargetsVertical.length; a++) {
    this.renderTargetsVertical[a].dispose();
  }
  this.renderTargetBright.dispose();
};
UnrealBloomPass.prototype.setSize = function(a, d) {
  a = Math.round(a / 2);
  d = Math.round(d / 2);
  this.renderTargetBright.setSize(a, d);
  for (var g = 0; g < this.nMips; g++) {
    this.renderTargetsHorizontal[g].setSize(a, d), this.renderTargetsVertical[g].setSize(a, d), this.separableBlurMaterials[g].uniforms.texSize.value.set(a, d), a = Math.round(a / 2), d = Math.round(d / 2);
  }
};
UnrealBloomPass.prototype.render = function(a, d, g, h, e, k, c) {
  a.autoClear = !1;
  a.setClearColor(new THREE.Color(0, 0, 0), 0);
  e && a.context.disable(a.context.STENCIL_TEST);
  this.renderToScreen && (this.quad.material = this.basic, this.basic.map = g.texture, a.setRenderTarget(null), a.clear(), a.render(this.scene, this.camera));
  this.highPassUniforms.tDiffuse.value = g.texture;
  this.quad.material = this.materialHighPassFilter;
  a.setRenderTarget(this.renderTargetBright);
  a.clear();
  a.render(this.scene, this.camera);
  d = this.renderTargetBright;
  for (h = 0; h < this.nMips; h++) {
    this.quad.material = this.separableBlurMaterials[h], this.separableBlurMaterials[h].uniforms.colorTexture.value = d.texture, this.separableBlurMaterials[h].uniforms.direction.value = UnrealBloomPass.BlurDirectionX, a.setRenderTarget(this.renderTargetsHorizontal[h]), a.clear(), a.render(this.scene, this.camera), this.separableBlurMaterials[h].uniforms.colorTexture.value = this.renderTargetsHorizontal[h].texture, this.separableBlurMaterials[h].uniforms.direction.value = UnrealBloomPass.BlurDirectionY, 
    a.setRenderTarget(this.renderTargetsVertical[h]), a.clear(), a.render(this.scene, this.camera), d = this.renderTargetsVertical[h];
  }
  this.quad.material = this.compositeMaterial;
  a.setRenderTarget(this.renderTargetsHorizontal[0]);
  a.render(this.scene, this.camera);
  this.quad.material = this.materialCopy;
  this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture;
  e && a.context.enable(a.context.STENCIL_TEST);
  a.setRenderTarget(this.renderToScreen ? null : g);
  a.render(this.scene, this.camera);
};
UnrealBloomPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.strength = this.strength;
  a.radius = this.radius;
  a.threshold = this.threshold;
  a.bloomFactors = this.bloomFactors;
  a.bloomTintColors = [];
  for (var d = 0; d < this.bloomTintColors.length; d++) {
    a.bloomTintColors.push(this.bloomTintColors[d].toArray());
  }
  return a;
};
UnrealBloomPass.getSeperableBlurMaterial = function(a) {
  return new THREE.ShaderMaterial({defines:{KERNEL_RADIUS:a, SIGMA:a}, uniforms:{colorTexture:{value:null}, texSize:{value:new THREE.Vector2(.5, .5)}, direction:{value:new THREE.Vector2(.5, .5)}}, vertexShader:"\n\t\t\tvarying vec2 vUv;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tvUv = uv;\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t\t\t}", fragmentShader:"\n\t\t\t#include <common>\n\t\t\tvarying vec2 vUv;\n\t\t\tuniform sampler2D colorTexture;\n\t\t\tuniform vec2 texSize;\n\t\t\tuniform vec2 direction;\n\t\t\t\n\t\t\tfloat gaussianPdf(in float x, in float sigma)\n\t\t\t{\n\t\t\t\treturn 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n\t\t\t}\n\t\t\t\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\tvec3 diffuseSum = texture2D(colorTexture, vUv).rgb * weightSum;\n\t\t\t\tfor(int i = 1; i < KERNEL_RADIUS; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\tvec3 sample1 = texture2D(colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\tvec3 sample2 = texture2D(colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t}\n\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t}"});
};
UnrealBloomPass.getCompositeMaterial = function(a) {
  return new THREE.ShaderMaterial({defines:{NUM_MIPS:a}, uniforms:{blurTexture1:{value:null}, blurTexture2:{value:null}, blurTexture3:{value:null}, blurTexture4:{value:null}, blurTexture5:{value:null}, dirtTexture:{value:null}, bloomStrength:{value:1}, bloomFactors:{value:null}, bloomTintColors:{value:null}, bloomRadius:{value:0}}, vertexShader:"\n\t\t\tvarying vec2 vUv;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tvUv = uv;\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t\t\t}", 
  fragmentShader:"\n\t\t\tvarying vec2 vUv;\n\t\t\tuniform sampler2D blurTexture1;\n\t\t\tuniform sampler2D blurTexture2;\n\t\t\tuniform sampler2D blurTexture3;\n\t\t\tuniform sampler2D blurTexture4;\n\t\t\tuniform sampler2D blurTexture5;\n\t\t\tuniform sampler2D dirtTexture;\n\t\t\tuniform float bloomStrength;\n\t\t\tuniform float bloomRadius;\n\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\t\t\t\n\t\t\tfloat lerpBloomFactor(const in float factor)\n\t\t\t{\n\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t}\n\t\t\t\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tgl_FragColor = bloomStrength * (lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \n\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \n\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \n\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \n\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv));\n\t\t\t}"});
};
"use strict";
function BloomPass(a, d, g, h) {
  Pass.call(this);
  void 0 === THREE.ConvolutionShader && console.error("BloomPass relies on THREE.ConvolutionShader");
  void 0 === THREE.CopyShader && console.error("BloomPass relies on THREE.CopyShader");
  this.type = "Bloom";
  this.copyToScreen = !0;
  this.createQuadScene();
  a = void 0 !== a ? a : 1;
  d = void 0 !== d ? d : 25;
  g = void 0 !== g ? g : 4;
  h = void 0 !== h ? h : 256;
  this.renderTargetX = new THREE.WebGLRenderTarget(h, h, Pass.RGBALinear);
  this.renderTargetY = new THREE.WebGLRenderTarget(h, h, Pass.RGBALinear);
  this.copyUniforms = THREE.UniformsUtils.clone(THREE.CopyShader.uniforms);
  this.copyUniforms.opacity.value = a;
  this.materialCopy = new THREE.ShaderMaterial({uniforms:this.copyUniforms, vertexShader:THREE.CopyShader.vertexShader, fragmentShader:THREE.CopyShader.fragmentShader, blending:THREE.AdditiveBlending, transparent:!0});
  this.convolutionUniforms = THREE.UniformsUtils.clone(THREE.ConvolutionShader.uniforms);
  this.convolutionUniforms.uImageIncrement.value = BloomPass.blurX;
  this.convolutionUniforms.cKernel.value = THREE.ConvolutionShader.buildKernel(g);
  this.materialConvolution = new THREE.ShaderMaterial({uniforms:this.convolutionUniforms, vertexShader:THREE.ConvolutionShader.vertexShader, fragmentShader:THREE.ConvolutionShader.fragmentShader, defines:{KERNEL_SIZE_FLOAT:d.toFixed(1), KERNEL_SIZE_INT:d.toFixed(0)}});
}
BloomPass.blurX = new THREE.Vector2(.001953125, 0);
BloomPass.blurY = new THREE.Vector2(0, .001953125);
BloomPass.prototype = Object.create(Pass.prototype);
BloomPass.prototype.render = function(a, d, g, h, e, k, c) {
  e && a.context.disable(a.context.STENCIL_TEST);
  this.quad.material = this.materialConvolution;
  this.convolutionUniforms.tDiffuse.value = g.texture;
  this.convolutionUniforms.uImageIncrement.value = BloomPass.blurX;
  a.setRenderTarget(this.renderTargetX);
  a.clear(!0, !0, !0);
  a.render(this.scene, this.camera);
  this.convolutionUniforms.tDiffuse.value = this.renderTargetX.texture;
  this.convolutionUniforms.uImageIncrement.value = BloomPass.blurY;
  a.setRenderTarget(this.renderTargetY);
  a.clear(!0, !0, !0);
  a.render(this.scene, this.camera);
  this.quad.material = this.materialCopy;
  this.copyUniforms.tDiffuse.value = this.renderTargetY.texture;
  e && a.context.enable(a.context.STENCIL_TEST);
  a.setRenderTarget(d);
  a.render(this.scene, this.camera);
};
BloomPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.strength = this.strength;
  a.kernelSize = this.kernelSize;
  a.sigma = this.sigma;
  a.resolution = this.resolution;
  return a;
};
"use strict";
function SSAONOHPass() {
  void 0 === THREE.SSAOShader && console.warn("SSAONOHPass depends on THREE.SSAOShader");
  Pass.call(this);
  this.type = "SSAONOH";
  this.kernel = [];
  this.noiseTexture = null;
  this.createQuadScene();
  this.depthTexture = new THREE.DepthTexture;
  this.depthTexture.type = THREE.UnsignedShortType;
  this.depthTexture.minFilter = THREE.NearestFilter;
  this.depthTexture.maxFilter = THREE.NearestFilter;
  this.normalMaterial = new THREE.MeshNormalMaterial;
  this.normalMaterial.blending = THREE.NoBlending;
  this.normalRenderTarget = new THREE.WebGLRenderTarget(1, 1, {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBAFormat, depthTexture:this.depthTexture, depthBuffer:!0});
  this.ssaoRenderTarget = new THREE.WebGLRenderTarget(1, 1, Pass.RGBALinear);
  this.blurRenderTarget = new THREE.WebGLRenderTarget(1, 1, Pass.RGBALinear);
  this.blurMaterial = new THREE.ShaderMaterial({defines:Object.assign({}, THREE.SSAOBlurShader.defines), uniforms:THREE.UniformsUtils.clone(THREE.SSAOBlurShader.uniforms), vertexShader:THREE.SSAOBlurShader.vertexShader, fragmentShader:THREE.SSAOBlurShader.fragmentShader});
  this.blurMaterial.uniforms.tDiffuse.value = this.ssaoRenderTarget.texture;
  this.ssaoMaterial = new THREE.ShaderMaterial({defines:Object.assign({}, THREE.SSAOShader.defines), uniforms:THREE.UniformsUtils.clone(THREE.SSAOShader.uniforms), vertexShader:THREE.SSAOShader.vertexShader, fragmentShader:THREE.SSAOShader.fragmentShader, blending:THREE.NoBlending});
  this.ssaoMaterial.uniforms.tNormal.value = this.normalRenderTarget.texture;
  this.copyMaterial = new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(THREE.CopyShader.uniforms), vertexShader:THREE.CopyShader.vertexShader, fragmentShader:THREE.CopyShader.fragmentShader, transparent:!0, depthTest:!1, depthWrite:!1, blendSrc:THREE.DstColorFactor, blendDst:THREE.ZeroFactor, blendEquation:THREE.AddEquation, blendSrcAlpha:THREE.DstAlphaFactor, blendDstAlpha:THREE.ZeroFactor, blendEquationAlpha:THREE.AddEquation});
  this._kernelSize = 0;
  var a = this;
  Object.defineProperties(this, {kernelRadius:{get:function() {
    return a.ssaoMaterial.uniforms.kernelRadius.value;
  }, set:function(d) {
    a.ssaoMaterial.uniforms.kernelRadius.value = d;
  }}, minDistance:{get:function() {
    return a.ssaoMaterial.uniforms.minDistance.value;
  }, set:function(d) {
    a.ssaoMaterial.uniforms.minDistance.value = d;
  }}, maxDistance:{get:function() {
    return a.ssaoMaterial.uniforms.maxDistance.value;
  }, set:function(d) {
    a.ssaoMaterial.uniforms.maxDistance.value = d;
  }}, kernelSize:{get:function() {
    return a._kernelSize;
  }, set:function(d) {
    a._kernelSize = d;
    a.generateSampleKernel();
    a.generateRandomKernelRotations();
    a.ssaoMaterial.uniforms.tNoise.value = a.noiseTexture;
    a.ssaoMaterial.uniforms.kernel.value = a.kernel;
  }}});
  this.kernelSize = 64;
  this.kernelRadius = 8;
  this.minDistance = .1;
  this.maxDistance = 1E3;
}
SSAONOHPass.prototype = Object.create(Pass.prototype);
SSAONOHPass.prototype.generateSampleKernel = function() {
  for (var a = 0; a < this._kernelSize; a++) {
    var d = new THREE.Vector3;
    d.x = 2 * Math.random() - 1;
    d.y = 2 * Math.random() - 1;
    d.z = Math.random();
    d.normalize();
    var g = a / this._kernelSize;
    g = THREE.Math.lerp(.1, 1, g * g);
    d.multiplyScalar(g);
    this.kernel.push(d);
  }
};
SSAONOHPass.prototype.generateRandomKernelRotations = function() {
  void 0 === SimplexNoise && console.error("SSAONOHPass: The pass relies on SimplexNoise.");
  for (var a = new SimplexNoise, d = new Float32Array(16), g = 0; 16 > g; g++) {
    d[g] = a.noise3d(2 * Math.random() - 1, 2 * Math.random() - 1, 0);
  }
  this.noiseTexture = new THREE.DataTexture(d, 4, 4, THREE.LuminanceFormat, THREE.FloatType);
  this.noiseTexture.wrapS = THREE.RepeatWrapping;
  this.noiseTexture.wrapT = THREE.RepeatWrapping;
  this.noiseTexture.needsUpdate = !0;
};
SSAONOHPass.prototype.render = function(a, d, g, h, e, k, c) {
  a.autoClear = !1;
  a.setClearColor(7829503);
  a.setClearAlpha(1);
  k.overrideMaterial = this.normalMaterial;
  a.setRenderTarget(this.normalRenderTarget);
  a.clear(!0, !0, !0);
  a.render(k, c);
  k.overrideMaterial = null;
  this.ssaoMaterial.uniforms.tDepth.value = this.depthTexture;
  this.ssaoMaterial.uniforms.tDiffuse.value = g.texture;
  this.ssaoMaterial.uniforms.cameraNear.value = c.near;
  this.ssaoMaterial.uniforms.cameraFar.value = c.far;
  this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(c.projectionMatrix);
  this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.getInverse(c.projectionMatrix);
  this.renderPass(a, this.ssaoMaterial, this.ssaoRenderTarget);
  this.renderPass(a, this.blurMaterial, this.blurRenderTarget);
  this.renderToScreen ? (this.copyMaterial.uniforms.tDiffuse.value = g.texture, this.copyMaterial.blending = THREE.NoBlending, this.renderPass(a, this.copyMaterial, null, this.clear), this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.copyMaterial.blending = THREE.CustomBlending, this.renderPass(a, this.copyMaterial, null, !1)) : (this.copyMaterial.uniforms.tDiffuse.value = g.texture, this.copyMaterial.blending = THREE.NoBlending, this.renderPass(a, this.copyMaterial, 
  d, this.clear), this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.copyMaterial.blending = THREE.CustomBlending, this.renderPass(a, this.copyMaterial, d, !1));
};
SSAONOHPass.prototype.renderPass = function(a, d, g, h) {
  this.quad.material = d;
  a.autoClear = !1;
  a.setRenderTarget(g);
  h && a.clear(!0, !0, !0);
  a.render(this.scene, this.camera);
};
SSAONOHPass.prototype.dispose = function() {
  this.normalRenderTarget.dispose();
  this.ssaoRenderTarget.dispose();
  this.blurRenderTarget.dispose();
  this.quad.geometry.dispose();
  this.normalMaterial.dispose();
  this.blurMaterial.dispose();
  this.copyMaterial.dispose();
};
SSAONOHPass.prototype.setSize = function(a, d) {
  this.ssaoMaterial.uniforms.resolution.value.set(a, d);
  this.blurMaterial.uniforms.resolution.value.set(a, d);
  this.normalRenderTarget.setSize(a, d);
  this.ssaoRenderTarget.setSize(a, d);
  this.blurRenderTarget.setSize(a, d);
};
SSAONOHPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.kernelSize = this.kernelSize;
  a.kernelRadius = this.kernelRadius;
  a.minDistance = this.minDistance;
  a.maxDistance = this.maxDistance;
  return a;
};
"use strict";
function SSAOPass() {
  ShaderPass.call(this, SSAOShader);
  this.type = "SSAO";
  this.depthMaterial = new THREE.MeshDepthMaterial;
  this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
  this.depthMaterial.blending = THREE.NoBlending;
  this.depthRenderTarget = new THREE.WebGLRenderTarget(2, 2, {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter});
  this.uniforms.tDepth.value = this.depthRenderTarget.texture;
  this.uniforms.size.value.set(2, 2);
  Object.defineProperties(this, {radius:{get:function() {
    return this.uniforms.radius.value;
  }, set:function(a) {
    this.uniforms.radius.value = a;
  }}, onlyAO:{get:function() {
    return this.uniforms.onlyAO.value;
  }, set:function(a) {
    this.uniforms.onlyAO.value = a;
  }}, aoClamp:{get:function() {
    return this.uniforms.aoClamp.value;
  }, set:function(a) {
    this.uniforms.aoClamp.value = a;
  }}, lumInfluence:{get:function() {
    return this.uniforms.lumInfluence.value;
  }, set:function(a) {
    this.uniforms.lumInfluence.value = a;
  }}});
  this.radius = 4;
  this.onlyAO = !1;
  this.aoClamp = .25;
  this.lumInfluence = .7;
}
SSAOPass.prototype = Object.create(ShaderPass.prototype);
SSAOPass.prototype.render = function(a, d, g, h, e, k, c) {
  this.uniforms.cameraNear.value = c.near;
  this.uniforms.cameraFar.value = c.far;
  k.overrideMaterial = this.depthMaterial;
  a.setRenderTarget(this.depthRenderTarget);
  a.clear(!0, !0, !0);
  a.render(k, c);
  k.overrideMaterial = null;
  ShaderPass.prototype.render.call(this, a, d, g, h, e);
};
SSAOPass.prototype.setSize = function(a, d) {
  this.uniforms.size.value.set(a, d);
  this.depthRenderTarget.setSize(a, d);
};
SSAOPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.onlyAO = this.onlyAO;
  a.radius = this.radius;
  a.aoClamp = this.aoClamp;
  a.lumInfluence = this.lumInfluence;
  return a;
};
"use strict";
function BokehPass(a, d, g) {
  void 0 === THREE.BokehShader && console.error("BokehPass relies on THREE.BokehShader");
  Pass.call(this);
  this.type = "Bokeh";
  this.renderTargetColor = new THREE.WebGLRenderTarget(0, 0, Pass.RGBLinear);
  this.renderTargetDepth = this.renderTargetColor.clone();
  this.materialDepth = new THREE.MeshDepthMaterial;
  this.materialDepth.depthPacking = THREE.RGBADepthPacking;
  this.materialDepth.blending = THREE.NoBlending;
  this.uniforms = THREE.UniformsUtils.clone(THREE.BokehShader.uniforms);
  this.uniforms.tDepth.value = this.renderTargetDepth.texture;
  this.materialBokeh = new THREE.ShaderMaterial({defines:THREE.BokehShader.defines, uniforms:this.uniforms, vertexShader:THREE.BokehShader.vertexShader, fragmentShader:THREE.BokehShader.fragmentShader});
  this.createQuadScene();
  this.quad.material = this.materialBokeh;
  var h = this;
  Object.defineProperties(this, {aperture:{get:function() {
    return h.uniforms.aperture.value;
  }, set:function(a) {
    h.uniforms.aperture.value = a;
  }}, focus:{get:function() {
    return h.uniforms.focus.value;
  }, set:function(a) {
    h.uniforms.focus.value = a;
  }}, maxblur:{get:function() {
    return h.uniforms.maxblur.value;
  }, set:function(a) {
    h.uniforms.maxblur.value = a;
  }}});
  this.focus = void 0 !== a ? a : 1;
  this.aperture = void 0 !== d ? d : 1;
  this.maxblur = void 0 !== g ? g : .2;
}
BokehPass.prototype = Object.create(Pass.prototype);
BokehPass.prototype.render = function(a, d, g, h, e, k, c) {
  k.overrideMaterial = this.materialDepth;
  a.autoClear = !1;
  a.setClearColor(16777215);
  a.setClearAlpha(1);
  a.setRenderTarget(this.renderTargetDepth);
  a.clear(!0, !0, !0);
  a.render(k, c);
  this.uniforms.tColor.value = g.texture;
  this.uniforms.nearClip.value = c.near;
  this.uniforms.farClip.value = c.far;
  this.uniforms.aspect.value = c.aspect;
  this.clear ? (a.autoClear = !0, a.autoClearColor = !0, a.autoClearDepth = !0, a.autoClearStencil = !0) : a.autoClear = !1;
  a.setRenderTarget(this.renderToScreen ? null : d);
  a.render(this.scene, this.camera);
  k.overrideMaterial = null;
};
BokehPass.prototype.setSize = function(a, d) {
  this.renderTargetColor.setSize(a, d);
  this.renderTargetDepth.setSize(a, d);
};
BokehPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.aperture = this.aperture;
  a.focus = this.focus;
  a.maxblur = this.maxblur;
  return a;
};
"use strict";
function CopyPass() {
  ShaderPass.call(this, THREE.CopyShader);
  this.type = "Copy";
}
CopyPass.prototype = Object.create(ShaderPass.prototype);
"use strict";
function FilmPass(a, d, g, h) {
  void 0 === THREE.FilmShader && console.error("FilmPass relies on THREE.FilmShader");
  Pass.call(this);
  this.type = "Film";
  this.createQuadScene();
  this.uniforms = THREE.UniformsUtils.clone(THREE.FilmShader.uniforms);
  this.material = new THREE.ShaderMaterial({uniforms:this.uniforms, vertexShader:THREE.FilmShader.vertexShader, fragmentShader:THREE.FilmShader.fragmentShader});
  var e = this;
  Object.defineProperties(this, {grayscale:{get:function() {
    return e.uniforms.grayscale.value;
  }, set:function(a) {
    e.uniforms.grayscale.value = a;
  }}, noiseIntensity:{get:function() {
    return e.uniforms.nIntensity.value;
  }, set:function(a) {
    e.uniforms.nIntensity.value = a;
  }}, scanlinesIntensity:{get:function() {
    return e.uniforms.sIntensity.value;
  }, set:function(a) {
    e.uniforms.sIntensity.value = a;
  }}, scanlinesCount:{get:function() {
    return e.uniforms.sCount.value;
  }, set:function(a) {
    e.uniforms.sCount.value = a;
  }}});
  this.grayscale = void 0 !== h ? h : !1;
  this.noiseIntensity = void 0 !== a ? a : .35;
  this.scanlinesIntensity = void 0 !== d ? d : .5;
  this.scanlinesCount = void 0 !== g ? g : 512;
}
FilmPass.prototype = Object.create(Pass.prototype);
FilmPass.prototype.render = function(a, d, g, h, e, k, c) {
  this.uniforms.time.value += h;
  this.uniforms.tDiffuse.value = g.texture;
  this.quad.material = this.material;
  this.clear ? (a.autoClear = !0, a.autoClearColor = !0, a.autoClearDepth = !0, a.autoClearStencil = !0) : a.autoClear = !1;
  a.setRenderTarget(this.renderToScreen ? null : d);
  a.render(this.scene, this.camera);
};
FilmPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.grayscale = this.grayscale;
  a.noiseIntensity = this.noiseIntensity;
  a.scanlinesIntensity = this.scanlinesIntensity;
  a.scanlinesCount = this.scanlinesCount;
  return a;
};
"use strict";
function DotScreenPass(a, d, g) {
  void 0 === THREE.DotScreenShader && console.error("DotScreenPass relies on THREE.DotScreenShader");
  Pass.call(this);
  this.type = "DotScreen";
  this.createQuadScene();
  this.uniforms = THREE.UniformsUtils.clone(THREE.DotScreenShader.uniforms);
  this.material = new THREE.ShaderMaterial({uniforms:this.uniforms, vertexShader:THREE.DotScreenShader.vertexShader, fragmentShader:THREE.DotScreenShader.fragmentShader});
  Object.defineProperties(this, {center:{get:function() {
    return this.uniforms.center.value;
  }, set:function(a) {
    this.uniforms.center.value = a;
  }}, angle:{get:function() {
    return this.uniforms.angle.value;
  }, set:function(a) {
    this.uniforms.angle.value = a;
  }}, scale:{get:function() {
    return this.uniforms.scale.value;
  }, set:function(a) {
    this.uniforms.scale.value = a;
  }}});
  void 0 !== a && this.center.copy(a);
  this.angle = void 0 !== d ? d : .5;
  this.scale = void 0 !== g ? g : .8;
}
DotScreenPass.prototype = Object.create(Pass.prototype);
DotScreenPass.prototype.render = function(a, d, g, h, e, k, c) {
  this.uniforms.tDiffuse.value = g.texture;
  this.uniforms.tSize.value.set(g.width, g.height);
  this.quad.material = this.material;
  this.clear ? (a.autoClear = !0, a.autoClearColor = !0, a.autoClearDepth = !0, a.autoClearStencil = !0) : a.autoClear = !1;
  a.setRenderTarget(this.renderToScreen ? null : d);
  a.render(this.scene, this.camera);
};
DotScreenPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.center = this.center.toArray();
  a.angle = this.angle;
  a.scale = this.scale;
  return a;
};
"use strict";
function SobelPass(a, d, g) {
  void 0 === THREE.SobelOperatorShader && console.error("SobelPass relies on THREE.SobelOperatorShader");
  void 0 === THREE.LuminosityShader && console.error("SobelPass relies on THREE.LuminosityShader");
  ShaderPass.call(this, THREE.SobelOperatorShader);
  this.type = "Sobel";
}
SobelPass.prototype = Object.create(ShaderPass.prototype);
SobelPass.prototype.setSize = function(a, d) {
  this.uniforms.resolution.value.set(a, d);
};
"use strict";
function ColorifyPass() {
  ShaderPass.call(this, THREE.ColorifyShader);
  this.type = "Colorify";
  Object.defineProperties(this, {color:{get:function() {
    return this.uniforms.color.value;
  }, set:function(a) {
    this.uniforms.color.value = a;
  }}});
}
ColorifyPass.prototype = Object.create(ShaderPass.prototype);
ColorifyPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.color = this.color.getHex();
  return a;
};
"use strict";
function TechnicolorPass() {
  ShaderPass.call(this, THREE.TechnicolorShader);
  this.type = "Technicolor";
}
TechnicolorPass.prototype = Object.create(ShaderPass.prototype);
"use strict";
function HueSaturationPass(a, d) {
  ShaderPass.call(this, THREE.HueSaturationShader);
  this.type = "HueSaturation";
  Object.defineProperties(this, {hue:{get:function() {
    return this.uniforms.hue.value;
  }, set:function(a) {
    this.uniforms.hue.value = a;
  }}, saturation:{get:function() {
    return this.uniforms.saturation.value;
  }, set:function(a) {
    this.uniforms.saturation.value = a;
  }}});
  this.hue = void 0 !== a ? a : 0;
  this.saturation = void 0 !== d ? d : 0;
}
HueSaturationPass.prototype = Object.create(ShaderPass.prototype);
HueSaturationPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.hue = this.hue;
  a.saturation = this.saturation;
  return a;
};
function AdaptiveToneMappingPass(a, d) {
  Pass.call(this);
  var g = this;
  this.type = "AdaptiveToneMapping";
  this.needsInit = !0;
  this.resolution = void 0 !== d ? d : 256;
  this._adaptive = void 0 !== a ? a : !0;
  this.currentLuminanceRT = this.previousLuminanceRT = this.luminanceRT = null;
  this.copyUniforms = THREE.UniformsUtils.clone(THREE.CopyShader.uniforms);
  this.materialCopy = new THREE.ShaderMaterial({uniforms:this.copyUniforms, vertexShader:THREE.CopyShader.vertexShader, fragmentShader:THREE.CopyShader.fragmentShader, blending:THREE.NoBlending, depthTest:!1});
  this.materialLuminance = new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(THREE.LuminosityShader.uniforms), vertexShader:THREE.LuminosityShader.vertexShader, fragmentShader:THREE.LuminosityShader.fragmentShader, blending:THREE.NoBlending});
  this.createShader();
  void 0 === THREE.ToneMapShader && console.error("nunuStudio: AdaptiveToneMappingPass relies on THREE.ToneMapShader");
  this.materialToneMap = new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(THREE.ToneMapShader.uniforms), vertexShader:THREE.ToneMapShader.vertexShader, fragmentShader:THREE.ToneMapShader.fragmentShader, blending:THREE.NoBlending});
  this.createQuadScene();
  Object.defineProperties(this, {minLuminance:{get:function() {
    return g.adaptLuminanceShader.uniforms.minLuminance.value;
  }, set:function(a) {
    g.adaptLuminanceShader.uniforms.minLuminance.value = a;
  }}, tau:{get:function() {
    return g.adaptLuminanceShader.uniforms.tau.value;
  }, set:function(a) {
    g.adaptLuminanceShader.uniforms.tau.value = a;
  }}, adaptive:{get:function() {
    return g._adaptive;
  }, set:function(a) {
    a ? (this._adaptive = !0, this.materialToneMap.defines.ADAPTED_LUMINANCE = "", this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture) : (this._adaptive = !1, delete this.materialToneMap.defines.ADAPTED_LUMINANCE, this.materialToneMap.uniforms.luminanceMap.value = null);
    this.materialToneMap.needsUpdate = !0;
  }}});
}
AdaptiveToneMappingPass.prototype = Object.create(Pass.prototype);
AdaptiveToneMappingPass.prototype.constructor = AdaptiveToneMappingPass;
AdaptiveToneMappingPass.prototype.render = function(a, d, g, h, e) {
  this.needsInit && (this.reset(), this.luminanceRT.texture.type = g.texture.type, this.previousLuminanceRT.texture.type = g.texture.type, this.currentLuminanceRT.texture.type = g.texture.type, this.needsInit = !1);
  this._adaptive && (this.quad.material = this.materialLuminance, this.materialLuminance.uniforms.tDiffuse.value = g.texture, a.setRenderTarget(this.currentLuminanceRT), a.render(this.scene, this.camera), this.quad.material = this.materialAdaptiveLum, this.materialAdaptiveLum.uniforms.delta.value = h, this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture, this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture, a.setRenderTarget(this.luminanceRT), 
  a.render(this.scene, this.camera), this.quad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.luminanceRT.texture, a.setRenderTarget(this.previousLuminanceRT), a.render(this.scene, this.camera));
  this.quad.material = this.materialToneMap;
  this.materialToneMap.uniforms.tDiffuse.value = g.texture;
  this.clear ? (a.autoClear = !0, a.autoClearColor = !0, a.autoClearDepth = !0, a.autoClearStencil = !0) : a.autoClear = !1;
  a.setRenderTarget(this.renderToScreen ? null : d);
  a.render(this.scene, this.camera);
};
AdaptiveToneMappingPass.prototype.createShader = function() {
  this.adaptLuminanceShader = {defines:{MIP_LEVEL_1X1:(Math.log(this.resolution) / Math.log(2)).toFixed(1)}, uniforms:{lastLum:{value:null}, currentLum:{value:null}, minLuminance:{value:.01}, delta:{value:.016}, tau:{value:1}}, vertexShader:"varying vec2 vUv;\n\t\tvoid main(){\n\t\t\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t\t\n\t\t}", fragmentShader:"varying vec2 vUv;\n\t\t\n\t\tuniform sampler2D lastLum;\n\t\tuniform sampler2D currentLum;\n\t\tuniform float minLuminance;\n\t\tuniform float delta;\n\t\tuniform float tau;\n\t\t\n\t\tvoid main()\n\t\t{\n\t\t\tvec4 lastLum = texture2D(lastLum, vUv, MIP_LEVEL_1X1);\n\t\t\tvec4 currentLum = texture2D(currentLum, vUv, MIP_LEVEL_1X1);\n\t\t\t\n\t\t\tfloat fLastLum = max(minLuminance, lastLum.r);\n\t\t\tfloat fCurrentLum = max(minLuminance, currentLum.r);\n\t\t\t\n\t\t\t// The adaption seems to work better in extreme lighting differences if the input luminance is squared.\t\t\tfCurrentLum *= fCurrentLum;\n\t\t\t\n\t\t\t// Adapt the luminance using Pattanaik's technique\t\t\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\n\t\t\tgl_FragColor.r = fAdaptedLum;\n\t\t}"};
  this.materialAdaptiveLum = new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(this.adaptLuminanceShader.uniforms), vertexShader:this.adaptLuminanceShader.vertexShader, fragmentShader:this.adaptLuminanceShader.fragmentShader, defines:this.adaptLuminanceShader.defines, blending:THREE.NoBlending});
};
AdaptiveToneMappingPass.prototype.reset = function() {
  this.luminanceRT && this.luminanceRT.dispose();
  this.currentLuminanceRT && this.currentLuminanceRT.dispose();
  this.previousLuminanceRT && this.previousLuminanceRT.dispose();
  this.luminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, Pass.RGBALinear);
  this.luminanceRT.texture.generateMipmaps = !1;
  this.previousLuminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, Pass.RGBALinear);
  this.previousLuminanceRT.texture.generateMipmaps = !1;
  this.currentLuminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, {minFilter:THREE.LinearMipMapLinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBAFormat});
  this._adaptive && (this.materialToneMap.defines.ADAPTED_LUMINANCE = "", this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture);
  this.quad.material = new THREE.MeshBasicMaterial({color:7829367});
  this.materialLuminance.needsUpdate = !0;
  this.materialAdaptiveLum.needsUpdate = !0;
  this.materialToneMap.needsUpdate = !0;
};
AdaptiveToneMappingPass.prototype.dispose = function() {
  this.luminanceRT && this.luminanceRT.dispose();
  this.previousLuminanceRT && this.previousLuminanceRT.dispose();
  this.currentLuminanceRT && this.currentLuminanceRT.dispose();
  this.materialLuminance && this.materialLuminance.dispose();
  this.materialAdaptiveLum && this.materialAdaptiveLum.dispose();
  this.materialCopy && this.materialCopy.dispose();
  this.materialToneMap && this.materialToneMap.dispose();
};
AdaptiveToneMappingPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.minLuminance = this.minLuminance;
  a.tau = this.tau;
  a.adaptive = this._adaptive;
  return a;
};
"use strict";
var SSAOShader = {uniforms:{tDiffuse:{value:null}, tDepth:{value:null}, size:{value:new THREE.Vector2(512, 512)}, cameraNear:{value:1}, cameraFar:{value:100}, radius:{value:32}, onlyAO:{value:0}, aoClamp:{value:.25}, lumInfluence:{value:.7}}, vertexShader:"\n\tvarying vec2 vUv;\n\tvoid main()\n\t{\n\t\tvUv = uv;\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t}", fragmentShader:"\n\tuniform float cameraNear;\n\tuniform float cameraFar;\n\n\t#ifdef USE_LOGDEPTHBUF\n\t\tuniform float logDepthBufFC;\n\t#endif\n\n\tuniform float radius; // ao radius \n\tuniform bool onlyAO; // use only ambient occlusion pass?\n\n\tuniform vec2 size; // texture width, height\n\tuniform float aoClamp; // depth clamp - reduces haloing at screen edges\n\n\tuniform float lumInfluence; // how much luminance affects occlusion\n\n\tuniform sampler2D tDiffuse;\n\tuniform sampler2D tDepth;\n\n\tvarying vec2 vUv;\n\n\t#define DL 2.399963229728653 // PI *(3.0 - sqrt(5.0))\n\t#define EULER 2.718281828459045\n\n\t// user variables\n\tconst int samples = 64; // ao sample count\n\tconst bool useNoise = true; // use noise instead of pattern for sample dithering\n\tconst float noiseAmount = 0.0004; // dithering amount\n\tconst float diffArea = 0.4; // self-shadowing reduction\n\tconst float gDisplace = 0.4; // gauss bell center\n\n\t// RGBA depth\n\t#include <packing>\n\n\t// generating noise / pattern texture for dithering\n\tvec2 rand(const vec2 coord)\n\t{\n\t\tvec2 noise;\n\n\t\tif(useNoise)\n\t\t{\n\t\t\tfloat nx = dot(coord, vec2(12.9898, 78.233));\n\t\t\tfloat ny = dot(coord, vec2(12.9898, 78.233) * 2.0);\n\t\t\tnoise = clamp(fract(43758.5453 * sin(vec2(nx, ny))), 0.0, 1.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat ff = fract(1.0 - coord.s *(size.x / 2.0));\n\t\t\tfloat gg = fract(coord.t *(size.y / 2.0));\n\t\t\tnoise = vec2(0.25, 0.75) * vec2(ff) + vec2(0.75, 0.25) * gg;\n\t\t}\n\n\t\treturn(noise * 2.0  - 1.0) * noiseAmount;\n\t}\n\n\tfloat readDepth(const in vec2 coord) {\n\n\t\tfloat cameraFarPlusNear = cameraFar + cameraNear;\n\t\tfloat cameraFarMinusNear = cameraFar - cameraNear;\n\t\tfloat cameraCoef = 2.0 * cameraNear;\n\n\t\t#ifdef USE_LOGDEPTHBUF\n\t\t\tfloat logz = unpackRGBAToDepth(texture2D(tDepth, coord));\n\t\t\tfloat w = pow(2.0, (logz / logDepthBufFC)) - 1.0;\n\t\t\tfloat z = (logz / w) + 1.0;\n\t\t#else\n\t\t\tfloat z = unpackRGBAToDepth(texture2D(tDepth, coord));\n\t\t#endif\n\n\t\treturn cameraCoef /(cameraFarPlusNear - z * cameraFarMinusNear);\n\t}\n\n\tfloat compareDepths(const in float depth1, const in float depth2, inout int far)\n\t{\n\t\tfloat garea = 8.0; // gauss bell width\n\t\tfloat diff =(depth1 - depth2) * 100.0; // depth difference (0-100)\n\n\t\t// reduce left bell width to avoid self-shadowing\n\t\tif(diff < gDisplace)\n\t\t{\n\t\t\tgarea = diffArea;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfar = 1;\n\t\t}\n\n\t\tfloat dd = diff - gDisplace;\n\t\tfloat gauss = pow(EULER, -2.0 *(dd * dd) /(garea * garea));\n\t\treturn gauss;\n\t}\n\n\tfloat calcAO(float depth, float dw, float dh)\n\t{\n\t\tvec2 vv = vec2(dw, dh);\n\t\tvec2 coord1 = vUv + radius * vv;\n\t\tvec2 coord2 = vUv - radius * vv;\n\n\t\tfloat temp1 = 0.0;\n\t\tfloat temp2 = 0.0;\n\n\t\tint far = 0;\n\t\ttemp1 = compareDepths(depth, readDepth(coord1), far);\n\n\t\t// DEPTH EXTRAPOLATION\n\t\tif(far > 0)\n\t\t{\n\t\t\ttemp2 = compareDepths(readDepth(coord2), depth, far);\n\t\t\ttemp1 +=(1.0 - temp1) * temp2;\n\t\t}\n\n\t\treturn temp1;\n\t}\n\n\tvoid main()\n\t{\n\t\tvec2 noise = rand(vUv);\n\t\tfloat depth = readDepth(vUv);\n\n\t\tfloat tt = clamp(depth, aoClamp, 1.0);\n\n\t\tfloat w =(1.0 / size.x) / tt +(noise.x *(1.0 - noise.x));\n\t\tfloat h =(1.0 / size.y) / tt +(noise.y *(1.0 - noise.y));\n\n\t\tfloat ao = 0.0;\n\n\t\tfloat dz = 1.0 / float(samples);\n\t\tfloat l = 0.0;\n\t\tfloat z = 1.0 - dz / 2.0;\n\n\t\tfor(int i = 0; i <= samples; i ++)\n\t\t{\n\t\t\tfloat r = sqrt(1.0 - z);\n\n\t\t\tfloat pw = cos(l) * r;\n\t\t\tfloat ph = sin(l) * r;\n\t\t\tao += calcAO(depth, pw * w, ph * h);\n\t\t\tz = z - dz;\n\t\t\tl = l + DL;\n\t\t}\n\n\t\tao /= float(samples);\n\t\tao = 1.0 - ao;\n\n\t\tvec3 color = texture2D(tDiffuse, vUv).rgb;\n\n\t\tvec3 lumcoeff = vec3(0.299, 0.587, 0.114);\n\t\tfloat lum = dot(color.rgb, lumcoeff);\n\t\tvec3 luminance = vec3(lum);\n\n\t\tvec3 final = vec3(color * mix(vec3(ao), vec3(1.0), luminance * lumInfluence)); // mix(color * ao, white, luminance)\n\n\t\tif(onlyAO)\n\t\t{\n\t\t\tfinal = vec3(mix(vec3(ao), vec3(1.0), luminance * lumInfluence)); // ambient occlusion only\n\t\t}\n\n\t\tgl_FragColor = vec4(final, 1.0);\n\t}"};
"use strict";
function Resource(a, d) {
  this.name = a;
  this.uuid = THREE.Math.generateUUID();
  this.type = d;
  this.encoding = this.format = "";
  this.data = null;
}
Resource.prototype.export = function(a) {
  "base64" === this.format ? FileSystem.writeFileBase64(a, this.data) : "arraybuffer" === this.format ? FileSystem.writeFileArrayBuffer(a, void 0 !== this.arraybuffer ? this.arraybuffer : this.data) : "string" === this.format ? FileSystem.writeFile(a, this.data) : "json" === this.format ? FileSystem.writeFile(a, JSON.stringify(this.data)) : "url" === this.format && FileSystem.writeFileArrayBuffer(a, FileSystem.readFileArrayBuffer(this.data));
};
Resource.prototype.dispose = function() {
};
Resource.prototype.toJSON = function(a) {
  a = {};
  a.name = this.name;
  a.uuid = this.uuid;
  a.type = this.type;
  return a;
};
"use strict";
function Font(a) {
  Resource.call(this, "font", "Font");
  this.reversed = !1;
  this.font = null;
  if (void 0 !== a) {
    if (a instanceof ArrayBuffer) {
      this.data = a, this.format = "arraybuffer", this.loadTTF();
    } else {
      if ("object" === typeof a) {
        this.font = this.data = a, this.encoding = this.format = "json";
      } else {
        if (this.encoding = FileSystem.getFileExtension(a), this.name = FileSystem.getFileName(a), "json" === this.encoding) {
          this.data = JSON.parse(FileSystem.readFile(a)), this.format = "json", this.font = this.data;
        } else {
          if ("ttf" === this.encoding || "otf" === this.encoding || "ttc" === this.encoding || "otc" === this.encoding) {
            this.data = FileSystem.readFileArrayBuffer(a), this.format = "arraybuffer", this.loadTTF();
          }
        }
      }
    }
  }
}
Font.prototype = Object.create(Resource.prototype);
Font.fileIsFont = function(a) {
  return void 0 !== a ? (a = a.name.toLocaleLowerCase(), a.endsWith("ttf") || a.endsWith("otf") || a.endsWith("ttc") || a.endsWith("otc") || a.endsWith("json")) : !1;
};
Font.prototype.isFont = !0;
Font.prototype.reverseGlyphs = function() {
  this.reversed = !this.reversed;
  this.loadTTF();
};
Font.prototype.loadTTF = function() {
  var a = new THREE.TTFLoader;
  a.reversed = this.reversed;
  this.font = a.parse(this.data);
};
Font.prototype.toJSON = function(a) {
  if (void 0 !== a.fonts[this.uuid]) {
    return a.fonts[this.uuid];
  }
  var d = Resource.prototype.toJSON.call(this, a);
  d.encoding = this.encoding;
  d.reversed = this.reversed;
  "arraybuffer" === this.format ? (d.data = this.data, d.format = this.format) : "base64" === this.format ? (d.data = ArraybufferUtils.fromBase64(this.data), d.format = "arraybuffer") : (d.data = this.data, d.format = this.format);
  return a.fonts[this.uuid] = d;
};
Font.prototype.generateShapes = function(a, d, g) {
  void 0 === d && (d = 100);
  void 0 === g && (g = 10);
  var h = this.font;
  a = String(a).split("");
  var e = d / h.resolution, k = (h.boundingBox.yMax - h.boundingBox.yMin) * e, c = 0, p = 0;
  d = [];
  for (var t = 0; t < a.length; t++) {
    var f = a[t];
    if ("\n" === f) {
      p -= k, c = 0;
    } else {
      var n;
      var b = e;
      var m = c, q = p;
      if (f = h.glyphs[f] || h.glyphs["?"]) {
        var y = new THREE.ShapePath, x = [], z = THREE.ShapeUtils.b2, r = THREE.ShapeUtils.b3;
        if (f.o) {
          for (var u = f._cachedOutline || (f._cachedOutline = f.o.split(" ")), v = 0, C = u.length; v < C;) {
            var A = u[v++];
            if ("m" === A) {
              var D = u[v++] * b + m;
              var F = u[v++] * b + q;
              y.moveTo(D, F);
            }
            if ("l" === A) {
              D = u[v++] * b + m, F = u[v++] * b + q, y.lineTo(D, F);
            } else {
              if ("q" === A) {
                var B = u[v++] * b + m;
                var E = u[v++] * b + q;
                var H = u[v++] * b + m;
                A = u[v++] * b + q;
                y.quadraticCurveTo(H, A, B, E);
                if (n = x[x.length - 1]) {
                  var L = n.x;
                  n = n.y;
                  for (var K = 1; K <= g; K++) {
                    var P = K / g;
                    z(P, L, H, B);
                    z(P, n, A, E);
                  }
                }
              } else {
                if ("b" === A && (B = u[v++] * b + m, E = u[v++] * b + q, H = u[v++] * b + m, A = u[v++] * b + q, D = u[v++] * b + m, F = u[v++] * b + q, y.bezierCurveTo(H, A, D, F, B, E), n = x[x.length - 1])) {
                  for (L = n.x, n = n.y, K = 1; K <= g; K++) {
                    P = K / g, r(P, L, H, D, B), r(P, n, A, F, E);
                  }
                }
              }
            }
          }
        }
        b = {width:f.ha * b, path:y};
      } else {
        b = void 0;
      }
      c += b.width;
      d.push(b.path);
    }
  }
  g = [];
  for (h = 0; h < d.length; h++) {
    Array.prototype.push.apply(g, d[h].toShapes());
  }
  return g;
};
"use strict";
function Video(a, d) {
  Resource.call(this, "video", "Video");
  void 0 !== a && (a instanceof ArrayBuffer ? this.loadArrayBufferData(a, d) : Base64Utils.isBase64(a) ? (this.encoding = Base64Utils.getFileFormat(a), this.format = "base64", this.data = a) : this.loadArrayBufferData(FileSystem.readFileArrayBuffer(a), FileSystem.getFileExtension(a)));
}
Video.prototype = Object.create(Resource.prototype);
Video.fileIsVideo = function(a) {
  return void 0 !== a && a.type.startsWith("video") ? !0 : !1;
};
Video.prototype.loadArrayBufferData = function(a, d) {
  var g = new Uint8Array(a);
  g = new Blob([g], {type:"video/" + d});
  this.data = URL.createObjectURL(g);
  this.arraybuffer = a;
  this.encoding = d;
  this.format = "arraybuffer";
};
Video.prototype.toJSON = function(a) {
  if (void 0 !== a.videos[this.uuid]) {
    return a.videos[this.uuid];
  }
  var d = Resource.prototype.toJSON.call(this, a);
  d.encoding = this.encoding;
  "arraybuffer" === this.format ? (d.format = this.format, d.data = this.arraybuffer) : "base64" === this.format ? (d.format = "arraybuffer", d.data = ArraybufferUtils.fromBase64(Base64Utils.removeHeader(this.data))) : (d.format = this.format, d.data = this.data);
  return a.videos[this.uuid] = d;
};
"use strict";
function Audio(a, d) {
  Resource.call(this, "audio", "Audio");
  void 0 !== a && (a instanceof ArrayBuffer ? (this.data = a, this.encoding = void 0 !== d ? d : "") : Base64Utils.isBase64(a) ? (this.encoding = void 0 !== d ? d : "", this.data = ArraybufferUtils.fromBase64(a)) : (this.data = FileSystem.readFileArrayBuffer(a), this.encoding = FileSystem.getFileExtension(a)), this.format = "arraybuffer");
}
Audio.prototype = Object.create(Resource.prototype);
Audio.fileIsAudio = function(a) {
  return void 0 !== a && a.type.startsWith("audio") ? !0 : !1;
};
Audio.prototype.getAudioBuffer = function(a, d) {
  a.decodeAudioData(this.data.slice(0), d, function(a) {
    console.error("nunuStudio: Cannot decode audio buffer (" + a + ")");
  });
};
Audio.prototype.toJSON = function(a) {
  if (void 0 !== a.audio[this.uuid]) {
    return a.audio[this.uuid];
  }
  var d = Resource.prototype.toJSON.call(this, a);
  d.encoding = this.encoding;
  d.data = this.data;
  d.format = this.format;
  return a.audio[this.uuid] = d;
};
"use strict";
function Image(a, d) {
  Resource.call(this, "image", "Image");
  this.height = this.width = -1;
  void 0 !== a ? a instanceof ArrayBuffer ? this.loadArrayBufferData(a, d) : Base64Utils.isBase64(a) ? (this.encoding = Base64Utils.getFileFormat(a), this.format = "base64", this.data = a) : a.startsWith("blob") ? (a = FileSystem.readFileArrayBuffer(a, !0), this.loadArrayBufferData(a)) : (this.encoding = FileSystem.getFileExtension(a), this.format = "url", this.data = a) : this.createSolidColor();
}
Image.prototype = Object.create(Resource.prototype);
Image.fileIsImage = function(a) {
  if (void 0 !== a) {
    if (a.type.startsWith("image")) {
      return !0;
    }
    a = a.name.toLocaleLowerCase();
    return a.endsWith("tga") || a.endsWith("dds") || a.endsWith("pvr") || a.endsWith("ktx") || a.endsWith("basis");
  }
  return !1;
};
Image.prototype.createSolidColor = function(a) {
  var d = document.createElement("canvas");
  d.width = 1;
  d.height = 1;
  var g = d.getContext("2d");
  g.fillStyle = void 0 !== a ? a : MathUtils.randomColor();
  g.fillRect(0, 0, 1, 1);
  this.data = d.toDataURL("image/png");
  this.format = "base64";
  this.encoding = "png";
};
Image.prototype.loadArrayBufferData = function(a, d) {
  var g = new Uint8Array(a);
  g = new Blob([g], {type:"image/" + d});
  this.data = URL.createObjectURL(g);
  this.arraybuffer = a;
  this.encoding = void 0 !== d ? d : "";
  this.format = "arraybuffer";
};
Image.prototype.hasTransparency = function(a) {
  if (!0 === a) {
    a = document.createElement("img");
    a.src = this.data;
    var d = document.createElement("canvas");
    d.width = a.width;
    d.height = a.height;
    d = d.getContext("2d");
    d.drawImage(a, 0, 0, a.width, a.height);
    a = d.getImageData(0, 0, a.width, a.height).data;
    for (d = 3; d < a.length; d += 4) {
      if (255 !== a[d]) {
        return !0;
      }
    }
    return !1;
  }
  return "png" === this.encoding || "gif" === this.encoding;
};
Image.prototype.compressJPEG = function(a) {
  var d = document.createElement("img");
  d.src = this.data;
  var g = document.createElement("canvas");
  g.width = d.width;
  g.height = d.height;
  g.getContext("2d").drawImage(d, 0, 0, d.width, d.height);
  var h = this;
  g.toBlob(function(a) {
    var d = new FileReader;
    d.onload = function() {
      h.encoding = "jpeg";
      h.format = "arraybuffer";
      h.data = d.result;
    };
    d.readAsArrayBuffer(a);
  }, "image/jpeg", void 0 !== a ? a : .7);
};
Image.prototype.dispose = function() {
  "arraybuffer" === this.format && URL.revokeObjectURL(this.data);
};
Image.prototype.toJSON = function(a) {
  if (void 0 !== a.images[this.uuid]) {
    return a.images[this.uuid];
  }
  var d = Resource.prototype.toJSON.call(this, a);
  "url" === this.format && this.loadArrayBufferData(FileSystem.readFileArrayBuffer(this.data), this.encoding);
  d.width = this.width;
  d.height = this.height;
  d.encoding = this.encoding;
  "arraybuffer" === this.format ? (d.format = this.format, d.data = this.arraybuffer) : "base64" === this.format ? (d.format = "arraybuffer", d.data = ArraybufferUtils.fromBase64(Base64Utils.removeHeader(this.data))) : (d.format = this.format, d.data = this.data);
  return a.images[this.uuid] = d;
};
"use strict";
function Model() {
  Resource.call(this, "model", "Model");
}
Model.prototype = Object.create(Resource.prototype);
Model.extensions = "gcode drc assimp assimp.json blend amf babylon prwm svg obj 3ds dae gltf glb 3mf awd ply vtk vtp wrl vrml fbx pcd stl json x".split(" ");
Model.fileIsModel = function(a) {
  if (void 0 !== a) {
    a = a.name.toLocaleLowerCase();
    for (var d = 0; d < Model.extensions.length; d++) {
      if (a.endsWith(Model.extensions[d])) {
        return !0;
      }
    }
  }
  return !1;
};
"use strict";
function TextFile(a, d) {
  Resource.call(this, "text", "TextFile");
  this.format = "string";
  this.encoding = void 0 !== d ? d : "txt";
  this.data = void 0 !== a ? a : "";
}
TextFile.prototype = Object.create(Resource.prototype);
TextFile.extensions = ".js .txt .glsl .json .xml .yaml .csv .css .html".split(" ");
TextFile.fileIsText = function(a) {
  a = a.name.toLocaleLowerCase();
  for (var d = 0; d < TextFile.extensions.length; d++) {
    if (a.endsWith(TextFile.extensions[d])) {
      return !0;
    }
  }
  return !1;
};
TextFile.prototype.toJSON = function(a) {
  if (void 0 !== a.resources[this.uuid]) {
    return a.resources[this.uuid];
  }
  var d = Resource.prototype.toJSON.call(this, a);
  d.encoding = this.encoding;
  d.data = this.data;
  d.format = this.format;
  return a.resources[this.uuid] = d;
};
"use strict";
function ResourceContainer() {
  this.images = [];
  this.videos = [];
  this.audio = [];
  this.fonts = [];
  this.materials = [];
  this.textures = [];
  this.geometries = [];
  this.resources = [];
  this.shapes = [];
  this.skeletons = [];
}
ResourceContainer.libraries = "images videos audio fonts materials textures geometries resources shapes skeletons".split(" ");
ResourceContainer.prototype.copyResources = function(a) {
  this.materials = a.materials;
  this.textures = a.textures;
  this.resources = a.resources;
  this.fonts = a.fonts;
  this.audio = a.audio;
  this.geometries = a.geometries;
  this.images = a.images;
  this.videos = a.videos;
  this.shapes = a.shapes;
  this.skeletons = a.skeletons;
};
ResourceContainer.prototype.getTexture = function(a) {
  void 0 === this.textures[a] && console.warn("ResourceContainer: Undefined texture", a);
  return this.textures[a];
};
ResourceContainer.prototype.getGeometry = function(a) {
  void 0 === this.geometries[a] && console.warn("ResourceContainer: Undefined geometry", a);
  return this.geometries[a];
};
ResourceContainer.prototype.getMaterial = function(a) {
  if (a instanceof Array) {
    for (var d = [], g = 0; g < a.length; g++) {
      void 0 === this.materials[a[g]] && console.warn("ResourceContainer: Undefined material", a), d.push(this.materials[a[g]]);
    }
    return d;
  }
  void 0 === this.materials[a] && console.warn("ResourceContainer: Undefined material", a);
  return this.materials[a];
};
ResourceContainer.prototype.getFont = function(a) {
  void 0 === this.fonts[a] && console.warn("ResourceContainer: Undefined font", a);
  return this.fonts[a];
};
ResourceContainer.prototype.getAudio = function(a) {
  void 0 === this.audio[a] && console.warn("ResourceContainer: Undefined audio", a);
  return this.audio[a];
};
"use strict";
function ResourceManager() {
  THREE.Object3D.call(this);
  ResourceContainer.call(this);
}
ResourceManager.prototype = Object.create(THREE.Object3D.prototype);
Object.assign(ResourceManager.prototype, ResourceContainer.prototype);
ResourceManager.prototype.dispose = function() {
  for (var a = 0; a < ResourceContainer.libraries.length; a++) {
    var d = ResourceContainer.libraries[a], g;
    for (g in this[d]) {
      this[d][g].dispose instanceof Function && this[d][g].dispose();
    }
  }
};
ResourceManager.prototype.removeGeometry = function(a, d) {
  this.traverse(function(g) {
    void 0 !== g.geometry && g.geometry.uuid === a.uuid && (g.geometry = d);
  });
  delete this.geometries[a.uuid];
};
ResourceManager.prototype.getResourceByName = function(a) {
  for (var d in this.resources) {
    if (this.resources[d].name === a) {
      return this.resources[d];
    }
  }
  console.warn("nunuStudio: Resource " + a + " not found");
  return null;
};
ResourceManager.prototype.addResource = function(a) {
  a instanceof Resource && (this.resources[a.uuid] = a);
};
ResourceManager.prototype.removeResource = function(a) {
  delete this.resources[a.uuid];
};
ResourceManager.prototype.getImageByName = function(a) {
  for (var d in this.images) {
    if (this.images[d].name === a) {
      return this.images[d];
    }
  }
  console.warn("nunuStudio: Resource " + a + " not found");
  return null;
};
ResourceManager.prototype.removeImage = function(a) {
  a instanceof Image && delete this.images[a.uuid];
};
ResourceManager.prototype.getVideoByName = function(a) {
  for (var d in this.videos) {
    if (this.videos[d].name === a) {
      return this.videos[d];
    }
  }
  console.warn("nunuStudio: Resource " + a + " not found");
  return null;
};
ResourceManager.prototype.removeVideo = function(a) {
  a instanceof Video && delete this.videos[a.uuid];
};
ResourceManager.prototype.getMaterialByName = function(a) {
  for (var d in this.materials) {
    if (this.materials[d].name === a) {
      return this.materials[d];
    }
  }
  console.warn("nunuStudio: Resource " + a + " not found");
  return null;
};
ResourceManager.prototype.addMaterial = function(a) {
  a instanceof THREE.Material && (this.materials[a.uuid] = a);
};
ResourceManager.prototype.removeMaterial = function(a, d, g) {
  void 0 === d && (d = new THREE.MeshBasicMaterial);
  void 0 === g && (g = new THREE.SpriteMaterial);
  a instanceof THREE.Material && (delete this.materials[a.uuid], this.traverse(function(h) {
    void 0 !== h.material && h.material.uuid === a.uuid && (h.material = h instanceof THREE.Sprite ? g : d);
  }));
};
ResourceManager.prototype.getTextureByName = function(a) {
  for (var d in this.textures) {
    if (this.textures[d].name === a) {
      return this.textures[d];
    }
  }
  console.warn("nunuStudio: Resource " + a + " not found");
  return null;
};
ResourceManager.prototype.addTexture = function(a) {
  material instanceof THREE.Texture && (this.textures[a.uuid] = a);
};
ResourceManager.prototype.removeTexture = function(a, d) {
  void 0 === d && (d = new THREE.Texture);
  a instanceof THREE.Texture && (delete this.textures[a.uuid], this.traverse(function(g) {
    void 0 !== g.material ? (g = g.material, null != g.map && g.map.uuid === a.uuid && (g.map = d, g.needsUpdate = !0), null != g.bumpMap && g.bumpMap.uuid === a.uuid && (g.bumpMap = d, g.needsUpdate = !0), null != g.normalMap && g.normalMap.uuid === a.uuid && (g.normalMap = d, g.needsUpdate = !0), null != g.displacementMap && g.displacementMap.uuid === a.uuid && (g.displacementMap = d, g.needsUpdate = !0), null != g.specularMap && g.specularMap.uuid === a.uuid && (g.specularMap = d, g.needsUpdate = 
    !0), null != g.emissiveMap && g.emissiveMap.uuid === a.uuid && (g.emissiveMap = d, g.needsUpdate = !0), null != g.alphaMap && g.alphaMap.uuid === a.uuid && (g.alphaMap = d, g.needsUpdate = !0), null != g.roughnessMap && g.roughnessMap.uuid === a.uuid && (g.roughnessMap = d, g.needsUpdate = !0), null != g.metalnessMap && g.metalnessMap.uuid === a.uuid && (g.metalnessMap = d, g.needsUpdate = !0), null != g.envMap && g.envMap.uuid === a.uuid && (g.envMap = null, g.needsUpdate = !0)) : g instanceof 
    ParticleEmitter && g.group.texture.uuid === a.uuid && (g.group.texture = d);
  }));
};
ResourceManager.prototype.getFontByName = function(a) {
  for (var d in this.fonts) {
    if (this.fonts[d].name === a) {
      return this.fonts[d];
    }
  }
  console.warn("nunuStudio: Resource " + a + " not found");
  return null;
};
ResourceManager.prototype.addFont = function(a) {
  a instanceof Font && (this.fonts[a.uuid] = a);
};
ResourceManager.prototype.removeFont = function(a, d) {
  void 0 === d && (d = new Font);
  a instanceof Font && (delete this.fonts[a.uuid], this.traverse(function(g) {
    void 0 !== g.font && g.font.uuid === a.uuid && g.setFont(d);
  }));
};
ResourceManager.prototype.getAudioByName = function(a) {
  for (var d in this.audio) {
    if (this.audio[d].name === a) {
      return this.audio[d];
    }
  }
  console.warn("nunuStudio: Resource " + a + " not found");
  return null;
};
ResourceManager.prototype.addAudio = function(a) {
  a instanceof Audio && (this.audio[a.uuid] = a);
};
ResourceManager.prototype.removeAudio = function(a, d) {
  void 0 === d && (d = new Audio);
  a instanceof Audio && (delete this.audio[a.uuid], this.traverse(function(g) {
    void 0 !== g.audio && g.audio.uuid === a.uuid && g.setAudio(d);
  }));
};
"use strict";
function VideoStream(a) {
  Video.call(this);
  this.format = "url";
  this.encoding = FileSystem.getFileExtension(a);
  this.data = a;
}
VideoStream.prototype = Object.create(Video.prototype);
"use strict";
function Texture(a, d, g, h, e, k, c, p, t, f) {
  this.source = "string" === typeof a ? new Image(a) : void 0 === a ? new Image : a;
  THREE.Texture.call(this, document.createElement("img"), d, g, h, e, k, c, p, t, f);
  var n = this;
  this.name = "texture";
  this.category = "Image";
  this.disposed = !1;
  this.format = this.source.hasTransparency() ? THREE.RGBAFormat : THREE.RGBFormat;
  this.image.src = this.source.data;
  this.image.onload = function() {
    n.needsUpdate = !0;
  };
  this.image.onerror = function() {
    console.log("nunuStudio: Failed to load image " + n.source.uuid + " data.");
    n.source.createSolidColor();
    n.image.src = n.source.data;
    n.needsUpdate = !0;
  };
  if ("gif" === this.source.encoding) {
    var b = function() {
      n.disposed || (n.needsUpdate = !0, requestAnimationFrame(b));
    };
    this.generateMipmaps = !1;
    this.minFilter = this.magFilter = THREE.LinearFilter;
    b();
  }
}
Texture.prototype = Object.create(THREE.Texture.prototype);
Texture.isTexture = !0;
Texture.prototype.dispose = function() {
  THREE.Texture.prototype.dispose.call(this);
  this.disposed = !0;
};
Texture.prototype.toJSON = function(a) {
  var d = THREE.Texture.prototype.toJSON.call(this, a);
  a = this.source.toJSON(a);
  d.image = a.uuid;
  return d;
};
"use strict";
function CanvasTexture(a, d, g, h, e, k, c, p, t, f, n) {
  THREE.Texture.call(this, document.createElement("canvas"), g, h, e, k, c, p, t, f, n);
  this.name = "canvas";
  this.category = "Canvas";
  this.format = THREE.RGBAFormat;
  Object.defineProperties(this, {width:{get:function() {
    return this.image.width;
  }, set:function(a) {
    this.image.width = a;
  }}, height:{get:function() {
    return this.image.height;
  }, set:function(a) {
    this.image.height = a;
  }}});
  this.width = void 0 !== a ? a : 1;
  this.height = void 0 !== d ? d : 1;
  this.context = this.image.getContext("2d");
}
CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = !0;
CanvasTexture.prototype.placeholder = function() {
  this.context.fillStyle = "#000000";
  this.context.fillRect(0, 0, this.width, this.height);
  this.context.font = "Normal " + Math.round(this.width / 12) + "px Arial";
  this.context.textAlign = "center";
  this.context.fillStyle = "#FF0000";
  this.context.fillText("Canvas Texture", this.width / 2, this.height / 2);
  this.needsUpdate = !0;
};
CanvasTexture.prototype.clear = function(a) {
  void 0 === a ? this.context.clearRect(0, 0, width, height) : (this.context.fillStyle = a, this.context.fillRect(0, 0, this.width, this.height));
};
CanvasTexture.prototype.toJSON = function(a) {
  a = THREE.Texture.prototype.toJSON.call(this, a);
  a.width = this.width;
  a.height = this.height;
  return a;
};
"use strict";
function VideoTexture(a, d, g, h, e, k) {
  function c() {
    p.disposed || (p.image.readyState >= p.image.HAVE_CURRENT_DATA && (p.needsUpdate = !0), requestAnimationFrame(c));
  }
  THREE.Texture.call(this, document.createElement("video"), d, g, h, THREE.LinearFilter, THREE.LinearFilter, THREE.RGBFormat, e, k);
  this.generateMipmaps = this.disposed = !1;
  this.name = "video";
  this.category = "Video";
  this.loop = this.autoplay = !0;
  this.volume = this.playbackRate = 1;
  this.image.crossOrigin = "anonymous";
  this.image.autoplay = this.autoplay;
  this.image.playbackRate = this.playbackRate;
  this.image.loop = this.loop;
  this.image.volume = this.volume;
  this.video = null;
  this.setVideo(a);
  var p = this;
  c();
}
VideoTexture.prototype = Object.create(THREE.Texture.prototype);
VideoTexture.isVideoTexture = !0;
VideoTexture.prototype.setVideo = function(a) {
  null === a || void 0 === a ? (this.video = null, this.image.src = null) : ("string" === typeof a ? this.video = new Video(a) : a instanceof Video && (this.video = a), this.image.src = this.video.data);
};
VideoTexture.prototype.setTime = function(a) {
  this.image.currentTime = a;
};
VideoTexture.prototype.setLoop = function(a) {
  this.loop = a;
  this.image.loop = a;
};
VideoTexture.prototype.setVolume = function(a) {
  this.volume = 0 <= a && 1 >= a ? a : 0 <= a ? 1 : 0;
  this.image.volume = this.volume;
};
VideoTexture.prototype.setAutoPlay = function(a) {
  this.autoplay = a;
  this.image.autoplay = this.autoplay;
};
VideoTexture.prototype.setPlaybackRate = function(a) {
  this.playbackRate = a;
  this.image.playbackRate = a;
};
VideoTexture.prototype.pause = function() {
  this.image.paused || this.image.pause();
};
VideoTexture.prototype.play = function() {
  this.image.paused && this.image.play();
};
VideoTexture.prototype.dispose = function() {
  THREE.Texture.prototype.dispose.call(this);
  this.disposed = !0;
  this.image.pause();
  this.image.src = "";
  this.image.load();
};
VideoTexture.prototype.toJSON = function(a) {
  var d = THREE.Texture.prototype.toJSON.call(this, a);
  a = this.video.toJSON(a);
  d.video = a.uuid;
  d.loop = this.loop;
  d.autoplay = this.autoplay;
  d.playbackRate = this.playbackRate;
  d.volume = this.volume;
  return d;
};
"use strict";
function WebcamTexture(a, d, g, h, e) {
  function k() {
    c.readyState >= c.HAVE_CURRENT_DATA && (p.needsUpdate = !0);
    p.disposed || requestAnimationFrame(k);
  }
  var c = document.createElement("video");
  c.autoplay = !0;
  c.loop = !0;
  THREE.Texture.call(this, c, a, d, g, THREE.LinearFilter, THREE.LinearFilter, THREE.RGBFormat, h, e);
  var p = this;
  this.disposed = this.generateMipmaps = !1;
  this.name = "webcam";
  this.category = "Webcam";
  this.mode = WebcamTexture.USER;
  this.stream = null;
  this.connect();
  requestAnimationFrame(k);
}
WebcamTexture.USER = 21;
WebcamTexture.ENVIRONMENT = 22;
WebcamTexture.prototype = Object.create(THREE.Texture.prototype);
WebcamTexture.prototype.constructor = WebcamTexture;
WebcamTexture.isTexture = !0;
WebcamTexture.prototype.connect = function() {
  var a = {facingMode:this.mode === WebcamTexture.USER ? "user" : {exact:"environment"}}, d = this;
  void 0 !== navigator.webkitGetUserMedia && (navigator.getUserMedia = navigator.webkitGetUserMedia);
  navigator.mediaDevices && navigator.mediaDevices.getUserMedia ? navigator.mediaDevices.getUserMedia({video:a}).then(function(a) {
    d.stream = a;
    d.image.srcObject = a;
    d.image.play();
  }).catch(function(a) {
    console.warn("nunuStudio: No webcam available");
  }) : navigator.getUserMedia && navigator.getUserMedia({video:!0}, function(a) {
    d.stream = a;
    d.image.src = URL.createObjectURL(a);
  }, function(a) {
    console.warn("nunuStudio: No webcam available");
  });
};
WebcamTexture.prototype.disconnect = function() {
  if (null !== this.stream) {
    for (var a = this.stream.getTracks(), d = 0; d < a.length; d++) {
      a[d].stop();
    }
  }
};
WebcamTexture.prototype.dispose = function() {
  THREE.Texture.prototype.dispose.call(this);
  this.disconnect();
  this.disposed = !0;
  this.image.paused || this.image.pause();
};
WebcamTexture.prototype.toJSON = function(a) {
  a = THREE.Texture.prototype.toJSON.call(this, a);
  a.mode = this.mode;
  return a;
};
"use strict";
function CubeTexture(a, d, g, h, e, k, c, p, t, f) {
  void 0 === d && (d = THREE.CubeReflectionMapping);
  for (var n = [], b = 0; 6 > b; b++) {
    n.push(document.createElement("canvas"));
  }
  THREE.Texture.call(this, n, d, g, h, e, k, c, p, t, f);
  this.images = void 0 !== a ? a : [];
  this.size = 512;
  this.flipY = !1;
  this.mode = 6 === this.images.length ? CubeTexture.CUBE : CubeTexture.CROSS;
  0 < this.images.length && this.updateImages();
  this.name = "cubetexture";
  this.category = "Cube";
}
CubeTexture.prototype = Object.create(THREE.Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = !0;
CubeTexture.RIGHT = 0;
CubeTexture.LEFT = 1;
CubeTexture.TOP = 2;
CubeTexture.BOTTOM = 3;
CubeTexture.FRONT = 4;
CubeTexture.BACK = 5;
CubeTexture.CUBE = 20;
CubeTexture.CROSS = 21;
CubeTexture.EQUIRECTANGULAR = 22;
CubeTexture.prototype.setSize = function(a) {
  0 !== (a & a - 1) ? console.warn("nunuStudio: CubeTexture new size is not a power of two.") : this.size = a;
};
CubeTexture.prototype.setImages = function(a, d) {
  this.mode = void 0 !== d ? d : CubeTexture.CUBE;
  this.images = a;
};
CubeTexture.prototype.updateImages = function() {
  var a = this;
  if (this.mode === CubeTexture.CUBE) {
    for (var d = 0; d < this.images.length; d++) {
      "string" === typeof this.images[d] && (this.images[d] = new Image(this.images[d]));
      var g = document.createElement("img");
      g.crossOrigin = "anonymous";
      g.index = d;
      g.src = this.images[d].data;
      g.onload = function() {
        a.image[this.index].width = a.size;
        a.image[this.index].height = a.size;
        a.image[this.index].getContext("2d").drawImage(this, 0, 0, a.size, a.size);
        a.needsUpdate = !0;
      };
    }
  } else {
    if (this.mode === CubeTexture.CROSS) {
      for (d = 0; d < this.image.length; d++) {
        this.image[d].width = this.size, this.image[d].height = this.size;
      }
      g = document.createElement("img");
      g.src = this.images[0].data;
      g.onload = function() {
        var d = this.naturalWidth / 4, e = this.naturalHeight / 3;
        a.image[CubeTexture.LEFT].getContext("2d").drawImage(this, 0, e, d, e, 0, 0, a.size, a.size);
        a.image[CubeTexture.FRONT].getContext("2d").drawImage(this, d, e, d, e, 0, 0, a.size, a.size);
        a.image[CubeTexture.RIGHT].getContext("2d").drawImage(this, 2 * d, e, d, e, 0, 0, a.size, a.size);
        a.image[CubeTexture.BACK].getContext("2d").drawImage(this, 3 * d, e, d, e, 0, 0, a.size, a.size);
        a.image[CubeTexture.TOP].getContext("2d").drawImage(this, d, 0, d, e, 0, 0, a.size, a.size);
        a.image[CubeTexture.BOTTOM].getContext("2d").drawImage(this, d, 2 * e, d, e, 0, 0, a.size, a.size);
        a.needsUpdate = !0;
      };
    } else {
      if (this.mode === CubeTexture.EQUIRECTANGULAR) {
        for (d = 0; d < this.image.length; d++) {
          this.image[d].width = this.size, this.image[d].height = this.size;
        }
        g = document.createElement("img");
        g.src = this.images[0].data;
        g.onload = function() {
          var d = document.createElement("canvas");
          d.width = g.naturalWidth;
          d.height = g.naturalHeight;
          var e = d.getContext("2d");
          e.drawImage(g, 0, 0);
          d = e.getImageData(0, 0, d.width, d.height);
          for (e = 0; 6 > e; e++) {
            var k = CubeTexture.renderEquirectFace(d, e, Math.PI, a.size);
            a.image[e].getContext("2d").putImageData(k, 0, 0);
          }
          a.needsUpdate = !0;
        };
      }
    }
  }
};
CubeTexture.resampleBilinear = function(a, d, g, h, e) {
  var k = a.width, c = a.height;
  a = a.data;
  var p = THREE.Math.clamp(Math.floor(g), 0, k - 1), t = THREE.Math.clamp(Math.ceil(g), 0, k - 1);
  g -= p;
  var f = THREE.Math.clamp(Math.floor(h), 0, c - 1), n = THREE.Math.clamp(Math.ceil(h), 0, c - 1);
  h -= f;
  c = 4 * (f * k + p);
  f = 4 * (f * k + t);
  p = 4 * (n * k + p);
  k = 4 * (n * k + t);
  for (t = 0; 3 > t; t++) {
    d.data[e + t] = Math.ceil((a[c + t] * (1 - g) + a[f + t] * g) * (1 - h) + (a[p + t] * (1 - g) + a[k + t] * g) * h);
  }
};
CubeTexture.renderEquirectFace = function(a, d, g, h) {
  var e = new ImageData(h, h);
  d = CubeTexture.faces[d];
  for (var k = 0; k < h; k++) {
    for (var c = 0; c < h; c++) {
      var p = 4 * (c * h + k);
      e.data[p + 3] = 255;
      var t = d(2 * (k + .5) / h - 1, 2 * (c + .5) / h - 1), f = Math.sqrt(t.x * t.x + t.y * t.y + t.z * t.z), n = THREE.Math.euclideanModulo(Math.atan2(t.y, t.x) + g, 2 * Math.PI);
      CubeTexture.resampleBilinear(a, e, a.width * n / Math.PI / 2 - .5, a.height * Math.acos(t.z / f) / Math.PI - .5, p);
    }
  }
  return e;
};
CubeTexture.faces = [function(a, d) {
  return new THREE.Vector3(a, -1, -d);
}, function(a, d) {
  return new THREE.Vector3(-a, 1, -d);
}, function(a, d) {
  return new THREE.Vector3(-d, -a, 1);
}, function(a, d) {
  return new THREE.Vector3(d, -a, -1);
}, function(a, d) {
  return new THREE.Vector3(-1, -a, -d);
}, function(a, d) {
  return new THREE.Vector3(1, a, -d);
}];
CubeTexture.prototype.toJSON = function(a) {
  var d = THREE.Texture.prototype.toJSON.call(this, a);
  d.size = this.size;
  d.mode = this.mode;
  d.images = [];
  if (this.mode === CubeTexture.EQUIRECTANGULAR || this.mode === CubeTexture.CROSS) {
    var g = this.images[0].toJSON(a);
    d.images.push(g.uuid);
  } else {
    for (var h = 0; h < this.images.length; h++) {
      g = this.images[h].toJSON(a), d.images.push(g.uuid);
    }
  }
  return d;
};
"use strict";
function DataTexture(a, d, g, h, e, k, c, p, t, f, n, b) {
  THREE.Texture.call(this, null, k, c, p, t, f, h, e, n, b);
  this.category = "DataTexture";
  this.image = {data:a || null, width:d || 1, height:g || 1};
  this.magFilter = void 0 !== t ? t : NearestFilter;
  this.minFilter = void 0 !== f ? f : NearestFilter;
  this.flipY = this.generateMipmaps = !1;
  this.unpackAlignment = 1;
  this.needsUpdate = !0;
}
THREE.DataTexture = DataTexture;
DataTexture.prototype = Object.create(THREE.Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = !0;
DataTexture.prototype.toJSON = function(a) {
  a = THREE.Texture.prototype.toJSON.call(this, a);
  a.image = {height:this.image.height, width:this.image.width, data:Array.from(this.image.data)};
  return a;
};
"use strict";
function CompressedTexture(a, d, g, h, e, k, c, p, t, f, n, b) {
  THREE.Texture.call(this, null, k, c, p, t, f, h, e, n, b);
  this.category = "Compressed";
  this.image = {width:d, height:g};
  this.mipmaps = a;
  this.generateMipmaps = this.flipY = this.isCubeTexture = !1;
}
CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = !0;
CompressedTexture.prototype.toJSON = function(a) {
  a = THREE.Texture.prototype.toJSON.call(this, a);
  if (a.isCubeTexture = this.isCubeTexture) {
    a.image = [];
    for (var d = 0; d < this.image.length; d++) {
      for (var g = {mipmaps:[], format:this.image[d].format, width:this.image[d].width, height:this.image[d].height}, h = 0; h < this.image[d].mipmaps.length; h++) {
        g.mipmaps.push({width:this.image[d].mipmaps[h].width, height:this.image[d].mipmaps[h].height, data:this.image[d].mipmaps[h].data});
      }
      a.image.push(g);
    }
  } else {
    for (a.mipmaps = [], a.width = this.image.width, a.height = this.image.height, h = 0; h < this.mipmaps.length; h++) {
      a.mipmaps.push({width:this.mipmaps[h].width, height:this.mipmaps[h].height, data:this.mipmaps[h].data});
    }
  }
  return a;
};
"use strict";
function SpriteSheetTexture(a, d, g, h, e, k, c) {
  function p() {
    t.disposed || (t.step(), setTimeout(p, 1E3 * t.animationSpeed));
  }
  "string" === typeof a ? this.source = new Image(a) : a instanceof Image && (this.source = a);
  THREE.Texture.call(this, document.createElement("img"), e, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.LinearFilter, THREE.LinearFilter, THREE.RGBFormat, k, c);
  this.name = "animation";
  this.category = "SpriteSheet";
  this.disposed = !1;
  this.format = this.source.hasTransparency() ? THREE.RGBAFormat : THREE.RGBFormat;
  this.repeat.set(1 / d, 1 / g);
  this.loop = !0;
  this.animationSpeed = .1;
  this._totalFrames = h;
  this._endFrame = this._beginFrame = 0;
  this._framesHorizontal = d;
  this._framesVertical = g;
  var t = this;
  Object.defineProperties(this, {framesHorizontal:{get:function() {
    return this._framesHorizontal;
  }, set:function(a) {
    this._framesHorizontal = a;
    this.repeat.x = 1 / a;
    this.totalFrames = this._framesHorizontal * this._framesVertical;
  }}, framesVertical:{get:function() {
    return this._framesVertical;
  }, set:function(a) {
    this._framesVertical = a;
    this.repeat.y = 1 / a;
    this.totalFrames = this._framesHorizontal * this._framesVertical;
  }}, endFrame:{get:function() {
    return this._endFrame;
  }, set:function(a) {
    a > this._totalFrames && (a = this._totalFrames);
    this._endFrame = a;
  }}, beginFrame:{get:function() {
    return this._beginFrame;
  }, set:function(a) {
    0 > a && (a = 0);
    this._beginFrame = this.currentFrame = a;
  }}, totalFrames:{get:function() {
    return this._totalFrames;
  }, set:function(a) {
    this._beginFrame = 0;
    this._totalFrames = this._endFrame = a;
  }}});
  this.image.crossOrigin = "anonymous";
  this.image.src = this.source.data;
  this.image.onload = function() {
    t.needsUpdate = !0;
  };
  this.currentFrame = 0;
  p();
}
SpriteSheetTexture.prototype = Object.create(THREE.Texture.prototype);
SpriteSheetTexture.isTexture = !0;
SpriteSheetTexture.prototype.step = function() {
  this.currentFrame++;
  this.currentFrame >= this._endFrame && (this.currentFrame = this._beginFrame);
  this.offset.x = this.currentFrame % this.framesHorizontal / this.framesHorizontal;
  this.offset.y = 1 - this.repeat.y - Math.floor(this.currentFrame / this.framesHorizontal) / this.framesVertical;
};
SpriteSheetTexture.prototype.setAnimationSpeed = function(a) {
  this.animationSpeed = a;
};
SpriteSheetTexture.prototype.setFrameGrid = function(a, d) {
  this._framesHorizontal = a;
  this._framesVertical = d;
  this._totalFrames = a * d;
  this.repeat.set(1 / a, 1 / d);
};
SpriteSheetTexture.prototype.setAnimationFrames = function(a, d) {
  this.beginFrame = a;
  this.endFrame = d;
};
SpriteSheetTexture.prototype.dispose = function() {
  THREE.Texture.prototype.dispose.call(this);
  this.disposed = !0;
};
SpriteSheetTexture.prototype.toJSON = function(a) {
  var d = THREE.Texture.prototype.toJSON.call(this, a);
  a = this.source.toJSON(a);
  d.image = a.uuid;
  d.loop = this.loop;
  d.animationSpeed = this.animationSpeed;
  d.framesHorizontal = this._framesHorizontal;
  d.framesVertical = this._framesVertical;
  d.totalFrames = this._totalFrames;
  d.beginFrame = this._beginFrame;
  d.endFrame = this._endFrame;
  return d;
};
"use strict";
function FontLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}
FontLoader.prototype.load = function(a, d, g, h) {
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    d(new Font(JSON.parse(a)));
  }, g, h);
};
FontLoader.prototype.parse = function(a) {
  if (void 0 !== a.data) {
    var d = new Font;
    d.name = a.name;
    d.uuid = a.uuid;
    d.encoding = a.encoding;
    void 0 !== a.reversed && (d.reversed = a.reversed);
    "arraybuffer" === a.format ? (d.format = a.format, d.data = void 0 !== a.data.toArrayBuffer ? a.data.toArrayBuffer() : a.data, d.loadTTF()) : "base64" === a.format ? (d.format = "arraybuffer", d.data = ArraybufferUtils.fromBase64(a.data), d.loadTTF()) : (d.format = a.format, d.data = a.data, d.font = a.data);
    return d;
  }
  return new Font(a);
};
"use strict";
function ImageLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.path = "";
  this.crossOrigin = "Anonymous";
}
ImageLoader.prototype.setCrossOrigin = function(a) {
  this.crossOrigin = a;
  return this;
};
ImageLoader.prototype.setPath = function(a) {
  this.path = a;
  return this;
};
ImageLoader.prototype.loadJSON = function(a, d, g, h) {
  var e = this;
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    d(e.parse(JSON.parse(a)));
  }, g, h);
};
ImageLoader.prototype.parse = function(a) {
  var d = new Image(void 0 !== a.data.toArrayBuffer ? a.data.toArrayBuffer() : a.data, a.encoding);
  d.name = a.name;
  d.uuid = a.uuid;
  void 0 !== a.width && (d.width = a.width, d.height = a.height);
  return d;
};
"use strict";
function VideoLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}
VideoLoader.prototype.load = function(a, d, g, h) {
  var e = this;
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    d(e.parse(JSON.parse(a)));
  }, g, h);
};
VideoLoader.prototype.parse = function(a) {
  var d = new Video(void 0 !== a.data.toArrayBuffer ? a.data.toArrayBuffer() : a.data, a.encoding);
  d.name = a.name;
  d.uuid = a.uuid;
  return d;
};
"use strict";
function AudioLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}
AudioLoader.prototype.load = function(a, d, g, h) {
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    d(self.parse(JSON.parse(a)));
  }, g, h);
};
AudioLoader.prototype.parse = function(a) {
  var d = new Audio;
  d.name = a.name;
  d.uuid = a.uuid;
  d.encoding = a.encoding;
  "base64" === a.format ? (d.format = "arraybuffer", d.data = ArraybufferUtils.fromBase64(a.data)) : "arraybuffer" === a.format ? (d.format = a.format, d.data = void 0 !== a.data.toArrayBuffer ? a.data.toArrayBuffer() : a.data) : (d.format = a.format, d.data = a.data);
  return d;
};
"use strict";
function MaterialLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.textures = {};
}
MaterialLoader.prototype.load = function(a, d, g, h) {
  var e = this;
  (new FileLoader(e.manager)).load(a, function(a) {
    d(e.parse(JSON.parse(a)));
  }, g, h);
};
MaterialLoader.prototype.setTextures = function(a) {
  this.textures = a;
};
MaterialLoader.prototype.parse = function(a) {
  var d = THREE.MaterialLoader.prototype.parse.call(this, a);
  if (void 0 !== a.materials) {
    for (var g = 0, h = a.materials.length; g < h; g++) {
      d.materials.push(this.parse(a.materials[g]));
    }
  }
  return d;
};
"use strict";
function TextureLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.path = "";
  this.crossOrigin = "anonymous";
  this.images = [];
  this.videos = [];
  this.fonts = [];
}
THREE._TextureLoader = THREE.TextureLoader;
THREE.TextureLoader = TextureLoader;
TextureLoader.prototype.setCrossOrigin = function(a) {
  this.crossOrigin = a;
  return this;
};
TextureLoader.prototype.setPath = function(a) {
  this.path = a;
  return this;
};
TextureLoader.prototype.setImages = function(a) {
  this.images = a;
  return this;
};
TextureLoader.prototype.setVideos = function(a) {
  this.videos = a;
  return this;
};
TextureLoader.prototype.setFonts = function(a) {
  this.fonts = a;
  return this;
};
TextureLoader.prototype.load = function(a, d, g, h) {
  try {
    var e = new Texture(this.path + a);
    void 0 !== d && d(e);
    return e;
  } catch (k) {
    return void 0 !== h && h(k), console.warn("nunuStudio: Texture not found", k), new Texture;
  }
};
TextureLoader.prototype.loadJSON = function(a, d, g, h) {
  var e = this;
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    e.parse(JSON.parse(a), d);
  }, g, h);
};
TextureLoader.prototype.parse = function(a, d) {
  var g = a.category;
  if ("Video" === g) {
    void 0 === a.video && console.warn("TextureLoader: No video specified for", a.uuid), void 0 === this.videos[a.video] && console.warn("TextureLoader: Undefined video", a.video), g = new VideoTexture(this.videos[a.video]), g.setLoop(a.loop), g.setAutoPlay(a.autoplay), g.setPlaybackRate(a.playbackRate), g.setVolume(a.volume);
  } else {
    if ("Webcam" === g) {
      g = new WebcamTexture, void 0 !== a.mode && (g.mode = a.mode);
    } else {
      if ("Compressed" === g) {
        if (a.isCubeTexture) {
          g = new CompressedTexture;
          g.image = [];
          g.isCubeTexture = !0;
          for (var h = 0; h < a.image.length; h++) {
            for (var e = 0; e < a.image[h].mipmaps.length; e++) {
              void 0 !== a.image[h].mipmaps[e].data.toArrayBuffer && (a.image[h].mipmaps[e].data = new Uint8Array(a.image[h].mipmaps[e].data.toArrayBuffer()));
            }
            g.image.push(a.image[h]);
          }
        } else {
          for (e = 0; e < a.mipmaps.length; e++) {
            void 0 !== a.mipmaps[e].data.toArrayBuffer && (a.mipmaps[e].data = new Uint8Array(a.mipmaps[e].data.toArrayBuffer()));
          }
          g = new CompressedTexture(a.mipmaps, a.width, a.height);
        }
      } else {
        if ("Cube" === g) {
          h = [];
          for (e = 0; e < a.images.length; e++) {
            void 0 === this.images[a.images[e]] && console.warn("nunuStudio: TextureLoader, undefined image", a.images[e]), h.push(this.images[a.images[e]]);
          }
          g = new CubeTexture;
          g.setImages(h, a.mode);
          g.setSize(a.size);
          g.updateImages();
        } else {
          "Canvas" === g ? g = new CanvasTexture(a.width, a.height) : "DataTexture" === g ? (g = new Float32Array(a.image.data), g = new DataTexture(g, a.image.width, a.image.height)) : (void 0 === a.image && console.warn("nunuStudio: TextureLoader, no image specified for", a.uuid), void 0 === this.images[a.image] && console.warn("nunuStudio: TextureLoader, undefined image", a.image), "SpriteSheet" === g ? (g = new SpriteSheetTexture(this.images[a.image], a.framesHorizontal, a.framesVertical, a.totalFrames), 
          g.loop = a.loop, g.animationSpeed = a.animationSpeed, g.beginFrame = a.beginFrame, g.endFrame = a.endFrame) : g = new Texture(this.images[a.image]));
        }
      }
    }
  }
  g.needsUpdate = !0;
  g.uuid = a.uuid;
  g.name = a.name;
  g.mapping = a.mapping;
  g.repeat.set(a.repeat[0], a.repeat[1]);
  g.offset.set(a.offset[0], a.offset[1]);
  void 0 !== a.center && g.center.set(a.center[0], a.center[1]);
  void 0 !== a.rotation && (g.rotation = a.rotation);
  g.wrapS = a.wrap[0];
  g.wrapT = a.wrap[1];
  void 0 !== a.format && (g.format = a.format);
  void 0 !== a.type && (g.type = a.type);
  void 0 !== a.encoding && (g.encoding = a.encoding);
  g.minFilter = a.minFilter;
  g.magFilter = a.magFilter;
  g.anisotropy = a.anisotropy;
  g.flipY = a.flipY;
  void 0 !== a.premultiplyAlpha && (g.premultiplyAlpha = a.premultiplyAlpha);
  void 0 !== a.unpackAlignment && (g.unpackAlignment = a.unpackAlignment);
  void 0 !== d && d(g);
  return g;
};
"use strict";
function GeometryLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.shapes = {};
}
GeometryLoader.prototype.setShapes = function(a) {
  this.shapes = a;
  return this;
};
GeometryLoader.prototype.load = function(a, d, g, h) {
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    d(self.parse(JSON.parse(a)));
  }, g, h);
};
GeometryLoader.prototype.parse = function(a) {
  var d = null;
  if ("CapsuleBufferGeometry" === a.type) {
    d = new CapsuleBufferGeometry(a.radiusTop, a.radiusBottom, a.height, a.radialSegments, a.heightSegments, a.capsTopSegments, a.capsBottomSegments, a.thetaStart, a.thetaLength);
  } else {
    if ("Geometry" === a.type) {
      d = (new LegacyGeometryLoader).parse(a.data).geometry;
    } else {
      var g = THREE.ObjectLoader.prototype.parseGeometries([a], this.shapes), h;
      for (h in g) {
        d = g[h];
        break;
      }
    }
  }
  d.uuid = a.uuid;
  d.name = void 0 !== a.name ? a.name : "geometry";
  return d;
};
"use strict";
function LegacyGeometryLoader(a) {
  this.manager = void 0 !== a ? a : DefaultLoadingManager;
  this.withCredentials = !1;
}
LegacyGeometryLoader.prototype.load = function(a, d, g, h) {
  var e = this, k = void 0 === this.path ? LoaderUtils.extractUrlBase(a) : this.path, c = new THREE.FileLoader(this.manager);
  c.setPath(this.path);
  c.setWithCredentials(this.withCredentials);
  c.load(a, function(c) {
    c = JSON.parse(c);
    var g = c.metadata;
    if (void 0 !== g && (g = g.type, void 0 !== g && "object" === g.toLowerCase())) {
      console.error("nunuStudio: LegacyGeometryLoader: " + a + " should be loaded with ObjectLoader instead.");
      return;
    }
    c = e.parse(c, k);
    d(c.geometry, c.materials);
  }, g, h);
};
LegacyGeometryLoader.prototype.setPath = function(a) {
  this.path = a;
  return this;
};
LegacyGeometryLoader.prototype.setResourcePath = function(a) {
  this.resourcePath = a;
  return this;
};
LegacyGeometryLoader.prototype.setCrossOrigin = function(a) {
  this.crossOrigin = a;
  return this;
};
LegacyGeometryLoader.prototype.parse = function() {
  return function(a, d) {
    void 0 !== a.data && (a = a.data);
    a.scale = void 0 !== a.scale ? 1 / a.scale : 1;
    var g = new THREE.Geometry, h = a, e, k, c, p = h.faces;
    var t = h.vertices;
    var f = h.normals, n = h.colors;
    var b = h.scale;
    var m = 0;
    if (void 0 !== h.uvs) {
      for (e = 0; e < h.uvs.length; e++) {
        h.uvs[e].length && m++;
      }
      for (e = 0; e < m; e++) {
        g.faceVertexUvs[e] = [];
      }
    }
    var q = 0;
    for (c = t.length; q < c;) {
      e = new THREE.Vector3, e.x = t[q++] * b, e.y = t[q++] * b, e.z = t[q++] * b, g.vertices.push(e);
    }
    q = 0;
    for (c = p.length; q < c;) {
      t = p[q++];
      var y = t & 1;
      var x = t & 2;
      e = t & 8;
      var z = t & 16;
      var r = t & 32;
      b = t & 64;
      t &= 128;
      if (y) {
        y = new THREE.Face3;
        y.a = p[q];
        y.b = p[q + 1];
        y.c = p[q + 3];
        var u = new THREE.Face3;
        u.a = p[q + 1];
        u.b = p[q + 2];
        u.c = p[q + 3];
        q += 4;
        x && (x = p[q++], y.materialIndex = x, u.materialIndex = x);
        x = g.faces.length;
        if (e) {
          for (e = 0; e < m; e++) {
            var v = h.uvs[e];
            g.faceVertexUvs[e][x] = [];
            g.faceVertexUvs[e][x + 1] = [];
            for (k = 0; 4 > k; k++) {
              var C = p[q++];
              var A = v[2 * C];
              C = v[2 * C + 1];
              A = new THREE.Vector2(A, C);
              2 !== k && g.faceVertexUvs[e][x].push(A);
              0 !== k && g.faceVertexUvs[e][x + 1].push(A);
            }
          }
        }
        z && (z = 3 * p[q++], y.normal.set(f[z++], f[z++], f[z]), u.normal.copy(y.normal));
        if (r) {
          for (e = 0; 4 > e; e++) {
            z = 3 * p[q++], r = new THREE.Vector3(f[z++], f[z++], f[z]), 2 !== e && y.vertexNormals.push(r), 0 !== e && u.vertexNormals.push(r);
          }
        }
        b && (b = p[q++], b = n[b], y.color.setHex(b), u.color.setHex(b));
        if (t) {
          for (e = 0; 4 > e; e++) {
            b = p[q++], b = n[b], 2 !== e && y.vertexColors.push(new Color(b)), 0 !== e && u.vertexColors.push(new Color(b));
          }
        }
        g.faces.push(y);
        g.faces.push(u);
      } else {
        y = new THREE.Face3;
        y.a = p[q++];
        y.b = p[q++];
        y.c = p[q++];
        x && (x = p[q++], y.materialIndex = x);
        x = g.faces.length;
        if (e) {
          for (e = 0; e < m; e++) {
            for (v = h.uvs[e], g.faceVertexUvs[e][x] = [], k = 0; 3 > k; k++) {
              C = p[q++], A = v[2 * C], C = v[2 * C + 1], A = new THREE.Vector2(A, C), g.faceVertexUvs[e][x].push(A);
            }
          }
        }
        z && (z = 3 * p[q++], y.normal.set(f[z++], f[z++], f[z]));
        if (r) {
          for (e = 0; 3 > e; e++) {
            z = 3 * p[q++], r = new THREE.Vector3(f[z++], f[z++], f[z]), y.vertexNormals.push(r);
          }
        }
        b && (b = p[q++], y.color.setHex(n[b]));
        if (t) {
          for (e = 0; 3 > e; e++) {
            b = p[q++], y.vertexColors.push(new Color(n[b]));
          }
        }
        g.faces.push(y);
      }
    }
    h = a;
    q = void 0 !== h.influencesPerVertex ? h.influencesPerVertex : 2;
    if (h.skinWeights) {
      for (c = 0, p = h.skinWeights.length; c < p; c += q) {
        g.skinWeights.push(new Vector4(h.skinWeights[c], 1 < q ? h.skinWeights[c + 1] : 0, 2 < q ? h.skinWeights[c + 2] : 0, 3 < q ? h.skinWeights[c + 3] : 0));
      }
    }
    if (h.skinIndices) {
      for (c = 0, p = h.skinIndices.length; c < p; c += q) {
        g.skinIndices.push(new Vector4(h.skinIndices[c], 1 < q ? h.skinIndices[c + 1] : 0, 2 < q ? h.skinIndices[c + 2] : 0, 3 < q ? h.skinIndices[c + 3] : 0));
      }
    }
    g.bones = h.bones;
    g.bones && 0 < g.bones.length && (g.skinWeights.length !== g.skinIndices.length || g.skinIndices.length !== g.vertices.length) && console.warn("When skinning, number of vertices (" + g.vertices.length + "), skinIndices (" + g.skinIndices.length + "), and skinWeights (" + g.skinWeights.length + ") should match.");
    c = a;
    p = c.scale;
    if (void 0 !== c.morphTargets) {
      for (h = 0, q = c.morphTargets.length; h < q; h++) {
        for (g.morphTargets[h] = {}, g.morphTargets[h].name = c.morphTargets[h].name, g.morphTargets[h].vertices = [], f = g.morphTargets[h].vertices, n = c.morphTargets[h].vertices, m = 0, t = n.length; m < t; m += 3) {
          b = new THREE.Vector3, b.x = n[m] * p, b.y = n[m + 1] * p, b.z = n[m + 2] * p, f.push(b);
        }
      }
    }
    if (void 0 !== c.morphColors && 0 < c.morphColors.length) {
      for (p = g.faces, c = c.morphColors[0].colors, h = 0, q = p.length; h < q; h++) {
        p[h].color.fromArray(c, 3 * h);
      }
    }
    c = a;
    h = [];
    q = [];
    void 0 !== c.animation && q.push(c.animation);
    void 0 !== c.animations && (c.animations.length ? q = q.concat(c.animations) : q.push(c.animations));
    for (c = 0; c < q.length; c++) {
      (p = THREE.AnimationClip.parseAnimation(q[c], g.bones)) && h.push(p);
    }
    g.morphTargets && (q = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(g.morphTargets, 10), h = h.concat(q));
    0 < h.length && (g.animations = h);
    g.computeFaceNormals();
    g.computeBoundingSphere();
    if (void 0 === a.materials || 0 === a.materials.length) {
      return {geometry:g};
    }
    a = Loader.prototype.initMaterials(a.materials, this.resourcePath || d, this.crossOrigin);
    return {geometry:g, materials:a};
  };
}();
"use strict";
function ObjectLoader(a) {
  ResourceContainer.call(this);
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.texturePath = "";
}
ObjectLoader.prototype = Object.create(ResourceContainer.prototype);
ObjectLoader.prototype.load = function(a, d, g, h) {
  "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
  var e = this;
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    e.parse(JSON.parse(a), d);
  }, g, h);
};
ObjectLoader.prototype.parse = function(a, d) {
  this.parseResources(a.resources);
  this.parseShape(a.shapes);
  this.parseGeometries(a.geometries);
  this.parseImages(a.images);
  this.parseVideos(a.videos);
  this.parseAudio(a.audio);
  this.parseFonts(a.fonts);
  this.parseTextures(a.textures);
  this.parseMaterials(a.materials);
  var g = this.parseObject(a.object);
  void 0 !== a.skeletons && (this.parseSkeletons(a.skeletons, g), this.bindSkeletons(g));
  void 0 !== a.images && 0 !== a.images.length || void 0 === d || d(g);
  return g;
};
ObjectLoader.prototype.setTexturePath = function(a) {
  this.texturePath = a;
};
ObjectLoader.prototype.setCrossOrigin = function(a) {
  this.crossOrigin = a;
};
ObjectLoader.prototype.parseResources = function(a) {
  if (void 0 !== a) {
    for (var d in a) {
      var g = new TextFile(a[d].data, a[d].encoding);
      g.format = a[d].format;
      g.name = a[d].name;
      g.uuid = a[d].uuid;
      this.resources[g.uuid] = g;
    }
  }
  return this.resources;
};
ObjectLoader.prototype.parseShape = function(a) {
  if (void 0 !== a) {
    for (var d = 0, g = a.length; d < g; d++) {
      var h = (new Shape).fromJSON(a[d]);
      this.shapes[h.uuid] = h;
    }
  }
  return this.shapes;
};
ObjectLoader.prototype.parseGeometries = function(a) {
  if (void 0 !== a) {
    var d = new GeometryLoader;
    d.setShapes(this.shapes);
    for (var g = 0; g < a.length; g++) {
      this.geometries[a[g].uuid] = d.parse(a[g]);
    }
  }
  return this.geometries;
};
ObjectLoader.prototype.parseMaterials = function(a) {
  if (void 0 !== a) {
    var d = new MaterialLoader;
    d.setTextures(this.textures);
    for (var g in a) {
      this.materials[a[g].uuid] = d.parse(a[g]);
    }
  }
  return this.materials;
};
ObjectLoader.prototype.parseImages = function(a) {
  if (void 0 !== a) {
    var d = new ImageLoader, g;
    for (g in a) {
      this.images[a[g].uuid] = d.parse(a[g]);
    }
  }
  return this.images;
};
ObjectLoader.prototype.parseVideos = function(a) {
  if (void 0 !== a) {
    var d = new VideoLoader, g;
    for (g in a) {
      this.videos[a[g].uuid] = d.parse(a[g]);
    }
  }
  return this.videos;
};
ObjectLoader.prototype.parseAudio = function(a) {
  if (void 0 !== a) {
    var d = new AudioLoader, g;
    for (g in a) {
      this.audio[a[g].uuid] = d.parse(a[g]);
    }
  }
  return this.audio;
};
ObjectLoader.prototype.parseFonts = function(a) {
  if (void 0 !== a) {
    var d = new FontLoader, g;
    for (g in a) {
      this.fonts[a[g].uuid] = d.parse(a[g]);
    }
  }
  return this.fonts;
};
ObjectLoader.prototype.parseTextures = function(a) {
  if (void 0 !== a) {
    var d = new TextureLoader;
    d.setImages(this.images);
    d.setVideos(this.videos);
    for (var g in a) {
      this.textures[a[g].uuid] = d.parse(a[g]);
    }
  }
  return this.textures;
};
ObjectLoader.prototype.parseSkeletons = function(a, d) {
  if (void 0 !== a) {
    for (var g = 0; g < a.length; g++) {
      this.skeletons[a[g].uuid] = THREE.Skeleton.fromJSON(a[g], d, this);
    }
  }
  return this.skeletons;
};
ObjectLoader.prototype.bindSkeletons = function(a) {
  var d = this;
  a.traverse(function(a) {
    if (a.isSkinnedMesh && void 0 !== a.skeletonUUID) {
      var g = d.skeletons[a.skeletonUUID];
      void 0 === g ? console.warn("ObjectLoader: Skeleton not found.", a.skeletonUUID) : (delete a.skeletonUUID, a.bind(g, a.bindMatrix));
    }
  });
};
ObjectLoader.prototype.parseObject = function(a) {
  try {
    switch(a.type) {
      case "SpineAnimation":
        for (var d = 0; d < a.textures.length; d++) {
          a.textures[d].texture = this.getTexture(a.textures[d].texture);
        }
        var g = new SpineAnimation(a.json, a.atlas, "", a.textures);
        void 0 !== a.animation && (g.animation = a.animation, g.track = a.track, g.loop = a.loop);
        void 0 !== a.skin && (g.skin = a.skin);
        break;
      case "Audio":
        g = new AudioEmitter(this.getAudio(a.audio));
        g.autoplay = a.autoplay;
        g.startTime = a.startTime;
        g.playbackRate = a.playbackRate;
        g.loop = void 0 !== a.source ? a.source.loop : a.loop;
        void 0 !== a.volume && (g.volume = a.volume);
        break;
      case "PositionalAudio":
        g = new PositionalAudio(this.getAudio(a.audio));
        g.autoplay = a.autoplay;
        g.startTime = a.startTime;
        g.playbackRate = a.playbackRate;
        g.loop = void 0 !== a.source ? a.source.loop : a.loop;
        void 0 !== a.volume && (g.volume = a.volume);
        g.distanceModel = a.distanceModel;
        g.panningModel = a.panningModel;
        break;
      case "Physics":
        g = PhysicsObject.fromJSON(a);
        break;
      case "ParticleEmiter":
        g = ParticleEmitter.fromJSON(a, this);
        break;
      case "LensFlare":
        g = new LensFlare;
        void 0 !== a.lensFlares && (a.elements = a.lensFlares);
        for (d = 0; d < a.elements.length; d++) {
          g.addFlare(this.getTexture(a.elements[d].texture), a.elements[d].size, a.elements[d].distance, new THREE.Color(a.elements[d].color));
        }
        break;
      case "TextMesh":
      case "Text3D":
        g = new TextMesh(a.text, this.getMaterial(a.material), this.getFont(a.font), a.height, a.bevel, a.bevelThickness, a.bevelSize, a.size, a.curveSegments, a.extruded);
        break;
      case "Program":
        g = new Program(a.name);
        g.description = a.description;
        g.author = a.author;
        g.version = a.version;
        g.vr = a.vr;
        g.vrScale = a.vrScale;
        void 0 !== a.rendererConfig ? g.rendererConfig.fromJSON(a.rendererConfig) : (g.rendererConfig.antialiasing = a.antialiasing, g.rendererConfig.shadows = a.shadows, g.rendererConfig.shadowsType = a.shadowsType, g.rendererConfig.toneMapping = a.toneMapping, g.rendererConfig.toneMappingWhitePoint = a.toneMappingWhitePoint, g.rendererConfig.toneMappingExposure = a.toneMappingExposure);
        void 0 !== a.lockPointer && (g.lockPointer = a.lockPointer);
        void 0 !== a.defaultScene && (g.defaultScene = a.defaultScene);
        void 0 !== a.handlePixelRatio && (g.handlePixelRatio = a.handlePixelRatio);
        break;
      case "LeapDevice":
        g = new LeapMotion;
        g.mode = a.mode;
        g.useArm = a.useArm;
        void 0 !== a.debugModel && (g.debugModel = a.debugModel);
        void 0 !== a.gesturesEnabled && (g.gesturesEnabled = a.gesturesEnabled);
        void 0 !== a.posesEnabled && (g.posesEnabled = a.posesEnabled);
        break;
      case "Kinect":
        g = new KinectDevice;
        void 0 !== a.debugModel && (g.debugModel = a.debugModel);
        break;
      case "Sky":
        g = new Sky(a.autoUpdate, a.dayTime, a.sunDistance, a.time);
        void 0 !== a.sun && (g.sun.shadow.fromJSON(a.sun.shadow), void 0 !== a.sun.castShadow && (g.sun.castShadow = a.sun.castShadow));
        if (void 0 !== a.colorTop) {
          for (g.colorTop = [], d = 0; d < a.colorTop.length; d++) {
            g.colorTop.push(new THREE.Color(a.colorTop[d]));
          }
        }
        if (void 0 !== a.colorBottom) {
          for (g.colorBottom = [], d = 0; d < a.colorBottom.length; d++) {
            g.colorBottom.push(new THREE.Color(a.colorBottom[d]));
          }
        }
        void 0 !== a.sunColor && (g.sunColor = a.sunColor);
        void 0 !== a.moonColor && (g.moonColor = a.moonColor);
        void 0 !== a.intensity && (g.intensity = a.intensity);
        break;
      case "CubeCamera":
        g = new CubeCamera(a.near, a.far, a.resolution, a.autoUpdate);
        break;
      case "FirstPersonControls":
        g = new FirstPersonControls;
        g.sensitivity = a.sensitivity;
        g.needsButtonPressed = a.needsButtonPressed;
        g.movementEnabled = a.movementEnabled;
        g.moveSpeed = a.moveSpeed;
        g.moveOnPlane = a.moveOnPlane;
        g.moveKeys = a.moveKeys;
        break;
      case "OrbitControls":
        g = new OrbitControls;
        g.distance = a.distance;
        g.maxDistance = a.maxDistance;
        g.minDistance = a.minDistance;
        g.sensitivity = a.sensitivity;
        g.limitUp = a.limitUp;
        g.limitDown = a.limitDown;
        g.needsButtonPressed = a.needsButtonPressed;
        g.zoomEnabled = a.zoomEnabled;
        g.movementEnabled = a.movementEnabled;
        void 0 !== a.smooth && (g.smooth = a.smooth, g.friction = a.friction, g.speed = a.speed, g.invertNavigation = a.invertNavigation);
        void 0 !== a.center && (g.center.fromArray(a.center), g.vector.fromArray(a.vector));
        break;
      case "Scene":
        g = new Scene;
        void 0 !== a.background && (Number.isInteger(a.background) ? g.background = new THREE.Color(a.background) : g.background = this.getTexture(a.background));
        void 0 !== a.environment && (g.environment = this.getTexture(a.environment));
        void 0 !== a.fog && ("Fog" === a.fog.type ? g.fog = new THREE.Fog(a.fog.color, a.fog.near, a.fog.far) : "FogExp2" === a.fog.type && (g.fog = new THREE.FogExp2(a.fog.color, a.fog.density)));
        void 0 !== a.defaultCamera && (g.defaultCamera = this.parse(a.defaultCamera));
        void 0 !== a.cameras && (g.cameras = a.cameras);
        void 0 !== a.usePhysics && (g.usePhysics = a.usePhysics);
        void 0 !== a.world && (g.world.gravity.set(a.world.gravity.x, a.world.gravity.y, a.world.gravity.z), g.world.quatNormalizeSkip = a.world.quatNormalizeSkip, g.world.quatNormalizeFast = a.world.quatNormalizeFast, g.world.solver.tolerance = a.world.solver.tolerance, g.world.solver.iterations = a.world.solver.iterations);
        break;
      case "PerspectiveCamera":
        g = new PerspectiveCamera(a.fov, a.aspect, a.near, a.far);
        void 0 !== a.focus && (g.focus = a.focus);
        void 0 !== a.zoom && (g.zoom = a.zoom);
        void 0 !== a.filmGauge && (g.filmGauge = a.filmGauge);
        void 0 !== a.filmOffset && (g.filmOffset = a.filmOffset);
        void 0 !== a.view && (g.view = Object.assign({}, a.view));
        void 0 !== a.viewport && (a.viewport instanceof Array ? (g.viewport.size.fromArray(a.viewport), g.viewport.offset.fromArray(a.offset)) : g.viewport.fromJSON(a.viewport));
        void 0 !== a.clearColor && (g.clearColor = a.clearColor);
        void 0 !== a.clearDepth && (g.clearDepth = a.clearDepth);
        void 0 !== a.clearStencil && (g.clearStencil = a.clearStencil);
        void 0 !== a.order && (g.order = a.order);
        void 0 !== a.composer && (g.composer = EffectComposer.fromJSON(a.composer));
        break;
      case "OrthographicCamera":
        g = new OrthographicCamera(a.size, a.aspect, a.mode, a.near, a.far);
        void 0 !== a.viewport && (a.viewport instanceof Array ? (g.viewport.size.fromArray(a.viewport), g.viewport.offset.fromArray(a.offset)) : g.viewport.fromJSON(a.viewport));
        void 0 !== a.clearColor && (g.clearColor = a.clearColor);
        void 0 !== a.clearDepth && (g.clearDepth = a.clearDepth);
        void 0 !== a.clearStencil && (g.clearStencil = a.clearStencil);
        void 0 !== a.order && (g.order = a.order);
        void 0 !== a.composer && (g.composer = EffectComposer.fromJSON(a.composer));
        void 0 !== a.zoom && (g.zoom = a.zoom);
        void 0 !== a.view && (g.view = Object.assign({}, a.view));
        break;
      case "Script":
        g = new Script(a.code, a.mode);
        break;
      case "RectAreaLight":
        g = new RectAreaLight(a.color, a.intensity, a.width, a.height);
        break;
      case "AmbientLight":
        g = new AmbientLight(a.color, a.intensity);
        break;
      case "DirectionalLight":
        g = new DirectionalLight(a.color, a.intensity);
        break;
      case "PointLight":
        g = new PointLight(a.color, a.intensity, a.distance, a.decay);
        break;
      case "SpotLight":
        g = new SpotLight(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay);
        break;
      case "HemisphereLight":
        g = new HemisphereLight(a.color, a.groundColor, a.intensity);
        break;
      case "HTMLView":
        g = new HTMLView;
        g.height = a.height;
        g.width = a.width;
        g.url = a.url;
        break;
      case "LightProbe":
        g = new LightProbe;
        g.sh.fromArray(a.sh);
        break;
      case "InstancedMesh":
        g = new InstancedMesh(this.getGeometry(a.geometry), this.getMaterial(a.material), a.count);
        g.instanceMatrix = new THREE.BufferAttribute(new Float32Array(a.instanceMatrix.array), 16);
        break;
      case "SkinnedMesh":
        g = new SkinnedMesh(this.getGeometry(a.geometry), this.getMaterial(a.material));
        void 0 !== a.skeleton && (g.skeletonUUID = a.skeleton);
        void 0 !== a.bindMode && (g.bindMode = a.bindMode);
        void 0 !== a.bindMatrix && g.bindMatrix.fromArray(a.bindMatrix);
        break;
      case "Mesh":
        g = new Mesh(this.getGeometry(a.geometry), this.getMaterial(a.material));
        break;
      case "TextBitmap":
        g = TextBitmap.fromJSON(a, this.getTexture(a.texture));
        break;
      case "TextSprite":
        g = TextSprite.fromJSON(a);
        break;
      case "LOD":
        g = new THREE.LOD;
        break;
      case "Line":
        g = new THREE.Line(this.getGeometry(a.geometry), this.getMaterial(a.material), a.mode);
        break;
      case "LineLoop":
        g = new THREE.LineLoop(this.getGeometry(a.geometry), this.getMaterial(a.material));
        break;
      case "LineSegments":
        g = new THREE.LineSegments(this.getGeometry(a.geometry), this.getMaterial(a.material));
        break;
      case "PointCloud":
      case "Points":
        g = new THREE.Points(this.getGeometry(a.geometry), this.getMaterial(a.material));
        break;
      case "Sprite":
        g = new Sprite(this.getMaterial(a.material));
        break;
      case "Group":
        g = new Container;
        break;
      case "Bone":
        g = new THREE.Bone;
        break;
      default:
        g = new Container;
    }
  } catch (k) {
    console.error("nunuStudio: Error parsing and creating object " + a.uuid + ", object skiped.", k, a), g = new Container;
  }
  g.uuid = a.uuid;
  g.name = a.name;
  g.locked = !0 === a.locked || !0 === a.hidden;
  g.folded = !0 === a.folded;
  void 0 !== a.frustumCulled && (g.frustumCulled = a.frustumCulled);
  void 0 !== a.renderOrder && (g.renderOrder = a.renderOrder);
  if (void 0 !== a.animations) {
    for (g.animations = [], d = 0; d < a.animations.length; d++) {
      var h = THREE.AnimationClip.parse(a.animations[d]);
      void 0 !== a.animations[d].uuid && (h.uuid = a.animations[d].uuid);
      g.animations.push(h);
    }
  }
  void 0 !== a.matrix && (g.matrix.fromArray(a.matrix), g.matrix.decompose(g.position, g.quaternion, g.scale));
  void 0 !== a.position && g.position.fromArray(a.position);
  void 0 !== a.rotation && g.rotation.fromArray(a.rotation);
  void 0 !== a.quaternion && g.quaternion.fromArray(a.quaternion);
  void 0 !== a.scale && g.scale.fromArray(a.scale);
  g.castShadow = !0 === a.castShadow;
  g.receiveShadow = !0 === a.receiveShadow;
  void 0 !== a.shadow && g.shadow.fromJSON(a.shadow);
  g.visible = !0 === a.visible;
  void 0 !== a.userData && (g.userData = a.userData);
  void 0 !== a.layers && (g.layers.mask = a.layers);
  if (void 0 !== a.children) {
    for (var e in a.children) {
      g.add(this.parseObject(a.children[e]));
    }
  }
  void 0 !== a.matrixAutoUpdate && (g.matrixAutoUpdate = a.matrixAutoUpdate, g.matrixAutoUpdate || (g.updateMatrix(), g.updateMatrixWorld(!0)));
  if ("Program" === a.type) {
    g.copyResources(this);
  } else {
    if ("Scene" === a.type) {
      for (d = 0; d < g.cameras.length; d++) {
        e = g.getCamera(g.cameras[d]), null !== e ? g.cameras[d] = e : g.cameras.splice(d, 1);
      }
    } else {
      if ("LOD" === a.type) {
        for (d = a.levels, a = 0; a < d.length; a++) {
          h = d[a], e = g.getObjectByProperty("uuid", h.object), void 0 !== e && g.addLevel(e, h.distance);
        }
      }
    }
  }
  return g;
};
"use strict";
function CapsuleBufferGeometry(a, d, g, h, e, k, c, p, t) {
  THREE.BufferGeometry.call(this);
  this.type = "CapsuleBufferGeometry";
  this.parameters = {radiusTop:a, radiusBottom:d, height:g, radialSegments:h, heightSegments:e, capsTopSegments:k, capsBottomSegments:c, thetaStart:p, thetaLength:t};
  a = void 0 !== a ? a : 1;
  d = void 0 !== d ? d : 1;
  g = void 0 !== g ? g : 2;
  h = Math.floor(h) || 8;
  e = Math.floor(e) || 1;
  k = Math.floor(k) || 2;
  c = Math.floor(c) || 2;
  p = void 0 !== p ? p : 0;
  t = void 0 !== t ? t : 2 * Math.PI;
  var f = Math.acos((d - a) / g), n = (h + 1) * (e + 1 + c + k), b = h * (e + c + k) * 6;
  b = new THREE.BufferAttribute(new (65535 < b ? Uint32Array : Uint16Array)(b), 1);
  var m = new THREE.BufferAttribute(new Float32Array(3 * n), 3), q = new THREE.BufferAttribute(new Float32Array(3 * n), 3);
  n = new THREE.BufferAttribute(new Float32Array(2 * n), 2);
  var y = 0, x = 0, z = [], r = g / 2, u, v = new THREE.Vector3, C = new THREE.Vector3, A = Math.cos(f), D = Math.sin(f), F = (new THREE.Vector2(a * D, r + a * A)).sub(new THREE.Vector2(d * D, -r + d * A)).length(), B = a * f + F + d * (Math.PI / 2 - f), E = 0;
  for (u = 0; u <= k; u++) {
    var H = [];
    var L = Math.PI / 2 - u / k * f;
    E += a * f / k;
    var K = Math.cos(L), P = Math.sin(L), J = K * a;
    for (L = 0; L <= h; L++) {
      var I = L / h, N = I * t + p, S = Math.sin(N);
      N = Math.cos(N);
      C.x = J * S;
      C.y = r + P * a;
      C.z = J * N;
      m.setXYZ(y, C.x, C.y, C.z);
      v.set(K * S, P, K * N);
      q.setXYZ(y, v.x, v.y, v.z);
      n.setXY(y, I, 1 - E / B);
      H.push(y);
      y++;
    }
    z.push(H);
  }
  g = g + A * a - A * d;
  K = D * (d - a) / g;
  for (u = 1; u <= e; u++) {
    H = [];
    E += F / e;
    J = D * (u * (d - a) / e + a);
    for (L = 0; L <= h; L++) {
      I = L / h, N = I * t + p, S = Math.sin(N), N = Math.cos(N), C.x = J * S, C.y = r + A * a - u * g / e, C.z = J * N, m.setXYZ(y, C.x, C.y, C.z), v.set(S, K, N).normalize(), q.setXYZ(y, v.x, v.y, v.z), n.setXY(y, I, 1 - E / B), H.push(y), y++;
    }
    z.push(H);
  }
  for (u = 1; u <= c; u++) {
    H = [];
    L = Math.PI / 2 - f - u / c * (Math.PI - f);
    E += d * f / c;
    K = Math.cos(L);
    P = Math.sin(L);
    J = K * d;
    for (L = 0; L <= h; L++) {
      I = L / h, N = I * t + p, S = Math.sin(N), N = Math.cos(N), C.x = J * S, C.y = -r + P * d, C.z = J * N, m.setXYZ(y, C.x, C.y, C.z), v.set(K * S, P, K * N), q.setXYZ(y, v.x, v.y, v.z), n.setXY(y, I, 1 - E / B), H.push(y), y++;
    }
    z.push(H);
  }
  for (L = 0; L < h; L++) {
    for (u = 0; u < k + e + c; u++) {
      a = z[u + 1][L], d = z[u + 1][L + 1], p = z[u][L + 1], b.setX(x, z[u][L]), x++, b.setX(x, a), x++, b.setX(x, p), x++, b.setX(x, a), x++, b.setX(x, d), x++, b.setX(x, p), x++;
    }
  }
  this.setIndex(b);
  this.addAttribute("position", m);
  this.addAttribute("normal", q);
  this.addAttribute("uv", n);
}
CapsuleBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
CapsuleBufferGeometry.prototype.constructor = CapsuleBufferGeometry;
"use strict";
function LeapMotion() {
  THREE.Group.call(this);
  this.type = "LeapDevice";
  this.name = "leap";
  this.posesEnabled = this.gesturesEnabled = this.debugModel = !0;
  this.mode = LeapMotion.DESK;
  this.useArm = !1;
  this.boneMeshes = [];
  this.armMeshes = [];
  this.material = new THREE.MeshPhongMaterial;
  this.geometry = new THREE.BoxBufferGeometry(1, 1, 1);
  this.gesture = [];
  for (var a = 0; 10 > a; a++) {
    this.gesture[a] = !1;
  }
  this.pose = [];
  for (a = 0; 3 > a; a++) {
    this.pose[a] = !1;
  }
  this.data = null;
}
LeapMotion.prototype = Object.create(THREE.Group.prototype);
LeapMotion.DESK = 0;
LeapMotion.HDM = 1;
LeapMotion.SWIPE = 0;
LeapMotion.SWIPE_LEFT = 1;
LeapMotion.SWIPE_RIGHT = 2;
LeapMotion.SWIPE_FRONT = 3;
LeapMotion.SWIPE_BACK = 4;
LeapMotion.SWIPE_UP = 5;
LeapMotion.SWIPE_DOWN = 6;
LeapMotion.CIRCLE = 7;
LeapMotion.SCREEN_TAP = 8;
LeapMotion.KEY_TAP = 9;
LeapMotion.CLOSED = 0;
LeapMotion.OPEN = 1;
LeapMotion.POINTING = 2;
LeapMotion.prototype.initialize = function() {
  var a = this;
  Leap.loop({background:!0}, function(d) {
    a.data = d;
  }).connect();
  THREE.Object3D.prototype.initialize.call(this);
};
LeapMotion.prototype.update = function(a) {
  null !== this.data && (this.gesturesEnabled && this.updateGestures(), this.posesEnabled && this.updatePoses(), this.debugModel && this.updateDebugModel());
  THREE.Object3D.prototype.update.call(this, a);
};
LeapMotion.prototype.checkGesture = function(a) {
  return void 0 !== this.gesture[a] ? this.gesture[a] : !1;
};
LeapMotion.prototype.checkPose = function(a) {
  return void 0 !== this.pose[a] ? this.pose[a] : !1;
};
LeapMotion.prototype.setMode = function(a) {
  this.mode = a;
};
LeapMotion.prototype.updatePoses = function() {
  for (var a = 0; a < this.pose.length; a++) {
    this.pose[a] = !0;
  }
  for (var d = 0; d < this.data.hands.length; d++) {
    var g = this.data.hands[d], h = g.sphereCenter;
    h = new THREE.Vector3(h[0], h[1], h[2]);
    var e = [], k = 0;
    for (a = 0; a < this.pose.length; a++) {
      this.pose[a] = !0;
    }
    var c = [];
    for (a = 0; a < g.fingers.length; a++) {
      var p = g.fingers[a];
      c.push(p.direction);
      p = p.distal.nextJoint;
      p = new THREE.Vector3(p[0], p[1], p[2]);
      e.push(h.distanceTo(p) / g._scaleFactor);
      0 !== a && (.3 > c[a][2] && (this.pose[LeapMotion.CLOSED] = !1), -.5 < c[a][2] && (this.pose[LeapMotion.OPEN] = !1), 1 === a ? k = e[1] : k < 2 * e[a] - 15 && (this.pose[LeapMotion.POINTING] = !1));
    }
    k < 2 * e[0] - 15 && (this.pose[LeapMotion.POINTING] = !1);
  }
};
LeapMotion.prototype.updateGestures = function() {
  for (var a = 0; a < this.gesture.length; a++) {
    this.gesture[a] = !1;
  }
  var d = this;
  this.data.valid && 0 < this.data.gestures.length && this.data.gestures.forEach(function(a) {
    "swipe" === a.type ? (d.gesture[LeapMotion.SWIPE] = !0, 0 < a.direction[0] ? d.gesture[LeapMotion.SWIPE_RIGHT] = !0 : d.gesture[LeapMotion.SWIPE_LEFT] = !0, 0 < a.direction[1] ? d.gesture[LeapMotion.SWIPE_UP] = !0 : d.gesture[LeapMotion.SWIPE_DOWN] = !0, 0 < a.direction[2] ? d.gesture[LeapMotion.SWIPE_FRONT] = !0 : d.gesture[LeapMotion.SWIPE_BACK] = !0) : "circle" === a.type ? d.gesture[LeapMotion.CIRCLE] = !0 : "keyTap" === a.type ? d.gesture[LeapMotion.KEY_TAP] = !0 : "screenTap" === a.type && 
    (d.gesture[LeapMotion.SCREEN_TAP] = !0);
  });
};
LeapMotion.prototype.updateDebugModel = function() {
  var a = this;
  this.armMeshes.forEach(function(c) {
    a.remove(c);
  });
  this.boneMeshes.forEach(function(c) {
    a.remove(c);
  });
  for (var d = 0, g = 0, h = 0; h < this.data.hands.length; h++) {
    for (var e = this.data.hands[h], k = 0; k < e.fingers.length; k++) {
      for (var c = e.fingers[k], p = 0; p < c.bones.length; p++) {
        var t = c.bones[p];
        if (0 !== d) {
          var f = this.boneMeshes[d] || this.addMesh(this.boneMeshes);
          this.updateMesh(t, f);
        }
        d++;
      }
    }
    this.showArm && (e = e.arm, k = this.armMeshes[g++] || this.addMesh(this.armMeshes), this.updateMesh(e, k), k.scale.set(e.width / 1200, e.width / 300, e.length / 150));
  }
};
LeapMotion.prototype.addMesh = function(a) {
  var d = new Mesh(this.geometry, this.material);
  d.castShadow = this.castShadow;
  d.receiveShadow = this.receiveShadow;
  a.push(d);
  return d;
};
LeapMotion.prototype.updateMesh = function(a, d) {
  d.position.fromArray(a.center());
  d.position.divideScalar(150);
  d.setRotationFromMatrix((new THREE.Matrix4).fromArray(a.matrix()));
  d.scale.set(a.width / 150, a.width / 150, a.length / 150);
  this.add(d);
};
LeapMotion.prototype.getMovement = function() {
  var a = this.data.gestures[0].position, d = this.data.gestures[0].startPosition;
  a = new THREE.Vector3(a[0] - d[0], a[1] - d[1], a[2] - d[2]);
  a.divideScalar(this.data.currentFrameRate);
  return a;
};
LeapMotion.prototype.toJSON = function(a) {
  a = THREE.Group.prototype.toJSON.call(this, a);
  a.object.type = this.type;
  a.object.debugModel = this.debugModel;
  a.object.gesturesEnabled = this.gesturesEnabled;
  a.object.posesEnabled = this.posesEnabled;
  a.object.mode = this.mode;
  a.object.useArm = this.useArm;
  return a;
};
"use strict";
function LeapMotion() {
  THREE.Group.call(this);
  this.type = "LeapDevice";
  this.name = "leap";
  this.posesEnabled = this.gesturesEnabled = this.debugModel = !0;
  this.mode = LeapMotion.DESK;
  this.useArm = !1;
  this.boneMeshes = [];
  this.armMeshes = [];
  this.material = new THREE.MeshPhongMaterial;
  this.geometry = new THREE.BoxBufferGeometry(1, 1, 1);
  this.gesture = [];
  for (var a = 0; 10 > a; a++) {
    this.gesture[a] = !1;
  }
  this.pose = [];
  for (a = 0; 3 > a; a++) {
    this.pose[a] = !1;
  }
  this.data = null;
}
LeapMotion.prototype = Object.create(THREE.Group.prototype);
LeapMotion.DESK = 0;
LeapMotion.HDM = 1;
LeapMotion.SWIPE = 0;
LeapMotion.SWIPE_LEFT = 1;
LeapMotion.SWIPE_RIGHT = 2;
LeapMotion.SWIPE_FRONT = 3;
LeapMotion.SWIPE_BACK = 4;
LeapMotion.SWIPE_UP = 5;
LeapMotion.SWIPE_DOWN = 6;
LeapMotion.CIRCLE = 7;
LeapMotion.SCREEN_TAP = 8;
LeapMotion.KEY_TAP = 9;
LeapMotion.CLOSED = 0;
LeapMotion.OPEN = 1;
LeapMotion.POINTING = 2;
LeapMotion.prototype.initialize = function() {
  var a = this;
  Leap.loop({background:!0}, function(d) {
    a.data = d;
  }).connect();
  THREE.Object3D.prototype.initialize.call(this);
};
LeapMotion.prototype.update = function(a) {
  null !== this.data && (this.gesturesEnabled && this.updateGestures(), this.posesEnabled && this.updatePoses(), this.debugModel && this.updateDebugModel());
  THREE.Object3D.prototype.update.call(this, a);
};
LeapMotion.prototype.checkGesture = function(a) {
  return void 0 !== this.gesture[a] ? this.gesture[a] : !1;
};
LeapMotion.prototype.checkPose = function(a) {
  return void 0 !== this.pose[a] ? this.pose[a] : !1;
};
LeapMotion.prototype.setMode = function(a) {
  this.mode = a;
};
LeapMotion.prototype.updatePoses = function() {
  for (var a = 0; a < this.pose.length; a++) {
    this.pose[a] = !0;
  }
  for (var d = 0; d < this.data.hands.length; d++) {
    var g = this.data.hands[d], h = g.sphereCenter;
    h = new THREE.Vector3(h[0], h[1], h[2]);
    var e = [], k = 0;
    for (a = 0; a < this.pose.length; a++) {
      this.pose[a] = !0;
    }
    var c = [];
    for (a = 0; a < g.fingers.length; a++) {
      var p = g.fingers[a];
      c.push(p.direction);
      p = p.distal.nextJoint;
      p = new THREE.Vector3(p[0], p[1], p[2]);
      e.push(h.distanceTo(p) / g._scaleFactor);
      0 !== a && (.3 > c[a][2] && (this.pose[LeapMotion.CLOSED] = !1), -.5 < c[a][2] && (this.pose[LeapMotion.OPEN] = !1), 1 === a ? k = e[1] : k < 2 * e[a] - 15 && (this.pose[LeapMotion.POINTING] = !1));
    }
    k < 2 * e[0] - 15 && (this.pose[LeapMotion.POINTING] = !1);
  }
};
LeapMotion.prototype.updateGestures = function() {
  for (var a = 0; a < this.gesture.length; a++) {
    this.gesture[a] = !1;
  }
  var d = this;
  this.data.valid && 0 < this.data.gestures.length && this.data.gestures.forEach(function(a) {
    "swipe" === a.type ? (d.gesture[LeapMotion.SWIPE] = !0, 0 < a.direction[0] ? d.gesture[LeapMotion.SWIPE_RIGHT] = !0 : d.gesture[LeapMotion.SWIPE_LEFT] = !0, 0 < a.direction[1] ? d.gesture[LeapMotion.SWIPE_UP] = !0 : d.gesture[LeapMotion.SWIPE_DOWN] = !0, 0 < a.direction[2] ? d.gesture[LeapMotion.SWIPE_FRONT] = !0 : d.gesture[LeapMotion.SWIPE_BACK] = !0) : "circle" === a.type ? d.gesture[LeapMotion.CIRCLE] = !0 : "keyTap" === a.type ? d.gesture[LeapMotion.KEY_TAP] = !0 : "screenTap" === a.type && 
    (d.gesture[LeapMotion.SCREEN_TAP] = !0);
  });
};
LeapMotion.prototype.updateDebugModel = function() {
  var a = this;
  this.armMeshes.forEach(function(c) {
    a.remove(c);
  });
  this.boneMeshes.forEach(function(c) {
    a.remove(c);
  });
  for (var d = 0, g = 0, h = 0; h < this.data.hands.length; h++) {
    for (var e = this.data.hands[h], k = 0; k < e.fingers.length; k++) {
      for (var c = e.fingers[k], p = 0; p < c.bones.length; p++) {
        var t = c.bones[p];
        if (0 !== d) {
          var f = this.boneMeshes[d] || this.addMesh(this.boneMeshes);
          this.updateMesh(t, f);
        }
        d++;
      }
    }
    this.showArm && (e = e.arm, k = this.armMeshes[g++] || this.addMesh(this.armMeshes), this.updateMesh(e, k), k.scale.set(e.width / 1200, e.width / 300, e.length / 150));
  }
};
LeapMotion.prototype.addMesh = function(a) {
  var d = new Mesh(this.geometry, this.material);
  d.castShadow = this.castShadow;
  d.receiveShadow = this.receiveShadow;
  a.push(d);
  return d;
};
LeapMotion.prototype.updateMesh = function(a, d) {
  d.position.fromArray(a.center());
  d.position.divideScalar(150);
  d.setRotationFromMatrix((new THREE.Matrix4).fromArray(a.matrix()));
  d.scale.set(a.width / 150, a.width / 150, a.length / 150);
  this.add(d);
};
LeapMotion.prototype.getMovement = function() {
  var a = this.data.gestures[0].position, d = this.data.gestures[0].startPosition;
  a = new THREE.Vector3(a[0] - d[0], a[1] - d[1], a[2] - d[2]);
  a.divideScalar(this.data.currentFrameRate);
  return a;
};
LeapMotion.prototype.toJSON = function(a) {
  a = THREE.Group.prototype.toJSON.call(this, a);
  a.object.type = this.type;
  a.object.debugModel = this.debugModel;
  a.object.gesturesEnabled = this.gesturesEnabled;
  a.object.posesEnabled = this.posesEnabled;
  a.object.mode = this.mode;
  a.object.useArm = this.useArm;
  return a;
};
"use strict";
function KinectDevice() {
  THREE.Group.call(this);
  this.type = "Kinect";
  this.name = "kinect";
  this.socket = new WebSocket("ws://127.0.0.1:8181");
  this.connected = !1;
  this.debugModel = !0;
  this.dataTimeout = 0;
  this.data = this.camera = null;
  this.dataReceived = !1;
  var a = this;
  this.socket.onopen = function() {
    a.connected = !0;
  };
  this.socket.onclose = function() {
    a.connected = !1;
  };
  this.socket.onmessage = function(d) {
    "string" === typeof d.data ? (a.data = JSON.parse(d.data), a.dataReceived = !0, a.dataTimeout = KinectDevice.DATA_TIMEOUT) : d.data instanceof Blob && (a.camera = d.data);
  };
}
KinectDevice.DATA_TIMEOUT = 20;
KinectDevice.DEPTH = 0;
KinectDevice.COLOR = 1;
KinectDevice.JOINTS_NAME = [["head", "shouldercenter"], ["shouldercenter", "shoulderright"], ["shouldercenter", "shoulderleft"], ["shoulderright", "elbowright"], ["shoulderleft", "elbowleft"], ["elbowright", "wristright"], ["elbowleft", "wristleft"], ["wristright", "handright"], ["wristleft", "handleft"], ["shouldercenter", "spine"], ["spine", "hipcenter"], ["hipcenter", "hipright"], ["hipcenter", "hipleft"], ["hipright", "kneeright"], ["hipleft", "kneeleft"], ["kneeright", "ankleright"], ["kneeleft", 
"ankleleft"], ["ankleright", "footright"], ["ankleleft", "footleft"]];
KinectDevice.prototype = Object.create(THREE.Group.prototype);
KinectDevice.prototype.update = function(a) {
  if (null !== this.data) {
    if (this.dataReceived) {
      for (this.dataReceived = !1; 0 < this.children.length;) {
        this.children.pop();
      }
      if (this.debugModel) {
        for (var d = new THREE.SphereGeometry(.04, 6, 6), g = new THREE.MeshPhongMaterial(16711680), h = 0; h < this.data.skeletons.length; h++) {
          for (var e = this.data.skeletons[h].joints, k = 0; k < e.length; k++) {
            var c = new Mesh(d, g);
            c.position.set(e[k].x, e[k].y, e[k].z);
            c.castShadow = !0;
            this.add(c);
          }
        }
      }
    } else {
      if (0 < this.dataTimeout && (this.dataTimeout--, 0 === this.dataTimeout)) {
        for (; 0 < this.children.length;) {
          this.children.pop();
        }
      }
    }
  }
  THREE.Object3D.prototype.update.call(this, a);
};
KinectDevice.prototype.isConnected = function() {
  return this.connected;
};
KinectDevice.prototype.setCameraMode = function(a) {
  a === KinectDevice.COLOR ? socket.send("Color") : a === KinectDevice.DEPTH && socket.send("Depth");
};
KinectDevice.prototype.toJSON = function(a) {
  a = THREE.Group.prototype.toJSON.call(this, a);
  a.object.debugModel = this.debugModel;
  return a;
};
"use strict";
function Mesh(a, d) {
  THREE._Mesh.call(this, a, d);
  this.name = "model";
  this.castShadow = this.receiveShadow = !0;
}
THREE._Mesh = THREE.Mesh;
THREE.Mesh = Mesh;
Mesh.prototype = Object.create(THREE._Mesh.prototype);
Mesh.prototype.dispose = function() {
  null !== this.material && void 0 !== this.material.dispose && this.material.dispose();
  null !== this.geometry && void 0 !== this.geometry.dispose && this.geometry.dispose();
  THREE.Object3D.prototype.dispose.call(this);
};
"use strict";
function SkinnedMesh(a, d) {
  THREE._SkinnedMesh.call(this, a, d);
  this.name = "skinned";
  this.castShadow = this.receiveShadow = !0;
  this.skeleton = null;
}
THREE._SkinnedMesh = THREE.SkinnedMesh;
THREE.SkinnedMesh = SkinnedMesh;
SkinnedMesh.prototype = Object.create(THREE._SkinnedMesh.prototype);
SkinnedMesh.prototype.dispose = function() {
  null !== this.material && void 0 !== this.material.dispose && this.material.dispose();
  null !== this.geometry && void 0 !== this.geometry.dispose && this.geometry.dispose();
  THREE.Object3D.prototype.dispose.call(this);
};
SkinnedMesh.prototype.toJSON = function(a) {
  var d = this;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, h) {
    null !== d.skeleton && (void 0 === a.skeletons[d.skeleton.uuid] && (a.skeletons[d.skeleton.uuid] = d.skeleton.toJSON(a)), h.skeleton = d.skeleton.uuid);
  });
  void 0 !== this.bindMode && (a.object.bindMode = this.bindMode);
  void 0 !== this.bindMatrix && (a.object.bindMatrix = this.bindMatrix.toArray());
  return a;
};
"use strict";
function InstancedMesh(a, d, g) {
  THREE._InstancedMesh.call(this, a, d, g);
  this.name = "instanced";
  this.type = "InstancedMesh";
  this.castShadow = this.receiveShadow = !0;
  Object.defineProperties(this, {count:{get:function() {
    return g;
  }, set:function(a) {
    a > g && (this.instanceMatrix = new THREE.BufferAttribute(new Float32Array(16 * a), 16));
    g = a;
  }}});
}
THREE._InstancedMesh = THREE.InstancedMesh;
THREE.InstancedMesh = InstancedMesh;
InstancedMesh.prototype = Object.create(THREE._InstancedMesh.prototype);
InstancedMesh.prototype.dispose = function() {
  null !== this.material && void 0 !== this.material.dispose && this.material.dispose();
  null !== this.geometry && this.geometry.dispose();
  THREE.Object3D.prototype.dispose.call(this);
};
InstancedMesh.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.instanceMatrix = this.instanceMatrix.toJSON();
  a.object.count = this.count;
  return a;
};
"use strict";
function CanvasSprite() {
  this.texture = new CanvasTexture;
  this.canvas = this.texture.image;
  var a = new THREE.SpriteMaterial({map:this.texture, color:16777215, transparent:!0, alphaTest:.4, depthTest:!0, depthWrite:!0, sizeAttenuation:!0});
  THREE.Sprite.call(this, a);
  this.name = "sprite";
  this.type = "CanvasSprite";
  Object.defineProperties(this, {sizeAttenuation:{get:function() {
    return this.material.sizeAttenuation;
  }, set:function(a) {
    this.material.sizeAttenuation = a;
    this.material.needsUpdate = !0;
  }}});
}
CanvasSprite.prototype = Object.create(THREE.Sprite.prototype);
"use strict";
function Sprite(a) {
  THREE._Sprite.call(this, a);
  this.name = "sprite";
}
THREE._Sprite = THREE.Sprite;
THREE.Sprite = Sprite;
Sprite.prototype = Object.create(THREE._Sprite.prototype);
Sprite.prototype.dispose = function() {
  null !== this.material && void 0 !== this.material.dispose && this.material.dispose();
  THREE.Object3D.prototype.dispose.call(this);
};
"use strict";
function TextMesh(a, d, g, h, e, k, c, p, t, f) {
  Mesh.call(this, TextMesh.EMPTY_GEOMETRY, d);
  this.name = "text";
  this.type = "TextMesh";
  this.font = void 0 !== g ? g : null;
  this.extruded = void 0 !== f ? f : !0;
  this.size = void 0 !== p ? p : 1;
  this.height = void 0 !== h ? h : .5;
  this.curveSegments = void 0 !== t ? t : 15;
  this.bevel = void 0 !== e ? e : !1;
  this.bevelThickness = void 0 !== k ? k : .1;
  this.bevelSize = void 0 !== c ? c : .05;
  a = void 0 !== a ? a : "text";
  Object.defineProperties(this, {text:{get:function() {
    return a;
  }, set:function(c) {
    a !== c && (a = c, this.updateGeometry());
  }}});
  this.updateGeometry();
}
TextMesh.prototype = Object.create(Mesh.prototype);
TextMesh.EMPTY_GEOMETRY = new THREE.Geometry;
TextMesh.prototype.setFont = function(a) {
  this.font !== a && (this.font = a, this.updateGeometry());
};
TextMesh.prototype.setText = function(a) {
  this.text = a;
};
TextMesh.prototype.updateGeometry = function() {
  if (null !== this.font) {
    if (void 0 !== this.geometry && this.geometry.dispose(), !0 !== this.font.isFont) {
      console.warn("nunuStudio: Font parameter is not an instance of THREE.Font."), this.geometry = TextMesh.EMPTY_GEOMETRY;
    } else {
      var a = this.font.generateShapes(this.text, this.size);
      this.extruded ? (this.geometry = new THREE.ExtrudeBufferGeometry(a, {curveSegments:this.curveSegments, depth:this.height, bevelEnabled:this.bevel, bevelSize:this.bevelSize, bevelThickness:this.bevelThickness}), this.geometry.computeVertexNormals()) : this.geometry = new THREE.ShapeBufferGeometry(a, this.curveSegments);
    }
  }
};
TextMesh.prototype.clone = function() {
  return new TextMesh(this.text, this.material, this.font, this.height, this.bevel, this.bevelThickness, this.bevelSize, this.size, this.curveSegments);
};
TextMesh.prototype.toJSON = function(a) {
  var d = this.geometry;
  this.geometry = void 0;
  var g = this.font;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, d) {
    g = g.toJSON(a);
  });
  a.object.text = this.text;
  a.object.font = g.uuid;
  a.object.size = this.size;
  a.object.curveSegments = this.curveSegments;
  a.object.height = this.height;
  a.object.bevel = this.bevel;
  a.object.bevelThickness = this.bevelThickness;
  a.object.bevelSize = this.bevelSize;
  a.object.extruded = this.extruded;
  this.geometry = d;
  return a;
};
"use strict";
function TextBitmap(a, d, g, h) {
  if (void 0 === a.font) {
    throw Error("TextBitmap configuration font is required.");
  }
  void 0 === a.width && (a.width = 500);
  void 0 === a.align && (a.align = TextBitmap.CENTER);
  void 0 === a.lineHeight && (a.lineHeight = a.font.common.lineHeight);
  void 0 === a.letterSpacing && (a.letterSpacing = 5);
  void 0 === a.text && (a.text = "");
  this.config = a;
  this.uniforms = {map:{type:"t", value:d}, color:{type:"v3", value:new THREE.Color(void 0 !== h ? h : 16777215)}, smoothing:{type:"f", value:0}, threshold:{type:"f", value:.4}};
  THREE.Mesh.call(this, createGeometry(this.config), null);
  this.name = "text";
  this.type = "TextBitmap";
  g = void 0 !== g ? g : TextBitmap.BITMAP;
  var e = .01;
  Object.defineProperties(this, {fontScale:{get:function() {
    return e;
  }, set:function(a) {
    e = a;
    this.updateGeometry();
  }}, shader:{get:function() {
    return g;
  }, set:function(a) {
    g = a;
    this.updateShader();
  }}, texture:{get:function() {
    return this.uniforms.map.value;
  }, set:function(a) {
    this.uniforms.map.value = a;
    this.material.needsUpdate = !0;
  }}, font:{get:function() {
    return this.config.font;
  }, set:function(a) {
    this.config.font = a;
    this.updateGeometry();
  }}, text:{get:function() {
    return this.config.text;
  }, set:function(a) {
    this.config.text !== a && (this.config.text = a, this.updateGeometry());
  }}, lineHeight:{get:function() {
    return this.config.lineHeight;
  }, set:function(a) {
    this.config.lineHeight = a;
    this.updateGeometry();
  }}, letterSpacing:{get:function() {
    return this.config.letterSpacing;
  }, set:function(a) {
    this.config.letterSpacing = a;
    this.updateGeometry();
  }}, align:{get:function() {
    return this.config.align;
  }, set:function(a) {
    this.config.align = a;
    this.updateGeometry();
  }}, width:{get:function() {
    return this.config.width;
  }, set:function(a) {
    this.config.width = a;
    this.updateGeometry();
  }}, color:{get:function() {
    return this.uniforms.color.value;
  }, set:function(a) {
    this.uniforms.color.value = a;
  }}, threshold:{get:function() {
    return this.uniforms.threshold.value;
  }, set:function(a) {
    this.uniforms.threshold.value = a;
  }}, smoothing:{get:function() {
    return this.uniforms.smoothing.value;
  }, set:function(a) {
    this.uniforms.smoothing.value = a;
  }}});
  this.updateGeometry();
  this.updateShader(d);
}
TextBitmap.prototype = Object.create(THREE.Mesh.prototype);
TextBitmap.prototype.constructor = TextBitmap;
TextBitmap.BITMAP = 100;
TextBitmap.SDF = 101;
TextBitmap.MSDF = 102;
TextBitmap.LEFT = "left";
TextBitmap.CENTER = "center";
TextBitmap.RIGHT = "right";
TextBitmap.VERTEX_SHADER = "\n#define BILLBOARD 0 \n\nvarying vec2 vUv;\n\nvoid main()\n{\n\tvUv = uv;\n\t\n\t#if BILLBOARD\n\t\tmat4 model = modelViewMatrix; \n\t\tmodel[0][0] = 1.0;\n\t\tmodel[0][1] = 0.0;\n\t\tmodel[0][2] = 0.0;\n\t\t\n\t\tmodel[1][0] = 0.0;\n\t\tmodel[1][1] = 1.0;\n\t\tmodel[1][2] = 0.0;\n\t\t\n\t\tmodel[2][0] = 0.0;\n\t\tmodel[2][1] = 0.0;\n\t\tmodel[2][2] = 1.0;\n\t\t\n\t\tgl_Position = projectionMatrix * model * vec4(position, 1.0);\n\t#else\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t#endif\n\t\n}";
TextBitmap.BITMAP_SHADER = "\nvarying vec2 vUv;\nuniform sampler2D map;\n\nvoid main()\n{\n\tgl_FragColor = texture2D(map, vUv);\n}";
TextBitmap.SDF_SHADER = "\nvarying vec2 vUv;\nuniform sampler2D map;\nuniform vec3 color;\nuniform float smoothing;\nuniform float threshold;\n\nvoid main()\n{\n\tfloat distance = texture2D(map, vUv).a;\n\tfloat alpha = smoothstep(threshold - smoothing, threshold + smoothing, distance);\n\tgl_FragColor = vec4(color, alpha);\n}";
TextBitmap.MSDF_SHADER = "\n#extension GL_OES_standard_derivatives : enable\n\nvarying vec2 vUv;\nuniform sampler2D map;\nuniform vec3 color;\nuniform float smoothing;\nuniform float threshold;\n\nfloat median(float r, float g, float b)\n{\n\treturn max(min(r, g), min(max(r, g), b));\n}\n\nvoid main()\n{\n\tvec3 sample = texture2D(map, vUv).rgb;\n\tfloat sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n\tfloat alpha = clamp(sigDist / fwidth(sigDist) + 0.5, 0.0, 1.0);\n\tgl_FragColor = vec4(color, 1.0 - alpha);\n}";
TextBitmap.prototype.setText = function(a) {
  this.text = a;
};
TextBitmap.prototype.updateShader = function() {
  this.material = new THREE.ShaderMaterial({uniforms:this.uniforms, fragmentShader:this.shader === TextBitmap.SDF ? TextBitmap.SDF_SHADER : this.shader === TextBitmap.MSDF ? TextBitmap.MSDF_SHADER : TextBitmap.BITMAP_SHADER, vertexShader:TextBitmap.VERTEX_SHADER, side:THREE.DoubleSide, transparent:!0, depthTest:!0});
};
TextBitmap.prototype.updateGeometry = function() {
  this.geometry.update(this.config);
  if (1 !== this.fontScale) {
    for (var a = this.geometry.attributes.position.array, d = 0; d < a.length; d++) {
      a[d] *= this.fontScale;
    }
  }
};
TextBitmap.prototype.toJSON = function(a) {
  var d = THREE.Object3D.prototype.toJSON.call(this, a);
  d.object.texture = this.texture.toJSON(a).uuid;
  d.object.fontScale = this.fontScale;
  d.object.shader = this.shader;
  d.object.text = this.text;
  d.object.font = this.font;
  d.object.lineHeight = this.lineHeight;
  d.object.letterSpacing = this.letterSpacing;
  d.object.align = this.align;
  d.object.width = this.width;
  d.object.color = this.color;
  d.object.threshold = this.threshold;
  d.object.smoothing = this.smoothing;
  return d;
};
TextBitmap.fromJSON = function(a, d) {
  d = new TextBitmap(a, d, a.shader);
  d.color = a.color;
  d.threshold = a.threshold;
  d.smoothing = a.smoothing;
  d.fontScale = a.fontScale;
  return d;
};
"use strict";
function TextSprite() {
  CanvasSprite.call(this);
  this.name = "text";
  this.type = "TextSprite";
  var a = "", d = "#FFFFFF", g = !0, h = "#000000", e = 1, k = 32, c = TextSprite.CENTER, p = "arial";
  Object.defineProperties(this, {font:{get:function() {
    return p;
  }, set:function(a) {
    p = a;
    this.drawText();
  }}, align:{get:function() {
    return c;
  }, set:function(a) {
    c = a;
    this.drawText();
  }}, color:{get:function() {
    return d;
  }, set:function(a) {
    d = a;
    this.drawText();
  }}, text:{get:function() {
    return a;
  }, set:function(c) {
    c !== a && (a = c, this.drawText());
  }}, outline:{get:function() {
    return g;
  }, set:function(a) {
    g = a;
    this.drawText();
  }}, outlineColor:{get:function() {
    return h;
  }, set:function(a) {
    h = a;
    this.drawText();
  }}, outlineWidth:{get:function() {
    return e;
  }, set:function(a) {
    e = a;
    this.drawText();
  }}, resolution:{get:function() {
    return k;
  }, set:function(a) {
    k = a;
    this.drawText();
  }}});
  this.text = "text";
}
TextSprite.prototype = Object.create(CanvasSprite.prototype);
TextSprite.LEFT = "left";
TextSprite.CENTER = "center";
TextSprite.RIGHT = "right";
TextSprite.prototype.drawText = function() {
  var a = this.resolution, d = .8 * a, g = this.texture.context;
  g.font = d + "px " + this.font;
  var h = g.measureText(this.text).width;
  h = THREE.Math.ceilPowerOfTwo(h);
  var e = h / a;
  this.texture.width = h;
  this.texture.height = a;
  g.clearRect(0, 0, h, a);
  0 !== this.text.length && (g.font = d + "px " + this.font, g.textAlign = this.align, g.textBaseline = "middle", g.fillStyle = this.color, g.fillText(this.text, h / 2, a / 2), !0 === this.outline && (g.lineWidth = this.outlineWidth, g.strokeStyle = this.outlineColor, g.strokeText(this.text, h / 2, a / 2)), this.scale.x = e * this.scale.y, this.texture.needsUpdate = !0);
};
TextSprite.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.text = this.text;
  a.object.color = this.color;
  a.object.outline = this.outline;
  a.object.outlineColor = this.outlineColor;
  a.object.outlineWidth = this.outlineWidth;
  a.object.resolution = this.resolution;
  a.object.align = this.align;
  a.object.font = this.font;
  return a;
};
TextSprite.fromJSON = function(a) {
  var d = new TextSprite;
  d.text = a.text;
  d.color = a.color;
  d.outline = a.outline;
  d.outlineColor = a.outlineColor;
  d.outlineWidth = a.outlineWidth;
  d.resolution = a.resolution;
  d.align = a.align;
  d.font = a.font;
  return d;
};
"use strict";
function PointLight(a, d, g, h) {
  THREE._PointLight.call(this, a, d, g, h);
  this.name = "point";
  this.castShadow = !0;
  this.shadow.camera.near = .1;
  this.shadow.camera.far = 1E3;
  this.shadow.bias = 0;
}
THREE._PointLight = THREE.PointLight;
THREE.PointLight = PointLight;
PointLight.prototype = Object.create(THREE._PointLight.prototype);
PointLight.prototype.updateShadowMap = function() {
  this.shadow.map.dispose();
  this.shadow.map = null;
  this.shadow.camera.updateProjectionMatrix();
};
"use strict";
function SpotLight(a, d, g, h, e, k) {
  THREE._SpotLight.call(this, a, d, g, h, e, k);
  this.name = "spotlight";
  this.castShadow = !0;
  this.shadow.camera.near = .05;
  this.shadow.camera.far = 5E3;
  this.shadow.mapSize.width = 512;
  this.shadow.mapSize.height = 512;
}
THREE._SpotLight = THREE.SpotLight;
THREE.SpotLight = SpotLight;
SpotLight.prototype = Object.create(THREE._SpotLight.prototype);
SpotLight.prototype.setTarget = function(a) {
  this.target = a;
};
SpotLight.prototype.updateShadowMap = function() {
  this.shadow.map.dispose();
  this.shadow.map = null;
  this.shadow.camera.updateProjectionMatrix();
};
SpotLight.prototype.toJSON = function(a) {
  a = THREE.Light.prototype.toJSON.call(this, a);
  a.object.target = this.target.uuid;
  return a;
};
"use strict";
function AmbientLight(a) {
  THREE._AmbientLight.call(this, a);
  this.name = "ambient";
  this.matrixAutoUpdate = !1;
}
THREE._AmbientLight = THREE.AmbientLight;
THREE.AmbientLight = AmbientLight;
AmbientLight.prototype = Object.create(THREE._AmbientLight.prototype);
"use strict";
function DirectionalLight(a, d) {
  THREE._DirectionalLight.call(this, a, d);
  this.name = "directional";
  this.castShadow = !0;
  this.shadow.camera.near = .5;
  this.shadow.camera.far = 1E4;
}
THREE._DirectionalLight = THREE.DirectionalLight;
THREE.DirectionalLight = DirectionalLight;
DirectionalLight.prototype = Object.create(THREE._DirectionalLight.prototype);
DirectionalLight.prototype.updateShadowMap = function() {
  this.shadow.map.dispose();
  this.shadow.map = null;
  this.shadow.camera.updateProjectionMatrix();
};
"use strict";
function HemisphereLight(a, d, g) {
  THREE._HemisphereLight.call(this, a, d, g);
  this.name = "hemisphere";
}
THREE._HemisphereLight = THREE.HemisphereLight;
THREE.HemisphereLight = HemisphereLight;
HemisphereLight.prototype = Object.create(THREE._HemisphereLight.prototype);
"use strict";
function RectAreaLight(a, d, g, h) {
  THREE._RectAreaLight.call(this, a, d, g, h);
  this.name = "rectarea";
}
THREE._RectAreaLight = THREE.RectAreaLight;
THREE.RectAreaLight = RectAreaLight;
RectAreaLight.prototype = Object.create(THREE._RectAreaLight.prototype);
RectAreaLight.prototype.toJSON = function(a) {
  a = THREE.Light.prototype.toJSON.call(this, a);
  a.object.width = this.width;
  a.object.height = this.height;
  return a;
};
"use strict";
function LightProbe(a, d) {
  THREE._LightProbe.call(this, a, d);
  this.type = "LightProbe";
  this.name = "probe";
}
THREE._LightProbe = THREE.LightProbe;
THREE.LightProbe = LightProbe;
LightProbe.prototype = Object.create(THREE._LightProbe.prototype);
LightProbe.prototype.generate = function() {
  var a = this.getScene();
  if (null === a) {
    console.warn("nunuStudio: LightProbe cannot generate, no scene.", this);
  } else {
    var d = new OffscreenCanvas(256, 256);
    d = new THREE.WebGLRenderer({canvas:d, alpha:!0});
    var g = new THREE._CubeCamera(1, 1E3, 256, {format:THREE.RGBAFormat, magFilter:THREE.LinearFilter, minFilter:THREE.LinearFilter});
    g.matrixAutoUpdate = !1;
    g.matrix.copy(this.matrix);
    g.matrixWorld.copy(this.matrixWorld);
    g.renderTarget.texture.encoding = THREE.sRGBEncoding;
    g.update(d, a);
    this.sh = LightProbeGenerator.fromCubeRenderTarget(d, g.renderTarget).sh;
  }
};
LightProbe.prototype.toJSON = function(a) {
  a = THREE.Light.prototype.toJSON.call(this, a);
  a.object.sh = this.sh.toArray();
  return a;
};
"use strict";
function Viewport(a) {
  this.offset = new THREE.Vector2(0, 0);
  this.size = new THREE.Vector2(1, 1);
  this.mode = void 0 !== a ? a : Viewport.RELATIVE;
  this.anchor = Viewport.TOP_LEFT;
  this.height = this.width = 1;
  this.viewport = new THREE.Vector4(0, 0, 1, 1);
}
Viewport.RELATIVE = 200;
Viewport.ABSOLUTE = 201;
Viewport.TOP_LEFT = 301;
Viewport.TOP_RIGHT = 302;
Viewport.BOTTOM_LEFT = 303;
Viewport.BOTTOM_RIGHT = 304;
Viewport.prototype.update = function(a) {
  var d;
  if (void 0 === a) {
    var g = d = 0;
    var h = this.width;
    a = this.height;
  } else {
    d = a.viewport.x, g = a.viewport.y, h = a.viewport.z, a = a.viewport.w;
  }
  if (this.mode === Viewport.RELATIVE) {
    var e = new THREE.Vector2(this.offset.x * h, this.offset.y * a);
    var k = new THREE.Vector2(this.size.x * h, this.size.y * a);
  } else {
    this.mode === Viewport.ABSOLUTE && (e = this.offset, k = this.size);
  }
  this.anchor === Viewport.BOTTOM_LEFT ? this.viewport.set(e.x + d, e.y + g, k.x, k.y) : this.anchor === Viewport.BOTTOM_RIGHT ? this.viewport.set(h - k.x - e.x + d, e.y + g, k.x, k.y) : this.anchor === Viewport.TOP_LEFT ? this.viewport.set(e.x + d, a - k.y - e.y + g, k.x, k.y) : this.anchor === Viewport.TOP_RIGHT && this.viewport.set(h - k.x - e.x + d, a - k.y - e.y + g, k.x, k.y);
};
Viewport.prototype.getAspectRatio = function() {
  return this.viewport.z / this.viewport.w;
};
Viewport.prototype.isInside = function(a, d) {
  return d.position.x > this.viewport.x && d.position.x < this.viewport.x + this.viewport.z && d.position.y < this.height - this.viewport.y && d.position.y > this.height - this.viewport.y - this.viewport.w;
};
Viewport.prototype.getNormalized = function() {
  var a = new THREE.Vector2;
  return function(d, g) {
    a.set((g.position.x - this.viewport.z - this.viewport.x) / this.viewport.z * 2 + 1, -(g.position.y - (this.height - (this.viewport.y + this.viewport.w))) / this.viewport.w * 2 + 1);
    return a;
  };
}();
Viewport.prototype.enable = function(a) {
  a.setViewport(this.viewport);
  a.setScissor(this.viewport);
};
Viewport.prototype.toJSON = function() {
  return {offset:this.offset.toArray(), size:this.size.toArray(), mode:this.mode, anchor:this.anchor};
};
Viewport.prototype.fromJSON = function(a) {
  this.offset.fromArray(a.offset);
  this.size.fromArray(a.size);
  this.mode = a.mode;
  this.anchor = a.anchor;
};
"use strict";
function PerspectiveCamera(a, d, g, h) {
  this.viewport = new Viewport;
  THREE.PerspectiveCamera.call(this, a, d, g, h);
  this.name = "camera";
  this.clearStencil = this.clearDepth = this.clearColor = !0;
  this.order = 0;
  this.composer = new EffectComposer;
  a = new RenderPass;
  a.renderToScreen = !0;
  this.composer.addPass(a);
}
PerspectiveCamera.prototype = Object.create(THREE.PerspectiveCamera.prototype);
PerspectiveCamera.prototype.resize = function(a, d, g) {
  this.viewport.width = a;
  this.viewport.height = d;
  this.viewport.update(g);
  this.aspect = this.viewport.getAspectRatio();
  this.updateProjectionMatrix();
  this.composer.setSize(this.viewport.viewport.z, this.viewport.viewport.w);
};
PerspectiveCamera.prototype.setupRenderer = function(a) {
  this.viewport.enable(a);
  a.clear(this.clearColor, this.clearDepth, this.clearStencil);
};
PerspectiveCamera.prototype.render = function(a, d) {
  this.composer.render(a, d, this, .016);
};
PerspectiveCamera.prototype.destroy = function() {
  var a = this.getScene();
  null !== a && a.removeCamera(this);
  THREE.Object3D.prototype.destroy.call(this);
};
PerspectiveCamera.prototype.updateProjectionMatrix = function() {
  var a = this.near * Math.tan(.5 * THREE.Math.DEG2RAD * this.fov) / this.zoom, d = 2 * a, g = this.aspect * d, h = -.5 * g;
  0 !== this.filmOffset && (h += this.near * this.filmOffset / this.getFilmWidth());
  this.projectionMatrix.makePerspective(h, h + g, a, a - d, this.near, this.far);
  this.projectionMatrixInverse.getInverse(this.projectionMatrix);
};
PerspectiveCamera.prototype.toJSON = function(a) {
  a = THREE.PerspectiveCamera.prototype.toJSON.call(this, a);
  a.object.clearColor = this.clearColor;
  a.object.clearDepth = this.clearDepth;
  a.object.clearStencil = this.clearStencil;
  a.object.viewport = this.viewport.toJSON();
  a.object.order = this.order;
  a.object.composer = this.composer.toJSON();
  return a;
};
"use strict";
function OrthographicCamera(a, d, g, h, e) {
  THREE.OrthographicCamera.call(this, -1, 1, 1, -1, h, e);
  this.name = "camera";
  this.size = void 0 != a ? a : 10;
  this.aspect = void 0 != d ? d : 1;
  this.mode = void 0 !== g ? g : OrthographicCamera.RESIZE_HORIZONTAL;
  this.viewport = new Viewport;
  this.clearStencil = this.clearDepth = this.clearColor = !0;
  this.order = 0;
  this.updateProjectionMatrix();
  this.composer = new EffectComposer;
  a = new RenderPass;
  a.renderToScreen = !0;
  this.composer.addPass(a);
}
OrthographicCamera.prototype = Object.create(THREE.OrthographicCamera.prototype);
OrthographicCamera.RESIZE_HORIZONTAL = 0;
OrthographicCamera.RESIZE_VERTICAL = 1;
OrthographicCamera.prototype.resize = function(a, d, g) {
  this.viewport.width = a;
  this.viewport.height = d;
  this.viewport.update(g);
  this.aspect = this.viewport.getAspectRatio();
  this.updateProjectionMatrix();
  this.composer.setSize(this.viewport.viewport.z, this.viewport.viewport.w);
};
OrthographicCamera.prototype.setupRenderer = function(a) {
  this.viewport.enable(a);
  a.clear(this.clearColor, this.clearDepth, this.clearStencil);
};
OrthographicCamera.prototype.render = function(a, d) {
  this.composer.render(a, d, this, .016);
};
OrthographicCamera.prototype.destroy = function() {
  var a = this.getScene();
  null !== a && a.removeCamera(this);
  THREE.Object3D.prototype.destroy.call(this);
};
OrthographicCamera.prototype.updateProjectionMatrix = function() {
  this.mode === OrthographicCamera.RESIZE_HORIZONTAL ? (this.top = this.size / 2, this.bottom = -this.top, this.right = this.top * this.aspect, this.left = -this.right) : this.mode === OrthographicCamera.RESIZE_VERTICAL && (this.right = this.size / 2, this.left = -this.right, this.top = this.right / this.aspect, this.bottom = -this.top);
  THREE.OrthographicCamera.prototype.updateProjectionMatrix.call(this);
};
OrthographicCamera.prototype.toJSON = function(a) {
  a = THREE.OrthographicCamera.prototype.toJSON.call(this, a);
  a.object.size = this.size;
  a.object.aspect = this.aspect;
  a.object.mode = this.mode;
  a.object.clearColor = this.clearColor;
  a.object.clearDepth = this.clearDepth;
  a.object.clearStencil = this.clearStencil;
  a.object.viewport = this.viewport.toJSON();
  a.object.order = this.order;
  a.object.composer = this.composer.toJSON();
  return a;
};
"use strict";
function CubeCamera(a, d, g, h) {
  THREE.Object3D.call(this);
  this.name = "cubecamera";
  this.type = "CubeCamera";
  this.near = void 0 !== a ? a : .01;
  this.far = void 0 !== d ? d : 1E4;
  this.resolution = void 0 !== g ? g : 256;
  this.autoUpdate = void 0 !== h ? h : !1;
  this.cameras = [];
  for (a = 0; 6 > a; a++) {
    d = new THREE.PerspectiveCamera(90, 1, this.near, this.far), d.parent = this, this.cameras.push(d);
  }
  this.cameras[0].up.set(0, -1, 0);
  this.cameras[0].lookAt(new THREE.Vector3(1, 0, 0));
  this.cameras[1].up.set(0, -1, 0);
  this.cameras[1].lookAt(new THREE.Vector3(-1, 0, 0));
  this.cameras[2].up.set(0, 0, 1);
  this.cameras[2].lookAt(new THREE.Vector3(0, 1, 0));
  this.cameras[3].up.set(0, 0, -1);
  this.cameras[3].lookAt(new THREE.Vector3(0, -1, 0));
  this.cameras[4].up.set(0, -1, 0);
  this.cameras[4].lookAt(new THREE.Vector3(0, 0, 1));
  this.cameras[5].up.set(0, -1, 0);
  this.cameras[5].lookAt(new THREE.Vector3(0, 0, -1));
  this.renderTarget = new THREE.WebGLCubeRenderTarget(new THREE.Vector2(this.resolution, this.resolution), {format:THREE.RGBFormat, magFilter:THREE.LinearFilter, minFilter:THREE.LinearFilter});
  this.cube = this.renderTarget.texture;
  this.cube.generateMipmaps = !1;
  this.cube.name = "cube";
  this.renderer = this.scene = null;
}
THREE._CubeCamera = THREE.CubeCamera;
THREE.CubeCamera = CubeCamera;
CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
CubeCamera.prototype.initialize = function() {
  for (var a = this; null !== a.parent;) {
    a = a.parent, a instanceof Scene ? this.scene = a : a instanceof Program && (this.renderer = a.renderer);
  }
  THREE.Object3D.prototype.initialize.call(this);
};
CubeCamera.prototype.update = function(a) {
  this.autoUpdate && this.updateCubeMap(this.renderer, this.scene);
  THREE.Object3D.prototype.update.call(this, a);
};
CubeCamera.prototype.setResolution = function(a) {
  this.resolution = a;
  this.renderTarget.setSize(a, a);
};
CubeCamera.prototype.clear = function(a, d, g, h) {
  for (var e = a.getRenderTarget(), k = 0; 6 > k; k++) {
    a.setRenderTarget(this.renderTarget, k), a.clear(d, g, h);
  }
  a.setRenderTarget(e);
};
CubeCamera.prototype.updateCubeMap = function(a, d) {
  var g = a.autoClear;
  a.autoClear = !0;
  for (var h = 0; 6 > h; h++) {
    this.cameras[h].updateMatrixWorld(), a.setRenderTarget(this.renderTarget, h), a.render(d, this.cameras[h]);
  }
  a.autoClear = g;
};
CubeCamera.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.near = this.near;
  a.object.far = this.far;
  a.object.resolution = this.resolution;
  a.object.autoUpdate = this.autoUpdate;
  return a;
};
"use strict";
function AudioEmitter(a) {
  THREE.Object3D.call(this);
  this.name = "audio";
  this.type = "Audio";
  this.listener = new THREE.AudioListener;
  this.context = this.listener.context;
  this.matrixAutoUpdate = !1;
  this.gain = this.context.createGain();
  this.gain.connect(this.listener.getInput());
  this.buffer = null;
  this.filters = [];
  this.sourceType = "empty";
  this.audio = void 0 !== a ? a : null;
  this.autoplay = !0;
  this.playbackRate = this.volume = 1;
  this.startTime = 0;
  this.loop = !0;
  this.detune = 0;
  this.isPlaying = !1;
  this.hasPlaybackControl = !0;
  this.filters = [];
}
THREE.Audio = AudioEmitter;
AudioEmitter.prototype = Object.create(THREE.Object3D.prototype);
AudioEmitter.SOURCE = {EMPTY:"empty", BUFFER:"buffer", NODE:"audioNode"};
AudioEmitter.prototype.onEnded = function() {
  this.isPlaying = !1;
};
AudioEmitter.prototype.connect = function() {
  if (0 < this.filters.length) {
    this.source.connect(this.filters[0]);
    for (var a = 1, d = this.filters.length; a < d; a++) {
      this.filters[a - 1].connect(this.filters[a]);
    }
    this.filters[this.filters.length - 1].connect(this.getOutput());
  } else {
    this.source.connect(this.getOutput());
  }
  return this;
};
AudioEmitter.prototype.disconnect = function() {
  if (0 < this.filters.length) {
    this.source.disconnect(this.filters[0]);
    for (var a = 1, d = this.filters.length; a < d; a++) {
      this.filters[a - 1].disconnect(this.filters[a]);
    }
    this.filters[this.filters.length - 1].disconnect(this.getOutput());
  } else {
    this.source.disconnect(this.getOutput());
  }
  return this;
};
AudioEmitter.prototype.initialize = function() {
  if (null !== this.audio) {
    var a = this;
    this.audio.getAudioBuffer(this.context, function(d) {
      a.setBuffer(d);
    });
  } else {
    console.warn("nunuStudio: AudioEmitter audio is null.");
  }
  this.setVolume(this.volume);
  this.setPlaybackRate(this.playbackRate);
  THREE.Object3D.prototype.initialize.call(this);
};
AudioEmitter.prototype.setBuffer = function(a) {
  this.buffer = a;
  this.sourceType = "buffer";
  !0 === this.autoplay && this.play();
  return this;
};
AudioEmitter.prototype.play = function() {
  if (null === this.buffer) {
    console.warn("nunuStudio: Audio buffer not ready, audio will not play.");
  } else {
    this.isPlaying && console.warn("nunuStudio: Audio is already playing, its only possible to control the last playing instance.");
    var a = this.context.createBufferSource();
    a.buffer = this.buffer;
    a.detune.value = this.detune;
    a.loop = this.loop;
    a.onended = this.onEnded.bind(this);
    a.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
    a.start(0, this.startTime);
    this.isPlaying = !0;
    this.source = a;
    return this.connect();
  }
};
AudioEmitter.prototype.pause = function() {
  this.source.stop();
  this.startTime = this.context.currentTime;
  this.isPlaying = !1;
  return this;
};
AudioEmitter.prototype.stop = function() {
  this.source.stop();
  this.startTime = 0;
  this.isPlaying = !1;
  return this;
};
AudioEmitter.prototype.setAudio = function(a) {
  this.audio = a;
  null !== this.buffer && (this.isPlaying && this.stop(), this.disconnect());
  var d = this;
  this.audio.getAudioBuffer(this.context, function(a) {
    d.setBuffer(a);
  });
};
AudioEmitter.prototype.getVolume = function() {
  return this.gain.gain.value;
};
AudioEmitter.prototype.setVolume = function(a) {
  this.volume = a;
  this.gain.gain.value = a;
  return this;
};
AudioEmitter.prototype.setLoop = function(a) {
  this.loop = a;
  this.isPlaying && (this.source.loop = this.loop);
  return this;
};
AudioEmitter.prototype.setDetune = function(a) {
  this.detune = a;
  !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01);
  return this;
};
AudioEmitter.prototype.getLoop = function() {
  return this.loop;
};
AudioEmitter.prototype.setPlaybackRate = function(a) {
  this.playbackRate = a;
  this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime);
  return this;
};
AudioEmitter.prototype.getPlaybackRate = function() {
  return this.playbackRate;
};
AudioEmitter.prototype.getFilters = function() {
  return this.filters;
};
AudioEmitter.prototype.setFilters = function(a) {
  a || (a = []);
  this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a;
  return this;
};
AudioEmitter.prototype.getFilter = function(a) {
  return this.getFilters()[void 0 !== a ? a : 0];
};
AudioEmitter.prototype.setFilter = function(a) {
  return this.setFilters(a ? [a] : []);
};
AudioEmitter.prototype.setNodeSource = function(a) {
  this.hasPlaybackControl = !1;
  this.sourceType = "audioNode";
  this.source = a;
  this.connect();
  return this;
};
AudioEmitter.prototype.getOutput = function() {
  return this.gain;
};
AudioEmitter.prototype.dispose = function() {
  this.isPlaying && (this.stop(), this.disconnect());
  THREE.Object3D.prototype.dispose.call(this);
};
AudioEmitter.prototype.toJSON = function(a) {
  var d = this.audio;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, h) {
    d = d.toJSON(a);
  });
  a.object.audio = d.uuid;
  a.object.volume = this.volume;
  a.object.autoplay = this.autoplay;
  a.object.startTime = this.startTime;
  a.object.playbackRate = this.playbackRate;
  a.object.loop = this.loop;
  return a;
};
"use strict";
function PositionalAudio(a) {
  AudioEmitter.call(this, a);
  this.type = "PositionalAudio";
  this.matrixAutoUpdate = !0;
  this.distanceModel = "inverse";
  this.panningModel = "HRTF";
  this.panner = this.context.createPanner();
  this.panner.connect(this.gain);
  this.panner.panningModel = this.panningModel;
  this.panner.distanceModel = this.distanceModel;
  this.panner.refDistance = 1;
  this.panner.maxDistance = 1E4;
  this.panner.rolloffFactor = 1;
  this.panner.coneInnerAngle = 360;
  this.panner.coneOuterAngle = 0;
  this.panner.coneOuterGain = 0;
  this.scene = null;
  this.tempPosition = new THREE.Vector3;
  this.tempPositionCamera = new THREE.Vector3;
  this.tempQuaternionCamera = new THREE.Quaternion;
}
THREE.PositionalAudio = PositionalAudio;
PositionalAudio.prototype = Object.create(AudioEmitter.prototype);
PositionalAudio.prototype.initialize = function() {
  AudioEmitter.prototype.initialize.call(this);
  for (var a = this.parent; null !== a;) {
    if (a instanceof Scene) {
      this.scene = a;
      break;
    }
    a = a.parent;
  }
};
PositionalAudio.prototype.update = function(a) {
  if (0 < this.scene.cameras.length) {
    var d = this.scene.cameras[0];
    this.getWorldPosition(this.tempPosition);
    d.getWorldPosition(this.tempPositionCamera);
    d.getWorldQuaternion(this.tempQuaternionCamera);
    this.tempPosition.sub(this.tempPositionCamera);
    this.tempPosition.z = -this.tempPosition.z;
    this.tempPosition.applyQuaternion(this.tempQuaternionCamera);
    this.panner.setPosition(this.tempPosition.x, this.tempPosition.z, this.tempPosition.y);
  } else {
    this.panner.setPosition(0, 0, 0), this.panner.setOrientation(0, 0, 0);
  }
  THREE.Object3D.prototype.update.call(this, a);
};
PositionalAudio.prototype.getOutput = function() {
  return this.panner;
};
PositionalAudio.prototype.getRefDistance = function() {
  return this.panner.refDistance;
};
PositionalAudio.prototype.setRefDistance = function(a) {
  this.panner.refDistance = a;
};
PositionalAudio.prototype.getRolloffFactor = function() {
  return this.panner.rolloffFactor;
};
PositionalAudio.prototype.setRolloffFactor = function(a) {
  this.panner.rolloffFactor = a;
};
PositionalAudio.prototype.getDistanceModel = function() {
  return this.panner.distanceModel;
};
PositionalAudio.prototype.setDistanceModel = function(a) {
  this.panner.distanceModel = a;
};
PositionalAudio.prototype.getMaxDistance = function() {
  return this.panner.maxDistance;
};
PositionalAudio.prototype.setMaxDistance = function(a) {
  this.panner.maxDistance = a;
};
PositionalAudio.prototype.toJSON = function(a) {
  a = AudioEmitter.prototype.toJSON.call(this, a);
  a.object.distanceModel = this.distanceModel;
  a.object.panningModel = this.panningModel;
  return a;
};
function Script(a, d) {
  THREE.Group.call(this);
  this.type = "Script";
  this.name = "script";
  this.code = void 0 !== a ? a : Script.DEFAULT;
  this.mode = void 0 !== d ? d : Script.APPEND;
  this.script = {};
  this.scene = this.program = null;
}
Script.prototype = Object.create(THREE.Group.prototype);
Script.includeRegex = /include[ ]*\([ \n]*["'].+?["'][ \n]*\);*/gi;
Script.includeRegexStart = /include[ ]*\([ \n]*["']/gi;
Script.includeRegexEnd = /["'][ \n]*\);*/gi;
Script.DEFAULT = "function initialize()\n{\n\t// TODO <INITIALIZATION CODE>\n}\n\nfunction update(delta)\n{\n\t// TODO <UPDATE CODE>\n}\n";
Script.METHODS = "initialize update dispose onMouseOver onResize onAppData".split(" ");
Script.APPEND = 100;
Script.EVALUATE = 101;
Script.INCLUDE = 102;
Script.getIncludes = function(a) {
  for (var d = [], g = new RegExp(Script.includeRegex, "gi");;) {
    var h = g.exec(a);
    if (null === h) {
      break;
    }
    h = h[0];
    h = h.replace(Script.includeRegexStart, "");
    h = h.replace(Script.includeRegexEnd, "");
    d.push(h);
  }
  return d;
};
Script.removeIncludes = function(a) {
  return a.replace(Script.includeRegex, "");
};
Script.prototype.initialize = function() {
  for (var a = this; null !== a.parent;) {
    a = a.parent, a instanceof Scene ? this.scene = a : a instanceof Program && (this.program = a);
  }
  THREE.Object3D.prototype.initialize.call(this);
  var d = this;
  this.compileCode(this.code, function() {
    void 0 !== d.script.initialize && d.script.initialize.call(d);
  });
};
Script.prototype.update = function(a) {
  if (void 0 !== this.script.onMouseOver) {
    var d = this.scene.raycaster.intersectObjects(this.children, !0);
    0 < d.length && this.script.onMouseOver.call(this, d);
  }
  void 0 !== this.script.update && this.script.update.call(this, a);
  THREE.Object3D.prototype.update.call(this, a);
};
Script.prototype.dispose = function() {
  void 0 !== this.script.dispose && this.script.dispose.call(this);
  THREE.Object3D.prototype.dispose.call(this);
};
Script.prototype.resize = function(a, d) {
  void 0 !== this.script.onResize && this.script.onResize.call(this, a, d);
};
Script.prototype.appData = function(a) {
  void 0 !== this.script.onAppData && this.script.onAppData.call(this, a);
};
Script.prototype.compileCode = function(a, d) {
  void 0 !== a && (this.code = a);
  try {
    a = this.code;
    for (var g = 0; g < Script.METHODS.length; g++) {
      var h = Script.METHODS[g];
      a += "\nif(this." + h + " == undefined && typeof " + h + " !== 'undefined'){this." + h + " = " + h + ";}";
    }
    if (this.mode === Script.APPEND) {
      var e = Script.getIncludes(a);
      a = Script.removeIncludes(a);
      for (g = 0; g < e.length; g++) {
        var k = this.program.getResourceByName(e[g]);
        if (null === k) {
          if (k = FileSystem.readFile(e[g], !0), null !== k) {
            a = k + "\n" + a;
          } else {
            throw Error("Script include() library " + e[g] + " not found.");
          }
        } else {
          a = k.data + "\n" + a;
        }
      }
      a += '\nfunction include(name)\t\t\t{\t\t\t\tconsole.warn("nunuStudio: Script running in append mode, " + name + " cannot be included in runtime.");\t\t\t}';
    } else {
      if (this.mode === Script.EVALUATE) {
        a += '\nfunction include(name)\t\t\t{\t\t\t\tvar text = program.getResourceByName(name);\t\t\t\tif(text === null)\t\t\t\t{\t\t\t\t\ttext = FileSystem.readFile(name, true);\t\t\t\t\tif(text !== null)\t\t\t\t\t{\t\t\t\t\t\tnew Function(text).call(this);\t\t\t\t\t}\t\t\t\t\telse\t\t\t\t\t{\t\t\t\t\t\tconsole.warn("nunuStudio: Javascript file " + name + " not found.");\t\t\t\t\t}\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tnew Function(text.data).call(this);\t\t\t\t}\t\t\t}';
      } else {
        if (this.mode === Script.INCLUDE) {
          e = Script.getIncludes(a);
          a = Script.removeIncludes(a);
          var c = 0, p = [];
          for (g = 0; g < e.length; g++) {
            var t = this.program.getResourceByName(e[g]);
            if (null !== t) {
              var f = new Blob([t.data], {type:"text/plain"});
              p.push(URL.createObjectURL(f));
            } else {
              var n = FileSystem.readFile(e[g], !0);
              if (null !== n) {
                f = new Blob([n], {type:"text/plain"}), p.push(URL.createObjectURL(f));
              } else {
                throw Error("Script include() library " + e[g] + " not found.");
              }
            }
          }
          if (0 < p.length) {
            for (g = 0; g < p.length; g++) {
              var b = document.createElement("script");
              b.type = "text/javascript";
              b.async = !0;
              b.src = url;
              b.onload = function() {
                c++;
                c === p.length && d();
              };
              b.onerror = b.onload;
              document.body.appendChild(b);
            }
          } else {
            d();
          }
        }
      }
    }
    var m = new Function("Keyboard, Mouse, self, program, scene", a);
    try {
      this.script = new m(this.program.keyboard, this.program.mouse, this, this.program, this.scene);
    } catch (q) {
      throw console.warn("nunuStudio: Error initializing script code", q), "Error initializing script code";
    }
    this.mode !== Script.INCLUDE && d();
  } catch (q) {
    throw console.warn("nunuStudio: Error compiling script code", q), "Error compiling script code";
  }
};
Script.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.code = this.code;
  a.object.mode = this.mode;
  return a;
};
"use strict";
function PhysicsObject() {
  THREE.Group.call(this);
  this.name = "physics";
  this.type = "Physics";
  this.body = new CANNON.Body;
  this.body.type = CANNON.Body.DYNAMIC;
  this.body.mass = 1;
  this.mode = PhysicsObject.LOCAL;
  this.world = null;
}
PhysicsObject.prototype = Object.create(THREE.Group.prototype);
PhysicsObject.LOCAL = 100;
PhysicsObject.WORLD = 101;
PhysicsObject.prototype.initialize = function() {
  if (this.mode === PhysicsObject.LOCAL) {
    this.body.position.copy(this.position), this.body.quaternion.copy(this.quaternion);
  } else {
    if (this.mode === PhysicsObject.WORLD) {
      var a = new THREE.Vector3;
      this.getWorldPosition(a);
      this.body.position.copy(a);
      a = new THREE.Quaternion;
      this.getWorldQuaternion(a);
      this.body.quaternion.copy(a);
    }
  }
  for (a = this; null !== a.parent;) {
    a = a.parent, a instanceof Scene && (this.world = a.world, this.world.addBody(this.body));
  }
  THREE.Object3D.prototype.initialize.call(this);
};
PhysicsObject.prototype.update = function(a) {
  if (this.mode === PhysicsObject.LOCAL) {
    this.position.copy(this.body.position), this.body.fixedRotation || this.quaternion.copy(this.body.quaternion);
  } else {
    if (this.mode === PhysicsObject.WORLD) {
      var d = new THREE.Matrix4;
      if (!this.body.fixedRotation) {
        var g = new THREE.Quaternion;
        g.copy(this.body.quaternion);
        d.makeRotationFromQuaternion(g);
      }
      d.setPosition(this.body.position.x, this.body.position.y, this.body.position.z);
      g = new THREE.Matrix4;
      g.getInverse(this.parent.matrixWorld);
      var h = new THREE.Vector3;
      g.multiply(d);
      g.decompose(this.position, this.quaternion, h);
    }
  }
  THREE.Object3D.prototype.update.call(this, a);
};
PhysicsObject.prototype.addShape = function(a) {
  a instanceof CANNON.Shape && this.body.addShape(a);
};
PhysicsObject.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.mode = this.mode;
  a.object.body = {};
  a.object.body.type = this.body.type;
  a.object.body.mass = this.body.mass;
  a.object.body.linearDamping = this.body.linearDamping;
  a.object.body.angularDamping = this.body.angularDamping;
  a.object.body.allowSleep = this.body.allowSleep;
  a.object.body.sleepSpeedLimit = this.body.sleepSpeedLimit;
  a.object.body.sleepTimeLimit = this.body.sleepTimeLimit;
  a.object.body.collisionFilterGroup = this.body.collisionFilterGroup;
  a.object.body.collisionFilterMask = this.body.collisionFilterMask;
  a.object.body.fixedRotation = this.body.fixedRotation;
  a.object.body.shapes = [];
  for (var d = this.body.shapes, g = 0; g < d.length; g++) {
    var h = d[g], e = {};
    e.type = h.type;
    h.type === CANNON.Shape.types.SPHERE ? e.radius = h.radius : h.type === CANNON.Shape.types.BOX ? (e.halfExtents = {}, e.halfExtents.x = h.halfExtents.x, e.halfExtents.y = h.halfExtents.y, e.halfExtents.z = h.halfExtents.z) : h.type === CANNON.Shape.types.CONVEXPOLYHEDRON ? (e.vertices = h.vertices, e.faces = h.faces) : h.type === CANNON.Shape.types.TRIMESH && (e.vertices = h.vertices, e.normals = h.normals, e.edges = h.edges, e.indices = h.indices);
    a.object.body.shapes[g] = e;
  }
  return a;
};
PhysicsObject.fromJSON = function(a) {
  var d = new PhysicsObject;
  void 0 !== a.mode && (d.mode = a.mode);
  d.body.type = a.body.type;
  d.body.mass = a.body.mass;
  d.body.linearDamping = a.body.linearDamping;
  d.body.angularDamping = a.body.angularDamping;
  d.body.allowSleep = a.body.allowSleep;
  d.body.sleepSpeedLimit = a.body.sleepSpeedLimit;
  d.body.sleepTimeLimit = a.body.sleepTimeLimit;
  d.body.collisionFilterGroup = a.body.collisionFilterGroup;
  d.body.collisionFilterMask = a.body.collisionFilterMask;
  d.body.fixedRotation = a.body.fixedRotation;
  a = a.body.shapes;
  for (var g = 0; g < a.length; g++) {
    var h = a[g];
    if (h.type === CANNON.Shape.types.SPHERE) {
      d.body.addShape(new CANNON.Sphere(h.radius));
    } else {
      if (h.type === CANNON.Shape.types.BOX) {
        d.body.addShape(new CANNON.Box(new CANNON.Vec3(h.halfExtents.x, h.halfExtents.y, h.halfExtents.z)));
      } else {
        if (h.type === CANNON.Shape.types.PARTICLE) {
          d.body.addShape(new CANNON.Particle);
        } else {
          if (h.type === CANNON.Shape.types.PLANE) {
            d.body.addShape(new CANNON.Plane);
          } else {
            if (h.type === CANNON.Shape.types.CONVEXPOLYHEDRON) {
              for (var e = 0; e < h.vertices.length; e++) {
                h.vertices[e] = new CANNON.Vec3(h.vertices[e].x, h.vertices[e].y, h.vertices[e].z);
              }
              d.body.addShape(new CANNON.ConvexPolyhedron(h.vertices, h.faces));
            }
          }
        }
      }
    }
  }
  return d;
};
"use strict";
function SpineAnimation(a, d, g, h) {
  void 0 === h && (h = []);
  var e = new spine.TextureAtlas(d, function(a) {
    for (var c = 0; c < h.length; c++) {
      if (h[c].name === a) {
        var e = new SpineTexture(h[c].texture);
        break;
      }
    }
    c === h.length && (e = new SpineTexture(new Texture(new Image(g + "/" + a))), h.push({name:a, texture:e.texture}));
    a = e.texture.image;
    c = e.texture.source;
    if (0 < c.width && 0 < c.height) {
      a.width = c.width, a.height = c.height;
    } else {
      if (0 !== a.naturalWidth && 0 !== a.naturalHeight) {
        a.width = a.naturalWidth, a.height = a.naturalHeight, c.width = a.width, c.height = a.height;
      } else {
        c = d.search("size: ");
        var k = d.search("\nformat");
        c = d.substring(c + 6, k);
        c = c.split(",");
        a.width = parseInt(c[0]);
        a.height = parseInt(c[1]);
      }
    }
    return e;
  });
  e = new spine.AtlasAttachmentLoader(e);
  e = (new spine.SkeletonJson(e)).readSkeletonData(a);
  spine.threejs.SkeletonMesh.call(this, e);
  this.name = "spine";
  this.type = "SpineAnimation";
  this.scale.set(.01, .01, .01);
  this.json = a;
  this.atlas = d;
  this.textures = h;
  this.skin = 0 < this.getSkins().length ? this.getSkins()[0].name : null;
  this.animation = 0 < this.getAnimations().length ? this.getAnimations()[0].name : null;
  this.track = 0;
  this.loop = !0;
  this.clock = new THREE.Clock;
  this.play();
}
SpineAnimation.prototype = Object.create(spine.threejs.SkeletonMesh.prototype);
SpineAnimation.prototype.update = function(a) {
  spine.threejs.SkeletonMesh.prototype.update.call(this, a);
  THREE.Object3D.prototype.update.call(this);
};
SpineAnimation.prototype.onBeforeRender = function() {
  this.state.update(this.clock.getDelta());
  this.state.apply(this.skeleton);
  this.skeleton.updateWorldTransform();
  this.updateGeometry();
};
SpineAnimation.prototype.play = function() {
  null !== this.animation && this.setAnimation(this.track, this.animation, this.loop);
  null !== this.skin && this.setSkin(this.skin);
};
SpineAnimation.prototype.getAnimations = function() {
  return this.state.data.skeletonData.animations;
};
SpineAnimation.prototype.setAnimation = function(a, d, g) {
  try {
    void 0 !== a && (this.track = a), void 0 !== d && (this.animation = d), void 0 !== g && (this.loop = g), this.state.setAnimation(this.track, this.animation, this.loop);
  } catch (h) {
    this.animation = null, console.warn("nunuStudio: Error setting spine animation " + name + " on track " + a);
  }
};
SpineAnimation.prototype.getSkins = function() {
  return this.state.data.skeletonData.skins;
};
SpineAnimation.prototype.setSkin = function(a) {
  try {
    this.skeleton.setSkinByName(a), this.skin = a;
  } catch (d) {
    this.skin = null, console.warn("nunuStudio: Error setting spine skin " + a);
  }
};
SpineAnimation.prototype.toJSON = function(a) {
  var d = [], g = this;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, e) {
    for (e = 0; e < g.textures.length; e++) {
      var h = g.textures[e].texture.toJSON(a);
      d.push({name:g.textures[e].name, texture:h.uuid});
    }
  });
  a.object.json = this.json;
  a.object.atlas = this.atlas;
  a.object.textures = d;
  null !== this.animation && (a.object.animation = this.animation, a.object.track = this.track, a.object.loop = this.loop);
  null !== this.skin && (a.object.skin = this.skin);
  return a;
};
"use strict";
function SpineTexture(a) {
  spine.threejs.ThreeJsTexture.call(this, a.image);
  this.texture = a;
  this.texture.flipY = !1;
}
SpineTexture.prototype = Object.create(spine.threejs.ThreeJsTexture.prototype);
"use strict";
function ParticleEmitterControl(a) {
  a = ShaderUtils.ensureTypedArg(a, ShaderUtils.types.OBJECT, {});
  a.position = ShaderUtils.ensureTypedArg(a.position, ShaderUtils.types.OBJECT, {});
  a.velocity = ShaderUtils.ensureTypedArg(a.velocity, ShaderUtils.types.OBJECT, {});
  a.acceleration = ShaderUtils.ensureTypedArg(a.acceleration, ShaderUtils.types.OBJECT, {});
  a.radius = ShaderUtils.ensureTypedArg(a.radius, ShaderUtils.types.OBJECT, {});
  a.drag = ShaderUtils.ensureTypedArg(a.drag, ShaderUtils.types.OBJECT, {});
  a.rotation = ShaderUtils.ensureTypedArg(a.rotation, ShaderUtils.types.OBJECT, {});
  a.color = ShaderUtils.ensureTypedArg(a.color, ShaderUtils.types.OBJECT, {});
  a.opacity = ShaderUtils.ensureTypedArg(a.opacity, ShaderUtils.types.OBJECT, {});
  a.size = ShaderUtils.ensureTypedArg(a.size, ShaderUtils.types.OBJECT, {});
  a.angle = ShaderUtils.ensureTypedArg(a.angle, ShaderUtils.types.OBJECT, {});
  a.wiggle = ShaderUtils.ensureTypedArg(a.wiggle, ShaderUtils.types.OBJECT, {});
  a.maxAge = ShaderUtils.ensureTypedArg(a.maxAge, ShaderUtils.types.OBJECT, {});
  a.onParticleSpawn && console.warn("nunuStudio: onParticleSpawn has been removed. Please set properties directly to alter values at runtime.");
  this.uuid = THREE.Math.generateUUID();
  this.type = ShaderUtils.ensureTypedArg(a.type, ShaderUtils.types.NUMBER, ParticleDistributions.BOX);
  this.position = {_value:ShaderUtils.ensureInstanceOf(a.position.value, THREE.Vector3, new THREE.Vector3), _spread:ShaderUtils.ensureInstanceOf(a.position.spread, THREE.Vector3, new THREE.Vector3), _spreadClamp:ShaderUtils.ensureInstanceOf(a.position.spreadClamp, THREE.Vector3, new THREE.Vector3), _distribution:ShaderUtils.ensureTypedArg(a.position.distribution, ShaderUtils.types.NUMBER, this.type), _randomise:ShaderUtils.ensureTypedArg(a.position.randomise, ShaderUtils.types.BOOLEAN, !1), _radius:ShaderUtils.ensureTypedArg(a.position.radius, 
  ShaderUtils.types.NUMBER, 10), _radiusScale:ShaderUtils.ensureInstanceOf(a.position.radiusScale, THREE.Vector3, new THREE.Vector3(1, 1, 1)), _distributionClamp:ShaderUtils.ensureTypedArg(a.position.distributionClamp, ShaderUtils.types.NUMBER, 0)};
  this.velocity = {_value:ShaderUtils.ensureInstanceOf(a.velocity.value, THREE.Vector3, new THREE.Vector3), _spread:ShaderUtils.ensureInstanceOf(a.velocity.spread, THREE.Vector3, new THREE.Vector3), _distribution:ShaderUtils.ensureTypedArg(a.velocity.distribution, ShaderUtils.types.NUMBER, this.type), _randomise:ShaderUtils.ensureTypedArg(a.position.randomise, ShaderUtils.types.BOOLEAN, !1)};
  this.acceleration = {_value:ShaderUtils.ensureInstanceOf(a.acceleration.value, THREE.Vector3, new THREE.Vector3), _spread:ShaderUtils.ensureInstanceOf(a.acceleration.spread, THREE.Vector3, new THREE.Vector3), _distribution:ShaderUtils.ensureTypedArg(a.acceleration.distribution, ShaderUtils.types.NUMBER, this.type), _randomise:ShaderUtils.ensureTypedArg(a.position.randomise, ShaderUtils.types.BOOLEAN, !1)};
  this.drag = {_value:ShaderUtils.ensureTypedArg(a.drag.value, ShaderUtils.types.NUMBER, 0), _spread:ShaderUtils.ensureTypedArg(a.drag.spread, ShaderUtils.types.NUMBER, 0), _randomise:ShaderUtils.ensureTypedArg(a.position.randomise, ShaderUtils.types.BOOLEAN, !1)};
  this.wiggle = {_value:ShaderUtils.ensureTypedArg(a.wiggle.value, ShaderUtils.types.NUMBER, 0), _spread:ShaderUtils.ensureTypedArg(a.wiggle.spread, ShaderUtils.types.NUMBER, 0)};
  this.rotation = {_axis:ShaderUtils.ensureInstanceOf(a.rotation.axis, THREE.Vector3, new THREE.Vector3(0, 1, 0)), _axisSpread:ShaderUtils.ensureInstanceOf(a.rotation.axisSpread, THREE.Vector3, new THREE.Vector3), _angle:ShaderUtils.ensureTypedArg(a.rotation.angle, ShaderUtils.types.NUMBER, 0), _angleSpread:ShaderUtils.ensureTypedArg(a.rotation.angleSpread, ShaderUtils.types.NUMBER, 0), _static:ShaderUtils.ensureTypedArg(a.rotation.static, ShaderUtils.types.BOOLEAN, !1), _center:ShaderUtils.ensureInstanceOf(a.rotation.center, 
  THREE.Vector3, this.position._value.clone()), _randomise:ShaderUtils.ensureTypedArg(a.position.randomise, ShaderUtils.types.BOOLEAN, !1)};
  this.maxAge = {_value:ShaderUtils.ensureTypedArg(a.maxAge.value, ShaderUtils.types.NUMBER, 2), _spread:ShaderUtils.ensureTypedArg(a.maxAge.spread, ShaderUtils.types.NUMBER, 0)};
  this.color = {_value:ShaderUtils.ensureArrayInstanceOf(a.color.value, THREE.Color, new THREE.Color), _spread:ShaderUtils.ensureArrayInstanceOf(a.color.spread, THREE.Vector3, new THREE.Vector3), _randomise:ShaderUtils.ensureTypedArg(a.position.randomise, ShaderUtils.types.BOOLEAN, !1)};
  this.opacity = {_value:ShaderUtils.ensureArrayTypedArg(a.opacity.value, ShaderUtils.types.NUMBER, 1), _spread:ShaderUtils.ensureArrayTypedArg(a.opacity.spread, ShaderUtils.types.NUMBER, 0), _randomise:ShaderUtils.ensureTypedArg(a.position.randomise, ShaderUtils.types.BOOLEAN, !1)};
  this.size = {_value:ShaderUtils.ensureArrayTypedArg(a.size.value, ShaderUtils.types.NUMBER, 1), _spread:ShaderUtils.ensureArrayTypedArg(a.size.spread, ShaderUtils.types.NUMBER, 0), _randomise:ShaderUtils.ensureTypedArg(a.position.randomise, ShaderUtils.types.BOOLEAN, !1)};
  this.angle = {_value:ShaderUtils.ensureArrayTypedArg(a.angle.value, ShaderUtils.types.NUMBER, 0), _spread:ShaderUtils.ensureArrayTypedArg(a.angle.spread, ShaderUtils.types.NUMBER, 0), _randomise:ShaderUtils.ensureTypedArg(a.position.randomise, ShaderUtils.types.BOOLEAN, !1)};
  this.particleCount = ShaderUtils.ensureTypedArg(a.particleCount, ShaderUtils.types.NUMBER, 100);
  this.duration = ShaderUtils.ensureTypedArg(a.duration, ShaderUtils.types.NUMBER, null);
  this.isStatic = ShaderUtils.ensureTypedArg(a.isStatic, ShaderUtils.types.BOOLEAN, !1);
  this.activeMultiplier = ShaderUtils.ensureTypedArg(a.activeMultiplier, ShaderUtils.types.NUMBER, 1);
  this.direction = ShaderUtils.ensureTypedArg(a.direction, ShaderUtils.types.NUMBER, 1);
  this.alive = ShaderUtils.ensureTypedArg(a.alive, ShaderUtils.types.BOOLEAN, !0);
  this.activeParticleCount = this.age = this.attributeEnd = this.attributeOffset = this.activationIndex = this.particlesPerSecond = 0;
  this.paramsArray = this.attributes = this.group = null;
  this.resetFlags = {position:ShaderUtils.ensureTypedArg(a.position.randomise, ShaderUtils.types.BOOLEAN, !1) || ShaderUtils.ensureTypedArg(a.radius.randomise, ShaderUtils.types.BOOLEAN, !1), velocity:ShaderUtils.ensureTypedArg(a.velocity.randomise, ShaderUtils.types.BOOLEAN, !1), acceleration:ShaderUtils.ensureTypedArg(a.acceleration.randomise, ShaderUtils.types.BOOLEAN, !1) || ShaderUtils.ensureTypedArg(a.drag.randomise, ShaderUtils.types.BOOLEAN, !1), rotation:ShaderUtils.ensureTypedArg(a.rotation.randomise, 
  ShaderUtils.types.BOOLEAN, !1), rotationCenter:ShaderUtils.ensureTypedArg(a.rotation.randomise, ShaderUtils.types.BOOLEAN, !1), size:ShaderUtils.ensureTypedArg(a.size.randomise, ShaderUtils.types.BOOLEAN, !1), color:ShaderUtils.ensureTypedArg(a.color.randomise, ShaderUtils.types.BOOLEAN, !1), opacity:ShaderUtils.ensureTypedArg(a.opacity.randomise, ShaderUtils.types.BOOLEAN, !1), angle:ShaderUtils.ensureTypedArg(a.angle.randomise, ShaderUtils.types.BOOLEAN, !1)};
  this.updateFlags = {};
  this.updateCounts = {};
  this.updateMap = {maxAge:"params", position:"position", velocity:"velocity", acceleration:"acceleration", drag:"acceleration", wiggle:"params", rotation:"rotation", size:"size", color:"color", opacity:"opacity", angle:"angle"};
  for (var d in this.updateMap) {
    this.updateMap.hasOwnProperty(d) && (this.updateCounts[this.updateMap[d]] = 0, this.updateFlags[this.updateMap[d]] = !1, this._createGetterSetters(this[d], d));
  }
  this.bufferUpdateRanges = {};
  this.attributeKeys = null;
  this.attributeCount = 0;
  ShaderUtils.ensureValueOverLifetimeCompliance(this.color, ParticleEmitter.valueOverLifetimeLength, ParticleEmitter.valueOverLifetimeLength);
  ShaderUtils.ensureValueOverLifetimeCompliance(this.opacity, ParticleEmitter.valueOverLifetimeLength, ParticleEmitter.valueOverLifetimeLength);
  ShaderUtils.ensureValueOverLifetimeCompliance(this.size, ParticleEmitter.valueOverLifetimeLength, ParticleEmitter.valueOverLifetimeLength);
  ShaderUtils.ensureValueOverLifetimeCompliance(this.angle, ParticleEmitter.valueOverLifetimeLength, ParticleEmitter.valueOverLifetimeLength);
}
ParticleEmitterControl.constructor = ParticleEmitterControl;
ParticleEmitterControl.prototype._createGetterSetters = function(a, d) {
  var g = this, h;
  for (h in a) {
    if (a.hasOwnProperty(h)) {
      var e = h.replace("_", "");
      Object.defineProperty(a, e, {get:function(a) {
        return function() {
          return this[a];
        };
      }(h), set:function(a) {
        return function(c) {
          var e = g.updateMap[d], h = this[a], f = ParticleEmitter.valueOverLifetimeLength;
          "_rotationCenter" === a ? (g.updateFlags.rotationCenter = !0, g.updateCounts.rotationCenter = 0) : "_randomise" === a ? g.resetFlags[e] = c : (g.updateFlags[e] = !0, g.updateCounts[e] = 0);
          g.group._updateDefines();
          this[a] = c;
          Array.isArray(h) && ShaderUtils.ensureValueOverLifetimeCompliance(g[d], f, f);
        };
      }(h)});
    }
  }
};
ParticleEmitterControl.prototype._setBufferUpdateRanges = function(a) {
  this.attributeKeys = a;
  this.attributeCount = a.length;
  for (var d = this.attributeCount - 1; 0 <= d; --d) {
    this.bufferUpdateRanges[a[d]] = {min:Number.POSITIVE_INFINITY, max:Number.NEGATIVE_INFINITY};
  }
};
ParticleEmitterControl.prototype._calculatePPSValue = function(a) {
  var d = this.particleCount;
  this.particlesPerSecond = this.duration ? d / (a < this.duration ? a : this.duration) : d / a;
};
ParticleEmitterControl.prototype._setAttributeOffset = function(a) {
  this.activationIndex = this.attributeOffset = a;
  this.activationEnd = a + this.particleCount;
};
ParticleEmitterControl.prototype._assignValue = function(a, d) {
  switch(a) {
    case "position":
      this._assignPositionValue(d);
      break;
    case "velocity":
    case "acceleration":
      this._assignForceValue(d, a);
      break;
    case "size":
    case "opacity":
      this._assignAbsLifetimeValue(d, a);
      break;
    case "angle":
      this._assignAngleValue(d);
      break;
    case "params":
      this._assignParamsValue(d);
      break;
    case "rotation":
      this._assignRotationValue(d);
      break;
    case "color":
      this._assignColorValue(d);
  }
};
ParticleEmitterControl.prototype._assignPositionValue = function(a) {
  var d = this.position, g = this.attributes.position, h = d._value, e = d._spread;
  switch(d._distribution) {
    case ParticleDistributions.BOX:
      ShaderUtils.randomVector3(g, a, h, e, d._spreadClamp);
      break;
    case ParticleDistributions.SPHERE:
      ShaderUtils.randomVector3OnSphere(g, a, h, d._radius, d._spread.x, d._radiusScale, d._spreadClamp.x, d._distributionClamp || this.particleCount);
      break;
    case ParticleDistributions.DISC:
      ShaderUtils.randomVector3OnDisc(g, a, h, d._radius, d._spread.x, d._radiusScale, d._spreadClamp.x);
  }
};
ParticleEmitterControl.prototype._assignForceValue = function(a, d) {
  var g = this[d], h = g._value, e = g._spread;
  switch(g._distribution) {
    case ParticleDistributions.BOX:
      ShaderUtils.randomVector3(this.attributes[d], a, h, e);
      break;
    case ParticleDistributions.SPHERE:
      var k = this.attributes.position.typedArray.array;
      var c = 3 * a;
      h = k[c];
      e = k[c + 1];
      k = k[c + 2];
      ShaderUtils.randomDirectionVector3OnSphere(this.attributes[d], a, h, e, k, this.position._value, g._value.x, g._spread.x);
      break;
    case ParticleDistributions.DISC:
      k = this.attributes.position.typedArray.array, c = 3 * a, h = k[c], e = k[c + 1], k = k[c + 2], ShaderUtils.randomDirectionVector3OnDisc(this.attributes[d], a, h, e, k, this.position._value, g._value.x, g._spread.x);
  }
  "acceleration" === d && (d = ShaderUtils.clamp(ShaderUtils.randomFloat(this.drag._value, this.drag._spread), 0, 1), this.attributes.acceleration.typedArray.array[4 * a + 3] = d);
};
ParticleEmitterControl.prototype._assignAbsLifetimeValue = function(a, d) {
  var g = this.attributes[d].typedArray;
  d = this[d];
  ShaderUtils.arrayValuesAreEqual(d._value) && ShaderUtils.arrayValuesAreEqual(d._spread) ? (d = Math.abs(ShaderUtils.randomFloat(d._value[0], d._spread[0])), g.setVec4Components(a, d, d, d, d)) : g.setVec4Components(a, Math.abs(ShaderUtils.randomFloat(d._value[0], d._spread[0])), Math.abs(ShaderUtils.randomFloat(d._value[1], d._spread[1])), Math.abs(ShaderUtils.randomFloat(d._value[2], d._spread[2])), Math.abs(ShaderUtils.randomFloat(d._value[3], d._spread[3])));
};
ParticleEmitterControl.prototype._assignAngleValue = function(a) {
  var d = this.attributes.angle.typedArray, g = this.angle;
  ShaderUtils.arrayValuesAreEqual(g._value) && ShaderUtils.arrayValuesAreEqual(g._spread) ? (g = ShaderUtils.randomFloat(g._value[0], g._spread[0]), d.setVec4Components(a, g, g, g, g)) : d.setVec4Components(a, ShaderUtils.randomFloat(g._value[0], g._spread[0]), ShaderUtils.randomFloat(g._value[1], g._spread[1]), ShaderUtils.randomFloat(g._value[2], g._spread[2]), ShaderUtils.randomFloat(g._value[3], g._spread[3]));
};
ParticleEmitterControl.prototype._assignParamsValue = function(a) {
  this.attributes.params.typedArray.setVec4Components(a, this.isStatic ? 1 : 0, 0, Math.abs(ShaderUtils.randomFloat(this.maxAge._value, this.maxAge._spread)), ShaderUtils.randomFloat(this.wiggle._value, this.wiggle._spread));
};
ParticleEmitterControl.prototype._assignRotationValue = function(a) {
  this.attributes.rotation.typedArray.setVec3Components(a, ShaderUtils.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread), ShaderUtils.randomFloat(this.rotation._angle, this.rotation._angleSpread), this.rotation._static ? 0 : 1);
  this.attributes.rotationCenter.typedArray.setVec3(a, this.rotation._center);
};
ParticleEmitterControl.prototype._assignColorValue = function(a) {
  ShaderUtils.randomColorAsHex(this.attributes.color, a, this.color._value, this.color._spread);
};
ParticleEmitterControl.prototype._resetParticle = function(a) {
  for (var d = this.resetFlags, g = this.updateFlags, h = this.updateCounts, e = this.attributeKeys, k, c, p = this.attributeCount - 1; 0 <= p; --p) {
    if (k = e[p], c = g[k], !0 === d[k] || !0 === c) {
      this._assignValue(k, a), this._updateAttributeUpdateRange(k, a), !0 === c && h[k] === this.particleCount ? (g[k] = !1, h[k] = 0) : 1 == c && ++h[k];
    }
  }
};
ParticleEmitterControl.prototype._updateAttributeUpdateRange = function(a, d) {
  a = this.bufferUpdateRanges[a];
  a.min = Math.min(d, a.min);
  a.max = Math.max(d, a.max);
};
ParticleEmitterControl.prototype._resetBufferRanges = function() {
  for (var a = this.bufferUpdateRanges, d = this.bufferUpdateKeys, g = this.bufferUpdateCount - 1; 0 <= g; --g) {
    var h = d[g];
    a[h].min = Number.POSITIVE_INFINITY;
    a[h].max = Number.NEGATIVE_INFINITY;
  }
};
ParticleEmitterControl.prototype._onRemove = function() {
  this.activeParticleCount = this.activationIndex = this.attributeOffset = this.particlesPerSecond = 0;
  this.paramsArray = this.attributes = this.group = null;
  this.age = 0;
};
ParticleEmitterControl.prototype._decrementParticleCount = function() {
  --this.activeParticleCount;
};
ParticleEmitterControl.prototype._incrementParticleCount = function() {
  ++this.activeParticleCount;
};
ParticleEmitterControl.prototype._checkParticleAges = function(a, d, g, h) {
  --d;
  for (var e, k, c, p; d >= a; --d) {
    e = 4 * d, p = g[e], 0 !== p && (c = g[e + 1], k = g[e + 2], 1 === this.direction ? (c += h, c >= k && (p = c = 0, this._decrementParticleCount())) : (c -= h, 0 >= c && (c = k, p = 0, this._decrementParticleCount())), g[e] = p, g[e + 1] = c, this._updateAttributeUpdateRange("params", d));
  }
};
ParticleEmitterControl.prototype._activateParticles = function(a, d, g, h) {
  for (var e = this.direction, k = a, c, p; k < d; ++k) {
    if (c = 4 * k, 0 == g[c] || 1 === this.particleCount) {
      this._incrementParticleCount(), g[c] = 1, this._resetParticle(k), p = h * (k - a), g[c + 1] = -1 === e ? g[c + 2] - p : p, this._updateAttributeUpdateRange("params", k);
    }
  }
};
ParticleEmitterControl.prototype.tick = function(a) {
  if (!this.isStatic) {
    null === this.paramsArray && (this.paramsArray = this.attributes.params.typedArray.array);
    var d = this.attributeOffset, g = d + this.particleCount, h = this.paramsArray, e = this.particlesPerSecond * this.activeMultiplier * a, k = this.activationIndex;
    this._resetBufferRanges();
    this._checkParticleAges(d, g, h, a);
    if (!1 === this.alive) {
      this.age = 0;
    } else {
      if (null !== this.duration && this.age > this.duration) {
        this.alive = !1, this.age = 0;
      } else {
        k = 1 === this.particleCount ? k : k | 0;
        var c = Math.min(k + e, this.activationEnd), p = c - this.activationIndex | 0;
        this._activateParticles(k, c, h, 0 < p ? a / p : 0);
        this.activationIndex += e;
        this.activationIndex > g && (this.activationIndex = d);
        this.age += a;
      }
    }
  }
};
ParticleEmitterControl.prototype.reset = function(a) {
  this.age = 0;
  this.alive = !1;
  if (!0 === a) {
    a = this.attributeOffset;
    for (var d = this.paramsArray, g = this.attributes.params.bufferAttribute, h = a + this.particleCount - 1, e; h >= a; --h) {
      e = 4 * h, d[e] = 0, d[e + 1] = 0;
    }
    g.updateRange.offset = 0;
    g.updateRange.count = -1;
    g.needsUpdate = !0;
  }
  return this;
};
ParticleEmitterControl.prototype.enable = function() {
  this.alive = !0;
  return this;
};
ParticleEmitterControl.prototype.disable = function() {
  this.alive = !1;
  return this;
};
ParticleEmitterControl.prototype.remove = function() {
  null !== this.group ? this.group.removeEmitter(this) : console.error("nunuStudio: ParticleEmitterControl does not belong to a group, cannot remove.");
  return this;
};
ParticleEmitterControl.prototype.toJSON = function(a) {
  a = {};
  a.uuid = this.uuid;
  a.type = this.type;
  a.direction = this.direction;
  a.particleCount = this.particleCount;
  a.duration = this.duration;
  a.isStatic = this.isStatic;
  a.maxAge = {};
  a.maxAge.value = this.maxAge.value;
  a.maxAge.spread = this.maxAge.spread;
  a.position = {};
  a.position.value = this.position.value.toArray();
  a.position.spread = this.position.spread.toArray();
  a.position.radius = this.position.radius;
  a.position.radiusScale = this.position.radiusScale.toArray();
  a.velocity = {};
  a.velocity.value = this.velocity.value.toArray();
  a.velocity.spread = this.velocity.spread.toArray();
  a.acceleration = {};
  a.acceleration.value = this.acceleration.value.toArray();
  a.acceleration.spread = this.acceleration.spread.toArray();
  a.wiggle = {};
  a.wiggle.value = this.wiggle.value;
  a.wiggle.spread = this.wiggle.spread;
  a.opacity = {};
  a.opacity.value = this.opacity.value.slice(0);
  a.opacity.spread = this.opacity.spread;
  a.size = {};
  a.size.value = this.size.value.slice(0);
  a.size.spread = this.size.spread;
  a.angle = {};
  a.angle.value = this.angle.value.slice(0);
  a.angle.spread = this.angle.spread;
  a.color = {};
  a.color.value = [];
  for (var d = 0; d < this.color.value.length; d++) {
    a.color.value.push(this.color.value[d].getHex());
  }
  a.color.spread = [];
  for (d = 0; d < this.color.spread.length; d++) {
    a.color.spread.push(this.color.spread[d].toArray());
  }
  return a;
};
"use strict";
function ParticleGroup(a) {
  a = ShaderUtils.ensureTypedArg(a, ShaderUtils.types.OBJECT, {});
  a.texture = ShaderUtils.ensureTypedArg(a.texture, ShaderUtils.types.OBJECT, {});
  this.uuid = THREE.Math.generateUUID();
  this.fixedTimeStep = ShaderUtils.ensureTypedArg(a.fixedTimeStep, ShaderUtils.types.NUMBER, .016);
  this.texture = ShaderUtils.ensureInstanceOf(a.texture.value, THREE.Texture, null);
  this.textureFrames = ShaderUtils.ensureInstanceOf(a.texture.frames, THREE.Vector2, new THREE.Vector2(1, 1));
  this.textureFrameCount = ShaderUtils.ensureTypedArg(a.texture.frameCount, ShaderUtils.types.NUMBER, this.textureFrames.x * this.textureFrames.y);
  this.textureLoop = ShaderUtils.ensureTypedArg(a.texture.loop, ShaderUtils.types.NUMBER, 1);
  this.textureFrames.max(new THREE.Vector2(1, 1));
  this.hasPerspective = ShaderUtils.ensureTypedArg(a.hasPerspective, ShaderUtils.types.BOOLEAN, !0);
  this.colorize = ShaderUtils.ensureTypedArg(a.colorize, ShaderUtils.types.BOOLEAN, !0);
  this.maxParticleCount = ShaderUtils.ensureTypedArg(a.maxParticleCount, ShaderUtils.types.NUMBER, null);
  this.blending = ShaderUtils.ensureTypedArg(a.blending, ShaderUtils.types.NUMBER, THREE.AdditiveBlending);
  this.transparent = ShaderUtils.ensureTypedArg(a.transparent, ShaderUtils.types.BOOLEAN, !0);
  this.alphaTest = parseFloat(ShaderUtils.ensureTypedArg(a.alphaTest, ShaderUtils.types.NUMBER, 0));
  this.depthWrite = ShaderUtils.ensureTypedArg(a.depthWrite, ShaderUtils.types.BOOLEAN, !1);
  this.depthTest = ShaderUtils.ensureTypedArg(a.depthTest, ShaderUtils.types.BOOLEAN, !0);
  this.fog = ShaderUtils.ensureTypedArg(a.fog, ShaderUtils.types.BOOLEAN, !0);
  this.scale = ShaderUtils.ensureTypedArg(a.scale, ShaderUtils.types.NUMBER, 300);
  this.emitters = [];
  this.emitterIDs = [];
  this.pool = [];
  this.poolCreationSettings = null;
  this._createNewWhenPoolEmpty = 0;
  this._attributesNeedDynamicReset = this._attributesNeedRefresh = !1;
  this.particleCount = 0;
  this.uniforms = {textureSampler:{type:"t", value:this.texture}, textureAnimation:{type:"v4", value:new THREE.Vector4(this.textureFrames.x, this.textureFrames.y, this.textureFrameCount, Math.max(Math.abs(this.textureLoop), 1))}, fogColor:{type:"c", value:null}, fogNear:{type:"f", value:10}, fogFar:{type:"f", value:200}, fogDensity:{type:"f", value:.5}, deltaTime:{type:"f", value:0}, runTime:{type:"f", value:0}, scale:{type:"f", value:this.scale}};
  this.defines = {HAS_PERSPECTIVE:this.hasPerspective, COLORIZE:this.colorize, VALUE_OVER_LIFETIME_LENGTH:ParticleEmitter.valueOverLifetimeLength, SHOULD_ROTATE_TEXTURE:!1, SHOULD_ROTATE_PARTICLES:!1, SHOULD_WIGGLE_PARTICLES:!1, SHOULD_CALCULATE_SPRITE:1 < this.textureFrames.x || 1 < this.textureFrames.y};
  this.attributes = {position:new ShaderAttribute("v3", !0), acceleration:new ShaderAttribute("v4", !0), velocity:new ShaderAttribute("v3", !0), rotation:new ShaderAttribute("v4", !0), rotationCenter:new ShaderAttribute("v3", !0), params:new ShaderAttribute("v4", !0), size:new ShaderAttribute("v4", !0), angle:new ShaderAttribute("v4", !0), color:new ShaderAttribute("v4", !0), opacity:new ShaderAttribute("v4", !0)};
  this.attributeKeys = Object.keys(this.attributes);
  this.attributeCount = this.attributeKeys.length;
  this.material = new THREE.ShaderMaterial({uniforms:this.uniforms, vertexShader:ParticleShaders.vertex, fragmentShader:ParticleShaders.fragment, blending:this.blending, transparent:this.transparent, alphaTest:this.alphaTest, depthWrite:this.depthWrite, depthTest:this.depthTest, defines:this.defines, fog:this.fog});
  this.geometry = new THREE.BufferGeometry;
  this.mesh = new THREE.Points(this.geometry, this.material);
  null === this.maxParticleCount && console.warn("nunuStudio: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.");
}
ParticleGroup.constructor = ParticleGroup;
ParticleGroup.prototype._updateDefines = function() {
  for (var a = this.emitters, d, g = this.defines, h = a.length - 1; 0 <= h; --h) {
    d = a[h], g.SHOULD_CALCULATE_SPRITE || (g.SHOULD_ROTATE_TEXTURE = g.SHOULD_ROTATE_TEXTURE || !!Math.max(Math.max.apply(null, d.angle.value), Math.max.apply(null, d.angle.spread))), g.SHOULD_ROTATE_PARTICLES = g.SHOULD_ROTATE_PARTICLES || !!Math.max(d.rotation.angle, d.rotation.angleSpread), g.SHOULD_WIGGLE_PARTICLES = g.SHOULD_WIGGLE_PARTICLES || !!Math.max(d.wiggle.value, d.wiggle.spread);
  }
  this.material.needsUpdate = !0;
};
ParticleGroup.prototype._applyAttributesToGeometry = function() {
  var a = this.attributes, d = this.geometry, g = d.attributes, h, e;
  for (e in a) {
    if (a.hasOwnProperty(e)) {
      var k = a[e];
      (h = g[e]) ? h.array = k.typedArray.array : d.setAttribute(e, k.bufferAttribute);
      k.bufferAttribute.needsUpdate = !0;
    }
  }
  this.geometry.setDrawRange(0, this.particleCount);
};
ParticleGroup.prototype.addEmitter = function(a) {
  if (!1 === a instanceof ParticleEmitterControl) {
    console.error("nunuStudio: emitter argument must be instance of ParticleEmitterControl.", a);
  } else {
    if (-1 < this.emitterIDs.indexOf(a.uuid)) {
      console.error("nunuStudio: ParticleEmitterControl already exists in this group.");
    } else {
      if (null !== a.group) {
        console.error("nunuStudio: ParticleEmitterControl already belongs to another group.");
      } else {
        var d = this.attributes, g = this.particleCount, h = g + a.particleCount;
        this.particleCount = h;
        null !== this.maxParticleCount && this.particleCount > this.maxParticleCount && console.warn("nunuStudio: ParticleGroup maxParticleCount exceeded. Requesting", this.particleCount, "particles, can support only", this.maxParticleCount);
        a._calculatePPSValue(a.maxAge._value + a.maxAge._spread);
        a._setBufferUpdateRanges(this.attributeKeys);
        a._setAttributeOffset(g);
        a.group = this;
        a.attributes = this.attributes;
        for (var e in d) {
          d.hasOwnProperty(e) && d[e]._createBufferAttribute(null !== this.maxParticleCount ? this.maxParticleCount : this.particleCount);
        }
        for (d = g; d < h; ++d) {
          a._assignPositionValue(d), a._assignForceValue(d, "velocity"), a._assignForceValue(d, "acceleration"), a._assignAbsLifetimeValue(d, "opacity"), a._assignAbsLifetimeValue(d, "size"), a._assignAngleValue(d), a._assignRotationValue(d), a._assignParamsValue(d), a._assignColorValue(d);
        }
        this._applyAttributesToGeometry();
        this.emitters.push(a);
        this.emitterIDs.push(a.uuid);
        this._updateDefines(a);
        this.material.needsUpdate = !0;
        this._attributesNeedRefresh = this.geometry.needsUpdate = !0;
        return this;
      }
    }
  }
};
ParticleGroup.prototype.removeEmitter = function(a) {
  var d = this.emitterIDs.indexOf(a.uuid);
  if (!1 === a instanceof ParticleEmitterControl) {
    console.error("nunuStudio: emitter argument must be instance of ParticleEmitterControl. Was provided with:", a);
  } else {
    if (-1 === d) {
      console.error("nunuStudio: ParticleEmitterControl does not exist in this group. Will not remove.");
    } else {
      for (var g = a.attributeOffset, h = g + a.particleCount, e = this.attributes.params.typedArray, k = g; k < h; ++k) {
        e.array[4 * k] = 0, e.array[4 * k + 1] = 0;
      }
      this.emitters.splice(d, 1);
      this.emitterIDs.splice(d, 1);
      for (var c in this.attributes) {
        this.attributes.hasOwnProperty(c) && this.attributes[c].splice(g, h);
      }
      this.particleCount -= a.particleCount;
      a._onRemove();
      this._attributesNeedRefresh = !0;
    }
  }
};
ParticleGroup.prototype.getFromPool = function() {
  var a = this.pool, d = this._createNewWhenPoolEmpty;
  return a.length ? a.pop() : d ? (a = new ParticleEmitterControl(this.poolCreationSettings), this.addEmitter(a), a) : null;
};
ParticleGroup.prototype.releaseIntoPool = function(a) {
  if (!1 === a instanceof ParticleEmitterControl) {
    console.error("nunuStudio: Argument is not instanceof ParticleEmitterControl:", a);
  } else {
    return a.reset(), this.pool.unshift(a), this;
  }
};
ParticleGroup.prototype.getPool = function() {
  return this.pool;
};
ParticleGroup.prototype.addPool = function(a, d, g) {
  this.poolCreationSettings = d;
  this._createNewWhenPoolEmpty = !!g;
  for (var h = 0; h < a; ++h) {
    g = Array.isArray(d) ? new ParticleEmitterControl(d[h]) : new ParticleEmitterControl(d), this.addEmitter(g), this.releaseIntoPool(g);
  }
  return this;
};
ParticleGroup.prototype._triggerSingleEmitter = function(a) {
  var d = this.getFromPool(), g = this;
  if (null === d) {
    console.log("nunuStudio: ParticleGroup pool ran out.");
  } else {
    return a instanceof THREE.Vector3 && (d.position.value.copy(a), d.position.value = d.position.value), d.enable(), setTimeout(function() {
      d.disable();
      g.releaseIntoPool(d);
    }, 1E3 * Math.max(d.duration, d.maxAge.value + d.maxAge.spread)), this;
  }
};
ParticleGroup.prototype.triggerEmitter = function(a, d) {
  if ("number" === typeof a && 1 < a) {
    for (var g = 0; g < a; ++g) {
      this._triggerSingleEmitter(d);
    }
  } else {
    this._triggerSingleEmitter(d);
  }
  return this;
};
ParticleGroup.prototype._updateUniforms = function(a) {
  this.uniforms.runTime.value += a;
  this.uniforms.deltaTime.value = a;
};
ParticleGroup.prototype._resetBufferRanges = function() {
  for (var a = this.attributeKeys, d = this.attributeCount - 1; 0 <= d; --d) {
    this.attributes[a[d]].resetUpdateRange();
  }
};
ParticleGroup.prototype._updateBuffers = function(a) {
  var d = this.attributeKeys, g = this.attributes;
  a = a.bufferUpdateRanges;
  for (var h, e, k = this.attributeCount - 1; 0 <= k; --k) {
    h = d[k], e = a[h], h = g[h], h.setUpdateRange(e.min, e.max), h.flagUpdate();
  }
};
ParticleGroup.prototype.tick = function(a) {
  var d = this.emitters, g = d.length;
  a = a || this.fixedTimeStep;
  var h = this.attributeKeys, e = this.attributes;
  this._updateUniforms(a);
  this._resetBufferRanges();
  if (0 !== g || !1 !== this._attributesNeedRefresh || !1 !== this._attributesNeedDynamicReset) {
    var k = 0;
    for (var c; k < g; ++k) {
      c = d[k], c.tick(a), this._updateBuffers(c);
    }
    if (!0 === this._attributesNeedDynamicReset) {
      k = this.attributeCount - 1;
      for (k; 0 <= k; --k) {
        e[h[k]].resetDynamic();
      }
      this._attributesNeedDynamicReset = !1;
    }
    if (!0 === this._attributesNeedRefresh) {
      k = this.attributeCount - 1;
      for (k; 0 <= k; --k) {
        e[h[k]].forceUpdateAll();
      }
      this._attributesNeedRefresh = !1;
      this._attributesNeedDynamicReset = !0;
    }
  }
};
ParticleGroup.prototype.dispose = function() {
  this.geometry.dispose();
  this.material.dispose();
  return this;
};
ParticleGroup.prototype.toJSON = function(a) {
  a = {texture:{}};
  a.texture.value = this.texture.uuid;
  a.texture.frames = this.textureFrames.toArray();
  a.texture.frameCount = this.textureFrameCount;
  a.texture.loop = this.textureLoop;
  a.fixedTimeStep = this.fixedTimeStep;
  a.hasPerspective = this.hasPerspective;
  a.colorize = this.colorize;
  a.maxParticleCount = this.maxParticleCount;
  a.transparent = this.transparent;
  a.blending = this.blending;
  a.alphaTest = this.alphaTest;
  a.depthWrite = this.depthWrite;
  a.depthTest = this.depthTest;
  a.fog = this.fog;
  a.scale = this.scale;
  return a;
};
"use strict";
var ShaderUtils = {types:{BOOLEAN:"boolean", STRING:"string", NUMBER:"number", OBJECT:"object"}, ensureTypedArg:function(a, d, g) {
  return typeof a === d ? a : g;
}, ensureArrayTypedArg:function(a, d, g) {
  if (Array.isArray(a)) {
    for (var h = a.length - 1; 0 <= h; --h) {
      if (typeof a[h] !== d) {
        return g;
      }
    }
    return a;
  }
  return this.ensureTypedArg(a, d, g);
}, ensureInstanceOf:function(a, d, g) {
  return void 0 !== d && a instanceof d ? a : g;
}, ensureArrayInstanceOf:function(a, d, g) {
  if (Array.isArray(a)) {
    for (var h = a.length - 1; 0 <= h; --h) {
      if (void 0 !== d && !1 === a[h] instanceof d) {
        return g;
      }
    }
    return a;
  }
  return this.ensureInstanceOf(a, d, g);
}, ensureValueOverLifetimeCompliance:function(a, d, g) {
  d = d || 3;
  g = g || 3;
  !1 === Array.isArray(a._value) && (a._value = [a._value]);
  !1 === Array.isArray(a._spread) && (a._spread = [a._spread]);
  var h = this.clamp(a._value.length, d, g);
  d = this.clamp(a._spread.length, d, g);
  h = Math.max(h, d);
  a._value.length !== h && (a._value = this.interpolateArray(a._value, h));
  a._spread.length !== h && (a._spread = this.interpolateArray(a._spread, h));
}, interpolateArray:function(a, d) {
  for (var g = a.length, h = ["function" === typeof a[0].clone ? a[0].clone() : a[0]], e = (g - 1) / (d - 1), k = 1; k < d - 1; ++k) {
    var c = k * e, p = Math.floor(c);
    h[k] = this.lerpTypeAgnostic(a[p], a[Math.ceil(c)], c - p);
  }
  h.push("function" === typeof a[g - 1].clone ? a[g - 1].clone() : a[g - 1]);
  return h;
}, clamp:function(a, d, g) {
  return Math.max(d, Math.min(a, g));
}, zeroToEpsilon:function(a, d) {
  d = d ? 1E-4 * Math.random() : 1E-5;
  0 > a && -1E-5 < a && (d = -d);
  return d;
}, lerpTypeAgnostic:function(a, d, g) {
  var h = this.types;
  if (typeof a === h.NUMBER && typeof d === h.NUMBER) {
    return a + (d - a) * g;
  }
  if (a instanceof THREE.Vector2 && d instanceof THREE.Vector2) {
    return h = a.clone(), h.x = this.lerp(a.x, d.x, g), h.y = this.lerp(a.y, d.y, g), h;
  }
  if (a instanceof THREE.Vector3 && d instanceof THREE.Vector3) {
    return h = a.clone(), h.x = this.lerp(a.x, d.x, g), h.y = this.lerp(a.y, d.y, g), h.z = this.lerp(a.z, d.z, g), h;
  }
  if (a instanceof THREE.Vector4 && d instanceof THREE.Vector4) {
    return h = a.clone(), h.x = this.lerp(a.x, d.x, g), h.y = this.lerp(a.y, d.y, g), h.z = this.lerp(a.z, d.z, g), h.w = this.lerp(a.w, d.w, g), h;
  }
  if (a instanceof THREE.Color && d instanceof THREE.Color) {
    return h = a.clone(), h.r = this.lerp(a.r, d.r, g), h.g = this.lerp(a.g, d.g, g), h.b = this.lerp(a.b, d.b, g), h;
  }
  console.warn("nunuStudio: Invalid argument types, or argument types do not match.", a, d);
}, lerp:function(a, d, g) {
  return a + (d - a) * g;
}, roundToNearestMultiple:function(a, d) {
  if (0 === d) {
    return a;
  }
  var g = Math.abs(a) % d;
  return 0 === g ? a : 0 > a ? -(Math.abs(a) - g) : a + d - g;
}, arrayValuesAreEqual:function(a) {
  for (var d = 0; d < a.length - 1; ++d) {
    if (a[d] !== a[d + 1]) {
      return !1;
    }
  }
  return !0;
}, randomFloat:function(a, d) {
  return a + d * (Math.random() - .5);
}, randomVector3:function(a, d, g, h, e) {
  var k = g.x + (Math.random() * h.x - .5 * h.x), c = g.y + (Math.random() * h.y - .5 * h.y);
  g = g.z + (Math.random() * h.z - .5 * h.z);
  e && (k = .5 * -e.x + this.roundToNearestMultiple(k, e.x), c = .5 * -e.y + this.roundToNearestMultiple(c, e.y), g = .5 * -e.z + this.roundToNearestMultiple(g, e.z));
  a.typedArray.setVec3Components(d, k, c, g);
}, randomColor:function(a, d, g, h) {
  var e = g.r + Math.random() * h.x, k = g.g + Math.random() * h.y;
  g = g.b + Math.random() * h.z;
  e = this.clamp(e, 0, 1);
  k = this.clamp(k, 0, 1);
  g = this.clamp(g, 0, 1);
  a.typedArray.setVec3Components(d, e, k, g);
}, randomColorAsHex:function() {
  var a = new THREE.Color;
  return function(d, g, h, e) {
    for (var k = h.length, c = [], p = 0; p < k; ++p) {
      var t = e[p];
      a.copy(h[p]);
      a.r += Math.random() * t.x - .5 * t.x;
      a.g += Math.random() * t.y - .5 * t.y;
      a.b += Math.random() * t.z - .5 * t.z;
      a.r = this.clamp(a.r, 0, 1);
      a.g = this.clamp(a.g, 0, 1);
      a.b = this.clamp(a.b, 0, 1);
      c.push(a.getHex());
    }
    d.typedArray.setVec4Components(g, c[0], c[1], c[2], c[3]);
  };
}(), randomVector3OnSphere:function(a, d, g, h, e, k, c, p) {
  p = 2 * Math.random() - 1;
  var t = 6.2832 * Math.random(), f = Math.sqrt(1 - p * p);
  h = this.randomFloat(h, e);
  c && (h = Math.round(h / c) * c);
  c = f * Math.cos(t) * h;
  t = f * Math.sin(t) * h;
  c *= k.x;
  t *= k.y;
  k = p * h * k.z;
  c += g.x;
  t += g.y;
  k += g.z;
  a.typedArray.setVec3Components(d, c, t, k);
}, seededRandom:function(a) {
  a = 1E4 * Math.sin(a);
  return a - (a | 0);
}, randomVector3OnDisc:function(a, d, g, h, e, k, c) {
  var p = 6.2832 * Math.random();
  h = Math.abs(this.randomFloat(h, e));
  c && (h = Math.round(h / c) * c);
  c = Math.cos(p) * h;
  p = Math.sin(p) * h;
  c *= k.x;
  p *= k.y;
  c += g.x;
  p += g.y;
  a.typedArray.setVec3Components(d, c, p, 0 + g.z);
}, randomDirectionVector3OnSphere:function() {
  var a = new THREE.Vector3;
  return function(d, g, h, e, k, c, p, t) {
    a.copy(c);
    a.x -= h;
    a.y -= e;
    a.z -= k;
    a.normalize().multiplyScalar(-this.randomFloat(p, t));
    d.typedArray.setVec3Components(g, a.x, a.y, a.z);
  };
}(), randomDirectionVector3OnDisc:function() {
  var a = new THREE.Vector3;
  return function(d, g, h, e, k, c, p, t) {
    a.copy(c);
    a.x -= h;
    a.y -= e;
    a.z -= k;
    a.normalize().multiplyScalar(-this.randomFloat(p, t));
    d.typedArray.setVec3Components(g, a.x, a.y, 0);
  };
}(), getPackedRotationAxis:function() {
  var a = new THREE.Vector3, d = new THREE.Vector3, g = new THREE.Color, h = new THREE.Vector3(1, 1, 1);
  return function(e, k) {
    a.copy(e).normalize();
    d.copy(k).normalize();
    a.x += .5 * -k.x + Math.random() * k.x;
    a.y += .5 * -k.y + Math.random() * k.y;
    a.z += .5 * -k.z + Math.random() * k.z;
    a.normalize().add(h).multiplyScalar(.5);
    g.setRGB(a.x, a.y, a.z);
    return g.getHex();
  };
}()};
"use strict";
function ShaderAttribute(a, d, g) {
  this.type = "string" === typeof a && ShaderAttribute.typeSizeMap.hasOwnProperty(a) ? a : "f";
  this.componentSize = ShaderAttribute.typeSizeMap[this.type];
  this.arrayType = g || Float32Array;
  this.bufferAttribute = this.typedArray = null;
  this.dynamicBuffer = !!d;
  this.updateMax = this.updateMin = 0;
}
ShaderAttribute.constructor = ShaderAttribute;
ShaderAttribute.typeSizeMap = {f:1, v2:2, v3:3, v4:4, c:3, m3:9, m4:16};
ShaderAttribute.prototype.setUpdateRange = function(a, d) {
  this.updateMin = Math.min(a * this.componentSize, this.updateMin * this.componentSize);
  this.updateMax = Math.max(d * this.componentSize, this.updateMax * this.componentSize);
};
ShaderAttribute.prototype.flagUpdate = function() {
  var a = this.bufferAttribute.updateRange;
  a.offset = this.updateMin;
  a.count = Math.min(this.updateMax - this.updateMin + this.componentSize, this.typedArray.array.length);
  this.bufferAttribute.needsUpdate = !0;
};
ShaderAttribute.prototype.resetUpdateRange = function() {
  this.updateMax = this.updateMin = 0;
};
ShaderAttribute.prototype.resetDynamic = function() {
  this.bufferAttribute.usage = this.dynamicBuffer ? THREE.DynamicDrawUsage : THREE.StaticDrawUsage;
};
ShaderAttribute.prototype.splice = function(a, d) {
  this.typedArray.splice(a, d);
  this.forceUpdateAll();
};
ShaderAttribute.prototype.forceUpdateAll = function() {
  this.bufferAttribute.array = this.typedArray.array;
  this.bufferAttribute.updateRange.offset = 0;
  this.bufferAttribute.updateRange.count = -1;
  this.bufferAttribute.usage = THREE.StaticDrawUsage;
  this.bufferAttribute.needsUpdate = !0;
};
ShaderAttribute.prototype._ensureTypedArray = function(a) {
  if (null === this.typedArray || this.typedArray.size !== a * this.componentSize) {
    null !== this.typedArray && this.typedArray.size !== a ? this.typedArray.setSize(a) : null === this.typedArray && (this.typedArray = new TypedArrayHelper(this.arrayType, a, this.componentSize));
  }
};
ShaderAttribute.prototype._createBufferAttribute = function(a) {
  this._ensureTypedArray(a);
  null !== this.bufferAttribute ? (this.bufferAttribute.array = this.typedArray.array, this.bufferAttribute.count = this.bufferAttribute.array.length / this.bufferAttribute.itemSize, this.bufferAttribute.needsUpdate = !0) : (this.bufferAttribute = new THREE.BufferAttribute(this.typedArray.array, this.componentSize), this.bufferAttribute.usage = this.dynamicBuffer ? THREE.DynamicDrawUsage : THREE.StaticDrawUsage);
};
ShaderAttribute.prototype.getLength = function() {
  return null === this.typedArray ? 0 : this.typedArray.array.length;
};
"use strict";
function TypedArrayHelper(a, d, g, h) {
  this.componentSize = g || 1;
  this.size = d || 1;
  this.TypedArrayConstructor = a || Float32Array;
  this.array = new a(d * this.componentSize);
  this.indexOffset = h || 0;
}
TypedArrayHelper.constructor = TypedArrayHelper;
TypedArrayHelper.prototype.setSize = function(a, d) {
  var g = this.array.length;
  d || (a *= this.componentSize);
  if (a < g) {
    return this.shrink(a);
  }
  if (a > g) {
    return this.grow(a);
  }
};
TypedArrayHelper.prototype.shrink = function(a) {
  this.array = this.array.subarray(0, a);
  this.size = a;
  return this;
};
TypedArrayHelper.prototype.grow = function(a) {
  var d = this.array, g = new this.TypedArrayConstructor(a);
  g.set(d);
  this.array = g;
  this.size = a;
  return this;
};
TypedArrayHelper.prototype.splice = function(a, d) {
  a *= this.componentSize;
  d *= this.componentSize;
  for (var g = [], h = this.array, e = h.length, k = 0; k < e; ++k) {
    (k < a || k >= d) && g.push(h[k]);
  }
  this.setFromArray(0, g);
  return this;
};
TypedArrayHelper.prototype.setFromArray = function(a, d) {
  var g = a + d.length;
  g > this.array.length ? this.grow(g) : g < this.array.length && this.shrink(g);
  this.array.set(d, this.indexOffset + a);
  return this;
};
TypedArrayHelper.prototype.setVec2 = function(a, d) {
  return this.setVec2Components(a, d.x, d.y);
};
TypedArrayHelper.prototype.setVec2Components = function(a, d, g) {
  var h = this.array;
  a = this.indexOffset + a * this.componentSize;
  h[a] = d;
  h[a + 1] = g;
  return this;
};
TypedArrayHelper.prototype.setVec3 = function(a, d) {
  return this.setVec3Components(a, d.x, d.y, d.z);
};
TypedArrayHelper.prototype.setVec3Components = function(a, d, g, h) {
  var e = this.array;
  a = this.indexOffset + a * this.componentSize;
  e[a] = d;
  e[a + 1] = g;
  e[a + 2] = h;
  return this;
};
TypedArrayHelper.prototype.setVec4 = function(a, d) {
  return this.setVec4Components(a, d.x, d.y, d.z, d.w);
};
TypedArrayHelper.prototype.setVec4Components = function(a, d, g, h, e) {
  var k = this.array;
  a = this.indexOffset + a * this.componentSize;
  k[a] = d;
  k[a + 1] = g;
  k[a + 2] = h;
  k[a + 3] = e;
  return this;
};
TypedArrayHelper.prototype.setMat3 = function(a, d) {
  return this.setFromArray(this.indexOffset + a * this.componentSize, d.elements);
};
TypedArrayHelper.prototype.setMat4 = function(a, d) {
  return this.setFromArray(this.indexOffset + a * this.componentSize, d.elements);
};
TypedArrayHelper.prototype.setColor = function(a, d) {
  return this.setVec3Components(a, d.r, d.g, d.b);
};
TypedArrayHelper.prototype.setNumber = function(a, d) {
  this.array[this.indexOffset + a * this.componentSize] = d;
  return this;
};
TypedArrayHelper.prototype.getValueAtIndex = function(a) {
  return this.array[this.indexOffset + a];
};
TypedArrayHelper.prototype.getComponentValueAtIndex = function(a) {
  return this.array.subarray(this.indexOffset + a * this.componentSize);
};
"use strict";
var ParticleShaderChunks = {defines:"#define PACKED_COLOR_SIZE 256.0\n#define PACKED_COLOR_DIVISOR 255.0", uniforms:"uniform float deltaTime;\nuniform float runTime;\nuniform sampler2D textureSampler;\nuniform vec4 textureAnimation;\nuniform float scale;", attributes:"attribute vec4 acceleration;\nattribute vec3 velocity;\nattribute vec4 rotation;\nattribute vec3 rotationCenter;\nattribute vec4 params;\nattribute vec4 size;\nattribute vec4 angle;\nattribute vec4 color;\nattribute vec4 opacity;", 
varyings:"varying vec4 vColor;\n#ifdef SHOULD_ROTATE_TEXTURE\n    varying float vAngle;\n#endif\n#ifdef SHOULD_CALCULATE_SPRITE\n    varying vec4 vSpriteSheet;\n#endif", branchAvoidanceFunctions:"float when_gt(float x, float y) {\n    return max(sign(x - y), 0.0);\n}\nfloat when_lt(float x, float y) {\n    return min(max(1.0 - sign(x - y), 0.0), 1.0);\n}\nfloat when_eq(float x, float y) {\n    return 1.0 - abs(sign(x - y));\n}\nfloat when_ge(float x, float y) {\n  return 1.0 - when_lt(x, y);\n}\nfloat when_le(float x, float y) {\n  return 1.0 - when_gt(x, y);\n}\nfloat and(float a, float b) {\n    return a * b;\n}\nfloat or(float a, float b) {\n    return min(a + b, 1.0);\n}", 
unpackColor:"vec3 unpackColor(in float hex) {\n   vec3 c = vec3(0.0);\n   float r = mod((hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE);\n   float g = mod((hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE);\n   float b = mod(hex, PACKED_COLOR_SIZE);\n   c.r = r / PACKED_COLOR_DIVISOR;\n   c.g = g / PACKED_COLOR_DIVISOR;\n   c.b = b / PACKED_COLOR_DIVISOR;\n   return c;\n}", unpackRotationAxis:"vec3 unpackRotationAxis(in float hex) {\n   vec3 c = vec3(0.0);\n   float r = mod((hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE);\n   float g = mod((hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE);\n   float b = mod(hex, PACKED_COLOR_SIZE);\n   c.r = r / PACKED_COLOR_DIVISOR;\n   c.g = g / PACKED_COLOR_DIVISOR;\n   c.b = b / PACKED_COLOR_DIVISOR;\n   c *= vec3(2.0);\n   c -= vec3(1.0);\n   return c;\n}", 
floatOverLifetime:"float getFloatOverLifetime(in float positionInTime, in vec4 attr) {\n    highp float value = 0.0;\n    float deltaAge = positionInTime * float(VALUE_OVER_LIFETIME_LENGTH - 1);\n    float fIndex = 0.0;\n    float shouldApplyValue = 0.0;\n    value += attr[0] * when_eq(deltaAge, 0.0);\n\n    for(int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i) {\n       fIndex = float(i);\n       shouldApplyValue = and(when_gt(deltaAge, fIndex), when_le(deltaAge, fIndex + 1.0));\n       value += shouldApplyValue * mix(attr[i], attr[i + 1], deltaAge - fIndex);\n    }\n\n    return value;\n}", 
colorOverLifetime:"vec3 getColorOverLifetime(in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4) {\n    vec3 value = vec3(0.0);\n    value.x = getFloatOverLifetime(positionInTime, vec4(color1.x, color2.x, color3.x, color4.x));\n    value.y = getFloatOverLifetime(positionInTime, vec4(color1.y, color2.y, color3.y, color4.y));\n    value.z = getFloatOverLifetime(positionInTime, vec4(color1.z, color2.z, color3.z, color4.z));\n    return value;\n}", paramFetchingFunctions:"float getAlive() {\n   return params.x;\n}\nfloat getAge() {\n   return params.y;\n}\nfloat getMaxAge() {\n   return params.z;\n}\nfloat getWiggle() {\n   return params.w;\n}", 
forceFetchingFunctions:"vec4 getPosition(in float age) {\n   return modelViewMatrix * vec4(position, 1.0);\n}\nvec3 getVelocity(in float age) {\n   return velocity * age;\n}\nvec3 getAcceleration(in float age) {\n   return acceleration.xyz * age;\n}", rotationFunctions:"#ifdef SHOULD_ROTATE_PARTICLES\n   mat4 getRotationMatrix(in vec3 axis, in float angle) {\n       axis = normalize(axis);\n       float s = sin(angle);\n       float c = cos(angle);\n       float oc = 1.0 - c;\n\n       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                   0.0,                                0.0,                                0.0,                                1.0);\n   }\n\n   vec3 getRotation(in vec3 pos, in float positionInTime) {\n      if(rotation.y == 0.0) {\n           return pos;\n      }\n\n      vec3 axis = unpackRotationAxis(rotation.x);\n      vec3 center = rotationCenter;\n      vec3 translated;\n      mat4 rotationMatrix;\n      float angle = 0.0;\n      angle += when_eq(rotation.z, 0.0) * rotation.y;\n      angle += when_gt(rotation.z, 0.0) * mix(0.0, rotation.y, positionInTime);\n      translated = rotationCenter - pos;\n      rotationMatrix = getRotationMatrix(axis, angle);\n      return center - vec3(rotationMatrix * vec4(translated, 0.0));\n   }\n#endif", 
rotateTexture:"    vec2 vUv = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);\n\n    #ifdef SHOULD_ROTATE_TEXTURE\n       float x = gl_PointCoord.x - 0.5;\n       float y = 1.0 - gl_PointCoord.y - 0.5;\n       float c = cos(-vAngle);\n       float s = sin(-vAngle);\n       vUv = vec2(c * x + s * y + 0.5, c * y - s * x + 0.5);\n    #endif\n\n    #ifdef SHOULD_CALCULATE_SPRITE\n        float framesX = vSpriteSheet.x;\n        float framesY = vSpriteSheet.y;\n        float columnNorm = vSpriteSheet.z;\n        float rowNorm = vSpriteSheet.w;\n        vUv.x = gl_PointCoord.x * framesX + columnNorm;\n        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);\n    #endif\n\n    vec4 rotatedTexture = texture2D(textureSampler, vUv);"};
"use strict";
var ParticleShaders = {vertex:[ParticleShaderChunks.defines, ParticleShaderChunks.uniforms, ParticleShaderChunks.attributes, ParticleShaderChunks.varyings, THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, THREE.ShaderChunk.fog_pars_vertex, ParticleShaderChunks.branchAvoidanceFunctions, ParticleShaderChunks.unpackColor, ParticleShaderChunks.unpackRotationAxis, ParticleShaderChunks.floatOverLifetime, ParticleShaderChunks.colorOverLifetime, ParticleShaderChunks.paramFetchingFunctions, 
ParticleShaderChunks.forceFetchingFunctions, ParticleShaderChunks.rotationFunctions, "void main() {\n    highp float age = getAge();\n    highp float alive = getAlive();\n    highp float maxAge = getMaxAge();\n    highp float positionInTime = (age / maxAge);\n    highp float isAlive = when_gt(alive, 0.0);\n    #ifdef SHOULD_WIGGLE_PARTICLES\n        float wiggleAmount = positionInTime * getWiggle();\n        float wiggleSin = isAlive * sin(wiggleAmount);\n        float wiggleCos = isAlive * cos(wiggleAmount);\n    #endif\n    vec3 vel = getVelocity(age);\n    vec3 accel = getAcceleration(age);\n    vec3 force = vec3(0.0);\n    vec3 pos = vec3(position);\n    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;\n    force += vel;\n    force *= drag;\n    force += accel * age;\n    pos += force;\n    #ifdef SHOULD_WIGGLE_PARTICLES\n        pos.x += wiggleSin;\n        pos.y += wiggleCos;\n        pos.z += wiggleSin;\n    #endif\n    #ifdef SHOULD_ROTATE_PARTICLES\n        pos = getRotation(pos, positionInTime);\n    #endif\n    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n    highp float pointSize = getFloatOverLifetime(positionInTime, size) * isAlive;\n    #ifdef HAS_PERSPECTIVE\n        float perspective = scale / length(mvPosition.xyz);\n    #else\n        float perspective = 1.0;\n    #endif\n    float pointSizePerspective = pointSize * perspective;\n    #ifdef COLORIZE\n       vec3 c = isAlive * getColorOverLifetime(\n           positionInTime,\n           unpackColor(color.x),\n           unpackColor(color.y),\n           unpackColor(color.z),\n           unpackColor(color.w)\n      );\n    #else\n       vec3 c = vec3(1.0);\n    #endif\n    float o = isAlive * getFloatOverLifetime(positionInTime, opacity);\n    vColor = vec4(c, o);\n    #ifdef SHOULD_ROTATE_TEXTURE\n        vAngle = isAlive * getFloatOverLifetime(positionInTime, angle);\n    #endif\n    #ifdef SHOULD_CALCULATE_SPRITE\n        float framesX = textureAnimation.x;\n        float framesY = textureAnimation.y;\n        float loopCount = textureAnimation.w;\n        float totalFrames = textureAnimation.z;\n        float frameNumber = mod((positionInTime * loopCount) * totalFrames, totalFrames);\n        float column = floor(mod(frameNumber, framesX));\n        float row = floor((frameNumber - column) / framesX);\n        float columnNorm = column / framesX;\n        float rowNorm = row / framesY;\n        vSpriteSheet.x = 1.0 / framesX;\n        vSpriteSheet.y = 1.0 / framesY;\n        vSpriteSheet.z = columnNorm;\n        vSpriteSheet.w = rowNorm;\n    #endif\n    gl_PointSize = pointSizePerspective;\n    gl_Position = projectionMatrix * mvPosition;", 
THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.fog_vertex, "}"].join("\n"), fragment:[ParticleShaderChunks.uniforms, THREE.ShaderChunk.common, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, ParticleShaderChunks.varyings, ParticleShaderChunks.branchAvoidanceFunctions, "void main() {\n    vec3 outgoingLight = vColor.xyz;\n    \n    #ifdef ALPHATEST\n       if(vColor.w < float(ALPHATEST)) discard;\n    #endif", ParticleShaderChunks.rotateTexture, THREE.ShaderChunk.logdepthbuf_fragment, 
"    outgoingLight = vColor.xyz * rotatedTexture.xyz;\n    gl_FragColor = vec4(outgoingLight.xyz, rotatedTexture.w * vColor.w);", THREE.ShaderChunk.fog_fragment, "}"].join("\n")};
"use strict";
function ParticleEmitter(a, d) {
  this.group = new ParticleGroup(void 0 !== a ? a : ParticleEmitter.defaultGroup);
  this.emitter = new ParticleEmitterControl(void 0 !== d ? d : ParticleEmitter.defaultEmitter);
  this.group.addEmitter(this.emitter);
  THREE.Points.call(this, this.group.geometry, this.group.material);
  this.type = "ParticleEmiter";
  this.name = "particle";
  this.dynamicEmitter = this.frustumCulled = !1;
  this.clock = new THREE.Clock;
  this.temp = new THREE.Vector4;
  var g = this;
  Object.defineProperties(this, {texture:{get:function() {
    return g.group.texture;
  }, set:function(a) {
    g.group.texture = a;
  }}});
}
var ParticleDistributions = {BOX:1, SPHERE:2, DISC:3};
ParticleEmitter.valueOverLifetimeLength = 4;
ParticleEmitter.prototype = Object.create(THREE.Points.prototype);
ParticleEmitter.defaultEmitter = {particleCount:200, velocity:{value:new THREE.Vector3(0, 0, 0), spread:new THREE.Vector3(3, 3, 3)}, acceleration:{value:new THREE.Vector3(0, 0, 0), spread:new THREE.Vector3(0, 0, 0)}};
ParticleEmitter.defaultGroup = {texture:{value:null}, maxParticleCount:200, blending:THREE.AdditiveBlending, fog:!1, depthWrite:!1, depthTest:!0, transparent:!0, hasPerspective:!0};
ParticleEmitter.prototype.reload = function() {
  this.dispose();
  var a = this.children;
  this.children = [];
  var d = (new ObjectLoader).parse(this.toJSON());
  this.children = a;
  this.group = d.group;
  this.emitter = d.emitter;
  this.geometry = this.group.geometry;
  this.material = this.group.material;
};
ParticleEmitter.prototype.updateMatrix = function() {
  this.dynamicEmitter ? (this.matrix.makeRotationFromQuaternion(this.quaternion), this.matrix.scale(this.scale)) : this.matrix.compose(this.position, this.quaternion, this.scale);
  this.matrixWorldNeedsUpdate = !0;
};
ParticleEmitter.prototype.onBeforeRender = function(a, d, g, h) {
  this.group.uniforms.scale.value = a.getCurrentViewport(this.temp).w;
  this.group.tick(this.clock.getDelta());
  !0 === this.dynamicEmitter && (this.emitter.position.value = this.position);
};
ParticleEmitter.prototype.dispose = function() {
  this.group.dispose();
  THREE.Object3D.prototype.dispose.call(this);
};
ParticleEmitter.prototype.toJSON = function(a) {
  var d = this.material, g = this.geometry;
  this.geometry = this.material = void 0;
  var h = this.group.texture, e = THREE.Object3D.prototype.toJSON.call(this, a, function(a, c) {
    h = h.toJSON(a);
  });
  this.material = d;
  this.geometry = g;
  e.object.group = this.group.toJSON(a);
  e.object.emitter = this.emitter.toJSON(a);
  return e;
};
ParticleEmitter.fromJSON = function(a, d) {
  function g(a) {
    return Array.isArray(a) ? (new THREE.Vector3).fromArray(a) : new THREE.Vector3(a.x, a.y, a.z);
  }
  if (void 0 !== a.group) {
    var h = a.group;
    h.texture.value = d.getTexture(h.texture.value);
    h.texture.frames = (new THREE.Vector2).fromArray(h.texture.frames || [1, 1]);
  }
  if (void 0 !== a.emitter) {
    for (d = a.emitter, d.position.value = g(d.position.value), d.position.spread = g(d.position.spread), d.velocity.value = g(d.velocity.value), d.velocity.spread = g(d.velocity.spread), d.acceleration.value = g(d.acceleration.value), d.acceleration.spread = g(d.acceleration.spread), h = 0; h < d.color.value.length; h++) {
      d.color.value[h] = new THREE.Color(d.color.value[h]), d.color.spread[h] = g(d.color.spread[h]);
    }
  }
  return new ParticleEmitter(a.group, a.emitter);
};
"use strict";
function Sky(a, d, g, h) {
  THREE.Group.call(this);
  this.name = "sky";
  this.type = "Sky";
  this.colorTop = [new THREE.Color(7844859), new THREE.Color(30463), new THREE.Color(220086), new THREE.Color(9273)];
  this.colorBottom = [new THREE.Color(15461606), new THREE.Color(16777215), new THREE.Color(16705495), new THREE.Color(26023)];
  this.sunColor = 16777130;
  this.intensity = .3;
  this.moonColor = 5592507;
  this.hemisphere = new THREE.HemisphereLight(3310847, 16764031, .5);
  this.hemisphere.locked = !0;
  this.hemisphere.matrixAutoUpdate = !1;
  this.add(this.hemisphere);
  this.sun = new DirectionalLight(this.sunColor, this.intensity);
  this.sun.castShadow = !0;
  this.sun.locked = !0;
  this.add(this.sun);
  var e = {topColor:{type:"c", value:new THREE.Color(0, .46, 1)}, bottomColor:{type:"c", value:new THREE.Color(1, 1, 1)}, offset:{type:"f", value:20}, exponent:{type:"f", value:.2}};
  e.topColor.value.copy(this.hemisphere.color);
  var k = new THREE.SphereBufferGeometry(1500, 16, 16);
  e = new THREE.ShaderMaterial({vertexShader:Sky.VERTEX, fragmentShader:Sky.FRAGMENT, uniforms:e, side:THREE.BackSide});
  this.sky = new THREE.Mesh(k, e);
  this.sky.locked = !0;
  this.sky.matrixAutoUpdate = !1;
  this.add(this.sky);
  this.sky.raycast = function() {
    return null;
  };
  this.autoUpdate = void 0 !== a ? a : !0;
  this.sunDistance = void 0 !== g ? g : 100;
  this.dayTime = void 0 !== d ? d : 120;
  this.time = void 0 !== h ? h : 75;
  this.updateSky();
}
Sky.prototype = Object.create(THREE.Group.prototype);
Sky.VERTEX = "varying vec3 vWorldPosition;\nvoid main()\n{\n\tvec4 worldPosition = modelMatrix * vec4(position, 1.0);\n\tvWorldPosition = worldPosition.xyz;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}";
Sky.FRAGMENT = "uniform vec3 topColor;\nuniform vec3 bottomColor;\nuniform float offset;\nuniform float exponent;\nvarying vec3 vWorldPosition;\nvoid main()\n{\n\tfloat h = normalize(vWorldPosition + offset).y;\n\tgl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h , 0.0), exponent), 0.0)), 1.0);\n}";
Sky.prototype.initialize = function() {
  this.updateSky();
  THREE.Object3D.prototype.initialize.call(this);
};
Sky.prototype.update = function(a) {
  this.autoUpdate && (this.time += a, this.time > this.dayTime && (this.time -= this.dayTime), this.updateSky());
  THREE.Object3D.prototype.update.call(this, a);
};
Sky.prototype.updateSky = function() {
  var a = this.time / this.dayTime;
  if (.25 > a) {
    this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[3].r, this.colorTop[3].g, this.colorTop[3].b), this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[3].r, this.colorBottom[3].g, this.colorBottom[3].b);
  } else {
    if (.292 > a) {
      var d = 23.81 * (a - .25), g = 1 - d;
      this.sky.material.uniforms.topColor.value.setRGB(g * this.colorTop[3].r + d * this.colorTop[0].r, g * this.colorTop[3].g + d * this.colorTop[0].g, g * this.colorTop[3].b + d * this.colorTop[0].b);
      this.sky.material.uniforms.bottomColor.value.setRGB(g * this.colorBottom[3].r + d * this.colorBottom[0].r, g * this.colorBottom[3].g + d * this.colorBottom[0].g, g * this.colorBottom[3].b + d * this.colorBottom[0].b);
    } else {
      .4167 > a ? (this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[0].r, this.colorTop[0].g, this.colorTop[0].b), this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[0].r, this.colorBottom[0].g, this.colorBottom[0].b)) : .5 > a ? (d = 12 * (a - .4167), g = 1 - d, this.sky.material.uniforms.topColor.value.setRGB(g * this.colorTop[0].r + d * this.colorTop[1].r, g * this.colorTop[0].g + d * this.colorTop[1].g, g * this.colorTop[0].b + d * this.colorTop[1].b), this.sky.material.uniforms.bottomColor.value.setRGB(g * 
      this.colorBottom[0].r + d * this.colorBottom[1].r, g * this.colorBottom[0].g + d * this.colorBottom[1].g, g * this.colorBottom[0].b + d * this.colorBottom[1].b)) : .708 > a ? (this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[1].r, this.colorTop[1].g, this.colorTop[1].b), this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[1].r, this.colorBottom[1].g, this.colorBottom[1].b)) : .75 > a ? (d = 23.81 * (a - .708), g = 1 - d, this.sky.material.uniforms.topColor.value.setRGB(g * 
      this.colorTop[1].r + d * this.colorTop[2].r, g * this.colorTop[1].g + d * this.colorTop[2].g, g * this.colorTop[1].b + d * this.colorTop[2].b), this.sky.material.uniforms.bottomColor.value.setRGB(g * this.colorBottom[1].r + d * this.colorBottom[2].r, g * this.colorBottom[1].g + d * this.colorBottom[2].g, g * this.colorBottom[1].b + d * this.colorBottom[2].b)) : .8333 > a ? (d = 12.048 * (a - .75), g = 1 - d, this.sky.material.uniforms.topColor.value.setRGB(g * this.colorTop[2].r + d * this.colorTop[3].r, 
      g * this.colorTop[2].g + d * this.colorTop[3].g, g * this.colorTop[2].b + d * this.colorTop[3].b), this.sky.material.uniforms.bottomColor.value.setRGB(g * this.colorBottom[2].r + d * this.colorBottom[3].r, g * this.colorBottom[2].g + d * this.colorBottom[3].g, g * this.colorBottom[2].b + d * this.colorBottom[3].b)) : (this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[3].r, this.colorTop[3].g, this.colorTop[3].b), this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[3].r, 
      this.colorBottom[3].g, this.colorBottom[3].b));
    }
  }
  .2 > a ? (this.sun.intensity = this.intensity, this.sun.color.setHex(this.moonColor)) : .3 > a ? (d = 10 * (a - .2), .5 > d ? (this.sun.intensity = (2 - 2 * d) * this.intensity, this.sun.color.setHex(this.moonColor)) : (this.sun.intensity = 2 * d * this.intensity, this.sun.color.setHex(this.sunColor))) : .7 > a ? (this.sun.intensity = this.intensity, this.sun.color.setHex(this.sunColor)) : .8 > a ? (d = 10 * (a - .7), .5 > d ? (this.sun.intensity = (2 - 2 * d) * this.intensity, this.sun.color.setHex(this.sunColor)) : 
  (this.sun.intensity = 2 * d * this.intensity, this.sun.color.setHex(this.moonColor))) : (this.sun.intensity = this.intensity, this.sun.color.setHex(this.moonColor));
  d = MathUtils.PI2 * a - MathUtils.PID2;
  .25 < a && .75 > a ? (this.sun.position.x = this.sunDistance * Math.cos(d), this.sun.position.y = this.sunDistance * Math.sin(d)) : (this.sun.position.x = this.sunDistance * Math.cos(d + Math.PI), this.sun.position.y = this.sunDistance * Math.sin(d + Math.PI));
};
Sky.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.colorTop = [];
  for (var d = 0; d < this.colorTop.length; d++) {
    a.object.colorTop.push(this.colorTop[d].toJSON());
  }
  a.object.colorBottom = [];
  for (d = 0; d < this.colorBottom.length; d++) {
    a.object.colorBottom.push(this.colorBottom[d].toJSON());
  }
  a.object.sunColor = this.sunColor;
  a.object.moonColor = this.moonColor;
  a.object.intensity = this.intensity;
  a.object.autoUpdate = this.autoUpdate;
  a.object.sunDistance = this.sunDistance;
  a.object.dayTime = this.dayTime;
  a.object.time = this.time;
  a.object.sun = {};
  a.object.sun.castShadow = this.sun.castShadow;
  a.object.sun.shadow = this.sun.shadow.toJSON();
  return a;
};
"use strict";
function Container() {
  THREE.Group.call(this);
  this.name = "container";
  this.type = "Group";
}
Container.prototype = Object.create(THREE.Group.prototype);
"use strict";
function LensFlare() {
  THREE.Mesh.call(this, THREE.Lensflare.Geometry, new THREE.MeshBasicMaterial({opacity:0, transparent:!0}));
  this.name = "lensflare";
  this.type = "LensFlare";
  this.renderOrder = Infinity;
  this.castShadow = this.receiveShadow = this.frustumCulled = !1;
  this.elements = [];
  var a = new THREE.Vector3, d = new THREE.DataTexture(new Uint8Array(768), 16, 16, THREE.RGBFormat);
  d.minFilter = THREE.NearestFilter;
  d.magFilter = THREE.NearestFilter;
  d.wrapS = THREE.ClampToEdgeWrapping;
  d.wrapT = THREE.ClampToEdgeWrapping;
  d.needsUpdate = !0;
  var g = new THREE.DataTexture(new Uint8Array(768), 16, 16, THREE.RGBFormat);
  g.minFilter = THREE.NearestFilter;
  g.magFilter = THREE.NearestFilter;
  g.wrapS = THREE.ClampToEdgeWrapping;
  g.wrapT = THREE.ClampToEdgeWrapping;
  g.needsUpdate = !0;
  var h = THREE.Lensflare.Geometry, e = THREE.Lensflare.Shader, k = new THREE.RawShaderMaterial({uniforms:{scale:{value:null}, screenPosition:{value:null}}, vertexShader:"precision highp float;\n\t\t\tuniform vec3 screenPosition;\n\t\t\tuniform vec2 scale;\n\t\t\tattribute vec3 position;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tgl_Position = vec4(position.xy * scale + screenPosition.xy, screenPosition.z, 1.0);\n\t\t\t}", fragmentShader:"precision highp float;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tgl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n\t\t\t}", 
  depthTest:!0, depthWrite:!1, transparent:!1}), c = new THREE.RawShaderMaterial({uniforms:{map:{value:d}, scale:{value:null}, screenPosition:{value:null}}, vertexShader:"precision highp float;\n\t\t\tuniform vec3 screenPosition;\n\t\t\tuniform vec2 scale;\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\t\t\tvarying vec2 vUV;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tvUV = uv;\n\t\t\t\tgl_Position = vec4(position.xy * scale + screenPosition.xy, screenPosition.z, 1.0);\n\t\t\t}", fragmentShader:"precision highp float;\n\t\t\tuniform sampler2D map;\n\t\t\tvarying vec2 vUV;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tgl_FragColor = texture2D(map, vUV);\n\t\t\t}", 
  depthTest:!1, depthWrite:!1, transparent:!1}), p = new THREE.Mesh(h, k);
  e = THREE.LensflareElement.Shader;
  var t = new THREE.RawShaderMaterial({uniforms:{map:{value:null}, occlusionMap:{value:g}, color:{value:new THREE.Color(16777215)}, scale:{value:new THREE.Vector2}, screenPosition:{value:new THREE.Vector3}}, vertexShader:e.vertexShader, fragmentShader:e.fragmentShader, blending:THREE.AdditiveBlending, transparent:!0, depthWrite:!1}), f = new THREE.Mesh(h, t), n = new THREE.Vector2, b = new THREE.Vector2, m = new THREE.Box2, q = new THREE.Vector4;
  this.onBeforeRender = function(e, x, z) {
    e.getCurrentViewport(q);
    x = q.w / q.z;
    var r = q.z / 2, u = q.w / 2, v = 16 / q.w;
    n.set(v * x, v);
    m.min.set(q.x, q.y);
    m.max.set(q.x + (q.z - 16), q.y + (q.w - 16));
    a.setFromMatrixPosition(this.matrixWorld);
    a.applyMatrix4(z.matrixWorldInverse);
    a.applyMatrix4(z.projectionMatrix);
    b.x = q.x + a.x * r + r - 8;
    b.y = q.y + a.y * u + u - 8;
    if (m.containsPoint(b)) {
      e.copyFramebufferToTexture(b, d);
      r = k.uniforms;
      r.scale.value = n;
      r.screenPosition.value = a;
      e.renderBufferDirect(z, null, h, k, p, null);
      e.copyFramebufferToTexture(b, g);
      r = c.uniforms;
      r.scale.value = n;
      r.screenPosition.value = a;
      e.renderBufferDirect(z, null, h, c, p, null);
      u = 2 * -a.x;
      for (var y = 2 * -a.y, A = 0, D = this.elements.length; A < D; A++) {
        x = this.elements[A], r = t.uniforms, r.color.value.copy(x.color), r.map.value = x.texture, r.screenPosition.value.x = a.x + u * x.distance, r.screenPosition.value.y = a.y + y * x.distance, v = x.size / q.w, x = q.w / q.z, r.scale.value.set(v * x, v), t.uniformsNeedUpdate = !0, e.renderBufferDirect(z, null, h, t, f, null);
      }
    }
  };
  this.dispose = function() {
    k.dispose();
    c.dispose();
    t.dispose();
    d.dispose();
    g.dispose();
    for (var a = 0; a < this.elements.length; a++) {
      this.elements[a].texture.dispose();
    }
  };
}
LensFlare.prototype = Object.create(THREE.Mesh.prototype);
LensFlare.prototype.addFlare = function(a, d, g, h) {
  void 0 === d && (d = -1);
  void 0 === g && (g = 0);
  void 0 === h && (h = new Color(16777215));
  g = Math.min(g, Math.max(0, g));
  this.addElement(new THREE.LensflareElement(a, d, g, h));
};
LensFlare.prototype.addElement = function(a) {
  this.elements.push(a);
};
LensFlare.prototype.toJSON = function(a) {
  var d = this, g = [];
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, e) {
    for (e = 0; e < d.elements.length; e++) {
      var h = {};
      h.texture = d.elements[e].texture.toJSON(a).uuid;
      h.size = d.elements[e].size;
      h.distance = d.elements[e].distance;
      h.color = d.elements[e].color.getHex();
      g.push(h);
    }
  });
  a.object.elements = g;
  return a;
};
"use strict";
function HTMLView(a) {
  var d = document.createElement("iframe");
  d.style.border = "none";
  CSS3DObject.call(this, d);
  this.type = "HTMLView";
  this.name = "webview";
  var g = this, h, e;
  Object.defineProperties(this, {url:{get:function() {
    return a;
  }, set:function(d) {
    a = void 0 !== d ? HTMLView.processURL(d) : "";
    g.element.src = a;
  }}, width:{get:function() {
    return h;
  }, set:function(a) {
    h = a;
    g.element.style.width = h + "px";
  }}, height:{get:function() {
    return e;
  }, set:function(a) {
    e = a;
    g.element.style.height = e + "px";
  }}});
  this.height = this.width = 512;
  this.url = void 0 !== a ? a : "";
}
HTMLView.prototype = Object.create(CSS3DObject.prototype);
HTMLView.prototype.constructor = HTMLView;
HTMLView.processURL = function(a) {
  return a.replace("watch?v=", "embed/");
};
HTMLView.prototype.toJSON = function(a) {
  a = CSS3DObject.prototype.toJSON.call(this, a);
  a.object.height = this.height;
  a.object.width = this.width;
  a.object.url = this.url;
  return a;
};
"use strict";
function OrbitControls() {
  THREE.Group.call(this);
  this.name = "orbit";
  this.type = "OrbitControls";
  this.distance = 4;
  this.maxDistance = 20;
  this.minDistance = 2;
  this.sensitivity = .002;
  this.zoomSensitivity = .001;
  this.limitUp = 1.57;
  this.limitDown = -1.57;
  this.movementEnabled = this.zoomEnabled = this.needsButtonPressed = !0;
  this.center = new THREE.Vector3(0, 0, 0);
  this.vector = new THREE.Vector2(Math.PI / 2, 0);
  this.smooth = !0;
  this.friction = .8;
  this.speed = .3;
  this.invertNavigation = !1;
  this.keyboard = this.mouse = null;
  this.speedDistance = 0;
  this.speedCenter = new THREE.Vector3(0, 0, 0);
  this.speedOrientation = new THREE.Vector2(0, 0);
  this.tempVector = new THREE.Vector3;
}
OrbitControls.UP = new THREE.Vector3(0, 1, 0);
OrbitControls.ZERO = new THREE.Vector3(0, 0, 0);
OrbitControls.prototype = Object.create(THREE.Group.prototype);
OrbitControls.prototype.initialize = function() {
  for (var a = this; null !== a.parent;) {
    a = a.parent, a instanceof Program && (this.mouse = a.mouse, this.keyboard = a.keyboard);
  }
  this.center.copy(this.position);
  this.updateControls();
  THREE.Group.prototype.initialize.call(this);
};
OrbitControls.prototype.update = function(a) {
  var d = !1;
  if (!this.needsButtonPressed || this.mouse.buttonPressed(Mouse.LEFT)) {
    !0 === this.smooth ? (this.speedOrientation.y += this.speed * this.sensitivity * (this.invertNavigation ? this.mouse.delta.y : -this.mouse.delta.y), this.speedOrientation.x -= this.speed * this.sensitivity * this.mouse.delta.x) : (this.vector.y -= this.sensitivity * (this.invertNavigation ? this.mouse.delta.y : -this.mouse.delta.y), this.vector.x -= this.sensitivity * this.mouse.delta.x), d = !0;
  }
  this.zoomEnabled && (this.mouse.buttonPressed(Mouse.MIDDLE) && (!0 === this.smooth ? this.speedCenter.y += this.speed * this.sensitivity * this.mouse.delta.y * this.distance : this.center.y += this.sensitivity * this.mouse.delta.y * this.distance, d = !0), 0 !== this.mouse.wheel && (!0 === this.smooth ? this.speedDistance += this.speed * this.mouse.wheel * this.position.distanceTo(this.center) * this.sensitivity : this.distance += this.mouse.wheel * this.position.distanceTo(this.center) * this.sensitivity, 
  d = !0));
  if (this.movementEnabled && this.mouse.buttonPressed(Mouse.RIGHT)) {
    d = this.getWorldDirection(this.tempVector);
    d.y = 0;
    d.normalize();
    if (!0 === this.smooth) {
      var g = this.speed * this.mouse.delta.y * this.sensitivity * this.distance;
      this.speedCenter.x += -d.x * g;
      this.speedCenter.z += -d.z * g;
      d.applyAxisAngle(OrbitControls.UP, Math.PI / 2);
      g = this.speed * this.mouse.delta.x * this.sensitivity * this.distance;
      this.speedCenter.x -= d.x * g;
      this.speedCenter.z -= d.z * g;
    } else {
      g = this.mouse.delta.y * this.sensitivity * this.distance, this.center.x += -d.x * g, this.center.z += -d.z * g, d.applyAxisAngle(OrbitControls.UP, Math.PI / 2), g = this.mouse.delta.x * this.sensitivity * this.distance, this.center.x -= d.x * g, this.center.z -= d.z * g;
    }
    d = !0;
  }
  !0 === this.smooth ? (this.distance += this.speedDistance, this.center.add(this.speedCenter), this.vector.add(this.speedOrientation), this.speedDistance *= this.friction, this.speedOrientation.multiplyScalar(this.friction), this.speedCenter.multiplyScalar(this.friction), this.updateControls()) : (!0 === d && this.updateControls(), THREE.Object3D.prototype.update.call(this, a));
};
OrbitControls.prototype.updateControls = function() {
  this.vector.y < this.limitDown ? this.vector.y = this.limitDown : this.vector.y > this.limitUp && (this.vector.y = this.limitUp);
  this.distance < this.minDistance ? this.distance = this.minDistance : this.distance > this.maxDistance && (this.distance = this.maxDistance);
  var a = this.distance * Math.cos(this.vector.y);
  this.position.set(Math.cos(this.vector.x) * a, this.distance * Math.sin(this.vector.y), Math.sin(this.vector.x) * a);
  this.position.add(this.center);
  a = new THREE.Matrix4;
  a.lookAt(this.position, this.center, OrbitControls.UP);
  this.quaternion.setFromRotationMatrix(a);
};
OrbitControls.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.distance = this.distance;
  a.object.maxDistance = this.maxDistance;
  a.object.minDistance = this.minDistance;
  a.object.sensitivity = this.sensitivity;
  a.object.limitUp = this.limitUp;
  a.object.limitDown = this.limitDown;
  a.object.needsButtonPressed = this.needsButtonPressed;
  a.object.zoomEnabled = this.zoomEnabled;
  a.object.movementEnabled = this.movementEnabled;
  a.object.smooth = this.smooth;
  a.object.friction = this.friction;
  a.object.speed = this.speed;
  a.object.invertNavigation = this.invertNavigation;
  a.object.center = this.center.toArray();
  a.object.vector = this.vector.toArray();
  return a;
};
"use strict";
function FirstPersonControls() {
  THREE.Group.call(this);
  this.name = "controls";
  this.type = "FirstPersonControls";
  this.sensitivity = .005;
  this.movementEnabled = this.needsButtonPressed = !0;
  this.moveSpeed = .05;
  this.moveOnPlane = !1;
  this.moveKeys = [Keyboard.W, Keyboard.S, Keyboard.A, Keyboard.D];
  this.vector = new THREE.Vector2(0, 0);
  this.keyboard = this.mouse = null;
  this.tempVector = new THREE.Vector3;
}
FirstPersonControls.UP = new THREE.Vector3(0, 1, 0);
FirstPersonControls.prototype = Object.create(THREE.Group.prototype);
FirstPersonControls.prototype.initialize = function() {
  for (var a = this; null !== a.parent;) {
    a = a.parent, a instanceof Program && (this.mouse = a.mouse, this.keyboard = a.keyboard);
  }
  this.updateControls();
  THREE.Group.prototype.initialize.call(this);
};
FirstPersonControls.prototype.update = function(a) {
  if (!this.needsButtonPressed || this.mouse.buttonPressed(Mouse.LEFT)) {
    this.vector.y -= this.sensitivity * this.mouse.delta.y, this.vector.x -= this.sensitivity * this.mouse.delta.x, -1.57 > this.vector.y ? this.vector.y = -1.57 : 1.57 < this.vector.y && (this.vector.y = 1.57), this.updateControls();
  }
  if (this.movementEnabled) {
    if (this.keyboard.keyPressed(this.moveKeys[0])) {
      var d = this.getWorldDirection(this.tempVector);
      this.moveOnPlane && (d.y = 0);
      d.normalize();
      d.multiplyScalar(this.moveSpeed);
      this.position.sub(d);
    }
    this.keyboard.keyPressed(this.moveKeys[1]) && (d = this.getWorldDirection(this.tempVector), this.moveOnPlane && (d.y = 0), d.normalize(), d.multiplyScalar(this.moveSpeed), this.position.add(d));
    this.keyboard.keyPressed(this.moveKeys[2]) && (d = new THREE.Vector3(Math.sin(this.vector.x - 1.57), 0, Math.cos(this.vector.x - 1.57)), d.normalize(), d.multiplyScalar(this.moveSpeed), this.position.sub(d));
    this.keyboard.keyPressed(this.moveKeys[3]) && (d = new THREE.Vector3(Math.sin(this.vector.x + 1.57), 0, Math.cos(this.vector.x + 1.57)), d.normalize(), d.multiplyScalar(this.moveSpeed), this.position.sub(d));
  }
  THREE.Object3D.prototype.update.call(this, a);
};
FirstPersonControls.prototype.updateControls = function() {
  var a = Math.cos(this.vector.y);
  a = new THREE.Vector3(Math.sin(this.vector.x) * a, Math.sin(this.vector.y), Math.cos(this.vector.x) * a);
  a.add(this.position);
  var d = new THREE.Matrix4;
  d.lookAt(this.position, a, FirstPersonControls.UP);
  this.quaternion.setFromRotationMatrix(d);
};
FirstPersonControls.prototype.getDirection = function() {
  var a = this.getWorldDirection(this.tempVector);
  a.normalize();
  return a;
};
FirstPersonControls.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.moveSpeed = this.moveSpeed;
  a.object.sensitivity = this.sensitivity;
  a.object.needsButtonPressed = this.needsButtonPressed;
  a.object.movementEnabled = this.movementEnabled;
  a.object.moveOnPlane = this.moveOnPlane;
  a.object.moveKeys = this.moveKeys;
  return a;
};
"use strict";
function Program(a) {
  ResourceManager.call(this);
  this.type = "Program";
  this.matrixAutoUpdate = !1;
  this.app = null;
  this.name = void 0 !== a ? a : "program";
  this.author = this.description = "";
  this.version = "0.0.0";
  this.vr = this.handlePixelRatio = this.lockPointer = !1;
  this.vrScale = 1;
  this.rendererConfig = new RendererConfiguration;
  this.targetConfig = new TargetConfig;
  this.division = this.canvas = this.renderer = this.mouse = this.keyboard = this.scene = this.defaultCamera = this.defaultScene = null;
  this.manager = new EventManager;
  this.clock = new THREE.Clock;
  this.vrRunning = !1;
}
Program.prototype = Object.create(ResourceManager.prototype);
Program.prototype.initialize = function() {
  this.manager.create();
  null === this.mouse && (this.mouse = new Mouse);
  null === this.keyboard && (this.keyboard = new keyboard);
  if (null !== this.defaultScene) {
    for (var a = 0; a < this.children.length; a++) {
      if (this.children[a].uuid === this.defaultScene) {
        this.setScene(this.children[a]);
        break;
      }
    }
  } else {
    0 < this.children.length && this.setScene(this.children[0]);
  }
  this.clock.start();
};
Program.prototype.setMouseKeyboard = function(a, d) {
  this.mouse !== a && (null !== this.mouse && this.mouse.dispose(), this.mouse = a);
  this.keyboard !== d && (null !== this.keyboard && this.keyboard.dispose(), this.keyboard = d);
};
Program.prototype.setRenderer = function(a, d) {
  this.renderer = a;
  this.renderer.autoClear = !1;
  this.canvas = a.domElement;
  this.division = this.canvas.parentElement;
  d && this.updateRenderer();
};
Program.prototype.update = function() {
  var a = this.clock.getDelta();
  this.scene.update(a);
};
Program.prototype.render = function(a) {
  this.scene.render(a);
};
Program.prototype.resize = function(a, d) {
  null !== this.defaultCamera && this.defaultCamera.resize(a, d);
  this.scene.resize(a, d);
};
Program.prototype.updateRenderer = function() {
  null !== this.renderer && this.rendererConfig.apply(this.renderer);
};
Program.prototype.vrAvailable = function() {
  return this.vr && Nunu.vrAvailable();
};
Program.prototype.enterVR = function() {
  if (this.vr) {
    var a = this;
    Nunu.enterVR(this.renderer, function() {
      a.vrRunning = !0;
    });
  }
};
Program.prototype.exitVR = function() {
  this.vr && (Nunu.exitVR(this.renderer), this.vrRunning = !1);
};
Program.prototype.setScene = function(a) {
  "string" === typeof a && (a = this.getObjectByName(a));
  null !== this.scene && this.scene.dispose();
  this.scene = a;
  null !== this.scene ? (null === this.scene.defaultCamera && (this.scene.defaultCamera = this.defaultCamera), this.scene.initialize()) : console.warn("nunuStudio: Program setScene scene is null.");
};
Program.prototype.remove = function(a) {
  if (a instanceof Scene) {
    var d = this.children.indexOf(a);
    -1 < d && (this.children.splice(d, 1), a.parent = null);
    a === this.scene && (this.scene.dispose(), this.scene = null);
    0 === this.children.length && (this.scene = null);
  } else {
    console.warn("nunuStudio: Trying to remove Object3D from program, only Scene objects allowed.");
  }
};
Program.prototype.add = function(a) {
  a instanceof Scene ? (a.parent = this, this.children.push(a)) : console.warn("nunuStudio: Trying to add Object3D to program, only Scene objects allowed.");
};
Program.prototype.clone = function() {
  return (new ObjectLoader).parse(this.toJSON());
};
Program.prototype.setInitialScene = function(a) {
  this.defaultScene = a.uuid;
};
Program.prototype.dispose = function() {
  this.manager.destroy();
  null !== this.scene ? this.scene.dispose() : console.warn("nunuStudio: Program dispose() scene is null.", this);
  ResourceManager.prototype.dispose.call(this);
  THREE.Object3D.prototype.dispose.call(this);
};
Program.prototype.receiveDataApp = function(a) {
  var d = !1;
  this.traverse(function(g) {
    g instanceof Script && (g.appData(a), d = !0);
  });
  d || console.warn("nunuStudio: No script with onAppData found", a);
};
Program.prototype.sendDataApp = function(a) {
  if (null !== this.app) {
    if (void 0 !== this.app.onDataReceived) {
      this.app.onDataReceived(a);
    } else {
      console.warn("nunuStudio: Send app data communication", a);
    }
  } else {
    console.warn("nunuStudio: Data sent to app", a);
  }
};
Program.prototype.toJSON = function(a, d) {
  var g = this;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, e) {
    if (!1 !== d) {
      e = g.textures;
      for (var h in e) {
        var c = e[h];
        void 0 === a.textures[c.uuid] && (a.textures[c.uuid] = c.toJSON(a));
      }
      e = g.materials;
      for (h in e) {
        c = e[h], void 0 === a.materials[c.uuid] && (a.materials[c.uuid] = c.toJSON(a));
      }
      e = g.fonts;
      for (h in e) {
        c = e[h], void 0 === a.fonts[c.uuid] && (a.fonts[c.uuid] = c.toJSON(a));
      }
      e = g.audio;
      for (h in e) {
        c = e[h], void 0 === a.audio[c.uuid] && (a.audio[c.uuid] = c.toJSON(a));
      }
      e = g.resources;
      for (h in e) {
        c = e[h], void 0 === a.resources[c.uuid] && (a.resources[c.uuid] = c.toJSON(a));
      }
    }
  });
  null !== this.defaultScene && (a.object.defaultScene = this.defaultScene);
  a.object.author = this.author;
  a.object.description = this.description;
  a.object.version = this.version;
  a.object.lockPointer = this.lockPointer;
  a.object.handlePixelRatio = this.handlePixelRatio;
  a.object.vr = this.vr;
  a.object.vrScale = this.vrScale;
  a.object.rendererConfig = this.rendererConfig.toJSON();
  return a;
};
"use strict";
function Scene() {
  THREE._Scene.call(this);
  this.name = "scene";
  this.matrixAutoUpdate = !1;
  this.usePhysics = !0;
  this.world = new CANNON.World;
  this.world.defaultContactMaterial.contactEquationStiffness = 1E9;
  this.world.defaultContactMaterial.contactEquationRelaxation = 4;
  this.world.quatNormalizeSkip = 0;
  this.world.quatNormalizeFast = !1;
  this.world.gravity.set(0, -9.8, 0);
  this.world.broadphase = new CANNON.NaiveBroadphase;
  this.world.solver = new CANNON.SplitSolver(new CANNON.GSSolver);
  this.world.solver.tolerance = .05;
  this.world.solver.iterations = 7;
  this.background = new THREE.Color(0);
  this.cameras = [];
  this.defaultCamera = null;
  this.delta = 0;
  this.raycaster = new THREE.Raycaster;
  this.useOctree = !1;
  this.octree = null;
  this.octreeUpdateScheduled = !1;
  this.octreeMatches = [];
  this.canvas = this.program = null;
  this.mouse = new THREE.Vector2(0, 0);
}
THREE._Scene = THREE.Scene;
Scene.prototype = Object.create(THREE._Scene.prototype);
Scene.prototype.initialize = function() {
  this.program = this.parent;
  this.canvas = this.parent.canvas;
  THREE.Object3D.prototype.initialize.call(this);
  for (var a = 0; a < this.children.length; a++) {
    this.children[a].traverse(function(a) {
      a.initialize();
    });
  }
};
Scene.prototype.update = function(a) {
  this.mouse.set(this.program.mouse.position.x / this.canvas.width * 2 - 1, -2 * this.program.mouse.position.y / this.canvas.height + 1);
  0 < this.cameras.length && this.raycaster.setFromCamera(this.mouse, this.cameras[0]);
  this.usePhysics && this.world.step(.05 > a ? a : .05);
  for (var d = 0; d < this.children.length; d++) {
    this.children[d].traverse(function(d) {
      d.update(a);
    });
  }
};
Scene.prototype.resize = function(a, d) {
  null !== this.defaultCamera && this.defaultCamera.resize(a, d);
  for (var g = 0; g < this.cameras.length; g++) {
    this.cameras[g].resize(a, d);
  }
  for (g = 0; g < this.children.length; g++) {
    this.children[g].traverse(function(g) {
      g.resize(a, d);
    });
  }
};
Scene.prototype.dispose = function() {
  for (var a = 0; a < this.children.length; a++) {
    this.children[a].traverse(function(a) {
      a.dispose();
    });
  }
};
Scene.prototype.render = function(a) {
  a.setClearColor(this.background);
  if (0 < this.cameras.length) {
    a.setScissorTest(!0);
    for (var d = 0; d < this.cameras.length; d++) {
      this.cameras[d].setupRenderer(a), this.cameras[d].render(a, this);
    }
    a.setScissorTest(!1);
  } else {
    null !== this.defaultCamera && this.defaultCamera.render(a, this);
  }
};
Scene.prototype.getCamera = function(a, d) {
  void 0 === d && (d = this);
  if (a === d.uuid) {
    return d;
  }
  d = d.children;
  for (var g = 0; g < d.length; g++) {
    var h = this.getCamera(a, d[g]);
    if (null !== h) {
      return h;
    }
  }
  return null;
};
Scene.prototype.addCamera = function(a) {
  -1 === this.cameras.indexOf(a) && (this.cameras.push(a), this.updateCameraOrder());
};
Scene.prototype.updateCameraOrder = function() {
  this.cameras.sort(function(a, d) {
    return a.order > d.order;
  });
};
Scene.prototype.removeCamera = function(a) {
  a = this.cameras.indexOf(a);
  -1 < a && this.cameras.splice(a, 1);
};
Scene.prototype.isCameraActive = function(a) {
  return -1 < this.cameras.indexOf(a);
};
Scene.prototype.setFogMode = function(a) {
  var d = null !== this.fog ? this.fog.color.getHex() : "#FFFFFF";
  a === THREE.Fog.LINEAR ? this.fog = new THREE.Fog(d, 5, 20) : a === THREE.Fog.EXPONENTIAL ? this.fog = new THREE.FogExp2(d, .01) : a === THREE.Fog.NONE && (this.fog = null);
};
Scene.prototype.toJSON = function(a) {
  if (null == this.parent || "Program" !== this.parent.type) {
    return console.warn("nunuStudio: Scene is not on top level serializing as Group."), this.type = "Group", THREE.Object3D.prototype.toJSON.call(this, a);
  }
  var d = this, g = THREE.Object3D.prototype.toJSON.call(this, a, function(a, e) {
    d.background instanceof THREE.Color ? e.background = d.background.toJSON(a) : d.background instanceof THREE.Texture && (e.background = d.background.toJSON(a).uuid);
    d.environment instanceof THREE.Texture && (e.environment = d.environment.toJSON(a).uuid);
  });
  if (null !== this.defaultCamera) {
    var h = new THREE.Vector3, e = new THREE.Quaternion, k = new THREE.Vector3;
    this.defaultCamera.matrixWorld.decompose(h, e, k);
    a = this.defaultCamera.toJSON(a);
    a.object.position = h.toArray();
    a.object.quaternion = e.toArray();
    a.object.scale = k.toArray();
    g.object.defaultCamera = a;
  }
  null !== this.fog && (g.object.fog = this.fog.toJSON());
  g.object.usePhysics = this.usePhysics;
  g.object.cameras = [];
  for (h = 0; h < this.cameras.length; h++) {
    g.object.cameras.push(this.cameras[h].uuid);
  }
  g.object.world = {};
  g.object.world.gravity = this.world.gravity;
  g.object.world.quatNormalizeSkip = this.world.quatNormalizeSkip;
  g.object.world.quatNormalizeFast = this.world.quatNormalizeFast;
  g.object.world.solver = {};
  g.object.world.solver.tolerance = this.world.solver.tolerance;
  g.object.world.solver.iterations = this.world.solver.iterations;
  return g;
};
"use strict";
function Base64Utils() {
}
Base64Utils.encoding = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
Base64Utils.isBase64 = function(a) {
  if ("string" !== typeof a) {
    return !1;
  }
  if (a.startsWith("data:")) {
    return !0;
  }
  for (var d = 0; d < a.length; d++) {
    if (!Base64Utils.encoding.includes(a.charAt(d))) {
      return !1;
    }
  }
  return !0;
};
Base64Utils.removeHeader = function(a) {
  return a.slice(a.search(";base64,") + 8);
};
Base64Utils.getFileFormat = function(a) {
  var d = a.indexOf("/") + 1, g = a.indexOf(";");
  return a.substr(d, g - d);
};
Base64Utils.fromArraybuffer = function(a) {
  var d = "";
  a = new Uint8Array(a);
  for (var g = a.byteLength % 3, h = a.byteLength - g, e, k, c, p, t = 0; t < h; t += 3) {
    p = a[t] << 16 | a[t + 1] << 8 | a[t + 2], e = (p & 16515072) >> 18, k = (p & 258048) >> 12, c = (p & 4032) >> 6, p &= 63, d += Base64Utils.encoding[e] + Base64Utils.encoding[k] + Base64Utils.encoding[c] + Base64Utils.encoding[p];
  }
  1 === g ? (p = a[h], d += Base64Utils.encoding[(p & 252) >> 2] + Base64Utils.encoding[(p & 3) << 4] + "==") : 2 === g && (p = a[h] << 8 | a[h + 1], d += Base64Utils.encoding[(p & 64512) >> 10] + Base64Utils.encoding[(p & 1008) >> 4] + Base64Utils.encoding[(p & 15) << 2] + "=");
  return d;
};
Base64Utils.fromBinaryString = function(a) {
  for (var d = "", g = a.length % 3, h = a.length - g, e, k, c, p = 0; p < h; p += 3) {
    e = a.charCodeAt(p) & 255, k = a.charCodeAt(p + 1), c = a.charCodeAt(p + 2), d += Base64Utils.encoding.charAt(e >> 2), d += Base64Utils.encoding.charAt((e & 3) << 4 | (k & 240) >> 4), d += Base64Utils.encoding.charAt((k & 15) << 2 | (c & 192) >> 6), d += Base64Utils.encoding.charAt(c & 63);
  }
  1 === g ? (e = a.charCodeAt(p) & 255, d += Base64Utils.encoding.charAt(e >> 2), d += Base64Utils.encoding.charAt((e & 3) << 4), d += "==") : 2 === g && (e = a.charCodeAt(p) & 255, k = a.charCodeAt(p + 1), d += Base64Utils.encoding.charAt(e >> 2), d += Base64Utils.encoding.charAt((e & 3) << 4 | (k & 240) >> 4), d += Base64Utils.encoding.charAt((k & 15) << 2), d += "=");
  return d;
};
"use strict";
function ArraybufferUtils() {
}
ArraybufferUtils.fromBinaryString = function(a) {
  for (var d = a.length, g = new ArrayBuffer(d), h = new Uint8Array(g), e = 0; e < d; e++) {
    h[e] = a.charCodeAt(e);
  }
  return g;
};
ArraybufferUtils.fromBase64 = function(a) {
  for (var d = a.length / 4 * 3, g = new ArrayBuffer(d), h = new Uint8Array(g), e, k, c, p, t = 0, f = 0; t < d; t += 3) {
    e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(f++)), k = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(f++)), c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(f++)), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(f++)), h[t] = e << 2 | k >> 4, 64 !== c && (h[t + 1] = (k & 15) << 4 | c >> 2), 64 !== p && (h[t + 2] = (c & 3) << 6 | p);
  }
  return g;
};
ArraybufferUtils.fromBuffer = function(a) {
  for (var d = new ArrayBuffer(a.length), g = new Uint8Array(d), h = 0; h < a.length; h++) {
    g[h] = a[h];
  }
  return d;
};
"use strict";
function BufferUtils() {
}
BufferUtils.fromArrayBuffer = function(a) {
  var d = new Buffer(a.byteLength);
  a = new Uint8Array(a);
  for (var g = 0; g < d.length; g++) {
    d[g] = a[g];
  }
  return d;
};
"use strict";
function Timer(a, d) {
  this.callback = a;
  this.time = d;
  this.running = !1;
  this.id = -1;
}
Timer.prototype.start = function() {
  function a() {
    d.callback();
    d.running && (d.id = setTimeout(a, d.time));
  }
  if (!this.running) {
    this.running = !0;
    var d = this;
    a();
  }
};
Timer.prototype.stop = function() {
  this.running = !1;
  clearTimeout(self.id);
};
"use strict";
function AnimationTimer(a) {
  this.callback = a;
  this.running = !1;
  this.id = -1;
}
AnimationTimer.prototype.start = function() {
  function a() {
    d.callback();
    d.running && (d.id = requestAnimationFrame(a));
  }
  if (!this.running) {
    this.running = !0;
    var d = this;
    a();
  }
};
AnimationTimer.prototype.stop = function() {
  this.running = !1;
  cancelAnimationFrame(this.id);
};
"use strict";
function LocalStorage() {
}
LocalStorage.set = function(a, d) {
  "object" === typeof d ? window.localStorage.setItem(a, JSON.stringify(d)) : window.localStorage.setItem(a, d);
};
LocalStorage.get = function(a) {
  a = window.localStorage.getItem(a);
  try {
    return JSON.parse(a);
  } catch (d) {
    return a;
  }
};
LocalStorage.exists = function(a) {
  return null !== window.localStorage.getItem(a);
};
LocalStorage.delete = function(a) {
  return window.localStorage.removeItem(a);
};
"use strict";
function EventManager() {
  this.events = [];
}
EventManager.prototype.add = function(a, d, g) {
  this.events.push([a, d, g, !1]);
};
EventManager.prototype.clear = function() {
  this.destroy();
  this.events = [];
};
EventManager.prototype.create = function() {
  for (var a = 0; a < this.events.length; a++) {
    var d = this.events[a];
    d[0].addEventListener(d[1], d[2]);
    d[3] = !0;
  }
};
EventManager.prototype.destroy = function() {
  for (var a = 0; a < this.events.length; a++) {
    var d = this.events[a];
    d[0].removeEventListener(d[1], d[2]);
    d[3] = !1;
  }
};
EventManager.prototype.addScrollEvent = function(a, d) {
  void 0 !== window.onmousewheel ? this.add(a, "mousewheel", d) : void 0 !== window.addEventListener ? this.add(a, "DOMMouseScroll", function(a) {
    a.deltaY = 30 * a.detail;
    d(a);
  }) : this.add(a, "wheel", d);
};
"use strict";
function MathUtils() {
}
MathUtils.PI2 = 2 * Math.PI;
MathUtils.PID3 = Math.PI / 3;
MathUtils.PID2 = Math.PI / 2;
MathUtils.randomColor = function() {
  for (var a = "#", d = 0; 6 > d; d++) {
    a += "0123456789ABCDEF"[Math.floor(16 * Math.random())];
  }
  return a;
};
"use strict";
function ObjectUtils() {
}
ObjectUtils.getRoot = function(a) {
  for (; null !== a.parent;) {
    a = a.parent;
  }
  return a;
};
ObjectUtils.scaleAndCenterObject = function(a) {
  var d = ObjectUtils.calculateBoundingBox(a);
  if (null !== d) {
    var g = new THREE.Vector3;
    d.getSize(g);
    g = 1 / (g.x > g.y ? g.x > g.z ? g.x : g.z : g.y > g.z ? g.y : g.z);
    var h = new THREE.Vector3;
    d.getCenter(h);
    h.multiplyScalar(g);
    a.scale.set(g, g, g);
    a.position.set(-h.x, -g * d.min.y, -h.z);
  }
};
ObjectUtils.calculateBoundingBox = function(a) {
  var d = null;
  a.traverse(function(a) {
    void 0 !== a.geometry && (a.geometry.computeBoundingBox(), a = a.geometry.boundingBox, null === d ? d = a.clone() : (a.min.x < d.min.x && (d.min.x = a.min.x), a.max.x > d.max.x && (d.max.x = a.max.x), a.min.y < d.min.y && (d.min.y = a.min.y), a.max.y > d.max.y && (d.max.y = a.max.y), a.min.z < d.min.z && (d.min.z = a.min.z), a.max.z > d.max.z && (d.max.z = a.max.z)));
  });
  return d;
};
ObjectUtils.centerGeometryOrigin = function(a) {
  a.traverse(function(a) {
    if (void 0 !== a.geometry) {
      a.geometry.computeBoundingBox();
      var d = a.geometry.boundingBox.clone().getCenter(new THREE.Vector3), h = new THREE.Matrix4;
      h.makeTranslation(-d.x, -d.y, -d.z);
      a.geometry.applyMatrix4(h);
      a.position.add(d);
    }
  });
};
ObjectUtils.convertToBufferGeometry = function(a) {
  a.traverse(function(a) {
    void 0 !== a.geometry && !0 === a.geometry.isGeometry && (a.geometry = (new THREE.BufferGeometry).fromGeometry(a.geometry));
  });
};
"use strict";
function PhysicsGenerator() {
}
PhysicsGenerator.Type = {BOX:"Box", CYLINDER:"Cylinder", SPHERE:"Sphere", HULL:"ConvexPolyhedron"};
PhysicsGenerator.createShape = function(a, d) {
  if (void 0 !== d) {
    return d === PhysicsGenerator.Type.BOX ? PhysicsGenerator.createBoundingBoxShape(a) : d === PhysicsGenerator.Type.CYLINDER ? PhysicsGenerator.createBoundingCylinderShape(a) : d === PhysicsGenerator.Type.SPHERE ? PhysicsGenerator.createBoundingSphereShape(a) : d === PhysicsGenerator.Type.HULL ? PhysicsGenerator.createConvexPolyhedron(a) : null;
  }
  d = PhysicsGenerator.getGeometry(a);
  if (!d) {
    return null;
  }
  switch(d.type) {
    case "BoxGeometry":
    case "BoxBufferGeometry":
      return PhysicsGenerator.createBoxShape(d);
    case "CylinderGeometry":
    case "CylinderBufferGeometry":
      return PhysicsGenerator.createCylinderShape(d);
    case "PlaneGeometry":
    case "PlaneBufferGeometry":
      return PhysicsGenerator.createPlaneShape(d);
    case "SphereGeometry":
    case "SphereBufferGeometry":
      return PhysicsGenerator.createSphereShape(d);
    case "TubeGeometry":
      return PhysicsGenerator.createTubeShape(d);
    case "Geometry":
    case "BufferGeometry":
      return PhysicsGenerator.createConvexPolyhedron(a);
    default:
      return PhysicsGenerator.createBoxShape(d);
  }
};
PhysicsGenerator.createBoxShape = function(a) {
  if (!PhysicsGenerator.getVertices(a).length) {
    return null;
  }
  a.computeBoundingBox();
  a = a.boundingBox;
  return new CANNON.Box(new CANNON.Vec3((a.max.x - a.min.x) / 2, (a.max.y - a.min.y) / 2, (a.max.z - a.min.z) / 2));
};
PhysicsGenerator.createBoundingBoxShape = function(a) {
  var d = new Box3;
  d.setFromObject(a);
  if (!isFinite(d.min.lengthSq())) {
    return null;
  }
  d = new CANNON.Box(new CANNON.Vec3((d.max.x - d.min.x) / 2, (d.max.y - d.min.y) / 2, (d.max.z - d.min.z) / 2));
  a.updateMatrixWorld();
  (new THREE.Vector3).setFromMatrixPosition(a.matrixWorld);
  return d;
};
PhysicsGenerator.createConvexPolyhedron = function(a) {
  var d = new THREE.QuickHull;
  d.setFromObject(a);
  a = [];
  for (var g = [], h = [], e = 0; e < d.faces.length; e++) {
    var k = d.faces[e], c = k.edge;
    do {
      var p = c.head().point;
      a.push(new CANNON.Vec3(p.x, p.y, p.z));
      c = c.next;
    } while (c !== k.edge);
    g.push([a.length - 3, a.length - 2, a.length - 1]);
    h.push(new CANNON.Vec3(k.normal.x, k.normal.y, k.normal.z));
  }
  return new CANNON.ConvexPolyhedron(a, g, h);
};
PhysicsGenerator.createCylinderShape = function(a) {
  a = a.parameters;
  a = new CANNON.Cylinder(a.radiusTop, a.radiusBottom, a.height, a.radialSegments);
  a.orientation = new CANNON.Quaternion;
  a.orientation.setFromEuler(0, 0, 0, "XYZ").normalize();
  return a;
};
PhysicsGenerator.createBoundingCylinderShape = function(a) {
  var d = ["x", "y", "z"];
  d = d.splice(d.indexOf("y"), 1) && d;
  a = PhysicsGenerator.getGeometry(a);
  a.computeBoundingBox();
  a.computeBoundingSphere();
  d = .5 * Math.max(a.boundingBox.max[d[0]] - a.boundingBox.min[d[0]], a.boundingBox.max[d[1]] - a.boundingBox.min[d[1]]);
  a = new CANNON.Cylinder(d, d, a.boundingBox.max.y - a.boundingBox.min.y, 12);
  a.orientation = new CANNON.Quaternion;
  a.orientation.setFromEuler(Math.PI / 2, 0, 0, "XYZ").normalize();
  return a;
};
PhysicsGenerator.createPlaneShape = function(a) {
  a.computeBoundingBox();
  a = a.boundingBox;
  return new CANNON.Box(new CANNON.Vec3((a.max.x - a.min.x) / 2, (a.max.y - a.min.y) / 2, (a.max.z - a.min.z) / 2));
};
PhysicsGenerator.createSphereShape = function(a) {
  return new CANNON.Sphere(a.parameters.radius);
};
PhysicsGenerator.createBoundingSphereShape = function(a) {
  a = PhysicsGenerator.getGeometry(a);
  a.computeBoundingSphere();
  return new CANNON.Sphere(a.boundingSphere.radius);
};
PhysicsGenerator.createTubeShape = function(a) {
  var d = new THREE.BufferGeometry;
  d.fromGeometry(a);
  return createTrimeshShape(d);
};
PhysicsGenerator.createTrimeshShape = function(a) {
  var d = PhysicsGenerator.getVertices(a);
  if (!d.length) {
    return null;
  }
  a = Object.keys(d).map(Number);
  return new CANNON.Trimesh(d, a);
};
PhysicsGenerator.getGeometry = function(a) {
  var d = PhysicsGenerator.getMeshes(a);
  if (0 === d.length) {
    return null;
  }
  var g = new THREE.Geometry;
  if (1 === d.length) {
    a = new THREE.Vector3;
    var h = new THREE.Quaternion, e = new THREE.Vector3(1, 1, 1);
    g = d[0].geometry.clone();
    d[0].updateMatrixWorld();
    d[0].matrixWorld.decompose(a, h, e);
    return g.scale(e.x, e.y, e.z);
  }
  for (h = new THREE.Geometry; e = d.pop();) {
    e.updateMatrixWorld(), e.geometry instanceof THREE.BufferGeometry ? (g.fromBufferGeometry(e.geometry), h.merge(g, e.matrixWorld)) : h.merge(e.geometry, e.matrixWorld);
  }
  d = new THREE.Matrix4;
  d.scale(a.scale);
  h.applyMatrix4(d);
  return h;
};
PhysicsGenerator.getVertices = function(a) {
  a.attributes || (a = (new THREE.BufferGeometry).fromGeometry(a));
  return a.attributes.position.array;
};
PhysicsGenerator.getMeshes = function(a) {
  var d = [];
  a.traverse(function(a) {
    a instanceof THREE.Mesh && d.push(a);
  });
  return d;
};
"use strict";
function UnitConverter() {
}
UnitConverter.scales = new Map([["Y", 1E24], ["Z", 1E21], ["E", 1E18], ["P", 1E15], ["T", 1E12], ["G", 1E9], ["M", 1E6], ["k", 1E3], ["m", .001], ["u", 1E-6], ["n", 1E-9], ["p", 1E-12], ["f", 1E-15], ["a", 1E-18], ["z", 1E-21], ["y", 1E-24]]);
UnitConverter.units = new Map([["m", new Map([["i", function(a) {
  return a / 39.3701;
}]])], ["i", new Map([["m", function(a) {
  return 39.3701 * a;
}]])], ["g", null], ["s", null], ["c", new Map([["k", function(a) {
  return a - 273.15;
}], ["f", function(a) {
  return (a - 32) / 1.8;
}]])], ["k", new Map([["c", function(a) {
  return a + 273.15;
}], ["f", function(a) {
  return (a - 32) / 1.8 + 273.15;
}]])], ["f", new Map([["c", function(a) {
  return 1.8 * a + 32;
}], ["k", function(a) {
  return 1.8 * a - 459.67;
}]])], ["d", new Map([["r", function(a) {
  return 180 / Math.PI * a;
}]])], ["r", new Map([["d", function(a) {
  return a / (180 / Math.PI);
}]])]]);
UnitConverter.convert = function(a, d, g) {
  1 < d.length && (a *= UnitConverter.scales.get(d.charAt(0)), d = d.slice(1));
  var h = 1;
  1 < g.length && (h = UnitConverter.scales.get(g.charAt(0)), g = g.slice(1));
  return d === g ? a / h : UnitConverter.units.get(g).get(d)(a) / h;
};

