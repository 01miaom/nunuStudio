/*


 opentype.js:
   license: MIT (http://opensource.org/licenses/MIT)
   author: Frederik De Bleser <frederik@debleser.be>
   version: 0.6.5

 tiny-inflate:
   license: MIT (http://opensource.org/licenses/MIT)
   author: Devon Govett <devongovett@gmail.com>
   maintainers: devongovett <devongovett@gmail.com>
   homepage: https://github.com/devongovett/tiny-inflate
   version: 1.0.2

 This header is generated by licensify (https://github.com/twada/licensify)
 Determine if an object is a Buffer

 @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 @license  MIT
 LeapJS v0.6.4                                                  
 http://github.com/leapmotion/leapjs/                                        

 Copyright 2013 LeapMotion, Inc. and other contributors                      
 Released under the Apache-2.0 license                                     
 http://github.com/leapmotion/leapjs/blob/master/LICENSE.txt                 
*/
var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.checkStringArgs = function(a, c, g) {
  if (null == a) {
    throw new TypeError("The 'this' value for String.prototype." + g + " must not be null or undefined");
  }
  if (c instanceof RegExp) {
    throw new TypeError("First argument to String.prototype." + g + " must not be a regular expression");
  }
  return a + "";
};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, c, g) {
  a != Array.prototype && a != Object.prototype && (a[c] = g.value);
};
$jscomp.getGlobal = function(a) {
  return "undefined" != typeof window && window === a ? a : "undefined" != typeof global && null != global ? global : a;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function(a, c, g, b) {
  if (c) {
    g = $jscomp.global;
    a = a.split(".");
    for (b = 0; b < a.length - 1; b++) {
      var e = a[b];
      e in g || (g[e] = {});
      g = g[e];
    }
    a = a[a.length - 1];
    b = g[a];
    c = c(b);
    c != b && null != c && $jscomp.defineProperty(g, a, {configurable:!0, writable:!0, value:c});
  }
};
$jscomp.polyfill("String.prototype.endsWith", function(a) {
  return a ? a : function(a, g) {
    var b = $jscomp.checkStringArgs(this, a, "endsWith");
    a += "";
    void 0 === g && (g = b.length);
    g = Math.max(0, Math.min(g | 0, b.length));
    for (var c = a.length; 0 < c && 0 < g;) {
      if (b[--g] != a[--c]) {
        return !1;
      }
    }
    return 0 >= c;
  };
}, "es6", "es3");
$jscomp.checkEs6ConformanceViaProxy = function() {
  try {
    var a = {}, c = Object.create(new $jscomp.global.Proxy(a, {get:function(g, b, e) {
      return g == a && "q" == b && e == c;
    }}));
    return !0 === c.q;
  } catch (g) {
    return !1;
  }
};
$jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS = !1;
$jscomp.ES6_CONFORMANCE = $jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS && $jscomp.checkEs6ConformanceViaProxy();
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
};
$jscomp.Symbol = function() {
  var a = 0;
  return function(c) {
    return $jscomp.SYMBOL_PREFIX + (c || "") + a++;
  };
}();
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var a = $jscomp.global.Symbol.iterator;
  a || (a = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
  "function" != typeof Array.prototype[a] && $jscomp.defineProperty(Array.prototype, a, {configurable:!0, writable:!0, value:function() {
    return $jscomp.arrayIterator(this);
  }});
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.initSymbolAsyncIterator = function() {
  $jscomp.initSymbol();
  var a = $jscomp.global.Symbol.asyncIterator;
  a || (a = $jscomp.global.Symbol.asyncIterator = $jscomp.global.Symbol("asyncIterator"));
  $jscomp.initSymbolAsyncIterator = function() {
  };
};
$jscomp.arrayIterator = function(a) {
  var c = 0;
  return $jscomp.iteratorPrototype(function() {
    return c < a.length ? {done:!1, value:a[c++]} : {done:!0};
  });
};
$jscomp.iteratorPrototype = function(a) {
  $jscomp.initSymbolIterator();
  a = {next:a};
  a[$jscomp.global.Symbol.iterator] = function() {
    return this;
  };
  return a;
};
$jscomp.makeIterator = function(a) {
  $jscomp.initSymbolIterator();
  var c = a[Symbol.iterator];
  return c ? c.call(a) : $jscomp.arrayIterator(a);
};
$jscomp.owns = function(a, c) {
  return Object.prototype.hasOwnProperty.call(a, c);
};
$jscomp.polyfill("WeakMap", function(a) {
  function c() {
    if (!a || !Object.seal) {
      return !1;
    }
    try {
      var b = Object.seal({}), f = Object.seal({}), c = new a([[b, 2], [f, 3]]);
      if (2 != c.get(b) || 3 != c.get(f)) {
        return !1;
      }
      c.delete(b);
      c.set(f, 4);
      return !c.has(b) && 4 == c.get(f);
    } catch (t) {
      return !1;
    }
  }
  function g(a) {
    $jscomp.owns(a, e) || $jscomp.defineProperty(a, e, {value:{}});
  }
  function b(a) {
    var b = Object[a];
    b && (Object[a] = function(a) {
      g(a);
      return b(a);
    });
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (a && $jscomp.ES6_CONFORMANCE) {
      return a;
    }
  } else {
    if (c()) {
      return a;
    }
  }
  var e = "$jscomp_hidden_" + Math.random();
  b("freeze");
  b("preventExtensions");
  b("seal");
  var f = 0, k = function(a) {
    this.id_ = (f += Math.random() + 1).toString();
    if (a) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      a = $jscomp.makeIterator(a);
      for (var b; !(b = a.next()).done;) {
        b = b.value, this.set(b[0], b[1]);
      }
    }
  };
  k.prototype.set = function(a, b) {
    g(a);
    if (!$jscomp.owns(a, e)) {
      throw Error("WeakMap key fail: " + a);
    }
    a[e][this.id_] = b;
    return this;
  };
  k.prototype.get = function(a) {
    return $jscomp.owns(a, e) ? a[e][this.id_] : void 0;
  };
  k.prototype.has = function(a) {
    return $jscomp.owns(a, e) && $jscomp.owns(a[e], this.id_);
  };
  k.prototype.delete = function(a) {
    return $jscomp.owns(a, e) && $jscomp.owns(a[e], this.id_) ? delete a[e][this.id_] : !1;
  };
  return k;
}, "es6", "es3");
$jscomp.polyfill("String.prototype.startsWith", function(a) {
  return a ? a : function(a, g) {
    var b = $jscomp.checkStringArgs(this, a, "startsWith");
    a += "";
    var c = b.length, f = a.length;
    g = Math.max(0, Math.min(g | 0, b.length));
    for (var k = 0; k < f && g < c;) {
      if (b[g++] != a[k++]) {
        return !1;
      }
    }
    return k >= f;
  };
}, "es6", "es3");
$jscomp.polyfill("Number.EPSILON", function(a) {
  return Math.pow(2, -52);
}, "es6", "es3");
$jscomp.polyfill("Math.sign", function(a) {
  return a ? a : function(a) {
    a = Number(a);
    return 0 === a || isNaN(a) ? a : 0 < a ? 1 : -1;
  };
}, "es6", "es3");
$jscomp.iteratorFromArray = function(a, c) {
  $jscomp.initSymbolIterator();
  a instanceof String && (a += "");
  var g = 0, b = {next:function() {
    if (g < a.length) {
      var e = g++;
      return {value:c(e, a[e]), done:!1};
    }
    b.next = function() {
      return {done:!0, value:void 0};
    };
    return b.next();
  }};
  b[Symbol.iterator] = function() {
    return b;
  };
  return b;
};
$jscomp.polyfill("Array.prototype.keys", function(a) {
  return a ? a : function() {
    return $jscomp.iteratorFromArray(this, function(a) {
      return a;
    });
  };
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.values", function(a) {
  return a ? a : function() {
    return $jscomp.iteratorFromArray(this, function(a, g) {
      return g;
    });
  };
}, "es8", "es3");
$jscomp.assign = "function" == typeof Object.assign ? Object.assign : function(a, c) {
  for (var g = 1; g < arguments.length; g++) {
    var b = arguments[g];
    if (b) {
      for (var e in b) {
        $jscomp.owns(b, e) && (a[e] = b[e]);
      }
    }
  }
  return a;
};
$jscomp.polyfill("Object.assign", function(a) {
  return a || $jscomp.assign;
}, "es6", "es3");
$jscomp.polyfill("String.prototype.repeat", function(a) {
  return a ? a : function(a) {
    var c = $jscomp.checkStringArgs(this, null, "repeat");
    if (0 > a || 1342177279 < a) {
      throw new RangeError("Invalid count value");
    }
    a |= 0;
    for (var b = ""; a;) {
      if (a & 1 && (b += c), a >>>= 1) {
        c += c;
      }
    }
    return b;
  };
}, "es6", "es3");
$jscomp.polyfill("Number.isFinite", function(a) {
  return a ? a : function(a) {
    return "number" !== typeof a ? !1 : !isNaN(a) && Infinity !== a && -Infinity !== a;
  };
}, "es6", "es3");
$jscomp.polyfill("Number.isInteger", function(a) {
  return a ? a : function(a) {
    return Number.isFinite(a) ? a === Math.floor(a) : !1;
  };
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.fill", function(a) {
  return a ? a : function(a, g, b) {
    var c = this.length || 0;
    0 > g && (g = Math.max(0, c + g));
    if (null == b || b > c) {
      b = c;
    }
    b = Number(b);
    0 > b && (b = Math.max(0, c + b));
    for (g = Number(g || 0); g < b; g++) {
      this[g] = a;
    }
    return this;
  };
}, "es6", "es3");
$jscomp.FORCE_POLYFILL_PROMISE = !1;
$jscomp.polyfill("Promise", function(a) {
  function c() {
    this.batch_ = null;
  }
  function g(a) {
    return a instanceof e ? a : new e(function(b, f) {
      b(a);
    });
  }
  if (a && !$jscomp.FORCE_POLYFILL_PROMISE) {
    return a;
  }
  c.prototype.asyncExecute = function(a) {
    null == this.batch_ && (this.batch_ = [], this.asyncExecuteBatch_());
    this.batch_.push(a);
    return this;
  };
  c.prototype.asyncExecuteBatch_ = function() {
    var a = this;
    this.asyncExecuteFunction(function() {
      a.executeBatch_();
    });
  };
  var b = $jscomp.global.setTimeout;
  c.prototype.asyncExecuteFunction = function(a) {
    b(a, 0);
  };
  c.prototype.executeBatch_ = function() {
    for (; this.batch_ && this.batch_.length;) {
      var a = this.batch_;
      this.batch_ = [];
      for (var b = 0; b < a.length; ++b) {
        var f = a[b];
        a[b] = null;
        try {
          f();
        } catch (m) {
          this.asyncThrow_(m);
        }
      }
    }
    this.batch_ = null;
  };
  c.prototype.asyncThrow_ = function(a) {
    this.asyncExecuteFunction(function() {
      throw a;
    });
  };
  var e = function(a) {
    this.state_ = 0;
    this.result_ = void 0;
    this.onSettledCallbacks_ = [];
    var b = this.createResolveAndReject_();
    try {
      a(b.resolve, b.reject);
    } catch (p) {
      b.reject(p);
    }
  };
  e.prototype.createResolveAndReject_ = function() {
    function a(a) {
      return function(c) {
        f || (f = !0, a.call(b, c));
      };
    }
    var b = this, f = !1;
    return {resolve:a(this.resolveTo_), reject:a(this.reject_)};
  };
  e.prototype.resolveTo_ = function(a) {
    if (a === this) {
      this.reject_(new TypeError("A Promise cannot resolve to itself"));
    } else {
      if (a instanceof e) {
        this.settleSameAsPromise_(a);
      } else {
        a: {
          switch(typeof a) {
            case "object":
              var b = null != a;
              break a;
            case "function":
              b = !0;
              break a;
            default:
              b = !1;
          }
        }
        b ? this.resolveToNonPromiseObj_(a) : this.fulfill_(a);
      }
    }
  };
  e.prototype.resolveToNonPromiseObj_ = function(a) {
    var b = void 0;
    try {
      b = a.then;
    } catch (p) {
      this.reject_(p);
      return;
    }
    "function" == typeof b ? this.settleSameAsThenable_(b, a) : this.fulfill_(a);
  };
  e.prototype.reject_ = function(a) {
    this.settle_(2, a);
  };
  e.prototype.fulfill_ = function(a) {
    this.settle_(1, a);
  };
  e.prototype.settle_ = function(a, b) {
    if (0 != this.state_) {
      throw Error("Cannot settle(" + a + ", " + b + "): Promise already settled in state" + this.state_);
    }
    this.state_ = a;
    this.result_ = b;
    this.executeOnSettledCallbacks_();
  };
  e.prototype.executeOnSettledCallbacks_ = function() {
    if (null != this.onSettledCallbacks_) {
      for (var a = 0; a < this.onSettledCallbacks_.length; ++a) {
        f.asyncExecute(this.onSettledCallbacks_[a]);
      }
      this.onSettledCallbacks_ = null;
    }
  };
  var f = new c;
  e.prototype.settleSameAsPromise_ = function(a) {
    var b = this.createResolveAndReject_();
    a.callWhenSettled_(b.resolve, b.reject);
  };
  e.prototype.settleSameAsThenable_ = function(a, b) {
    var f = this.createResolveAndReject_();
    try {
      a.call(b, f.resolve, f.reject);
    } catch (m) {
      f.reject(m);
    }
  };
  e.prototype.then = function(a, b) {
    function f(a, b) {
      return "function" == typeof a ? function(b) {
        try {
          c(a(b));
        } catch (y) {
          k(y);
        }
      } : b;
    }
    var c, k, d = new e(function(a, b) {
      c = a;
      k = b;
    });
    this.callWhenSettled_(f(a, c), f(b, k));
    return d;
  };
  e.prototype.catch = function(a) {
    return this.then(void 0, a);
  };
  e.prototype.callWhenSettled_ = function(a, b) {
    function c() {
      switch(e.state_) {
        case 1:
          a(e.result_);
          break;
        case 2:
          b(e.result_);
          break;
        default:
          throw Error("Unexpected state: " + e.state_);
      }
    }
    var e = this;
    null == this.onSettledCallbacks_ ? f.asyncExecute(c) : this.onSettledCallbacks_.push(c);
  };
  e.resolve = g;
  e.reject = function(a) {
    return new e(function(b, f) {
      f(a);
    });
  };
  e.race = function(a) {
    return new e(function(b, f) {
      for (var c = $jscomp.makeIterator(a), e = c.next(); !e.done; e = c.next()) {
        g(e.value).callWhenSettled_(b, f);
      }
    });
  };
  e.all = function(a) {
    var b = $jscomp.makeIterator(a), f = b.next();
    return f.done ? g([]) : new e(function(a, c) {
      function d(b) {
        return function(d) {
          e[b] = d;
          k--;
          0 == k && a(e);
        };
      }
      var e = [], k = 0;
      do {
        e.push(void 0), k++, g(f.value).callWhenSettled_(d(e.length - 1), c), f = b.next();
      } while (!f.done);
    });
  };
  return e;
}, "es6", "es3");
$jscomp.polyfill("Object.is", function(a) {
  return a ? a : function(a, g) {
    return a === g ? 0 !== a || 1 / a === 1 / g : a !== a && g !== g;
  };
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.includes", function(a) {
  return a ? a : function(a, g) {
    var b = this;
    b instanceof String && (b = String(b));
    var c = b.length;
    g = g || 0;
    for (0 > g && (g = Math.max(g + c, 0)); g < c; g++) {
      var f = b[g];
      if (f === a || Object.is(f, a)) {
        return !0;
      }
    }
    return !1;
  };
}, "es7", "es3");
$jscomp.polyfill("String.prototype.includes", function(a) {
  return a ? a : function(a, g) {
    return -1 !== $jscomp.checkStringArgs(this, a, "includes").indexOf(a, g || 0);
  };
}, "es6", "es3");
function NunuApp(a) {
  this.renderer = this.program = null;
  this.canvasFitWindow = this.running = !1;
  this.canvas = a;
  this.events = new EventManager;
  void 0 === a && (this.canvas = document.createElement("canvas"), this.canvas.style.position = "absolute", this.canvas.style.left = "0px", this.canvas.style.top = "0px", this.canvasFitWindow = !0, document.body.appendChild(this.canvas));
}
NunuApp.loadApp = function(a, c) {
  "string" === typeof c && (c = document.getElementById(c));
  var g = new NunuApp(c);
  g.loadRunProgram(a);
  window.addEventListener("resize", function() {
    Nunu.isFullscreen() ? (g.canvas.width = window.innerWidth, g.canvas.height = window.innerHeight) : (g.canvas.width = nunuApps[i].canvas.parentElement.offsetWidth, g.canvas.height = nunuApps[i].canvas.parentElement.offsetWidth);
    g.resize();
  });
};
NunuApp.prototype.run = function() {
  if (null === this.program) {
    console.warn("nunuStudio: no program is loaded [app.loadPogram(fname)]");
  } else {
    this.renderer = new THREE.WebGLRenderer({canvas:this.canvas, alpha:!0, antialias:this.program.antialiasing});
    this.renderer.shadowMap.enabled = this.program.shadows;
    this.renderer.shadowMap.type = this.program.shadowsType;
    this.renderer.toneMapping = this.program.toneMapping;
    this.renderer.toneMappingExposure = this.program.toneMappingExposure;
    this.renderer.toneMappingWhitePoint = this.program.toneMappingWhitePoint;
    this.keyboard = new Keyboard;
    this.mouse = new Mouse;
    this.mouse.setCanvas(this.canvas);
    this.program.app = this;
    this.program.defaultCamera = new PerspectiveCamera(60, 1, .1, 1E5);
    this.program.defaultCamera.position.set(0, 5, -5);
    this.program.setRenderer(this.renderer);
    this.program.setMouseKeyboard(this.mouse, this.keyboard);
    this.program.initialize();
    if (this.program.lockPointer) {
      var a = this.canvas;
      a.requestPointerLock = a.requestPointerLock || a.mozRequestPointerLock || a.webkitRequestPointerLock;
      this.events.add(a, "click", function() {
        a.requestPointerLock && a.requestPointerLock();
      });
    }
    var c = this;
    this.events.add(window, "beforeunload", function() {
      c.exit();
    });
    this.events.create();
    this.resize();
    this.resume();
  }
};
NunuApp.prototype.loadRunProgram = function(a, c, g) {
  this.loadProgramAsync(a, function(a) {
    a.run();
    void 0 !== c && c(a);
  }, g);
};
NunuApp.prototype.loadProgram = function(a) {
  if (a.endsWith(".isp")) {
    var c = new ObjectLoader;
    a = FileSystem.readFile(a);
    this.program = c.parse(JSON.parse(a));
  } else {
    if (a.endsWith(".nsp")) {
      c = new ObjectLoader;
      a = FileSystem.readFileArrayBuffer(a);
      var g = new dcodeIO.PSON.StaticPair;
      this.program = c.parse(g.decode(a));
    }
  }
};
NunuApp.prototype.loadProgramAsync = function(a, c, g) {
  var b = this;
  a.endsWith(".isp") ? FileSystem.readFile(a, !1, function(a) {
    var f = new ObjectLoader;
    b.program = f.parse(JSON.parse(a));
    void 0 !== c && c(b);
  }, g) : a.endsWith(".nsp") && FileSystem.readFileArrayBuffer(a, !1, function(a) {
    var f = new ObjectLoader, e = new dcodeIO.PSON.StaticPair;
    b.program = f.parse(e.decode(a));
    void 0 !== c && c(b);
  }, g);
};
NunuApp.prototype.update = function() {
  this.mouse.update();
  this.keyboard.update();
  this.program.update();
  this.program.render(this.renderer);
};
NunuApp.prototype.exit = function() {
  this.events.destroy();
  null !== this.program && (this.program.dispose(), this.program = null);
  null !== this.renderer && (this.renderer.dispose(), this.renderer = null);
  null !== this.mouse && (this.mouse.dispose(), this.mouse = null);
  null !== this.keyboard && (this.keyboard.dispose(), this.keyboard = null);
  if (void 0 !== this.onExit) {
    this.onExit();
  }
};
NunuApp.prototype.resume = function() {
  if (null !== this.program && !this.running) {
    var a = this, c = function() {
      a.running && (a.update(), a.program.useVR ? a.program.display.requestAnimationFrame(c) : requestAnimationFrame(c));
    };
    this.running = !0;
    c();
  }
};
NunuApp.prototype.pause = function() {
  this.running = !1;
};
NunuApp.prototype.setCanvas = function(a) {
  this.canvas = a;
  this.canvasFitWindow = !1;
};
NunuApp.prototype.resize = function() {
  if (null !== this.canvas && null !== this.program && null !== this.renderer) {
    if (this.canvasFitWindow) {
      this.canvas.style.width = window.innerWidth + "px";
      this.canvas.style.height = window.innerHeight + "px";
      var a = window.innerWidth;
      var c = window.innerHeight;
    } else {
      a = this.canvas.offsetWidth, c = this.canvas.offsetHeight;
    }
    this.program.handlePixelRatio && (a *= window.devicePixelRatio, c *= window.devicePixelRatio);
    this.renderer.setSize(a, c, !1);
    this.program.resize(a, c);
  }
};
NunuApp.prototype.sendData = function(a) {
  null !== this.program && this.program.receiveDataApp(a);
};
NunuApp.prototype.setOnDataReceived = function(a) {
  this.onDataReceived = a;
};
NunuApp.prototype.setOnExit = function(a) {
  this.onExit = a;
};
NunuApp.prototype.vrAvailable = function() {
  return null !== this.program && this.program.vr && Nunu.webvrAvailable();
};
NunuApp.prototype.toggleVR = function() {
  this.vrAvailable() ? this.program.useVR ? this.program.exitVR() : this.program.displayVR() : console.warn("nunuStudio: loaded program is not VR enabled");
};
NunuApp.prototype.toggleFullscreen = function(a) {
  var c = Nunu.isFullscreen();
  void 0 === a && (a = this.canvas);
  Nunu.setFullscreen(!c, a);
};
(function(a, c) {
  "object" === typeof exports && "undefined" !== typeof module ? c(exports) : "function" === typeof define && define.amd ? define(["exports"], c) : (a = a || self, c(a.THREE = {}));
})(this, function(a) {
  function c() {
  }
  function g(h, a) {
    this.x = h || 0;
    this.y = a || 0;
  }
  function b() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }
  function e(h, a, b, d) {
    this._x = h || 0;
    this._y = a || 0;
    this._z = b || 0;
    this._w = void 0 !== d ? d : 1;
  }
  function f(h, a, b) {
    this.x = h || 0;
    this.y = a || 0;
    this.z = b || 0;
  }
  function k() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }
  function n(h, a, b, d, f, c, e, l, q, m) {
    Object.defineProperty(this, "id", {value:Xf++});
    this.uuid = ia.generateUUID();
    this.name = "";
    this.image = void 0 !== h ? h : n.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = void 0 !== a ? a : n.DEFAULT_MAPPING;
    this.wrapS = void 0 !== b ? b : 1001;
    this.wrapT = void 0 !== d ? d : 1001;
    this.magFilter = void 0 !== f ? f : 1006;
    this.minFilter = void 0 !== c ? c : 1008;
    this.anisotropy = void 0 !== q ? q : 1;
    this.format = void 0 !== e ? e : 1023;
    this.type = void 0 !== l ? l : 1009;
    this.offset = new g(0, 0);
    this.repeat = new g(1, 1);
    this.center = new g(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = !0;
    this.matrix = new k;
    this.generateMipmaps = !0;
    this.premultiplyAlpha = !1;
    this.flipY = !0;
    this.unpackAlignment = 4;
    this.encoding = void 0 !== m ? m : 3E3;
    this.version = 0;
    this.onUpdate = null;
  }
  function p(h, a, b, d) {
    this.x = h || 0;
    this.y = a || 0;
    this.z = b || 0;
    this.w = void 0 !== d ? d : 1;
  }
  function m(h, a, b) {
    this.width = h;
    this.height = a;
    this.scissor = new p(0, 0, h, a);
    this.scissorTest = !1;
    this.viewport = new p(0, 0, h, a);
    b = b || {};
    this.texture = new n(void 0, void 0, b.wrapS, b.wrapT, b.magFilter, b.minFilter, b.format, b.type, b.anisotropy, b.encoding);
    this.texture.generateMipmaps = void 0 !== b.generateMipmaps ? b.generateMipmaps : !1;
    this.texture.minFilter = void 0 !== b.minFilter ? b.minFilter : 1006;
    this.depthBuffer = void 0 !== b.depthBuffer ? b.depthBuffer : !0;
    this.stencilBuffer = void 0 !== b.stencilBuffer ? b.stencilBuffer : !0;
    this.depthTexture = void 0 !== b.depthTexture ? b.depthTexture : null;
  }
  function t(h, a, b) {
    m.call(this, h, a, b);
    this.samples = 4;
  }
  function d(h, a, b) {
    m.call(this, h, a, b);
  }
  function l(h, a, b, d, f, c, e, l, k, g, q, m) {
    n.call(this, null, c, e, l, k, g, d, f, q, m);
    this.image = {data:h, width:a, height:b};
    this.magFilter = void 0 !== k ? k : 1003;
    this.minFilter = void 0 !== g ? g : 1003;
    this.flipY = this.generateMipmaps = !1;
    this.unpackAlignment = 1;
  }
  function u(h, a) {
    this.min = void 0 !== h ? h : new f(Infinity, Infinity, Infinity);
    this.max = void 0 !== a ? a : new f(-Infinity, -Infinity, -Infinity);
  }
  function w(h, a) {
    this.center = void 0 !== h ? h : new f;
    this.radius = void 0 !== a ? a : 0;
  }
  function y(h, a) {
    this.normal = void 0 !== h ? h : new f(1, 0, 0);
    this.constant = void 0 !== a ? a : 0;
  }
  function x(h, a, b, d, f, c) {
    this.planes = [void 0 !== h ? h : new y, void 0 !== a ? a : new y, void 0 !== b ? b : new y, void 0 !== d ? d : new y, void 0 !== f ? f : new y, void 0 !== c ? c : new y];
  }
  function q(h) {
    var a = {}, b;
    for (b in h) {
      a[b] = {};
      for (var d in h[b]) {
        var f = h[b][d];
        f && (f.isColor || f.isMatrix3 || f.isMatrix4 || f.isVector2 || f.isVector3 || f.isVector4 || f.isTexture) ? a[b][d] = f.clone() : Array.isArray(f) ? a[b][d] = f.slice() : a[b][d] = f;
      }
    }
    return a;
  }
  function v(h) {
    for (var a = {}, b = 0; b < h.length; b++) {
      var d = q(h[b]), f;
      for (f in d) {
        a[f] = d[f];
      }
    }
    return a;
  }
  function z(h, a, b) {
    return void 0 === a && void 0 === b ? this.set(h) : this.setRGB(h, a, b);
  }
  function C() {
    function h(r, f) {
      !1 !== b && (d(r, f), a.requestAnimationFrame(h));
    }
    var a = null, b = !1, d = null;
    return {start:function() {
      !0 !== b && null !== d && (a.requestAnimationFrame(h), b = !0);
    }, stop:function() {
      b = !1;
    }, setAnimationLoop:function(h) {
      d = h;
    }, setContext:function(h) {
      a = h;
    }};
  }
  function A(h) {
    function a(a, r) {
      var b = a.array, d = a.dynamic ? 35048 : 35044, f = h.createBuffer();
      h.bindBuffer(r, f);
      h.bufferData(r, b, d);
      a.onUploadCallback();
      r = 5126;
      b instanceof Float32Array ? r = 5126 : b instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : b instanceof Uint16Array ? r = 5123 : b instanceof Int16Array ? r = 5122 : b instanceof Uint32Array ? r = 5125 : b instanceof Int32Array ? r = 5124 : b instanceof Int8Array ? r = 5120 : b instanceof Uint8Array && (r = 5121);
      return {buffer:f, type:r, bytesPerElement:b.BYTES_PER_ELEMENT, version:a.version};
    }
    var b = new WeakMap;
    return {get:function(h) {
      h.isInterleavedBufferAttribute && (h = h.data);
      return b.get(h);
    }, remove:function(a) {
      a.isInterleavedBufferAttribute && (a = a.data);
      var r = b.get(a);
      r && (h.deleteBuffer(r.buffer), b.delete(a));
    }, update:function(r, d) {
      r.isInterleavedBufferAttribute && (r = r.data);
      var f = b.get(r);
      if (void 0 === f) {
        b.set(r, a(r, d));
      } else {
        if (f.version < r.version) {
          var F = r, c = F.array, e = F.updateRange;
          h.bindBuffer(d, f.buffer);
          !1 === F.dynamic ? h.bufferData(d, c, 35044) : -1 === e.count ? h.bufferSubData(d, 0, c) : 0 === e.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (h.bufferSubData(d, e.offset * c.BYTES_PER_ELEMENT, c.subarray(e.offset, e.offset + e.count)), e.count = -1);
          f.version = r.version;
        }
      }
    }};
  }
  function D(h, a, b, d, c, e) {
    this.a = h;
    this.b = a;
    this.c = b;
    this.normal = d && d.isVector3 ? d : new f;
    this.vertexNormals = Array.isArray(d) ? d : [];
    this.color = c && c.isColor ? c : new z;
    this.vertexColors = Array.isArray(c) ? c : [];
    this.materialIndex = void 0 !== e ? e : 0;
  }
  function E(h, a, b, d) {
    this._x = h || 0;
    this._y = a || 0;
    this._z = b || 0;
    this._order = d || E.DefaultOrder;
  }
  function B() {
    this.mask = 1;
  }
  function G() {
    Object.defineProperty(this, "id", {value:Yf++});
    this.uuid = ia.generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = G.DefaultUp.clone();
    var h = new f, a = new E, d = new e, c = new f(1, 1, 1);
    a.onChange(function() {
      d.setFromEuler(a, !1);
    });
    d.onChange(function() {
      a.setFromQuaternion(d, void 0, !1);
    });
    Object.defineProperties(this, {position:{configurable:!0, enumerable:!0, value:h}, rotation:{configurable:!0, enumerable:!0, value:a}, quaternion:{configurable:!0, enumerable:!0, value:d}, scale:{configurable:!0, enumerable:!0, value:c}, modelViewMatrix:{value:new b}, normalMatrix:{value:new k}});
    this.matrix = new b;
    this.matrixWorld = new b;
    this.matrixAutoUpdate = G.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = !1;
    this.layers = new B;
    this.visible = !0;
    this.receiveShadow = this.castShadow = !1;
    this.frustumCulled = !0;
    this.renderOrder = 0;
    this.userData = {};
  }
  function H() {
    Object.defineProperty(this, "id", {value:Zf += 2});
    this.uuid = ia.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingSphere = this.boundingBox = null;
    this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1;
  }
  function K(h, a, b) {
    if (Array.isArray(h)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.name = "";
    this.array = h;
    this.itemSize = a;
    this.count = void 0 !== h ? h.length / a : 0;
    this.normalized = !0 === b;
    this.dynamic = !1;
    this.updateRange = {offset:0, count:-1};
    this.version = 0;
  }
  function I(h, a, b) {
    K.call(this, new Int8Array(h), a, b);
  }
  function L(h, a, b) {
    K.call(this, new Uint8Array(h), a, b);
  }
  function R(h, a, b) {
    K.call(this, new Uint8ClampedArray(h), a, b);
  }
  function J(h, a, b) {
    K.call(this, new Int16Array(h), a, b);
  }
  function Q(h, a, b) {
    K.call(this, new Uint16Array(h), a, b);
  }
  function aa(h, a, b) {
    K.call(this, new Int32Array(h), a, b);
  }
  function U(h, a, b) {
    K.call(this, new Uint32Array(h), a, b);
  }
  function N(h, a, b) {
    K.call(this, new Float32Array(h), a, b);
  }
  function S(h, a, b) {
    K.call(this, new Float64Array(h), a, b);
  }
  function V() {
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    this.boundingSphere = this.boundingBox = null;
    this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1;
  }
  function M(h) {
    if (0 === h.length) {
      return -Infinity;
    }
    for (var a = h[0], b = 1, d = h.length; b < d; ++b) {
      h[b] > a && (a = h[b]);
    }
    return a;
  }
  function O() {
    Object.defineProperty(this, "id", {value:$f += 2});
    this.uuid = ia.generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingSphere = this.boundingBox = null;
    this.drawRange = {start:0, count:Infinity};
    this.userData = {};
  }
  function P(h, a, b, d, f, c) {
    H.call(this);
    this.type = "BoxGeometry";
    this.parameters = {width:h, height:a, depth:b, widthSegments:d, heightSegments:f, depthSegments:c};
    this.fromBufferGeometry(new ka(h, a, b, d, f, c));
    this.mergeVertices();
  }
  function ka(h, a, b, d, c, e) {
    function r(h, a, r, b, d, c, e, m, t, p, u) {
      var v = c / t, Y = e / p, w = c / 2, T = e / 2, z = m / 2;
      e = t + 1;
      var y = p + 1, ya = c = 0, x, oa, D = new f;
      for (oa = 0; oa < y; oa++) {
        var C = oa * Y - T;
        for (x = 0; x < e; x++) {
          D[h] = (x * v - w) * b, D[a] = C * d, D[r] = z, k.push(D.x, D.y, D.z), D[h] = 0, D[a] = 0, D[r] = 0 < m ? 1 : -1, g.push(D.x, D.y, D.z), q.push(x / t), q.push(1 - oa / p), c += 1;
        }
      }
      for (oa = 0; oa < p; oa++) {
        for (x = 0; x < t; x++) {
          h = W + x + e * (oa + 1), a = W + (x + 1) + e * (oa + 1), r = W + (x + 1) + e * oa, l.push(W + x + e * oa, h, r), l.push(h, a, r), ya += 6;
        }
      }
      F.addGroup(n, ya, u);
      n += ya;
      W += c;
    }
    O.call(this);
    this.type = "BoxBufferGeometry";
    this.parameters = {width:h, height:a, depth:b, widthSegments:d, heightSegments:c, depthSegments:e};
    var F = this;
    h = h || 1;
    a = a || 1;
    b = b || 1;
    d = Math.floor(d) || 1;
    c = Math.floor(c) || 1;
    e = Math.floor(e) || 1;
    var l = [], k = [], g = [], q = [], W = 0, n = 0;
    r("z", "y", "x", -1, -1, b, a, h, e, c, 0);
    r("z", "y", "x", 1, -1, b, a, -h, e, c, 1);
    r("x", "z", "y", 1, 1, h, b, a, d, e, 2);
    r("x", "z", "y", 1, -1, h, b, -a, d, e, 3);
    r("x", "y", "z", 1, -1, h, a, b, d, c, 4);
    r("x", "y", "z", -1, -1, h, a, -b, d, c, 5);
    this.setIndex(l);
    this.addAttribute("position", new N(k, 3));
    this.addAttribute("normal", new N(g, 3));
    this.addAttribute("uv", new N(q, 2));
  }
  function ha(h, a, b, d) {
    H.call(this);
    this.type = "PlaneGeometry";
    this.parameters = {width:h, height:a, widthSegments:b, heightSegments:d};
    this.fromBufferGeometry(new ja(h, a, b, d));
    this.mergeVertices();
  }
  function ja(h, a, b, d) {
    O.call(this);
    this.type = "PlaneBufferGeometry";
    this.parameters = {width:h, height:a, widthSegments:b, heightSegments:d};
    h = h || 1;
    a = a || 1;
    var r = h / 2, f = a / 2;
    b = Math.floor(b) || 1;
    d = Math.floor(d) || 1;
    var c = b + 1, F = d + 1, e = h / b, l = a / d, k = [], g = [], q = [], W = [];
    for (h = 0; h < F; h++) {
      var n = h * l - f;
      for (a = 0; a < c; a++) {
        g.push(a * e - r, -n, 0), q.push(0, 0, 1), W.push(a / b), W.push(1 - h / d);
      }
    }
    for (h = 0; h < d; h++) {
      for (a = 0; a < b; a++) {
        r = a + c * (h + 1), f = a + 1 + c * (h + 1), F = a + 1 + c * h, k.push(a + c * h, r, F), k.push(r, f, F);
      }
    }
    this.setIndex(k);
    this.addAttribute("position", new N(g, 3));
    this.addAttribute("normal", new N(q, 3));
    this.addAttribute("uv", new N(W, 2));
  }
  function X() {
    Object.defineProperty(this, "id", {value:bg++});
    this.uuid = ia.generateUUID();
    this.name = "";
    this.type = "Material";
    this.lights = this.fog = !0;
    this.blending = 1;
    this.side = 0;
    this.vertexTangents = this.flatShading = !1;
    this.vertexColors = 0;
    this.opacity = 1;
    this.transparent = !1;
    this.blendSrc = 204;
    this.blendDst = 205;
    this.blendEquation = 100;
    this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
    this.depthFunc = 3;
    this.depthWrite = this.depthTest = !0;
    this.clippingPlanes = null;
    this.clipShadows = this.clipIntersection = !1;
    this.shadowSide = null;
    this.colorWrite = !0;
    this.precision = null;
    this.polygonOffset = !1;
    this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
    this.dithering = !1;
    this.alphaTest = 0;
    this.premultipliedAlpha = !1;
    this.visible = !0;
    this.userData = {};
    this.needsUpdate = !0;
  }
  function fa(h) {
    X.call(this);
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    this.linewidth = 1;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1;
    this.extensions = {derivatives:!1, fragDepth:!1, drawBuffers:!1, shaderTextureLOD:!1};
    this.defaultAttributeValues = {color:[1, 1, 1], uv:[0, 0], uv2:[0, 0]};
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = !1;
    void 0 !== h && (void 0 !== h.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(h));
  }
  function ba(h, a) {
    this.origin = void 0 !== h ? h : new f;
    this.direction = void 0 !== a ? a : new f;
  }
  function la(h, a, b) {
    this.a = void 0 !== h ? h : new f;
    this.b = void 0 !== a ? a : new f;
    this.c = void 0 !== b ? b : new f;
  }
  function ma(h) {
    X.call(this);
    this.type = "MeshBasicMaterial";
    this.color = new z(16777215);
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.envMap = this.alphaMap = this.specularMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.lights = this.morphTargets = this.skinning = !1;
    this.setValues(h);
  }
  function ca(h, a) {
    G.call(this);
    this.type = "Mesh";
    this.geometry = void 0 !== h ? h : new O;
    this.material = void 0 !== a ? a : new ma({color:16777215 * Math.random()});
    this.drawMode = 0;
    this.updateMorphTargets();
  }
  function Ua(h, a, b, d) {
    function r(h, r) {
      a.buffers.color.setClear(h.r, h.g, h.b, r, d);
    }
    var f = new z(0), c = 0, F, e, l = null, k = 0;
    return {getClearColor:function() {
      return f;
    }, setClearColor:function(h, a) {
      f.set(h);
      c = void 0 !== a ? a : 1;
      r(f, c);
    }, getClearAlpha:function() {
      return c;
    }, setClearAlpha:function(h) {
      c = h;
      r(f, c);
    }, render:function(a, d, g, W) {
      d = d.background;
      null === d ? (r(f, c), l = null, k = 0) : d && d.isColor && (r(d, 1), W = !0, l = null, k = 0);
      (h.autoClear || W) && h.clear(h.autoClearColor, h.autoClearDepth, h.autoClearStencil);
      if (d && (d.isCubeTexture || d.isWebGLRenderTargetCube)) {
        void 0 === e && (e = new ca(new ka(1, 1, 1), new fa({type:"BackgroundCubeMaterial", uniforms:q(fb.cube.uniforms), vertexShader:fb.cube.vertexShader, fragmentShader:fb.cube.fragmentShader, side:1, depthTest:!1, depthWrite:!1, fog:!1})), e.geometry.removeAttribute("normal"), e.geometry.removeAttribute("uv"), e.onBeforeRender = function(h, a, r) {
          this.matrixWorld.copyPosition(r.matrixWorld);
        }, Object.defineProperty(e.material, "map", {get:function() {
          return this.uniforms.tCube.value;
        }}), b.update(e));
        W = d.isWebGLRenderTargetCube ? d.texture : d;
        e.material.uniforms.tCube.value = W;
        e.material.uniforms.tFlip.value = d.isWebGLRenderTargetCube ? 1 : -1;
        if (l !== d || k !== W.version) {
          e.material.needsUpdate = !0, l = d, k = W.version;
        }
        a.unshift(e, e.geometry, e.material, 0, 0, null);
      } else {
        if (d && d.isTexture) {
          void 0 === F && (F = new ca(new ja(2, 2), new fa({type:"BackgroundMaterial", uniforms:q(fb.background.uniforms), vertexShader:fb.background.vertexShader, fragmentShader:fb.background.fragmentShader, side:0, depthTest:!1, depthWrite:!1, fog:!1})), F.geometry.removeAttribute("normal"), Object.defineProperty(F.material, "map", {get:function() {
            return this.uniforms.t2D.value;
          }}), b.update(F));
          F.material.uniforms.t2D.value = d;
          !0 === d.matrixAutoUpdate && d.updateMatrix();
          F.material.uniforms.uvTransform.value.copy(d.matrix);
          if (l !== d || k !== d.version) {
            F.material.needsUpdate = !0, l = d, k = d.version;
          }
          a.unshift(F, F.geometry, F.material, 0, 0, null);
        }
      }
    }};
  }
  function ob(h, a, b, d) {
    var r;
    this.setMode = function(h) {
      r = h;
    };
    this.render = function(a, d) {
      h.drawArrays(r, a, d);
      b.update(d, r);
    };
    this.renderInstances = function(f, c, F) {
      if (d.isWebGL2) {
        var e = h;
      } else {
        if (e = a.get("ANGLE_instanced_arrays"), null === e) {
          console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      e[d.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, c, F, f.maxInstancedCount);
      b.update(F, r, f.maxInstancedCount);
    };
  }
  function pb(h, a, b) {
    function r(a) {
      if ("highp" === a) {
        if (0 < h.getShaderPrecisionFormat(35633, 36338).precision && 0 < h.getShaderPrecisionFormat(35632, 36338).precision) {
          return "highp";
        }
        a = "mediump";
      }
      return "mediump" === a && 0 < h.getShaderPrecisionFormat(35633, 36337).precision && 0 < h.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp";
    }
    var d, f = "undefined" !== typeof WebGL2RenderingContext && h instanceof WebGL2RenderingContext, c = void 0 !== b.precision ? b.precision : "highp", F = r(c);
    F !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", F, "instead."), c = F);
    b = !0 === b.logarithmicDepthBuffer;
    F = h.getParameter(34930);
    var e = h.getParameter(35660), l = h.getParameter(3379), k = h.getParameter(34076), g = h.getParameter(34921), q = h.getParameter(36347), n = h.getParameter(36348), m = h.getParameter(36349), t = 0 < e, p = f || !!a.get("OES_texture_float"), u = t && p, v = f ? h.getParameter(36183) : 0;
    return {isWebGL2:f, getMaxAnisotropy:function() {
      if (void 0 !== d) {
        return d;
      }
      var r = a.get("EXT_texture_filter_anisotropic");
      return d = null !== r ? h.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
    }, getMaxPrecision:r, precision:c, logarithmicDepthBuffer:b, maxTextures:F, maxVertexTextures:e, maxTextureSize:l, maxCubemapSize:k, maxAttributes:g, maxVertexUniforms:q, maxVaryings:n, maxFragmentUniforms:m, vertexTextures:t, floatFragmentTextures:p, floatVertexTextures:u, maxSamples:v};
  }
  function qb() {
    function h() {
      q.value !== d && (q.value = d, q.needsUpdate = 0 < f);
      b.numPlanes = f;
      b.numIntersection = 0;
    }
    function a(h, a, r, d) {
      var f = null !== h ? h.length : 0, c = null;
      if (0 !== f) {
        c = q.value;
        if (!0 !== d || null === c) {
          d = r + 4 * f;
          a = a.matrixWorldInverse;
          g.getNormalMatrix(a);
          if (null === c || c.length < d) {
            c = new Float32Array(d);
          }
          for (d = 0; d !== f; ++d, r += 4) {
            l.copy(h[d]).applyMatrix4(a, g), l.normal.toArray(c, r), c[r + 3] = l.constant;
          }
        }
        q.value = c;
        q.needsUpdate = !0;
      }
      b.numPlanes = f;
      return c;
    }
    var b = this, d = null, f = 0, c = !1, e = !1, l = new y, g = new k, q = {value:null, needsUpdate:!1};
    this.uniform = q;
    this.numIntersection = this.numPlanes = 0;
    this.init = function(h, r, b) {
      var F = 0 !== h.length || r || 0 !== f || c;
      c = r;
      d = a(h, b, 0);
      f = h.length;
      return F;
    };
    this.beginShadows = function() {
      e = !0;
      a(null);
    };
    this.endShadows = function() {
      e = !1;
      h();
    };
    this.setState = function(r, b, F, l, k, g) {
      if (!c || null === r || 0 === r.length || e && !F) {
        e ? a(null) : h();
      } else {
        F = e ? 0 : f;
        var W = 4 * F, n = k.clippingState || null;
        q.value = n;
        n = a(r, l, W, g);
        for (r = 0; r !== W; ++r) {
          n[r] = d[r];
        }
        k.clippingState = n;
        this.numIntersection = b ? this.numPlanes : 0;
        this.numPlanes += F;
      }
    };
  }
  function rb(h) {
    var a = {};
    return {get:function(r) {
      if (void 0 !== a[r]) {
        return a[r];
      }
      switch(r) {
        case "WEBGL_depth_texture":
          var b = h.getExtension("WEBGL_depth_texture") || h.getExtension("MOZ_WEBGL_depth_texture") || h.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          b = h.getExtension("EXT_texture_filter_anisotropic") || h.getExtension("MOZ_EXT_texture_filter_anisotropic") || h.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          b = h.getExtension("WEBGL_compressed_texture_s3tc") || h.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || h.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          b = h.getExtension("WEBGL_compressed_texture_pvrtc") || h.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          b = h.getExtension(r);
      }
      null === b && console.warn("THREE.WebGLRenderer: " + r + " extension not supported.");
      return a[r] = b;
    }};
  }
  function ne(h, a, b) {
    function r(h) {
      var c = h.target;
      h = d[c.id];
      null !== h.index && a.remove(h.index);
      for (var F in h.attributes) {
        a.remove(h.attributes[F]);
      }
      c.removeEventListener("dispose", r);
      delete d[c.id];
      if (F = f[h.id]) {
        a.remove(F), delete f[h.id];
      }
      b.memory.geometries--;
    }
    var d = {}, f = {};
    return {get:function(h, a) {
      var f = d[a.id];
      if (f) {
        return f;
      }
      a.addEventListener("dispose", r);
      a.isBufferGeometry ? f = a : a.isGeometry && (void 0 === a._bufferGeometry && (a._bufferGeometry = (new O).setFromObject(h)), f = a._bufferGeometry);
      d[a.id] = f;
      b.memory.geometries++;
      return f;
    }, update:function(h) {
      var r = h.index, b = h.attributes;
      null !== r && a.update(r, 34963);
      for (var d in b) {
        a.update(b[d], 34962);
      }
      h = h.morphAttributes;
      for (d in h) {
        r = h[d];
        b = 0;
        for (var f = r.length; b < f; b++) {
          a.update(r[b], 34962);
        }
      }
    }, getWireframeAttribute:function(h) {
      var r = f[h.id];
      if (r) {
        return r;
      }
      r = [];
      var b = h.index, d = h.attributes;
      if (null !== b) {
        b = b.array;
        d = 0;
        for (var c = b.length; d < c; d += 3) {
          var F = b[d + 0], e = b[d + 1], l = b[d + 2];
          r.push(F, e, e, l, l, F);
        }
      } else {
        for (b = d.position.array, d = 0, c = b.length / 3 - 1; d < c; d += 3) {
          F = d + 0, e = d + 1, l = d + 2, r.push(F, e, e, l, l, F);
        }
      }
      r = new (65535 < M(r) ? U : Q)(r, 1);
      a.update(r, 34963);
      return f[h.id] = r;
    }};
  }
  function oe(h, a, b, d) {
    var r, f, c;
    this.setMode = function(h) {
      r = h;
    };
    this.setIndex = function(h) {
      f = h.type;
      c = h.bytesPerElement;
    };
    this.render = function(a, d) {
      h.drawElements(r, d, f, a * c);
      b.update(d, r);
    };
    this.renderInstances = function(F, e, l) {
      if (d.isWebGL2) {
        var k = h;
      } else {
        if (k = a.get("ANGLE_instanced_arrays"), null === k) {
          console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      k[d.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, l, f, e * c, F.maxInstancedCount);
      b.update(l, r, F.maxInstancedCount);
    };
  }
  function pe(h) {
    var a = {frame:0, calls:0, triangles:0, points:0, lines:0};
    return {memory:{geometries:0, textures:0}, render:a, programs:null, autoReset:!0, reset:function() {
      a.frame++;
      a.calls = 0;
      a.triangles = 0;
      a.points = 0;
      a.lines = 0;
    }, update:function(h, r, b) {
      b = b || 1;
      a.calls++;
      switch(r) {
        case 4:
          a.triangles += h / 3 * b;
          break;
        case 5:
        case 6:
          a.triangles += b * (h - 2);
          break;
        case 1:
          a.lines += h / 2 * b;
          break;
        case 3:
          a.lines += b * (h - 1);
          break;
        case 2:
          a.lines += b * h;
          break;
        case 0:
          a.points += b * h;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", r);
      }
    }};
  }
  function qe(h, a) {
    return Math.abs(a[1]) - Math.abs(h[1]);
  }
  function re(h) {
    var a = {}, b = new Float32Array(8);
    return {update:function(r, d, f, c) {
      var F = r.morphTargetInfluences, e = F.length;
      r = a[d.id];
      if (void 0 === r) {
        r = [];
        for (var l = 0; l < e; l++) {
          r[l] = [l, 0];
        }
        a[d.id] = r;
      }
      var k = f.morphTargets && d.morphAttributes.position;
      f = f.morphNormals && d.morphAttributes.normal;
      for (l = 0; l < e; l++) {
        var g = r[l];
        0 !== g[1] && (k && d.removeAttribute("morphTarget" + l), f && d.removeAttribute("morphNormal" + l));
      }
      for (l = 0; l < e; l++) {
        g = r[l], g[0] = l, g[1] = F[l];
      }
      r.sort(qe);
      for (l = 0; 8 > l; l++) {
        if (g = r[l]) {
          if (F = g[0], e = g[1]) {
            k && d.addAttribute("morphTarget" + l, k[F]);
            f && d.addAttribute("morphNormal" + l, f[F]);
            b[l] = e;
            continue;
          }
        }
        b[l] = 0;
      }
      c.getUniforms().setValue(h, "morphTargetInfluences", b);
    }};
  }
  function se(h, a) {
    var r = {};
    return {update:function(b) {
      var d = a.render.frame, f = b.geometry, c = h.get(b, f);
      r[c.id] !== d && (f.isGeometry && c.updateFromObject(b), h.update(c), r[c.id] = d);
      return c;
    }, dispose:function() {
      r = {};
    }};
  }
  function za(h, a, b, d, f, c, e, l, k, g) {
    h = void 0 !== h ? h : [];
    n.call(this, h, void 0 !== a ? a : 301, b, d, f, c, void 0 !== e ? e : 1022, l, k, g);
    this.flipY = !1;
  }
  function Ja(h, a, b, d) {
    n.call(this, null);
    this.image = {data:h, width:a, height:b, depth:d};
    this.minFilter = this.magFilter = 1003;
    this.wrapR = 1001;
    this.flipY = this.generateMipmaps = !1;
  }
  function gb(h, a, b) {
    var r = h[0];
    if (0 >= r || 0 < r) {
      return h;
    }
    var d = a * b, f = ef[d];
    void 0 === f && (f = new Float32Array(d), ef[d] = f);
    if (0 !== a) {
      for (r.toArray(f, 0), r = 1, d = 0; r !== a; ++r) {
        d += b, h[r].toArray(f, d);
      }
    }
    return f;
  }
  function qa(h, a) {
    if (h.length !== a.length) {
      return !1;
    }
    for (var r = 0, b = h.length; r < b; r++) {
      if (h[r] !== a[r]) {
        return !1;
      }
    }
    return !0;
  }
  function ua(h, a) {
    for (var r = 0, b = a.length; r < b; r++) {
      h[r] = a[r];
    }
  }
  function Nb(h, a) {
    var r = ff[a];
    void 0 === r && (r = new Int32Array(a), ff[a] = r);
    for (var b = 0; b !== a; ++b) {
      r[b] = h.allocTextureUnit();
    }
    return r;
  }
  function sb(h, a) {
    var r = this.cache;
    r[0] !== a && (h.uniform1f(this.addr, a), r[0] = a);
  }
  function Md(h, a) {
    var r = this.cache;
    r[0] !== a && (h.uniform1i(this.addr, a), r[0] = a);
  }
  function gc(h, a) {
    var r = this.cache;
    if (void 0 !== a.x) {
      if (r[0] !== a.x || r[1] !== a.y) {
        h.uniform2f(this.addr, a.x, a.y), r[0] = a.x, r[1] = a.y;
      }
    } else {
      qa(r, a) || (h.uniform2fv(this.addr, a), ua(r, a));
    }
  }
  function Bb(h, a) {
    var r = this.cache;
    if (void 0 !== a.x) {
      if (r[0] !== a.x || r[1] !== a.y || r[2] !== a.z) {
        h.uniform3f(this.addr, a.x, a.y, a.z), r[0] = a.x, r[1] = a.y, r[2] = a.z;
      }
    } else {
      if (void 0 !== a.r) {
        if (r[0] !== a.r || r[1] !== a.g || r[2] !== a.b) {
          h.uniform3f(this.addr, a.r, a.g, a.b), r[0] = a.r, r[1] = a.g, r[2] = a.b;
        }
      } else {
        qa(r, a) || (h.uniform3fv(this.addr, a), ua(r, a));
      }
    }
  }
  function Nd(h, a) {
    var r = this.cache;
    if (void 0 !== a.x) {
      if (r[0] !== a.x || r[1] !== a.y || r[2] !== a.z || r[3] !== a.w) {
        h.uniform4f(this.addr, a.x, a.y, a.z, a.w), r[0] = a.x, r[1] = a.y, r[2] = a.z, r[3] = a.w;
      }
    } else {
      qa(r, a) || (h.uniform4fv(this.addr, a), ua(r, a));
    }
  }
  function Cb(h, a) {
    var r = this.cache, b = a.elements;
    void 0 === b ? qa(r, a) || (h.uniformMatrix2fv(this.addr, !1, a), ua(r, a)) : qa(r, b) || (gf.set(b), h.uniformMatrix2fv(this.addr, !1, gf), ua(r, b));
  }
  function Oc(h, a) {
    var r = this.cache, b = a.elements;
    void 0 === b ? qa(r, a) || (h.uniformMatrix3fv(this.addr, !1, a), ua(r, a)) : qa(r, b) || (hf.set(b), h.uniformMatrix3fv(this.addr, !1, hf), ua(r, b));
  }
  function Od(h, a) {
    var r = this.cache, b = a.elements;
    void 0 === b ? qa(r, a) || (h.uniformMatrix4fv(this.addr, !1, a), ua(r, a)) : qa(r, b) || (jf.set(b), h.uniformMatrix4fv(this.addr, !1, jf), ua(r, b));
  }
  function Db(h, a, b) {
    var r = this.cache, d = b.allocTextureUnit();
    r[0] !== d && (h.uniform1i(this.addr, d), r[0] = d);
    b.setTexture2D(a || kf, d);
  }
  function tb(h, a, b) {
    var r = this.cache, d = b.allocTextureUnit();
    r[0] !== d && (h.uniform1i(this.addr, d), r[0] = d);
    b.setTexture3D(a || cg, d);
  }
  function Eb(h, a, b) {
    var r = this.cache, d = b.allocTextureUnit();
    r[0] !== d && (h.uniform1i(this.addr, d), r[0] = d);
    b.setTextureCube(a || lf, d);
  }
  function Pc(h, a) {
    var r = this.cache;
    qa(r, a) || (h.uniform2iv(this.addr, a), ua(r, a));
  }
  function hb(h, a) {
    var r = this.cache;
    qa(r, a) || (h.uniform3iv(this.addr, a), ua(r, a));
  }
  function ub(h, a) {
    var r = this.cache;
    qa(r, a) || (h.uniform4iv(this.addr, a), ua(r, a));
  }
  function Ob(h) {
    switch(h) {
      case 5126:
        return sb;
      case 35664:
        return gc;
      case 35665:
        return Bb;
      case 35666:
        return Nd;
      case 35674:
        return Cb;
      case 35675:
        return Oc;
      case 35676:
        return Od;
      case 35678:
      case 36198:
        return Db;
      case 35679:
        return tb;
      case 35680:
        return Eb;
      case 5124:
      case 35670:
        return Md;
      case 35667:
      case 35671:
        return Pc;
      case 35668:
      case 35672:
        return hb;
      case 35669:
      case 35673:
        return ub;
    }
  }
  function Qc(h, a) {
    var r = this.cache;
    qa(r, a) || (h.uniform1fv(this.addr, a), ua(r, a));
  }
  function Fb(h, a) {
    var r = this.cache;
    qa(r, a) || (h.uniform1iv(this.addr, a), ua(r, a));
  }
  function Rc(h, a) {
    var r = this.cache;
    a = gb(a, this.size, 2);
    qa(r, a) || (h.uniform2fv(this.addr, a), this.updateCache(a));
  }
  function Pa(h, a) {
    var r = this.cache;
    a = gb(a, this.size, 3);
    qa(r, a) || (h.uniform3fv(this.addr, a), this.updateCache(a));
  }
  function Ba(h, a) {
    var r = this.cache;
    a = gb(a, this.size, 4);
    qa(r, a) || (h.uniform4fv(this.addr, a), this.updateCache(a));
  }
  function Sc(h, a) {
    var r = this.cache;
    a = gb(a, this.size, 4);
    qa(r, a) || (h.uniformMatrix2fv(this.addr, !1, a), this.updateCache(a));
  }
  function ib(h, a) {
    var r = this.cache;
    a = gb(a, this.size, 9);
    qa(r, a) || (h.uniformMatrix3fv(this.addr, !1, a), this.updateCache(a));
  }
  function hc(h, a) {
    var r = this.cache;
    a = gb(a, this.size, 16);
    qa(r, a) || (h.uniformMatrix4fv(this.addr, !1, a), this.updateCache(a));
  }
  function Gb(h, a, b) {
    var r = this.cache, d = a.length, f = Nb(b, d);
    !1 === qa(r, f) && (h.uniform1iv(this.addr, f), ua(r, f));
    for (h = 0; h !== d; ++h) {
      b.setTexture2D(a[h] || kf, f[h]);
    }
  }
  function Va(h, a, b) {
    var r = this.cache, d = a.length, f = Nb(b, d);
    !1 === qa(r, f) && (h.uniform1iv(this.addr, f), ua(r, f));
    for (h = 0; h !== d; ++h) {
      b.setTextureCube(a[h] || lf, f[h]);
    }
  }
  function sa(h) {
    switch(h) {
      case 5126:
        return Qc;
      case 35664:
        return Rc;
      case 35665:
        return Pa;
      case 35666:
        return Ba;
      case 35674:
        return Sc;
      case 35675:
        return ib;
      case 35676:
        return hc;
      case 35678:
        return Gb;
      case 35680:
        return Va;
      case 5124:
      case 35670:
        return Fb;
      case 35667:
      case 35671:
        return Pc;
      case 35668:
      case 35672:
        return hb;
      case 35669:
      case 35673:
        return ub;
    }
  }
  function Tc(h, a, b) {
    this.id = h;
    this.addr = b;
    this.cache = [];
    this.setValue = Ob(a.type);
  }
  function Ca(h, a, b) {
    this.id = h;
    this.addr = b;
    this.cache = [];
    this.size = a.size;
    this.setValue = sa(a.type);
  }
  function Qa(h) {
    this.id = h;
    this.seq = [];
    this.map = {};
  }
  function Hb(h, a, b) {
    this.seq = [];
    this.map = {};
    this.renderer = b;
    b = h.getProgramParameter(a, 35718);
    for (var r = 0; r < b; ++r) {
      var d = h.getActiveUniform(a, r), f = h.getUniformLocation(a, d.name), c = this, e = d.name, F = e.length;
      for (te.lastIndex = 0;;) {
        var l = te.exec(e), k = te.lastIndex, g = l[1], q = l[3];
        "]" === l[2] && (g |= 0);
        if (void 0 === q || "[" === q && k + 2 === F) {
          e = c;
          d = void 0 === q ? new Tc(g, d, f) : new Ca(g, d, f);
          e.seq.push(d);
          e.map[d.id] = d;
          break;
        } else {
          q = c.map[g], void 0 === q && (q = new Qa(g), g = c, c = q, g.seq.push(c), g.map[c.id] = c), c = q;
        }
      }
    }
  }
  function ic(h) {
    h = h.split("\n");
    for (var a = 0; a < h.length; a++) {
      h[a] = a + 1 + ": " + h[a];
    }
    return h.join("\n");
  }
  function vb(h, a, b) {
    var r = h.createShader(a);
    h.shaderSource(r, b);
    h.compileShader(r);
    !1 === h.getShaderParameter(r, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile.");
    "" !== h.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === a ? "vertex" : "fragment", h.getShaderInfoLog(r), ic(b));
    return r;
  }
  function Aa(h) {
    switch(h) {
      case 3E3:
        return ["Linear", "( value )"];
      case 3001:
        return ["sRGB", "( value )"];
      case 3002:
        return ["RGBE", "( value )"];
      case 3004:
        return ["RGBM", "( value, 7.0 )"];
      case 3005:
        return ["RGBM", "( value, 16.0 )"];
      case 3006:
        return ["RGBD", "( value, 256.0 )"];
      case 3007:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      default:
        throw Error("unsupported encoding: " + h);
    }
  }
  function Wa(h, a) {
    a = Aa(a);
    return "vec4 " + h + "( vec4 value ) { return " + a[0] + "ToLinear" + a[1] + "; }";
  }
  function Ra(h, a) {
    a = Aa(a);
    return "vec4 " + h + "( vec4 value ) { return LinearTo" + a[0] + a[1] + "; }";
  }
  function Sa(h, a) {
    switch(a) {
      case 1:
        a = "Linear";
        break;
      case 2:
        a = "Reinhard";
        break;
      case 3:
        a = "Uncharted2";
        break;
      case 4:
        a = "OptimizedCineon";
        break;
      case 5:
        a = "ACESFilmic";
        break;
      default:
        throw Error("unsupported toneMapping: " + a);
    }
    return "vec3 " + h + "( vec3 color ) { return " + a + "ToneMapping( color ); }";
  }
  function dg(h, a, b) {
    h = h || {};
    return [h.derivatives || a.envMapCubeUV || a.bumpMap || a.normalMap && !a.objectSpaceNormalMap || a.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (h.fragDepth || a.logarithmicDepthBuffer) && b.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", h.drawBuffers && b.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (h.shaderTextureLOD || a.envMap) && b.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : 
    ""].filter(Uc).join("\n");
  }
  function eg(h) {
    var a = [], b;
    for (b in h) {
      var d = h[b];
      !1 !== d && a.push("#define " + b + " " + d);
    }
    return a.join("\n");
  }
  function Uc(h) {
    return "" !== h;
  }
  function mf(h, a) {
    return h.replace(/NUM_DIR_LIGHTS/g, a.numDirLights).replace(/NUM_SPOT_LIGHTS/g, a.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, a.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, a.numPointLights).replace(/NUM_HEMI_LIGHTS/g, a.numHemiLights);
  }
  function nf(h, a) {
    return h.replace(/NUM_CLIPPING_PLANES/g, a.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, a.numClippingPlanes - a.numClipIntersection);
  }
  function ue(h) {
    return h.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(h, a) {
      h = na[a];
      if (void 0 === h) {
        throw Error("Can not resolve #include <" + a + ">");
      }
      return ue(h);
    });
  }
  function of(h) {
    return h.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(h, a, b, d) {
      h = "";
      for (a = parseInt(a); a < parseInt(b); a++) {
        h += d.replace(/\[ i \]/g, "[ " + a + " ]");
      }
      return h;
    });
  }
  function fg(h, a, b, d, f, c, e) {
    var r = h.context, l = d.defines, F = f.vertexShader, k = f.fragmentShader, g = "SHADOWMAP_TYPE_BASIC";
    1 === c.shadowMapType ? g = "SHADOWMAP_TYPE_PCF" : 2 === c.shadowMapType && (g = "SHADOWMAP_TYPE_PCF_SOFT");
    var q = "ENVMAP_TYPE_CUBE", n = "ENVMAP_MODE_REFLECTION", W = "ENVMAP_BLENDING_MULTIPLY";
    if (c.envMap) {
      switch(d.envMap.mapping) {
        case 301:
        case 302:
          q = "ENVMAP_TYPE_CUBE";
          break;
        case 306:
        case 307:
          q = "ENVMAP_TYPE_CUBE_UV";
          break;
        case 303:
        case 304:
          q = "ENVMAP_TYPE_EQUIREC";
          break;
        case 305:
          q = "ENVMAP_TYPE_SPHERE";
      }
      switch(d.envMap.mapping) {
        case 302:
        case 304:
          n = "ENVMAP_MODE_REFRACTION";
      }
      switch(d.combine) {
        case 0:
          W = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case 1:
          W = "ENVMAP_BLENDING_MIX";
          break;
        case 2:
          W = "ENVMAP_BLENDING_ADD";
      }
    }
    var m = 0 < h.gammaFactor ? h.gammaFactor : 1, t = e.isWebGL2 ? "" : dg(d.extensions, c, a), p = eg(l), u = r.createProgram();
    d.isRawShaderMaterial ? (l = [p].filter(Uc).join("\n"), 0 < l.length && (l += "\n"), a = [t, p].filter(Uc).join("\n"), 0 < a.length && (a += "\n")) : (l = ["precision " + c.precision + " float;", "precision " + c.precision + " int;", "#define SHADER_NAME " + f.name, p, c.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m, "#define MAX_BONES " + c.maxBones, c.useFog && c.fog ? "#define USE_FOG" : "", c.useFog && c.fogExp ? "#define FOG_EXP2" : "", c.map ? "#define USE_MAP" : 
    "", c.envMap ? "#define USE_ENVMAP" : "", c.envMap ? "#define " + n : "", c.lightMap ? "#define USE_LIGHTMAP" : "", c.aoMap ? "#define USE_AOMAP" : "", c.emissiveMap ? "#define USE_EMISSIVEMAP" : "", c.bumpMap ? "#define USE_BUMPMAP" : "", c.normalMap ? "#define USE_NORMALMAP" : "", c.normalMap && c.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", c.displacementMap && c.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", c.specularMap ? "#define USE_SPECULARMAP" : "", c.roughnessMap ? 
    "#define USE_ROUGHNESSMAP" : "", c.metalnessMap ? "#define USE_METALNESSMAP" : "", c.alphaMap ? "#define USE_ALPHAMAP" : "", c.vertexTangents ? "#define USE_TANGENT" : "", c.vertexColors ? "#define USE_COLOR" : "", c.flatShading ? "#define FLAT_SHADED" : "", c.skinning ? "#define USE_SKINNING" : "", c.useVertexTexture ? "#define BONE_TEXTURE" : "", c.morphTargets ? "#define USE_MORPHTARGETS" : "", c.morphNormals && !1 === c.flatShading ? "#define USE_MORPHNORMALS" : "", c.doubleSided ? "#define DOUBLE_SIDED" : 
    "", c.flipSided ? "#define FLIP_SIDED" : "", c.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", c.shadowMapEnabled ? "#define " + g : "", c.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", c.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", c.logarithmicDepthBuffer && (e.isWebGL2 || a.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", 
    "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", 
    "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Uc).join("\n"), a = [t, "precision " + c.precision + " float;", "precision " + c.precision + " int;", "#define SHADER_NAME " + f.name, p, c.alphaTest ? "#define ALPHATEST " + 
    c.alphaTest + (c.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + m, c.useFog && c.fog ? "#define USE_FOG" : "", c.useFog && c.fogExp ? "#define FOG_EXP2" : "", c.map ? "#define USE_MAP" : "", c.matcap ? "#define USE_MATCAP" : "", c.envMap ? "#define USE_ENVMAP" : "", c.envMap ? "#define " + q : "", c.envMap ? "#define " + n : "", c.envMap ? "#define " + W : "", c.lightMap ? "#define USE_LIGHTMAP" : "", c.aoMap ? "#define USE_AOMAP" : "", c.emissiveMap ? "#define USE_EMISSIVEMAP" : 
    "", c.bumpMap ? "#define USE_BUMPMAP" : "", c.normalMap ? "#define USE_NORMALMAP" : "", c.normalMap && c.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", c.specularMap ? "#define USE_SPECULARMAP" : "", c.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", c.metalnessMap ? "#define USE_METALNESSMAP" : "", c.alphaMap ? "#define USE_ALPHAMAP" : "", c.vertexTangents ? "#define USE_TANGENT" : "", c.vertexColors ? "#define USE_COLOR" : "", c.gradientMap ? "#define USE_GRADIENTMAP" : "", c.flatShading ? 
    "#define FLAT_SHADED" : "", c.doubleSided ? "#define DOUBLE_SIDED" : "", c.flipSided ? "#define FLIP_SIDED" : "", c.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", c.shadowMapEnabled ? "#define " + g : "", c.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", c.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", c.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", c.logarithmicDepthBuffer && (e.isWebGL2 || a.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : 
    "", c.envMap && (e.isWebGL2 || a.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== c.toneMapping ? "#define TONE_MAPPING" : "", 0 !== c.toneMapping ? na.tonemapping_pars_fragment : "", 0 !== c.toneMapping ? Sa("toneMapping", c.toneMapping) : "", c.dithering ? "#define DITHERING" : "", c.outputEncoding || c.mapEncoding || c.matcapEncoding || c.envMapEncoding || c.emissiveMapEncoding ? na.encodings_pars_fragment : 
    "", c.mapEncoding ? Wa("mapTexelToLinear", c.mapEncoding) : "", c.matcapEncoding ? Wa("matcapTexelToLinear", c.matcapEncoding) : "", c.envMapEncoding ? Wa("envMapTexelToLinear", c.envMapEncoding) : "", c.emissiveMapEncoding ? Wa("emissiveMapTexelToLinear", c.emissiveMapEncoding) : "", c.outputEncoding ? Ra("linearToOutputTexel", c.outputEncoding) : "", c.depthPacking ? "#define DEPTH_PACKING " + d.depthPacking : "", "\n"].filter(Uc).join("\n"));
    F = ue(F);
    F = mf(F, c);
    F = nf(F, c);
    k = ue(k);
    k = mf(k, c);
    k = nf(k, c);
    F = of(F);
    k = of(k);
    e.isWebGL2 && !d.isRawShaderMaterial && (e = !1, g = /^\s*#version\s+300\s+es\s*\n/, d.isShaderMaterial && null !== F.match(g) && null !== k.match(g) && (e = !0, F = F.replace(g, ""), k = k.replace(g, "")), l = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + l, a = ["#version 300 es\n\n#define varying in", e ? "" : "out highp vec4 pc_fragColor;", e ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + 
    "\n" + a);
    k = a + k;
    F = vb(r, 35633, l + F);
    k = vb(r, 35632, k);
    r.attachShader(u, F);
    r.attachShader(u, k);
    void 0 !== d.index0AttributeName ? r.bindAttribLocation(u, 0, d.index0AttributeName) : !0 === c.morphTargets && r.bindAttribLocation(u, 0, "position");
    r.linkProgram(u);
    c = r.getProgramInfoLog(u).trim();
    e = r.getShaderInfoLog(F).trim();
    g = r.getShaderInfoLog(k).trim();
    n = q = !0;
    if (!1 === r.getProgramParameter(u, 35714)) {
      q = !1, console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(u, 35715), "gl.getProgramInfoLog", c, e, g);
    } else {
      if ("" !== c) {
        console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", c);
      } else {
        if ("" === e || "" === g) {
          n = !1;
        }
      }
    }
    n && (this.diagnostics = {runnable:q, material:d, programLog:c, vertexShader:{log:e, prefix:l}, fragmentShader:{log:g, prefix:a}});
    r.deleteShader(F);
    r.deleteShader(k);
    var v;
    this.getUniforms = function() {
      void 0 === v && (v = new Hb(r, u, h));
      return v;
    };
    var Y;
    this.getAttributes = function() {
      if (void 0 === Y) {
        for (var h = {}, a = r.getProgramParameter(u, 35721), b = 0; b < a; b++) {
          var d = r.getActiveAttrib(u, b).name;
          h[d] = r.getAttribLocation(u, d);
        }
        Y = h;
      }
      return Y;
    };
    this.destroy = function() {
      r.deleteProgram(u);
      this.program = void 0;
    };
    Object.defineProperties(this, {uniforms:{get:function() {
      console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
      return this.getUniforms();
    }}, attributes:{get:function() {
      console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
      return this.getAttributes();
    }}});
    this.name = f.name;
    this.id = gg++;
    this.code = b;
    this.usedTimes = 1;
    this.program = u;
    this.vertexShader = F;
    this.fragmentShader = k;
    return this;
  }
  function hg(h, a, b) {
    function r(h, a) {
      if (h) {
        h.isTexture ? r = h.encoding : h.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), r = h.texture.encoding);
      } else {
        var r = 3E3;
      }
      3E3 === r && a && (r = 3007);
      return r;
    }
    var d = [], f = {MeshDepthMaterial:"depth", MeshDistanceMaterial:"distanceRGBA", MeshNormalMaterial:"normal", MeshBasicMaterial:"basic", MeshLambertMaterial:"lambert", MeshPhongMaterial:"phong", MeshToonMaterial:"phong", MeshStandardMaterial:"physical", MeshPhysicalMaterial:"physical", MeshMatcapMaterial:"matcap", LineBasicMaterial:"basic", LineDashedMaterial:"dashed", PointsMaterial:"points", ShadowMaterial:"shadow", SpriteMaterial:"sprite"}, c = "precision supportsVertexTextures map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
    this.getParameters = function(a, d, c, e, l, F, k) {
      var g = f[a.type];
      if (k.isSkinnedMesh) {
        var q = k.skeleton.bones;
        if (b.floatVertexTextures) {
          q = 1024;
        } else {
          var n = Math.min(Math.floor((b.maxVertexUniforms - 20) / 4), q.length);
          n < q.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + q.length + " bones. This GPU supports " + n + "."), q = 0) : q = n;
        }
      } else {
        q = 0;
      }
      n = b.precision;
      null !== a.precision && (n = b.getMaxPrecision(a.precision), n !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", n, "instead."));
      var W = h.getRenderTarget();
      return {shaderID:g, precision:n, supportsVertexTextures:b.vertexTextures, outputEncoding:r(W ? W.texture : null, h.gammaOutput), map:!!a.map, mapEncoding:r(a.map, h.gammaInput), matcap:!!a.matcap, matcapEncoding:r(a.matcap, h.gammaInput), envMap:!!a.envMap, envMapMode:a.envMap && a.envMap.mapping, envMapEncoding:r(a.envMap, h.gammaInput), envMapCubeUV:!!a.envMap && (306 === a.envMap.mapping || 307 === a.envMap.mapping), lightMap:!!a.lightMap, aoMap:!!a.aoMap, emissiveMap:!!a.emissiveMap, emissiveMapEncoding:r(a.emissiveMap, 
      h.gammaInput), bumpMap:!!a.bumpMap, normalMap:!!a.normalMap, objectSpaceNormalMap:1 === a.normalMapType, displacementMap:!!a.displacementMap, roughnessMap:!!a.roughnessMap, metalnessMap:!!a.metalnessMap, specularMap:!!a.specularMap, alphaMap:!!a.alphaMap, gradientMap:!!a.gradientMap, combine:a.combine, vertexTangents:a.vertexTangents, vertexColors:a.vertexColors, fog:!!e, useFog:a.fog, fogExp:e && e.isFogExp2, flatShading:a.flatShading, sizeAttenuation:a.sizeAttenuation, logarithmicDepthBuffer:b.logarithmicDepthBuffer, 
      skinning:a.skinning && 0 < q, maxBones:q, useVertexTexture:b.floatVertexTextures, morphTargets:a.morphTargets, morphNormals:a.morphNormals, maxMorphTargets:h.maxMorphTargets, maxMorphNormals:h.maxMorphNormals, numDirLights:d.directional.length, numPointLights:d.point.length, numSpotLights:d.spot.length, numRectAreaLights:d.rectArea.length, numHemiLights:d.hemi.length, numClippingPlanes:l, numClipIntersection:F, dithering:a.dithering, shadowMapEnabled:h.shadowMap.enabled && k.receiveShadow && 
      0 < c.length, shadowMapType:h.shadowMap.type, toneMapping:h.toneMapping, physicallyCorrectLights:h.physicallyCorrectLights, premultipliedAlpha:a.premultipliedAlpha, alphaTest:a.alphaTest, doubleSided:2 === a.side, flipSided:1 === a.side, depthPacking:void 0 !== a.depthPacking ? a.depthPacking : !1};
    };
    this.getProgramCode = function(a, r) {
      var b = [];
      r.shaderID ? b.push(r.shaderID) : (b.push(a.fragmentShader), b.push(a.vertexShader));
      if (void 0 !== a.defines) {
        for (var d in a.defines) {
          b.push(d), b.push(a.defines[d]);
        }
      }
      for (d = 0; d < c.length; d++) {
        b.push(r[c[d]]);
      }
      b.push(a.onBeforeCompile.toString());
      b.push(h.gammaOutput);
      b.push(h.gammaFactor);
      return b.join();
    };
    this.acquireProgram = function(r, f, c, e) {
      for (var l, F = 0, k = d.length; F < k; F++) {
        var g = d[F];
        if (g.code === e) {
          l = g;
          ++l.usedTimes;
          break;
        }
      }
      void 0 === l && (l = new fg(h, a, e, r, f, c, b), d.push(l));
      return l;
    };
    this.releaseProgram = function(h) {
      if (0 === --h.usedTimes) {
        var a = d.indexOf(h);
        d[a] = d[d.length - 1];
        d.pop();
        h.destroy();
      }
    };
    this.programs = d;
  }
  function ig() {
    var h = new WeakMap;
    return {get:function(a) {
      var r = h.get(a);
      void 0 === r && (r = {}, h.set(a, r));
      return r;
    }, remove:function(a) {
      h.delete(a);
    }, update:function(a, b, d) {
      h.get(a)[b] = d;
    }, dispose:function() {
      h = new WeakMap;
    }};
  }
  function jg(h, a) {
    return h.groupOrder !== a.groupOrder ? h.groupOrder - a.groupOrder : h.renderOrder !== a.renderOrder ? h.renderOrder - a.renderOrder : h.program && a.program && h.program !== a.program ? h.program.id - a.program.id : h.material.id !== a.material.id ? h.material.id - a.material.id : h.z !== a.z ? h.z - a.z : h.id - a.id;
  }
  function kg(h, a) {
    return h.groupOrder !== a.groupOrder ? h.groupOrder - a.groupOrder : h.renderOrder !== a.renderOrder ? h.renderOrder - a.renderOrder : h.z !== a.z ? a.z - h.z : h.id - a.id;
  }
  function pf() {
    function h(h, r, d, f, c, e) {
      var l = a[b];
      void 0 === l ? (l = {id:h.id, object:h, geometry:r, material:d, program:d.program, groupOrder:f, renderOrder:h.renderOrder, z:c, group:e}, a[b] = l) : (l.id = h.id, l.object = h, l.geometry = r, l.material = d, l.program = d.program, l.groupOrder = f, l.renderOrder = h.renderOrder, l.z = c, l.group = e);
      b++;
      return l;
    }
    var a = [], b = 0, d = [], f = [];
    return {opaque:d, transparent:f, init:function() {
      b = 0;
      d.length = 0;
      f.length = 0;
    }, push:function(a, r, b, c, e, l) {
      a = h(a, r, b, c, e, l);
      (!0 === b.transparent ? f : d).push(a);
    }, unshift:function(a, r, b, c, e, l) {
      a = h(a, r, b, c, e, l);
      (!0 === b.transparent ? f : d).unshift(a);
    }, sort:function() {
      1 < d.length && d.sort(jg);
      1 < f.length && f.sort(kg);
    }};
  }
  function lg() {
    function h(r) {
      r = r.target;
      r.removeEventListener("dispose", h);
      delete a[r.id];
    }
    var a = {};
    return {get:function(r, b) {
      var d = a[r.id];
      if (void 0 === d) {
        var f = new pf;
        a[r.id] = {};
        a[r.id][b.id] = f;
        r.addEventListener("dispose", h);
      } else {
        f = d[b.id], void 0 === f && (f = new pf, d[b.id] = f);
      }
      return f;
    }, dispose:function() {
      a = {};
    }};
  }
  function mg() {
    var h = {};
    return {get:function(a) {
      if (void 0 !== h[a.id]) {
        return h[a.id];
      }
      switch(a.type) {
        case "DirectionalLight":
          var r = {direction:new f, color:new z, shadow:!1, shadowBias:0, shadowRadius:1, shadowMapSize:new g};
          break;
        case "SpotLight":
          r = {position:new f, direction:new f, color:new z, distance:0, coneCos:0, penumbraCos:0, decay:0, shadow:!1, shadowBias:0, shadowRadius:1, shadowMapSize:new g};
          break;
        case "PointLight":
          r = {position:new f, color:new z, distance:0, decay:0, shadow:!1, shadowBias:0, shadowRadius:1, shadowMapSize:new g, shadowCameraNear:1, shadowCameraFar:1E3};
          break;
        case "HemisphereLight":
          r = {direction:new f, skyColor:new z, groundColor:new z};
          break;
        case "RectAreaLight":
          r = {color:new z, position:new f, halfWidth:new f, halfHeight:new f};
      }
      return h[a.id] = r;
    }};
  }
  function ng() {
    var h = new mg, a = {id:og++, hash:{stateID:-1, directionalLength:-1, pointLength:-1, spotLength:-1, rectAreaLength:-1, hemiLength:-1, shadowsLength:-1}, ambient:[0, 0, 0], directional:[], directionalShadowMap:[], directionalShadowMatrix:[], spot:[], spotShadowMap:[], spotShadowMatrix:[], rectArea:[], point:[], pointShadowMap:[], pointShadowMatrix:[], hemi:[]}, d = new f, c = new b, e = new b;
    return {setup:function(r, b, f) {
      var l = 0, k = 0, F = 0, g = 0, q = 0, n = 0, W = 0, m = 0;
      f = f.matrixWorldInverse;
      for (var t = 0, p = r.length; t < p; t++) {
        var u = r[t], v = u.color, w = u.intensity, Y = u.distance, z = u.shadow && u.shadow.map ? u.shadow.map.texture : null;
        if (u.isAmbientLight) {
          l += v.r * w, k += v.g * w, F += v.b * w;
        } else {
          if (u.isDirectionalLight) {
            var T = h.get(u);
            T.color.copy(u.color).multiplyScalar(u.intensity);
            T.direction.setFromMatrixPosition(u.matrixWorld);
            d.setFromMatrixPosition(u.target.matrixWorld);
            T.direction.sub(d);
            T.direction.transformDirection(f);
            if (T.shadow = u.castShadow) {
              v = u.shadow, T.shadowBias = v.bias, T.shadowRadius = v.radius, T.shadowMapSize = v.mapSize;
            }
            a.directionalShadowMap[g] = z;
            a.directionalShadowMatrix[g] = u.shadow.matrix;
            a.directional[g] = T;
            g++;
          } else {
            if (u.isSpotLight) {
              T = h.get(u);
              T.position.setFromMatrixPosition(u.matrixWorld);
              T.position.applyMatrix4(f);
              T.color.copy(v).multiplyScalar(w);
              T.distance = Y;
              T.direction.setFromMatrixPosition(u.matrixWorld);
              d.setFromMatrixPosition(u.target.matrixWorld);
              T.direction.sub(d);
              T.direction.transformDirection(f);
              T.coneCos = Math.cos(u.angle);
              T.penumbraCos = Math.cos(u.angle * (1 - u.penumbra));
              T.decay = u.decay;
              if (T.shadow = u.castShadow) {
                v = u.shadow, T.shadowBias = v.bias, T.shadowRadius = v.radius, T.shadowMapSize = v.mapSize;
              }
              a.spotShadowMap[n] = z;
              a.spotShadowMatrix[n] = u.shadow.matrix;
              a.spot[n] = T;
              n++;
            } else {
              if (u.isRectAreaLight) {
                T = h.get(u), T.color.copy(v).multiplyScalar(w), T.position.setFromMatrixPosition(u.matrixWorld), T.position.applyMatrix4(f), e.identity(), c.copy(u.matrixWorld), c.premultiply(f), e.extractRotation(c), T.halfWidth.set(.5 * u.width, 0, 0), T.halfHeight.set(0, .5 * u.height, 0), T.halfWidth.applyMatrix4(e), T.halfHeight.applyMatrix4(e), a.rectArea[W] = T, W++;
              } else {
                if (u.isPointLight) {
                  T = h.get(u);
                  T.position.setFromMatrixPosition(u.matrixWorld);
                  T.position.applyMatrix4(f);
                  T.color.copy(u.color).multiplyScalar(u.intensity);
                  T.distance = u.distance;
                  T.decay = u.decay;
                  if (T.shadow = u.castShadow) {
                    v = u.shadow, T.shadowBias = v.bias, T.shadowRadius = v.radius, T.shadowMapSize = v.mapSize, T.shadowCameraNear = v.camera.near, T.shadowCameraFar = v.camera.far;
                  }
                  a.pointShadowMap[q] = z;
                  a.pointShadowMatrix[q] = u.shadow.matrix;
                  a.point[q] = T;
                  q++;
                } else {
                  u.isHemisphereLight && (T = h.get(u), T.direction.setFromMatrixPosition(u.matrixWorld), T.direction.transformDirection(f), T.direction.normalize(), T.skyColor.copy(u.color).multiplyScalar(w), T.groundColor.copy(u.groundColor).multiplyScalar(w), a.hemi[m] = T, m++);
                }
              }
            }
          }
        }
      }
      a.ambient[0] = l;
      a.ambient[1] = k;
      a.ambient[2] = F;
      a.directional.length = g;
      a.spot.length = n;
      a.rectArea.length = W;
      a.point.length = q;
      a.hemi.length = m;
      a.hash.stateID = a.id;
      a.hash.directionalLength = g;
      a.hash.pointLength = q;
      a.hash.spotLength = n;
      a.hash.rectAreaLength = W;
      a.hash.hemiLength = m;
      a.hash.shadowsLength = b.length;
    }, state:a};
  }
  function qf() {
    var h = new ng, a = [], b = [];
    return {init:function() {
      a.length = 0;
      b.length = 0;
    }, state:{lightsArray:a, shadowsArray:b, lights:h}, setupLights:function(r) {
      h.setup(a, b, r);
    }, pushLight:function(h) {
      a.push(h);
    }, pushShadow:function(h) {
      b.push(h);
    }};
  }
  function pg() {
    function h(r) {
      r = r.target;
      r.removeEventListener("dispose", h);
      delete a[r.id];
    }
    var a = {};
    return {get:function(r, b) {
      if (void 0 === a[r.id]) {
        var d = new qf;
        a[r.id] = {};
        a[r.id][b.id] = d;
        r.addEventListener("dispose", h);
      } else {
        void 0 === a[r.id][b.id] ? (d = new qf, a[r.id][b.id] = d) : d = a[r.id][b.id];
      }
      return d;
    }, dispose:function() {
      a = {};
    }};
  }
  function Ib(h) {
    X.call(this);
    this.type = "MeshDepthMaterial";
    this.depthPacking = 3200;
    this.morphTargets = this.skinning = !1;
    this.displacementMap = this.alphaMap = this.map = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.lights = this.fog = !1;
    this.setValues(h);
  }
  function Jb(h) {
    X.call(this);
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new f;
    this.nearDistance = 1;
    this.farDistance = 1E3;
    this.morphTargets = this.skinning = !1;
    this.displacementMap = this.alphaMap = this.map = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.lights = this.fog = !1;
    this.setValues(h);
  }
  function rf(h, a, d) {
    function r(a, r, b, d, f, c) {
      var e = a.geometry, l = t, k = a.customDepthMaterial;
      b && (l = u, k = a.customDistanceMaterial);
      k ? l = k : (k = !1, r.morphTargets && (e && e.isBufferGeometry ? k = e.morphAttributes && e.morphAttributes.position && 0 < e.morphAttributes.position.length : e && e.isGeometry && (k = e.morphTargets && 0 < e.morphTargets.length)), a.isSkinnedMesh && !1 === r.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", a), a = a.isSkinnedMesh && r.skinning, e = 0, k && (e |= 1), a && (e |= 2), l = l[e]);
      h.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length && (e = l.uuid, k = r.uuid, a = v[e], void 0 === a && (a = {}, v[e] = a), e = a[k], void 0 === e && (e = l.clone(), a[k] = e), l = e);
      l.visible = r.visible;
      l.wireframe = r.wireframe;
      l.side = null != r.shadowSide ? r.shadowSide : w[r.side];
      l.clipShadows = r.clipShadows;
      l.clippingPlanes = r.clippingPlanes;
      l.clipIntersection = r.clipIntersection;
      l.wireframeLinewidth = r.wireframeLinewidth;
      l.linewidth = r.linewidth;
      b && l.isMeshDistanceMaterial && (l.referencePosition.copy(d), l.nearDistance = f, l.farDistance = c);
      return l;
    }
    function c(b, d, f, l) {
      if (!1 !== b.visible) {
        if (b.layers.test(d.layers) && (b.isMesh || b.isLine || b.isPoints) && b.castShadow && (!b.frustumCulled || e.intersectsObject(b))) {
          b.modelViewMatrix.multiplyMatrices(f.matrixWorldInverse, b.matrixWorld);
          var k = a.update(b), F = b.material;
          if (Array.isArray(F)) {
            for (var g = k.groups, q = 0, m = g.length; q < m; q++) {
              var W = g[q], t = F[W.materialIndex];
              t && t.visible && (t = r(b, t, l, n, f.near, f.far), h.renderBufferDirect(f, null, k, t, b, W));
            }
          } else {
            F.visible && (t = r(b, F, l, n, f.near, f.far), h.renderBufferDirect(f, null, k, t, b, null));
          }
        }
        b = b.children;
        k = 0;
        for (F = b.length; k < F; k++) {
          c(b[k], d, f, l);
        }
      }
    }
    var e = new x, l = new b, k = new g, F = new g(d, d), q = new f, n = new f, t = Array(4), u = Array(4), v = {}, w = {0:1, 1:0, 2:2}, z = [new f(1, 0, 0), new f(-1, 0, 0), new f(0, 0, 1), new f(0, 0, -1), new f(0, 1, 0), new f(0, -1, 0)], y = [new f(0, 1, 0), new f(0, 1, 0), new f(0, 1, 0), new f(0, 1, 0), new f(0, 0, 1), new f(0, 0, -1)], D = [new p, new p, new p, new p, new p, new p];
    for (d = 0; 4 !== d; ++d) {
      var C = 0 !== (d & 1), B = 0 !== (d & 2), A = new Ib({depthPacking:3201, morphTargets:C, skinning:B});
      t[d] = A;
      C = new Jb({morphTargets:C, skinning:B});
      u[d] = C;
    }
    var E = this;
    this.enabled = !1;
    this.autoUpdate = !0;
    this.needsUpdate = !1;
    this.type = 1;
    this.render = function(a, r, b) {
      if (!1 !== E.enabled && (!1 !== E.autoUpdate || !1 !== E.needsUpdate) && 0 !== a.length) {
        var d = h.getRenderTarget(), f = h.state;
        f.setBlending(0);
        f.buffers.color.setClear(1, 1, 1, 1);
        f.buffers.depth.setTest(!0);
        f.setScissorTest(!1);
        for (var g, W = 0, t = a.length; W < t; W++) {
          var u = a[W];
          g = u.shadow;
          var p = u && u.isPointLight;
          if (void 0 === g) {
            console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
          } else {
            var v = g.camera;
            k.copy(g.mapSize);
            k.min(F);
            if (p) {
              var w = k.x, Y = k.y;
              D[0].set(2 * w, Y, w, Y);
              D[1].set(0, Y, w, Y);
              D[2].set(3 * w, Y, w, Y);
              D[3].set(w, Y, w, Y);
              D[4].set(3 * w, 0, w, Y);
              D[5].set(w, 0, w, Y);
              k.x *= 4;
              k.y *= 2;
            }
            null === g.map && (g.map = new m(k.x, k.y, {minFilter:1003, magFilter:1003, format:1023}), g.map.texture.name = u.name + ".shadowMap", v.updateProjectionMatrix());
            g.isSpotLightShadow && g.update(u);
            w = g.map;
            Y = g.matrix;
            n.setFromMatrixPosition(u.matrixWorld);
            v.position.copy(n);
            p ? (g = 6, Y.makeTranslation(-n.x, -n.y, -n.z)) : (g = 1, q.setFromMatrixPosition(u.target.matrixWorld), v.lookAt(q), v.updateMatrixWorld(), Y.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), Y.multiply(v.projectionMatrix), Y.multiply(v.matrixWorldInverse));
            h.setRenderTarget(w);
            h.clear();
            for (u = 0; u < g; u++) {
              p && (q.copy(v.position), q.add(z[u]), v.up.copy(y[u]), v.lookAt(q), v.updateMatrixWorld(), f.viewport(D[u])), l.multiplyMatrices(v.projectionMatrix, v.matrixWorldInverse), e.setFromMatrix(l), c(r, b, v, p);
            }
          }
        }
        E.needsUpdate = !1;
        h.setRenderTarget(d);
      }
    };
  }
  function qg(h, a, b, d) {
    function r(a, r, b) {
      var d = new Uint8Array(4), f = h.createTexture();
      h.bindTexture(a, f);
      h.texParameteri(a, 10241, 9728);
      h.texParameteri(a, 10240, 9728);
      for (a = 0; a < b; a++) {
        h.texImage2D(r + a, 0, 6408, 1, 1, 0, 6408, 5121, d);
      }
      return f;
    }
    function f(r, b) {
      u[r] = 1;
      0 === v[r] && (h.enableVertexAttribArray(r), v[r] = 1);
      w[r] !== b && ((d.isWebGL2 ? h : a.get("ANGLE_instanced_arrays"))[d.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](r, b), w[r] = b);
    }
    function c(a) {
      !0 !== z[a] && (h.enable(a), z[a] = !0);
    }
    function e(a) {
      !1 !== z[a] && (h.disable(a), z[a] = !1);
    }
    function l(a, r, d, f, l, k, F, g) {
      if (0 === a) {
        D && (e(3042), D = !1);
      } else {
        if (D || (c(3042), D = !0), 5 !== a) {
          if (a !== C || g !== O) {
            if (100 !== B || 100 !== G) {
              h.blendEquation(32774), G = B = 100;
            }
            if (g) {
              switch(a) {
                case 1:
                  h.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case 2:
                  h.blendFunc(1, 1);
                  break;
                case 3:
                  h.blendFuncSeparate(0, 0, 769, 771);
                  break;
                case 4:
                  h.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", a);
              }
            } else {
              switch(a) {
                case 1:
                  h.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case 2:
                  h.blendFunc(770, 1);
                  break;
                case 3:
                  h.blendFunc(0, 769);
                  break;
                case 4:
                  h.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", a);
              }
            }
            H = M = E = A = null;
            C = a;
            O = g;
          }
        } else {
          l = l || r;
          k = k || d;
          F = F || f;
          if (r !== B || l !== G) {
            h.blendEquationSeparate(b.convert(r), b.convert(l)), B = r, G = l;
          }
          if (d !== A || f !== E || k !== M || F !== H) {
            h.blendFuncSeparate(b.convert(d), b.convert(f), b.convert(k), b.convert(F)), A = d, E = f, M = k, H = F;
          }
          C = a;
          O = null;
        }
      }
    }
    function k(a) {
      P !== a && (a ? h.frontFace(2304) : h.frontFace(2305), P = a);
    }
    function F(a) {
      0 !== a ? (c(2884), a !== J && (1 === a ? h.cullFace(1029) : 2 === a ? h.cullFace(1028) : h.cullFace(1032))) : e(2884);
      J = a;
    }
    function g(a, r, b) {
      if (a) {
        if (c(32823), N !== r || I !== b) {
          h.polygonOffset(r, b), N = r, I = b;
        }
      } else {
        e(32823);
      }
    }
    function q(a) {
      void 0 === a && (a = 33984 + K - 1);
      L !== a && (h.activeTexture(a), L = a);
    }
    var n = new function() {
      var a = !1, r = new p, b = null, d = new p(0, 0, 0, 0);
      return {setMask:function(r) {
        b === r || a || (h.colorMask(r, r, r, r), b = r);
      }, setLocked:function(h) {
        a = h;
      }, setClear:function(a, b, f, c, e) {
        !0 === e && (a *= c, b *= c, f *= c);
        r.set(a, b, f, c);
        !1 === d.equals(r) && (h.clearColor(a, b, f, c), d.copy(r));
      }, reset:function() {
        a = !1;
        b = null;
        d.set(-1, 0, 0, 0);
      }};
    }, t = new function() {
      var a = !1, r = null, b = null, d = null;
      return {setTest:function(h) {
        h ? c(2929) : e(2929);
      }, setMask:function(b) {
        r === b || a || (h.depthMask(b), r = b);
      }, setFunc:function(a) {
        if (b !== a) {
          if (a) {
            switch(a) {
              case 0:
                h.depthFunc(512);
                break;
              case 1:
                h.depthFunc(519);
                break;
              case 2:
                h.depthFunc(513);
                break;
              case 3:
                h.depthFunc(515);
                break;
              case 4:
                h.depthFunc(514);
                break;
              case 5:
                h.depthFunc(518);
                break;
              case 6:
                h.depthFunc(516);
                break;
              case 7:
                h.depthFunc(517);
                break;
              default:
                h.depthFunc(515);
            }
          } else {
            h.depthFunc(515);
          }
          b = a;
        }
      }, setLocked:function(h) {
        a = h;
      }, setClear:function(a) {
        d !== a && (h.clearDepth(a), d = a);
      }, reset:function() {
        a = !1;
        d = b = r = null;
      }};
    }, W = new function() {
      var a = !1, r = null, b = null, d = null, f = null, l = null, k = null, F = null, g = null;
      return {setTest:function(h) {
        h ? c(2960) : e(2960);
      }, setMask:function(b) {
        r === b || a || (h.stencilMask(b), r = b);
      }, setFunc:function(a, r, c) {
        if (b !== a || d !== r || f !== c) {
          h.stencilFunc(a, r, c), b = a, d = r, f = c;
        }
      }, setOp:function(a, r, b) {
        if (l !== a || k !== r || F !== b) {
          h.stencilOp(a, r, b), l = a, k = r, F = b;
        }
      }, setLocked:function(h) {
        a = h;
      }, setClear:function(a) {
        g !== a && (h.clearStencil(a), g = a);
      }, reset:function() {
        a = !1;
        g = F = k = l = f = d = b = r = null;
      }};
    }, m = h.getParameter(34921), u = new Uint8Array(m), v = new Uint8Array(m), w = new Uint8Array(m), z = {}, y = null, x = null, D = null, C = null, B = null, A = null, E = null, G = null, M = null, H = null, O = !1, P = null, J = null, U = null, N = null, I = null, K = h.getParameter(35661), Q = !1;
    m = 0;
    m = h.getParameter(7938);
    -1 !== m.indexOf("WebGL") ? (m = parseFloat(/^WebGL ([0-9])/.exec(m)[1]), Q = 1 <= m) : -1 !== m.indexOf("OpenGL ES") && (m = parseFloat(/^OpenGL ES ([0-9])/.exec(m)[1]), Q = 2 <= m);
    var L = null, aa = {}, S = new p, V = new p, R = {};
    R[3553] = r(3553, 3553, 1);
    R[34067] = r(34067, 34069, 6);
    n.setClear(0, 0, 0, 1);
    t.setClear(1);
    W.setClear(0);
    c(2929);
    t.setFunc(3);
    k(!1);
    F(1);
    c(2884);
    l(0);
    return {buffers:{color:n, depth:t, stencil:W}, initAttributes:function() {
      for (var h = 0, a = u.length; h < a; h++) {
        u[h] = 0;
      }
    }, enableAttribute:function(h) {
      f(h, 0);
    }, enableAttributeAndDivisor:f, disableUnusedAttributes:function() {
      for (var a = 0, r = v.length; a !== r; ++a) {
        v[a] !== u[a] && (h.disableVertexAttribArray(a), v[a] = 0);
      }
    }, enable:c, disable:e, getCompressedTextureFormats:function() {
      if (null === y && (y = [], a.get("WEBGL_compressed_texture_pvrtc") || a.get("WEBGL_compressed_texture_s3tc") || a.get("WEBGL_compressed_texture_etc1") || a.get("WEBGL_compressed_texture_astc"))) {
        for (var r = h.getParameter(34467), b = 0; b < r.length; b++) {
          y.push(r[b]);
        }
      }
      return y;
    }, useProgram:function(a) {
      return x !== a ? (h.useProgram(a), x = a, !0) : !1;
    }, setBlending:l, setMaterial:function(h, a) {
      2 === h.side ? e(2884) : c(2884);
      var r = 1 === h.side;
      a && (r = !r);
      k(r);
      1 === h.blending && !1 === h.transparent ? l(0) : l(h.blending, h.blendEquation, h.blendSrc, h.blendDst, h.blendEquationAlpha, h.blendSrcAlpha, h.blendDstAlpha, h.premultipliedAlpha);
      t.setFunc(h.depthFunc);
      t.setTest(h.depthTest);
      t.setMask(h.depthWrite);
      n.setMask(h.colorWrite);
      g(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits);
    }, setFlipSided:k, setCullFace:F, setLineWidth:function(a) {
      a !== U && (Q && h.lineWidth(a), U = a);
    }, setPolygonOffset:g, setScissorTest:function(h) {
      h ? c(3089) : e(3089);
    }, activeTexture:q, bindTexture:function(a, r) {
      null === L && q();
      var b = aa[L];
      void 0 === b && (b = {type:void 0, texture:void 0}, aa[L] = b);
      if (b.type !== a || b.texture !== r) {
        h.bindTexture(a, r || R[a]), b.type = a, b.texture = r;
      }
    }, compressedTexImage2D:function() {
      try {
        h.compressedTexImage2D.apply(h, arguments);
      } catch (Vc) {
        console.error("THREE.WebGLState:", Vc);
      }
    }, texImage2D:function() {
      try {
        h.texImage2D.apply(h, arguments);
      } catch (Vc) {
        console.error("THREE.WebGLState:", Vc);
      }
    }, texImage3D:function() {
      try {
        h.texImage3D.apply(h, arguments);
      } catch (Vc) {
        console.error("THREE.WebGLState:", Vc);
      }
    }, scissor:function(a) {
      !1 === S.equals(a) && (h.scissor(a.x, a.y, a.z, a.w), S.copy(a));
    }, viewport:function(a) {
      !1 === V.equals(a) && (h.viewport(a.x, a.y, a.z, a.w), V.copy(a));
    }, reset:function() {
      for (var a = 0; a < v.length; a++) {
        1 === v[a] && (h.disableVertexAttribArray(a), v[a] = 0);
      }
      z = {};
      L = y = null;
      aa = {};
      J = P = C = x = null;
      n.reset();
      t.reset();
      W.reset();
    }};
  }
  function rg(h, a, b, d, f, c, e) {
    function r(h, a) {
      return x ? new OffscreenCanvas(h, a) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    }
    function l(h, a, b, d) {
      var f = 1;
      if (h.width > d || h.height > d) {
        f = d / Math.max(h.width, h.height);
      }
      if (1 > f || !0 === a) {
        if (h instanceof ImageBitmap || h instanceof HTMLImageElement || h instanceof HTMLCanvasElement) {
          return d = a ? ia.floorPowerOfTwo : Math.floor, a = d(f * h.width), f = d(f * h.height), void 0 === y && (y = r(a, f)), b = b ? r(a, f) : y, b.width = a, b.height = f, b.getContext("2d").drawImage(h, 0, 0, a, f), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + h.width + "x" + h.height + ") to (" + a + "x" + f + ")."), x ? b.transferToImageBitmap() : b;
        }
        "data" in h && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + h.width + "x" + h.height + ").");
      }
      return h;
    }
    function k(h) {
      return ia.isPowerOfTwo(h.width) && ia.isPowerOfTwo(h.height);
    }
    function F(h, a) {
      return h.generateMipmaps && a && 1003 !== h.minFilter && 1006 !== h.minFilter;
    }
    function g(a, r, b, f) {
      h.generateMipmap(a);
      d.get(r).__maxMipLevel = Math.log(Math.max(b, f)) * Math.LOG2E;
    }
    function q(h, r) {
      if (!f.isWebGL2) {
        return h;
      }
      var b = h;
      6403 === h && (5126 === r && (b = 33326), 5131 === r && (b = 33325), 5121 === r && (b = 33321));
      6407 === h && (5126 === r && (b = 34837), 5131 === r && (b = 34843), 5121 === r && (b = 32849));
      6408 === h && (5126 === r && (b = 34836), 5131 === r && (b = 34842), 5121 === r && (b = 32856));
      33325 === b || 33326 === b || 34842 === b || 34836 === b ? a.get("EXT_color_buffer_float") : (34843 === b || 34837 === b) && console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.");
      return b;
    }
    function n(h) {
      return 1003 === h || 1004 === h || 1005 === h ? 9728 : 9729;
    }
    function m(a) {
      a = a.target;
      a.removeEventListener("dispose", m);
      var r = d.get(a);
      void 0 !== r.__webglInit && (h.deleteTexture(r.__webglTexture), d.remove(a));
      a.isVideoTexture && delete z[a.id];
      e.memory.textures--;
    }
    function t(a) {
      a = a.target;
      a.removeEventListener("dispose", t);
      var r = d.get(a), b = d.get(a.texture);
      if (a) {
        void 0 !== b.__webglTexture && h.deleteTexture(b.__webglTexture);
        a.depthTexture && a.depthTexture.dispose();
        if (a.isWebGLRenderTargetCube) {
          for (b = 0; 6 > b; b++) {
            h.deleteFramebuffer(r.__webglFramebuffer[b]), r.__webglDepthbuffer && h.deleteRenderbuffer(r.__webglDepthbuffer[b]);
          }
        } else {
          h.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && h.deleteRenderbuffer(r.__webglDepthbuffer);
        }
        d.remove(a.texture);
        d.remove(a);
      }
      e.memory.textures--;
    }
    function u(h, a) {
      var r = d.get(h);
      if (h.isVideoTexture) {
        var f = h.id, c = e.render.frame;
        z[f] !== c && (z[f] = c, h.update());
      }
      if (0 < h.version && r.__version !== h.version) {
        if (f = h.image, void 0 === f) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
        } else {
          if (!1 === f.complete) {
            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
          } else {
            v(r, h, a);
            return;
          }
        }
      }
      b.activeTexture(33984 + a);
      b.bindTexture(3553, r.__webglTexture);
    }
    function W(r, b, e) {
      e ? (h.texParameteri(r, 10242, c.convert(b.wrapS)), h.texParameteri(r, 10243, c.convert(b.wrapT)), 32879 === r && h.texParameteri(r, 32882, c.convert(b.wrapR)), h.texParameteri(r, 10240, c.convert(b.magFilter)), h.texParameteri(r, 10241, c.convert(b.minFilter))) : (h.texParameteri(r, 10242, 33071), h.texParameteri(r, 10243, 33071), 32879 === r && h.texParameteri(r, 32882, 33071), 1001 === b.wrapS && 1001 === b.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), 
      h.texParameteri(r, 10240, n(b.magFilter)), h.texParameteri(r, 10241, n(b.minFilter)), 1003 !== b.minFilter && 1006 !== b.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
      !(e = a.get("EXT_texture_filter_anisotropic")) || 1015 === b.type && null === a.get("OES_texture_float_linear") || 1016 === b.type && null === (f.isWebGL2 || a.get("OES_texture_half_float_linear")) || !(1 < b.anisotropy || d.get(b).__currentAnisotropy) || (h.texParameterf(r, e.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, f.getMaxAnisotropy())), d.get(b).__currentAnisotropy = b.anisotropy);
    }
    function p(a, r) {
      void 0 === a.__webglInit && (a.__webglInit = !0, r.addEventListener("dispose", m), a.__webglTexture = h.createTexture(), e.memory.textures++);
    }
    function v(a, r, d) {
      var e = r.isDataTexture3D ? 32879 : 3553;
      p(a, r);
      b.activeTexture(33984 + d);
      b.bindTexture(e, a.__webglTexture);
      h.pixelStorei(37440, r.flipY);
      h.pixelStorei(37441, r.premultiplyAlpha);
      h.pixelStorei(3317, r.unpackAlignment);
      d = (d = f.isWebGL2 ? !1 : 1001 !== r.wrapS || 1001 !== r.wrapT || 1003 !== r.minFilter && 1006 !== r.minFilter) && !1 === k(r.image);
      d = l(r.image, d, !1, f.maxTextureSize);
      var n = k(d) || f.isWebGL2, m = c.convert(r.format), t = c.convert(r.type), u = q(m, t);
      W(e, r, n);
      var v = r.mipmaps;
      if (r.isDepthTexture) {
        u = 6402;
        if (1015 === r.type) {
          if (!f.isWebGL2) {
            throw Error("Float Depth Texture only supported in WebGL2.0");
          }
          u = 36012;
        } else {
          f.isWebGL2 && (u = 33189);
        }
        1026 === r.format && 6402 === u && 1012 !== r.type && 1014 !== r.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = 1012, t = c.convert(r.type));
        1027 === r.format && (u = 34041, 1020 !== r.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = 1020, t = c.convert(r.type)));
        b.texImage2D(3553, 0, u, d.width, d.height, 0, m, t, null);
      } else {
        if (r.isDataTexture) {
          if (0 < v.length && n) {
            for (var w = 0, Y = v.length; w < Y; w++) {
              e = v[w], b.texImage2D(3553, w, u, e.width, e.height, 0, m, t, e.data);
            }
            r.generateMipmaps = !1;
            a.__maxMipLevel = v.length - 1;
          } else {
            b.texImage2D(3553, 0, u, d.width, d.height, 0, m, t, d.data), a.__maxMipLevel = 0;
          }
        } else {
          if (r.isCompressedTexture) {
            w = 0;
            for (Y = v.length; w < Y; w++) {
              e = v[w], 1023 !== r.format && 1022 !== r.format ? -1 < b.getCompressedTextureFormats().indexOf(m) ? b.compressedTexImage2D(3553, w, u, e.width, e.height, 0, e.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : b.texImage2D(3553, w, u, e.width, e.height, 0, m, t, e.data);
            }
            a.__maxMipLevel = v.length - 1;
          } else {
            if (r.isDataTexture3D) {
              b.texImage3D(32879, 0, u, d.width, d.height, d.depth, 0, m, t, d.data), a.__maxMipLevel = 0;
            } else {
              if (0 < v.length && n) {
                w = 0;
                for (Y = v.length; w < Y; w++) {
                  e = v[w], b.texImage2D(3553, w, u, m, t, e);
                }
                r.generateMipmaps = !1;
                a.__maxMipLevel = v.length - 1;
              } else {
                b.texImage2D(3553, 0, u, m, t, d), a.__maxMipLevel = 0;
              }
            }
          }
        }
      }
      F(r, n) && g(3553, r, d.width, d.height);
      a.__version = r.version;
      if (r.onUpdate) {
        r.onUpdate(r);
      }
    }
    function w(a, r, f, e) {
      var l = c.convert(r.texture.format), k = c.convert(r.texture.type), F = q(l, k);
      b.texImage2D(e, 0, F, r.width, r.height, 0, l, k, null);
      h.bindFramebuffer(36160, a);
      h.framebufferTexture2D(36160, f, e, d.get(r.texture).__webglTexture, 0);
      h.bindFramebuffer(36160, null);
    }
    function Y(a, r, b) {
      h.bindRenderbuffer(36161, a);
      if (r.depthBuffer && !r.stencilBuffer) {
        b ? (b = T(r), h.renderbufferStorageMultisample(36161, b, 33189, r.width, r.height)) : h.renderbufferStorage(36161, 33189, r.width, r.height), h.framebufferRenderbuffer(36160, 36096, 36161, a);
      } else {
        if (r.depthBuffer && r.stencilBuffer) {
          b ? (b = T(r), h.renderbufferStorageMultisample(36161, b, 34041, r.width, r.height)) : h.renderbufferStorage(36161, 34041, r.width, r.height), h.framebufferRenderbuffer(36160, 33306, 36161, a);
        } else {
          a = c.convert(r.texture.format);
          var d = c.convert(r.texture.type);
          a = q(a, d);
          b ? (b = T(r), h.renderbufferStorageMultisample(36161, b, a, r.width, r.height)) : h.renderbufferStorage(36161, a, r.width, r.height);
        }
      }
      h.bindRenderbuffer(36161, null);
    }
    function T(h) {
      return f.isWebGL2 && h.isWebGLMultisampleRenderTarget ? Math.min(f.maxSamples, h.samples) : 0;
    }
    var z = {}, y, x = "undefined" !== typeof OffscreenCanvas;
    this.setTexture2D = u;
    this.setTexture3D = function(h, a) {
      var r = d.get(h);
      0 < h.version && r.__version !== h.version ? v(r, h, a) : (b.activeTexture(33984 + a), b.bindTexture(32879, r.__webglTexture));
    };
    this.setTextureCube = function(a, r) {
      var e = d.get(a);
      if (6 === a.image.length) {
        if (0 < a.version && e.__version !== a.version) {
          p(e, a);
          b.activeTexture(33984 + r);
          b.bindTexture(34067, e.__webglTexture);
          h.pixelStorei(37440, a.flipY);
          r = a && a.isCompressedTexture;
          for (var n = a.image[0] && a.image[0].isDataTexture, m = [], t = 0; 6 > t; t++) {
            m[t] = r || n ? n ? a.image[t].image : a.image[t] : l(a.image[t], !1, !0, f.maxCubemapSize);
          }
          var u = m[0], v = k(u) || f.isWebGL2, w = c.convert(a.format), Y = c.convert(a.type), T = q(w, Y);
          W(34067, a, v);
          for (t = 0; 6 > t; t++) {
            if (r) {
              for (var z, y = m[t].mipmaps, x = 0, ya = y.length; x < ya; x++) {
                z = y[x], 1023 !== a.format && 1022 !== a.format ? -1 < b.getCompressedTextureFormats().indexOf(w) ? b.compressedTexImage2D(34069 + t, x, T, z.width, z.height, 0, z.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : b.texImage2D(34069 + t, x, T, z.width, z.height, 0, w, Y, z.data);
              }
            } else {
              n ? b.texImage2D(34069 + t, 0, T, m[t].width, m[t].height, 0, w, Y, m[t].data) : b.texImage2D(34069 + t, 0, T, w, Y, m[t]);
            }
          }
          e.__maxMipLevel = r ? y.length - 1 : 0;
          F(a, v) && g(34067, a, u.width, u.height);
          e.__version = a.version;
          if (a.onUpdate) {
            a.onUpdate(a);
          }
        } else {
          b.activeTexture(33984 + r), b.bindTexture(34067, e.__webglTexture);
        }
      }
    };
    this.setTextureCubeDynamic = function(h, a) {
      b.activeTexture(33984 + a);
      b.bindTexture(34067, d.get(h).__webglTexture);
    };
    this.setupRenderTarget = function(a) {
      var r = d.get(a), l = d.get(a.texture);
      a.addEventListener("dispose", t);
      l.__webglTexture = h.createTexture();
      e.memory.textures++;
      var n = ! 0 === a.isWebGLRenderTargetCube, m = !0 === a.isWebGLMultisampleRenderTarget, p = k(a) || f.isWebGL2;
      if (n) {
        for (r.__webglFramebuffer = [], m = 0; 6 > m; m++) {
          r.__webglFramebuffer[m] = h.createFramebuffer();
        }
      } else {
        if (r.__webglFramebuffer = h.createFramebuffer(), m) {
          if (f.isWebGL2) {
            r.__webglMultisampledFramebuffer = h.createFramebuffer();
            r.__webglColorRenderbuffer = h.createRenderbuffer();
            h.bindRenderbuffer(36161, r.__webglColorRenderbuffer);
            m = c.convert(a.texture.format);
            var v = c.convert(a.texture.type);
            m = q(m, v);
            v = T(a);
            h.renderbufferStorageMultisample(36161, v, m, a.width, a.height);
            h.bindFramebuffer(36160, r.__webglMultisampledFramebuffer);
            h.framebufferRenderbuffer(36160, 36064, 36161, r.__webglColorRenderbuffer);
            h.bindRenderbuffer(36161, null);
            a.depthBuffer && (r.__webglDepthRenderbuffer = h.createRenderbuffer(), Y(r.__webglDepthRenderbuffer, a, !0));
            h.bindFramebuffer(36160, null);
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
          }
        }
      }
      if (n) {
        b.bindTexture(34067, l.__webglTexture);
        W(34067, a.texture, p);
        for (m = 0; 6 > m; m++) {
          w(r.__webglFramebuffer[m], a, 36064, 34069 + m);
        }
        F(a.texture, p) && g(34067, a.texture, a.width, a.height);
        b.bindTexture(34067, null);
      } else {
        b.bindTexture(3553, l.__webglTexture), W(3553, a.texture, p), w(r.__webglFramebuffer, a, 36064, 3553), F(a.texture, p) && g(3553, a.texture, a.width, a.height), b.bindTexture(3553, null);
      }
      if (a.depthBuffer) {
        r = d.get(a);
        l = !0 === a.isWebGLRenderTargetCube;
        if (a.depthTexture) {
          if (l) {
            throw Error("target.depthTexture not supported in Cube render targets");
          }
          if (a && a.isWebGLRenderTargetCube) {
            throw Error("Depth Texture with cube render targets is not supported");
          }
          h.bindFramebuffer(36160, r.__webglFramebuffer);
          if (!a.depthTexture || !a.depthTexture.isDepthTexture) {
            throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          }
          d.get(a.depthTexture).__webglTexture && a.depthTexture.image.width === a.width && a.depthTexture.image.height === a.height || (a.depthTexture.image.width = a.width, a.depthTexture.image.height = a.height, a.depthTexture.needsUpdate = !0);
          u(a.depthTexture, 0);
          r = d.get(a.depthTexture).__webglTexture;
          if (1026 === a.depthTexture.format) {
            h.framebufferTexture2D(36160, 36096, 3553, r, 0);
          } else {
            if (1027 === a.depthTexture.format) {
              h.framebufferTexture2D(36160, 33306, 3553, r, 0);
            } else {
              throw Error("Unknown depthTexture format");
            }
          }
        } else {
          if (l) {
            for (r.__webglDepthbuffer = [], l = 0; 6 > l; l++) {
              h.bindFramebuffer(36160, r.__webglFramebuffer[l]), r.__webglDepthbuffer[l] = h.createRenderbuffer(), Y(r.__webglDepthbuffer[l], a);
            }
          } else {
            h.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = h.createRenderbuffer(), Y(r.__webglDepthbuffer, a);
          }
        }
        h.bindFramebuffer(36160, null);
      }
    };
    this.updateRenderTargetMipmap = function(h) {
      var a = h.texture, r = k(h) || f.isWebGL2;
      if (F(a, r)) {
        r = h.isWebGLRenderTargetCube ? 34067 : 3553;
        var c = d.get(a).__webglTexture;
        b.bindTexture(r, c);
        g(r, a, h.width, h.height);
        b.bindTexture(r, null);
      }
    };
    this.updateMultisampleRenderTarget = function(a) {
      if (a.isWebGLMultisampleRenderTarget) {
        if (f.isWebGL2) {
          var r = d.get(a);
          h.bindFramebuffer(36008, r.__webglMultisampledFramebuffer);
          h.bindFramebuffer(36009, r.__webglFramebuffer);
          r = a.width;
          var b = a.height, c = 16384;
          a.depthBuffer && (c |= 256);
          a.stencilBuffer && (c |= 1024);
          h.blitFramebuffer(0, 0, r, b, 0, 0, r, b, c, 9728);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    };
  }
  function sf(h, a, b) {
    return {convert:function(h) {
      if (1E3 === h) {
        return 10497;
      }
      if (1001 === h) {
        return 33071;
      }
      if (1002 === h) {
        return 33648;
      }
      if (1003 === h) {
        return 9728;
      }
      if (1004 === h) {
        return 9984;
      }
      if (1005 === h) {
        return 9986;
      }
      if (1006 === h) {
        return 9729;
      }
      if (1007 === h) {
        return 9985;
      }
      if (1008 === h) {
        return 9987;
      }
      if (1009 === h) {
        return 5121;
      }
      if (1017 === h) {
        return 32819;
      }
      if (1018 === h) {
        return 32820;
      }
      if (1019 === h) {
        return 33635;
      }
      if (1010 === h) {
        return 5120;
      }
      if (1011 === h) {
        return 5122;
      }
      if (1012 === h) {
        return 5123;
      }
      if (1013 === h) {
        return 5124;
      }
      if (1014 === h) {
        return 5125;
      }
      if (1015 === h) {
        return 5126;
      }
      if (1016 === h) {
        if (b.isWebGL2) {
          return 5131;
        }
        var r = a.get("OES_texture_half_float");
        if (null !== r) {
          return r.HALF_FLOAT_OES;
        }
      }
      if (1021 === h) {
        return 6406;
      }
      if (1022 === h) {
        return 6407;
      }
      if (1023 === h) {
        return 6408;
      }
      if (1024 === h) {
        return 6409;
      }
      if (1025 === h) {
        return 6410;
      }
      if (1026 === h) {
        return 6402;
      }
      if (1027 === h) {
        return 34041;
      }
      if (1028 === h) {
        return 6403;
      }
      if (100 === h) {
        return 32774;
      }
      if (101 === h) {
        return 32778;
      }
      if (102 === h) {
        return 32779;
      }
      if (200 === h) {
        return 0;
      }
      if (201 === h) {
        return 1;
      }
      if (202 === h) {
        return 768;
      }
      if (203 === h) {
        return 769;
      }
      if (204 === h) {
        return 770;
      }
      if (205 === h) {
        return 771;
      }
      if (206 === h) {
        return 772;
      }
      if (207 === h) {
        return 773;
      }
      if (208 === h) {
        return 774;
      }
      if (209 === h) {
        return 775;
      }
      if (210 === h) {
        return 776;
      }
      if (33776 === h || 33777 === h || 33778 === h || 33779 === h) {
        if (r = a.get("WEBGL_compressed_texture_s3tc"), null !== r) {
          if (33776 === h) {
            return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
          }
          if (33777 === h) {
            return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          }
          if (33778 === h) {
            return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          }
          if (33779 === h) {
            return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
        }
      }
      if (35840 === h || 35841 === h || 35842 === h || 35843 === h) {
        if (r = a.get("WEBGL_compressed_texture_pvrtc"), null !== r) {
          if (35840 === h) {
            return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          }
          if (35841 === h) {
            return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          }
          if (35842 === h) {
            return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          }
          if (35843 === h) {
            return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
        }
      }
      if (36196 === h && (r = a.get("WEBGL_compressed_texture_etc1"), null !== r)) {
        return r.COMPRESSED_RGB_ETC1_WEBGL;
      }
      if (37808 === h || 37809 === h || 37810 === h || 37811 === h || 37812 === h || 37813 === h || 37814 === h || 37815 === h || 37816 === h || 37817 === h || 37818 === h || 37819 === h || 37820 === h || 37821 === h) {
        if (r = a.get("WEBGL_compressed_texture_astc"), null !== r) {
          return h;
        }
      }
      if (103 === h || 104 === h) {
        if (b.isWebGL2) {
          if (103 === h) {
            return 32775;
          }
          if (104 === h) {
            return 32776;
          }
        }
        r = a.get("EXT_blend_minmax");
        if (null !== r) {
          if (103 === h) {
            return r.MIN_EXT;
          }
          if (104 === h) {
            return r.MAX_EXT;
          }
        }
      }
      if (1020 === h) {
        if (b.isWebGL2) {
          return 34042;
        }
        r = a.get("WEBGL_depth_texture");
        if (null !== r) {
          return r.UNSIGNED_INT_24_8_WEBGL;
        }
      }
      return 0;
    }};
  }
  function jc() {
    G.call(this);
    this.type = "Group";
  }
  function jb() {
    G.call(this);
    this.type = "Camera";
    this.matrixWorldInverse = new b;
    this.projectionMatrix = new b;
    this.projectionMatrixInverse = new b;
  }
  function va(h, a, b, d) {
    jb.call(this);
    this.type = "PerspectiveCamera";
    this.fov = void 0 !== h ? h : 50;
    this.zoom = 1;
    this.near = void 0 !== b ? b : .1;
    this.far = void 0 !== d ? d : 2E3;
    this.focus = 10;
    this.aspect = void 0 !== a ? a : 1;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  function Wc(h) {
    va.call(this);
    this.cameras = h || [];
  }
  function tf(h, a, b) {
    uf.setFromMatrixPosition(a.matrixWorld);
    vf.setFromMatrixPosition(b.matrixWorld);
    var r = uf.distanceTo(vf), d = a.projectionMatrix.elements, f = b.projectionMatrix.elements, c = d[14] / (d[10] - 1);
    b = d[14] / (d[10] + 1);
    var e = (d[9] + 1) / d[5], l = (d[9] - 1) / d[5], k = (d[8] - 1) / d[0], F = (f[8] + 1) / f[0];
    d = c * k;
    f = c * F;
    F = r / (-k + F);
    k = F * -k;
    a.matrixWorld.decompose(h.position, h.quaternion, h.scale);
    h.translateX(k);
    h.translateZ(F);
    h.matrixWorld.compose(h.position, h.quaternion, h.scale);
    h.matrixWorldInverse.getInverse(h.matrixWorld);
    a = c + F;
    c = b + F;
    h.projectionMatrix.makePerspective(d - k, f + (r - k), e * b / c * a, l * b / c * a, a, c);
  }
  function wf(h) {
    function a() {
      return null !== l && !0 === l.isPresenting;
    }
    function d() {
      if (a()) {
        var r = l.getEyeParameters("left"), b = r.renderWidth * u;
        r = r.renderHeight * u;
        E = h.getPixelRatio();
        h.getSize(A);
        h.setDrawingBufferSize(2 * b, r, 1);
        M.start();
      } else {
        c.enabled && h.setDrawingBufferSize(A.width, A.height, E), M.stop();
      }
    }
    var c = this, l = null, k = null, q = null, n = [], m = new b, t = new b, u = 1, v = "stage";
    "undefined" !== typeof window && "VRFrameData" in window && (k = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", d, !1));
    var w = new b, z = new e, y = new f, x = new va;
    x.bounds = new p(0, 0, .5, 1);
    x.layers.enable(1);
    var D = new va;
    D.bounds = new p(.5, 0, .5, 1);
    D.layers.enable(2);
    var B = new Wc([x, D]);
    B.layers.enable(1);
    B.layers.enable(2);
    var A = new g, E, G = [];
    this.enabled = !1;
    this.getController = function(h) {
      var a = n[h];
      void 0 === a && (a = new jc, a.matrixAutoUpdate = !1, a.visible = !1, n[h] = a);
      return a;
    };
    this.getDevice = function() {
      return l;
    };
    this.setDevice = function(h) {
      void 0 !== h && (l = h);
      M.setContext(h);
    };
    this.setFramebufferScaleFactor = function(h) {
      u = h;
    };
    this.setFrameOfReferenceType = function(h) {
      v = h;
    };
    this.setPoseTarget = function(h) {
      void 0 !== h && (q = h);
    };
    this.getCamera = function(h) {
      var a = "stage" === v ? 1.6 : 0;
      if (null === l) {
        return h.position.set(0, a, 0), h;
      }
      l.depthNear = h.near;
      l.depthFar = h.far;
      l.getFrameData(k);
      if ("stage" === v) {
        var r = l.stageParameters;
        r ? m.fromArray(r.sittingToStandingTransform) : m.makeTranslation(0, a, 0);
      }
      a = k.pose;
      r = null !== q ? q : h;
      r.matrix.copy(m);
      r.matrix.decompose(r.position, r.quaternion, r.scale);
      null !== a.orientation && (z.fromArray(a.orientation), r.quaternion.multiply(z));
      null !== a.position && (z.setFromRotationMatrix(m), y.fromArray(a.position), y.applyQuaternion(z), r.position.add(y));
      r.updateMatrixWorld();
      if (!1 === l.isPresenting) {
        return h;
      }
      x.near = h.near;
      D.near = h.near;
      x.far = h.far;
      D.far = h.far;
      x.matrixWorldInverse.fromArray(k.leftViewMatrix);
      D.matrixWorldInverse.fromArray(k.rightViewMatrix);
      t.getInverse(m);
      "stage" === v && (x.matrixWorldInverse.multiply(t), D.matrixWorldInverse.multiply(t));
      h = r.parent;
      null !== h && (w.getInverse(h.matrixWorld), x.matrixWorldInverse.multiply(w), D.matrixWorldInverse.multiply(w));
      x.matrixWorld.getInverse(x.matrixWorldInverse);
      D.matrixWorld.getInverse(D.matrixWorldInverse);
      x.projectionMatrix.fromArray(k.leftProjectionMatrix);
      D.projectionMatrix.fromArray(k.rightProjectionMatrix);
      tf(B, x, D);
      h = l.getLayers();
      h.length && (h = h[0], null !== h.leftBounds && 4 === h.leftBounds.length && x.bounds.fromArray(h.leftBounds), null !== h.rightBounds && 4 === h.rightBounds.length && D.bounds.fromArray(h.rightBounds));
      h = 0;
      a: for (; h < n.length; h++) {
        a = n[h];
        b: {
          r = h;
          for (var b = navigator.getGamepads && navigator.getGamepads(), d = 0, f = 0, c = b.length; d < c; d++) {
            var e = b[d];
            if (e && ("Daydream Controller" === e.id || "Gear VR Controller" === e.id || "Oculus Go Controller" === e.id || "OpenVR Gamepad" === e.id || e.id.startsWith("Oculus Touch") || e.id.startsWith("Spatial Controller"))) {
              if (f === r) {
                r = e;
                break b;
              }
              f++;
            }
          }
          r = void 0;
        }
        if (void 0 !== r && void 0 !== r.pose) {
          if (null === r.pose) {
            break a;
          }
          b = r.pose;
          !1 === b.hasPosition && a.position.set(.2, -.6, -.05);
          null !== b.position && a.position.fromArray(b.position);
          null !== b.orientation && a.quaternion.fromArray(b.orientation);
          a.matrix.compose(a.position, a.quaternion, a.scale);
          a.matrix.premultiply(m);
          a.matrix.decompose(a.position, a.quaternion, a.scale);
          a.matrixWorldNeedsUpdate = !0;
          a.visible = !0;
          b = "Daydream Controller" === r.id ? 0 : 1;
          G[h] !== r.buttons[b].pressed && (G[h] = r.buttons[b].pressed, !0 === G[h] ? a.dispatchEvent({type:"selectstart"}) : (a.dispatchEvent({type:"selectend"}), a.dispatchEvent({type:"select"})));
        } else {
          a.visible = !1;
        }
      }
      return B;
    };
    this.getStandingMatrix = function() {
      return m;
    };
    this.isPresenting = a;
    var M = new C;
    this.setAnimationLoop = function(h) {
      M.setAnimationLoop(h);
    };
    this.submitFrame = function() {
      a() && l.submitFrame();
    };
    this.dispose = function() {
      "undefined" !== typeof window && window.removeEventListener("vrdisplaypresentchange", d);
    };
  }
  function sg(h) {
    function a() {
      return null !== l && null !== g;
    }
    function b(h) {
      var a = m[t.indexOf(h.inputSource)];
      a && a.dispatchEvent({type:h.type});
    }
    function d() {
      h.setFramebuffer(null);
      y.stop();
    }
    function f(h, a) {
      null === a ? h.matrixWorld.copy(h.matrix) : h.matrixWorld.multiplyMatrices(a.matrixWorld, h.matrix);
      h.matrixWorldInverse.getInverse(h.matrixWorld);
    }
    var c = h.context, e = null, l = null, k = 1, g = null, q = "stage", n = null, m = [], t = [], u = new va;
    u.layers.enable(1);
    u.viewport = new p;
    var v = new va;
    v.layers.enable(2);
    v.viewport = new p;
    var w = new Wc([u, v]);
    w.layers.enable(1);
    w.layers.enable(2);
    this.enabled = !1;
    this.getController = function(h) {
      var a = m[h];
      void 0 === a && (a = new jc, a.matrixAutoUpdate = !1, a.visible = !1, m[h] = a);
      return a;
    };
    this.getDevice = function() {
      return e;
    };
    this.setDevice = function(h) {
      void 0 !== h && (e = h);
      h instanceof XRDevice && c.setCompatibleXRDevice(h);
    };
    this.setFramebufferScaleFactor = function(h) {
      k = h;
    };
    this.setFrameOfReferenceType = function(h) {
      q = h;
    };
    this.setSession = function(a) {
      l = a;
      null !== l && (l.addEventListener("select", b), l.addEventListener("selectstart", b), l.addEventListener("selectend", b), l.addEventListener("end", d), l.baseLayer = new XRWebGLLayer(l, c, {framebufferScaleFactor:k}), l.requestFrameOfReference(q).then(function(a) {
        g = a;
        h.setFramebuffer(l.baseLayer.framebuffer);
        y.setContext(l);
        y.start();
      }), t = l.getInputSources(), l.addEventListener("inputsourceschange", function() {
        t = l.getInputSources();
        console.log(t);
        for (var h = 0; h < m.length; h++) {
          m[h].userData.inputSource = t[h];
        }
      }));
    };
    this.getCamera = function(h) {
      if (a()) {
        var r = h.parent, b = w.cameras;
        f(w, r);
        for (var d = 0; d < b.length; d++) {
          f(b[d], r);
        }
        h.matrixWorld.copy(w.matrixWorld);
        h = h.children;
        d = 0;
        for (r = h.length; d < r; d++) {
          h[d].updateMatrixWorld(!0);
        }
        tf(w, u, v);
        return w;
      }
      return h;
    };
    this.isPresenting = a;
    var z = null, y = new C;
    y.setAnimationLoop(function(h, a) {
      n = a.getDevicePose(g);
      if (null !== n) {
        for (var r = l.baseLayer, b = a.views, d = 0; d < b.length; d++) {
          var f = b[d], c = r.getViewport(f), e = n.getViewMatrix(f), k = w.cameras[d];
          k.matrix.fromArray(e).getInverse(k.matrix);
          k.projectionMatrix.fromArray(f.projectionMatrix);
          k.viewport.set(c.x, c.y, c.width, c.height);
          0 === d && w.matrix.copy(k.matrix);
        }
      }
      for (d = 0; d < m.length; d++) {
        r = m[d];
        if (b = t[d]) {
          if (b = a.getInputPose(b, g), null !== b) {
            "targetRay" in b ? r.matrix.elements = b.targetRay.transformMatrix : "pointerMatrix" in b && (r.matrix.elements = b.pointerMatrix);
            r.matrix.decompose(r.position, r.rotation, r.scale);
            r.visible = !0;
            continue;
          }
        }
        r.visible = !1;
      }
      z && z(h);
    });
    this.setAnimationLoop = function(h) {
      z = h;
    };
    this.dispose = function() {
    };
    this.getStandingMatrix = function() {
      console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed.");
      return new THREE.Matrix4;
    };
    this.submitFrame = function() {
    };
  }
  function ve(h) {
    function a() {
      sa = new rb(Z);
      Aa = new pb(Z, sa, h);
      Aa.isWebGL2 || (sa.get("WEBGL_depth_texture"), sa.get("OES_texture_float"), sa.get("OES_texture_half_float"), sa.get("OES_texture_half_float_linear"), sa.get("OES_standard_derivatives"), sa.get("OES_element_index_uint"), sa.get("ANGLE_instanced_arrays"));
      sa.get("OES_texture_float_linear");
      Ra = new sf(Z, sa, Aa);
      ca = new qg(Z, sa, Ra, Aa);
      ca.scissor(Ob.copy(Gb).multiplyScalar(Ba));
      ca.viewport(fa.copy(Fb).multiplyScalar(Ba));
      da = new pe(Z);
      Ca = new ig;
      Qa = new rg(Z, sa, ca, Ca, Aa, Ra, da);
      na = new A(Z);
      ra = new ne(Z, na, da);
      vb = new se(ra, da);
      ta = new re(Z);
      pa = new hg(Q, sa, Aa);
      ic = new lg;
      Wa = new pg;
      qa = new Ua(Q, ca, vb, J);
      ua = new ob(Z, sa, da, Aa);
      va = new oe(Z, sa, da, Aa);
      da.programs = pa.programs;
      Q.context = Z;
      Q.capabilities = Aa;
      Q.extensions = sa;
      Q.properties = Ca;
      Q.renderLists = ic;
      Q.state = ca;
      Q.info = da;
    }
    function d(h) {
      h.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      L = !0;
    }
    function c() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      L = !1;
      a();
    }
    function e(h) {
      h = h.target;
      h.removeEventListener("dispose", e);
      k(h);
      Ca.remove(h);
    }
    function k(h) {
      var a = Ca.get(h).program;
      h.program = void 0;
      void 0 !== a && pa.releaseProgram(a);
    }
    function n(h, a) {
      h.render(function(h) {
        Q.renderBufferImmediate(h, a);
      });
    }
    function m(h, a, r, b) {
      if (!1 !== h.visible) {
        if (h.layers.test(a.layers)) {
          if (h.isGroup) {
            r = h.renderOrder;
          } else {
            if (h.isLight) {
              K.pushLight(h), h.castShadow && K.pushShadow(h);
            } else {
              if (h.isSprite) {
                if (!h.frustumCulled || Sc.intersectsSprite(h)) {
                  b && ib.setFromMatrixPosition(h.matrixWorld).applyMatrix4(la);
                  var d = vb.update(h), f = h.material;
                  I.push(h, d, f, r, ib.z, null);
                }
              } else {
                if (h.isImmediateRenderObject) {
                  b && ib.setFromMatrixPosition(h.matrixWorld).applyMatrix4(la), I.push(h, null, h.material, r, ib.z, null);
                } else {
                  if (h.isMesh || h.isLine || h.isPoints) {
                    if (h.isSkinnedMesh && h.skeleton.update(), !h.frustumCulled || Sc.intersectsObject(h)) {
                      if (b && ib.setFromMatrixPosition(h.matrixWorld).applyMatrix4(la), d = vb.update(h), f = h.material, Array.isArray(f)) {
                        for (var c = d.groups, e = 0, l = c.length; e < l; e++) {
                          var k = c[e], F = f[k.materialIndex];
                          F && F.visible && I.push(h, d, F, r, ib.z, k);
                        }
                      } else {
                        f.visible && I.push(h, d, f, r, ib.z, null);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        h = h.children;
        e = 0;
        for (l = h.length; e < l; e++) {
          m(h[e], a, r, b);
        }
      }
    }
    function t(h, a, r, b) {
      for (var d = 0, f = h.length; d < f; d++) {
        var c = h[d], e = c.object, l = c.geometry, k = void 0 === b ? c.material : b;
        c = c.group;
        if (r.isArrayCamera) {
          X = r;
          for (var F = r.cameras, g = 0, q = F.length; g < q; g++) {
            var n = F[g];
            if (e.layers.test(n.layers)) {
              if ("viewport" in n) {
                ca.viewport(fa.copy(n.viewport));
              } else {
                var m = n.bounds;
                ca.viewport(fa.set(m.x * Va, m.y * Pa, m.z * Va, m.w * Pa).multiplyScalar(Ba));
              }
              K.setupLights(n);
              u(e, a, n, l, k, c);
            }
          }
        } else {
          X = null, u(e, a, r, l, k, c);
        }
      }
    }
    function u(h, a, r, b, d, f) {
      h.onBeforeRender(Q, a, r, b, d, f);
      K = Wa.get(a, X || r);
      h.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, h.matrixWorld);
      h.normalMatrix.getNormalMatrix(h.modelViewMatrix);
      if (h.isImmediateRenderObject) {
        ca.setMaterial(d);
        var c = w(r, a.fog, d, h);
        ka = B = null;
        ha = !1;
        n(h, c);
      } else {
        Q.renderBufferDirect(r, a.fog, b, d, h, f);
      }
      h.onAfterRender(Q, a, r, b, d, f);
      K = Wa.get(a, X || r);
    }
    function v(h, a, r) {
      var b = Ca.get(h), d = K.state.lights, f = b.lightsHash, c = d.state.hash;
      r = pa.getParameters(h, d.state, K.state.shadowsArray, a, ma.numPlanes, ma.numIntersection, r);
      var l = pa.getProgramCode(h, r), F = b.program, g = !0;
      if (void 0 === F) {
        h.addEventListener("dispose", e);
      } else {
        if (F.code !== l) {
          k(h);
        } else {
          if (f.stateID !== c.stateID || f.directionalLength !== c.directionalLength || f.pointLength !== c.pointLength || f.spotLength !== c.spotLength || f.rectAreaLength !== c.rectAreaLength || f.hemiLength !== c.hemiLength || f.shadowsLength !== c.shadowsLength) {
            f.stateID = c.stateID, f.directionalLength = c.directionalLength, f.pointLength = c.pointLength, f.spotLength = c.spotLength, f.rectAreaLength = c.rectAreaLength, f.hemiLength = c.hemiLength, f.shadowsLength = c.shadowsLength;
          } else {
            if (void 0 !== r.shaderID) {
              return;
            }
          }
          g = !1;
        }
      }
      g && (r.shaderID ? (l = fb[r.shaderID], b.shader = {name:h.type, uniforms:q(l.uniforms), vertexShader:l.vertexShader, fragmentShader:l.fragmentShader}) : b.shader = {name:h.type, uniforms:h.uniforms, vertexShader:h.vertexShader, fragmentShader:h.fragmentShader}, h.onBeforeCompile(b.shader, Q), l = pa.getProgramCode(h, r), F = pa.acquireProgram(h, b.shader, r, l), b.program = F, h.program = F);
      r = F.getAttributes();
      if (h.morphTargets) {
        for (l = h.numSupportedMorphTargets = 0; l < Q.maxMorphTargets; l++) {
          0 <= r["morphTarget" + l] && h.numSupportedMorphTargets++;
        }
      }
      if (h.morphNormals) {
        for (l = h.numSupportedMorphNormals = 0; l < Q.maxMorphNormals; l++) {
          0 <= r["morphNormal" + l] && h.numSupportedMorphNormals++;
        }
      }
      r = b.shader.uniforms;
      if (!h.isShaderMaterial && !h.isRawShaderMaterial || !0 === h.clipping) {
        b.numClippingPlanes = ma.numPlanes, b.numIntersection = ma.numIntersection, r.clippingPlanes = ma.uniform;
      }
      b.fog = a;
      void 0 === f && (b.lightsHash = f = {});
      f.stateID = c.stateID;
      f.directionalLength = c.directionalLength;
      f.pointLength = c.pointLength;
      f.spotLength = c.spotLength;
      f.rectAreaLength = c.rectAreaLength;
      f.hemiLength = c.hemiLength;
      f.shadowsLength = c.shadowsLength;
      h.lights && (r.ambientLightColor.value = d.state.ambient, r.directionalLights.value = d.state.directional, r.spotLights.value = d.state.spot, r.rectAreaLights.value = d.state.rectArea, r.pointLights.value = d.state.point, r.hemisphereLights.value = d.state.hemi, r.directionalShadowMap.value = d.state.directionalShadowMap, r.directionalShadowMatrix.value = d.state.directionalShadowMatrix, r.spotShadowMap.value = d.state.spotShadowMap, r.spotShadowMatrix.value = d.state.spotShadowMatrix, r.pointShadowMap.value = 
      d.state.pointShadowMap, r.pointShadowMatrix.value = d.state.pointShadowMatrix);
      h = b.program.getUniforms();
      h = Hb.seqWithValue(h.seq, r);
      b.uniformsList = h;
    }
    function w(h, a, r, b) {
      Qc = 0;
      var d = Ca.get(r), f = d.lightsHash, c = K.state.lights.state.hash;
      hc && (Tc || h !== ja) && ma.setState(r.clippingPlanes, r.clipIntersection, r.clipShadows, h, d, h === ja && r.id === R);
      !1 === r.needsUpdate && (void 0 === d.program ? r.needsUpdate = !0 : r.fog && d.fog !== a ? r.needsUpdate = !0 : !r.lights || f.stateID === c.stateID && f.directionalLength === c.directionalLength && f.pointLength === c.pointLength && f.spotLength === c.spotLength && f.rectAreaLength === c.rectAreaLength && f.hemiLength === c.hemiLength && f.shadowsLength === c.shadowsLength ? void 0 === d.numClippingPlanes || d.numClippingPlanes === ma.numPlanes && d.numIntersection === ma.numIntersection || 
      (r.needsUpdate = !0) : r.needsUpdate = !0);
      r.needsUpdate && (v(r, a, b), r.needsUpdate = !1);
      var e = !1, k = !1, F = !1;
      f = d.program;
      c = f.getUniforms();
      var g = d.shader.uniforms;
      ca.useProgram(f.program) && (F = k = e = !0);
      r.id !== R && (R = r.id, k = !0);
      if (e || ja !== h) {
        c.setValue(Z, "projectionMatrix", h.projectionMatrix);
        Aa.logarithmicDepthBuffer && c.setValue(Z, "logDepthBufFC", 2 / (Math.log(h.far + 1) / Math.LN2));
        ja !== h && (ja = h, F = k = !0);
        if (r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshStandardMaterial || r.envMap) {
          e = c.map.cameraPosition, void 0 !== e && e.setValue(Z, ib.setFromMatrixPosition(h.matrixWorld));
        }
        (r.isMeshPhongMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.skinning) && c.setValue(Z, "viewMatrix", h.matrixWorldInverse);
      }
      if (r.skinning && (c.setOptional(Z, b, "bindMatrix"), c.setOptional(Z, b, "bindMatrixInverse"), h = b.skeleton)) {
        if (e = h.bones, Aa.floatVertexTextures) {
          if (void 0 === h.boneTexture) {
            e = Math.sqrt(4 * e.length);
            e = ia.ceilPowerOfTwo(e);
            e = Math.max(e, 4);
            var q = new Float32Array(e * e * 4);
            q.set(h.boneMatrices);
            var n = new l(q, e, e, 1023, 1015);
            n.needsUpdate = !0;
            h.boneMatrices = q;
            h.boneTexture = n;
            h.boneTextureSize = e;
          }
          c.setValue(Z, "boneTexture", h.boneTexture);
          c.setValue(Z, "boneTextureSize", h.boneTextureSize);
        } else {
          c.setOptional(Z, h, "boneMatrices");
        }
      }
      k && (c.setValue(Z, "toneMappingExposure", Q.toneMappingExposure), c.setValue(Z, "toneMappingWhitePoint", Q.toneMappingWhitePoint), r.lights && (k = F, g.ambientLightColor.needsUpdate = k, g.directionalLights.needsUpdate = k, g.pointLights.needsUpdate = k, g.spotLights.needsUpdate = k, g.rectAreaLights.needsUpdate = k, g.hemisphereLights.needsUpdate = k), a && r.fog && (g.fogColor.value = a.color, a.isFog ? (g.fogNear.value = a.near, g.fogFar.value = a.far) : a.isFogExp2 && (g.fogDensity.value = 
      a.density)), r.isMeshBasicMaterial ? z(g, r) : r.isMeshLambertMaterial ? (z(g, r), r.emissiveMap && (g.emissiveMap.value = r.emissiveMap)) : r.isMeshPhongMaterial ? (z(g, r), r.isMeshToonMaterial ? (y(g, r), r.gradientMap && (g.gradientMap.value = r.gradientMap)) : y(g, r)) : r.isMeshStandardMaterial ? (z(g, r), r.isMeshPhysicalMaterial ? (D(g, r), g.reflectivity.value = r.reflectivity, g.clearCoat.value = r.clearCoat, g.clearCoatRoughness.value = r.clearCoatRoughness) : D(g, r)) : r.isMeshMatcapMaterial ? 
      (z(g, r), r.matcap && (g.matcap.value = r.matcap), r.bumpMap && (g.bumpMap.value = r.bumpMap, g.bumpScale.value = r.bumpScale, 1 === r.side && (g.bumpScale.value *= -1)), r.normalMap && (g.normalMap.value = r.normalMap, g.normalScale.value.copy(r.normalScale), 1 === r.side && g.normalScale.value.negate()), r.displacementMap && (g.displacementMap.value = r.displacementMap, g.displacementScale.value = r.displacementScale, g.displacementBias.value = r.displacementBias)) : r.isMeshDepthMaterial ? 
      (z(g, r), r.displacementMap && (g.displacementMap.value = r.displacementMap, g.displacementScale.value = r.displacementScale, g.displacementBias.value = r.displacementBias)) : r.isMeshDistanceMaterial ? (z(g, r), r.displacementMap && (g.displacementMap.value = r.displacementMap, g.displacementScale.value = r.displacementScale, g.displacementBias.value = r.displacementBias), g.referencePosition.value.copy(r.referencePosition), g.nearDistance.value = r.nearDistance, g.farDistance.value = r.farDistance) : 
      r.isMeshNormalMaterial ? (z(g, r), r.bumpMap && (g.bumpMap.value = r.bumpMap, g.bumpScale.value = r.bumpScale, 1 === r.side && (g.bumpScale.value *= -1)), r.normalMap && (g.normalMap.value = r.normalMap, g.normalScale.value.copy(r.normalScale), 1 === r.side && g.normalScale.value.negate()), r.displacementMap && (g.displacementMap.value = r.displacementMap, g.displacementScale.value = r.displacementScale, g.displacementBias.value = r.displacementBias)) : r.isLineBasicMaterial ? (g.diffuse.value = 
      r.color, g.opacity.value = r.opacity, r.isLineDashedMaterial && (g.dashSize.value = r.dashSize, g.totalSize.value = r.dashSize + r.gapSize, g.scale.value = r.scale)) : r.isPointsMaterial ? (g.diffuse.value = r.color, g.opacity.value = r.opacity, g.size.value = r.size * Ba, g.scale.value = .5 * Pa, g.map.value = r.map, null !== r.map && (!0 === r.map.matrixAutoUpdate && r.map.updateMatrix(), g.uvTransform.value.copy(r.map.matrix))) : r.isSpriteMaterial ? (g.diffuse.value = r.color, g.opacity.value = 
      r.opacity, g.rotation.value = r.rotation, g.map.value = r.map, null !== r.map && (!0 === r.map.matrixAutoUpdate && r.map.updateMatrix(), g.uvTransform.value.copy(r.map.matrix))) : r.isShadowMaterial && (g.color.value = r.color, g.opacity.value = r.opacity), void 0 !== g.ltc_1 && (g.ltc_1.value = ea.LTC_1), void 0 !== g.ltc_2 && (g.ltc_2.value = ea.LTC_2), Hb.upload(Z, d.uniformsList, g, Q));
      r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (Hb.upload(Z, d.uniformsList, g, Q), r.uniformsNeedUpdate = !1);
      r.isSpriteMaterial && c.setValue(Z, "center", b.center);
      c.setValue(Z, "modelViewMatrix", b.modelViewMatrix);
      c.setValue(Z, "normalMatrix", b.normalMatrix);
      c.setValue(Z, "modelMatrix", b.matrixWorld);
      return f;
    }
    function z(h, a) {
      h.opacity.value = a.opacity;
      a.color && (h.diffuse.value = a.color);
      a.emissive && h.emissive.value.copy(a.emissive).multiplyScalar(a.emissiveIntensity);
      a.map && (h.map.value = a.map);
      a.alphaMap && (h.alphaMap.value = a.alphaMap);
      a.specularMap && (h.specularMap.value = a.specularMap);
      a.envMap && (h.envMap.value = a.envMap, h.flipEnvMap.value = a.envMap.isCubeTexture ? -1 : 1, h.reflectivity.value = a.reflectivity, h.refractionRatio.value = a.refractionRatio, h.maxMipLevel.value = Ca.get(a.envMap).__maxMipLevel);
      a.lightMap && (h.lightMap.value = a.lightMap, h.lightMapIntensity.value = a.lightMapIntensity);
      a.aoMap && (h.aoMap.value = a.aoMap, h.aoMapIntensity.value = a.aoMapIntensity);
      if (a.map) {
        var r = a.map;
      } else {
        a.specularMap ? r = a.specularMap : a.displacementMap ? r = a.displacementMap : a.normalMap ? r = a.normalMap : a.bumpMap ? r = a.bumpMap : a.roughnessMap ? r = a.roughnessMap : a.metalnessMap ? r = a.metalnessMap : a.alphaMap ? r = a.alphaMap : a.emissiveMap && (r = a.emissiveMap);
      }
      void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), h.uvTransform.value.copy(r.matrix));
    }
    function y(h, a) {
      h.specular.value = a.specular;
      h.shininess.value = Math.max(a.shininess, 1E-4);
      a.emissiveMap && (h.emissiveMap.value = a.emissiveMap);
      a.bumpMap && (h.bumpMap.value = a.bumpMap, h.bumpScale.value = a.bumpScale, 1 === a.side && (h.bumpScale.value *= -1));
      a.normalMap && (h.normalMap.value = a.normalMap, h.normalScale.value.copy(a.normalScale), 1 === a.side && h.normalScale.value.negate());
      a.displacementMap && (h.displacementMap.value = a.displacementMap, h.displacementScale.value = a.displacementScale, h.displacementBias.value = a.displacementBias);
    }
    function D(h, a) {
      h.roughness.value = a.roughness;
      h.metalness.value = a.metalness;
      a.roughnessMap && (h.roughnessMap.value = a.roughnessMap);
      a.metalnessMap && (h.metalnessMap.value = a.metalnessMap);
      a.emissiveMap && (h.emissiveMap.value = a.emissiveMap);
      a.bumpMap && (h.bumpMap.value = a.bumpMap, h.bumpScale.value = a.bumpScale, 1 === a.side && (h.bumpScale.value *= -1));
      a.normalMap && (h.normalMap.value = a.normalMap, h.normalScale.value.copy(a.normalScale), 1 === a.side && h.normalScale.value.negate());
      a.displacementMap && (h.displacementMap.value = a.displacementMap, h.displacementScale.value = a.displacementScale, h.displacementBias.value = a.displacementBias);
      a.envMap && (h.envMapIntensity.value = a.envMapIntensity);
    }
    var B;
    console.log("THREE.WebGLRenderer", "102dev");
    h = h || {};
    var E = void 0 !== h.canvas ? h.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), G = void 0 !== h.context ? h.context : null, M = void 0 !== h.alpha ? h.alpha : !1, H = void 0 !== h.depth ? h.depth : !0, O = void 0 !== h.stencil ? h.stencil : !0, P = void 0 !== h.antialias ? h.antialias : !1, J = void 0 !== h.premultipliedAlpha ? h.premultipliedAlpha : !0, U = void 0 !== h.preserveDrawingBuffer ? h.preserveDrawingBuffer : !1, N = void 0 !== h.powerPreference ? h.powerPreference : 
    "default", I = null, K = null;
    this.domElement = E;
    this.context = null;
    this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
    this.clippingPlanes = [];
    this.localClippingEnabled = !1;
    this.gammaFactor = 2;
    this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1;
    this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    var Q = this, L = !1, aa = null, S = null, V = null, R = -1, ka = B = null, ha = !1, ja = null, X = null, fa = new p, Ob = new p, ba = null, Qc = 0, Va = E.width, Pa = E.height, Ba = 1, Fb = new p(0, 0, Va, Pa), Gb = new p(0, 0, Va, Pa), Rc = !1, Sc = new x, ma = new qb, hc = !1, Tc = !1, la = new b, ib = new f;
    try {
      M = {alpha:M, depth:H, stencil:O, antialias:P, premultipliedAlpha:J, preserveDrawingBuffer:U, powerPreference:N};
      E.addEventListener("webglcontextlost", d, !1);
      E.addEventListener("webglcontextrestored", c, !1);
      var Z = G || E.getContext("webgl", M) || E.getContext("experimental-webgl", M);
      if (null === Z) {
        if (null !== E.getContext("webgl")) {
          throw Error("Error creating WebGL context with your selected attributes.");
        }
        throw Error("Error creating WebGL context.");
      }
      void 0 === Z.getShaderPrecisionFormat && (Z.getShaderPrecisionFormat = function() {
        return {rangeMin:1, rangeMax:1, precision:1};
      });
    } catch (xf) {
      throw console.error("THREE.WebGLRenderer: " + xf.message), xf;
    }
    var sa, Aa, ca, da, Ca, Qa, na, ra, vb, pa, ic, Wa, qa, ta, ua, va, Ra;
    a();
    var Sa = null;
    "undefined" !== typeof navigator && (Sa = "xr" in navigator ? new sg(Q) : new wf(Q));
    this.vr = Sa;
    var za = new rf(Q, vb, Aa.maxTextureSize);
    this.shadowMap = za;
    this.getContext = function() {
      return Z;
    };
    this.getContextAttributes = function() {
      return Z.getContextAttributes();
    };
    this.forceContextLoss = function() {
      var h = sa.get("WEBGL_lose_context");
      h && h.loseContext();
    };
    this.forceContextRestore = function() {
      var h = sa.get("WEBGL_lose_context");
      h && h.restoreContext();
    };
    this.getPixelRatio = function() {
      return Ba;
    };
    this.setPixelRatio = function(h) {
      void 0 !== h && (Ba = h, this.setSize(Va, Pa, !1));
    };
    this.getSize = function(h) {
      void 0 === h && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), h = new g);
      return h.set(Va, Pa);
    };
    this.setSize = function(h, a, r) {
      Sa.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Va = h, Pa = a, E.width = h * Ba, E.height = a * Ba, !1 !== r && (E.style.width = h + "px", E.style.height = a + "px"), this.setViewport(0, 0, h, a));
    };
    this.getDrawingBufferSize = function(h) {
      void 0 === h && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), h = new g);
      return h.set(Va * Ba, Pa * Ba);
    };
    this.setDrawingBufferSize = function(h, a, r) {
      Va = h;
      Pa = a;
      Ba = r;
      E.width = h * r;
      E.height = a * r;
      this.setViewport(0, 0, h, a);
    };
    this.getCurrentViewport = function(h) {
      void 0 === h && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), h = new p);
      return h.copy(fa);
    };
    this.getViewport = function(h) {
      return h.copy(Fb);
    };
    this.setViewport = function(h, a, r, b) {
      h.isVector4 ? Fb.set(h.x, h.y, h.z, h.w) : Fb.set(h, a, r, b);
      ca.viewport(fa.copy(Fb).multiplyScalar(Ba));
    };
    this.getScissor = function(h) {
      return h.copy(Gb);
    };
    this.setScissor = function(h, a, r, b) {
      h.isVector4 ? Gb.set(h.x, h.y, h.z, h.w) : Gb.set(h, a, r, b);
      ca.scissor(Ob.copy(Gb).multiplyScalar(Ba));
    };
    this.getScissorTest = function() {
      return Rc;
    };
    this.setScissorTest = function(h) {
      ca.setScissorTest(Rc = h);
    };
    this.getClearColor = function() {
      return qa.getClearColor();
    };
    this.setClearColor = function() {
      qa.setClearColor.apply(qa, arguments);
    };
    this.getClearAlpha = function() {
      return qa.getClearAlpha();
    };
    this.setClearAlpha = function() {
      qa.setClearAlpha.apply(qa, arguments);
    };
    this.clear = function(h, a, r) {
      var b = 0;
      if (void 0 === h || h) {
        b |= 16384;
      }
      if (void 0 === a || a) {
        b |= 256;
      }
      if (void 0 === r || r) {
        b |= 1024;
      }
      Z.clear(b);
    };
    this.clearColor = function() {
      this.clear(!0, !1, !1);
    };
    this.clearDepth = function() {
      this.clear(!1, !0, !1);
    };
    this.clearStencil = function() {
      this.clear(!1, !1, !0);
    };
    this.dispose = function() {
      E.removeEventListener("webglcontextlost", d, !1);
      E.removeEventListener("webglcontextrestored", c, !1);
      ic.dispose();
      Wa.dispose();
      Ca.dispose();
      vb.dispose();
      Sa.dispose();
      wa.stop();
    };
    this.renderBufferImmediate = function(h, a) {
      ca.initAttributes();
      var r = Ca.get(h);
      h.hasPositions && !r.position && (r.position = Z.createBuffer());
      h.hasNormals && !r.normal && (r.normal = Z.createBuffer());
      h.hasUvs && !r.uv && (r.uv = Z.createBuffer());
      h.hasColors && !r.color && (r.color = Z.createBuffer());
      a = a.getAttributes();
      h.hasPositions && (Z.bindBuffer(34962, r.position), Z.bufferData(34962, h.positionArray, 35048), ca.enableAttribute(a.position), Z.vertexAttribPointer(a.position, 3, 5126, !1, 0, 0));
      h.hasNormals && (Z.bindBuffer(34962, r.normal), Z.bufferData(34962, h.normalArray, 35048), ca.enableAttribute(a.normal), Z.vertexAttribPointer(a.normal, 3, 5126, !1, 0, 0));
      h.hasUvs && (Z.bindBuffer(34962, r.uv), Z.bufferData(34962, h.uvArray, 35048), ca.enableAttribute(a.uv), Z.vertexAttribPointer(a.uv, 2, 5126, !1, 0, 0));
      h.hasColors && (Z.bindBuffer(34962, r.color), Z.bufferData(34962, h.colorArray, 35048), ca.enableAttribute(a.color), Z.vertexAttribPointer(a.color, 3, 5126, !1, 0, 0));
      ca.disableUnusedAttributes();
      Z.drawArrays(4, 0, h.count);
      h.count = 0;
    };
    this.renderBufferDirect = function(h, a, r, b, d, f) {
      var c = d.isMesh && 0 > d.normalMatrix.determinant();
      ca.setMaterial(b, c);
      var e = w(h, a, b, d), l = !+1;
      if (B !== r.id || ka !== e.id || ha !== (!0 === b.wireframe)) {
        B = r.id, ka = e.id, ha = !0 === b.wireframe, l = !0;
      }
      d.morphTargetInfluences && (ta.update(d, r, b, e), l = !0);
      c = r.index;
      var k = r.attributes.position;
      a = 1;
      !0 === b.wireframe && (c = ra.getWireframeAttribute(r), a = 2);
      h = ua;
      if (null !== c) {
        var F = na.get(c);
        h = va;
        h.setIndex(F);
      }
      if (l) {
        if (r && r.isInstancedBufferGeometry && !Aa.isWebGL2 && null === sa.get("ANGLE_instanced_arrays")) {
          console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        } else {
          ca.initAttributes();
          l = r.attributes;
          e = e.getAttributes();
          var g = b.defaultAttributeValues;
          for (z in e) {
            var q = e[z];
            if (0 <= q) {
              var n = l[z];
              if (void 0 !== n) {
                var m = n.normalized, t = n.itemSize, u = na.get(n);
                if (void 0 !== u) {
                  var p = u.buffer, W = u.type;
                  u = u.bytesPerElement;
                  if (n.isInterleavedBufferAttribute) {
                    var v = n.data, Y = v.stride;
                    n = n.offset;
                    v && v.isInstancedInterleavedBuffer ? (ca.enableAttributeAndDivisor(q, v.meshPerAttribute), void 0 === r.maxInstancedCount && (r.maxInstancedCount = v.meshPerAttribute * v.count)) : ca.enableAttribute(q);
                    Z.bindBuffer(34962, p);
                    Z.vertexAttribPointer(q, t, W, m, Y * u, n * u);
                  } else {
                    n.isInstancedBufferAttribute ? (ca.enableAttributeAndDivisor(q, n.meshPerAttribute), void 0 === r.maxInstancedCount && (r.maxInstancedCount = n.meshPerAttribute * n.count)) : ca.enableAttribute(q), Z.bindBuffer(34962, p), Z.vertexAttribPointer(q, t, W, m, 0, 0);
                  }
                }
              } else {
                if (void 0 !== g && (m = g[z], void 0 !== m)) {
                  switch(m.length) {
                    case 2:
                      Z.vertexAttrib2fv(q, m);
                      break;
                    case 3:
                      Z.vertexAttrib3fv(q, m);
                      break;
                    case 4:
                      Z.vertexAttrib4fv(q, m);
                      break;
                    default:
                      Z.vertexAttrib1fv(q, m);
                  }
                }
              }
            }
          }
          ca.disableUnusedAttributes();
        }
        null !== c && Z.bindBuffer(34963, F.buffer);
      }
      F = Infinity;
      null !== c ? F = c.count : void 0 !== k && (F = k.count);
      c = r.drawRange.start * a;
      k = null !== f ? f.start * a : 0;
      var z = Math.max(c, k);
      f = Math.max(0, Math.min(F, c + r.drawRange.count * a, k + (null !== f ? f.count * a : Infinity)) - 1 - z + 1);
      if (0 !== f) {
        if (d.isMesh) {
          if (!0 === b.wireframe) {
            ca.setLineWidth(b.wireframeLinewidth * (null === S ? Ba : 1)), h.setMode(1);
          } else {
            switch(d.drawMode) {
              case 0:
                h.setMode(4);
                break;
              case 1:
                h.setMode(5);
                break;
              case 2:
                h.setMode(6);
            }
          }
        } else {
          d.isLine ? (b = b.linewidth, void 0 === b && (b = 1), ca.setLineWidth(b * (null === S ? Ba : 1)), d.isLineSegments ? h.setMode(1) : d.isLineLoop ? h.setMode(2) : h.setMode(3)) : d.isPoints ? h.setMode(0) : d.isSprite && h.setMode(4);
        }
        r && r.isInstancedBufferGeometry ? 0 < r.maxInstancedCount && h.renderInstances(r, z, f) : h.render(z, f);
      }
    };
    this.compile = function(h, a) {
      K = Wa.get(h, a);
      K.init();
      h.traverse(function(h) {
        h.isLight && (K.pushLight(h), h.castShadow && K.pushShadow(h));
      });
      K.setupLights(a);
      h.traverse(function(a) {
        if (a.material) {
          if (Array.isArray(a.material)) {
            for (var r = 0; r < a.material.length; r++) {
              v(a.material[r], h.fog, a);
            }
          } else {
            v(a.material, h.fog, a);
          }
        }
      });
    };
    var xa = null, wa = new C;
    wa.setAnimationLoop(function(h) {
      Sa.isPresenting() || xa && xa(h);
    });
    "undefined" !== typeof window && wa.setContext(window);
    this.setAnimationLoop = function(h) {
      xa = h;
      Sa.setAnimationLoop(h);
      wa.start();
    };
    this.render = function(h, a, r, b) {
      if (void 0 !== r) {
        console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
        var d = r;
      }
      if (void 0 !== b) {
        console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
        var f = b;
      }
      a && a.isCamera ? L || (ka = B = null, ha = !1, R = -1, ja = null, !0 === h.autoUpdate && h.updateMatrixWorld(), null === a.parent && a.updateMatrixWorld(), Sa.enabled && (a = Sa.getCamera(a)), K = Wa.get(h, a), K.init(), h.onBeforeRender(Q, h, a, d || S), la.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse), Sc.setFromMatrix(la), Tc = this.localClippingEnabled, hc = ma.init(this.clippingPlanes, Tc, a), I = ic.get(h, a), I.init(), m(h, a, 0, Q.sortObjects), !0 === Q.sortObjects && 
      I.sort(), hc && ma.beginShadows(), za.render(K.state.shadowsArray, h, a), K.setupLights(a), hc && ma.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== d && this.setRenderTarget(d), qa.render(I, h, a, f), r = I.opaque, b = I.transparent, h.overrideMaterial ? (d = h.overrideMaterial, r.length && t(r, h, a, d), b.length && t(b, h, a, d)) : (r.length && t(r, h, a), b.length && t(b, h, a)), null !== S && (Qa.updateRenderTargetMipmap(S), Qa.updateMultisampleRenderTarget(S)), ca.buffers.depth.setTest(!0), 
      ca.buffers.depth.setMask(!0), ca.buffers.color.setMask(!0), ca.setPolygonOffset(!1), h.onAfterRender(Q, h, a), Sa.enabled && Sa.submitFrame(), K = I = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
    };
    this.allocTextureUnit = function() {
      var h = Qc;
      h >= Aa.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + h + " texture units while this GPU supports only " + Aa.maxTextures);
      Qc += 1;
      return h;
    };
    this.setTexture2D = function() {
      var h = !1;
      return function(a, r) {
        a && a.isWebGLRenderTarget && (h || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), h = !0), a = a.texture);
        Qa.setTexture2D(a, r);
      };
    }();
    this.setTexture3D = function() {
      return function(h, a) {
        Qa.setTexture3D(h, a);
      };
    }();
    this.setTexture = function() {
      var h = !1;
      return function(a, r) {
        h || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), h = !0);
        Qa.setTexture2D(a, r);
      };
    }();
    this.setTextureCube = function() {
      var h = !1;
      return function(a, r) {
        a && a.isWebGLRenderTargetCube && (h || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), h = !0), a = a.texture);
        a && a.isCubeTexture || Array.isArray(a.image) && 6 === a.image.length ? Qa.setTextureCube(a, r) : Qa.setTextureCubeDynamic(a, r);
      };
    }();
    this.setFramebuffer = function(h) {
      aa = h;
    };
    this.getRenderTarget = function() {
      return S;
    };
    this.setRenderTarget = function(h, a, r) {
      (S = h) && void 0 === Ca.get(h).__webglFramebuffer && Qa.setupRenderTarget(h);
      var b = aa, d = !1;
      h ? (b = Ca.get(h).__webglFramebuffer, h.isWebGLRenderTargetCube ? (b = b[a || 0], d = !0) : b = h.isWebGLMultisampleRenderTarget ? Ca.get(h).__webglMultisampledFramebuffer : b, fa.copy(h.viewport), Ob.copy(h.scissor), ba = h.scissorTest) : (fa.copy(Fb).multiplyScalar(Ba), Ob.copy(Gb).multiplyScalar(Ba), ba = Rc);
      V !== b && (Z.bindFramebuffer(36160, b), V = b);
      ca.viewport(fa);
      ca.scissor(Ob);
      ca.setScissorTest(ba);
      d && (h = Ca.get(h.texture), Z.framebufferTexture2D(36160, 36064, 34069 + a || 0, h.__webglTexture, r || 0));
    };
    this.readRenderTargetPixels = function(h, a, r, b, d, f) {
      if (h && h.isWebGLRenderTarget) {
        var c = Ca.get(h).__webglFramebuffer;
        if (c) {
          var e = !1;
          c !== V && (Z.bindFramebuffer(36160, c), e = !0);
          try {
            var l = h.texture, k = l.format, F = l.type;
            1023 !== k && Ra.convert(k) !== Z.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === F || Ra.convert(F) === Z.getParameter(35738) || 1015 === F && (Aa.isWebGL2 || sa.get("OES_texture_float") || sa.get("WEBGL_color_buffer_float")) || 1016 === F && (Aa.isWebGL2 ? sa.get("EXT_color_buffer_float") : sa.get("EXT_color_buffer_half_float")) ? 36053 === Z.checkFramebufferStatus(36160) ? 0 <= 
            a && a <= h.width - b && 0 <= r && r <= h.height - d && Z.readPixels(a, r, b, d, Ra.convert(k), Ra.convert(F), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          } finally {
            e && Z.bindFramebuffer(36160, V);
          }
        }
      } else {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      }
    };
    this.copyFramebufferToTexture = function(h, a, r) {
      var b = a.image.width, d = a.image.height, f = Ra.convert(a.format);
      this.setTexture2D(a, 0);
      Z.copyTexImage2D(3553, r || 0, f, h.x, h.y, b, d, 0);
    };
    this.copyTextureToTexture = function(h, a, r, b) {
      var d = a.image.width, f = a.image.height, c = Ra.convert(r.format), e = Ra.convert(r.type);
      this.setTexture2D(r, 0);
      a.isDataTexture ? Z.texSubImage2D(3553, b || 0, h.x, h.y, d, f, c, e, a.image.data) : Z.texSubImage2D(3553, b || 0, h.x, h.y, c, e, a.image);
    };
  }
  function kc(h, a) {
    this.name = "";
    this.color = new z(h);
    this.density = void 0 !== a ? a : 2.5E-4;
  }
  function lc(h, a, b) {
    this.name = "";
    this.color = new z(h);
    this.near = void 0 !== a ? a : 1;
    this.far = void 0 !== b ? b : 1E3;
  }
  function Pd() {
    G.call(this);
    this.type = "Scene";
    this.overrideMaterial = this.fog = this.background = null;
    this.autoUpdate = !0;
  }
  function Pb(h, a) {
    this.array = h;
    this.stride = a;
    this.count = void 0 !== h ? h.length / a : 0;
    this.dynamic = !1;
    this.updateRange = {offset:0, count:-1};
    this.version = 0;
  }
  function Xc(h, a, b, d) {
    this.data = h;
    this.itemSize = a;
    this.offset = b;
    this.normalized = !0 === d;
  }
  function Kb(h) {
    X.call(this);
    this.type = "SpriteMaterial";
    this.color = new z(16777215);
    this.map = null;
    this.rotation = 0;
    this.sizeAttenuation = !0;
    this.lights = !1;
    this.transparent = !0;
    this.setValues(h);
  }
  function Yc(h) {
    G.call(this);
    this.type = "Sprite";
    if (void 0 === mc) {
      mc = new O;
      var a = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
      a = new Pb(a, 5);
      mc.setIndex([0, 1, 2, 0, 2, 3]);
      mc.addAttribute("position", new Xc(a, 3, 0, !1));
      mc.addAttribute("uv", new Xc(a, 2, 3, !1));
    }
    this.geometry = mc;
    this.material = void 0 !== h ? h : new Kb;
    this.center = new g(.5, .5);
  }
  function Zc() {
    G.call(this);
    this.type = "LOD";
    Object.defineProperties(this, {levels:{enumerable:!0, value:[]}});
  }
  function $c(h, a) {
    h && h.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    ca.call(this, h, a);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new b;
    this.bindMatrixInverse = new b;
  }
  function Qd(h, a) {
    h = h || [];
    this.bones = h.slice(0);
    this.boneMatrices = new Float32Array(16 * this.bones.length);
    if (void 0 === a) {
      this.calculateInverses();
    } else {
      if (this.bones.length === a.length) {
        this.boneInverses = a.slice(0);
      } else {
        for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], h = 0, a = this.bones.length; h < a; h++) {
          this.boneInverses.push(new b);
        }
      }
    }
  }
  function we() {
    G.call(this);
    this.type = "Bone";
  }
  function ra(h) {
    X.call(this);
    this.type = "LineBasicMaterial";
    this.color = new z(16777215);
    this.linewidth = 1;
    this.linejoin = this.linecap = "round";
    this.lights = !1;
    this.setValues(h);
  }
  function wa(h, a, b) {
    1 === b && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
    G.call(this);
    this.type = "Line";
    this.geometry = void 0 !== h ? h : new O;
    this.material = void 0 !== a ? a : new ra({color:16777215 * Math.random()});
  }
  function pa(h, a) {
    wa.call(this, h, a);
    this.type = "LineSegments";
  }
  function Rd(h, a) {
    wa.call(this, h, a);
    this.type = "LineLoop";
  }
  function Xa(h) {
    X.call(this);
    this.type = "PointsMaterial";
    this.color = new z(16777215);
    this.map = null;
    this.size = 1;
    this.sizeAttenuation = !0;
    this.lights = this.morphTargets = !1;
    this.setValues(h);
  }
  function nc(h, a) {
    G.call(this);
    this.type = "Points";
    this.geometry = void 0 !== h ? h : new O;
    this.material = void 0 !== a ? a : new Xa({color:16777215 * Math.random()});
  }
  function xe(h, a, b, d, f, c, e, l, k) {
    n.call(this, h, a, b, d, f, c, e, l, k);
    this.format = void 0 !== e ? e : 1022;
    this.minFilter = void 0 !== c ? c : 1006;
    this.magFilter = void 0 !== f ? f : 1006;
    this.generateMipmaps = !1;
  }
  function oc(h, a, b, d, f, c, e, l, k, g, q, m) {
    n.call(this, null, c, e, l, k, g, d, f, q, m);
    this.image = {width:a, height:b};
    this.mipmaps = h;
    this.generateMipmaps = this.flipY = !1;
  }
  function ad(h, a, b, d, f, c, e, l, k) {
    n.call(this, h, a, b, d, f, c, e, l, k);
    this.needsUpdate = !0;
  }
  function bd(h, a, b, d, f, c, e, l, k, g) {
    g = void 0 !== g ? g : 1026;
    if (1026 !== g && 1027 !== g) {
      throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    void 0 === b && 1026 === g && (b = 1012);
    void 0 === b && 1027 === g && (b = 1020);
    n.call(this, null, d, f, c, e, l, g, b, k);
    this.image = {width:h, height:a};
    this.magFilter = void 0 !== e ? e : 1003;
    this.minFilter = void 0 !== l ? l : 1003;
    this.generateMipmaps = this.flipY = !1;
  }
  function pc(h) {
    O.call(this);
    this.type = "WireframeGeometry";
    var a = [], b, d, c, e = [0, 0], l = {}, k = ["a", "b", "c"];
    if (h && h.isGeometry) {
      var g = h.faces, q = 0;
      for (d = g.length; q < d; q++) {
        var n = g[q];
        for (b = 0; 3 > b; b++) {
          var m = n[k[b]], t = n[k[(b + 1) % 3]];
          e[0] = Math.min(m, t);
          e[1] = Math.max(m, t);
          m = e[0] + "," + e[1];
          void 0 === l[m] && (l[m] = {index1:e[0], index2:e[1]});
        }
      }
      for (m in l) {
        q = l[m], k = h.vertices[q.index1], a.push(k.x, k.y, k.z), k = h.vertices[q.index2], a.push(k.x, k.y, k.z);
      }
    } else {
      if (h && h.isBufferGeometry) {
        if (k = new f, null !== h.index) {
          g = h.attributes.position;
          n = h.index;
          var u = h.groups;
          0 === u.length && (u = [{start:0, count:n.count, materialIndex:0}]);
          h = 0;
          for (c = u.length; h < c; ++h) {
            for (q = u[h], b = q.start, d = q.count, q = b, d = b + d; q < d; q += 3) {
              for (b = 0; 3 > b; b++) {
                m = n.getX(q + b), t = n.getX(q + (b + 1) % 3), e[0] = Math.min(m, t), e[1] = Math.max(m, t), m = e[0] + "," + e[1], void 0 === l[m] && (l[m] = {index1:e[0], index2:e[1]});
              }
            }
          }
          for (m in l) {
            q = l[m], k.fromBufferAttribute(g, q.index1), a.push(k.x, k.y, k.z), k.fromBufferAttribute(g, q.index2), a.push(k.x, k.y, k.z);
          }
        } else {
          for (g = h.attributes.position, q = 0, d = g.count / 3; q < d; q++) {
            for (b = 0; 3 > b; b++) {
              l = 3 * q + b, k.fromBufferAttribute(g, l), a.push(k.x, k.y, k.z), l = 3 * q + (b + 1) % 3, k.fromBufferAttribute(g, l), a.push(k.x, k.y, k.z);
            }
          }
        }
      }
    }
    this.addAttribute("position", new N(a, 3));
  }
  function cd(h, a, b) {
    H.call(this);
    this.type = "ParametricGeometry";
    this.parameters = {func:h, slices:a, stacks:b};
    this.fromBufferGeometry(new qc(h, a, b));
    this.mergeVertices();
  }
  function qc(h, a, b) {
    O.call(this);
    this.type = "ParametricBufferGeometry";
    this.parameters = {func:h, slices:a, stacks:b};
    var r = [], d = [], c = [], e = [], l = new f, k = new f, F = new f, g = new f, q = new f, n, m;
    3 > h.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
    var t = a + 1;
    for (n = 0; n <= b; n++) {
      var u = n / b;
      for (m = 0; m <= a; m++) {
        var p = m / a;
        h(p, u, k);
        d.push(k.x, k.y, k.z);
        0 <= p - 1E-5 ? (h(p - 1E-5, u, F), g.subVectors(k, F)) : (h(p + 1E-5, u, F), g.subVectors(F, k));
        0 <= u - 1E-5 ? (h(p, u - 1E-5, F), q.subVectors(k, F)) : (h(p, u + 1E-5, F), q.subVectors(F, k));
        l.crossVectors(g, q).normalize();
        c.push(l.x, l.y, l.z);
        e.push(p, u);
      }
    }
    for (n = 0; n < b; n++) {
      for (m = 0; m < a; m++) {
        h = n * t + m + 1, l = (n + 1) * t + m + 1, k = (n + 1) * t + m, r.push(n * t + m, h, k), r.push(h, l, k);
      }
    }
    this.setIndex(r);
    this.addAttribute("position", new N(d, 3));
    this.addAttribute("normal", new N(c, 3));
    this.addAttribute("uv", new N(e, 2));
  }
  function dd(h, a, b, d) {
    H.call(this);
    this.type = "PolyhedronGeometry";
    this.parameters = {vertices:h, indices:a, radius:b, detail:d};
    this.fromBufferGeometry(new Ka(h, a, b, d));
    this.mergeVertices();
  }
  function Ka(h, a, b, d) {
    function r(h) {
      l.push(h.x, h.y, h.z);
    }
    function c(a, r) {
      a *= 3;
      r.x = h[a + 0];
      r.y = h[a + 1];
      r.z = h[a + 2];
    }
    function e(h, a, r, b) {
      0 > b && 1 === h.x && (k[a] = h.x - 1);
      0 === r.x && 0 === r.z && (k[a] = b / 2 / Math.PI + .5);
    }
    O.call(this);
    this.type = "PolyhedronBufferGeometry";
    this.parameters = {vertices:h, indices:a, radius:b, detail:d};
    b = b || 1;
    d = d || 0;
    var l = [], k = [];
    (function(h) {
      for (var b = new f, d = new f, e = new f, l = 0; l < a.length; l += 3) {
        c(a[l + 0], b);
        c(a[l + 1], d);
        c(a[l + 2], e);
        var k, F, g = b, q = d, n = e, m = Math.pow(2, h), t = [];
        for (F = 0; F <= m; F++) {
          t[F] = [];
          var u = g.clone().lerp(n, F / m), p = q.clone().lerp(n, F / m), v = m - F;
          for (k = 0; k <= v; k++) {
            t[F][k] = 0 === k && F === m ? u : u.clone().lerp(p, k / v);
          }
        }
        for (F = 0; F < m; F++) {
          for (k = 0; k < 2 * (m - F) - 1; k++) {
            g = Math.floor(k / 2), 0 === k % 2 ? (r(t[F][g + 1]), r(t[F + 1][g]), r(t[F][g])) : (r(t[F][g + 1]), r(t[F + 1][g + 1]), r(t[F + 1][g]));
          }
        }
      }
    })(d);
    (function(h) {
      for (var a = new f, r = 0; r < l.length; r += 3) {
        a.x = l[r + 0], a.y = l[r + 1], a.z = l[r + 2], a.normalize().multiplyScalar(h), l[r + 0] = a.x, l[r + 1] = a.y, l[r + 2] = a.z;
      }
    })(b);
    (function() {
      for (var h = new f, a = 0; a < l.length; a += 3) {
        h.x = l[a + 0], h.y = l[a + 1], h.z = l[a + 2], k.push(Math.atan2(h.z, -h.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-h.y, Math.sqrt(h.x * h.x + h.z * h.z)) / Math.PI + .5));
      }
      h = new f;
      a = new f;
      for (var r = new f, b = new f, d = new g, c = new g, F = new g, q = 0, n = 0; q < l.length; q += 9, n += 6) {
        h.set(l[q + 0], l[q + 1], l[q + 2]);
        a.set(l[q + 3], l[q + 4], l[q + 5]);
        r.set(l[q + 6], l[q + 7], l[q + 8]);
        d.set(k[n + 0], k[n + 1]);
        c.set(k[n + 2], k[n + 3]);
        F.set(k[n + 4], k[n + 5]);
        b.copy(h).add(a).add(r).divideScalar(3);
        var m = Math.atan2(b.z, -b.x);
        e(d, n + 0, h, m);
        e(c, n + 2, a, m);
        e(F, n + 4, r, m);
      }
      for (h = 0; h < k.length; h += 6) {
        a = k[h + 0], r = k[h + 2], b = k[h + 4], d = Math.min(a, r, b), .9 < Math.max(a, r, b) && .1 > d && (.2 > a && (k[h + 0] += 1), .2 > r && (k[h + 2] += 1), .2 > b && (k[h + 4] += 1));
      }
    })();
    this.addAttribute("position", new N(l, 3));
    this.addAttribute("normal", new N(l.slice(), 3));
    this.addAttribute("uv", new N(k, 2));
    0 === d ? this.computeVertexNormals() : this.normalizeNormals();
  }
  function ed(h, a) {
    H.call(this);
    this.type = "TetrahedronGeometry";
    this.parameters = {radius:h, detail:a};
    this.fromBufferGeometry(new rc(h, a));
    this.mergeVertices();
  }
  function rc(h, a) {
    Ka.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], h, a);
    this.type = "TetrahedronBufferGeometry";
    this.parameters = {radius:h, detail:a};
  }
  function fd(h, a) {
    H.call(this);
    this.type = "OctahedronGeometry";
    this.parameters = {radius:h, detail:a};
    this.fromBufferGeometry(new Qb(h, a));
    this.mergeVertices();
  }
  function Qb(h, a) {
    Ka.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], h, a);
    this.type = "OctahedronBufferGeometry";
    this.parameters = {radius:h, detail:a};
  }
  function gd(h, a) {
    H.call(this);
    this.type = "IcosahedronGeometry";
    this.parameters = {radius:h, detail:a};
    this.fromBufferGeometry(new sc(h, a));
    this.mergeVertices();
  }
  function sc(h, a) {
    var r = (1 + Math.sqrt(5)) / 2;
    Ka.call(this, [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], h, a);
    this.type = "IcosahedronBufferGeometry";
    this.parameters = {radius:h, detail:a};
  }
  function hd(h, a) {
    H.call(this);
    this.type = "DodecahedronGeometry";
    this.parameters = {radius:h, detail:a};
    this.fromBufferGeometry(new tc(h, a));
    this.mergeVertices();
  }
  function tc(h, a) {
    var r = (1 + Math.sqrt(5)) / 2, b = 1 / r;
    Ka.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -b, -r, 0, -b, r, 0, b, -r, 0, b, r, -b, -r, 0, -b, r, 0, b, -r, 0, b, r, 0, -r, 0, -b, r, 0, -b, -r, 0, b, r, 0, b], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 
    8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], h, a);
    this.type = "DodecahedronBufferGeometry";
    this.parameters = {radius:h, detail:a};
  }
  function id(h, a, b, d, f, c) {
    H.call(this);
    this.type = "TubeGeometry";
    this.parameters = {path:h, tubularSegments:a, radius:b, radialSegments:d, closed:f};
    void 0 !== c && console.warn("THREE.TubeGeometry: taper has been removed.");
    h = new Rb(h, a, b, d, f);
    this.tangents = h.tangents;
    this.normals = h.normals;
    this.binormals = h.binormals;
    this.fromBufferGeometry(h);
    this.mergeVertices();
  }
  function Rb(h, a, b, d, c) {
    function r(r) {
      q = h.getPointAt(r / a, q);
      var f = e.normals[r];
      r = e.binormals[r];
      for (m = 0; m <= d; m++) {
        var c = m / d * Math.PI * 2, g = Math.sin(c);
        c = -Math.cos(c);
        k.x = c * f.x + g * r.x;
        k.y = c * f.y + g * r.y;
        k.z = c * f.z + g * r.z;
        k.normalize();
        u.push(k.x, k.y, k.z);
        l.x = q.x + b * k.x;
        l.y = q.y + b * k.y;
        l.z = q.z + b * k.z;
        t.push(l.x, l.y, l.z);
      }
    }
    O.call(this);
    this.type = "TubeBufferGeometry";
    this.parameters = {path:h, tubularSegments:a, radius:b, radialSegments:d, closed:c};
    a = a || 64;
    b = b || 1;
    d = d || 8;
    c = c || !1;
    var e = h.computeFrenetFrames(a, c);
    this.tangents = e.tangents;
    this.normals = e.normals;
    this.binormals = e.binormals;
    var l = new f, k = new f, F = new g, q = new f, n, m, t = [], u = [], p = [], v = [];
    for (n = 0; n < a; n++) {
      r(n);
    }
    r(!1 === c ? a : 0);
    for (n = 0; n <= a; n++) {
      for (m = 0; m <= d; m++) {
        F.x = n / a, F.y = m / d, p.push(F.x, F.y);
      }
    }
    (function() {
      for (m = 1; m <= a; m++) {
        for (n = 1; n <= d; n++) {
          var h = (d + 1) * m + (n - 1), r = (d + 1) * m + n, b = (d + 1) * (m - 1) + n;
          v.push((d + 1) * (m - 1) + (n - 1), h, b);
          v.push(h, r, b);
        }
      }
    })();
    this.setIndex(v);
    this.addAttribute("position", new N(t, 3));
    this.addAttribute("normal", new N(u, 3));
    this.addAttribute("uv", new N(p, 2));
  }
  function jd(h, a, b, d, f, c, e) {
    H.call(this);
    this.type = "TorusKnotGeometry";
    this.parameters = {radius:h, tube:a, tubularSegments:b, radialSegments:d, p:f, q:c};
    void 0 !== e && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
    this.fromBufferGeometry(new uc(h, a, b, d, f, c));
    this.mergeVertices();
  }
  function uc(h, a, b, d, c, e) {
    function r(h, a, r, b, d) {
      var c = Math.sin(h);
      a = r / a * h;
      r = Math.cos(a);
      d.x = b * (2 + r) * .5 * Math.cos(h);
      d.y = b * (2 + r) * c * .5;
      d.z = b * Math.sin(a) * .5;
    }
    O.call(this);
    this.type = "TorusKnotBufferGeometry";
    this.parameters = {radius:h, tube:a, tubularSegments:b, radialSegments:d, p:c, q:e};
    h = h || 1;
    a = a || .4;
    b = Math.floor(b) || 64;
    d = Math.floor(d) || 8;
    c = c || 2;
    e = e || 3;
    var l = [], k = [], g = [], F = [], q, n = new f, m = new f, t = new f, u = new f, p = new f, v = new f, W = new f;
    for (q = 0; q <= b; ++q) {
      var w = q / b * c * Math.PI * 2;
      r(w, c, e, h, t);
      r(w + .01, c, e, h, u);
      v.subVectors(u, t);
      W.addVectors(u, t);
      p.crossVectors(v, W);
      W.crossVectors(p, v);
      p.normalize();
      W.normalize();
      for (w = 0; w <= d; ++w) {
        var Y = w / d * Math.PI * 2, z = -a * Math.cos(Y);
        Y = a * Math.sin(Y);
        n.x = t.x + (z * W.x + Y * p.x);
        n.y = t.y + (z * W.y + Y * p.y);
        n.z = t.z + (z * W.z + Y * p.z);
        k.push(n.x, n.y, n.z);
        m.subVectors(n, t).normalize();
        g.push(m.x, m.y, m.z);
        F.push(q / b);
        F.push(w / d);
      }
    }
    for (w = 1; w <= b; w++) {
      for (q = 1; q <= d; q++) {
        h = (d + 1) * w + (q - 1), a = (d + 1) * w + q, c = (d + 1) * (w - 1) + q, l.push((d + 1) * (w - 1) + (q - 1), h, c), l.push(h, a, c);
      }
    }
    this.setIndex(l);
    this.addAttribute("position", new N(k, 3));
    this.addAttribute("normal", new N(g, 3));
    this.addAttribute("uv", new N(F, 2));
  }
  function kd(h, a, b, d, c) {
    H.call(this);
    this.type = "TorusGeometry";
    this.parameters = {radius:h, tube:a, radialSegments:b, tubularSegments:d, arc:c};
    this.fromBufferGeometry(new vc(h, a, b, d, c));
    this.mergeVertices();
  }
  function vc(h, a, b, d, c) {
    O.call(this);
    this.type = "TorusBufferGeometry";
    this.parameters = {radius:h, tube:a, radialSegments:b, tubularSegments:d, arc:c};
    h = h || 1;
    a = a || .4;
    b = Math.floor(b) || 8;
    d = Math.floor(d) || 6;
    c = c || 2 * Math.PI;
    var r = [], e = [], l = [], k = [], g = new f, F = new f, q = new f, n, m;
    for (n = 0; n <= b; n++) {
      for (m = 0; m <= d; m++) {
        var t = m / d * c, u = n / b * Math.PI * 2;
        F.x = (h + a * Math.cos(u)) * Math.cos(t);
        F.y = (h + a * Math.cos(u)) * Math.sin(t);
        F.z = a * Math.sin(u);
        e.push(F.x, F.y, F.z);
        g.x = h * Math.cos(t);
        g.y = h * Math.sin(t);
        q.subVectors(F, g).normalize();
        l.push(q.x, q.y, q.z);
        k.push(m / d);
        k.push(n / b);
      }
    }
    for (n = 1; n <= b; n++) {
      for (m = 1; m <= d; m++) {
        h = (d + 1) * (n - 1) + m - 1, a = (d + 1) * (n - 1) + m, c = (d + 1) * n + m, r.push((d + 1) * n + m - 1, h, c), r.push(h, a, c);
      }
    }
    this.setIndex(r);
    this.addAttribute("position", new N(e, 3));
    this.addAttribute("normal", new N(l, 3));
    this.addAttribute("uv", new N(k, 2));
  }
  function yf(h, a, b, d, c) {
    for (var r, f = 0, e = a, l = b - d; e < b; e += d) {
      f += (h[l] - h[e]) * (h[e + 1] + h[l + 1]), l = e;
    }
    if (c === 0 < f) {
      for (c = a; c < b; c += d) {
        r = zf(c, h[c], h[c + 1], r);
      }
    } else {
      for (c = b - d; c >= a; c -= d) {
        r = zf(c, h[c], h[c + 1], r);
      }
    }
    r && Sb(r, r.next) && (ld(r), r = r.next);
    return r;
  }
  function md(h, a) {
    if (!h) {
      return h;
    }
    a || (a = h);
    do {
      var r = !1;
      if (h.steiner || !Sb(h, h.next) && 0 !== Ga(h.prev, h, h.next)) {
        h = h.next;
      } else {
        ld(h);
        h = a = h.prev;
        if (h === h.next) {
          break;
        }
        r = !0;
      }
    } while (r || h !== a);
    return a;
  }
  function nd(h, a, b, d, c, f, e) {
    if (h) {
      if (!e && f) {
        var r = h, l = r;
        do {
          null === l.z && (l.z = ye(l.x, l.y, d, c, f)), l.prevZ = l.prev, l = l.nextZ = l.next;
        } while (l !== r);
        l.prevZ.nextZ = null;
        l.prevZ = null;
        r = l;
        var k, g, F, q, n = 1;
        do {
          l = r;
          var m = r = null;
          for (g = 0; l;) {
            g++;
            var t = l;
            for (k = F = 0; k < n && (F++, t = t.nextZ, t); k++) {
            }
            for (q = n; 0 < F || 0 < q && t;) {
              0 !== F && (0 === q || !t || l.z <= t.z) ? (k = l, l = l.nextZ, F--) : (k = t, t = t.nextZ, q--), m ? m.nextZ = k : r = k, k.prevZ = m, m = k;
            }
            l = t;
          }
          m.nextZ = null;
          n *= 2;
        } while (1 < g);
      }
      for (r = h; h.prev !== h.next;) {
        l = h.prev;
        t = h.next;
        if (f) {
          a: {
            m = h;
            q = d;
            var u = c, p = f;
            g = m.prev;
            F = m;
            n = m.next;
            if (0 <= Ga(g, F, n)) {
              m = !1;
            } else {
              var v = g.x > F.x ? g.x > n.x ? g.x : n.x : F.x > n.x ? F.x : n.x, W = g.y > F.y ? g.y > n.y ? g.y : n.y : F.y > n.y ? F.y : n.y;
              k = ye(g.x < F.x ? g.x < n.x ? g.x : n.x : F.x < n.x ? F.x : n.x, g.y < F.y ? g.y < n.y ? g.y : n.y : F.y < n.y ? F.y : n.y, q, u, p);
              q = ye(v, W, q, u, p);
              for (u = m.nextZ; u && u.z <= q;) {
                if (u !== m.prev && u !== m.next && Sd(g.x, g.y, F.x, F.y, n.x, n.y, u.x, u.y) && 0 <= Ga(u.prev, u, u.next)) {
                  m = !1;
                  break a;
                }
                u = u.nextZ;
              }
              for (u = m.prevZ; u && u.z >= k;) {
                if (u !== m.prev && u !== m.next && Sd(g.x, g.y, F.x, F.y, n.x, n.y, u.x, u.y) && 0 <= Ga(u.prev, u, u.next)) {
                  m = !1;
                  break a;
                }
                u = u.prevZ;
              }
              m = !0;
            }
          }
        } else {
          a: {
            if (m = h, g = m.prev, F = m, n = m.next, 0 <= Ga(g, F, n)) {
              m = !1;
            } else {
              for (k = m.next.next; k !== m.prev;) {
                if (Sd(g.x, g.y, F.x, F.y, n.x, n.y, k.x, k.y) && 0 <= Ga(k.prev, k, k.next)) {
                  m = !1;
                  break a;
                }
                k = k.next;
              }
              m = !0;
            }
          }
        }
        if (m) {
          a.push(l.i / b), a.push(h.i / b), a.push(t.i / b), ld(h), r = h = t.next;
        } else {
          if (h = t, h === r) {
            if (!e) {
              nd(md(h), a, b, d, c, f, 1);
            } else {
              if (1 === e) {
                e = a;
                r = b;
                l = h;
                do {
                  t = l.prev, m = l.next.next, !Sb(t, m) && Af(t, l, l.next, m) && od(t, m) && od(m, t) && (e.push(t.i / r), e.push(l.i / r), e.push(m.i / r), ld(l), ld(l.next), l = h = m), l = l.next;
                } while (l !== h);
                h = l;
                nd(h, a, b, d, c, f, 2);
              } else {
                if (2 === e) {
                  a: {
                    e = h;
                    do {
                      for (r = e.next.next; r !== e.prev;) {
                        if (l = e.i !== r.i) {
                          l = e;
                          t = r;
                          if (m = l.next.i !== t.i && l.prev.i !== t.i) {
                            b: {
                              m = l;
                              do {
                                if (m.i !== l.i && m.next.i !== l.i && m.i !== t.i && m.next.i !== t.i && Af(m, m.next, l, t)) {
                                  m = !0;
                                  break b;
                                }
                                m = m.next;
                              } while (m !== l);
                              m = !1;
                            }
                            m = !m;
                          }
                          if (m = m && od(l, t) && od(t, l)) {
                            m = l;
                            g = !1;
                            F = (l.x + t.x) / 2;
                            t = (l.y + t.y) / 2;
                            do {
                              m.y > t !== m.next.y > t && m.next.y !== m.y && F < (m.next.x - m.x) * (t - m.y) / (m.next.y - m.y) + m.x && (g = !g), m = m.next;
                            } while (m !== l);
                            m = g;
                          }
                          l = m;
                        }
                        if (l) {
                          h = Bf(e, r);
                          e = md(e, e.next);
                          h = md(h, h.next);
                          nd(e, a, b, d, c, f);
                          nd(h, a, b, d, c, f);
                          break a;
                        }
                        r = r.next;
                      }
                      e = e.next;
                    } while (e !== h);
                  }
                }
              }
            }
            break;
          }
        }
      }
    }
  }
  function tg(h, a) {
    return h.x - a.x;
  }
  function ug(h, a) {
    var r = a, b = h.x, d = h.y, c = -Infinity;
    do {
      if (d <= r.y && d >= r.next.y && r.next.y !== r.y) {
        var f = r.x + (d - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
        if (f <= b && f > c) {
          c = f;
          if (f === b) {
            if (d === r.y) {
              return r;
            }
            if (d === r.next.y) {
              return r.next;
            }
          }
          var e = r.x < r.next.x ? r : r.next;
        }
      }
      r = r.next;
    } while (r !== a);
    if (!e) {
      return null;
    }
    if (b === c) {
      return e.prev;
    }
    a = e;
    f = e.x;
    var l = e.y, k = Infinity;
    for (r = e.next; r !== a;) {
      if (b >= r.x && r.x >= f && b !== r.x && Sd(d < l ? b : c, d, f, l, d < l ? c : b, d, r.x, r.y)) {
        var g = Math.abs(d - r.y) / (b - r.x);
        (g < k || g === k && r.x > e.x) && od(r, h) && (e = r, k = g);
      }
      r = r.next;
    }
    return e;
  }
  function ye(h, a, b, d, c) {
    h = 32767 * (h - b) * c;
    a = 32767 * (a - d) * c;
    h = (h | h << 8) & 16711935;
    h = (h | h << 4) & 252645135;
    h = (h | h << 2) & 858993459;
    a = (a | a << 8) & 16711935;
    a = (a | a << 4) & 252645135;
    a = (a | a << 2) & 858993459;
    return (h | h << 1) & 1431655765 | ((a | a << 1) & 1431655765) << 1;
  }
  function vg(h) {
    var a = h, b = h;
    do {
      a.x < b.x && (b = a), a = a.next;
    } while (a !== h);
    return b;
  }
  function Sd(h, a, b, d, c, f, e, l) {
    return 0 <= (c - e) * (a - l) - (h - e) * (f - l) && 0 <= (h - e) * (d - l) - (b - e) * (a - l) && 0 <= (b - e) * (f - l) - (c - e) * (d - l);
  }
  function Ga(h, a, b) {
    return (a.y - h.y) * (b.x - a.x) - (a.x - h.x) * (b.y - a.y);
  }
  function Sb(h, a) {
    return h.x === a.x && h.y === a.y;
  }
  function Af(h, a, b, d) {
    return Sb(h, a) && Sb(b, d) || Sb(h, d) && Sb(b, a) ? !0 : 0 < Ga(h, a, b) !== 0 < Ga(h, a, d) && 0 < Ga(b, d, h) !== 0 < Ga(b, d, a);
  }
  function od(h, a) {
    return 0 > Ga(h.prev, h, h.next) ? 0 <= Ga(h, a, h.next) && 0 <= Ga(h, h.prev, a) : 0 > Ga(h, a, h.prev) || 0 > Ga(h, h.next, a);
  }
  function Bf(h, a) {
    var r = new ze(h.i, h.x, h.y), b = new ze(a.i, a.x, a.y), d = h.next, c = a.prev;
    h.next = a;
    a.prev = h;
    r.next = d;
    d.prev = r;
    b.next = r;
    r.prev = b;
    c.next = b;
    b.prev = c;
    return b;
  }
  function zf(h, a, b, d) {
    h = new ze(h, a, b);
    d ? (h.next = d.next, h.prev = d, d.next.prev = h, d.next = h) : (h.prev = h, h.next = h);
    return h;
  }
  function ld(h) {
    h.next.prev = h.prev;
    h.prev.next = h.next;
    h.prevZ && (h.prevZ.nextZ = h.nextZ);
    h.nextZ && (h.nextZ.prevZ = h.prevZ);
  }
  function ze(h, a, b) {
    this.i = h;
    this.x = a;
    this.y = b;
    this.nextZ = this.prevZ = this.z = this.next = this.prev = null;
    this.steiner = !1;
  }
  function Cf(h) {
    var a = h.length;
    2 < a && h[a - 1].equals(h[0]) && h.pop();
  }
  function Df(h, a) {
    for (var r = 0; r < a.length; r++) {
      h.push(a[r].x), h.push(a[r].y);
    }
  }
  function Tb(h, a) {
    H.call(this);
    this.type = "ExtrudeGeometry";
    this.parameters = {shapes:h, options:a};
    this.fromBufferGeometry(new kb(h, a));
    this.mergeVertices();
  }
  function kb(h, a) {
    function r(h) {
      function r(h, a, r) {
        a || console.error("THREE.ExtrudeGeometry: vec does not exist");
        return a.clone().multiplyScalar(r).add(h);
      }
      function e(h, a, r) {
        var b = h.x - a.x, d = h.y - a.y, c = r.x - h.x, f = r.y - h.y, e = b * b + d * d;
        if (Math.abs(b * f - d * c) > Number.EPSILON) {
          var l = Math.sqrt(e), k = Math.sqrt(c * c + f * f);
          e = a.x - d / l;
          a = a.y + b / l;
          f = ((r.x - f / k - e) * f - (r.y + c / k - a) * c) / (b * f - d * c);
          c = e + b * f - h.x;
          b = a + d * f - h.y;
          d = c * c + b * b;
          if (2 >= d) {
            return new g(c, b);
          }
          d = Math.sqrt(d / 2);
        } else {
          h = !1, b > Number.EPSILON ? c > Number.EPSILON && (h = !0) : b < -Number.EPSILON ? c < -Number.EPSILON && (h = !0) : Math.sign(d) === Math.sign(f) && (h = !0), h ? (c = -d, d = Math.sqrt(e)) : (c = b, b = d, d = Math.sqrt(e / 2));
        }
        return new g(c / d, b / d);
      }
      function l(h, a) {
        for (I = h.length; 0 <= --I;) {
          var r = I, c = I - 1;
          0 > c && (c = h.length - 1);
          var f, e = u + 2 * Y;
          for (f = 0; f < e; f++) {
            var l = O * f, k = O * (f + 1), g = a + c + l, q = a + c + k;
            k = a + r + k;
            F(a + r + l);
            F(g);
            F(k);
            F(g);
            F(q);
            F(k);
            l = d.length / 3;
            l = y.generateSideWallUV(b, d, l - 6, l - 3, l - 2, l - 1);
            m(l[0]);
            m(l[1]);
            m(l[3]);
            m(l[1]);
            m(l[2]);
            m(l[3]);
          }
        }
      }
      function k(h, a, r) {
        n.push(h);
        n.push(a);
        n.push(r);
      }
      function q(h, a, r) {
        F(h);
        F(a);
        F(r);
        h = d.length / 3;
        h = y.generateTopUV(b, d, h - 3, h - 2, h - 1);
        m(h[0]);
        m(h[1]);
        m(h[2]);
      }
      function F(h) {
        d.push(n[3 * h]);
        d.push(n[3 * h + 1]);
        d.push(n[3 * h + 2]);
      }
      function m(h) {
        c.push(h.x);
        c.push(h.y);
      }
      var n = [], t = void 0 !== a.curveSegments ? a.curveSegments : 12, u = void 0 !== a.steps ? a.steps : 1, p = void 0 !== a.depth ? a.depth : 100, v = void 0 !== a.bevelEnabled ? a.bevelEnabled : !0, W = void 0 !== a.bevelThickness ? a.bevelThickness : 6, w = void 0 !== a.bevelSize ? a.bevelSize : W - 2, Y = void 0 !== a.bevelSegments ? a.bevelSegments : 3, z = a.extrudePath, y = void 0 !== a.UVGenerator ? a.UVGenerator : wg;
      void 0 !== a.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), p = a.amount);
      var T = !1;
      if (z) {
        var x = z.getSpacedPoints(u);
        T = !0;
        v = !1;
        var ya = z.computeFrenetFrames(u, !1), D = new f, C = new f, B = new f;
      }
      v || (w = W = Y = 0);
      var E;
      t = h.extractPoints(t);
      h = t.shape;
      var A = t.holes;
      if (!wb.isClockWise(h)) {
        h = h.reverse();
        var oa = 0;
        for (E = A.length; oa < E; oa++) {
          var G = A[oa];
          wb.isClockWise(G) && (A[oa] = G.reverse());
        }
      }
      var M = wb.triangulateShape(h, A), Ia = h;
      oa = 0;
      for (E = A.length; oa < E; oa++) {
        G = A[oa], h = h.concat(G);
      }
      var H, O = h.length, P, J = M.length;
      t = [];
      var I = 0, U = Ia.length, N = U - 1;
      for (H = I + 1; I < U; I++, N++, H++) {
        N === U && (N = 0), H === U && (H = 0), t[I] = e(Ia[I], Ia[N], Ia[H]);
      }
      z = [];
      var K = t.concat();
      oa = 0;
      for (E = A.length; oa < E; oa++) {
        G = A[oa];
        var Q = [];
        I = 0;
        U = G.length;
        N = U - 1;
        for (H = I + 1; I < U; I++, N++, H++) {
          N === U && (N = 0), H === U && (H = 0), Q[I] = e(G[I], G[N], G[H]);
        }
        z.push(Q);
        K = K.concat(Q);
      }
      for (N = 0; N < Y; N++) {
        U = N / Y;
        var L = W * Math.cos(U * Math.PI / 2);
        H = w * Math.sin(U * Math.PI / 2);
        I = 0;
        for (U = Ia.length; I < U; I++) {
          var S = r(Ia[I], t[I], H);
          k(S.x, S.y, -L);
        }
        oa = 0;
        for (E = A.length; oa < E; oa++) {
          for (G = A[oa], Q = z[oa], I = 0, U = G.length; I < U; I++) {
            S = r(G[I], Q[I], H), k(S.x, S.y, -L);
          }
        }
      }
      H = w;
      for (I = 0; I < O; I++) {
        S = v ? r(h[I], K[I], H) : h[I], T ? (C.copy(ya.normals[0]).multiplyScalar(S.x), D.copy(ya.binormals[0]).multiplyScalar(S.y), B.copy(x[0]).add(C).add(D), k(B.x, B.y, B.z)) : k(S.x, S.y, 0);
      }
      for (U = 1; U <= u; U++) {
        for (I = 0; I < O; I++) {
          S = v ? r(h[I], K[I], H) : h[I], T ? (C.copy(ya.normals[U]).multiplyScalar(S.x), D.copy(ya.binormals[U]).multiplyScalar(S.y), B.copy(x[U]).add(C).add(D), k(B.x, B.y, B.z)) : k(S.x, S.y, p / u * U);
        }
      }
      for (N = Y - 1; 0 <= N; N--) {
        U = N / Y;
        L = W * Math.cos(U * Math.PI / 2);
        H = w * Math.sin(U * Math.PI / 2);
        I = 0;
        for (U = Ia.length; I < U; I++) {
          S = r(Ia[I], t[I], H), k(S.x, S.y, p + L);
        }
        oa = 0;
        for (E = A.length; oa < E; oa++) {
          for (G = A[oa], Q = z[oa], I = 0, U = G.length; I < U; I++) {
            S = r(G[I], Q[I], H), T ? k(S.x, S.y + x[u - 1].y, x[u - 1].x + L) : k(S.x, S.y, p + L);
          }
        }
      }
      (function() {
        var h = d.length / 3;
        if (v) {
          var a = 0 * O;
          for (I = 0; I < J; I++) {
            P = M[I], q(P[2] + a, P[1] + a, P[0] + a);
          }
          a = O * (u + 2 * Y);
          for (I = 0; I < J; I++) {
            P = M[I], q(P[0] + a, P[1] + a, P[2] + a);
          }
        } else {
          for (I = 0; I < J; I++) {
            P = M[I], q(P[2], P[1], P[0]);
          }
          for (I = 0; I < J; I++) {
            P = M[I], q(P[0] + O * u, P[1] + O * u, P[2] + O * u);
          }
        }
        b.addGroup(h, d.length / 3 - h, 0);
      })();
      (function() {
        var h = d.length / 3, a = 0;
        l(Ia, a);
        a += Ia.length;
        oa = 0;
        for (E = A.length; oa < E; oa++) {
          G = A[oa], l(G, a), a += G.length;
        }
        b.addGroup(h, d.length / 3 - h, 1);
      })();
    }
    O.call(this);
    this.type = "ExtrudeBufferGeometry";
    this.parameters = {shapes:h, options:a};
    h = Array.isArray(h) ? h : [h];
    for (var b = this, d = [], c = [], e = 0, l = h.length; e < l; e++) {
      r(h[e]);
    }
    this.addAttribute("position", new N(d, 3));
    this.addAttribute("uv", new N(c, 2));
    this.computeVertexNormals();
  }
  function Ef(h, a, b) {
    b.shapes = [];
    if (Array.isArray(h)) {
      for (var r = 0, d = h.length; r < d; r++) {
        b.shapes.push(h[r].uuid);
      }
    } else {
      b.shapes.push(h.uuid);
    }
    void 0 !== a.extrudePath && (b.options.extrudePath = a.extrudePath.toJSON());
    return b;
  }
  function pd(h, a) {
    H.call(this);
    this.type = "TextGeometry";
    this.parameters = {text:h, parameters:a};
    this.fromBufferGeometry(new wc(h, a));
    this.mergeVertices();
  }
  function wc(h, a) {
    a = a || {};
    var r = a.font;
    if (!r || !r.isFont) {
      return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new H;
    }
    h = r.generateShapes(h, a.size);
    a.depth = void 0 !== a.height ? a.height : 50;
    void 0 === a.bevelThickness && (a.bevelThickness = 10);
    void 0 === a.bevelSize && (a.bevelSize = 8);
    void 0 === a.bevelEnabled && (a.bevelEnabled = !1);
    kb.call(this, h, a);
    this.type = "TextBufferGeometry";
  }
  function qd(h, a, b, d, c, f, e) {
    H.call(this);
    this.type = "SphereGeometry";
    this.parameters = {radius:h, widthSegments:a, heightSegments:b, phiStart:d, phiLength:c, thetaStart:f, thetaLength:e};
    this.fromBufferGeometry(new Ub(h, a, b, d, c, f, e));
    this.mergeVertices();
  }
  function Ub(h, a, b, d, c, e, l) {
    O.call(this);
    this.type = "SphereBufferGeometry";
    this.parameters = {radius:h, widthSegments:a, heightSegments:b, phiStart:d, phiLength:c, thetaStart:e, thetaLength:l};
    h = h || 1;
    a = Math.max(3, Math.floor(a) || 8);
    b = Math.max(2, Math.floor(b) || 6);
    d = void 0 !== d ? d : 0;
    c = void 0 !== c ? c : 2 * Math.PI;
    e = void 0 !== e ? e : 0;
    l = void 0 !== l ? l : Math.PI;
    var r = e + l, k, g, q = 0, F = [], m = new f, n = new f, t = [], u = [], p = [], v = [];
    for (g = 0; g <= b; g++) {
      var W = [], w = g / b;
      for (k = 0; k <= a; k++) {
        var Y = k / a;
        m.x = -h * Math.cos(d + Y * c) * Math.sin(e + w * l);
        m.y = h * Math.cos(e + w * l);
        m.z = h * Math.sin(d + Y * c) * Math.sin(e + w * l);
        u.push(m.x, m.y, m.z);
        n.set(m.x, m.y, m.z).normalize();
        p.push(n.x, n.y, n.z);
        v.push(Y, 1 - w);
        W.push(q++);
      }
      F.push(W);
    }
    for (g = 0; g < b; g++) {
      for (k = 0; k < a; k++) {
        h = F[g][k + 1], d = F[g][k], c = F[g + 1][k], l = F[g + 1][k + 1], (0 !== g || 0 < e) && t.push(h, d, l), (g !== b - 1 || r < Math.PI) && t.push(d, c, l);
      }
    }
    this.setIndex(t);
    this.addAttribute("position", new N(u, 3));
    this.addAttribute("normal", new N(p, 3));
    this.addAttribute("uv", new N(v, 2));
  }
  function rd(h, a, b, d, c, f) {
    H.call(this);
    this.type = "RingGeometry";
    this.parameters = {innerRadius:h, outerRadius:a, thetaSegments:b, phiSegments:d, thetaStart:c, thetaLength:f};
    this.fromBufferGeometry(new xc(h, a, b, d, c, f));
    this.mergeVertices();
  }
  function xc(h, a, b, d, c, e) {
    O.call(this);
    this.type = "RingBufferGeometry";
    this.parameters = {innerRadius:h, outerRadius:a, thetaSegments:b, phiSegments:d, thetaStart:c, thetaLength:e};
    h = h || .5;
    a = a || 1;
    c = void 0 !== c ? c : 0;
    e = void 0 !== e ? e : 2 * Math.PI;
    b = void 0 !== b ? Math.max(3, b) : 8;
    d = void 0 !== d ? Math.max(1, d) : 1;
    var r = [], l = [], k = [], q = [], F = h, m = (a - h) / d, n = new f, t = new g, u, p;
    for (u = 0; u <= d; u++) {
      for (p = 0; p <= b; p++) {
        h = c + p / b * e, n.x = F * Math.cos(h), n.y = F * Math.sin(h), l.push(n.x, n.y, n.z), k.push(0, 0, 1), t.x = (n.x / a + 1) / 2, t.y = (n.y / a + 1) / 2, q.push(t.x, t.y);
      }
      F += m;
    }
    for (u = 0; u < d; u++) {
      for (a = u * (b + 1), p = 0; p < b; p++) {
        h = p + a, c = h + b + 1, e = h + b + 2, F = h + 1, r.push(h, c, F), r.push(c, e, F);
      }
    }
    this.setIndex(r);
    this.addAttribute("position", new N(l, 3));
    this.addAttribute("normal", new N(k, 3));
    this.addAttribute("uv", new N(q, 2));
  }
  function sd(h, a, b, d) {
    H.call(this);
    this.type = "LatheGeometry";
    this.parameters = {points:h, segments:a, phiStart:b, phiLength:d};
    this.fromBufferGeometry(new yc(h, a, b, d));
    this.mergeVertices();
  }
  function yc(h, a, b, d) {
    O.call(this);
    this.type = "LatheBufferGeometry";
    this.parameters = {points:h, segments:a, phiStart:b, phiLength:d};
    a = Math.floor(a) || 12;
    b = b || 0;
    d = d || 2 * Math.PI;
    d = ia.clamp(d, 0, 2 * Math.PI);
    var r = [], c = [], e = [], l = 1 / a, k = new f, q = new g, F;
    for (F = 0; F <= a; F++) {
      var m = b + F * l * d, n = Math.sin(m), t = Math.cos(m);
      for (m = 0; m <= h.length - 1; m++) {
        k.x = h[m].x * n, k.y = h[m].y, k.z = h[m].x * t, c.push(k.x, k.y, k.z), q.x = F / a, q.y = m / (h.length - 1), e.push(q.x, q.y);
      }
    }
    for (F = 0; F < a; F++) {
      for (m = 0; m < h.length - 1; m++) {
        b = m + F * h.length, l = b + h.length, k = b + h.length + 1, q = b + 1, r.push(b, l, q), r.push(l, k, q);
      }
    }
    this.setIndex(r);
    this.addAttribute("position", new N(c, 3));
    this.addAttribute("uv", new N(e, 2));
    this.computeVertexNormals();
    if (d === 2 * Math.PI) {
      for (d = this.attributes.normal.array, r = new f, c = new f, e = new f, b = a * h.length * 3, m = F = 0; F < h.length; F++, m += 3) {
        r.x = d[m + 0], r.y = d[m + 1], r.z = d[m + 2], c.x = d[b + m + 0], c.y = d[b + m + 1], c.z = d[b + m + 2], e.addVectors(r, c).normalize(), d[m + 0] = d[b + m + 0] = e.x, d[m + 1] = d[b + m + 1] = e.y, d[m + 2] = d[b + m + 2] = e.z;
      }
    }
  }
  function Vb(h, a) {
    H.call(this);
    this.type = "ShapeGeometry";
    "object" === typeof a && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), a = a.curveSegments);
    this.parameters = {shapes:h, curveSegments:a};
    this.fromBufferGeometry(new Wb(h, a));
    this.mergeVertices();
  }
  function Wb(h, a) {
    function r(h) {
      var r, e = d.length / 3;
      h = h.extractPoints(a);
      var k = h.shape, g = h.holes;
      !1 === wb.isClockWise(k) && (k = k.reverse());
      h = 0;
      for (r = g.length; h < r; h++) {
        var q = g[h];
        !0 === wb.isClockWise(q) && (g[h] = q.reverse());
      }
      var F = wb.triangulateShape(k, g);
      h = 0;
      for (r = g.length; h < r; h++) {
        q = g[h], k = k.concat(q);
      }
      h = 0;
      for (r = k.length; h < r; h++) {
        q = k[h], d.push(q.x, q.y, 0), c.push(0, 0, 1), f.push(q.x, q.y);
      }
      h = 0;
      for (r = F.length; h < r; h++) {
        k = F[h], b.push(k[0] + e, k[1] + e, k[2] + e), l += 3;
      }
    }
    O.call(this);
    this.type = "ShapeBufferGeometry";
    this.parameters = {shapes:h, curveSegments:a};
    a = a || 12;
    var b = [], d = [], c = [], f = [], e = 0, l = 0;
    if (!1 === Array.isArray(h)) {
      r(h);
    } else {
      for (var k = 0; k < h.length; k++) {
        r(h[k]), this.addGroup(e, l, k), e += l, l = 0;
      }
    }
    this.setIndex(b);
    this.addAttribute("position", new N(d, 3));
    this.addAttribute("normal", new N(c, 3));
    this.addAttribute("uv", new N(f, 2));
  }
  function Ff(h, a) {
    a.shapes = [];
    if (Array.isArray(h)) {
      for (var r = 0, b = h.length; r < b; r++) {
        a.shapes.push(h[r].uuid);
      }
    } else {
      a.shapes.push(h.uuid);
    }
    return a;
  }
  function zc(h, a) {
    O.call(this);
    this.type = "EdgesGeometry";
    this.parameters = {thresholdAngle:a};
    var r = [];
    a = Math.cos(ia.DEG2RAD * (void 0 !== a ? a : 1));
    var b = [0, 0], d = {}, c = ["a", "b", "c"];
    if (h.isBufferGeometry) {
      var f = new H;
      f.fromBufferGeometry(h);
    } else {
      f = h.clone();
    }
    f.mergeVertices();
    f.computeFaceNormals();
    h = f.vertices;
    f = f.faces;
    for (var e = 0, l = f.length; e < l; e++) {
      for (var k = f[e], g = 0; 3 > g; g++) {
        var q = k[c[g]], m = k[c[(g + 1) % 3]];
        b[0] = Math.min(q, m);
        b[1] = Math.max(q, m);
        q = b[0] + "," + b[1];
        void 0 === d[q] ? d[q] = {index1:b[0], index2:b[1], face1:e, face2:void 0} : d[q].face2 = e;
      }
    }
    for (q in d) {
      if (b = d[q], void 0 === b.face2 || f[b.face1].normal.dot(f[b.face2].normal) <= a) {
        c = h[b.index1], r.push(c.x, c.y, c.z), c = h[b.index2], r.push(c.x, c.y, c.z);
      }
    }
    this.addAttribute("position", new N(r, 3));
  }
  function Xb(h, a, b, d, c, f, e, l) {
    H.call(this);
    this.type = "CylinderGeometry";
    this.parameters = {radiusTop:h, radiusBottom:a, height:b, radialSegments:d, heightSegments:c, openEnded:f, thetaStart:e, thetaLength:l};
    this.fromBufferGeometry(new xb(h, a, b, d, c, f, e, l));
    this.mergeVertices();
  }
  function xb(h, a, b, d, c, e, l, k) {
    function r(r) {
      var b, c = new g, e = new f, p = 0, w = !0 === r ? h : a, z = !0 === r ? 1 : -1, Y = u;
      for (b = 1; b <= d; b++) {
        m.push(0, v * z, 0), n.push(0, z, 0), t.push(.5, .5), u++;
      }
      var y = u;
      for (b = 0; b <= d; b++) {
        var x = b / d * k + l, T = Math.cos(x);
        x = Math.sin(x);
        e.x = w * x;
        e.y = v * z;
        e.z = w * T;
        m.push(e.x, e.y, e.z);
        n.push(0, z, 0);
        c.x = .5 * T + .5;
        c.y = .5 * x * z + .5;
        t.push(c.x, c.y);
        u++;
      }
      for (b = 0; b < d; b++) {
        c = Y + b, e = y + b, !0 === r ? F.push(e, e + 1, c) : F.push(e + 1, e, c), p += 3;
      }
      q.addGroup(W, p, !0 === r ? 1 : 2);
      W += p;
    }
    O.call(this);
    this.type = "CylinderBufferGeometry";
    this.parameters = {radiusTop:h, radiusBottom:a, height:b, radialSegments:d, heightSegments:c, openEnded:e, thetaStart:l, thetaLength:k};
    var q = this;
    h = void 0 !== h ? h : 1;
    a = void 0 !== a ? a : 1;
    b = b || 1;
    d = Math.floor(d) || 8;
    c = Math.floor(c) || 1;
    e = void 0 !== e ? e : !1;
    l = void 0 !== l ? l : 0;
    k = void 0 !== k ? k : 2 * Math.PI;
    var F = [], m = [], n = [], t = [], u = 0, p = [], v = b / 2, W = 0;
    (function() {
      var r, e, g = new f, w = new f, z = 0, Y = (a - h) / b;
      for (e = 0; e <= c; e++) {
        var y = [], x = e / c, T = x * (a - h) + h;
        for (r = 0; r <= d; r++) {
          var D = r / d, ya = D * k + l, C = Math.sin(ya);
          ya = Math.cos(ya);
          w.x = T * C;
          w.y = -x * b + v;
          w.z = T * ya;
          m.push(w.x, w.y, w.z);
          g.set(C, Y, ya).normalize();
          n.push(g.x, g.y, g.z);
          t.push(D, 1 - x);
          y.push(u++);
        }
        p.push(y);
      }
      for (r = 0; r < d; r++) {
        for (e = 0; e < c; e++) {
          g = p[e + 1][r], w = p[e + 1][r + 1], Y = p[e][r + 1], F.push(p[e][r], g, Y), F.push(g, w, Y), z += 6;
        }
      }
      q.addGroup(W, z, 0);
      W += z;
    })();
    !1 === e && (0 < h && r(!0), 0 < a && r(!1));
    this.setIndex(F);
    this.addAttribute("position", new N(m, 3));
    this.addAttribute("normal", new N(n, 3));
    this.addAttribute("uv", new N(t, 2));
  }
  function td(h, a, b, d, c, f, e) {
    Xb.call(this, 0, h, a, b, d, c, f, e);
    this.type = "ConeGeometry";
    this.parameters = {radius:h, height:a, radialSegments:b, heightSegments:d, openEnded:c, thetaStart:f, thetaLength:e};
  }
  function ud(h, a, b, d, c, f, e) {
    xb.call(this, 0, h, a, b, d, c, f, e);
    this.type = "ConeBufferGeometry";
    this.parameters = {radius:h, height:a, radialSegments:b, heightSegments:d, openEnded:c, thetaStart:f, thetaLength:e};
  }
  function vd(h, a, b, d) {
    H.call(this);
    this.type = "CircleGeometry";
    this.parameters = {radius:h, segments:a, thetaStart:b, thetaLength:d};
    this.fromBufferGeometry(new Ac(h, a, b, d));
    this.mergeVertices();
  }
  function Ac(h, a, b, d) {
    O.call(this);
    this.type = "CircleBufferGeometry";
    this.parameters = {radius:h, segments:a, thetaStart:b, thetaLength:d};
    h = h || 1;
    a = void 0 !== a ? Math.max(3, a) : 8;
    b = void 0 !== b ? b : 0;
    d = void 0 !== d ? d : 2 * Math.PI;
    var r = [], c = [], e = [], l = [], k, q = new f, F = new g;
    c.push(0, 0, 0);
    e.push(0, 0, 1);
    l.push(.5, .5);
    var m = 0;
    for (k = 3; m <= a; m++, k += 3) {
      var n = b + m / a * d;
      q.x = h * Math.cos(n);
      q.y = h * Math.sin(n);
      c.push(q.x, q.y, q.z);
      e.push(0, 0, 1);
      F.x = (c[k] / h + 1) / 2;
      F.y = (c[k + 1] / h + 1) / 2;
      l.push(F.x, F.y);
    }
    for (k = 1; k <= a; k++) {
      r.push(k, k + 1, 0);
    }
    this.setIndex(r);
    this.addAttribute("position", new N(c, 3));
    this.addAttribute("normal", new N(e, 3));
    this.addAttribute("uv", new N(l, 2));
  }
  function Yb(h) {
    X.call(this);
    this.type = "ShadowMaterial";
    this.color = new z(0);
    this.transparent = !0;
    this.setValues(h);
  }
  function Bc(h) {
    fa.call(this, h);
    this.type = "RawShaderMaterial";
  }
  function lb(h) {
    X.call(this);
    this.defines = {STANDARD:""};
    this.type = "MeshStandardMaterial";
    this.color = new z(16777215);
    this.metalness = this.roughness = .5;
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new z(0);
    this.emissiveIntensity = 1;
    this.bumpMap = this.emissiveMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new g(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(h);
  }
  function Zb(h) {
    lb.call(this);
    this.defines = {PHYSICAL:""};
    this.type = "MeshPhysicalMaterial";
    this.reflectivity = .5;
    this.clearCoatRoughness = this.clearCoat = 0;
    this.setValues(h);
  }
  function Ya(h) {
    X.call(this);
    this.type = "MeshPhongMaterial";
    this.color = new z(16777215);
    this.specular = new z(1118481);
    this.shininess = 30;
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new z(0);
    this.emissiveIntensity = 1;
    this.bumpMap = this.emissiveMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new g(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.envMap = this.alphaMap = this.specularMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(h);
  }
  function $b(h) {
    Ya.call(this);
    this.defines = {TOON:""};
    this.type = "MeshToonMaterial";
    this.gradientMap = null;
    this.setValues(h);
  }
  function ac(h) {
    X.call(this);
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new g(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1;
    this.setValues(h);
  }
  function bc(h) {
    X.call(this);
    this.type = "MeshLambertMaterial";
    this.color = new z(16777215);
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new z(0);
    this.emissiveIntensity = 1;
    this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(h);
  }
  function cc(h) {
    X.call(this);
    this.defines = {MATCAP:""};
    this.type = "MeshMatcapMaterial";
    this.color = new z(16777215);
    this.bumpMap = this.map = this.matcap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new g(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.lights = this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(h);
  }
  function dc(h) {
    ra.call(this);
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(h);
  }
  function Na(h, a, b, d) {
    this.parameterPositions = h;
    this._cachedIndex = 0;
    this.resultBuffer = void 0 !== d ? d : new a.constructor(b);
    this.sampleValues = a;
    this.valueSize = b;
  }
  function Td(h, a, b, d) {
    Na.call(this, h, a, b, d);
    this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0;
  }
  function wd(h, a, b, d) {
    Na.call(this, h, a, b, d);
  }
  function Ud(h, a, b, d) {
    Na.call(this, h, a, b, d);
  }
  function Da(h, a, b, d) {
    if (void 0 === h) {
      throw Error("THREE.KeyframeTrack: track name is undefined");
    }
    if (void 0 === a || 0 === a.length) {
      throw Error("THREE.KeyframeTrack: no keyframes in track named " + h);
    }
    this.name = h;
    this.times = xa.convertArray(a, this.TimeBufferType);
    this.values = xa.convertArray(b, this.ValueBufferType);
    this.setInterpolation(d || this.DefaultInterpolation);
  }
  function Vd(h, a, b) {
    Da.call(this, h, a, b);
  }
  function Wd(h, a, b, d) {
    Da.call(this, h, a, b, d);
  }
  function Cc(h, a, b, d) {
    Da.call(this, h, a, b, d);
  }
  function Xd(h, a, b, d) {
    Na.call(this, h, a, b, d);
  }
  function xd(h, a, b, d) {
    Da.call(this, h, a, b, d);
  }
  function Yd(h, a, b, d) {
    Da.call(this, h, a, b, d);
  }
  function Dc(h, a, b, d) {
    Da.call(this, h, a, b, d);
  }
  function Ta(h, a, b) {
    this.name = h;
    this.tracks = b;
    this.duration = void 0 !== a ? a : -1;
    this.uuid = ia.generateUUID();
    0 > this.duration && this.resetDuration();
  }
  function xg(h) {
    switch(h.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return Cc;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return Dc;
      case "color":
        return Wd;
      case "quaternion":
        return xd;
      case "bool":
      case "boolean":
        return Vd;
      case "string":
        return Yd;
    }
    throw Error("THREE.KeyframeTrack: Unsupported typeName: " + h);
  }
  function yg(h) {
    if (void 0 === h.type) {
      throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
    }
    var a = xg(h.type);
    if (void 0 === h.times) {
      var b = [], d = [];
      xa.flattenJSON(h.keys, b, d, "value");
      h.times = b;
      h.values = d;
    }
    return void 0 !== a.parse ? a.parse(h) : new a(h.name, h.times, h.values, h.interpolation);
  }
  function Ae(h, a, b) {
    var r = this, d = !1, c = 0, f = 0, e = void 0;
    this.onStart = void 0;
    this.onLoad = h;
    this.onProgress = a;
    this.onError = b;
    this.itemStart = function(h) {
      f++;
      if (!1 === d && void 0 !== r.onStart) {
        r.onStart(h, c, f);
      }
      d = !0;
    };
    this.itemEnd = function(h) {
      c++;
      if (void 0 !== r.onProgress) {
        r.onProgress(h, c, f);
      }
      if (c === f && (d = !1, void 0 !== r.onLoad)) {
        r.onLoad();
      }
    };
    this.itemError = function(h) {
      if (void 0 !== r.onError) {
        r.onError(h);
      }
    };
    this.resolveURL = function(h) {
      return e ? e(h) : h;
    };
    this.setURLModifier = function(h) {
      e = h;
      return this;
    };
  }
  function Za(h) {
    this.manager = void 0 !== h ? h : La;
  }
  function Gf(h) {
    this.manager = void 0 !== h ? h : La;
  }
  function Hf(h) {
    this.manager = void 0 !== h ? h : La;
    this._parser = null;
  }
  function Be(h) {
    this.manager = void 0 !== h ? h : La;
    this._parser = null;
  }
  function yd(h) {
    this.manager = void 0 !== h ? h : La;
  }
  function Ce(h) {
    this.manager = void 0 !== h ? h : La;
  }
  function Zd(h) {
    this.manager = void 0 !== h ? h : La;
  }
  function da() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  function Oa(h, a, b, d, c, f, e, l) {
    da.call(this);
    this.type = "EllipseCurve";
    this.aX = h || 0;
    this.aY = a || 0;
    this.xRadius = b || 1;
    this.yRadius = d || 1;
    this.aStartAngle = c || 0;
    this.aEndAngle = f || 2 * Math.PI;
    this.aClockwise = e || !1;
    this.aRotation = l || 0;
  }
  function Ec(h, a, b, d, c, f) {
    Oa.call(this, h, a, b, b, d, c, f);
    this.type = "ArcCurve";
  }
  function De() {
    var h = 0, a = 0, b = 0, d = 0;
    return {initCatmullRom:function(r, c, f, e, l) {
      r = l * (f - r);
      e = l * (e - c);
      h = c;
      a = r;
      b = -3 * c + 3 * f - 2 * r - e;
      d = 2 * c - 2 * f + r + e;
    }, initNonuniformCatmullRom:function(r, c, f, e, l, k, g) {
      r = ((c - r) / l - (f - r) / (l + k) + (f - c) / k) * k;
      e = ((f - c) / k - (e - c) / (k + g) + (e - f) / g) * k;
      h = c;
      a = r;
      b = -3 * c + 3 * f - 2 * r - e;
      d = 2 * c - 2 * f + r + e;
    }, calc:function(r) {
      var c = r * r;
      return h + a * r + b * c + d * c * r;
    }};
  }
  function Ea(h, a, b, d) {
    da.call(this);
    this.type = "CatmullRomCurve3";
    this.points = h || [];
    this.closed = a || !1;
    this.curveType = b || "centripetal";
    this.tension = d || .5;
  }
  function If(h, a, b, d, c) {
    a = .5 * (d - a);
    c = .5 * (c - b);
    var r = h * h;
    return (2 * b - 2 * d + a + c) * h * r + (-3 * b + 3 * d - 2 * a - c) * r + a * h + b;
  }
  function zd(h, a, b, d) {
    var r = 1 - h;
    return r * r * a + 2 * (1 - h) * h * b + h * h * d;
  }
  function Ad(h, a, b, d, c) {
    var r = 1 - h, f = 1 - h;
    return r * r * r * a + 3 * f * f * h * b + 3 * (1 - h) * h * h * d + h * h * h * c;
  }
  function $a(h, a, b, d) {
    da.call(this);
    this.type = "CubicBezierCurve";
    this.v0 = h || new g;
    this.v1 = a || new g;
    this.v2 = b || new g;
    this.v3 = d || new g;
  }
  function mb(h, a, b, d) {
    da.call(this);
    this.type = "CubicBezierCurve3";
    this.v0 = h || new f;
    this.v1 = a || new f;
    this.v2 = b || new f;
    this.v3 = d || new f;
  }
  function Ma(h, a) {
    da.call(this);
    this.type = "LineCurve";
    this.v1 = h || new g;
    this.v2 = a || new g;
  }
  function ab(h, a) {
    da.call(this);
    this.type = "LineCurve3";
    this.v1 = h || new f;
    this.v2 = a || new f;
  }
  function bb(h, a, b) {
    da.call(this);
    this.type = "QuadraticBezierCurve";
    this.v0 = h || new g;
    this.v1 = a || new g;
    this.v2 = b || new g;
  }
  function nb(h, a, b) {
    da.call(this);
    this.type = "QuadraticBezierCurve3";
    this.v0 = h || new f;
    this.v1 = a || new f;
    this.v2 = b || new f;
  }
  function cb(h) {
    da.call(this);
    this.type = "SplineCurve";
    this.points = h || [];
  }
  function yb() {
    da.call(this);
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = !1;
  }
  function db(h) {
    yb.call(this);
    this.type = "Path";
    this.currentPoint = new g;
    h && this.setFromPoints(h);
  }
  function Lb(h) {
    db.call(this, h);
    this.uuid = ia.generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  function ta(h, a) {
    G.call(this);
    this.type = "Light";
    this.color = new z(h);
    this.intensity = void 0 !== a ? a : 1;
    this.receiveShadow = void 0;
  }
  function $d(h, a, b) {
    ta.call(this, h, b);
    this.type = "HemisphereLight";
    this.castShadow = void 0;
    this.position.copy(G.DefaultUp);
    this.updateMatrix();
    this.groundColor = new z(a);
  }
  function ec(h) {
    this.camera = h;
    this.bias = 0;
    this.radius = 1;
    this.mapSize = new g(512, 512);
    this.map = null;
    this.matrix = new b;
  }
  function ae() {
    ec.call(this, new va(50, 1, .5, 500));
  }
  function be(h, a, b, d, c, f) {
    ta.call(this, h, a);
    this.type = "SpotLight";
    this.position.copy(G.DefaultUp);
    this.updateMatrix();
    this.target = new G;
    Object.defineProperty(this, "power", {get:function() {
      return this.intensity * Math.PI;
    }, set:function(h) {
      this.intensity = h / Math.PI;
    }});
    this.distance = void 0 !== b ? b : 0;
    this.angle = void 0 !== d ? d : Math.PI / 3;
    this.penumbra = void 0 !== c ? c : 0;
    this.decay = void 0 !== f ? f : 1;
    this.shadow = new ae;
  }
  function ce(h, a, b, d) {
    ta.call(this, h, a);
    this.type = "PointLight";
    Object.defineProperty(this, "power", {get:function() {
      return 4 * this.intensity * Math.PI;
    }, set:function(h) {
      this.intensity = h / (4 * Math.PI);
    }});
    this.distance = void 0 !== b ? b : 0;
    this.decay = void 0 !== d ? d : 1;
    this.shadow = new ec(new va(90, 1, .5, 500));
  }
  function Bd(h, a, b, d, c, f) {
    jb.call(this);
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = void 0 !== h ? h : -1;
    this.right = void 0 !== a ? a : 1;
    this.top = void 0 !== b ? b : 1;
    this.bottom = void 0 !== d ? d : -1;
    this.near = void 0 !== c ? c : .1;
    this.far = void 0 !== f ? f : 2E3;
    this.updateProjectionMatrix();
  }
  function de() {
    ec.call(this, new Bd(-5, 5, 5, -5, .5, 500));
  }
  function ee(h, a) {
    ta.call(this, h, a);
    this.type = "DirectionalLight";
    this.position.copy(G.DefaultUp);
    this.updateMatrix();
    this.target = new G;
    this.shadow = new de;
  }
  function fe(h, a) {
    ta.call(this, h, a);
    this.type = "AmbientLight";
    this.castShadow = void 0;
  }
  function ge(h, a, b, d) {
    ta.call(this, h, a);
    this.type = "RectAreaLight";
    this.width = void 0 !== b ? b : 10;
    this.height = void 0 !== d ? d : 10;
  }
  function he(h) {
    this.manager = void 0 !== h ? h : La;
    this.textures = {};
  }
  function Ee(h) {
    this.manager = void 0 !== h ? h : La;
  }
  function Fe(h) {
    this.manager = void 0 !== h ? h : La;
    this.resourcePath = "";
  }
  function Ge(h) {
    "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    this.manager = void 0 !== h ? h : La;
    this.options = void 0;
  }
  function He() {
    this.type = "ShapePath";
    this.color = new z;
    this.subPaths = [];
    this.currentPath = null;
  }
  function Ie(h) {
    this.type = "Font";
    this.data = h;
  }
  function Jf(h) {
    this.manager = void 0 !== h ? h : La;
  }
  function Cd() {
  }
  function Je(h) {
    this.manager = void 0 !== h ? h : La;
  }
  function Kf() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = .064;
    this.cameraL = new va;
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = !1;
    this.cameraR = new va;
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = !1;
  }
  function Dd(h, a, b, c) {
    G.call(this);
    this.type = "CubeCamera";
    var r = new va(90, 1, h, a);
    r.up.set(0, -1, 0);
    r.lookAt(new f(1, 0, 0));
    this.add(r);
    var e = new va(90, 1, h, a);
    e.up.set(0, -1, 0);
    e.lookAt(new f(-1, 0, 0));
    this.add(e);
    var l = new va(90, 1, h, a);
    l.up.set(0, 0, 1);
    l.lookAt(new f(0, 1, 0));
    this.add(l);
    var k = new va(90, 1, h, a);
    k.up.set(0, 0, -1);
    k.lookAt(new f(0, -1, 0));
    this.add(k);
    var g = new va(90, 1, h, a);
    g.up.set(0, -1, 0);
    g.lookAt(new f(0, 0, 1));
    this.add(g);
    var q = new va(90, 1, h, a);
    q.up.set(0, -1, 0);
    q.lookAt(new f(0, 0, -1));
    this.add(q);
    c = c || {format:1022, magFilter:1006, minFilter:1006};
    this.renderTarget = new d(b, b, c);
    this.renderTarget.texture.name = "CubeCamera";
    this.update = function(h, a) {
      null === this.parent && this.updateMatrixWorld();
      var b = h.getRenderTarget(), d = this.renderTarget, c = d.texture.generateMipmaps;
      d.texture.generateMipmaps = !1;
      h.setRenderTarget(d, 0);
      h.render(a, r);
      h.setRenderTarget(d, 1);
      h.render(a, e);
      h.setRenderTarget(d, 2);
      h.render(a, l);
      h.setRenderTarget(d, 3);
      h.render(a, k);
      h.setRenderTarget(d, 4);
      h.render(a, g);
      d.texture.generateMipmaps = c;
      h.setRenderTarget(d, 5);
      h.render(a, q);
      h.setRenderTarget(b);
    };
    this.clear = function(h, a, b, r) {
      for (var d = h.getRenderTarget(), c = this.renderTarget, f = 0; 6 > f; f++) {
        c.activeCubeFace = f, h.setRenderTarget(c), h.clear(a, b, r);
      }
      h.setRenderTarget(d);
    };
  }
  function Ke(h) {
    this.autoStart = void 0 !== h ? h : !0;
    this.elapsedTime = this.oldTime = this.startTime = 0;
    this.running = !1;
  }
  function Le() {
    G.call(this);
    this.type = "AudioListener";
    this.context = Me.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
  }
  function Fc(h) {
    G.call(this);
    this.type = "Audio";
    this.listener = h;
    this.context = h.context;
    this.gain = this.context.createGain();
    this.gain.connect(h.getInput());
    this.autoplay = !1;
    this.buffer = null;
    this.detune = 0;
    this.loop = !1;
    this.offset = this.startTime = 0;
    this.playbackRate = 1;
    this.isPlaying = !1;
    this.hasPlaybackControl = !0;
    this.sourceType = "empty";
    this.filters = [];
  }
  function Ne(h) {
    Fc.call(this, h);
    this.panner = this.context.createPanner();
    this.panner.connect(this.gain);
  }
  function Oe(h, a) {
    this.analyser = h.context.createAnalyser();
    this.analyser.fftSize = void 0 !== a ? a : 2048;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    h.getOutput().connect(this.analyser);
  }
  function Pe(h, a, b) {
    this.binding = h;
    this.valueSize = b;
    h = Float64Array;
    switch(a) {
      case "quaternion":
        a = this._slerp;
        break;
      case "string":
      case "bool":
        h = Array;
        a = this._select;
        break;
      default:
        a = this._lerp;
    }
    this.buffer = new h(4 * b);
    this._mixBufferRegion = a;
    this.referenceCount = this.useCount = this.cumulativeWeight = 0;
  }
  function Lf(h, a, b) {
    b = b || Fa.parseTrackName(a);
    this._targetGroup = h;
    this._bindings = h.subscribe_(a, b);
  }
  function Fa(h, a, b) {
    this.path = a;
    this.parsedPath = b || Fa.parseTrackName(a);
    this.node = Fa.findNode(h, this.parsedPath.nodeName) || h;
    this.rootNode = h;
  }
  function Mf() {
    this.uuid = ia.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    var h = {};
    this._indicesByUUID = h;
    for (var a = 0, b = arguments.length; a !== b; ++a) {
      h[arguments[a].uuid] = a;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    var d = this;
    this.stats = {objects:{get total() {
      return d._objects.length;
    }, get inUse() {
      return this.total - d.nCachedObjects_;
    }}, get bindingsPerObject() {
      return d._bindings.length;
    }};
  }
  function Nf(h, a, b) {
    this._mixer = h;
    this._clip = a;
    this._localRoot = b || null;
    h = a.tracks;
    a = h.length;
    b = Array(a);
    for (var r = {endingStart:2400, endingEnd:2400}, d = 0; d !== a; ++d) {
      var c = h[d].createInterpolant(null);
      b[d] = c;
      c.settings = r;
    }
    this._interpolantSettings = r;
    this._interpolants = b;
    this._propertyBindings = Array(a);
    this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null;
    this.loop = 2201;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1;
    this.repetitions = Infinity;
    this.paused = !1;
    this.enabled = !0;
    this.clampWhenFinished = !1;
    this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
  }
  function Qe(h) {
    this._root = h;
    this._initMemoryManager();
    this.time = this._accuIndex = 0;
    this.timeScale = 1;
  }
  function ie(h, a) {
    "string" === typeof h && (console.warn("THREE.Uniform: Type parameter is no longer needed."), h = a);
    this.value = h;
  }
  function Re() {
    O.call(this);
    this.type = "InstancedBufferGeometry";
    this.maxInstancedCount = void 0;
  }
  function Se(h, a, b) {
    Pb.call(this, h, a);
    this.meshPerAttribute = b || 1;
  }
  function Te(h, a, b, d) {
    "number" === typeof b && (d = b, b = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));
    K.call(this, h, a, b);
    this.meshPerAttribute = d || 1;
  }
  function Of(h, a, b, d) {
    this.ray = new ba(h, a);
    this.near = b || 0;
    this.far = d || Infinity;
    this.params = {Mesh:{}, Line:{}, LOD:{}, Points:{threshold:1}, Sprite:{}};
    Object.defineProperties(this.params, {PointCloud:{get:function() {
      console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
      return this.Points;
    }}});
  }
  function Pf(h, a) {
    return h.distance - a.distance;
  }
  function Ue(h, a, b, d) {
    if (!1 !== h.visible && (h.raycast(a, b), !0 === d)) {
      h = h.children;
      d = 0;
      for (var r = h.length; d < r; d++) {
        Ue(h[d], a, b, !0);
      }
    }
  }
  function Qf(h, a, b) {
    this.radius = void 0 !== h ? h : 1;
    this.phi = void 0 !== a ? a : 0;
    this.theta = void 0 !== b ? b : 0;
    return this;
  }
  function Rf(h, a, b) {
    this.radius = void 0 !== h ? h : 1;
    this.theta = void 0 !== a ? a : 0;
    this.y = void 0 !== b ? b : 0;
    return this;
  }
  function Ve(h, a) {
    this.min = void 0 !== h ? h : new g(Infinity, Infinity);
    this.max = void 0 !== a ? a : new g(-Infinity, -Infinity);
  }
  function We(h, a) {
    this.start = void 0 !== h ? h : new f;
    this.end = void 0 !== a ? a : new f;
  }
  function Ed(h) {
    G.call(this);
    this.material = h;
    this.render = function() {
    };
  }
  function Fd(h, a, b, d) {
    this.object = h;
    this.size = void 0 !== a ? a : 1;
    h = void 0 !== b ? b : 16711680;
    d = void 0 !== d ? d : 1;
    a = 0;
    (b = this.object.geometry) && b.isGeometry ? a = 3 * b.faces.length : b && b.isBufferGeometry && (a = b.attributes.normal.count);
    b = new O;
    a = new N(6 * a, 3);
    b.addAttribute("position", a);
    pa.call(this, b, new ra({color:h, linewidth:d}));
    this.matrixAutoUpdate = !1;
    this.update();
  }
  function Gc(h, a) {
    G.call(this);
    this.light = h;
    this.light.updateMatrixWorld();
    this.matrix = h.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.color = a;
    h = new O;
    a = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (var b = 0, r = 1; 32 > b; b++, r++) {
      var d = b / 32 * Math.PI * 2, c = r / 32 * Math.PI * 2;
      a.push(Math.cos(d), Math.sin(d), 1, Math.cos(c), Math.sin(c), 1);
    }
    h.addAttribute("position", new N(a, 3));
    a = new ra({fog:!1});
    this.cone = new pa(h, a);
    this.add(this.cone);
    this.update();
  }
  function Sf(h) {
    var a = [];
    h && h.isBone && a.push(h);
    for (var b = 0; b < h.children.length; b++) {
      a.push.apply(a, Sf(h.children[b]));
    }
    return a;
  }
  function Hc(h) {
    for (var a = Sf(h), b = new O, d = [], c = [], f = new z(0, 0, 1), e = new z(0, 1, 0), l = 0; l < a.length; l++) {
      var k = a[l];
      k.parent && k.parent.isBone && (d.push(0, 0, 0), d.push(0, 0, 0), c.push(f.r, f.g, f.b), c.push(e.r, e.g, e.b));
    }
    b.addAttribute("position", new N(d, 3));
    b.addAttribute("color", new N(c, 3));
    d = new ra({vertexColors:2, depthTest:!1, depthWrite:!1, transparent:!0});
    pa.call(this, b, d);
    this.root = h;
    this.bones = a;
    this.matrix = h.matrixWorld;
    this.matrixAutoUpdate = !1;
  }
  function Ic(h, a, b) {
    this.light = h;
    this.light.updateMatrixWorld();
    this.color = b;
    h = new Ub(a, 4, 2);
    a = new ma({wireframe:!0, fog:!1});
    ca.call(this, h, a);
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.update();
  }
  function Jc(h, a) {
    this.type = "RectAreaLightHelper";
    this.light = h;
    this.color = a;
    h = new O;
    h.addAttribute("position", new N([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3));
    h.computeBoundingSphere();
    a = new ra({fog:!1});
    wa.call(this, h, a);
    h = new O;
    h.addAttribute("position", new N([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3));
    h.computeBoundingSphere();
    this.add(new ca(h, new ma({side:1, fog:!1})));
    this.update();
  }
  function Kc(h, a, b) {
    G.call(this);
    this.light = h;
    this.light.updateMatrixWorld();
    this.matrix = h.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.color = b;
    h = new Qb(a);
    h.rotateY(.5 * Math.PI);
    this.material = new ma({wireframe:!0, fog:!1});
    void 0 === this.color && (this.material.vertexColors = 2);
    a = h.getAttribute("position");
    a = new Float32Array(3 * a.count);
    h.addAttribute("color", new K(a, 3));
    this.add(new ca(h, this.material));
    this.update();
  }
  function Gd(h, a, b, d) {
    h = h || 10;
    a = a || 10;
    b = new z(void 0 !== b ? b : 4473924);
    d = new z(void 0 !== d ? d : 8947848);
    var r = a / 2, c = h / a, f = h / 2;
    h = [];
    for (var e = [], l = 0, k = 0, g = -f; l <= a; l++, g += c) {
      h.push(-f, 0, g, f, 0, g);
      h.push(g, 0, -f, g, 0, f);
      var q = l === r ? b : d;
      q.toArray(e, k);
      k += 3;
      q.toArray(e, k);
      k += 3;
      q.toArray(e, k);
      k += 3;
      q.toArray(e, k);
      k += 3;
    }
    a = new O;
    a.addAttribute("position", new N(h, 3));
    a.addAttribute("color", new N(e, 3));
    b = new ra({vertexColors:2});
    pa.call(this, a, b);
  }
  function je(h, a, b, d, c, f) {
    h = h || 10;
    a = a || 16;
    b = b || 8;
    d = d || 64;
    c = new z(void 0 !== c ? c : 4473924);
    f = new z(void 0 !== f ? f : 8947848);
    var r = [], e = [], l;
    for (l = 0; l <= a; l++) {
      var k = l / a * 2 * Math.PI, g = Math.sin(k) * h;
      k = Math.cos(k) * h;
      r.push(0, 0, 0);
      r.push(g, 0, k);
      var q = l & 1 ? c : f;
      e.push(q.r, q.g, q.b);
      e.push(q.r, q.g, q.b);
    }
    for (l = 0; l <= b; l++) {
      q = l & 1 ? c : f;
      var m = h - h / b * l;
      for (a = 0; a < d; a++) {
        k = a / d * 2 * Math.PI, g = Math.sin(k) * m, k = Math.cos(k) * m, r.push(g, 0, k), e.push(q.r, q.g, q.b), k = (a + 1) / d * 2 * Math.PI, g = Math.sin(k) * m, k = Math.cos(k) * m, r.push(g, 0, k), e.push(q.r, q.g, q.b);
      }
    }
    h = new O;
    h.addAttribute("position", new N(r, 3));
    h.addAttribute("color", new N(e, 3));
    r = new ra({vertexColors:2});
    pa.call(this, h, r);
  }
  function Lc(h, a, b, d) {
    this.audio = h;
    this.range = a || 1;
    this.divisionsInnerAngle = b || 16;
    this.divisionsOuterAngle = d || 2;
    h = new O;
    a = new Float32Array(3 * (3 * (this.divisionsInnerAngle + 2 * this.divisionsOuterAngle) + 3));
    h.addAttribute("position", new K(a, 3));
    a = new ra({color:65280});
    b = new ra({color:16776960});
    wa.call(this, h, [b, a]);
    this.update();
  }
  function Hd(h, a, b, d) {
    this.object = h;
    this.size = void 0 !== a ? a : 1;
    h = void 0 !== b ? b : 16776960;
    d = void 0 !== d ? d : 1;
    a = 0;
    (b = this.object.geometry) && b.isGeometry ? a = b.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
    b = new O;
    a = new N(6 * a, 3);
    b.addAttribute("position", a);
    pa.call(this, b, new ra({color:h, linewidth:d}));
    this.matrixAutoUpdate = !1;
    this.update();
  }
  function Mc(h, a, b) {
    G.call(this);
    this.light = h;
    this.light.updateMatrixWorld();
    this.matrix = h.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.color = b;
    void 0 === a && (a = 1);
    h = new O;
    h.addAttribute("position", new N([-a, a, 0, a, a, 0, a, -a, 0, -a, -a, 0, -a, a, 0], 3));
    a = new ra({fog:!1});
    this.lightPlane = new wa(h, a);
    this.add(this.lightPlane);
    h = new O;
    h.addAttribute("position", new N([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new wa(h, a);
    this.add(this.targetLine);
    this.update();
  }
  function Id(h) {
    function a(h, a, r) {
      b(h, r);
      b(a, r);
    }
    function b(h, a) {
      f.push(0, 0, 0);
      e.push(a.r, a.g, a.b);
      void 0 === l[h] && (l[h] = []);
      l[h].push(f.length / 3 - 1);
    }
    var d = new O, c = new ra({color:16777215, vertexColors:1}), f = [], e = [], l = {}, k = new z(16755200), g = new z(16711680), q = new z(43775), m = new z(16777215), n = new z(3355443);
    a("n1", "n2", k);
    a("n2", "n4", k);
    a("n4", "n3", k);
    a("n3", "n1", k);
    a("f1", "f2", k);
    a("f2", "f4", k);
    a("f4", "f3", k);
    a("f3", "f1", k);
    a("n1", "f1", k);
    a("n2", "f2", k);
    a("n3", "f3", k);
    a("n4", "f4", k);
    a("p", "n1", g);
    a("p", "n2", g);
    a("p", "n3", g);
    a("p", "n4", g);
    a("u1", "u2", q);
    a("u2", "u3", q);
    a("u3", "u1", q);
    a("c", "t", m);
    a("p", "c", n);
    a("cn1", "cn2", n);
    a("cn3", "cn4", n);
    a("cf1", "cf2", n);
    a("cf3", "cf4", n);
    d.addAttribute("position", new N(f, 3));
    d.addAttribute("color", new N(e, 3));
    pa.call(this, d, c);
    this.camera = h;
    this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix();
    this.matrix = h.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.pointMap = l;
    this.update();
  }
  function zb(h, a) {
    this.object = h;
    void 0 === a && (a = 16776960);
    h = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var b = new Float32Array(24), r = new O;
    r.setIndex(new K(h, 1));
    r.addAttribute("position", new K(b, 3));
    pa.call(this, r, new ra({color:a}));
    this.matrixAutoUpdate = !1;
    this.update();
  }
  function Jd(h, a) {
    this.type = "Box3Helper";
    this.box = h;
    h = void 0 !== a ? a : 16776960;
    a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var b = new O;
    b.setIndex(new K(a, 1));
    b.addAttribute("position", new N([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3));
    pa.call(this, b, new ra({color:h}));
    this.geometry.computeBoundingSphere();
  }
  function Kd(h, a, b) {
    this.type = "PlaneHelper";
    this.plane = h;
    this.size = void 0 === a ? 1 : a;
    h = void 0 !== b ? b : 16776960;
    a = new O;
    a.addAttribute("position", new N([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3));
    a.computeBoundingSphere();
    wa.call(this, a, new ra({color:h}));
    a = new O;
    a.addAttribute("position", new N([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3));
    a.computeBoundingSphere();
    this.add(new ca(a, new ma({color:h, opacity:.2, transparent:!0, depthWrite:!1})));
  }
  function Ab(h, a, b, d, c, e) {
    G.call(this);
    void 0 === h && (h = new f(0, 0, 1));
    void 0 === a && (a = new f(0, 0, 0));
    void 0 === b && (b = 1);
    void 0 === d && (d = 16776960);
    void 0 === c && (c = .2 * b);
    void 0 === e && (e = .2 * c);
    void 0 === ke && (ke = new O, ke.addAttribute("position", new N([0, 0, 0, 0, 1, 0], 3)), Xe = new xb(0, .5, 1, 5, 1), Xe.translate(0, -.5, 0));
    this.position.copy(a);
    this.line = new wa(ke, new ra({color:d}));
    this.line.matrixAutoUpdate = !1;
    this.add(this.line);
    this.cone = new ca(Xe, new ma({color:d}));
    this.cone.matrixAutoUpdate = !1;
    this.add(this.cone);
    this.setDirection(h);
    this.setLength(b, c, e);
  }
  function Ld(h) {
    h = h || 1;
    var a = [0, 0, 0, h, 0, 0, 0, 0, 0, 0, h, 0, 0, 0, 0, 0, 0, h];
    h = new O;
    h.addAttribute("position", new N(a, 3));
    h.addAttribute("color", new N([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
    a = new ra({vertexColors:2});
    pa.call(this, h, a);
  }
  function Tf(h) {
    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    Ea.call(this, h);
    this.type = "catmullrom";
    this.closed = !0;
  }
  function Uf(h) {
    console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    Ea.call(this, h);
    this.type = "catmullrom";
  }
  function Ye(h) {
    console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
    Ea.call(this, h);
    this.type = "catmullrom";
  }
  void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52));
  void 0 === Number.isInteger && (Number.isInteger = function(h) {
    return "number" === typeof h && isFinite(h) && Math.floor(h) === h;
  });
  void 0 === Math.sign && (Math.sign = function(h) {
    return 0 > h ? -1 : 0 < h ? 1 : +h;
  });
  !1 === "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {get:function() {
    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
  }});
  void 0 === Object.assign && function() {
    Object.assign = function(h) {
      if (void 0 === h || null === h) {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      for (var a = Object(h), b = 1; b < arguments.length; b++) {
        var d = arguments[b];
        if (void 0 !== d && null !== d) {
          for (var c in d) {
            Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
          }
        }
      }
      return a;
    };
  }();
  Object.assign(c.prototype, {addEventListener:function(h, a) {
    void 0 === this._listeners && (this._listeners = {});
    var b = this._listeners;
    void 0 === b[h] && (b[h] = []);
    -1 === b[h].indexOf(a) && b[h].push(a);
  }, hasEventListener:function(h, a) {
    if (void 0 === this._listeners) {
      return !1;
    }
    var b = this._listeners;
    return void 0 !== b[h] && -1 !== b[h].indexOf(a);
  }, removeEventListener:function(h, a) {
    void 0 !== this._listeners && (h = this._listeners[h], void 0 !== h && (a = h.indexOf(a), -1 !== a && h.splice(a, 1)));
  }, dispatchEvent:function(h) {
    if (void 0 !== this._listeners) {
      var a = this._listeners[h.type];
      if (void 0 !== a) {
        h.target = this;
        a = a.slice(0);
        for (var b = 0, d = a.length; b < d; b++) {
          a[b].call(this, h);
        }
      }
    }
  }});
  var ia = {DEG2RAD:Math.PI / 180, RAD2DEG:180 / Math.PI, generateUUID:function() {
    for (var h = [], a = 0; 256 > a; a++) {
      h[a] = (16 > a ? "0" : "") + a.toString(16);
    }
    return function() {
      var a = 4294967295 * Math.random() | 0, b = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0, d = 4294967295 * Math.random() | 0;
      return (h[a & 255] + h[a >> 8 & 255] + h[a >> 16 & 255] + h[a >> 24 & 255] + "-" + h[b & 255] + h[b >> 8 & 255] + "-" + h[b >> 16 & 15 | 64] + h[b >> 24 & 255] + "-" + h[r & 63 | 128] + h[r >> 8 & 255] + "-" + h[r >> 16 & 255] + h[r >> 24 & 255] + h[d & 255] + h[d >> 8 & 255] + h[d >> 16 & 255] + h[d >> 24 & 255]).toUpperCase();
    };
  }(), clamp:function(h, a, b) {
    return Math.max(a, Math.min(b, h));
  }, euclideanModulo:function(h, a) {
    return (h % a + a) % a;
  }, mapLinear:function(h, a, b, d, c) {
    return d + (h - a) * (c - d) / (b - a);
  }, lerp:function(h, a, b) {
    return (1 - b) * h + b * a;
  }, smoothstep:function(h, a, b) {
    if (h <= a) {
      return 0;
    }
    if (h >= b) {
      return 1;
    }
    h = (h - a) / (b - a);
    return h * h * (3 - 2 * h);
  }, smootherstep:function(h, a, b) {
    if (h <= a) {
      return 0;
    }
    if (h >= b) {
      return 1;
    }
    h = (h - a) / (b - a);
    return h * h * h * (h * (6 * h - 15) + 10);
  }, randInt:function(h, a) {
    return h + Math.floor(Math.random() * (a - h + 1));
  }, randFloat:function(h, a) {
    return h + Math.random() * (a - h);
  }, randFloatSpread:function(a) {
    return a * (.5 - Math.random());
  }, degToRad:function(a) {
    return a * ia.DEG2RAD;
  }, radToDeg:function(a) {
    return a * ia.RAD2DEG;
  }, isPowerOfTwo:function(a) {
    return 0 === (a & a - 1) && 0 !== a;
  }, ceilPowerOfTwo:function(a) {
    return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));
  }, floorPowerOfTwo:function(a) {
    return Math.pow(2, Math.floor(Math.log(a) / Math.LN2));
  }};
  Object.defineProperties(g.prototype, {width:{get:function() {
    return this.x;
  }, set:function(a) {
    this.x = a;
  }}, height:{get:function() {
    return this.y;
  }, set:function(a) {
    this.y = a;
  }}});
  Object.assign(g.prototype, {isVector2:!0, set:function(a, b) {
    this.x = a;
    this.y = b;
    return this;
  }, setScalar:function(a) {
    this.y = this.x = a;
    return this;
  }, setX:function(a) {
    this.x = a;
    return this;
  }, setY:function(a) {
    this.y = a;
    return this;
  }, setComponent:function(a, b) {
    switch(a) {
      case 0:
        this.x = b;
        break;
      case 1:
        this.y = b;
        break;
      default:
        throw Error("index is out of range: " + a);
    }
    return this;
  }, getComponent:function(a) {
    switch(a) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw Error("index is out of range: " + a);
    }
  }, clone:function() {
    return new this.constructor(this.x, this.y);
  }, copy:function(a) {
    this.x = a.x;
    this.y = a.y;
    return this;
  }, add:function(a, b) {
    if (void 0 !== b) {
      return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
    }
    this.x += a.x;
    this.y += a.y;
    return this;
  }, addScalar:function(a) {
    this.x += a;
    this.y += a;
    return this;
  }, addVectors:function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }, addScaledVector:function(a, b) {
    this.x += a.x * b;
    this.y += a.y * b;
    return this;
  }, sub:function(a, b) {
    if (void 0 !== b) {
      return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
    }
    this.x -= a.x;
    this.y -= a.y;
    return this;
  }, subScalar:function(a) {
    this.x -= a;
    this.y -= a;
    return this;
  }, subVectors:function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }, multiply:function(a) {
    this.x *= a.x;
    this.y *= a.y;
    return this;
  }, multiplyScalar:function(a) {
    this.x *= a;
    this.y *= a;
    return this;
  }, divide:function(a) {
    this.x /= a.x;
    this.y /= a.y;
    return this;
  }, divideScalar:function(a) {
    return this.multiplyScalar(1 / a);
  }, applyMatrix3:function(a) {
    var h = this.x, b = this.y;
    a = a.elements;
    this.x = a[0] * h + a[3] * b + a[6];
    this.y = a[1] * h + a[4] * b + a[7];
    return this;
  }, min:function(a) {
    this.x = Math.min(this.x, a.x);
    this.y = Math.min(this.y, a.y);
    return this;
  }, max:function(a) {
    this.x = Math.max(this.x, a.x);
    this.y = Math.max(this.y, a.y);
    return this;
  }, clamp:function(a, b) {
    this.x = Math.max(a.x, Math.min(b.x, this.x));
    this.y = Math.max(a.y, Math.min(b.y, this.y));
    return this;
  }, clampScalar:function() {
    var a = new g, b = new g;
    return function(h, r) {
      a.set(h, h);
      b.set(r, r);
      return this.clamp(a, b);
    };
  }(), clampLength:function(a, b) {
    var h = this.length();
    return this.divideScalar(h || 1).multiplyScalar(Math.max(a, Math.min(b, h)));
  }, floor:function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }, ceil:function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }, round:function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }, roundToZero:function() {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }, negate:function() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }, dot:function(a) {
    return this.x * a.x + this.y * a.y;
  }, cross:function(a) {
    return this.x * a.y - this.y * a.x;
  }, lengthSq:function() {
    return this.x * this.x + this.y * this.y;
  }, length:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, manhattanLength:function() {
    return Math.abs(this.x) + Math.abs(this.y);
  }, normalize:function() {
    return this.divideScalar(this.length() || 1);
  }, angle:function() {
    var a = Math.atan2(this.y, this.x);
    0 > a && (a += 2 * Math.PI);
    return a;
  }, distanceTo:function(a) {
    return Math.sqrt(this.distanceToSquared(a));
  }, distanceToSquared:function(a) {
    var h = this.x - a.x;
    a = this.y - a.y;
    return h * h + a * a;
  }, manhattanDistanceTo:function(a) {
    return Math.abs(this.x - a.x) + Math.abs(this.y - a.y);
  }, setLength:function(a) {
    return this.normalize().multiplyScalar(a);
  }, lerp:function(a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    return this;
  }, lerpVectors:function(a, b, d) {
    return this.subVectors(b, a).multiplyScalar(d).add(a);
  }, equals:function(a) {
    return a.x === this.x && a.y === this.y;
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    this.x = a[b];
    this.y = a[b + 1];
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this.x;
    a[b + 1] = this.y;
    return a;
  }, fromBufferAttribute:function(a, b, d) {
    void 0 !== d && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    this.x = a.getX(b);
    this.y = a.getY(b);
    return this;
  }, rotateAround:function(a, b) {
    var h = Math.cos(b);
    b = Math.sin(b);
    var r = this.x - a.x, d = this.y - a.y;
    this.x = r * h - d * b + a.x;
    this.y = r * b + d * h + a.y;
    return this;
  }});
  Object.assign(b.prototype, {isMatrix4:!0, set:function(a, b, d, c, f, e, l, k, g, q, m, n, t, u, p, v) {
    var h = this.elements;
    h[0] = a;
    h[4] = b;
    h[8] = d;
    h[12] = c;
    h[1] = f;
    h[5] = e;
    h[9] = l;
    h[13] = k;
    h[2] = g;
    h[6] = q;
    h[10] = m;
    h[14] = n;
    h[3] = t;
    h[7] = u;
    h[11] = p;
    h[15] = v;
    return this;
  }, identity:function() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }, clone:function() {
    return (new b).fromArray(this.elements);
  }, copy:function(a) {
    var h = this.elements;
    a = a.elements;
    h[0] = a[0];
    h[1] = a[1];
    h[2] = a[2];
    h[3] = a[3];
    h[4] = a[4];
    h[5] = a[5];
    h[6] = a[6];
    h[7] = a[7];
    h[8] = a[8];
    h[9] = a[9];
    h[10] = a[10];
    h[11] = a[11];
    h[12] = a[12];
    h[13] = a[13];
    h[14] = a[14];
    h[15] = a[15];
    return this;
  }, copyPosition:function(a) {
    var h = this.elements;
    a = a.elements;
    h[12] = a[12];
    h[13] = a[13];
    h[14] = a[14];
    return this;
  }, extractBasis:function(a, b, d) {
    a.setFromMatrixColumn(this, 0);
    b.setFromMatrixColumn(this, 1);
    d.setFromMatrixColumn(this, 2);
    return this;
  }, makeBasis:function(a, b, d) {
    this.set(a.x, b.x, d.x, 0, a.y, b.y, d.y, 0, a.z, b.z, d.z, 0, 0, 0, 0, 1);
    return this;
  }, extractRotation:function() {
    var a = new f;
    return function(h) {
      var b = this.elements, r = h.elements, d = 1 / a.setFromMatrixColumn(h, 0).length(), c = 1 / a.setFromMatrixColumn(h, 1).length();
      h = 1 / a.setFromMatrixColumn(h, 2).length();
      b[0] = r[0] * d;
      b[1] = r[1] * d;
      b[2] = r[2] * d;
      b[3] = 0;
      b[4] = r[4] * c;
      b[5] = r[5] * c;
      b[6] = r[6] * c;
      b[7] = 0;
      b[8] = r[8] * h;
      b[9] = r[9] * h;
      b[10] = r[10] * h;
      b[11] = 0;
      b[12] = 0;
      b[13] = 0;
      b[14] = 0;
      b[15] = 1;
      return this;
    };
  }(), makeRotationFromEuler:function(a) {
    a && a.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    var h = this.elements, b = a.x, d = a.y, c = a.z, f = Math.cos(b);
    b = Math.sin(b);
    var e = Math.cos(d);
    d = Math.sin(d);
    var l = Math.cos(c);
    c = Math.sin(c);
    if ("XYZ" === a.order) {
      a = f * l;
      var k = f * c, g = b * l, q = b * c;
      h[0] = e * l;
      h[4] = -e * c;
      h[8] = d;
      h[1] = k + g * d;
      h[5] = a - q * d;
      h[9] = -b * e;
      h[2] = q - a * d;
      h[6] = g + k * d;
      h[10] = f * e;
    } else {
      "YXZ" === a.order ? (a = e * l, k = e * c, g = d * l, q = d * c, h[0] = a + q * b, h[4] = g * b - k, h[8] = f * d, h[1] = f * c, h[5] = f * l, h[9] = -b, h[2] = k * b - g, h[6] = q + a * b, h[10] = f * e) : "ZXY" === a.order ? (a = e * l, k = e * c, g = d * l, q = d * c, h[0] = a - q * b, h[4] = -f * c, h[8] = g + k * b, h[1] = k + g * b, h[5] = f * l, h[9] = q - a * b, h[2] = -f * d, h[6] = b, h[10] = f * e) : "ZYX" === a.order ? (a = f * l, k = f * c, g = b * l, q = b * c, h[0] = e * l, h[4] = 
      g * d - k, h[8] = a * d + q, h[1] = e * c, h[5] = q * d + a, h[9] = k * d - g, h[2] = -d, h[6] = b * e, h[10] = f * e) : "YZX" === a.order ? (a = f * e, k = f * d, g = b * e, q = b * d, h[0] = e * l, h[4] = q - a * c, h[8] = g * c + k, h[1] = c, h[5] = f * l, h[9] = -b * l, h[2] = -d * l, h[6] = k * c + g, h[10] = a - q * c) : "XZY" === a.order && (a = f * e, k = f * d, g = b * e, q = b * d, h[0] = e * l, h[4] = -c, h[8] = d * l, h[1] = a * c + q, h[5] = f * l, h[9] = k * c - g, h[2] = g * 
      c - k, h[6] = b * l, h[10] = q * c + a);
    }
    h[3] = 0;
    h[7] = 0;
    h[11] = 0;
    h[12] = 0;
    h[13] = 0;
    h[14] = 0;
    h[15] = 1;
    return this;
  }, makeRotationFromQuaternion:function() {
    var a = new f(0, 0, 0), b = new f(1, 1, 1);
    return function(h) {
      return this.compose(a, h, b);
    };
  }(), lookAt:function() {
    var a = new f, b = new f, d = new f;
    return function(h, r, c) {
      var f = this.elements;
      d.subVectors(h, r);
      0 === d.lengthSq() && (d.z = 1);
      d.normalize();
      a.crossVectors(c, d);
      0 === a.lengthSq() && (1 === Math.abs(c.z) ? d.x += 1E-4 : d.z += 1E-4, d.normalize(), a.crossVectors(c, d));
      a.normalize();
      b.crossVectors(d, a);
      f[0] = a.x;
      f[4] = b.x;
      f[8] = d.x;
      f[1] = a.y;
      f[5] = b.y;
      f[9] = d.y;
      f[2] = a.z;
      f[6] = b.z;
      f[10] = d.z;
      return this;
    };
  }(), multiply:function(a, b) {
    return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a);
  }, premultiply:function(a) {
    return this.multiplyMatrices(a, this);
  }, multiplyMatrices:function(a, b) {
    var h = a.elements, d = b.elements;
    b = this.elements;
    a = h[0];
    var r = h[4], c = h[8], f = h[12], e = h[1], l = h[5], k = h[9], g = h[13], q = h[2], m = h[6], n = h[10], t = h[14], u = h[3], p = h[7], v = h[11];
    h = h[15];
    var w = d[0], z = d[4], y = d[8], x = d[12], D = d[1], C = d[5], B = d[9], E = d[13], A = d[2], G = d[6], M = d[10], H = d[14], O = d[3], I = d[7], P = d[11];
    d = d[15];
    b[0] = a * w + r * D + c * A + f * O;
    b[4] = a * z + r * C + c * G + f * I;
    b[8] = a * y + r * B + c * M + f * P;
    b[12] = a * x + r * E + c * H + f * d;
    b[1] = e * w + l * D + k * A + g * O;
    b[5] = e * z + l * C + k * G + g * I;
    b[9] = e * y + l * B + k * M + g * P;
    b[13] = e * x + l * E + k * H + g * d;
    b[2] = q * w + m * D + n * A + t * O;
    b[6] = q * z + m * C + n * G + t * I;
    b[10] = q * y + m * B + n * M + t * P;
    b[14] = q * x + m * E + n * H + t * d;
    b[3] = u * w + p * D + v * A + h * O;
    b[7] = u * z + p * C + v * G + h * I;
    b[11] = u * y + p * B + v * M + h * P;
    b[15] = u * x + p * E + v * H + h * d;
    return this;
  }, multiplyScalar:function(a) {
    var h = this.elements;
    h[0] *= a;
    h[4] *= a;
    h[8] *= a;
    h[12] *= a;
    h[1] *= a;
    h[5] *= a;
    h[9] *= a;
    h[13] *= a;
    h[2] *= a;
    h[6] *= a;
    h[10] *= a;
    h[14] *= a;
    h[3] *= a;
    h[7] *= a;
    h[11] *= a;
    h[15] *= a;
    return this;
  }, applyToBufferAttribute:function() {
    var a = new f;
    return function(h) {
      for (var b = 0, d = h.count; b < d; b++) {
        a.x = h.getX(b), a.y = h.getY(b), a.z = h.getZ(b), a.applyMatrix4(this), h.setXYZ(b, a.x, a.y, a.z);
      }
      return h;
    };
  }(), determinant:function() {
    var a = this.elements, b = a[0], d = a[4], c = a[8], f = a[12], e = a[1], l = a[5], k = a[9], g = a[13], q = a[2], m = a[6], n = a[10], t = a[14];
    return a[3] * (+f * k * m - c * g * m - f * l * n + d * g * n + c * l * t - d * k * t) + a[7] * (+b * k * t - b * g * n + f * e * n - c * e * t + c * g * q - f * k * q) + a[11] * (+b * g * m - b * l * t - f * e * m + d * e * t + f * l * q - d * g * q) + a[15] * (-c * l * q - b * k * m + b * l * n + c * e * m - d * e * n + d * k * q);
  }, transpose:function() {
    var a = this.elements, b = a[1];
    a[1] = a[4];
    a[4] = b;
    b = a[2];
    a[2] = a[8];
    a[8] = b;
    b = a[6];
    a[6] = a[9];
    a[9] = b;
    b = a[3];
    a[3] = a[12];
    a[12] = b;
    b = a[7];
    a[7] = a[13];
    a[13] = b;
    b = a[11];
    a[11] = a[14];
    a[14] = b;
    return this;
  }, setPosition:function(a) {
    var h = this.elements;
    h[12] = a.x;
    h[13] = a.y;
    h[14] = a.z;
    return this;
  }, getInverse:function(a, b) {
    var h = this.elements, d = a.elements;
    a = d[0];
    var r = d[1], c = d[2], f = d[3], e = d[4], l = d[5], k = d[6], g = d[7], q = d[8], m = d[9], n = d[10], t = d[11], u = d[12], p = d[13], v = d[14];
    d = d[15];
    var w = m * v * g - p * n * g + p * k * t - l * v * t - m * k * d + l * n * d, z = u * n * g - q * v * g - u * k * t + e * v * t + q * k * d - e * n * d, y = q * p * g - u * m * g + u * l * t - e * p * t - q * l * d + e * m * d, x = u * m * k - q * p * k - u * l * n + e * p * n + q * l * v - e * m * v, D = a * w + r * z + c * y + f * x;
    if (0 === D) {
      if (!0 === b) {
        throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
      }
      console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
      return this.identity();
    }
    b = 1 / D;
    h[0] = w * b;
    h[1] = (p * n * f - m * v * f - p * c * t + r * v * t + m * c * d - r * n * d) * b;
    h[2] = (l * v * f - p * k * f + p * c * g - r * v * g - l * c * d + r * k * d) * b;
    h[3] = (m * k * f - l * n * f - m * c * g + r * n * g + l * c * t - r * k * t) * b;
    h[4] = z * b;
    h[5] = (q * v * f - u * n * f + u * c * t - a * v * t - q * c * d + a * n * d) * b;
    h[6] = (u * k * f - e * v * f - u * c * g + a * v * g + e * c * d - a * k * d) * b;
    h[7] = (e * n * f - q * k * f + q * c * g - a * n * g - e * c * t + a * k * t) * b;
    h[8] = y * b;
    h[9] = (u * m * f - q * p * f - u * r * t + a * p * t + q * r * d - a * m * d) * b;
    h[10] = (e * p * f - u * l * f + u * r * g - a * p * g - e * r * d + a * l * d) * b;
    h[11] = (q * l * f - e * m * f - q * r * g + a * m * g + e * r * t - a * l * t) * b;
    h[12] = x * b;
    h[13] = (q * p * c - u * m * c + u * r * n - a * p * n - q * r * v + a * m * v) * b;
    h[14] = (u * l * c - e * p * c - u * r * k + a * p * k + e * r * v - a * l * v) * b;
    h[15] = (e * m * c - q * l * c + q * r * k - a * m * k - e * r * n + a * l * n) * b;
    return this;
  }, scale:function(a) {
    var h = this.elements, b = a.x, d = a.y;
    a = a.z;
    h[0] *= b;
    h[4] *= d;
    h[8] *= a;
    h[1] *= b;
    h[5] *= d;
    h[9] *= a;
    h[2] *= b;
    h[6] *= d;
    h[10] *= a;
    h[3] *= b;
    h[7] *= d;
    h[11] *= a;
    return this;
  }, getMaxScaleOnAxis:function() {
    var a = this.elements;
    return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]));
  }, makeTranslation:function(a, b, d) {
    this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, d, 0, 0, 0, 1);
    return this;
  }, makeRotationX:function(a) {
    var h = Math.cos(a);
    a = Math.sin(a);
    this.set(1, 0, 0, 0, 0, h, -a, 0, 0, a, h, 0, 0, 0, 0, 1);
    return this;
  }, makeRotationY:function(a) {
    var h = Math.cos(a);
    a = Math.sin(a);
    this.set(h, 0, a, 0, 0, 1, 0, 0, -a, 0, h, 0, 0, 0, 0, 1);
    return this;
  }, makeRotationZ:function(a) {
    var h = Math.cos(a);
    a = Math.sin(a);
    this.set(h, -a, 0, 0, a, h, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }, makeRotationAxis:function(a, b) {
    var h = Math.cos(b);
    b = Math.sin(b);
    var d = 1 - h, r = a.x, c = a.y;
    a = a.z;
    var f = d * r, e = d * c;
    this.set(f * r + h, f * c - b * a, f * a + b * c, 0, f * c + b * a, e * c + h, e * a - b * r, 0, f * a - b * c, e * a + b * r, d * a * a + h, 0, 0, 0, 0, 1);
    return this;
  }, makeScale:function(a, b, d) {
    this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, d, 0, 0, 0, 0, 1);
    return this;
  }, makeShear:function(a, b, d) {
    this.set(1, b, d, 0, a, 1, d, 0, a, b, 1, 0, 0, 0, 0, 1);
    return this;
  }, compose:function(a, b, d) {
    var h = this.elements, r = b._x, c = b._y, f = b._z, e = b._w, l = r + r, k = c + c, g = f + f;
    b = r * l;
    var q = r * k;
    r *= g;
    var m = c * k;
    c *= g;
    f *= g;
    l *= e;
    k *= e;
    e *= g;
    g = d.x;
    var n = d.y;
    d = d.z;
    h[0] = (1 - (m + f)) * g;
    h[1] = (q + e) * g;
    h[2] = (r - k) * g;
    h[3] = 0;
    h[4] = (q - e) * n;
    h[5] = (1 - (b + f)) * n;
    h[6] = (c + l) * n;
    h[7] = 0;
    h[8] = (r + k) * d;
    h[9] = (c - l) * d;
    h[10] = (1 - (b + m)) * d;
    h[11] = 0;
    h[12] = a.x;
    h[13] = a.y;
    h[14] = a.z;
    h[15] = 1;
    return this;
  }, decompose:function() {
    var a = new f, d = new b;
    return function(h, b, r) {
      var c = this.elements, f = a.set(c[0], c[1], c[2]).length(), e = a.set(c[4], c[5], c[6]).length(), l = a.set(c[8], c[9], c[10]).length();
      0 > this.determinant() && (f = -f);
      h.x = c[12];
      h.y = c[13];
      h.z = c[14];
      d.copy(this);
      h = 1 / f;
      c = 1 / e;
      var k = 1 / l;
      d.elements[0] *= h;
      d.elements[1] *= h;
      d.elements[2] *= h;
      d.elements[4] *= c;
      d.elements[5] *= c;
      d.elements[6] *= c;
      d.elements[8] *= k;
      d.elements[9] *= k;
      d.elements[10] *= k;
      b.setFromRotationMatrix(d);
      r.x = f;
      r.y = e;
      r.z = l;
      return this;
    };
  }(), makePerspective:function(a, b, d, c, f, e) {
    void 0 === e && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    var h = this.elements;
    h[0] = 2 * f / (b - a);
    h[4] = 0;
    h[8] = (b + a) / (b - a);
    h[12] = 0;
    h[1] = 0;
    h[5] = 2 * f / (d - c);
    h[9] = (d + c) / (d - c);
    h[13] = 0;
    h[2] = 0;
    h[6] = 0;
    h[10] = -(e + f) / (e - f);
    h[14] = -2 * e * f / (e - f);
    h[3] = 0;
    h[7] = 0;
    h[11] = -1;
    h[15] = 0;
    return this;
  }, makeOrthographic:function(a, b, d, c, f, e) {
    var h = this.elements, r = 1 / (b - a), l = 1 / (d - c), k = 1 / (e - f);
    h[0] = 2 * r;
    h[4] = 0;
    h[8] = 0;
    h[12] = -((b + a) * r);
    h[1] = 0;
    h[5] = 2 * l;
    h[9] = 0;
    h[13] = -((d + c) * l);
    h[2] = 0;
    h[6] = 0;
    h[10] = -2 * k;
    h[14] = -((e + f) * k);
    h[3] = 0;
    h[7] = 0;
    h[11] = 0;
    h[15] = 1;
    return this;
  }, equals:function(a) {
    var h = this.elements;
    a = a.elements;
    for (var b = 0; 16 > b; b++) {
      if (h[b] !== a[b]) {
        return !1;
      }
    }
    return !0;
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    for (var h = 0; 16 > h; h++) {
      this.elements[h] = a[h + b];
    }
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    var h = this.elements;
    a[b] = h[0];
    a[b + 1] = h[1];
    a[b + 2] = h[2];
    a[b + 3] = h[3];
    a[b + 4] = h[4];
    a[b + 5] = h[5];
    a[b + 6] = h[6];
    a[b + 7] = h[7];
    a[b + 8] = h[8];
    a[b + 9] = h[9];
    a[b + 10] = h[10];
    a[b + 11] = h[11];
    a[b + 12] = h[12];
    a[b + 13] = h[13];
    a[b + 14] = h[14];
    a[b + 15] = h[15];
    return a;
  }});
  Object.assign(e, {slerp:function(a, b, d, c) {
    return d.copy(a).slerp(b, c);
  }, slerpFlat:function(a, b, d, c, f, e, l) {
    var h = d[c + 0], r = d[c + 1], k = d[c + 2];
    d = d[c + 3];
    c = f[e + 0];
    var g = f[e + 1], q = f[e + 2];
    f = f[e + 3];
    if (d !== f || h !== c || r !== g || k !== q) {
      e = 1 - l;
      var m = h * c + r * g + k * q + d * f, n = 0 <= m ? 1 : -1, t = 1 - m * m;
      t > Number.EPSILON && (t = Math.sqrt(t), m = Math.atan2(t, m * n), e = Math.sin(e * m) / t, l = Math.sin(l * m) / t);
      n *= l;
      h = h * e + c * n;
      r = r * e + g * n;
      k = k * e + q * n;
      d = d * e + f * n;
      e === 1 - l && (l = 1 / Math.sqrt(h * h + r * r + k * k + d * d), h *= l, r *= l, k *= l, d *= l);
    }
    a[b] = h;
    a[b + 1] = r;
    a[b + 2] = k;
    a[b + 3] = d;
  }});
  Object.defineProperties(e.prototype, {x:{get:function() {
    return this._x;
  }, set:function(a) {
    this._x = a;
    this.onChangeCallback();
  }}, y:{get:function() {
    return this._y;
  }, set:function(a) {
    this._y = a;
    this.onChangeCallback();
  }}, z:{get:function() {
    return this._z;
  }, set:function(a) {
    this._z = a;
    this.onChangeCallback();
  }}, w:{get:function() {
    return this._w;
  }, set:function(a) {
    this._w = a;
    this.onChangeCallback();
  }}});
  Object.assign(e.prototype, {isQuaternion:!0, set:function(a, b, d, c) {
    this._x = a;
    this._y = b;
    this._z = d;
    this._w = c;
    this.onChangeCallback();
    return this;
  }, clone:function() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }, copy:function(a) {
    this._x = a.x;
    this._y = a.y;
    this._z = a.z;
    this._w = a.w;
    this.onChangeCallback();
    return this;
  }, setFromEuler:function(a, b) {
    if (!a || !a.isEuler) {
      throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    var h = a._x, d = a._y, r = a._z;
    a = a.order;
    var c = Math.cos, f = Math.sin, e = c(h / 2), l = c(d / 2);
    c = c(r / 2);
    h = f(h / 2);
    d = f(d / 2);
    r = f(r / 2);
    "XYZ" === a ? (this._x = h * l * c + e * d * r, this._y = e * d * c - h * l * r, this._z = e * l * r + h * d * c, this._w = e * l * c - h * d * r) : "YXZ" === a ? (this._x = h * l * c + e * d * r, this._y = e * d * c - h * l * r, this._z = e * l * r - h * d * c, this._w = e * l * c + h * d * r) : "ZXY" === a ? (this._x = h * l * c - e * d * r, this._y = e * d * c + h * l * r, this._z = e * l * r + h * d * c, this._w = e * l * c - h * d * r) : "ZYX" === a ? (this._x = h * l * c - e * d * r, this._y = 
    e * d * c + h * l * r, this._z = e * l * r - h * d * c, this._w = e * l * c + h * d * r) : "YZX" === a ? (this._x = h * l * c + e * d * r, this._y = e * d * c + h * l * r, this._z = e * l * r - h * d * c, this._w = e * l * c - h * d * r) : "XZY" === a && (this._x = h * l * c - e * d * r, this._y = e * d * c - h * l * r, this._z = e * l * r + h * d * c, this._w = e * l * c + h * d * r);
    if (!1 !== b) {
      this.onChangeCallback();
    }
    return this;
  }, setFromAxisAngle:function(a, b) {
    b /= 2;
    var h = Math.sin(b);
    this._x = a.x * h;
    this._y = a.y * h;
    this._z = a.z * h;
    this._w = Math.cos(b);
    this.onChangeCallback();
    return this;
  }, setFromRotationMatrix:function(a) {
    var h = a.elements, b = h[0];
    a = h[4];
    var d = h[8], c = h[1], f = h[5], e = h[9], l = h[2], k = h[6];
    h = h[10];
    var g = b + f + h;
    0 < g ? (b = .5 / Math.sqrt(g + 1), this._w = .25 / b, this._x = (k - e) * b, this._y = (d - l) * b, this._z = (c - a) * b) : b > f && b > h ? (b = 2 * Math.sqrt(1 + b - f - h), this._w = (k - e) / b, this._x = .25 * b, this._y = (a + c) / b, this._z = (d + l) / b) : f > h ? (b = 2 * Math.sqrt(1 + f - b - h), this._w = (d - l) / b, this._x = (a + c) / b, this._y = .25 * b, this._z = (e + k) / b) : (b = 2 * Math.sqrt(1 + h - b - f), this._w = (c - a) / b, this._x = (d + l) / b, this._y = (e + 
    k) / b, this._z = .25 * b);
    this.onChangeCallback();
    return this;
  }, setFromUnitVectors:function() {
    var a = new f, b;
    return function(h, d) {
      void 0 === a && (a = new f);
      b = h.dot(d) + 1;
      1E-6 > b ? (b = 0, Math.abs(h.x) > Math.abs(h.z) ? a.set(-h.y, h.x, 0) : a.set(0, -h.z, h.y)) : a.crossVectors(h, d);
      this._x = a.x;
      this._y = a.y;
      this._z = a.z;
      this._w = b;
      return this.normalize();
    };
  }(), angleTo:function(a) {
    return 2 * Math.acos(Math.abs(ia.clamp(this.dot(a), -1, 1)));
  }, rotateTowards:function(a, b) {
    var h = this.angleTo(a);
    if (0 === h) {
      return this;
    }
    this.slerp(a, Math.min(1, b / h));
    return this;
  }, inverse:function() {
    return this.conjugate();
  }, conjugate:function() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this.onChangeCallback();
    return this;
  }, dot:function(a) {
    return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w;
  }, lengthSq:function() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }, length:function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }, normalize:function() {
    var a = this.length();
    0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
    this.onChangeCallback();
    return this;
  }, multiply:function(a, b) {
    return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a);
  }, premultiply:function(a) {
    return this.multiplyQuaternions(a, this);
  }, multiplyQuaternions:function(a, b) {
    var h = a._x, d = a._y, r = a._z;
    a = a._w;
    var c = b._x, f = b._y, e = b._z;
    b = b._w;
    this._x = h * b + a * c + d * e - r * f;
    this._y = d * b + a * f + r * c - h * e;
    this._z = r * b + a * e + h * f - d * c;
    this._w = a * b - h * c - d * f - r * e;
    this.onChangeCallback();
    return this;
  }, slerp:function(a, b) {
    if (0 === b) {
      return this;
    }
    if (1 === b) {
      return this.copy(a);
    }
    var h = this._x, d = this._y, r = this._z, c = this._w, f = c * a._w + h * a._x + d * a._y + r * a._z;
    0 > f ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, f = -f) : this.copy(a);
    if (1 <= f) {
      return this._w = c, this._x = h, this._y = d, this._z = r, this;
    }
    a = 1 - f * f;
    if (a <= Number.EPSILON) {
      return f = 1 - b, this._w = f * c + b * this._w, this._x = f * h + b * this._x, this._y = f * d + b * this._y, this._z = f * r + b * this._z, this.normalize();
    }
    a = Math.sqrt(a);
    var e = Math.atan2(a, f);
    f = Math.sin((1 - b) * e) / a;
    b = Math.sin(b * e) / a;
    this._w = c * f + this._w * b;
    this._x = h * f + this._x * b;
    this._y = d * f + this._y * b;
    this._z = r * f + this._z * b;
    this.onChangeCallback();
    return this;
  }, equals:function(a) {
    return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w;
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    this._x = a[b];
    this._y = a[b + 1];
    this._z = a[b + 2];
    this._w = a[b + 3];
    this.onChangeCallback();
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this._x;
    a[b + 1] = this._y;
    a[b + 2] = this._z;
    a[b + 3] = this._w;
    return a;
  }, onChange:function(a) {
    this.onChangeCallback = a;
    return this;
  }, onChangeCallback:function() {
  }});
  Object.assign(f.prototype, {isVector3:!0, set:function(a, b, d) {
    this.x = a;
    this.y = b;
    this.z = d;
    return this;
  }, setScalar:function(a) {
    this.z = this.y = this.x = a;
    return this;
  }, setX:function(a) {
    this.x = a;
    return this;
  }, setY:function(a) {
    this.y = a;
    return this;
  }, setZ:function(a) {
    this.z = a;
    return this;
  }, setComponent:function(a, b) {
    switch(a) {
      case 0:
        this.x = b;
        break;
      case 1:
        this.y = b;
        break;
      case 2:
        this.z = b;
        break;
      default:
        throw Error("index is out of range: " + a);
    }
    return this;
  }, getComponent:function(a) {
    switch(a) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw Error("index is out of range: " + a);
    }
  }, clone:function() {
    return new this.constructor(this.x, this.y, this.z);
  }, copy:function(a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    return this;
  }, add:function(a, b) {
    if (void 0 !== b) {
      return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
    }
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    return this;
  }, addScalar:function(a) {
    this.x += a;
    this.y += a;
    this.z += a;
    return this;
  }, addVectors:function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }, addScaledVector:function(a, b) {
    this.x += a.x * b;
    this.y += a.y * b;
    this.z += a.z * b;
    return this;
  }, sub:function(a, b) {
    if (void 0 !== b) {
      return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
    }
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    return this;
  }, subScalar:function(a) {
    this.x -= a;
    this.y -= a;
    this.z -= a;
    return this;
  }, subVectors:function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }, multiply:function(a, b) {
    if (void 0 !== b) {
      return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b);
    }
    this.x *= a.x;
    this.y *= a.y;
    this.z *= a.z;
    return this;
  }, multiplyScalar:function(a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    return this;
  }, multiplyVectors:function(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }, applyEuler:function() {
    var a = new e;
    return function(h) {
      h && h.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
      return this.applyQuaternion(a.setFromEuler(h));
    };
  }(), applyAxisAngle:function() {
    var a = new e;
    return function(h, b) {
      return this.applyQuaternion(a.setFromAxisAngle(h, b));
    };
  }(), applyMatrix3:function(a) {
    var h = this.x, b = this.y, d = this.z;
    a = a.elements;
    this.x = a[0] * h + a[3] * b + a[6] * d;
    this.y = a[1] * h + a[4] * b + a[7] * d;
    this.z = a[2] * h + a[5] * b + a[8] * d;
    return this;
  }, applyMatrix4:function(a) {
    var h = this.x, b = this.y, d = this.z;
    a = a.elements;
    var c = 1 / (a[3] * h + a[7] * b + a[11] * d + a[15]);
    this.x = (a[0] * h + a[4] * b + a[8] * d + a[12]) * c;
    this.y = (a[1] * h + a[5] * b + a[9] * d + a[13]) * c;
    this.z = (a[2] * h + a[6] * b + a[10] * d + a[14]) * c;
    return this;
  }, applyQuaternion:function(a) {
    var h = this.x, b = this.y, d = this.z, c = a.x, f = a.y, e = a.z;
    a = a.w;
    var l = a * h + f * d - e * b, k = a * b + e * h - c * d, g = a * d + c * b - f * h;
    h = -c * h - f * b - e * d;
    this.x = l * a + h * -c + k * -e - g * -f;
    this.y = k * a + h * -f + g * -c - l * -e;
    this.z = g * a + h * -e + l * -f - k * -c;
    return this;
  }, project:function(a) {
    return this.applyMatrix4(a.matrixWorldInverse).applyMatrix4(a.projectionMatrix);
  }, unproject:function() {
    var a = new b;
    return function(h) {
      return this.applyMatrix4(a.getInverse(h.projectionMatrix)).applyMatrix4(h.matrixWorld);
    };
  }(), transformDirection:function(a) {
    var h = this.x, b = this.y, d = this.z;
    a = a.elements;
    this.x = a[0] * h + a[4] * b + a[8] * d;
    this.y = a[1] * h + a[5] * b + a[9] * d;
    this.z = a[2] * h + a[6] * b + a[10] * d;
    return this.normalize();
  }, divide:function(a) {
    this.x /= a.x;
    this.y /= a.y;
    this.z /= a.z;
    return this;
  }, divideScalar:function(a) {
    return this.multiplyScalar(1 / a);
  }, min:function(a) {
    this.x = Math.min(this.x, a.x);
    this.y = Math.min(this.y, a.y);
    this.z = Math.min(this.z, a.z);
    return this;
  }, max:function(a) {
    this.x = Math.max(this.x, a.x);
    this.y = Math.max(this.y, a.y);
    this.z = Math.max(this.z, a.z);
    return this;
  }, clamp:function(a, b) {
    this.x = Math.max(a.x, Math.min(b.x, this.x));
    this.y = Math.max(a.y, Math.min(b.y, this.y));
    this.z = Math.max(a.z, Math.min(b.z, this.z));
    return this;
  }, clampScalar:function() {
    var a = new f, b = new f;
    return function(h, d) {
      a.set(h, h, h);
      b.set(d, d, d);
      return this.clamp(a, b);
    };
  }(), clampLength:function(a, b) {
    var h = this.length();
    return this.divideScalar(h || 1).multiplyScalar(Math.max(a, Math.min(b, h)));
  }, floor:function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }, ceil:function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }, round:function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }, roundToZero:function() {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }, negate:function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }, dot:function(a) {
    return this.x * a.x + this.y * a.y + this.z * a.z;
  }, lengthSq:function() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }, length:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }, manhattanLength:function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }, normalize:function() {
    return this.divideScalar(this.length() || 1);
  }, setLength:function(a) {
    return this.normalize().multiplyScalar(a);
  }, lerp:function(a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    this.z += (a.z - this.z) * b;
    return this;
  }, lerpVectors:function(a, b, d) {
    return this.subVectors(b, a).multiplyScalar(d).add(a);
  }, cross:function(a, b) {
    return void 0 !== b ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b)) : this.crossVectors(this, a);
  }, crossVectors:function(a, b) {
    var h = a.x, d = a.y;
    a = a.z;
    var c = b.x, r = b.y;
    b = b.z;
    this.x = d * b - a * r;
    this.y = a * c - h * b;
    this.z = h * r - d * c;
    return this;
  }, projectOnVector:function(a) {
    var h = a.dot(this) / a.lengthSq();
    return this.copy(a).multiplyScalar(h);
  }, projectOnPlane:function() {
    var a = new f;
    return function(h) {
      a.copy(this).projectOnVector(h);
      return this.sub(a);
    };
  }(), reflect:function() {
    var a = new f;
    return function(h) {
      return this.sub(a.copy(h).multiplyScalar(2 * this.dot(h)));
    };
  }(), angleTo:function(a) {
    a = this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq());
    return Math.acos(ia.clamp(a, -1, 1));
  }, distanceTo:function(a) {
    return Math.sqrt(this.distanceToSquared(a));
  }, distanceToSquared:function(a) {
    var h = this.x - a.x, b = this.y - a.y;
    a = this.z - a.z;
    return h * h + b * b + a * a;
  }, manhattanDistanceTo:function(a) {
    return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z);
  }, setFromSpherical:function(a) {
    return this.setFromSphericalCoords(a.radius, a.phi, a.theta);
  }, setFromSphericalCoords:function(a, b, d) {
    var h = Math.sin(b) * a;
    this.x = h * Math.sin(d);
    this.y = Math.cos(b) * a;
    this.z = h * Math.cos(d);
    return this;
  }, setFromCylindrical:function(a) {
    return this.setFromCylindricalCoords(a.radius, a.theta, a.y);
  }, setFromCylindricalCoords:function(a, b, d) {
    this.x = a * Math.sin(b);
    this.y = d;
    this.z = a * Math.cos(b);
    return this;
  }, setFromMatrixPosition:function(a) {
    a = a.elements;
    this.x = a[12];
    this.y = a[13];
    this.z = a[14];
    return this;
  }, setFromMatrixScale:function(a) {
    var h = this.setFromMatrixColumn(a, 0).length(), b = this.setFromMatrixColumn(a, 1).length();
    a = this.setFromMatrixColumn(a, 2).length();
    this.x = h;
    this.y = b;
    this.z = a;
    return this;
  }, setFromMatrixColumn:function(a, b) {
    return this.fromArray(a.elements, 4 * b);
  }, equals:function(a) {
    return a.x === this.x && a.y === this.y && a.z === this.z;
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    this.x = a[b];
    this.y = a[b + 1];
    this.z = a[b + 2];
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this.x;
    a[b + 1] = this.y;
    a[b + 2] = this.z;
    return a;
  }, fromBufferAttribute:function(a, b, d) {
    void 0 !== d && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    this.x = a.getX(b);
    this.y = a.getY(b);
    this.z = a.getZ(b);
    return this;
  }});
  Object.assign(k.prototype, {isMatrix3:!0, set:function(a, b, d, c, f, e, l, k, g) {
    var h = this.elements;
    h[0] = a;
    h[1] = c;
    h[2] = l;
    h[3] = b;
    h[4] = f;
    h[5] = k;
    h[6] = d;
    h[7] = e;
    h[8] = g;
    return this;
  }, identity:function() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }, clone:function() {
    return (new this.constructor).fromArray(this.elements);
  }, copy:function(a) {
    var h = this.elements;
    a = a.elements;
    h[0] = a[0];
    h[1] = a[1];
    h[2] = a[2];
    h[3] = a[3];
    h[4] = a[4];
    h[5] = a[5];
    h[6] = a[6];
    h[7] = a[7];
    h[8] = a[8];
    return this;
  }, setFromMatrix4:function(a) {
    a = a.elements;
    this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]);
    return this;
  }, applyToBufferAttribute:function() {
    var a = new f;
    return function(h) {
      for (var b = 0, d = h.count; b < d; b++) {
        a.x = h.getX(b), a.y = h.getY(b), a.z = h.getZ(b), a.applyMatrix3(this), h.setXYZ(b, a.x, a.y, a.z);
      }
      return h;
    };
  }(), multiply:function(a) {
    return this.multiplyMatrices(this, a);
  }, premultiply:function(a) {
    return this.multiplyMatrices(a, this);
  }, multiplyMatrices:function(a, b) {
    var h = a.elements, d = b.elements;
    b = this.elements;
    a = h[0];
    var c = h[3], r = h[6], f = h[1], e = h[4], l = h[7], k = h[2], g = h[5];
    h = h[8];
    var q = d[0], m = d[3], n = d[6], t = d[1], u = d[4], p = d[7], v = d[2], w = d[5];
    d = d[8];
    b[0] = a * q + c * t + r * v;
    b[3] = a * m + c * u + r * w;
    b[6] = a * n + c * p + r * d;
    b[1] = f * q + e * t + l * v;
    b[4] = f * m + e * u + l * w;
    b[7] = f * n + e * p + l * d;
    b[2] = k * q + g * t + h * v;
    b[5] = k * m + g * u + h * w;
    b[8] = k * n + g * p + h * d;
    return this;
  }, multiplyScalar:function(a) {
    var h = this.elements;
    h[0] *= a;
    h[3] *= a;
    h[6] *= a;
    h[1] *= a;
    h[4] *= a;
    h[7] *= a;
    h[2] *= a;
    h[5] *= a;
    h[8] *= a;
    return this;
  }, determinant:function() {
    var a = this.elements, b = a[0], d = a[1], c = a[2], f = a[3], e = a[4], l = a[5], k = a[6], g = a[7];
    a = a[8];
    return b * e * a - b * l * g - d * f * a + d * l * k + c * f * g - c * e * k;
  }, getInverse:function(a, b) {
    a && a.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
    var h = a.elements;
    a = this.elements;
    var d = h[0], c = h[1], f = h[2], r = h[3], e = h[4], l = h[5], k = h[6], g = h[7];
    h = h[8];
    var q = h * e - l * g, m = l * k - h * r, n = g * r - e * k, t = d * q + c * m + f * n;
    if (0 === t) {
      if (!0 === b) {
        throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
      }
      console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
      return this.identity();
    }
    b = 1 / t;
    a[0] = q * b;
    a[1] = (f * g - h * c) * b;
    a[2] = (l * c - f * e) * b;
    a[3] = m * b;
    a[4] = (h * d - f * k) * b;
    a[5] = (f * r - l * d) * b;
    a[6] = n * b;
    a[7] = (c * k - g * d) * b;
    a[8] = (e * d - c * r) * b;
    return this;
  }, transpose:function() {
    var a = this.elements, b = a[1];
    a[1] = a[3];
    a[3] = b;
    b = a[2];
    a[2] = a[6];
    a[6] = b;
    b = a[5];
    a[5] = a[7];
    a[7] = b;
    return this;
  }, getNormalMatrix:function(a) {
    return this.setFromMatrix4(a).getInverse(this).transpose();
  }, transposeIntoArray:function(a) {
    var h = this.elements;
    a[0] = h[0];
    a[1] = h[3];
    a[2] = h[6];
    a[3] = h[1];
    a[4] = h[4];
    a[5] = h[7];
    a[6] = h[2];
    a[7] = h[5];
    a[8] = h[8];
    return this;
  }, setUvTransform:function(a, b, d, c, f, e, l) {
    var h = Math.cos(f);
    f = Math.sin(f);
    this.set(d * h, d * f, -d * (h * e + f * l) + e + a, -c * f, c * h, -c * (-f * e + h * l) + l + b, 0, 0, 1);
  }, scale:function(a, b) {
    var h = this.elements;
    h[0] *= a;
    h[3] *= a;
    h[6] *= a;
    h[1] *= b;
    h[4] *= b;
    h[7] *= b;
    return this;
  }, rotate:function(a) {
    var h = Math.cos(a);
    a = Math.sin(a);
    var b = this.elements, d = b[0], c = b[3], f = b[6], e = b[1], l = b[4], k = b[7];
    b[0] = h * d + a * e;
    b[3] = h * c + a * l;
    b[6] = h * f + a * k;
    b[1] = -a * d + h * e;
    b[4] = -a * c + h * l;
    b[7] = -a * f + h * k;
    return this;
  }, translate:function(a, b) {
    var h = this.elements;
    h[0] += a * h[2];
    h[3] += a * h[5];
    h[6] += a * h[8];
    h[1] += b * h[2];
    h[4] += b * h[5];
    h[7] += b * h[8];
    return this;
  }, equals:function(a) {
    var h = this.elements;
    a = a.elements;
    for (var b = 0; 9 > b; b++) {
      if (h[b] !== a[b]) {
        return !1;
      }
    }
    return !0;
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    for (var h = 0; 9 > h; h++) {
      this.elements[h] = a[h + b];
    }
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    var h = this.elements;
    a[b] = h[0];
    a[b + 1] = h[1];
    a[b + 2] = h[2];
    a[b + 3] = h[3];
    a[b + 4] = h[4];
    a[b + 5] = h[5];
    a[b + 6] = h[6];
    a[b + 7] = h[7];
    a[b + 8] = h[8];
    return a;
  }});
  var Nc, Mb = {getDataURL:function(a) {
    if ("undefined" == typeof HTMLCanvasElement) {
      return a.src;
    }
    if (!(a instanceof HTMLCanvasElement)) {
      void 0 === Nc && (Nc = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"));
      Nc.width = a.width;
      Nc.height = a.height;
      var h = Nc.getContext("2d");
      a instanceof ImageData ? h.putImageData(a, 0, 0) : h.drawImage(a, 0, 0, a.width, a.height);
      a = Nc;
    }
    return 2048 < a.width || 2048 < a.height ? a.toDataURL("image/jpeg", .6) : a.toDataURL("image/png");
  }}, Xf = 0;
  n.DEFAULT_IMAGE = void 0;
  n.DEFAULT_MAPPING = 300;
  n.prototype = Object.assign(Object.create(c.prototype), {constructor:n, isTexture:!0, updateMatrix:function() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.name = a.name;
    this.image = a.image;
    this.mipmaps = a.mipmaps.slice(0);
    this.mapping = a.mapping;
    this.wrapS = a.wrapS;
    this.wrapT = a.wrapT;
    this.magFilter = a.magFilter;
    this.minFilter = a.minFilter;
    this.anisotropy = a.anisotropy;
    this.format = a.format;
    this.type = a.type;
    this.offset.copy(a.offset);
    this.repeat.copy(a.repeat);
    this.center.copy(a.center);
    this.rotation = a.rotation;
    this.matrixAutoUpdate = a.matrixAutoUpdate;
    this.matrix.copy(a.matrix);
    this.generateMipmaps = a.generateMipmaps;
    this.premultiplyAlpha = a.premultiplyAlpha;
    this.flipY = a.flipY;
    this.unpackAlignment = a.unpackAlignment;
    this.encoding = a.encoding;
    return this;
  }, toJSON:function(a) {
    var h = void 0 === a || "string" === typeof a;
    if (!h && void 0 !== a.textures[this.uuid]) {
      return a.textures[this.uuid];
    }
    var b = {metadata:{version:4.5, type:"Texture", generator:"Texture.toJSON"}, uuid:this.uuid, name:this.name, mapping:this.mapping, repeat:[this.repeat.x, this.repeat.y], offset:[this.offset.x, this.offset.y], center:[this.center.x, this.center.y], rotation:this.rotation, wrap:[this.wrapS, this.wrapT], format:this.format, type:this.type, encoding:this.encoding, minFilter:this.minFilter, magFilter:this.magFilter, anisotropy:this.anisotropy, flipY:this.flipY, premultiplyAlpha:this.premultiplyAlpha, 
    unpackAlignment:this.unpackAlignment};
    if (void 0 !== this.image) {
      var d = this.image;
      void 0 === d.uuid && (d.uuid = ia.generateUUID());
      if (!h && void 0 === a.images[d.uuid]) {
        if (Array.isArray(d)) {
          for (var c = [], f = 0, e = d.length; f < e; f++) {
            c.push(Mb.getDataURL(d[f]));
          }
        } else {
          c = Mb.getDataURL(d);
        }
        a.images[d.uuid] = {uuid:d.uuid, url:c};
      }
      b.image = d.uuid;
    }
    h || (a.textures[this.uuid] = b);
    return b;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }, transformUv:function(a) {
    if (300 !== this.mapping) {
      return a;
    }
    a.applyMatrix3(this.matrix);
    if (0 > a.x || 1 < a.x) {
      switch(this.wrapS) {
        case 1E3:
          a.x -= Math.floor(a.x);
          break;
        case 1001:
          a.x = 0 > a.x ? 0 : 1;
          break;
        case 1002:
          a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x);
      }
    }
    if (0 > a.y || 1 < a.y) {
      switch(this.wrapT) {
        case 1E3:
          a.y -= Math.floor(a.y);
          break;
        case 1001:
          a.y = 0 > a.y ? 0 : 1;
          break;
        case 1002:
          a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y);
      }
    }
    this.flipY && (a.y = 1 - a.y);
    return a;
  }});
  Object.defineProperty(n.prototype, "needsUpdate", {set:function(a) {
    !0 === a && this.version++;
  }});
  Object.assign(p.prototype, {isVector4:!0, set:function(a, b, d, c) {
    this.x = a;
    this.y = b;
    this.z = d;
    this.w = c;
    return this;
  }, setScalar:function(a) {
    this.w = this.z = this.y = this.x = a;
    return this;
  }, setX:function(a) {
    this.x = a;
    return this;
  }, setY:function(a) {
    this.y = a;
    return this;
  }, setZ:function(a) {
    this.z = a;
    return this;
  }, setW:function(a) {
    this.w = a;
    return this;
  }, setComponent:function(a, b) {
    switch(a) {
      case 0:
        this.x = b;
        break;
      case 1:
        this.y = b;
        break;
      case 2:
        this.z = b;
        break;
      case 3:
        this.w = b;
        break;
      default:
        throw Error("index is out of range: " + a);
    }
    return this;
  }, getComponent:function(a) {
    switch(a) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw Error("index is out of range: " + a);
    }
  }, clone:function() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }, copy:function(a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    this.w = void 0 !== a.w ? a.w : 1;
    return this;
  }, add:function(a, b) {
    if (void 0 !== b) {
      return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
    }
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    this.w += a.w;
    return this;
  }, addScalar:function(a) {
    this.x += a;
    this.y += a;
    this.z += a;
    this.w += a;
    return this;
  }, addVectors:function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }, addScaledVector:function(a, b) {
    this.x += a.x * b;
    this.y += a.y * b;
    this.z += a.z * b;
    this.w += a.w * b;
    return this;
  }, sub:function(a, b) {
    if (void 0 !== b) {
      return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
    }
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    this.w -= a.w;
    return this;
  }, subScalar:function(a) {
    this.x -= a;
    this.y -= a;
    this.z -= a;
    this.w -= a;
    return this;
  }, subVectors:function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }, multiplyScalar:function(a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    this.w *= a;
    return this;
  }, applyMatrix4:function(a) {
    var h = this.x, b = this.y, d = this.z, c = this.w;
    a = a.elements;
    this.x = a[0] * h + a[4] * b + a[8] * d + a[12] * c;
    this.y = a[1] * h + a[5] * b + a[9] * d + a[13] * c;
    this.z = a[2] * h + a[6] * b + a[10] * d + a[14] * c;
    this.w = a[3] * h + a[7] * b + a[11] * d + a[15] * c;
    return this;
  }, divideScalar:function(a) {
    return this.multiplyScalar(1 / a);
  }, setAxisAngleFromQuaternion:function(a) {
    this.w = 2 * Math.acos(a.w);
    var h = Math.sqrt(1 - a.w * a.w);
    1E-4 > h ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / h, this.y = a.y / h, this.z = a.z / h);
    return this;
  }, setAxisAngleFromRotationMatrix:function(a) {
    a = a.elements;
    var h = a[0], b = a[4], d = a[8], c = a[1], f = a[5], e = a[9], l = a[2], k = a[6], g = a[10];
    if (.01 > Math.abs(b - c) && .01 > Math.abs(d - l) && .01 > Math.abs(e - k)) {
      if (.1 > Math.abs(b + c) && .1 > Math.abs(d + l) && .1 > Math.abs(e + k) && .1 > Math.abs(h + f + g - 3)) {
        return this.set(1, 0, 0, 0), this;
      }
      a = Math.PI;
      h = (h + 1) / 2;
      f = (f + 1) / 2;
      g = (g + 1) / 2;
      b = (b + c) / 4;
      d = (d + l) / 4;
      e = (e + k) / 4;
      h > f && h > g ? .01 > h ? (k = 0, b = l = .707106781) : (k = Math.sqrt(h), l = b / k, b = d / k) : f > g ? .01 > f ? (k = .707106781, l = 0, b = .707106781) : (l = Math.sqrt(f), k = b / l, b = e / l) : .01 > g ? (l = k = .707106781, b = 0) : (b = Math.sqrt(g), k = d / b, l = e / b);
      this.set(k, l, b, a);
      return this;
    }
    a = Math.sqrt((k - e) * (k - e) + (d - l) * (d - l) + (c - b) * (c - b));
    .001 > Math.abs(a) && (a = 1);
    this.x = (k - e) / a;
    this.y = (d - l) / a;
    this.z = (c - b) / a;
    this.w = Math.acos((h + f + g - 1) / 2);
    return this;
  }, min:function(a) {
    this.x = Math.min(this.x, a.x);
    this.y = Math.min(this.y, a.y);
    this.z = Math.min(this.z, a.z);
    this.w = Math.min(this.w, a.w);
    return this;
  }, max:function(a) {
    this.x = Math.max(this.x, a.x);
    this.y = Math.max(this.y, a.y);
    this.z = Math.max(this.z, a.z);
    this.w = Math.max(this.w, a.w);
    return this;
  }, clamp:function(a, b) {
    this.x = Math.max(a.x, Math.min(b.x, this.x));
    this.y = Math.max(a.y, Math.min(b.y, this.y));
    this.z = Math.max(a.z, Math.min(b.z, this.z));
    this.w = Math.max(a.w, Math.min(b.w, this.w));
    return this;
  }, clampScalar:function() {
    var a, b;
    return function(h, d) {
      void 0 === a && (a = new p, b = new p);
      a.set(h, h, h, h);
      b.set(d, d, d, d);
      return this.clamp(a, b);
    };
  }(), clampLength:function(a, b) {
    var h = this.length();
    return this.divideScalar(h || 1).multiplyScalar(Math.max(a, Math.min(b, h)));
  }, floor:function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }, ceil:function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }, round:function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }, roundToZero:function() {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }, negate:function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }, dot:function(a) {
    return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
  }, lengthSq:function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }, length:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }, manhattanLength:function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }, normalize:function() {
    return this.divideScalar(this.length() || 1);
  }, setLength:function(a) {
    return this.normalize().multiplyScalar(a);
  }, lerp:function(a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    this.z += (a.z - this.z) * b;
    this.w += (a.w - this.w) * b;
    return this;
  }, lerpVectors:function(a, b, d) {
    return this.subVectors(b, a).multiplyScalar(d).add(a);
  }, equals:function(a) {
    return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    this.x = a[b];
    this.y = a[b + 1];
    this.z = a[b + 2];
    this.w = a[b + 3];
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this.x;
    a[b + 1] = this.y;
    a[b + 2] = this.z;
    a[b + 3] = this.w;
    return a;
  }, fromBufferAttribute:function(a, b, d) {
    void 0 !== d && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    this.x = a.getX(b);
    this.y = a.getY(b);
    this.z = a.getZ(b);
    this.w = a.getW(b);
    return this;
  }});
  m.prototype = Object.assign(Object.create(c.prototype), {constructor:m, isWebGLRenderTarget:!0, setSize:function(a, b) {
    if (this.width !== a || this.height !== b) {
      this.width = a, this.height = b, this.dispose();
    }
    this.viewport.set(0, 0, a, b);
    this.scissor.set(0, 0, a, b);
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.width = a.width;
    this.height = a.height;
    this.viewport.copy(a.viewport);
    this.texture = a.texture.clone();
    this.depthBuffer = a.depthBuffer;
    this.stencilBuffer = a.stencilBuffer;
    this.depthTexture = a.depthTexture;
    return this;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }});
  t.prototype = Object.assign(Object.create(m.prototype), {constructor:t, isWebGLMultisampleRenderTarget:!0, copy:function(a) {
    m.prototype.copy.call(this, a);
    this.samples = a.samples;
    return this;
  }});
  d.prototype = Object.create(m.prototype);
  d.prototype.constructor = d;
  d.prototype.isWebGLRenderTargetCube = !0;
  l.prototype = Object.create(n.prototype);
  l.prototype.constructor = l;
  l.prototype.isDataTexture = !0;
  Object.assign(u.prototype, {isBox3:!0, set:function(a, b) {
    this.min.copy(a);
    this.max.copy(b);
    return this;
  }, setFromArray:function(a) {
    for (var h = Infinity, b = Infinity, d = Infinity, c = -Infinity, f = -Infinity, e = -Infinity, l = 0, k = a.length; l < k; l += 3) {
      var g = a[l], q = a[l + 1], m = a[l + 2];
      g < h && (h = g);
      q < b && (b = q);
      m < d && (d = m);
      g > c && (c = g);
      q > f && (f = q);
      m > e && (e = m);
    }
    this.min.set(h, b, d);
    this.max.set(c, f, e);
    return this;
  }, setFromBufferAttribute:function(a) {
    for (var h = Infinity, b = Infinity, d = Infinity, c = -Infinity, f = -Infinity, e = -Infinity, l = 0, k = a.count; l < k; l++) {
      var g = a.getX(l), q = a.getY(l), m = a.getZ(l);
      g < h && (h = g);
      q < b && (b = q);
      m < d && (d = m);
      g > c && (c = g);
      q > f && (f = q);
      m > e && (e = m);
    }
    this.min.set(h, b, d);
    this.max.set(c, f, e);
    return this;
  }, setFromPoints:function(a) {
    this.makeEmpty();
    for (var h = 0, b = a.length; h < b; h++) {
      this.expandByPoint(a[h]);
    }
    return this;
  }, setFromCenterAndSize:function() {
    var a = new f;
    return function(h, b) {
      b = a.copy(b).multiplyScalar(.5);
      this.min.copy(h).sub(b);
      this.max.copy(h).add(b);
      return this;
    };
  }(), setFromObject:function(a) {
    this.makeEmpty();
    return this.expandByObject(a);
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.min.copy(a.min);
    this.max.copy(a.max);
    return this;
  }, makeEmpty:function() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }, isEmpty:function() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }, getCenter:function(a) {
    void 0 === a && (console.warn("THREE.Box3: .getCenter() target is now required"), a = new f);
    return this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5);
  }, getSize:function(a) {
    void 0 === a && (console.warn("THREE.Box3: .getSize() target is now required"), a = new f);
    return this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min);
  }, expandByPoint:function(a) {
    this.min.min(a);
    this.max.max(a);
    return this;
  }, expandByVector:function(a) {
    this.min.sub(a);
    this.max.add(a);
    return this;
  }, expandByScalar:function(a) {
    this.min.addScalar(-a);
    this.max.addScalar(a);
    return this;
  }, expandByObject:function() {
    function a(a) {
      var h = a.geometry;
      if (void 0 !== h) {
        if (h.isGeometry) {
          for (h = h.vertices, d = 0, c = h.length; d < c; d++) {
            e.copy(h[d]), e.applyMatrix4(a.matrixWorld), b.expandByPoint(e);
          }
        } else {
          if (h.isBufferGeometry && (h = h.attributes.position, void 0 !== h)) {
            for (d = 0, c = h.count; d < c; d++) {
              e.fromBufferAttribute(h, d).applyMatrix4(a.matrixWorld), b.expandByPoint(e);
            }
          }
        }
      }
    }
    var b, d, c, e = new f;
    return function(h) {
      b = this;
      h.updateMatrixWorld(!0);
      h.traverse(a);
      return this;
    };
  }(), containsPoint:function(a) {
    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0;
  }, containsBox:function(a) {
    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z;
  }, getParameter:function(a, b) {
    void 0 === b && (console.warn("THREE.Box3: .getParameter() target is now required"), b = new f);
    return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));
  }, intersectsBox:function(a) {
    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0;
  }, intersectsSphere:function() {
    var a = new f;
    return function(h) {
      this.clampPoint(h.center, a);
      return a.distanceToSquared(h.center) <= h.radius * h.radius;
    };
  }(), intersectsPlane:function(a) {
    if (0 < a.normal.x) {
      var h = a.normal.x * this.min.x, b = a.normal.x * this.max.x;
    } else {
      h = a.normal.x * this.max.x, b = a.normal.x * this.min.x;
    }
    0 < a.normal.y ? (h += a.normal.y * this.min.y, b += a.normal.y * this.max.y) : (h += a.normal.y * this.max.y, b += a.normal.y * this.min.y);
    0 < a.normal.z ? (h += a.normal.z * this.min.z, b += a.normal.z * this.max.z) : (h += a.normal.z * this.max.z, b += a.normal.z * this.min.z);
    return h <= -a.constant && b >= -a.constant;
  }, intersectsTriangle:function() {
    function a(a) {
      var h, f = 0;
      for (h = a.length - 3; f <= h; f += 3) {
        g.fromArray(a, f);
        var e = m.x * Math.abs(g.x) + m.y * Math.abs(g.y) + m.z * Math.abs(g.z), r = b.dot(g), l = d.dot(g), k = c.dot(g);
        if (Math.max(-Math.max(r, l, k), Math.min(r, l, k)) > e) {
          return !1;
        }
      }
      return !0;
    }
    var b = new f, d = new f, c = new f, e = new f, l = new f, k = new f, g = new f, q = new f, m = new f, n = new f;
    return function(h) {
      if (this.isEmpty()) {
        return !1;
      }
      this.getCenter(q);
      m.subVectors(this.max, q);
      b.subVectors(h.a, q);
      d.subVectors(h.b, q);
      c.subVectors(h.c, q);
      e.subVectors(d, b);
      l.subVectors(c, d);
      k.subVectors(b, c);
      h = [0, -e.z, e.y, 0, -l.z, l.y, 0, -k.z, k.y, e.z, 0, -e.x, l.z, 0, -l.x, k.z, 0, -k.x, -e.y, e.x, 0, -l.y, l.x, 0, -k.y, k.x, 0];
      if (!a(h)) {
        return !1;
      }
      h = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!a(h)) {
        return !1;
      }
      n.crossVectors(e, l);
      h = [n.x, n.y, n.z];
      return a(h);
    };
  }(), clampPoint:function(a, b) {
    void 0 === b && (console.warn("THREE.Box3: .clampPoint() target is now required"), b = new f);
    return b.copy(a).clamp(this.min, this.max);
  }, distanceToPoint:function() {
    var a = new f;
    return function(h) {
      return a.copy(h).clamp(this.min, this.max).sub(h).length();
    };
  }(), getBoundingSphere:function() {
    var a = new f;
    return function(h) {
      void 0 === h && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), h = new w);
      this.getCenter(h.center);
      h.radius = .5 * this.getSize(a).length();
      return h;
    };
  }(), intersect:function(a) {
    this.min.max(a.min);
    this.max.min(a.max);
    this.isEmpty() && this.makeEmpty();
    return this;
  }, union:function(a) {
    this.min.min(a.min);
    this.max.max(a.max);
    return this;
  }, applyMatrix4:function() {
    var a = [new f, new f, new f, new f, new f, new f, new f, new f];
    return function(h) {
      if (this.isEmpty()) {
        return this;
      }
      a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(h);
      a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(h);
      a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(h);
      a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(h);
      a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(h);
      a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(h);
      a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(h);
      a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(h);
      this.setFromPoints(a);
      return this;
    };
  }(), translate:function(a) {
    this.min.add(a);
    this.max.add(a);
    return this;
  }, equals:function(a) {
    return a.min.equals(this.min) && a.max.equals(this.max);
  }});
  Object.assign(w.prototype, {set:function(a, b) {
    this.center.copy(a);
    this.radius = b;
    return this;
  }, setFromPoints:function() {
    var a = new u;
    return function(h, b) {
      var d = this.center;
      void 0 !== b ? d.copy(b) : a.setFromPoints(h).getCenter(d);
      for (var c = b = 0, f = h.length; c < f; c++) {
        b = Math.max(b, d.distanceToSquared(h[c]));
      }
      this.radius = Math.sqrt(b);
      return this;
    };
  }(), clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.center.copy(a.center);
    this.radius = a.radius;
    return this;
  }, empty:function() {
    return 0 >= this.radius;
  }, containsPoint:function(a) {
    return a.distanceToSquared(this.center) <= this.radius * this.radius;
  }, distanceToPoint:function(a) {
    return a.distanceTo(this.center) - this.radius;
  }, intersectsSphere:function(a) {
    var h = this.radius + a.radius;
    return a.center.distanceToSquared(this.center) <= h * h;
  }, intersectsBox:function(a) {
    return a.intersectsSphere(this);
  }, intersectsPlane:function(a) {
    return Math.abs(a.distanceToPoint(this.center)) <= this.radius;
  }, clampPoint:function(a, b) {
    var h = this.center.distanceToSquared(a);
    void 0 === b && (console.warn("THREE.Sphere: .clampPoint() target is now required"), b = new f);
    b.copy(a);
    h > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center));
    return b;
  }, getBoundingBox:function(a) {
    void 0 === a && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), a = new u);
    a.set(this.center, this.center);
    a.expandByScalar(this.radius);
    return a;
  }, applyMatrix4:function(a) {
    this.center.applyMatrix4(a);
    this.radius *= a.getMaxScaleOnAxis();
    return this;
  }, translate:function(a) {
    this.center.add(a);
    return this;
  }, equals:function(a) {
    return a.center.equals(this.center) && a.radius === this.radius;
  }});
  Object.assign(y.prototype, {set:function(a, b) {
    this.normal.copy(a);
    this.constant = b;
    return this;
  }, setComponents:function(a, b, d, c) {
    this.normal.set(a, b, d);
    this.constant = c;
    return this;
  }, setFromNormalAndCoplanarPoint:function(a, b) {
    this.normal.copy(a);
    this.constant = -b.dot(this.normal);
    return this;
  }, setFromCoplanarPoints:function() {
    var a = new f, b = new f;
    return function(h, d, c) {
      d = a.subVectors(c, d).cross(b.subVectors(h, d)).normalize();
      this.setFromNormalAndCoplanarPoint(d, h);
      return this;
    };
  }(), clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.normal.copy(a.normal);
    this.constant = a.constant;
    return this;
  }, normalize:function() {
    var a = 1 / this.normal.length();
    this.normal.multiplyScalar(a);
    this.constant *= a;
    return this;
  }, negate:function() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }, distanceToPoint:function(a) {
    return this.normal.dot(a) + this.constant;
  }, distanceToSphere:function(a) {
    return this.distanceToPoint(a.center) - a.radius;
  }, projectPoint:function(a, b) {
    void 0 === b && (console.warn("THREE.Plane: .projectPoint() target is now required"), b = new f);
    return b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a);
  }, intersectLine:function() {
    var a = new f;
    return function(h, b) {
      void 0 === b && (console.warn("THREE.Plane: .intersectLine() target is now required"), b = new f);
      var d = h.delta(a), c = this.normal.dot(d);
      if (0 === c) {
        if (0 === this.distanceToPoint(h.start)) {
          return b.copy(h.start);
        }
      } else {
        if (c = -(h.start.dot(this.normal) + this.constant) / c, !(0 > c || 1 < c)) {
          return b.copy(d).multiplyScalar(c).add(h.start);
        }
      }
    };
  }(), intersectsLine:function(a) {
    var h = this.distanceToPoint(a.start);
    a = this.distanceToPoint(a.end);
    return 0 > h && 0 < a || 0 > a && 0 < h;
  }, intersectsBox:function(a) {
    return a.intersectsPlane(this);
  }, intersectsSphere:function(a) {
    return a.intersectsPlane(this);
  }, coplanarPoint:function(a) {
    void 0 === a && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), a = new f);
    return a.copy(this.normal).multiplyScalar(-this.constant);
  }, applyMatrix4:function() {
    var a = new f, b = new k;
    return function(h, d) {
      d = d || b.getNormalMatrix(h);
      h = this.coplanarPoint(a).applyMatrix4(h);
      d = this.normal.applyMatrix3(d).normalize();
      this.constant = -h.dot(d);
      return this;
    };
  }(), translate:function(a) {
    this.constant -= a.dot(this.normal);
    return this;
  }, equals:function(a) {
    return a.normal.equals(this.normal) && a.constant === this.constant;
  }});
  Object.assign(x.prototype, {set:function(a, b, d, c, f, e) {
    var h = this.planes;
    h[0].copy(a);
    h[1].copy(b);
    h[2].copy(d);
    h[3].copy(c);
    h[4].copy(f);
    h[5].copy(e);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    for (var h = this.planes, b = 0; 6 > b; b++) {
      h[b].copy(a.planes[b]);
    }
    return this;
  }, setFromMatrix:function(a) {
    var h = this.planes, b = a.elements;
    a = b[0];
    var d = b[1], c = b[2], f = b[3], e = b[4], l = b[5], k = b[6], g = b[7], q = b[8], m = b[9], n = b[10], t = b[11], u = b[12], p = b[13], v = b[14];
    b = b[15];
    h[0].setComponents(f - a, g - e, t - q, b - u).normalize();
    h[1].setComponents(f + a, g + e, t + q, b + u).normalize();
    h[2].setComponents(f + d, g + l, t + m, b + p).normalize();
    h[3].setComponents(f - d, g - l, t - m, b - p).normalize();
    h[4].setComponents(f - c, g - k, t - n, b - v).normalize();
    h[5].setComponents(f + c, g + k, t + n, b + v).normalize();
    return this;
  }, intersectsObject:function() {
    var a = new w;
    return function(h) {
      var b = h.geometry;
      null === b.boundingSphere && b.computeBoundingSphere();
      a.copy(b.boundingSphere).applyMatrix4(h.matrixWorld);
      return this.intersectsSphere(a);
    };
  }(), intersectsSprite:function() {
    var a = new w;
    return function(h) {
      a.center.set(0, 0, 0);
      a.radius = .7071067811865476;
      a.applyMatrix4(h.matrixWorld);
      return this.intersectsSphere(a);
    };
  }(), intersectsSphere:function(a) {
    var h = this.planes, b = a.center;
    a = -a.radius;
    for (var d = 0; 6 > d; d++) {
      if (h[d].distanceToPoint(b) < a) {
        return !1;
      }
    }
    return !0;
  }, intersectsBox:function() {
    var a = new f;
    return function(h) {
      for (var b = this.planes, d = 0; 6 > d; d++) {
        var c = b[d];
        a.x = 0 < c.normal.x ? h.max.x : h.min.x;
        a.y = 0 < c.normal.y ? h.max.y : h.min.y;
        a.z = 0 < c.normal.z ? h.max.z : h.min.z;
        if (0 > c.distanceToPoint(a)) {
          return !1;
        }
      }
      return !0;
    };
  }(), containsPoint:function(a) {
    for (var h = this.planes, b = 0; 6 > b; b++) {
      if (0 > h[b].distanceToPoint(a)) {
        return !1;
      }
    }
    return !0;
  }});
  var na = {alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", 
  aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex:"vec3 transformed = vec3( position );", beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs:"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}", 
  bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", 
  clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", 
  clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif", clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif", 
  color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex:"#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common:"#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}", 
  cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif", 
  defaultnormal_vertex:"vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif", 
  emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", 
  envmap_fragment:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", 
  envmap_pars_fragment:"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", 
  envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment:"#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", 
  envmap_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", 
  fog_vertex:"#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif", fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", 
  gradientmap_pars_fragment:"#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif", lightmap_fragment:"#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif", 
  lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif", 
  lights_pars_begin:"uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", 
  lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", 
  lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif", 
  lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", 
  lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif", 
  lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif", 
  lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif", 
  logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif", map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", 
  map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment:"#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif", map_particle_pars_fragment:"#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif", metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", 
  metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", 
  morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", 
  normal_fragment_begin:"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif", 
  normal_fragment_maps:"#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", 
  normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif", 
  packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", 
  premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex:"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment:"#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment:"#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", 
  roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", 
  shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif", 
  shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif", 
  shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}", 
  skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", 
  skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", 
  specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment:"#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}", 
  uv_pars_fragment:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif", 
  uv_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif", 
  uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif", background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", 
  cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", 
  depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}", 
  depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}", 
  distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", 
  distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", 
  equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", 
  equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", 
  linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", 
  meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", 
  meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", 
  meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", 
  meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", 
  meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", 
  meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", 
  meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", 
  meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", 
  meshphysical_frag:"#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", 
  meshphysical_vert:"#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", 
  normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", 
  normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", 
  points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", 
  points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", 
  shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}", shadow_vert:"#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", 
  sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", 
  sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"}, 
  zg = {clone:q, merge:v}, Ag = {aliceblue:15792383, antiquewhite:16444375, aqua:65535, aquamarine:8388564, azure:15794175, beige:16119260, bisque:16770244, black:0, blanchedalmond:16772045, blue:255, blueviolet:9055202, brown:10824234, burlywood:14596231, cadetblue:6266528, chartreuse:8388352, chocolate:13789470, coral:16744272, cornflowerblue:6591981, cornsilk:16775388, crimson:14423100, cyan:65535, darkblue:139, darkcyan:35723, darkgoldenrod:12092939, darkgray:11119017, darkgreen:25600, darkgrey:11119017, 
  darkkhaki:12433259, darkmagenta:9109643, darkolivegreen:5597999, darkorange:16747520, darkorchid:10040012, darkred:9109504, darksalmon:15308410, darkseagreen:9419919, darkslateblue:4734347, darkslategray:3100495, darkslategrey:3100495, darkturquoise:52945, darkviolet:9699539, deeppink:16716947, deepskyblue:49151, dimgray:6908265, dimgrey:6908265, dodgerblue:2003199, firebrick:11674146, floralwhite:16775920, forestgreen:2263842, fuchsia:16711935, gainsboro:14474460, ghostwhite:16316671, gold:16766720, 
  goldenrod:14329120, gray:8421504, green:32768, greenyellow:11403055, grey:8421504, honeydew:15794160, hotpink:16738740, indianred:13458524, indigo:4915330, ivory:16777200, khaki:15787660, lavender:15132410, lavenderblush:16773365, lawngreen:8190976, lemonchiffon:16775885, lightblue:11393254, lightcoral:15761536, lightcyan:14745599, lightgoldenrodyellow:16448210, lightgray:13882323, lightgreen:9498256, lightgrey:13882323, lightpink:16758465, lightsalmon:16752762, lightseagreen:2142890, lightskyblue:8900346, 
  lightslategray:7833753, lightslategrey:7833753, lightsteelblue:11584734, lightyellow:16777184, lime:65280, limegreen:3329330, linen:16445670, magenta:16711935, maroon:8388608, mediumaquamarine:6737322, mediumblue:205, mediumorchid:12211667, mediumpurple:9662683, mediumseagreen:3978097, mediumslateblue:8087790, mediumspringgreen:64154, mediumturquoise:4772300, mediumvioletred:13047173, midnightblue:1644912, mintcream:16121850, mistyrose:16770273, moccasin:16770229, navajowhite:16768685, navy:128, 
  oldlace:16643558, olive:8421376, olivedrab:7048739, orange:16753920, orangered:16729344, orchid:14315734, palegoldenrod:15657130, palegreen:10025880, paleturquoise:11529966, palevioletred:14381203, papayawhip:16773077, peachpuff:16767673, peru:13468991, pink:16761035, plum:14524637, powderblue:11591910, purple:8388736, rebeccapurple:6697881, red:16711680, rosybrown:12357519, royalblue:4286945, saddlebrown:9127187, salmon:16416882, sandybrown:16032864, seagreen:3050327, seashell:16774638, sienna:10506797, 
  silver:12632256, skyblue:8900331, slateblue:6970061, slategray:7372944, slategrey:7372944, snow:16775930, springgreen:65407, steelblue:4620980, tan:13808780, teal:32896, thistle:14204888, tomato:16737095, turquoise:4251856, violet:15631086, wheat:16113331, white:16777215, whitesmoke:16119285, yellow:16776960, yellowgreen:10145074};
  Object.assign(z.prototype, {isColor:!0, r:1, g:1, b:1, set:function(a) {
    a && a.isColor ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
    return this;
  }, setScalar:function(a) {
    this.b = this.g = this.r = a;
    return this;
  }, setHex:function(a) {
    a = Math.floor(a);
    this.r = (a >> 16 & 255) / 255;
    this.g = (a >> 8 & 255) / 255;
    this.b = (a & 255) / 255;
    return this;
  }, setRGB:function(a, b, d) {
    this.r = a;
    this.g = b;
    this.b = d;
    return this;
  }, setHSL:function() {
    function a(a, h, b) {
      0 > b && (b += 1);
      1 < b && --b;
      return b < 1 / 6 ? a + 6 * (h - a) * b : .5 > b ? h : b < 2 / 3 ? a + 6 * (h - a) * (2 / 3 - b) : a;
    }
    return function(h, b, d) {
      h = ia.euclideanModulo(h, 1);
      b = ia.clamp(b, 0, 1);
      d = ia.clamp(d, 0, 1);
      0 === b ? this.r = this.g = this.b = d : (b = .5 >= d ? d * (1 + b) : d + b - d * b, d = 2 * d - b, this.r = a(d, b, h + 1 / 3), this.g = a(d, b, h), this.b = a(d, b, h - 1 / 3));
      return this;
    };
  }(), setStyle:function(a) {
    function h(h) {
      void 0 !== h && 1 > parseFloat(h) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.");
    }
    var b;
    if (b = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
      var d = b[2];
      switch(b[1]) {
        case "rgb":
        case "rgba":
          if (b = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
            return this.r = Math.min(255, parseInt(b[1], 10)) / 255, this.g = Math.min(255, parseInt(b[2], 10)) / 255, this.b = Math.min(255, parseInt(b[3], 10)) / 255, h(b[5]), this;
          }
          if (b = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
            return this.r = Math.min(100, parseInt(b[1], 10)) / 100, this.g = Math.min(100, parseInt(b[2], 10)) / 100, this.b = Math.min(100, parseInt(b[3], 10)) / 100, h(b[5]), this;
          }
          break;
        case "hsl":
        case "hsla":
          if (b = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
            d = parseFloat(b[1]) / 360;
            var c = parseInt(b[2], 10) / 100, f = parseInt(b[3], 10) / 100;
            h(b[5]);
            return this.setHSL(d, c, f);
          }
      }
    } else {
      if (b = /^#([A-Fa-f0-9]+)$/.exec(a)) {
        b = b[1];
        d = b.length;
        if (3 === d) {
          return this.r = parseInt(b.charAt(0) + b.charAt(0), 16) / 255, this.g = parseInt(b.charAt(1) + b.charAt(1), 16) / 255, this.b = parseInt(b.charAt(2) + b.charAt(2), 16) / 255, this;
        }
        if (6 === d) {
          return this.r = parseInt(b.charAt(0) + b.charAt(1), 16) / 255, this.g = parseInt(b.charAt(2) + b.charAt(3), 16) / 255, this.b = parseInt(b.charAt(4) + b.charAt(5), 16) / 255, this;
        }
      }
    }
    a && 0 < a.length && (b = Ag[a], void 0 !== b ? this.setHex(b) : console.warn("THREE.Color: Unknown color " + a));
    return this;
  }, clone:function() {
    return new this.constructor(this.r, this.g, this.b);
  }, copy:function(a) {
    this.r = a.r;
    this.g = a.g;
    this.b = a.b;
    return this;
  }, copyGammaToLinear:function(a, b) {
    void 0 === b && (b = 2);
    this.r = Math.pow(a.r, b);
    this.g = Math.pow(a.g, b);
    this.b = Math.pow(a.b, b);
    return this;
  }, copyLinearToGamma:function(a, b) {
    void 0 === b && (b = 2);
    b = 0 < b ? 1 / b : 1;
    this.r = Math.pow(a.r, b);
    this.g = Math.pow(a.g, b);
    this.b = Math.pow(a.b, b);
    return this;
  }, convertGammaToLinear:function(a) {
    this.copyGammaToLinear(this, a);
    return this;
  }, convertLinearToGamma:function(a) {
    this.copyLinearToGamma(this, a);
    return this;
  }, copySRGBToLinear:function() {
    function a(a) {
      return .04045 > a ? .0773993808 * a : Math.pow(.9478672986 * a + .0521327014, 2.4);
    }
    return function(h) {
      this.r = a(h.r);
      this.g = a(h.g);
      this.b = a(h.b);
      return this;
    };
  }(), copyLinearToSRGB:function() {
    function a(a) {
      return .0031308 > a ? 12.92 * a : 1.055 * Math.pow(a, .41666) - .055;
    }
    return function(h) {
      this.r = a(h.r);
      this.g = a(h.g);
      this.b = a(h.b);
      return this;
    };
  }(), convertSRGBToLinear:function() {
    this.copySRGBToLinear(this);
    return this;
  }, convertLinearToSRGB:function() {
    this.copyLinearToSRGB(this);
    return this;
  }, getHex:function() {
    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
  }, getHexString:function() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }, getHSL:function(a) {
    void 0 === a && (console.warn("THREE.Color: .getHSL() target is now required"), a = {h:0, s:0, l:0});
    var h = this.r, b = this.g, d = this.b, c = Math.max(h, b, d), f = Math.min(h, b, d), e, l = (f + c) / 2;
    if (f === c) {
      f = e = 0;
    } else {
      var k = c - f;
      f = .5 >= l ? k / (c + f) : k / (2 - c - f);
      switch(c) {
        case h:
          e = (b - d) / k + (b < d ? 6 : 0);
          break;
        case b:
          e = (d - h) / k + 2;
          break;
        case d:
          e = (h - b) / k + 4;
      }
      e /= 6;
    }
    a.h = e;
    a.s = f;
    a.l = l;
    return a;
  }, getStyle:function() {
    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
  }, offsetHSL:function() {
    var a = {};
    return function(h, b, d) {
      this.getHSL(a);
      a.h += h;
      a.s += b;
      a.l += d;
      this.setHSL(a.h, a.s, a.l);
      return this;
    };
  }(), add:function(a) {
    this.r += a.r;
    this.g += a.g;
    this.b += a.b;
    return this;
  }, addColors:function(a, b) {
    this.r = a.r + b.r;
    this.g = a.g + b.g;
    this.b = a.b + b.b;
    return this;
  }, addScalar:function(a) {
    this.r += a;
    this.g += a;
    this.b += a;
    return this;
  }, sub:function(a) {
    this.r = Math.max(0, this.r - a.r);
    this.g = Math.max(0, this.g - a.g);
    this.b = Math.max(0, this.b - a.b);
    return this;
  }, multiply:function(a) {
    this.r *= a.r;
    this.g *= a.g;
    this.b *= a.b;
    return this;
  }, multiplyScalar:function(a) {
    this.r *= a;
    this.g *= a;
    this.b *= a;
    return this;
  }, lerp:function(a, b) {
    this.r += (a.r - this.r) * b;
    this.g += (a.g - this.g) * b;
    this.b += (a.b - this.b) * b;
    return this;
  }, lerpHSL:function() {
    var a = {h:0, s:0, l:0}, b = {h:0, s:0, l:0};
    return function(h, d) {
      this.getHSL(a);
      h.getHSL(b);
      h = ia.lerp(a.h, b.h, d);
      var c = ia.lerp(a.s, b.s, d);
      d = ia.lerp(a.l, b.l, d);
      this.setHSL(h, c, d);
      return this;
    };
  }(), equals:function(a) {
    return a.r === this.r && a.g === this.g && a.b === this.b;
  }, fromArray:function(a, b) {
    void 0 === b && (b = 0);
    this.r = a[b];
    this.g = a[b + 1];
    this.b = a[b + 2];
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this.r;
    a[b + 1] = this.g;
    a[b + 2] = this.b;
    return a;
  }, toJSON:function() {
    return this.getHex();
  }});
  var ea = {common:{diffuse:{value:new z(15658734)}, opacity:{value:1}, map:{value:null}, uvTransform:{value:new k}, alphaMap:{value:null}}, specularmap:{specularMap:{value:null}}, envmap:{envMap:{value:null}, flipEnvMap:{value:-1}, reflectivity:{value:1}, refractionRatio:{value:.98}, maxMipLevel:{value:0}}, aomap:{aoMap:{value:null}, aoMapIntensity:{value:1}}, lightmap:{lightMap:{value:null}, lightMapIntensity:{value:1}}, emissivemap:{emissiveMap:{value:null}}, bumpmap:{bumpMap:{value:null}, bumpScale:{value:1}}, 
  normalmap:{normalMap:{value:null}, normalScale:{value:new g(1, 1)}}, displacementmap:{displacementMap:{value:null}, displacementScale:{value:1}, displacementBias:{value:0}}, roughnessmap:{roughnessMap:{value:null}}, metalnessmap:{metalnessMap:{value:null}}, gradientmap:{gradientMap:{value:null}}, fog:{fogDensity:{value:2.5E-4}, fogNear:{value:1}, fogFar:{value:2E3}, fogColor:{value:new z(16777215)}}, lights:{ambientLightColor:{value:[]}, directionalLights:{value:[], properties:{direction:{}, color:{}, 
  shadow:{}, shadowBias:{}, shadowRadius:{}, shadowMapSize:{}}}, directionalShadowMap:{value:[]}, directionalShadowMatrix:{value:[]}, spotLights:{value:[], properties:{color:{}, position:{}, direction:{}, distance:{}, coneCos:{}, penumbraCos:{}, decay:{}, shadow:{}, shadowBias:{}, shadowRadius:{}, shadowMapSize:{}}}, spotShadowMap:{value:[]}, spotShadowMatrix:{value:[]}, pointLights:{value:[], properties:{color:{}, position:{}, decay:{}, distance:{}, shadow:{}, shadowBias:{}, shadowRadius:{}, shadowMapSize:{}, 
  shadowCameraNear:{}, shadowCameraFar:{}}}, pointShadowMap:{value:[]}, pointShadowMatrix:{value:[]}, hemisphereLights:{value:[], properties:{direction:{}, skyColor:{}, groundColor:{}}}, rectAreaLights:{value:[], properties:{color:{}, position:{}, width:{}, height:{}}}}, points:{diffuse:{value:new z(15658734)}, opacity:{value:1}, size:{value:1}, scale:{value:1}, map:{value:null}, uvTransform:{value:new k}}, sprite:{diffuse:{value:new z(15658734)}, opacity:{value:1}, center:{value:new g(.5, .5)}, 
  rotation:{value:0}, map:{value:null}, uvTransform:{value:new k}}}, fb = {basic:{uniforms:v([ea.common, ea.specularmap, ea.envmap, ea.aomap, ea.lightmap, ea.fog]), vertexShader:na.meshbasic_vert, fragmentShader:na.meshbasic_frag}, lambert:{uniforms:v([ea.common, ea.specularmap, ea.envmap, ea.aomap, ea.lightmap, ea.emissivemap, ea.fog, ea.lights, {emissive:{value:new z(0)}}]), vertexShader:na.meshlambert_vert, fragmentShader:na.meshlambert_frag}, phong:{uniforms:v([ea.common, ea.specularmap, ea.envmap, 
  ea.aomap, ea.lightmap, ea.emissivemap, ea.bumpmap, ea.normalmap, ea.displacementmap, ea.gradientmap, ea.fog, ea.lights, {emissive:{value:new z(0)}, specular:{value:new z(1118481)}, shininess:{value:30}}]), vertexShader:na.meshphong_vert, fragmentShader:na.meshphong_frag}, standard:{uniforms:v([ea.common, ea.envmap, ea.aomap, ea.lightmap, ea.emissivemap, ea.bumpmap, ea.normalmap, ea.displacementmap, ea.roughnessmap, ea.metalnessmap, ea.fog, ea.lights, {emissive:{value:new z(0)}, roughness:{value:.5}, 
  metalness:{value:.5}, envMapIntensity:{value:1}}]), vertexShader:na.meshphysical_vert, fragmentShader:na.meshphysical_frag}, matcap:{uniforms:v([ea.common, ea.bumpmap, ea.normalmap, ea.displacementmap, ea.fog, {matcap:{value:null}}]), vertexShader:na.meshmatcap_vert, fragmentShader:na.meshmatcap_frag}, points:{uniforms:v([ea.points, ea.fog]), vertexShader:na.points_vert, fragmentShader:na.points_frag}, dashed:{uniforms:v([ea.common, ea.fog, {scale:{value:1}, dashSize:{value:1}, totalSize:{value:2}}]), 
  vertexShader:na.linedashed_vert, fragmentShader:na.linedashed_frag}, depth:{uniforms:v([ea.common, ea.displacementmap]), vertexShader:na.depth_vert, fragmentShader:na.depth_frag}, normal:{uniforms:v([ea.common, ea.bumpmap, ea.normalmap, ea.displacementmap, {opacity:{value:1}}]), vertexShader:na.normal_vert, fragmentShader:na.normal_frag}, sprite:{uniforms:v([ea.sprite, ea.fog]), vertexShader:na.sprite_vert, fragmentShader:na.sprite_frag}, background:{uniforms:{uvTransform:{value:new k}, t2D:{value:null}}, 
  vertexShader:na.background_vert, fragmentShader:na.background_frag}, cube:{uniforms:{tCube:{value:null}, tFlip:{value:-1}, opacity:{value:1}}, vertexShader:na.cube_vert, fragmentShader:na.cube_frag}, equirect:{uniforms:{tEquirect:{value:null}}, vertexShader:na.equirect_vert, fragmentShader:na.equirect_frag}, distanceRGBA:{uniforms:v([ea.common, ea.displacementmap, {referencePosition:{value:new f}, nearDistance:{value:1}, farDistance:{value:1E3}}]), vertexShader:na.distanceRGBA_vert, fragmentShader:na.distanceRGBA_frag}, 
  shadow:{uniforms:v([ea.lights, ea.fog, {color:{value:new z(0)}, opacity:{value:1}}]), vertexShader:na.shadow_vert, fragmentShader:na.shadow_frag}};
  fb.physical = {uniforms:v([fb.standard.uniforms, {clearCoat:{value:0}, clearCoatRoughness:{value:0}}]), vertexShader:na.meshphysical_vert, fragmentShader:na.meshphysical_frag};
  Object.assign(D.prototype, {clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.a = a.a;
    this.b = a.b;
    this.c = a.c;
    this.normal.copy(a.normal);
    this.color.copy(a.color);
    this.materialIndex = a.materialIndex;
    for (var h = 0, b = a.vertexNormals.length; h < b; h++) {
      this.vertexNormals[h] = a.vertexNormals[h].clone();
    }
    h = 0;
    for (b = a.vertexColors.length; h < b; h++) {
      this.vertexColors[h] = a.vertexColors[h].clone();
    }
    return this;
  }});
  E.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
  E.DefaultOrder = "XYZ";
  Object.defineProperties(E.prototype, {x:{get:function() {
    return this._x;
  }, set:function(a) {
    this._x = a;
    this.onChangeCallback();
  }}, y:{get:function() {
    return this._y;
  }, set:function(a) {
    this._y = a;
    this.onChangeCallback();
  }}, z:{get:function() {
    return this._z;
  }, set:function(a) {
    this._z = a;
    this.onChangeCallback();
  }}, order:{get:function() {
    return this._order;
  }, set:function(a) {
    this._order = a;
    this.onChangeCallback();
  }}});
  Object.assign(E.prototype, {isEuler:!0, set:function(a, b, d, c) {
    this._x = a;
    this._y = b;
    this._z = d;
    this._order = c || this._order;
    this.onChangeCallback();
    return this;
  }, clone:function() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }, copy:function(a) {
    this._x = a._x;
    this._y = a._y;
    this._z = a._z;
    this._order = a._order;
    this.onChangeCallback();
    return this;
  }, setFromRotationMatrix:function(a, b, d) {
    var h = ia.clamp, c = a.elements;
    a = c[0];
    var f = c[4], e = c[8], l = c[1], k = c[5], r = c[9], g = c[2], q = c[6];
    c = c[10];
    b = b || this._order;
    "XYZ" === b ? (this._y = Math.asin(h(e, -1, 1)), .99999 > Math.abs(e) ? (this._x = Math.atan2(-r, c), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(q, k), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-h(r, -1, 1)), .99999 > Math.abs(r) ? (this._y = Math.atan2(e, c), this._z = Math.atan2(l, k)) : (this._y = Math.atan2(-g, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(h(q, -1, 1)), .99999 > Math.abs(q) ? (this._y = Math.atan2(-g, c), this._z = Math.atan2(-f, k)) : (this._y = 
    0, this._z = Math.atan2(l, a))) : "ZYX" === b ? (this._y = Math.asin(-h(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(q, c), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-f, k))) : "YZX" === b ? (this._z = Math.asin(h(l, -1, 1)), .99999 > Math.abs(l) ? (this._x = Math.atan2(-r, k), this._y = Math.atan2(-g, a)) : (this._x = 0, this._y = Math.atan2(e, c))) : "XZY" === b ? (this._z = Math.asin(-h(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(q, k), this._y = 
    Math.atan2(e, a)) : (this._x = Math.atan2(-r, c), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b);
    this._order = b;
    if (!1 !== d) {
      this.onChangeCallback();
    }
    return this;
  }, setFromQuaternion:function() {
    var a = new b;
    return function(h, b, d) {
      a.makeRotationFromQuaternion(h);
      return this.setFromRotationMatrix(a, b, d);
    };
  }(), setFromVector3:function(a, b) {
    return this.set(a.x, a.y, a.z, b || this._order);
  }, reorder:function() {
    var a = new e;
    return function(h) {
      a.setFromEuler(this);
      return this.setFromQuaternion(a, h);
    };
  }(), equals:function(a) {
    return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order;
  }, fromArray:function(a) {
    this._x = a[0];
    this._y = a[1];
    this._z = a[2];
    void 0 !== a[3] && (this._order = a[3]);
    this.onChangeCallback();
    return this;
  }, toArray:function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this._x;
    a[b + 1] = this._y;
    a[b + 2] = this._z;
    a[b + 3] = this._order;
    return a;
  }, toVector3:function(a) {
    return a ? a.set(this._x, this._y, this._z) : new f(this._x, this._y, this._z);
  }, onChange:function(a) {
    this.onChangeCallback = a;
    return this;
  }, onChangeCallback:function() {
  }});
  Object.assign(B.prototype, {set:function(a) {
    this.mask = 1 << a | 0;
  }, enable:function(a) {
    this.mask = this.mask | 1 << a | 0;
  }, toggle:function(a) {
    this.mask ^= 1 << a | 0;
  }, disable:function(a) {
    this.mask &= ~(1 << a | 0);
  }, test:function(a) {
    return 0 !== (this.mask & a.mask);
  }});
  var Yf = 0;
  G.DefaultUp = new f(0, 1, 0);
  G.DefaultMatrixAutoUpdate = !0;
  G.prototype = Object.assign(Object.create(c.prototype), {constructor:G, isObject3D:!0, onBeforeRender:function() {
  }, onAfterRender:function() {
  }, applyMatrix:function(a) {
    this.matrix.multiplyMatrices(a, this.matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }, applyQuaternion:function(a) {
    this.quaternion.premultiply(a);
    return this;
  }, setRotationFromAxisAngle:function(a, b) {
    this.quaternion.setFromAxisAngle(a, b);
  }, setRotationFromEuler:function(a) {
    this.quaternion.setFromEuler(a, !0);
  }, setRotationFromMatrix:function(a) {
    this.quaternion.setFromRotationMatrix(a);
  }, setRotationFromQuaternion:function(a) {
    this.quaternion.copy(a);
  }, rotateOnAxis:function() {
    var a = new e;
    return function(h, b) {
      a.setFromAxisAngle(h, b);
      this.quaternion.multiply(a);
      return this;
    };
  }(), rotateOnWorldAxis:function() {
    var a = new e;
    return function(h, b) {
      a.setFromAxisAngle(h, b);
      this.quaternion.premultiply(a);
      return this;
    };
  }(), rotateX:function() {
    var a = new f(1, 0, 0);
    return function(h) {
      return this.rotateOnAxis(a, h);
    };
  }(), rotateY:function() {
    var a = new f(0, 1, 0);
    return function(h) {
      return this.rotateOnAxis(a, h);
    };
  }(), rotateZ:function() {
    var a = new f(0, 0, 1);
    return function(h) {
      return this.rotateOnAxis(a, h);
    };
  }(), translateOnAxis:function() {
    var a = new f;
    return function(h, b) {
      a.copy(h).applyQuaternion(this.quaternion);
      this.position.add(a.multiplyScalar(b));
      return this;
    };
  }(), translateX:function() {
    var a = new f(1, 0, 0);
    return function(h) {
      return this.translateOnAxis(a, h);
    };
  }(), translateY:function() {
    var a = new f(0, 1, 0);
    return function(h) {
      return this.translateOnAxis(a, h);
    };
  }(), translateZ:function() {
    var a = new f(0, 0, 1);
    return function(h) {
      return this.translateOnAxis(a, h);
    };
  }(), localToWorld:function(a) {
    return a.applyMatrix4(this.matrixWorld);
  }, worldToLocal:function() {
    var a = new b;
    return function(h) {
      return h.applyMatrix4(a.getInverse(this.matrixWorld));
    };
  }(), lookAt:function() {
    var a = new e, d = new b, c = new f, l = new f;
    return function(h, b, f) {
      h.isVector3 ? c.copy(h) : c.set(h, b, f);
      h = this.parent;
      this.updateWorldMatrix(!0, !1);
      l.setFromMatrixPosition(this.matrixWorld);
      this.isCamera || this.isLight ? d.lookAt(l, c, this.up) : d.lookAt(c, l, this.up);
      this.quaternion.setFromRotationMatrix(d);
      h && (d.extractRotation(h.matrixWorld), a.setFromRotationMatrix(d), this.quaternion.premultiply(a.inverse()));
    };
  }(), add:function(a) {
    if (1 < arguments.length) {
      for (var h = 0; h < arguments.length; h++) {
        this.add(arguments[h]);
      }
      return this;
    }
    if (a === this) {
      return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this;
    }
    a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({type:"added"}), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a);
    return this;
  }, remove:function(a) {
    if (1 < arguments.length) {
      for (var h = 0; h < arguments.length; h++) {
        this.remove(arguments[h]);
      }
      return this;
    }
    h = this.children.indexOf(a);
    -1 !== h && (a.parent = null, a.dispatchEvent({type:"removed"}), this.children.splice(h, 1));
    return this;
  }, getObjectById:function(a) {
    return this.getObjectByProperty("id", a);
  }, getObjectByName:function(a) {
    return this.getObjectByProperty("name", a);
  }, getObjectByProperty:function(a, b) {
    if (this[a] === b) {
      return this;
    }
    for (var h = 0, d = this.children.length; h < d; h++) {
      var c = this.children[h].getObjectByProperty(a, b);
      if (void 0 !== c) {
        return c;
      }
    }
  }, getWorldPosition:function(a) {
    void 0 === a && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), a = new f);
    this.updateMatrixWorld(!0);
    return a.setFromMatrixPosition(this.matrixWorld);
  }, getWorldQuaternion:function() {
    var a = new f, b = new f;
    return function(h) {
      void 0 === h && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), h = new e);
      this.updateMatrixWorld(!0);
      this.matrixWorld.decompose(a, h, b);
      return h;
    };
  }(), getWorldScale:function() {
    var a = new f, b = new e;
    return function(h) {
      void 0 === h && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), h = new f);
      this.updateMatrixWorld(!0);
      this.matrixWorld.decompose(a, b, h);
      return h;
    };
  }(), getWorldDirection:function(a) {
    void 0 === a && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), a = new f);
    this.updateMatrixWorld(!0);
    var h = this.matrixWorld.elements;
    return a.set(h[8], h[9], h[10]).normalize();
  }, raycast:function() {
  }, traverse:function(a) {
    a(this);
    for (var h = this.children, b = 0, d = h.length; b < d; b++) {
      h[b].traverse(a);
    }
  }, traverseVisible:function(a) {
    if (!1 !== this.visible) {
      a(this);
      for (var h = this.children, b = 0, d = h.length; b < d; b++) {
        h[b].traverseVisible(a);
      }
    }
  }, traverseAncestors:function(a) {
    var h = this.parent;
    null !== h && (a(h), h.traverseAncestors(a));
  }, updateMatrix:function() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = !0;
  }, updateMatrixWorld:function(a) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || a) {
      null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
    }
    for (var h = this.children, b = 0, d = h.length; b < d; b++) {
      h[b].updateMatrixWorld(a);
    }
  }, updateWorldMatrix:function(a, b) {
    var h = this.parent;
    !0 === a && null !== h && h.updateWorldMatrix(!0, !1);
    this.matrixAutoUpdate && this.updateMatrix();
    null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    if (!0 === b) {
      for (a = this.children, b = 0, h = a.length; b < h; b++) {
        a[b].updateWorldMatrix(!1, !0);
      }
    }
  }, toJSON:function(a) {
    function h(h, b) {
      void 0 === h[b.uuid] && (h[b.uuid] = b.toJSON(a));
      return b.uuid;
    }
    function b(a) {
      var h = [], b;
      for (b in a) {
        var d = a[b];
        delete d.metadata;
        h.push(d);
      }
      return h;
    }
    var d = void 0 === a || "string" === typeof a, c = {};
    d && (a = {geometries:{}, materials:{}, textures:{}, images:{}, shapes:{}}, c.metadata = {version:4.5, type:"Object", generator:"Object3D.toJSON"});
    var f = {};
    f.uuid = this.uuid;
    f.type = this.type;
    "" !== this.name && (f.name = this.name);
    !0 === this.castShadow && (f.castShadow = !0);
    !0 === this.receiveShadow && (f.receiveShadow = !0);
    !1 === this.visible && (f.visible = !1);
    !1 === this.frustumCulled && (f.frustumCulled = !1);
    0 !== this.renderOrder && (f.renderOrder = this.renderOrder);
    "{}" !== JSON.stringify(this.userData) && (f.userData = this.userData);
    f.layers = this.layers.mask;
    f.matrix = this.matrix.toArray();
    !1 === this.matrixAutoUpdate && (f.matrixAutoUpdate = !1);
    this.isMesh && 0 !== this.drawMode && (f.drawMode = this.drawMode);
    if (this.isMesh || this.isLine || this.isPoints) {
      f.geometry = h(a.geometries, this.geometry);
      var e = this.geometry.parameters;
      if (void 0 !== e && void 0 !== e.shapes) {
        if (e = e.shapes, Array.isArray(e)) {
          for (var l = 0, k = e.length; l < k; l++) {
            h(a.shapes, e[l]);
          }
        } else {
          h(a.shapes, e);
        }
      }
    }
    if (void 0 !== this.material) {
      if (Array.isArray(this.material)) {
        e = [];
        l = 0;
        for (k = this.material.length; l < k; l++) {
          e.push(h(a.materials, this.material[l]));
        }
        f.material = e;
      } else {
        f.material = h(a.materials, this.material);
      }
    }
    if (0 < this.children.length) {
      for (f.children = [], l = 0; l < this.children.length; l++) {
        f.children.push(this.children[l].toJSON(a).object);
      }
    }
    if (d) {
      d = b(a.geometries);
      l = b(a.materials);
      k = b(a.textures);
      var g = b(a.images);
      e = b(a.shapes);
      0 < d.length && (c.geometries = d);
      0 < l.length && (c.materials = l);
      0 < k.length && (c.textures = k);
      0 < g.length && (c.images = g);
      0 < e.length && (c.shapes = e);
    }
    c.object = f;
    return c;
  }, clone:function(a) {
    return (new this.constructor).copy(this, a);
  }, copy:function(a, b) {
    void 0 === b && (b = !0);
    this.name = a.name;
    this.up.copy(a.up);
    this.position.copy(a.position);
    this.quaternion.copy(a.quaternion);
    this.scale.copy(a.scale);
    this.matrix.copy(a.matrix);
    this.matrixWorld.copy(a.matrixWorld);
    this.matrixAutoUpdate = a.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
    this.layers.mask = a.layers.mask;
    this.visible = a.visible;
    this.castShadow = a.castShadow;
    this.receiveShadow = a.receiveShadow;
    this.frustumCulled = a.frustumCulled;
    this.renderOrder = a.renderOrder;
    this.userData = JSON.parse(JSON.stringify(a.userData));
    if (!0 === b) {
      for (b = 0; b < a.children.length; b++) {
        this.add(a.children[b].clone());
      }
    }
    return this;
  }});
  var Zf = 0;
  H.prototype = Object.assign(Object.create(c.prototype), {constructor:H, isGeometry:!0, applyMatrix:function(a) {
    for (var h = (new k).getNormalMatrix(a), b = 0, d = this.vertices.length; b < d; b++) {
      this.vertices[b].applyMatrix4(a);
    }
    b = 0;
    for (d = this.faces.length; b < d; b++) {
      a = this.faces[b];
      a.normal.applyMatrix3(h).normalize();
      for (var c = 0, f = a.vertexNormals.length; c < f; c++) {
        a.vertexNormals[c].applyMatrix3(h).normalize();
      }
    }
    null !== this.boundingBox && this.computeBoundingBox();
    null !== this.boundingSphere && this.computeBoundingSphere();
    this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
    return this;
  }, rotateX:function() {
    var a = new b;
    return function(h) {
      a.makeRotationX(h);
      this.applyMatrix(a);
      return this;
    };
  }(), rotateY:function() {
    var a = new b;
    return function(h) {
      a.makeRotationY(h);
      this.applyMatrix(a);
      return this;
    };
  }(), rotateZ:function() {
    var a = new b;
    return function(h) {
      a.makeRotationZ(h);
      this.applyMatrix(a);
      return this;
    };
  }(), translate:function() {
    var a = new b;
    return function(h, b, d) {
      a.makeTranslation(h, b, d);
      this.applyMatrix(a);
      return this;
    };
  }(), scale:function() {
    var a = new b;
    return function(h, b, d) {
      a.makeScale(h, b, d);
      this.applyMatrix(a);
      return this;
    };
  }(), lookAt:function() {
    var a = new G;
    return function(h) {
      a.lookAt(h);
      a.updateMatrix();
      this.applyMatrix(a.matrix);
    };
  }(), fromBufferGeometry:function(a) {
    function h(a, h, d, c) {
      var e = void 0 === k ? [] : [b.colors[a].clone(), b.colors[h].clone(), b.colors[d].clone()], r = void 0 === l ? [] : [(new f).fromArray(l, 3 * a), (new f).fromArray(l, 3 * h), (new f).fromArray(l, 3 * d)];
      c = new D(a, h, d, r, e, c);
      b.faces.push(c);
      void 0 !== q && b.faceVertexUvs[0].push([(new g).fromArray(q, 2 * a), (new g).fromArray(q, 2 * h), (new g).fromArray(q, 2 * d)]);
      void 0 !== m && b.faceVertexUvs[1].push([(new g).fromArray(m, 2 * a), (new g).fromArray(m, 2 * h), (new g).fromArray(m, 2 * d)]);
    }
    var b = this, d = null !== a.index ? a.index.array : void 0, c = a.attributes, e = c.position.array, l = void 0 !== c.normal ? c.normal.array : void 0, k = void 0 !== c.color ? c.color.array : void 0, q = void 0 !== c.uv ? c.uv.array : void 0, m = void 0 !== c.uv2 ? c.uv2.array : void 0;
    void 0 !== m && (this.faceVertexUvs[1] = []);
    for (var n = c = 0; c < e.length; c += 3, n += 2) {
      b.vertices.push((new f).fromArray(e, c)), void 0 !== k && b.colors.push((new z).fromArray(k, c));
    }
    var t = a.groups;
    if (0 < t.length) {
      for (c = 0; c < t.length; c++) {
        e = t[c];
        var u = e.start, p = e.count;
        n = u;
        for (u += p; n < u; n += 3) {
          void 0 !== d ? h(d[n], d[n + 1], d[n + 2], e.materialIndex) : h(n, n + 1, n + 2, e.materialIndex);
        }
      }
    } else {
      if (void 0 !== d) {
        for (c = 0; c < d.length; c += 3) {
          h(d[c], d[c + 1], d[c + 2]);
        }
      } else {
        for (c = 0; c < e.length / 3; c += 3) {
          h(c, c + 1, c + 2);
        }
      }
    }
    this.computeFaceNormals();
    null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
    null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
    return this;
  }, center:function() {
    var a = new f;
    return function() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(a).negate();
      this.translate(a.x, a.y, a.z);
      return this;
    };
  }(), normalize:function() {
    this.computeBoundingSphere();
    var a = this.boundingSphere.center, d = this.boundingSphere.radius;
    d = 0 === d ? 1 : 1 / d;
    var c = new b;
    c.set(d, 0, 0, -d * a.x, 0, d, 0, -d * a.y, 0, 0, d, -d * a.z, 0, 0, 0, 1);
    this.applyMatrix(c);
    return this;
  }, computeFaceNormals:function() {
    for (var a = new f, b = new f, d = 0, c = this.faces.length; d < c; d++) {
      var e = this.faces[d], l = this.vertices[e.a], k = this.vertices[e.b];
      a.subVectors(this.vertices[e.c], k);
      b.subVectors(l, k);
      a.cross(b);
      a.normalize();
      e.normal.copy(a);
    }
  }, computeVertexNormals:function(a) {
    void 0 === a && (a = !0);
    var h, b = Array(this.vertices.length), d = 0;
    for (h = this.vertices.length; d < h; d++) {
      b[d] = new f;
    }
    if (a) {
      var c = new f, e = new f;
      a = 0;
      for (d = this.faces.length; a < d; a++) {
        h = this.faces[a];
        var l = this.vertices[h.a], k = this.vertices[h.b];
        c.subVectors(this.vertices[h.c], k);
        e.subVectors(l, k);
        c.cross(e);
        b[h.a].add(c);
        b[h.b].add(c);
        b[h.c].add(c);
      }
    } else {
      for (this.computeFaceNormals(), a = 0, d = this.faces.length; a < d; a++) {
        h = this.faces[a], b[h.a].add(h.normal), b[h.b].add(h.normal), b[h.c].add(h.normal);
      }
    }
    d = 0;
    for (h = this.vertices.length; d < h; d++) {
      b[d].normalize();
    }
    a = 0;
    for (d = this.faces.length; a < d; a++) {
      h = this.faces[a], l = h.vertexNormals, 3 === l.length ? (l[0].copy(b[h.a]), l[1].copy(b[h.b]), l[2].copy(b[h.c])) : (l[0] = b[h.a].clone(), l[1] = b[h.b].clone(), l[2] = b[h.c].clone());
    }
    0 < this.faces.length && (this.normalsNeedUpdate = !0);
  }, computeFlatVertexNormals:function() {
    var a;
    this.computeFaceNormals();
    var b = 0;
    for (a = this.faces.length; b < a; b++) {
      var d = this.faces[b], c = d.vertexNormals;
      3 === c.length ? (c[0].copy(d.normal), c[1].copy(d.normal), c[2].copy(d.normal)) : (c[0] = d.normal.clone(), c[1] = d.normal.clone(), c[2] = d.normal.clone());
    }
    0 < this.faces.length && (this.normalsNeedUpdate = !0);
  }, computeMorphNormals:function() {
    var a, b, d = 0;
    for (b = this.faces.length; d < b; d++) {
      var c = this.faces[d];
      c.__originalFaceNormal ? c.__originalFaceNormal.copy(c.normal) : c.__originalFaceNormal = c.normal.clone();
      c.__originalVertexNormals || (c.__originalVertexNormals = []);
      var e = 0;
      for (a = c.vertexNormals.length; e < a; e++) {
        c.__originalVertexNormals[e] ? c.__originalVertexNormals[e].copy(c.vertexNormals[e]) : c.__originalVertexNormals[e] = c.vertexNormals[e].clone();
      }
    }
    var l = new H;
    l.faces = this.faces;
    e = 0;
    for (a = this.morphTargets.length; e < a; e++) {
      if (!this.morphNormals[e]) {
        this.morphNormals[e] = {};
        this.morphNormals[e].faceNormals = [];
        this.morphNormals[e].vertexNormals = [];
        c = this.morphNormals[e].faceNormals;
        var k = this.morphNormals[e].vertexNormals;
        d = 0;
        for (b = this.faces.length; d < b; d++) {
          var g = new f, q = {a:new f, b:new f, c:new f};
          c.push(g);
          k.push(q);
        }
      }
      k = this.morphNormals[e];
      l.vertices = this.morphTargets[e].vertices;
      l.computeFaceNormals();
      l.computeVertexNormals();
      d = 0;
      for (b = this.faces.length; d < b; d++) {
        c = this.faces[d], g = k.faceNormals[d], q = k.vertexNormals[d], g.copy(c.normal), q.a.copy(c.vertexNormals[0]), q.b.copy(c.vertexNormals[1]), q.c.copy(c.vertexNormals[2]);
      }
    }
    d = 0;
    for (b = this.faces.length; d < b; d++) {
      c = this.faces[d], c.normal = c.__originalFaceNormal, c.vertexNormals = c.__originalVertexNormals;
    }
  }, computeBoundingBox:function() {
    null === this.boundingBox && (this.boundingBox = new u);
    this.boundingBox.setFromPoints(this.vertices);
  }, computeBoundingSphere:function() {
    null === this.boundingSphere && (this.boundingSphere = new w);
    this.boundingSphere.setFromPoints(this.vertices);
  }, merge:function(a, b, d) {
    if (a && a.isGeometry) {
      var h, c = this.vertices.length, f = this.vertices, e = a.vertices, l = this.faces, r = a.faces, g = this.faceVertexUvs[0], q = a.faceVertexUvs[0], m = this.colors, n = a.colors;
      void 0 === d && (d = 0);
      void 0 !== b && (h = (new k).getNormalMatrix(b));
      a = 0;
      for (var t = e.length; a < t; a++) {
        var u = e[a].clone();
        void 0 !== b && u.applyMatrix4(b);
        f.push(u);
      }
      a = 0;
      for (t = n.length; a < t; a++) {
        m.push(n[a].clone());
      }
      a = 0;
      for (t = r.length; a < t; a++) {
        e = r[a];
        var p = e.vertexNormals;
        n = e.vertexColors;
        m = new D(e.a + c, e.b + c, e.c + c);
        m.normal.copy(e.normal);
        void 0 !== h && m.normal.applyMatrix3(h).normalize();
        b = 0;
        for (f = p.length; b < f; b++) {
          u = p[b].clone(), void 0 !== h && u.applyMatrix3(h).normalize(), m.vertexNormals.push(u);
        }
        m.color.copy(e.color);
        b = 0;
        for (f = n.length; b < f; b++) {
          u = n[b], m.vertexColors.push(u.clone());
        }
        m.materialIndex = e.materialIndex + d;
        l.push(m);
      }
      a = 0;
      for (t = q.length; a < t; a++) {
        if (d = q[a], h = [], void 0 !== d) {
          b = 0;
          for (f = d.length; b < f; b++) {
            h.push(d[b].clone());
          }
          g.push(h);
        }
      }
    } else {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a);
    }
  }, mergeMesh:function(a) {
    a && a.isMesh ? (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a);
  }, mergeVertices:function() {
    var a = {}, b = [], d = [], c = Math.pow(10, 4), f, e = 0;
    for (f = this.vertices.length; e < f; e++) {
      var l = this.vertices[e];
      l = Math.round(l.x * c) + "_" + Math.round(l.y * c) + "_" + Math.round(l.z * c);
      void 0 === a[l] ? (a[l] = e, b.push(this.vertices[e]), d[e] = b.length - 1) : d[e] = d[a[l]];
    }
    a = [];
    e = 0;
    for (f = this.faces.length; e < f; e++) {
      for (c = this.faces[e], c.a = d[c.a], c.b = d[c.b], c.c = d[c.c], c = [c.a, c.b, c.c], l = 0; 3 > l; l++) {
        if (c[l] === c[(l + 1) % 3]) {
          a.push(e);
          break;
        }
      }
    }
    for (e = a.length - 1; 0 <= e; e--) {
      for (c = a[e], this.faces.splice(c, 1), d = 0, f = this.faceVertexUvs.length; d < f; d++) {
        this.faceVertexUvs[d].splice(c, 1);
      }
    }
    e = this.vertices.length - b.length;
    this.vertices = b;
    return e;
  }, setFromPoints:function(a) {
    this.vertices = [];
    for (var h = 0, b = a.length; h < b; h++) {
      var d = a[h];
      this.vertices.push(new f(d.x, d.y, d.z || 0));
    }
    return this;
  }, sortFacesByMaterialIndex:function() {
    for (var a = this.faces, b = a.length, d = 0; d < b; d++) {
      a[d]._id = d;
    }
    a.sort(function(a, h) {
      return a.materialIndex - h.materialIndex;
    });
    var c = this.faceVertexUvs[0], f = this.faceVertexUvs[1], e, l;
    c && c.length === b && (e = []);
    f && f.length === b && (l = []);
    for (d = 0; d < b; d++) {
      var k = a[d]._id;
      e && e.push(c[k]);
      l && l.push(f[k]);
    }
    e && (this.faceVertexUvs[0] = e);
    l && (this.faceVertexUvs[1] = l);
  }, toJSON:function() {
    function a(a, h, b) {
      return b ? a | 1 << h : a & ~(1 << h);
    }
    function b(a) {
      var h = a.x.toString() + a.y.toString() + a.z.toString();
      if (void 0 !== q[h]) {
        return q[h];
      }
      q[h] = g.length / 3;
      g.push(a.x, a.y, a.z);
      return q[h];
    }
    function d(a) {
      var h = a.r.toString() + a.g.toString() + a.b.toString();
      if (void 0 !== n[h]) {
        return n[h];
      }
      n[h] = m.length;
      m.push(a.getHex());
      return n[h];
    }
    function c(a) {
      var h = a.x.toString() + a.y.toString();
      if (void 0 !== u[h]) {
        return u[h];
      }
      u[h] = t.length / 2;
      t.push(a.x, a.y);
      return u[h];
    }
    var f = {metadata:{version:4.5, type:"Geometry", generator:"Geometry.toJSON"}};
    f.uuid = this.uuid;
    f.type = this.type;
    "" !== this.name && (f.name = this.name);
    if (void 0 !== this.parameters) {
      var e = this.parameters, l;
      for (l in e) {
        void 0 !== e[l] && (f[l] = e[l]);
      }
      return f;
    }
    e = [];
    for (l = 0; l < this.vertices.length; l++) {
      var k = this.vertices[l];
      e.push(k.x, k.y, k.z);
    }
    k = [];
    var g = [], q = {}, m = [], n = {}, t = [], u = {};
    for (l = 0; l < this.faces.length; l++) {
      var p = this.faces[l], v = void 0 !== this.faceVertexUvs[0][l], w = 0 < p.normal.length(), z = 0 < p.vertexNormals.length, y = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b, x = 0 < p.vertexColors.length, D = 0;
      D = a(D, 0, 0);
      D = a(D, 1, !0);
      D = a(D, 2, !1);
      D = a(D, 3, v);
      D = a(D, 4, w);
      D = a(D, 5, z);
      D = a(D, 6, y);
      D = a(D, 7, x);
      k.push(D);
      k.push(p.a, p.b, p.c);
      k.push(p.materialIndex);
      v && (v = this.faceVertexUvs[0][l], k.push(c(v[0]), c(v[1]), c(v[2])));
      w && k.push(b(p.normal));
      z && (w = p.vertexNormals, k.push(b(w[0]), b(w[1]), b(w[2])));
      y && k.push(d(p.color));
      x && (p = p.vertexColors, k.push(d(p[0]), d(p[1]), d(p[2])));
    }
    f.data = {};
    f.data.vertices = e;
    f.data.normals = g;
    0 < m.length && (f.data.colors = m);
    0 < t.length && (f.data.uvs = [t]);
    f.data.faces = k;
    return f;
  }, clone:function() {
    return (new H).copy(this);
  }, copy:function(a) {
    var h, b, d;
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingSphere = this.boundingBox = null;
    this.name = a.name;
    var c = a.vertices, f = 0;
    for (h = c.length; f < h; f++) {
      this.vertices.push(c[f].clone());
    }
    c = a.colors;
    f = 0;
    for (h = c.length; f < h; f++) {
      this.colors.push(c[f].clone());
    }
    c = a.faces;
    f = 0;
    for (h = c.length; f < h; f++) {
      this.faces.push(c[f].clone());
    }
    f = 0;
    for (h = a.faceVertexUvs.length; f < h; f++) {
      var e = a.faceVertexUvs[f];
      void 0 === this.faceVertexUvs[f] && (this.faceVertexUvs[f] = []);
      c = 0;
      for (b = e.length; c < b; c++) {
        var l = e[c], k = [], g = 0;
        for (d = l.length; g < d; g++) {
          k.push(l[g].clone());
        }
        this.faceVertexUvs[f].push(k);
      }
    }
    g = a.morphTargets;
    f = 0;
    for (h = g.length; f < h; f++) {
      d = {};
      d.name = g[f].name;
      if (void 0 !== g[f].vertices) {
        for (d.vertices = [], c = 0, b = g[f].vertices.length; c < b; c++) {
          d.vertices.push(g[f].vertices[c].clone());
        }
      }
      if (void 0 !== g[f].normals) {
        for (d.normals = [], c = 0, b = g[f].normals.length; c < b; c++) {
          d.normals.push(g[f].normals[c].clone());
        }
      }
      this.morphTargets.push(d);
    }
    g = a.morphNormals;
    f = 0;
    for (h = g.length; f < h; f++) {
      d = {};
      if (void 0 !== g[f].vertexNormals) {
        for (d.vertexNormals = [], c = 0, b = g[f].vertexNormals.length; c < b; c++) {
          e = g[f].vertexNormals[c], l = {}, l.a = e.a.clone(), l.b = e.b.clone(), l.c = e.c.clone(), d.vertexNormals.push(l);
        }
      }
      if (void 0 !== g[f].faceNormals) {
        for (d.faceNormals = [], c = 0, b = g[f].faceNormals.length; c < b; c++) {
          d.faceNormals.push(g[f].faceNormals[c].clone());
        }
      }
      this.morphNormals.push(d);
    }
    c = a.skinWeights;
    f = 0;
    for (h = c.length; f < h; f++) {
      this.skinWeights.push(c[f].clone());
    }
    c = a.skinIndices;
    f = 0;
    for (h = c.length; f < h; f++) {
      this.skinIndices.push(c[f].clone());
    }
    c = a.lineDistances;
    f = 0;
    for (h = c.length; f < h; f++) {
      this.lineDistances.push(c[f]);
    }
    f = a.boundingBox;
    null !== f && (this.boundingBox = f.clone());
    f = a.boundingSphere;
    null !== f && (this.boundingSphere = f.clone());
    this.elementsNeedUpdate = a.elementsNeedUpdate;
    this.verticesNeedUpdate = a.verticesNeedUpdate;
    this.uvsNeedUpdate = a.uvsNeedUpdate;
    this.normalsNeedUpdate = a.normalsNeedUpdate;
    this.colorsNeedUpdate = a.colorsNeedUpdate;
    this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate;
    this.groupsNeedUpdate = a.groupsNeedUpdate;
    return this;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }});
  Object.defineProperty(K.prototype, "needsUpdate", {set:function(a) {
    !0 === a && this.version++;
  }});
  Object.assign(K.prototype, {isBufferAttribute:!0, onUploadCallback:function() {
  }, setArray:function(a) {
    if (Array.isArray(a)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.count = void 0 !== a ? a.length / this.itemSize : 0;
    this.array = a;
    return this;
  }, setDynamic:function(a) {
    this.dynamic = a;
    return this;
  }, copy:function(a) {
    this.name = a.name;
    this.array = new a.array.constructor(a.array);
    this.itemSize = a.itemSize;
    this.count = a.count;
    this.normalized = a.normalized;
    this.dynamic = a.dynamic;
    return this;
  }, copyAt:function(a, b, d) {
    a *= this.itemSize;
    d *= b.itemSize;
    for (var h = 0, c = this.itemSize; h < c; h++) {
      this.array[a + h] = b.array[d + h];
    }
    return this;
  }, copyArray:function(a) {
    this.array.set(a);
    return this;
  }, copyColorsArray:function(a) {
    for (var h = this.array, b = 0, d = 0, c = a.length; d < c; d++) {
      var f = a[d];
      void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), f = new z);
      h[b++] = f.r;
      h[b++] = f.g;
      h[b++] = f.b;
    }
    return this;
  }, copyVector2sArray:function(a) {
    for (var h = this.array, b = 0, d = 0, c = a.length; d < c; d++) {
      var f = a[d];
      void 0 === f && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", d), f = new g);
      h[b++] = f.x;
      h[b++] = f.y;
    }
    return this;
  }, copyVector3sArray:function(a) {
    for (var h = this.array, b = 0, d = 0, c = a.length; d < c; d++) {
      var e = a[d];
      void 0 === e && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), e = new f);
      h[b++] = e.x;
      h[b++] = e.y;
      h[b++] = e.z;
    }
    return this;
  }, copyVector4sArray:function(a) {
    for (var h = this.array, b = 0, d = 0, c = a.length; d < c; d++) {
      var f = a[d];
      void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), f = new p);
      h[b++] = f.x;
      h[b++] = f.y;
      h[b++] = f.z;
      h[b++] = f.w;
    }
    return this;
  }, set:function(a, b) {
    void 0 === b && (b = 0);
    this.array.set(a, b);
    return this;
  }, getX:function(a) {
    return this.array[a * this.itemSize];
  }, setX:function(a, b) {
    this.array[a * this.itemSize] = b;
    return this;
  }, getY:function(a) {
    return this.array[a * this.itemSize + 1];
  }, setY:function(a, b) {
    this.array[a * this.itemSize + 1] = b;
    return this;
  }, getZ:function(a) {
    return this.array[a * this.itemSize + 2];
  }, setZ:function(a, b) {
    this.array[a * this.itemSize + 2] = b;
    return this;
  }, getW:function(a) {
    return this.array[a * this.itemSize + 3];
  }, setW:function(a, b) {
    this.array[a * this.itemSize + 3] = b;
    return this;
  }, setXY:function(a, b, d) {
    a *= this.itemSize;
    this.array[a + 0] = b;
    this.array[a + 1] = d;
    return this;
  }, setXYZ:function(a, b, d, c) {
    a *= this.itemSize;
    this.array[a + 0] = b;
    this.array[a + 1] = d;
    this.array[a + 2] = c;
    return this;
  }, setXYZW:function(a, b, d, c, f) {
    a *= this.itemSize;
    this.array[a + 0] = b;
    this.array[a + 1] = d;
    this.array[a + 2] = c;
    this.array[a + 3] = f;
    return this;
  }, onUpload:function(a) {
    this.onUploadCallback = a;
    return this;
  }, clone:function() {
    return (new this.constructor(this.array, this.itemSize)).copy(this);
  }});
  I.prototype = Object.create(K.prototype);
  I.prototype.constructor = I;
  L.prototype = Object.create(K.prototype);
  L.prototype.constructor = L;
  R.prototype = Object.create(K.prototype);
  R.prototype.constructor = R;
  J.prototype = Object.create(K.prototype);
  J.prototype.constructor = J;
  Q.prototype = Object.create(K.prototype);
  Q.prototype.constructor = Q;
  aa.prototype = Object.create(K.prototype);
  aa.prototype.constructor = aa;
  U.prototype = Object.create(K.prototype);
  U.prototype.constructor = U;
  N.prototype = Object.create(K.prototype);
  N.prototype.constructor = N;
  S.prototype = Object.create(K.prototype);
  S.prototype.constructor = S;
  Object.assign(V.prototype, {computeGroups:function(a) {
    var h = [], b = void 0;
    a = a.faces;
    for (var d = 0; d < a.length; d++) {
      var c = a[d];
      if (c.materialIndex !== b) {
        b = c.materialIndex;
        void 0 !== f && (f.count = 3 * d - f.start, h.push(f));
        var f = {start:3 * d, materialIndex:b};
      }
    }
    void 0 !== f && (f.count = 3 * d - f.start, h.push(f));
    this.groups = h;
  }, fromGeometry:function(a) {
    var h = a.faces, b = a.vertices, d = a.faceVertexUvs, c = d[0] && 0 < d[0].length, f = d[1] && 0 < d[1].length, e = a.morphTargets, l = e.length;
    if (0 < l) {
      for (var k = [], q = 0; q < l; q++) {
        k[q] = {name:e[q].name, data:[]};
      }
      this.morphTargets.position = k;
    }
    var m = a.morphNormals, n = m.length;
    if (0 < n) {
      var t = [];
      for (q = 0; q < n; q++) {
        t[q] = {name:m[q].name, data:[]};
      }
      this.morphTargets.normal = t;
    }
    var u = a.skinIndices, p = a.skinWeights, v = u.length === b.length, w = p.length === b.length;
    0 < b.length && 0 === h.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    for (q = 0; q < h.length; q++) {
      var z = h[q];
      this.vertices.push(b[z.a], b[z.b], b[z.c]);
      var y = z.vertexNormals;
      3 === y.length ? this.normals.push(y[0], y[1], y[2]) : (y = z.normal, this.normals.push(y, y, y));
      y = z.vertexColors;
      3 === y.length ? this.colors.push(y[0], y[1], y[2]) : (y = z.color, this.colors.push(y, y, y));
      !0 === c && (y = d[0][q], void 0 !== y ? this.uvs.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", q), this.uvs.push(new g, new g, new g)));
      !0 === f && (y = d[1][q], void 0 !== y ? this.uvs2.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", q), this.uvs2.push(new g, new g, new g)));
      for (y = 0; y < l; y++) {
        var x = e[y].vertices;
        k[y].data.push(x[z.a], x[z.b], x[z.c]);
      }
      for (y = 0; y < n; y++) {
        x = m[y].vertexNormals[q], t[y].data.push(x.a, x.b, x.c);
      }
      v && this.skinIndices.push(u[z.a], u[z.b], u[z.c]);
      w && this.skinWeights.push(p[z.a], p[z.b], p[z.c]);
    }
    this.computeGroups(a);
    this.verticesNeedUpdate = a.verticesNeedUpdate;
    this.normalsNeedUpdate = a.normalsNeedUpdate;
    this.colorsNeedUpdate = a.colorsNeedUpdate;
    this.uvsNeedUpdate = a.uvsNeedUpdate;
    this.groupsNeedUpdate = a.groupsNeedUpdate;
    return this;
  }});
  var $f = 1;
  O.prototype = Object.assign(Object.create(c.prototype), {constructor:O, isBufferGeometry:!0, getIndex:function() {
    return this.index;
  }, setIndex:function(a) {
    Array.isArray(a) ? this.index = new (65535 < M(a) ? U : Q)(a, 1) : this.index = a;
  }, addAttribute:function(a, b, d) {
    if (!(b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute)) {
      return console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(a, new K(b, d));
    }
    if ("index" === a) {
      return console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b), this;
    }
    this.attributes[a] = b;
    return this;
  }, getAttribute:function(a) {
    return this.attributes[a];
  }, removeAttribute:function(a) {
    delete this.attributes[a];
    return this;
  }, addGroup:function(a, b, d) {
    this.groups.push({start:a, count:b, materialIndex:void 0 !== d ? d : 0});
  }, clearGroups:function() {
    this.groups = [];
  }, setDrawRange:function(a, b) {
    this.drawRange.start = a;
    this.drawRange.count = b;
  }, applyMatrix:function(a) {
    var h = this.attributes.position;
    void 0 !== h && (a.applyToBufferAttribute(h), h.needsUpdate = !0);
    var b = this.attributes.normal;
    void 0 !== b && (h = (new k).getNormalMatrix(a), h.applyToBufferAttribute(b), b.needsUpdate = !0);
    b = this.attributes.tangent;
    void 0 !== b && (h = (new k).getNormalMatrix(a), h.applyToBufferAttribute(b), b.needsUpdate = !0);
    null !== this.boundingBox && this.computeBoundingBox();
    null !== this.boundingSphere && this.computeBoundingSphere();
    return this;
  }, rotateX:function() {
    var a = new b;
    return function(h) {
      a.makeRotationX(h);
      this.applyMatrix(a);
      return this;
    };
  }(), rotateY:function() {
    var a = new b;
    return function(h) {
      a.makeRotationY(h);
      this.applyMatrix(a);
      return this;
    };
  }(), rotateZ:function() {
    var a = new b;
    return function(h) {
      a.makeRotationZ(h);
      this.applyMatrix(a);
      return this;
    };
  }(), translate:function() {
    var a = new b;
    return function(h, b, d) {
      a.makeTranslation(h, b, d);
      this.applyMatrix(a);
      return this;
    };
  }(), scale:function() {
    var a = new b;
    return function(h, b, d) {
      a.makeScale(h, b, d);
      this.applyMatrix(a);
      return this;
    };
  }(), lookAt:function() {
    var a = new G;
    return function(h) {
      a.lookAt(h);
      a.updateMatrix();
      this.applyMatrix(a.matrix);
    };
  }(), center:function() {
    var a = new f;
    return function() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(a).negate();
      this.translate(a.x, a.y, a.z);
      return this;
    };
  }(), setFromObject:function(a) {
    var h = a.geometry;
    if (a.isPoints || a.isLine) {
      a = new N(3 * h.vertices.length, 3);
      var b = new N(3 * h.colors.length, 3);
      this.addAttribute("position", a.copyVector3sArray(h.vertices));
      this.addAttribute("color", b.copyColorsArray(h.colors));
      h.lineDistances && h.lineDistances.length === h.vertices.length && (a = new N(h.lineDistances.length, 1), this.addAttribute("lineDistance", a.copyArray(h.lineDistances)));
      null !== h.boundingSphere && (this.boundingSphere = h.boundingSphere.clone());
      null !== h.boundingBox && (this.boundingBox = h.boundingBox.clone());
    } else {
      a.isMesh && h && h.isGeometry && this.fromGeometry(h);
    }
    return this;
  }, setFromPoints:function(a) {
    for (var h = [], b = 0, d = a.length; b < d; b++) {
      var c = a[b];
      h.push(c.x, c.y, c.z || 0);
    }
    this.addAttribute("position", new N(h, 3));
    return this;
  }, updateFromObject:function(a) {
    var h = a.geometry;
    if (a.isMesh) {
      var b = h.__directGeometry;
      !0 === h.elementsNeedUpdate && (b = void 0, h.elementsNeedUpdate = !1);
      if (void 0 === b) {
        return this.fromGeometry(h);
      }
      b.verticesNeedUpdate = h.verticesNeedUpdate;
      b.normalsNeedUpdate = h.normalsNeedUpdate;
      b.colorsNeedUpdate = h.colorsNeedUpdate;
      b.uvsNeedUpdate = h.uvsNeedUpdate;
      b.groupsNeedUpdate = h.groupsNeedUpdate;
      h.verticesNeedUpdate = !1;
      h.normalsNeedUpdate = !1;
      h.colorsNeedUpdate = !1;
      h.uvsNeedUpdate = !1;
      h.groupsNeedUpdate = !1;
      h = b;
    }
    !0 === h.verticesNeedUpdate && (b = this.attributes.position, void 0 !== b && (b.copyVector3sArray(h.vertices), b.needsUpdate = !0), h.verticesNeedUpdate = !1);
    !0 === h.normalsNeedUpdate && (b = this.attributes.normal, void 0 !== b && (b.copyVector3sArray(h.normals), b.needsUpdate = !0), h.normalsNeedUpdate = !1);
    !0 === h.colorsNeedUpdate && (b = this.attributes.color, void 0 !== b && (b.copyColorsArray(h.colors), b.needsUpdate = !0), h.colorsNeedUpdate = !1);
    h.uvsNeedUpdate && (b = this.attributes.uv, void 0 !== b && (b.copyVector2sArray(h.uvs), b.needsUpdate = !0), h.uvsNeedUpdate = !1);
    h.lineDistancesNeedUpdate && (b = this.attributes.lineDistance, void 0 !== b && (b.copyArray(h.lineDistances), b.needsUpdate = !0), h.lineDistancesNeedUpdate = !1);
    h.groupsNeedUpdate && (h.computeGroups(a.geometry), this.groups = h.groups, h.groupsNeedUpdate = !1);
    return this;
  }, fromGeometry:function(a) {
    a.__directGeometry = (new V).fromGeometry(a);
    return this.fromDirectGeometry(a.__directGeometry);
  }, fromDirectGeometry:function(a) {
    var h = new Float32Array(3 * a.vertices.length);
    this.addAttribute("position", (new K(h, 3)).copyVector3sArray(a.vertices));
    0 < a.normals.length && (h = new Float32Array(3 * a.normals.length), this.addAttribute("normal", (new K(h, 3)).copyVector3sArray(a.normals)));
    0 < a.colors.length && (h = new Float32Array(3 * a.colors.length), this.addAttribute("color", (new K(h, 3)).copyColorsArray(a.colors)));
    0 < a.uvs.length && (h = new Float32Array(2 * a.uvs.length), this.addAttribute("uv", (new K(h, 2)).copyVector2sArray(a.uvs)));
    0 < a.uvs2.length && (h = new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", (new K(h, 2)).copyVector2sArray(a.uvs2)));
    this.groups = a.groups;
    for (var b in a.morphTargets) {
      h = [];
      for (var d = a.morphTargets[b], c = 0, f = d.length; c < f; c++) {
        var e = d[c], l = new N(3 * e.data.length, 3);
        l.name = e.name;
        h.push(l.copyVector3sArray(e.data));
      }
      this.morphAttributes[b] = h;
    }
    0 < a.skinIndices.length && (b = new N(4 * a.skinIndices.length, 4), this.addAttribute("skinIndex", b.copyVector4sArray(a.skinIndices)));
    0 < a.skinWeights.length && (b = new N(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", b.copyVector4sArray(a.skinWeights)));
    null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
    null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
    return this;
  }, computeBoundingBox:function() {
    null === this.boundingBox && (this.boundingBox = new u);
    var a = this.attributes.position;
    void 0 !== a ? this.boundingBox.setFromBufferAttribute(a) : this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }, computeBoundingSphere:function() {
    var a = new u, b = new f;
    return function() {
      null === this.boundingSphere && (this.boundingSphere = new w);
      var h = this.attributes.position;
      if (h) {
        var d = this.boundingSphere.center;
        a.setFromBufferAttribute(h);
        a.getCenter(d);
        for (var c = 0, f = 0, e = h.count; f < e; f++) {
          b.x = h.getX(f), b.y = h.getY(f), b.z = h.getZ(f), c = Math.max(c, d.distanceToSquared(b));
        }
        this.boundingSphere.radius = Math.sqrt(c);
        isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    };
  }(), computeFaceNormals:function() {
  }, computeVertexNormals:function() {
    var a = this.index, b = this.attributes;
    if (b.position) {
      var d = b.position.array;
      if (void 0 === b.normal) {
        this.addAttribute("normal", new K(new Float32Array(d.length), 3));
      } else {
        for (var c = b.normal.array, e = 0, l = c.length; e < l; e++) {
          c[e] = 0;
        }
      }
      c = b.normal.array;
      var k = new f, g = new f, q = new f, m = new f, n = new f;
      if (a) {
        var t = a.array;
        e = 0;
        for (l = a.count; e < l; e += 3) {
          a = 3 * t[e + 0];
          var u = 3 * t[e + 1], p = 3 * t[e + 2];
          k.fromArray(d, a);
          g.fromArray(d, u);
          q.fromArray(d, p);
          m.subVectors(q, g);
          n.subVectors(k, g);
          m.cross(n);
          c[a] += m.x;
          c[a + 1] += m.y;
          c[a + 2] += m.z;
          c[u] += m.x;
          c[u + 1] += m.y;
          c[u + 2] += m.z;
          c[p] += m.x;
          c[p + 1] += m.y;
          c[p + 2] += m.z;
        }
      } else {
        for (e = 0, l = d.length; e < l; e += 9) {
          k.fromArray(d, e), g.fromArray(d, e + 3), q.fromArray(d, e + 6), m.subVectors(q, g), n.subVectors(k, g), m.cross(n), c[e] = m.x, c[e + 1] = m.y, c[e + 2] = m.z, c[e + 3] = m.x, c[e + 4] = m.y, c[e + 5] = m.z, c[e + 6] = m.x, c[e + 7] = m.y, c[e + 8] = m.z;
        }
      }
      this.normalizeNormals();
      b.normal.needsUpdate = !0;
    }
  }, merge:function(a, b) {
    if (a && a.isBufferGeometry) {
      void 0 === b && (b = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
      var h = this.attributes, d;
      for (d in h) {
        if (void 0 !== a.attributes[d]) {
          var c = h[d].array, f = a.attributes[d], e = f.array, l = 0;
          for (f = f.itemSize * b; l < e.length; l++, f++) {
            c[f] = e[l];
          }
        }
      }
      return this;
    }
    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a);
  }, normalizeNormals:function() {
    var a = new f;
    return function() {
      for (var h = this.attributes.normal, b = 0, d = h.count; b < d; b++) {
        a.x = h.getX(b), a.y = h.getY(b), a.z = h.getZ(b), a.normalize(), h.setXYZ(b, a.x, a.y, a.z);
      }
    };
  }(), toNonIndexed:function() {
    function a(a, h) {
      var b = a.array;
      a = a.itemSize;
      for (var d = new b.constructor(h.length * a), c, f = 0, e = 0, l = h.length; e < l; e++) {
        c = h[e] * a;
        for (var k = 0; k < a; k++) {
          d[f++] = b[c++];
        }
      }
      return new K(d, a);
    }
    if (null === this.index) {
      return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
    }
    var b = new O, d = this.index.array, c = this.attributes, f;
    for (f in c) {
      var e = c[f];
      e = a(e, d);
      b.addAttribute(f, e);
    }
    var l = this.morphAttributes;
    for (f in l) {
      var k = [], g = l[f];
      c = 0;
      for (var q = g.length; c < q; c++) {
        e = g[c], e = a(e, d), k.push(e);
      }
      b.morphAttributes[f] = k;
    }
    d = this.groups;
    c = 0;
    for (f = d.length; c < f; c++) {
      e = d[c], b.addGroup(e.start, e.count, e.materialIndex);
    }
    return b;
  }, toJSON:function() {
    var a = {metadata:{version:4.5, type:"BufferGeometry", generator:"BufferGeometry.toJSON"}};
    a.uuid = this.uuid;
    a.type = this.type;
    "" !== this.name && (a.name = this.name);
    0 < Object.keys(this.userData).length && (a.userData = this.userData);
    if (void 0 !== this.parameters) {
      var b = this.parameters;
      for (q in b) {
        void 0 !== b[q] && (a[q] = b[q]);
      }
      return a;
    }
    a.data = {attributes:{}};
    b = this.index;
    null !== b && (a.data.index = {type:b.array.constructor.name, array:Array.prototype.slice.call(b.array)});
    var d = this.attributes;
    for (q in d) {
      b = d[q];
      var c = {itemSize:b.itemSize, type:b.array.constructor.name, array:Array.prototype.slice.call(b.array), normalized:b.normalized};
      "" !== b.name && (c.name = b.name);
      a.data.attributes[q] = c;
    }
    d = {};
    var f = !1;
    for (q in this.morphAttributes) {
      for (var e = this.morphAttributes[q], l = [], k = 0, g = e.length; k < g; k++) {
        b = e[k], c = {itemSize:b.itemSize, type:b.array.constructor.name, array:Array.prototype.slice.call(b.array), normalized:b.normalized}, "" !== b.name && (c.name = b.name), l.push(c);
      }
      0 < l.length && (d[q] = l, f = !0);
    }
    f && (a.data.morphAttributes = d);
    var q = this.groups;
    0 < q.length && (a.data.groups = JSON.parse(JSON.stringify(q)));
    q = this.boundingSphere;
    null !== q && (a.data.boundingSphere = {center:q.center.toArray(), radius:q.radius});
    return a;
  }, clone:function() {
    return (new O).copy(this);
  }, copy:function(a) {
    var h;
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingSphere = this.boundingBox = null;
    this.name = a.name;
    var b = a.index;
    null !== b && this.setIndex(b.clone());
    b = a.attributes;
    for (e in b) {
      this.addAttribute(e, b[e].clone());
    }
    var d = a.morphAttributes;
    for (e in d) {
      var c = [], f = d[e];
      b = 0;
      for (h = f.length; b < h; b++) {
        c.push(f[b].clone());
      }
      this.morphAttributes[e] = c;
    }
    var e = a.groups;
    b = 0;
    for (h = e.length; b < h; b++) {
      d = e[b], this.addGroup(d.start, d.count, d.materialIndex);
    }
    e = a.boundingBox;
    null !== e && (this.boundingBox = e.clone());
    e = a.boundingSphere;
    null !== e && (this.boundingSphere = e.clone());
    this.drawRange.start = a.drawRange.start;
    this.drawRange.count = a.drawRange.count;
    this.userData = a.userData;
    return this;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }});
  P.prototype = Object.create(H.prototype);
  P.prototype.constructor = P;
  ka.prototype = Object.create(O.prototype);
  ka.prototype.constructor = ka;
  ha.prototype = Object.create(H.prototype);
  ha.prototype.constructor = ha;
  ja.prototype = Object.create(O.prototype);
  ja.prototype.constructor = ja;
  var bg = 0;
  X.prototype = Object.assign(Object.create(c.prototype), {constructor:X, isMaterial:!0, onBeforeCompile:function() {
  }, setValues:function(a) {
    if (void 0 !== a) {
      for (var h in a) {
        var b = a[h];
        if (void 0 === b) {
          console.warn("THREE.Material: '" + h + "' parameter is undefined.");
        } else {
          if ("shading" === h) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === b ? !0 : !1;
          } else {
            var d = this[h];
            void 0 === d ? console.warn("THREE." + this.type + ": '" + h + "' is not a property of this material.") : d && d.isColor ? d.set(b) : d && d.isVector3 && b && b.isVector3 ? d.copy(b) : this[h] = b;
          }
        }
      }
    }
  }, toJSON:function(a) {
    function h(a) {
      var h = [], b;
      for (b in a) {
        var d = a[b];
        delete d.metadata;
        h.push(d);
      }
      return h;
    }
    var b = void 0 === a || "string" === typeof a;
    b && (a = {textures:{}, images:{}});
    var d = {metadata:{version:4.5, type:"Material", generator:"Material.toJSON"}};
    d.uuid = this.uuid;
    d.type = this.type;
    "" !== this.name && (d.name = this.name);
    this.color && this.color.isColor && (d.color = this.color.getHex());
    void 0 !== this.roughness && (d.roughness = this.roughness);
    void 0 !== this.metalness && (d.metalness = this.metalness);
    this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex());
    1 !== this.emissiveIntensity && (d.emissiveIntensity = this.emissiveIntensity);
    this.specular && this.specular.isColor && (d.specular = this.specular.getHex());
    void 0 !== this.shininess && (d.shininess = this.shininess);
    void 0 !== this.clearCoat && (d.clearCoat = this.clearCoat);
    void 0 !== this.clearCoatRoughness && (d.clearCoatRoughness = this.clearCoatRoughness);
    this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid);
    this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid);
    this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid);
    this.aoMap && this.aoMap.isTexture && (d.aoMap = this.aoMap.toJSON(a).uuid, d.aoMapIntensity = this.aoMapIntensity);
    this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale);
    this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalMapType = this.normalMapType, d.normalScale = this.normalScale.toArray());
    this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias);
    this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid);
    this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid);
    this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid);
    this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid);
    this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity, void 0 !== this.combine && (d.combine = this.combine), void 0 !== this.envMapIntensity && (d.envMapIntensity = this.envMapIntensity));
    this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid);
    void 0 !== this.size && (d.size = this.size);
    void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation);
    1 !== this.blending && (d.blending = this.blending);
    !0 === this.flatShading && (d.flatShading = this.flatShading);
    0 !== this.side && (d.side = this.side);
    0 !== this.vertexColors && (d.vertexColors = this.vertexColors);
    1 > this.opacity && (d.opacity = this.opacity);
    !0 === this.transparent && (d.transparent = this.transparent);
    d.depthFunc = this.depthFunc;
    d.depthTest = this.depthTest;
    d.depthWrite = this.depthWrite;
    0 !== this.rotation && (d.rotation = this.rotation);
    !0 === this.polygonOffset && (d.polygonOffset = !0);
    0 !== this.polygonOffsetFactor && (d.polygonOffsetFactor = this.polygonOffsetFactor);
    0 !== this.polygonOffsetUnits && (d.polygonOffsetUnits = this.polygonOffsetUnits);
    1 !== this.linewidth && (d.linewidth = this.linewidth);
    void 0 !== this.dashSize && (d.dashSize = this.dashSize);
    void 0 !== this.gapSize && (d.gapSize = this.gapSize);
    void 0 !== this.scale && (d.scale = this.scale);
    !0 === this.dithering && (d.dithering = !0);
    0 < this.alphaTest && (d.alphaTest = this.alphaTest);
    !0 === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha);
    !0 === this.wireframe && (d.wireframe = this.wireframe);
    1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth);
    "round" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap);
    "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin);
    !0 === this.morphTargets && (d.morphTargets = !0);
    !0 === this.skinning && (d.skinning = !0);
    !1 === this.visible && (d.visible = !1);
    "{}" !== JSON.stringify(this.userData) && (d.userData = this.userData);
    b && (b = h(a.textures), a = h(a.images), 0 < b.length && (d.textures = b), 0 < a.length && (d.images = a));
    return d;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.name = a.name;
    this.fog = a.fog;
    this.lights = a.lights;
    this.blending = a.blending;
    this.side = a.side;
    this.flatShading = a.flatShading;
    this.vertexColors = a.vertexColors;
    this.opacity = a.opacity;
    this.transparent = a.transparent;
    this.blendSrc = a.blendSrc;
    this.blendDst = a.blendDst;
    this.blendEquation = a.blendEquation;
    this.blendSrcAlpha = a.blendSrcAlpha;
    this.blendDstAlpha = a.blendDstAlpha;
    this.blendEquationAlpha = a.blendEquationAlpha;
    this.depthFunc = a.depthFunc;
    this.depthTest = a.depthTest;
    this.depthWrite = a.depthWrite;
    this.colorWrite = a.colorWrite;
    this.precision = a.precision;
    this.polygonOffset = a.polygonOffset;
    this.polygonOffsetFactor = a.polygonOffsetFactor;
    this.polygonOffsetUnits = a.polygonOffsetUnits;
    this.dithering = a.dithering;
    this.alphaTest = a.alphaTest;
    this.premultipliedAlpha = a.premultipliedAlpha;
    this.visible = a.visible;
    this.userData = JSON.parse(JSON.stringify(a.userData));
    this.clipShadows = a.clipShadows;
    this.clipIntersection = a.clipIntersection;
    var h = a.clippingPlanes, b = null;
    if (null !== h) {
      var d = h.length;
      b = Array(d);
      for (var c = 0; c !== d; ++c) {
        b[c] = h[c].clone();
      }
    }
    this.clippingPlanes = b;
    this.shadowSide = a.shadowSide;
    return this;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }});
  fa.prototype = Object.create(X.prototype);
  fa.prototype.constructor = fa;
  fa.prototype.isShaderMaterial = !0;
  fa.prototype.copy = function(a) {
    X.prototype.copy.call(this, a);
    this.fragmentShader = a.fragmentShader;
    this.vertexShader = a.vertexShader;
    this.uniforms = q(a.uniforms);
    this.defines = Object.assign({}, a.defines);
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.lights = a.lights;
    this.clipping = a.clipping;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    this.extensions = a.extensions;
    return this;
  };
  fa.prototype.toJSON = function(a) {
    var h = X.prototype.toJSON.call(this, a);
    h.uniforms = {};
    for (var b in this.uniforms) {
      var d = this.uniforms[b].value;
      h.uniforms[b] = d && d.isTexture ? {type:"t", value:d.toJSON(a).uuid} : d && d.isColor ? {type:"c", value:d.getHex()} : d && d.isVector2 ? {type:"v2", value:d.toArray()} : d && d.isVector3 ? {type:"v3", value:d.toArray()} : d && d.isVector4 ? {type:"v4", value:d.toArray()} : d && d.isMatrix3 ? {type:"m3", value:d.toArray()} : d && d.isMatrix4 ? {type:"m4", value:d.toArray()} : {value:d};
    }
    0 < Object.keys(this.defines).length && (h.defines = this.defines);
    h.vertexShader = this.vertexShader;
    h.fragmentShader = this.fragmentShader;
    a = {};
    for (var c in this.extensions) {
      !0 === this.extensions[c] && (a[c] = !0);
    }
    0 < Object.keys(a).length && (h.extensions = a);
    return h;
  };
  Object.assign(ba.prototype, {set:function(a, b) {
    this.origin.copy(a);
    this.direction.copy(b);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.origin.copy(a.origin);
    this.direction.copy(a.direction);
    return this;
  }, at:function(a, b) {
    void 0 === b && (console.warn("THREE.Ray: .at() target is now required"), b = new f);
    return b.copy(this.direction).multiplyScalar(a).add(this.origin);
  }, lookAt:function(a) {
    this.direction.copy(a).sub(this.origin).normalize();
    return this;
  }, recast:function() {
    var a = new f;
    return function(h) {
      this.origin.copy(this.at(h, a));
      return this;
    };
  }(), closestPointToPoint:function(a, b) {
    void 0 === b && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), b = new f);
    b.subVectors(a, this.origin);
    a = b.dot(this.direction);
    return 0 > a ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin);
  }, distanceToPoint:function(a) {
    return Math.sqrt(this.distanceSqToPoint(a));
  }, distanceSqToPoint:function() {
    var a = new f;
    return function(h) {
      var b = a.subVectors(h, this.origin).dot(this.direction);
      if (0 > b) {
        return this.origin.distanceToSquared(h);
      }
      a.copy(this.direction).multiplyScalar(b).add(this.origin);
      return a.distanceToSquared(h);
    };
  }(), distanceSqToSegment:function() {
    var a = new f, b = new f, d = new f;
    return function(h, c, f, e) {
      a.copy(h).add(c).multiplyScalar(.5);
      b.copy(c).sub(h).normalize();
      d.copy(this.origin).sub(a);
      var l = .5 * h.distanceTo(c), k = -this.direction.dot(b), g = d.dot(this.direction), q = -d.dot(b), r = d.lengthSq(), m = Math.abs(1 - k * k);
      if (0 < m) {
        h = k * q - g;
        c = k * g - q;
        var n = l * m;
        0 <= h ? c >= -n ? c <= n ? (l = 1 / m, h *= l, c *= l, k = h * (h + k * c + 2 * g) + c * (k * h + c + 2 * q) + r) : (c = l, h = Math.max(0, -(k * c + g)), k = -h * h + c * (c + 2 * q) + r) : (c = -l, h = Math.max(0, -(k * c + g)), k = -h * h + c * (c + 2 * q) + r) : c <= -n ? (h = Math.max(0, -(-k * l + g)), c = 0 < h ? -l : Math.min(Math.max(-l, -q), l), k = -h * h + c * (c + 2 * q) + r) : c <= n ? (h = 0, c = Math.min(Math.max(-l, -q), l), k = c * (c + 2 * q) + r) : (h = Math.max(0, -(k * 
        l + g)), c = 0 < h ? l : Math.min(Math.max(-l, -q), l), k = -h * h + c * (c + 2 * q) + r);
      } else {
        c = 0 < k ? -l : l, h = Math.max(0, -(k * c + g)), k = -h * h + c * (c + 2 * q) + r;
      }
      f && f.copy(this.direction).multiplyScalar(h).add(this.origin);
      e && e.copy(b).multiplyScalar(c).add(a);
      return k;
    };
  }(), intersectSphere:function() {
    var a = new f;
    return function(h, b) {
      a.subVectors(h.center, this.origin);
      var d = a.dot(this.direction), c = a.dot(a) - d * d;
      h = h.radius * h.radius;
      if (c > h) {
        return null;
      }
      h = Math.sqrt(h - c);
      c = d - h;
      d += h;
      return 0 > c && 0 > d ? null : 0 > c ? this.at(d, b) : this.at(c, b);
    };
  }(), intersectsSphere:function(a) {
    return this.distanceSqToPoint(a.center) <= a.radius * a.radius;
  }, distanceToPlane:function(a) {
    var h = a.normal.dot(this.direction);
    if (0 === h) {
      return 0 === a.distanceToPoint(this.origin) ? 0 : null;
    }
    a = -(this.origin.dot(a.normal) + a.constant) / h;
    return 0 <= a ? a : null;
  }, intersectPlane:function(a, b) {
    a = this.distanceToPlane(a);
    return null === a ? null : this.at(a, b);
  }, intersectsPlane:function(a) {
    var h = a.distanceToPoint(this.origin);
    return 0 === h || 0 > a.normal.dot(this.direction) * h ? !0 : !1;
  }, intersectBox:function(a, b) {
    var h = 1 / this.direction.x, d = 1 / this.direction.y, c = 1 / this.direction.z, f = this.origin;
    if (0 <= h) {
      var e = (a.min.x - f.x) * h;
      h *= a.max.x - f.x;
    } else {
      e = (a.max.x - f.x) * h, h *= a.min.x - f.x;
    }
    if (0 <= d) {
      var l = (a.min.y - f.y) * d;
      d *= a.max.y - f.y;
    } else {
      l = (a.max.y - f.y) * d, d *= a.min.y - f.y;
    }
    if (e > d || l > h) {
      return null;
    }
    if (l > e || e !== e) {
      e = l;
    }
    if (d < h || h !== h) {
      h = d;
    }
    0 <= c ? (l = (a.min.z - f.z) * c, a = (a.max.z - f.z) * c) : (l = (a.max.z - f.z) * c, a = (a.min.z - f.z) * c);
    if (e > a || l > h) {
      return null;
    }
    if (l > e || e !== e) {
      e = l;
    }
    if (a < h || h !== h) {
      h = a;
    }
    return 0 > h ? null : this.at(0 <= e ? e : h, b);
  }, intersectsBox:function() {
    var a = new f;
    return function(h) {
      return null !== this.intersectBox(h, a);
    };
  }(), intersectTriangle:function() {
    var a = new f, b = new f, d = new f, c = new f;
    return function(h, f, e, l, k) {
      b.subVectors(f, h);
      d.subVectors(e, h);
      c.crossVectors(b, d);
      f = this.direction.dot(c);
      if (0 < f) {
        if (l) {
          return null;
        }
        l = 1;
      } else {
        if (0 > f) {
          l = -1, f = -f;
        } else {
          return null;
        }
      }
      a.subVectors(this.origin, h);
      h = l * this.direction.dot(d.crossVectors(a, d));
      if (0 > h) {
        return null;
      }
      e = l * this.direction.dot(b.cross(a));
      if (0 > e || h + e > f) {
        return null;
      }
      h = -l * a.dot(c);
      return 0 > h ? null : this.at(h / f, k);
    };
  }(), applyMatrix4:function(a) {
    this.origin.applyMatrix4(a);
    this.direction.transformDirection(a);
    return this;
  }, equals:function(a) {
    return a.origin.equals(this.origin) && a.direction.equals(this.direction);
  }});
  Object.assign(la, {getNormal:function() {
    var a = new f;
    return function(h, b, d, c) {
      void 0 === c && (console.warn("THREE.Triangle: .getNormal() target is now required"), c = new f);
      c.subVectors(d, b);
      a.subVectors(h, b);
      c.cross(a);
      h = c.lengthSq();
      return 0 < h ? c.multiplyScalar(1 / Math.sqrt(h)) : c.set(0, 0, 0);
    };
  }(), getBarycoord:function() {
    var a = new f, b = new f, d = new f;
    return function(h, c, e, l, k) {
      a.subVectors(l, c);
      b.subVectors(e, c);
      d.subVectors(h, c);
      h = a.dot(a);
      c = a.dot(b);
      e = a.dot(d);
      var g = b.dot(b);
      l = b.dot(d);
      var q = h * g - c * c;
      void 0 === k && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), k = new f);
      if (0 === q) {
        return k.set(-2, -1, -1);
      }
      q = 1 / q;
      g = (g * e - c * l) * q;
      h = (h * l - c * e) * q;
      return k.set(1 - g - h, h, g);
    };
  }(), containsPoint:function() {
    var a = new f;
    return function(h, b, d, c) {
      la.getBarycoord(h, b, d, c, a);
      return 0 <= a.x && 0 <= a.y && 1 >= a.x + a.y;
    };
  }(), getUV:function() {
    var a = new f;
    return function(h, b, d, c, f, e, l, k) {
      this.getBarycoord(h, b, d, c, a);
      k.set(0, 0);
      k.addScaledVector(f, a.x);
      k.addScaledVector(e, a.y);
      k.addScaledVector(l, a.z);
      return k;
    };
  }()});
  Object.assign(la.prototype, {set:function(a, b, d) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(d);
    return this;
  }, setFromPointsAndIndices:function(a, b, d, c) {
    this.a.copy(a[b]);
    this.b.copy(a[d]);
    this.c.copy(a[c]);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.a.copy(a.a);
    this.b.copy(a.b);
    this.c.copy(a.c);
    return this;
  }, getArea:function() {
    var a = new f, b = new f;
    return function() {
      a.subVectors(this.c, this.b);
      b.subVectors(this.a, this.b);
      return .5 * a.cross(b).length();
    };
  }(), getMidpoint:function(a) {
    void 0 === a && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), a = new f);
    return a.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }, getNormal:function(a) {
    return la.getNormal(this.a, this.b, this.c, a);
  }, getPlane:function(a) {
    void 0 === a && (console.warn("THREE.Triangle: .getPlane() target is now required"), a = new f);
    return a.setFromCoplanarPoints(this.a, this.b, this.c);
  }, getBarycoord:function(a, b) {
    return la.getBarycoord(a, this.a, this.b, this.c, b);
  }, containsPoint:function(a) {
    return la.containsPoint(a, this.a, this.b, this.c);
  }, getUV:function(a, b, d, c, f) {
    return la.getUV(a, this.a, this.b, this.c, b, d, c, f);
  }, intersectsBox:function(a) {
    return a.intersectsTriangle(this);
  }, closestPointToPoint:function() {
    var a = new f, b = new f, d = new f, c = new f, e = new f, l = new f;
    return function(h, k) {
      void 0 === k && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), k = new f);
      var g = this.a, q = this.b, m = this.c;
      a.subVectors(q, g);
      b.subVectors(m, g);
      c.subVectors(h, g);
      var r = a.dot(c), n = b.dot(c);
      if (0 >= r && 0 >= n) {
        return k.copy(g);
      }
      e.subVectors(h, q);
      var t = a.dot(e), u = b.dot(e);
      if (0 <= t && u <= t) {
        return k.copy(q);
      }
      var p = r * u - t * n;
      if (0 >= p && 0 <= r && 0 >= t) {
        return q = r / (r - t), k.copy(g).addScaledVector(a, q);
      }
      l.subVectors(h, m);
      h = a.dot(l);
      var v = b.dot(l);
      if (0 <= v && h <= v) {
        return k.copy(m);
      }
      r = h * n - r * v;
      if (0 >= r && 0 <= n && 0 >= v) {
        return p = n / (n - v), k.copy(g).addScaledVector(b, p);
      }
      n = t * v - h * u;
      if (0 >= n && 0 <= u - t && 0 <= h - v) {
        return d.subVectors(m, q), p = (u - t) / (u - t + (h - v)), k.copy(q).addScaledVector(d, p);
      }
      m = 1 / (n + r + p);
      q = r * m;
      p *= m;
      return k.copy(g).addScaledVector(a, q).addScaledVector(b, p);
    };
  }(), equals:function(a) {
    return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);
  }});
  ma.prototype = Object.create(X.prototype);
  ma.prototype.constructor = ma;
  ma.prototype.isMeshBasicMaterial = !0;
  ma.prototype.copy = function(a) {
    X.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    return this;
  };
  ca.prototype = Object.assign(Object.create(G.prototype), {constructor:ca, isMesh:!0, setDrawMode:function(a) {
    this.drawMode = a;
  }, copy:function(a) {
    G.prototype.copy.call(this, a);
    this.drawMode = a.drawMode;
    void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice());
    void 0 !== a.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, a.morphTargetDictionary));
    return this;
  }, updateMorphTargets:function() {
    var a = this.geometry;
    if (a.isBufferGeometry) {
      a = a.morphAttributes;
      var b = Object.keys(a);
      if (0 < b.length) {
        var d = a[b[0]];
        if (void 0 !== d) {
          for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = d.length; a < b; a++) {
            var c = d[a].name || String(a);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[c] = a;
          }
        }
      }
    } else {
      a = a.morphTargets, void 0 !== a && 0 < a.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }, raycast:function() {
    function a(a, h, b, d, c, f, e, l) {
      if (null === (1 === h.side ? d.intersectTriangle(e, f, c, !0, l) : d.intersectTriangle(c, f, e, 2 !== h.side, l))) {
        return null;
      }
      x.copy(l);
      x.applyMatrix4(a.matrixWorld);
      h = b.ray.origin.distanceTo(x);
      return h < b.near || h > b.far ? null : {distance:h, point:x.clone(), object:a};
    }
    function d(h, b, d, c, f, e, l, r, n) {
      k.fromBufferAttribute(f, l);
      q.fromBufferAttribute(f, r);
      m.fromBufferAttribute(f, n);
      if (h = a(h, b, d, c, k, q, m, y)) {
        e && (p.fromBufferAttribute(e, l), v.fromBufferAttribute(e, r), z.fromBufferAttribute(e, n), h.uv = la.getUV(y, k, q, m, p, v, z, new g)), e = new D(l, r, n), la.getNormal(k, q, m, e.normal), h.face = e;
      }
      return h;
    }
    var c = new b, e = new ba, l = new w, k = new f, q = new f, m = new f, n = new f, t = new f, u = new f, p = new g, v = new g, z = new g, y = new f, x = new f;
    return function(h, b) {
      var f = this.geometry, r = this.material, w = this.matrixWorld;
      if (void 0 !== r && (null === f.boundingSphere && f.computeBoundingSphere(), l.copy(f.boundingSphere), l.applyMatrix4(w), !1 !== h.ray.intersectsSphere(l) && (c.getInverse(w), e.copy(h.ray).applyMatrix4(c), null === f.boundingBox || !1 !== e.intersectsBox(f.boundingBox)))) {
        if (f.isBufferGeometry) {
          var x = f.index, F = f.attributes.position, D = f.attributes.uv, C = f.groups;
          f = f.drawRange;
          var B, W;
          if (null !== x) {
            if (Array.isArray(r)) {
              var E = 0;
              for (B = C.length; E < B; E++) {
                var A = C[E], Y = r[A.materialIndex], G = Math.max(A.start, f.start);
                for (W = Math.min(A.start + A.count, f.start + f.count); G < W; G += 3) {
                  w = x.getX(G);
                  var T = x.getX(G + 1), M = x.getX(G + 2);
                  if (w = d(this, Y, h, e, F, D, w, T, M)) {
                    w.faceIndex = Math.floor(G / 3), w.face.materialIndex = A.materialIndex, b.push(w);
                  }
                }
              }
            } else {
              for (G = Math.max(0, f.start), w = Math.min(x.count, f.start + f.count), E = G, B = w; E < B; E += 3) {
                if (w = x.getX(E), T = x.getX(E + 1), M = x.getX(E + 2), w = d(this, r, h, e, F, D, w, T, M)) {
                  w.faceIndex = Math.floor(E / 3), b.push(w);
                }
              }
            }
          } else {
            if (void 0 !== F) {
              if (Array.isArray(r)) {
                for (E = 0, B = C.length; E < B; E++) {
                  for (A = C[E], Y = r[A.materialIndex], G = Math.max(A.start, f.start), W = w = Math.min(A.start + A.count, f.start + f.count); G < W; G += 3) {
                    if (w = G, T = G + 1, M = G + 2, w = d(this, Y, h, e, F, D, w, T, M)) {
                      w.faceIndex = Math.floor(G / 3), w.face.materialIndex = A.materialIndex, b.push(w);
                    }
                  }
                }
              } else {
                for (G = Math.max(0, f.start), w = Math.min(F.count, f.start + f.count), E = G, B = w; E < B; E += 3) {
                  if (w = E, T = E + 1, M = E + 2, w = d(this, r, h, e, F, D, w, T, M)) {
                    w.faceIndex = Math.floor(E / 3), b.push(w);
                  }
                }
              }
            }
          }
        } else {
          if (f.isGeometry) {
            for (F = Array.isArray(r), D = f.vertices, C = f.faces, w = f.faceVertexUvs[0], 0 < w.length && (x = w), Y = 0, G = C.length; Y < G; Y++) {
              if (W = C[Y], w = F ? r[W.materialIndex] : r, void 0 !== w) {
                E = D[W.a];
                B = D[W.b];
                A = D[W.c];
                if (!0 === w.morphTargets) {
                  T = f.morphTargets;
                  M = this.morphTargetInfluences;
                  k.set(0, 0, 0);
                  q.set(0, 0, 0);
                  m.set(0, 0, 0);
                  for (var H = 0, O = T.length; H < O; H++) {
                    var ya = M[H];
                    if (0 !== ya) {
                      var I = T[H].vertices;
                      k.addScaledVector(n.subVectors(I[W.a], E), ya);
                      q.addScaledVector(t.subVectors(I[W.b], B), ya);
                      m.addScaledVector(u.subVectors(I[W.c], A), ya);
                    }
                  }
                  k.add(E);
                  q.add(B);
                  m.add(A);
                  E = k;
                  B = q;
                  A = m;
                }
                if (w = a(this, w, h, e, E, B, A, y)) {
                  x && x[Y] && (T = x[Y], p.copy(T[0]), v.copy(T[1]), z.copy(T[2]), w.uv = la.getUV(y, E, B, A, p, v, z, new g)), w.face = W, w.faceIndex = Y, b.push(w);
                }
              }
            }
          }
        }
      }
    };
  }(), clone:function() {
    return (new this.constructor(this.geometry, this.material)).copy(this);
  }});
  za.prototype = Object.create(n.prototype);
  za.prototype.constructor = za;
  za.prototype.isCubeTexture = !0;
  Object.defineProperty(za.prototype, "images", {get:function() {
    return this.image;
  }, set:function(a) {
    this.image = a;
  }});
  Ja.prototype = Object.create(n.prototype);
  Ja.prototype.constructor = Ja;
  Ja.prototype.isDataTexture3D = !0;
  var kf = new n, cg = new Ja, lf = new za, ef = [], ff = [], jf = new Float32Array(16), hf = new Float32Array(9), gf = new Float32Array(4);
  Ca.prototype.updateCache = function(a) {
    var h = this.cache;
    a instanceof Float32Array && h.length !== a.length && (this.cache = new Float32Array(a.length));
    ua(h, a);
  };
  Qa.prototype.setValue = function(a, b, d) {
    for (var h = this.seq, c = 0, f = h.length; c !== f; ++c) {
      var e = h[c];
      e.setValue(a, b[e.id], d);
    }
  };
  var te = /([\w\d_]+)(\])?(\[|\.)?/g;
  Hb.prototype.setValue = function(a, b, d) {
    b = this.map[b];
    void 0 !== b && b.setValue(a, d, this.renderer);
  };
  Hb.prototype.setOptional = function(a, b, d) {
    b = b[d];
    void 0 !== b && this.setValue(a, d, b);
  };
  Hb.upload = function(a, b, d, c) {
    for (var h = 0, f = b.length; h !== f; ++h) {
      var e = b[h], l = d[e.id];
      !1 !== l.needsUpdate && e.setValue(a, l.value, c);
    }
  };
  Hb.seqWithValue = function(a, b) {
    for (var h = [], d = 0, c = a.length; d !== c; ++d) {
      var f = a[d];
      f.id in b && h.push(f);
    }
    return h;
  };
  var gg = 0, og = 0;
  Ib.prototype = Object.create(X.prototype);
  Ib.prototype.constructor = Ib;
  Ib.prototype.isMeshDepthMaterial = !0;
  Ib.prototype.copy = function(a) {
    X.prototype.copy.call(this, a);
    this.depthPacking = a.depthPacking;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.map = a.map;
    this.alphaMap = a.alphaMap;
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    return this;
  };
  Jb.prototype = Object.create(X.prototype);
  Jb.prototype.constructor = Jb;
  Jb.prototype.isMeshDistanceMaterial = !0;
  Jb.prototype.copy = function(a) {
    X.prototype.copy.call(this, a);
    this.referencePosition.copy(a.referencePosition);
    this.nearDistance = a.nearDistance;
    this.farDistance = a.farDistance;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.map = a.map;
    this.alphaMap = a.alphaMap;
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    return this;
  };
  jc.prototype = Object.assign(Object.create(G.prototype), {constructor:jc, isGroup:!0});
  jb.prototype = Object.assign(Object.create(G.prototype), {constructor:jb, isCamera:!0, copy:function(a, b) {
    G.prototype.copy.call(this, a, b);
    this.matrixWorldInverse.copy(a.matrixWorldInverse);
    this.projectionMatrix.copy(a.projectionMatrix);
    this.projectionMatrixInverse.copy(a.projectionMatrixInverse);
    return this;
  }, getWorldDirection:function(a) {
    void 0 === a && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), a = new f);
    this.updateMatrixWorld(!0);
    var h = this.matrixWorld.elements;
    return a.set(-h[8], -h[9], -h[10]).normalize();
  }, updateMatrixWorld:function(a) {
    G.prototype.updateMatrixWorld.call(this, a);
    this.matrixWorldInverse.getInverse(this.matrixWorld);
  }, clone:function() {
    return (new this.constructor).copy(this);
  }});
  va.prototype = Object.assign(Object.create(jb.prototype), {constructor:va, isPerspectiveCamera:!0, copy:function(a, b) {
    jb.prototype.copy.call(this, a, b);
    this.fov = a.fov;
    this.zoom = a.zoom;
    this.near = a.near;
    this.far = a.far;
    this.focus = a.focus;
    this.aspect = a.aspect;
    this.view = null === a.view ? null : Object.assign({}, a.view);
    this.filmGauge = a.filmGauge;
    this.filmOffset = a.filmOffset;
    return this;
  }, setFocalLength:function(a) {
    a = .5 * this.getFilmHeight() / a;
    this.fov = 2 * ia.RAD2DEG * Math.atan(a);
    this.updateProjectionMatrix();
  }, getFocalLength:function() {
    var a = Math.tan(.5 * ia.DEG2RAD * this.fov);
    return .5 * this.getFilmHeight() / a;
  }, getEffectiveFOV:function() {
    return 2 * ia.RAD2DEG * Math.atan(Math.tan(.5 * ia.DEG2RAD * this.fov) / this.zoom);
  }, getFilmWidth:function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }, getFilmHeight:function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }, setViewOffset:function(a, b, d, c, f, e) {
    this.aspect = a / b;
    null === this.view && (this.view = {enabled:!0, fullWidth:1, fullHeight:1, offsetX:0, offsetY:0, width:1, height:1});
    this.view.enabled = !0;
    this.view.fullWidth = a;
    this.view.fullHeight = b;
    this.view.offsetX = d;
    this.view.offsetY = c;
    this.view.width = f;
    this.view.height = e;
    this.updateProjectionMatrix();
  }, clearViewOffset:function() {
    null !== this.view && (this.view.enabled = !1);
    this.updateProjectionMatrix();
  }, updateProjectionMatrix:function() {
    var a = this.near, b = a * Math.tan(.5 * ia.DEG2RAD * this.fov) / this.zoom, d = 2 * b, c = this.aspect * d, f = -.5 * c, e = this.view;
    if (null !== this.view && this.view.enabled) {
      var l = e.fullWidth, k = e.fullHeight;
      f += e.offsetX * c / l;
      b -= e.offsetY * d / k;
      c *= e.width / l;
      d *= e.height / k;
    }
    e = this.filmOffset;
    0 !== e && (f += a * e / this.getFilmWidth());
    this.projectionMatrix.makePerspective(f, f + c, b, b - d, a, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  }, toJSON:function(a) {
    a = G.prototype.toJSON.call(this, a);
    a.object.fov = this.fov;
    a.object.zoom = this.zoom;
    a.object.near = this.near;
    a.object.far = this.far;
    a.object.focus = this.focus;
    a.object.aspect = this.aspect;
    null !== this.view && (a.object.view = Object.assign({}, this.view));
    a.object.filmGauge = this.filmGauge;
    a.object.filmOffset = this.filmOffset;
    return a;
  }});
  Wc.prototype = Object.assign(Object.create(va.prototype), {constructor:Wc, isArrayCamera:!0});
  var uf = new f, vf = new f;
  kc.prototype.isFogExp2 = !0;
  kc.prototype.clone = function() {
    return new kc(this.color, this.density);
  };
  kc.prototype.toJSON = function() {
    return {type:"FogExp2", color:this.color.getHex(), density:this.density};
  };
  lc.prototype.isFog = !0;
  lc.prototype.clone = function() {
    return new lc(this.color, this.near, this.far);
  };
  lc.prototype.toJSON = function() {
    return {type:"Fog", color:this.color.getHex(), near:this.near, far:this.far};
  };
  Pd.prototype = Object.assign(Object.create(G.prototype), {constructor:Pd, isScene:!0, copy:function(a, b) {
    G.prototype.copy.call(this, a, b);
    null !== a.background && (this.background = a.background.clone());
    null !== a.fog && (this.fog = a.fog.clone());
    null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone());
    this.autoUpdate = a.autoUpdate;
    this.matrixAutoUpdate = a.matrixAutoUpdate;
    return this;
  }, toJSON:function(a) {
    var h = G.prototype.toJSON.call(this, a);
    null !== this.background && (h.object.background = this.background.toJSON(a));
    null !== this.fog && (h.object.fog = this.fog.toJSON());
    return h;
  }, dispose:function() {
    this.dispatchEvent({type:"dispose"});
  }});
  Object.defineProperty(Pb.prototype, "needsUpdate", {set:function(a) {
    !0 === a && this.version++;
  }});
  Object.assign(Pb.prototype, {isInterleavedBuffer:!0, onUploadCallback:function() {
  }, setArray:function(a) {
    if (Array.isArray(a)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.count = void 0 !== a ? a.length / this.stride : 0;
    this.array = a;
    return this;
  }, setDynamic:function(a) {
    this.dynamic = a;
    return this;
  }, copy:function(a) {
    this.array = new a.array.constructor(a.array);
    this.count = a.count;
    this.stride = a.stride;
    this.dynamic = a.dynamic;
    return this;
  }, copyAt:function(a, b, d) {
    a *= this.stride;
    d *= b.stride;
    for (var h = 0, c = this.stride; h < c; h++) {
      this.array[a + h] = b.array[d + h];
    }
    return this;
  }, set:function(a, b) {
    void 0 === b && (b = 0);
    this.array.set(a, b);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, onUpload:function(a) {
    this.onUploadCallback = a;
    return this;
  }});
  Object.defineProperties(Xc.prototype, {count:{get:function() {
    return this.data.count;
  }}, array:{get:function() {
    return this.data.array;
  }}});
  Object.assign(Xc.prototype, {isInterleavedBufferAttribute:!0, setX:function(a, b) {
    this.data.array[a * this.data.stride + this.offset] = b;
    return this;
  }, setY:function(a, b) {
    this.data.array[a * this.data.stride + this.offset + 1] = b;
    return this;
  }, setZ:function(a, b) {
    this.data.array[a * this.data.stride + this.offset + 2] = b;
    return this;
  }, setW:function(a, b) {
    this.data.array[a * this.data.stride + this.offset + 3] = b;
    return this;
  }, getX:function(a) {
    return this.data.array[a * this.data.stride + this.offset];
  }, getY:function(a) {
    return this.data.array[a * this.data.stride + this.offset + 1];
  }, getZ:function(a) {
    return this.data.array[a * this.data.stride + this.offset + 2];
  }, getW:function(a) {
    return this.data.array[a * this.data.stride + this.offset + 3];
  }, setXY:function(a, b, d) {
    a = a * this.data.stride + this.offset;
    this.data.array[a + 0] = b;
    this.data.array[a + 1] = d;
    return this;
  }, setXYZ:function(a, b, d, c) {
    a = a * this.data.stride + this.offset;
    this.data.array[a + 0] = b;
    this.data.array[a + 1] = d;
    this.data.array[a + 2] = c;
    return this;
  }, setXYZW:function(a, b, d, c, f) {
    a = a * this.data.stride + this.offset;
    this.data.array[a + 0] = b;
    this.data.array[a + 1] = d;
    this.data.array[a + 2] = c;
    this.data.array[a + 3] = f;
    return this;
  }});
  Kb.prototype = Object.create(X.prototype);
  Kb.prototype.constructor = Kb;
  Kb.prototype.isSpriteMaterial = !0;
  Kb.prototype.copy = function(a) {
    X.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.rotation = a.rotation;
    this.sizeAttenuation = a.sizeAttenuation;
    return this;
  };
  var mc;
  Yc.prototype = Object.assign(Object.create(G.prototype), {constructor:Yc, isSprite:!0, raycast:function() {
    function a(a, h, b, d, c, f) {
      l.subVectors(a, b).addScalar(.5).multiply(d);
      void 0 !== c ? (k.x = f * l.x - c * l.y, k.y = c * l.x + f * l.y) : k.copy(l);
      a.copy(h);
      a.x += k.x;
      a.y += k.y;
      a.applyMatrix4(q);
    }
    var d = new f, c = new f, e = new f, l = new g, k = new g, q = new b, m = new f, n = new f, t = new f, u = new g, p = new g, v = new g;
    return function(h, b) {
      c.setFromMatrixScale(this.matrixWorld);
      q.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld);
      e.setFromMatrixPosition(this.modelViewMatrix);
      var f = this.material.rotation;
      if (0 !== f) {
        var l = Math.cos(f), k = Math.sin(f);
      }
      f = this.center;
      a(m.set(-.5, -.5, 0), e, f, c, k, l);
      a(n.set(.5, -.5, 0), e, f, c, k, l);
      a(t.set(.5, .5, 0), e, f, c, k, l);
      u.set(0, 0);
      p.set(1, 0);
      v.set(1, 1);
      var r = h.ray.intersectTriangle(m, n, t, !1, d);
      if (null !== r || (a(n.set(-.5, .5, 0), e, f, c, k, l), p.set(0, 1), r = h.ray.intersectTriangle(m, t, n, !1, d), null !== r)) {
        k = h.ray.origin.distanceTo(d), k < h.near || k > h.far || b.push({distance:k, point:d.clone(), uv:la.getUV(d, m, n, t, u, p, v, new g), face:null, object:this});
      }
    };
  }(), clone:function() {
    return (new this.constructor(this.material)).copy(this);
  }, copy:function(a) {
    G.prototype.copy.call(this, a);
    void 0 !== a.center && this.center.copy(a.center);
    return this;
  }});
  Zc.prototype = Object.assign(Object.create(G.prototype), {constructor:Zc, copy:function(a) {
    G.prototype.copy.call(this, a, !1);
    a = a.levels;
    for (var h = 0, b = a.length; h < b; h++) {
      var d = a[h];
      this.addLevel(d.object.clone(), d.distance);
    }
    return this;
  }, addLevel:function(a, b) {
    void 0 === b && (b = 0);
    b = Math.abs(b);
    for (var h = this.levels, d = 0; d < h.length && !(b < h[d].distance); d++) {
    }
    h.splice(d, 0, {distance:b, object:a});
    this.add(a);
  }, getObjectForDistance:function(a) {
    for (var h = this.levels, b = 1, d = h.length; b < d && !(a < h[b].distance); b++) {
    }
    return h[b - 1].object;
  }, raycast:function() {
    var a = new f;
    return function(h, b) {
      a.setFromMatrixPosition(this.matrixWorld);
      var d = h.ray.origin.distanceTo(a);
      this.getObjectForDistance(d).raycast(h, b);
    };
  }(), update:function() {
    var a = new f, b = new f;
    return function(h) {
      var d = this.levels;
      if (1 < d.length) {
        a.setFromMatrixPosition(h.matrixWorld);
        b.setFromMatrixPosition(this.matrixWorld);
        h = a.distanceTo(b);
        d[0].object.visible = !0;
        for (var c = 1, f = d.length; c < f; c++) {
          if (h >= d[c].distance) {
            d[c - 1].object.visible = !1, d[c].object.visible = !0;
          } else {
            break;
          }
        }
        for (; c < f; c++) {
          d[c].object.visible = !1;
        }
      }
    };
  }(), toJSON:function(a) {
    a = G.prototype.toJSON.call(this, a);
    a.object.levels = [];
    for (var h = this.levels, b = 0, d = h.length; b < d; b++) {
      var c = h[b];
      a.object.levels.push({object:c.object.uuid, distance:c.distance});
    }
    return a;
  }});
  $c.prototype = Object.assign(Object.create(ca.prototype), {constructor:$c, isSkinnedMesh:!0, bind:function(a, b) {
    this.skeleton = a;
    void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), b = this.matrixWorld);
    this.bindMatrix.copy(b);
    this.bindMatrixInverse.getInverse(b);
  }, pose:function() {
    this.skeleton.pose();
  }, normalizeSkinWeights:function() {
    for (var a = new p, b = this.geometry.attributes.skinWeight, d = 0, c = b.count; d < c; d++) {
      a.x = b.getX(d);
      a.y = b.getY(d);
      a.z = b.getZ(d);
      a.w = b.getW(d);
      var f = 1 / a.manhattanLength();
      Infinity !== f ? a.multiplyScalar(f) : a.set(1, 0, 0, 0);
      b.setXYZW(d, a.x, a.y, a.z, a.w);
    }
  }, updateMatrixWorld:function(a) {
    ca.prototype.updateMatrixWorld.call(this, a);
    "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }, clone:function() {
    return (new this.constructor(this.geometry, this.material)).copy(this);
  }});
  Object.assign(Qd.prototype, {calculateInverses:function() {
    this.boneInverses = [];
    for (var a = 0, d = this.bones.length; a < d; a++) {
      var c = new b;
      this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
      this.boneInverses.push(c);
    }
  }, pose:function() {
    var a, b, d = 0;
    for (b = this.bones.length; d < b; d++) {
      (a = this.bones[d]) && a.matrixWorld.getInverse(this.boneInverses[d]);
    }
    d = 0;
    for (b = this.bones.length; d < b; d++) {
      if (a = this.bones[d]) {
        a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale);
      }
    }
  }, update:function() {
    var a = new b, d = new b;
    return function() {
      for (var h = this.bones, b = this.boneInverses, c = this.boneMatrices, f = this.boneTexture, e = 0, l = h.length; e < l; e++) {
        a.multiplyMatrices(h[e] ? h[e].matrixWorld : d, b[e]), a.toArray(c, 16 * e);
      }
      void 0 !== f && (f.needsUpdate = !0);
    };
  }(), clone:function() {
    return new Qd(this.bones, this.boneInverses);
  }, getBoneByName:function(a) {
    for (var h = 0, b = this.bones.length; h < b; h++) {
      var d = this.bones[h];
      if (d.name === a) {
        return d;
      }
    }
  }});
  we.prototype = Object.assign(Object.create(G.prototype), {constructor:we, isBone:!0});
  ra.prototype = Object.create(X.prototype);
  ra.prototype.constructor = ra;
  ra.prototype.isLineBasicMaterial = !0;
  ra.prototype.copy = function(a) {
    X.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.linewidth = a.linewidth;
    this.linecap = a.linecap;
    this.linejoin = a.linejoin;
    return this;
  };
  wa.prototype = Object.assign(Object.create(G.prototype), {constructor:wa, isLine:!0, computeLineDistances:function() {
    var a = new f, b = new f;
    return function() {
      var h = this.geometry;
      if (h.isBufferGeometry) {
        if (null === h.index) {
          for (var d = h.attributes.position, c = [0], f = 1, e = d.count; f < e; f++) {
            a.fromBufferAttribute(d, f - 1), b.fromBufferAttribute(d, f), c[f] = c[f - 1], c[f] += a.distanceTo(b);
          }
          h.addAttribute("lineDistance", new N(c, 1));
        } else {
          console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
      } else {
        if (h.isGeometry) {
          for (d = h.vertices, c = h.lineDistances, c[0] = 0, f = 1, e = d.length; f < e; f++) {
            c[f] = c[f - 1], c[f] += d[f - 1].distanceTo(d[f]);
          }
        }
      }
      return this;
    };
  }(), raycast:function() {
    var a = new b, d = new ba, c = new w;
    return function(h, b) {
      var e = h.linePrecision, l = this.geometry, k = this.matrixWorld;
      null === l.boundingSphere && l.computeBoundingSphere();
      c.copy(l.boundingSphere);
      c.applyMatrix4(k);
      c.radius += e;
      if (!1 !== h.ray.intersectsSphere(c)) {
        a.getInverse(k);
        d.copy(h.ray).applyMatrix4(a);
        e /= (this.scale.x + this.scale.y + this.scale.z) / 3;
        e *= e;
        var g = new f, q = new f;
        k = new f;
        var m = new f, n = this && this.isLineSegments ? 2 : 1;
        if (l.isBufferGeometry) {
          var r = l.index, t = l.attributes.position.array;
          if (null !== r) {
            r = r.array;
            l = 0;
            for (var u = r.length - 1; l < u; l += n) {
              var p = r[l + 1];
              g.fromArray(t, 3 * r[l]);
              q.fromArray(t, 3 * p);
              p = d.distanceSqToSegment(g, q, m, k);
              p > e || (m.applyMatrix4(this.matrixWorld), p = h.ray.origin.distanceTo(m), p < h.near || p > h.far || b.push({distance:p, point:k.clone().applyMatrix4(this.matrixWorld), index:l, face:null, faceIndex:null, object:this}));
            }
          } else {
            for (l = 0, u = t.length / 3 - 1; l < u; l += n) {
              g.fromArray(t, 3 * l), q.fromArray(t, 3 * l + 3), p = d.distanceSqToSegment(g, q, m, k), p > e || (m.applyMatrix4(this.matrixWorld), p = h.ray.origin.distanceTo(m), p < h.near || p > h.far || b.push({distance:p, point:k.clone().applyMatrix4(this.matrixWorld), index:l, face:null, faceIndex:null, object:this}));
            }
          }
        } else {
          if (l.isGeometry) {
            for (g = l.vertices, q = g.length, l = 0; l < q - 1; l += n) {
              p = d.distanceSqToSegment(g[l], g[l + 1], m, k), p > e || (m.applyMatrix4(this.matrixWorld), p = h.ray.origin.distanceTo(m), p < h.near || p > h.far || b.push({distance:p, point:k.clone().applyMatrix4(this.matrixWorld), index:l, face:null, faceIndex:null, object:this}));
            }
          }
        }
      }
    };
  }(), copy:function(a) {
    G.prototype.copy.call(this, a);
    this.geometry.copy(a.geometry);
    this.material.copy(a.material);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }});
  pa.prototype = Object.assign(Object.create(wa.prototype), {constructor:pa, isLineSegments:!0, computeLineDistances:function() {
    var a = new f, b = new f;
    return function() {
      var h = this.geometry;
      if (h.isBufferGeometry) {
        if (null === h.index) {
          for (var d = h.attributes.position, c = [], f = 0, e = d.count; f < e; f += 2) {
            a.fromBufferAttribute(d, f), b.fromBufferAttribute(d, f + 1), c[f] = 0 === f ? 0 : c[f - 1], c[f + 1] = c[f] + a.distanceTo(b);
          }
          h.addAttribute("lineDistance", new N(c, 1));
        } else {
          console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
      } else {
        if (h.isGeometry) {
          for (d = h.vertices, c = h.lineDistances, f = 0, e = d.length; f < e; f += 2) {
            a.copy(d[f]), b.copy(d[f + 1]), c[f] = 0 === f ? 0 : c[f - 1], c[f + 1] = c[f] + a.distanceTo(b);
          }
        }
      }
      return this;
    };
  }()});
  Rd.prototype = Object.assign(Object.create(wa.prototype), {constructor:Rd, isLineLoop:!0});
  Xa.prototype = Object.create(X.prototype);
  Xa.prototype.constructor = Xa;
  Xa.prototype.isPointsMaterial = !0;
  Xa.prototype.copy = function(a) {
    X.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.size = a.size;
    this.sizeAttenuation = a.sizeAttenuation;
    this.morphTargets = a.morphTargets;
    return this;
  };
  nc.prototype = Object.assign(Object.create(G.prototype), {constructor:nc, isPoints:!0, raycast:function() {
    var a = new b, d = new ba, c = new w;
    return function(h, b) {
      function e(a, c) {
        var f = d.distanceSqToPoint(a);
        f < m && (d.closestPointToPoint(a, n), n.applyMatrix4(g), a = h.ray.origin.distanceTo(n), a < h.near || a > h.far || b.push({distance:a, distanceToRay:Math.sqrt(f), point:n.clone(), index:c, face:null, object:l}));
      }
      var l = this, k = this.geometry, g = this.matrixWorld, q = h.params.Points.threshold;
      null === k.boundingSphere && k.computeBoundingSphere();
      c.copy(k.boundingSphere);
      c.applyMatrix4(g);
      c.radius += q;
      if (!1 !== h.ray.intersectsSphere(c)) {
        a.getInverse(g);
        d.copy(h.ray).applyMatrix4(a);
        q /= (this.scale.x + this.scale.y + this.scale.z) / 3;
        var m = q * q;
        q = new f;
        var n = new f;
        if (k.isBufferGeometry) {
          var r = k.index;
          k = k.attributes.position.array;
          if (null !== r) {
            var t = r.array;
            r = 0;
            for (var u = t.length; r < u; r++) {
              var p = t[r];
              q.fromArray(k, 3 * p);
              e(q, p);
            }
          } else {
            for (r = 0, t = k.length / 3; r < t; r++) {
              q.fromArray(k, 3 * r), e(q, r);
            }
          }
        } else {
          for (q = k.vertices, r = 0, t = q.length; r < t; r++) {
            e(q[r], r);
          }
        }
      }
    };
  }(), clone:function() {
    return (new this.constructor(this.geometry, this.material)).copy(this);
  }});
  xe.prototype = Object.assign(Object.create(n.prototype), {constructor:xe, isVideoTexture:!0, update:function() {
    var a = this.image;
    a.readyState >= a.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }});
  oc.prototype = Object.create(n.prototype);
  oc.prototype.constructor = oc;
  oc.prototype.isCompressedTexture = !0;
  ad.prototype = Object.create(n.prototype);
  ad.prototype.constructor = ad;
  ad.prototype.isCanvasTexture = !0;
  bd.prototype = Object.create(n.prototype);
  bd.prototype.constructor = bd;
  bd.prototype.isDepthTexture = !0;
  pc.prototype = Object.create(O.prototype);
  pc.prototype.constructor = pc;
  cd.prototype = Object.create(H.prototype);
  cd.prototype.constructor = cd;
  qc.prototype = Object.create(O.prototype);
  qc.prototype.constructor = qc;
  dd.prototype = Object.create(H.prototype);
  dd.prototype.constructor = dd;
  Ka.prototype = Object.create(O.prototype);
  Ka.prototype.constructor = Ka;
  ed.prototype = Object.create(H.prototype);
  ed.prototype.constructor = ed;
  rc.prototype = Object.create(Ka.prototype);
  rc.prototype.constructor = rc;
  fd.prototype = Object.create(H.prototype);
  fd.prototype.constructor = fd;
  Qb.prototype = Object.create(Ka.prototype);
  Qb.prototype.constructor = Qb;
  gd.prototype = Object.create(H.prototype);
  gd.prototype.constructor = gd;
  sc.prototype = Object.create(Ka.prototype);
  sc.prototype.constructor = sc;
  hd.prototype = Object.create(H.prototype);
  hd.prototype.constructor = hd;
  tc.prototype = Object.create(Ka.prototype);
  tc.prototype.constructor = tc;
  id.prototype = Object.create(H.prototype);
  id.prototype.constructor = id;
  Rb.prototype = Object.create(O.prototype);
  Rb.prototype.constructor = Rb;
  Rb.prototype.toJSON = function() {
    var a = O.prototype.toJSON.call(this);
    a.path = this.parameters.path.toJSON();
    return a;
  };
  jd.prototype = Object.create(H.prototype);
  jd.prototype.constructor = jd;
  uc.prototype = Object.create(O.prototype);
  uc.prototype.constructor = uc;
  kd.prototype = Object.create(H.prototype);
  kd.prototype.constructor = kd;
  vc.prototype = Object.create(O.prototype);
  vc.prototype.constructor = vc;
  var Bg = {triangulate:function(a, b, d) {
    d = d || 2;
    var h = b && b.length, c = h ? b[0] * d : a.length, f = yf(a, 0, c, d, !0), e = [];
    if (!f) {
      return e;
    }
    var l;
    if (h) {
      var k = d;
      h = [];
      var g, q = 0;
      for (g = b.length; q < g; q++) {
        var m = b[q] * k;
        m = yf(a, m, q < g - 1 ? b[q + 1] * k : a.length, k, !1);
        m === m.next && (m.steiner = !0);
        h.push(vg(m));
      }
      h.sort(tg);
      for (q = 0; q < h.length; q++) {
        b = h[q];
        k = f;
        if (k = ug(b, k)) {
          b = Bf(k, b), md(b, b.next);
        }
        f = md(f, f.next);
      }
    }
    if (a.length > 80 * d) {
      var n = l = a[0], r = h = a[1];
      for (k = d; k < c; k += d) {
        q = a[k], b = a[k + 1], q < n && (n = q), b < r && (r = b), q > l && (l = q), b > h && (h = b);
      }
      l = Math.max(l - n, h - r);
      l = 0 !== l ? 1 / l : 0;
    }
    nd(f, e, d, n, r, l);
    return e;
  }}, wb = {area:function(a) {
    for (var h = a.length, b = 0, d = h - 1, c = 0; c < h; d = c++) {
      b += a[d].x * a[c].y - a[c].x * a[d].y;
    }
    return .5 * b;
  }, isClockWise:function(a) {
    return 0 > wb.area(a);
  }, triangulateShape:function(a, b) {
    var h = [], d = [], c = [];
    Cf(a);
    Df(h, a);
    var f = a.length;
    b.forEach(Cf);
    for (a = 0; a < b.length; a++) {
      d.push(f), f += b[a].length, Df(h, b[a]);
    }
    b = Bg.triangulate(h, d);
    for (a = 0; a < b.length; a += 3) {
      c.push(b.slice(a, a + 3));
    }
    return c;
  }};
  Tb.prototype = Object.create(H.prototype);
  Tb.prototype.constructor = Tb;
  Tb.prototype.toJSON = function() {
    var a = H.prototype.toJSON.call(this);
    return Ef(this.parameters.shapes, this.parameters.options, a);
  };
  kb.prototype = Object.create(O.prototype);
  kb.prototype.constructor = kb;
  kb.prototype.toJSON = function() {
    var a = O.prototype.toJSON.call(this);
    return Ef(this.parameters.shapes, this.parameters.options, a);
  };
  var wg = {generateTopUV:function(a, b, d, c, f) {
    a = b[3 * c];
    c = b[3 * c + 1];
    var h = b[3 * f];
    f = b[3 * f + 1];
    return [new g(b[3 * d], b[3 * d + 1]), new g(a, c), new g(h, f)];
  }, generateSideWallUV:function(a, b, d, c, f, e) {
    a = b[3 * d];
    var h = b[3 * d + 1];
    d = b[3 * d + 2];
    var l = b[3 * c], k = b[3 * c + 1];
    c = b[3 * c + 2];
    var q = b[3 * f], m = b[3 * f + 1];
    f = b[3 * f + 2];
    var n = b[3 * e], r = b[3 * e + 1];
    b = b[3 * e + 2];
    return .01 > Math.abs(h - k) ? [new g(a, 1 - d), new g(l, 1 - c), new g(q, 1 - f), new g(n, 1 - b)] : [new g(h, 1 - d), new g(k, 1 - c), new g(m, 1 - f), new g(r, 1 - b)];
  }};
  pd.prototype = Object.create(H.prototype);
  pd.prototype.constructor = pd;
  wc.prototype = Object.create(kb.prototype);
  wc.prototype.constructor = wc;
  qd.prototype = Object.create(H.prototype);
  qd.prototype.constructor = qd;
  Ub.prototype = Object.create(O.prototype);
  Ub.prototype.constructor = Ub;
  rd.prototype = Object.create(H.prototype);
  rd.prototype.constructor = rd;
  xc.prototype = Object.create(O.prototype);
  xc.prototype.constructor = xc;
  sd.prototype = Object.create(H.prototype);
  sd.prototype.constructor = sd;
  yc.prototype = Object.create(O.prototype);
  yc.prototype.constructor = yc;
  Vb.prototype = Object.create(H.prototype);
  Vb.prototype.constructor = Vb;
  Vb.prototype.toJSON = function() {
    var a = H.prototype.toJSON.call(this);
    return Ff(this.parameters.shapes, a);
  };
  Wb.prototype = Object.create(O.prototype);
  Wb.prototype.constructor = Wb;
  Wb.prototype.toJSON = function() {
    var a = O.prototype.toJSON.call(this);
    return Ff(this.parameters.shapes, a);
  };
  zc.prototype = Object.create(O.prototype);
  zc.prototype.constructor = zc;
  Xb.prototype = Object.create(H.prototype);
  Xb.prototype.constructor = Xb;
  xb.prototype = Object.create(O.prototype);
  xb.prototype.constructor = xb;
  td.prototype = Object.create(Xb.prototype);
  td.prototype.constructor = td;
  ud.prototype = Object.create(xb.prototype);
  ud.prototype.constructor = ud;
  vd.prototype = Object.create(H.prototype);
  vd.prototype.constructor = vd;
  Ac.prototype = Object.create(O.prototype);
  Ac.prototype.constructor = Ac;
  var Ha = Object.freeze({WireframeGeometry:pc, ParametricGeometry:cd, ParametricBufferGeometry:qc, TetrahedronGeometry:ed, TetrahedronBufferGeometry:rc, OctahedronGeometry:fd, OctahedronBufferGeometry:Qb, IcosahedronGeometry:gd, IcosahedronBufferGeometry:sc, DodecahedronGeometry:hd, DodecahedronBufferGeometry:tc, PolyhedronGeometry:dd, PolyhedronBufferGeometry:Ka, TubeGeometry:id, TubeBufferGeometry:Rb, TorusKnotGeometry:jd, TorusKnotBufferGeometry:uc, TorusGeometry:kd, TorusBufferGeometry:vc, TextGeometry:pd, 
  TextBufferGeometry:wc, SphereGeometry:qd, SphereBufferGeometry:Ub, RingGeometry:rd, RingBufferGeometry:xc, PlaneGeometry:ha, PlaneBufferGeometry:ja, LatheGeometry:sd, LatheBufferGeometry:yc, ShapeGeometry:Vb, ShapeBufferGeometry:Wb, ExtrudeGeometry:Tb, ExtrudeBufferGeometry:kb, EdgesGeometry:zc, ConeGeometry:td, ConeBufferGeometry:ud, CylinderGeometry:Xb, CylinderBufferGeometry:xb, CircleGeometry:vd, CircleBufferGeometry:Ac, BoxGeometry:P, BoxBufferGeometry:ka});
  Yb.prototype = Object.create(X.prototype);
  Yb.prototype.constructor = Yb;
  Yb.prototype.isShadowMaterial = !0;
  Yb.prototype.copy = function(a) {
    X.prototype.copy.call(this, a);
    this.color.copy(a.color);
    return this;
  };
  Bc.prototype = Object.create(fa.prototype);
  Bc.prototype.constructor = Bc;
  Bc.prototype.isRawShaderMaterial = !0;
  lb.prototype = Object.create(X.prototype);
  lb.prototype.constructor = lb;
  lb.prototype.isMeshStandardMaterial = !0;
  lb.prototype.copy = function(a) {
    X.prototype.copy.call(this, a);
    this.defines = {STANDARD:""};
    this.color.copy(a.color);
    this.roughness = a.roughness;
    this.metalness = a.metalness;
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.roughnessMap = a.roughnessMap;
    this.metalnessMap = a.metalnessMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.envMapIntensity = a.envMapIntensity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  Zb.prototype = Object.create(lb.prototype);
  Zb.prototype.constructor = Zb;
  Zb.prototype.isMeshPhysicalMaterial = !0;
  Zb.prototype.copy = function(a) {
    lb.prototype.copy.call(this, a);
    this.defines = {PHYSICAL:""};
    this.reflectivity = a.reflectivity;
    this.clearCoat = a.clearCoat;
    this.clearCoatRoughness = a.clearCoatRoughness;
    return this;
  };
  Ya.prototype = Object.create(X.prototype);
  Ya.prototype.constructor = Ya;
  Ya.prototype.isMeshPhongMaterial = !0;
  Ya.prototype.copy = function(a) {
    X.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.specular.copy(a.specular);
    this.shininess = a.shininess;
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  $b.prototype = Object.create(Ya.prototype);
  $b.prototype.constructor = $b;
  $b.prototype.isMeshToonMaterial = !0;
  $b.prototype.copy = function(a) {
    Ya.prototype.copy.call(this, a);
    this.gradientMap = a.gradientMap;
    return this;
  };
  ac.prototype = Object.create(X.prototype);
  ac.prototype.constructor = ac;
  ac.prototype.isMeshNormalMaterial = !0;
  ac.prototype.copy = function(a) {
    X.prototype.copy.call(this, a);
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  bc.prototype = Object.create(X.prototype);
  bc.prototype.constructor = bc;
  bc.prototype.isMeshLambertMaterial = !0;
  bc.prototype.copy = function(a) {
    X.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  cc.prototype = Object.create(X.prototype);
  cc.prototype.constructor = cc;
  cc.prototype.isMeshMatcapMaterial = !0;
  cc.prototype.copy = function(a) {
    X.prototype.copy.call(this, a);
    this.defines = {MATCAP:""};
    this.color.copy(a.color);
    this.matcap = a.matcap;
    this.map = a.map;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.alphaMap = a.alphaMap;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  dc.prototype = Object.create(ra.prototype);
  dc.prototype.constructor = dc;
  dc.prototype.isLineDashedMaterial = !0;
  dc.prototype.copy = function(a) {
    ra.prototype.copy.call(this, a);
    this.scale = a.scale;
    this.dashSize = a.dashSize;
    this.gapSize = a.gapSize;
    return this;
  };
  var Cg = Object.freeze({ShadowMaterial:Yb, SpriteMaterial:Kb, RawShaderMaterial:Bc, ShaderMaterial:fa, PointsMaterial:Xa, MeshPhysicalMaterial:Zb, MeshStandardMaterial:lb, MeshPhongMaterial:Ya, MeshToonMaterial:$b, MeshNormalMaterial:ac, MeshLambertMaterial:bc, MeshDepthMaterial:Ib, MeshDistanceMaterial:Jb, MeshBasicMaterial:ma, MeshMatcapMaterial:cc, LineDashedMaterial:dc, LineBasicMaterial:ra, Material:X}), xa = {arraySlice:function(a, b, d) {
    return xa.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== d ? d : a.length)) : a.slice(b, d);
  }, convertArray:function(a, b, d) {
    return !a || !d && a.constructor === b ? a : "number" === typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a);
  }, isTypedArray:function(a) {
    return ArrayBuffer.isView(a) && !(a instanceof DataView);
  }, getKeyframeOrder:function(a) {
    for (var b = a.length, h = Array(b), d = 0; d !== b; ++d) {
      h[d] = d;
    }
    h.sort(function(b, h) {
      return a[b] - a[h];
    });
    return h;
  }, sortedArray:function(a, b, d) {
    for (var h = a.length, c = new a.constructor(h), f = 0, e = 0; e !== h; ++f) {
      for (var l = d[f] * b, k = 0; k !== b; ++k) {
        c[e++] = a[l + k];
      }
    }
    return c;
  }, flattenJSON:function(a, b, d, c) {
    for (var h = 1, f = a[0]; void 0 !== f && void 0 === f[c];) {
      f = a[h++];
    }
    if (void 0 !== f) {
      var e = f[c];
      if (void 0 !== e) {
        if (Array.isArray(e)) {
          do {
            e = f[c], void 0 !== e && (b.push(f.time), d.push.apply(d, e)), f = a[h++];
          } while (void 0 !== f);
        } else {
          if (void 0 !== e.toArray) {
            do {
              e = f[c], void 0 !== e && (b.push(f.time), e.toArray(d, d.length)), f = a[h++];
            } while (void 0 !== f);
          } else {
            do {
              e = f[c], void 0 !== e && (b.push(f.time), d.push(e)), f = a[h++];
            } while (void 0 !== f);
          }
        }
      }
    }
  }};
  Object.assign(Na.prototype, {evaluate:function(a) {
    var b = this.parameterPositions, h = this._cachedIndex, d = b[h], c = b[h - 1];
    a: {
      b: {
        c: {
          d: {
            if (!(a < d)) {
              for (var f = h + 2;;) {
                if (void 0 === d) {
                  if (a < c) {
                    break d;
                  }
                  this._cachedIndex = h = b.length;
                  return this.afterEnd_(h - 1, a, c);
                }
                if (h === f) {
                  break;
                }
                c = d;
                d = b[++h];
                if (a < d) {
                  break b;
                }
              }
              d = b.length;
              break c;
            }
          }
          if (a >= c) {
            break a;
          } else {
            f = b[1];
            a < f && (h = 2, c = f);
            for (f = h - 2;;) {
              if (void 0 === c) {
                return this._cachedIndex = 0, this.beforeStart_(0, a, d);
              }
              if (h === f) {
                break;
              }
              d = c;
              c = b[--h - 1];
              if (a >= c) {
                break b;
              }
            }
            d = h;
            h = 0;
          }
        }
        for (; h < d;) {
          c = h + d >>> 1, a < b[c] ? d = c : h = c + 1;
        }
        d = b[h];
        c = b[h - 1];
        if (void 0 === c) {
          return this._cachedIndex = 0, this.beforeStart_(0, a, d);
        }
        if (void 0 === d) {
          return this._cachedIndex = h = b.length, this.afterEnd_(h - 1, c, a);
        }
      }
      this._cachedIndex = h;
      this.intervalChanged_(h, c, d);
    }
    return this.interpolate_(h, c, a, d);
  }, settings:null, DefaultSettings_:{}, getSettings_:function() {
    return this.settings || this.DefaultSettings_;
  }, copySampleValue_:function(a) {
    var b = this.resultBuffer, h = this.sampleValues, d = this.valueSize;
    a *= d;
    for (var c = 0; c !== d; ++c) {
      b[c] = h[a + c];
    }
    return b;
  }, interpolate_:function() {
    throw Error("call to abstract method");
  }, intervalChanged_:function() {
  }});
  Object.assign(Na.prototype, {beforeStart_:Na.prototype.copySampleValue_, afterEnd_:Na.prototype.copySampleValue_});
  Td.prototype = Object.assign(Object.create(Na.prototype), {constructor:Td, DefaultSettings_:{endingStart:2400, endingEnd:2400}, intervalChanged_:function(a, b, d) {
    var h = this.parameterPositions, c = a - 2, f = a + 1, e = h[c], l = h[f];
    if (void 0 === e) {
      switch(this.getSettings_().endingStart) {
        case 2401:
          c = a;
          e = 2 * b - d;
          break;
        case 2402:
          c = h.length - 2;
          e = b + h[c] - h[c + 1];
          break;
        default:
          c = a, e = d;
      }
    }
    if (void 0 === l) {
      switch(this.getSettings_().endingEnd) {
        case 2401:
          f = a;
          l = 2 * d - b;
          break;
        case 2402:
          f = 1;
          l = d + h[1] - h[0];
          break;
        default:
          f = a - 1, l = b;
      }
    }
    a = .5 * (d - b);
    h = this.valueSize;
    this._weightPrev = a / (b - e);
    this._weightNext = a / (l - d);
    this._offsetPrev = c * h;
    this._offsetNext = f * h;
  }, interpolate_:function(a, b, d, c) {
    var h = this.resultBuffer, f = this.sampleValues, e = this.valueSize;
    a *= e;
    var l = a - e, k = this._offsetPrev, g = this._offsetNext, q = this._weightPrev, m = this._weightNext, n = (d - b) / (c - b);
    d = n * n;
    c = d * n;
    b = -q * c + 2 * q * d - q * n;
    q = (1 + q) * c + (-1.5 - 2 * q) * d + (-.5 + q) * n + 1;
    n = (-1 - m) * c + (1.5 + m) * d + .5 * n;
    m = m * c - m * d;
    for (d = 0; d !== e; ++d) {
      h[d] = b * f[k + d] + q * f[l + d] + n * f[a + d] + m * f[g + d];
    }
    return h;
  }});
  wd.prototype = Object.assign(Object.create(Na.prototype), {constructor:wd, interpolate_:function(a, b, d, c) {
    var h = this.resultBuffer, f = this.sampleValues, e = this.valueSize;
    a *= e;
    var l = a - e;
    b = (d - b) / (c - b);
    d = 1 - b;
    for (c = 0; c !== e; ++c) {
      h[c] = f[l + c] * d + f[a + c] * b;
    }
    return h;
  }});
  Ud.prototype = Object.assign(Object.create(Na.prototype), {constructor:Ud, interpolate_:function(a) {
    return this.copySampleValue_(a - 1);
  }});
  Object.assign(Da, {toJSON:function(a) {
    var b = a.constructor;
    if (void 0 !== b.toJSON) {
      b = b.toJSON(a);
    } else {
      b = {name:a.name, times:xa.convertArray(a.times, Array), values:xa.convertArray(a.values, Array)};
      var h = a.getInterpolation();
      h !== a.DefaultInterpolation && (b.interpolation = h);
    }
    b.type = a.ValueTypeName;
    return b;
  }});
  Object.assign(Da.prototype, {constructor:Da, TimeBufferType:Float32Array, ValueBufferType:Float32Array, DefaultInterpolation:2301, InterpolantFactoryMethodDiscrete:function(a) {
    return new Ud(this.times, this.values, this.getValueSize(), a);
  }, InterpolantFactoryMethodLinear:function(a) {
    return new wd(this.times, this.values, this.getValueSize(), a);
  }, InterpolantFactoryMethodSmooth:function(a) {
    return new Td(this.times, this.values, this.getValueSize(), a);
  }, setInterpolation:function(a) {
    switch(a) {
      case 2300:
        var b = this.InterpolantFactoryMethodDiscrete;
        break;
      case 2301:
        b = this.InterpolantFactoryMethodLinear;
        break;
      case 2302:
        b = this.InterpolantFactoryMethodSmooth;
    }
    if (void 0 === b) {
      b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (void 0 === this.createInterpolant) {
        if (a !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw Error(b);
        }
      }
      console.warn("THREE.KeyframeTrack:", b);
      return this;
    }
    this.createInterpolant = b;
    return this;
  }, getInterpolation:function() {
    switch(this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return 2300;
      case this.InterpolantFactoryMethodLinear:
        return 2301;
      case this.InterpolantFactoryMethodSmooth:
        return 2302;
    }
  }, getValueSize:function() {
    return this.values.length / this.times.length;
  }, shift:function(a) {
    if (0 !== a) {
      for (var b = this.times, h = 0, d = b.length; h !== d; ++h) {
        b[h] += a;
      }
    }
    return this;
  }, scale:function(a) {
    if (1 !== a) {
      for (var b = this.times, h = 0, d = b.length; h !== d; ++h) {
        b[h] *= a;
      }
    }
    return this;
  }, trim:function(a, b) {
    for (var h = this.times, d = h.length, c = 0, f = d - 1; c !== d && h[c] < a;) {
      ++c;
    }
    for (; -1 !== f && h[f] > b;) {
      --f;
    }
    ++f;
    if (0 !== c || f !== d) {
      c >= f && (f = Math.max(f, 1), c = f - 1), a = this.getValueSize(), this.times = xa.arraySlice(h, c, f), this.values = xa.arraySlice(this.values, c * a, f * a);
    }
    return this;
  }, validate:function() {
    var a = !0, b = this.getValueSize();
    0 !== b - Math.floor(b) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), a = !1);
    var d = this.times;
    b = this.values;
    var c = d.length;
    0 === c && (console.error("THREE.KeyframeTrack: Track is empty.", this), a = !1);
    for (var f = null, e = 0; e !== c; e++) {
      var l = d[e];
      if ("number" === typeof l && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, l);
        a = !1;
        break;
      }
      if (null !== f && f > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, e, l, f);
        a = !1;
        break;
      }
      f = l;
    }
    if (void 0 !== b && xa.isTypedArray(b)) {
      for (e = 0, d = b.length; e !== d; ++e) {
        if (c = b[e], isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, c);
          a = !1;
          break;
        }
      }
    }
    return a;
  }, optimize:function() {
    for (var a = this.times, b = this.values, d = this.getValueSize(), c = 2302 === this.getInterpolation(), f = 1, e = a.length - 1, l = 1; l < e; ++l) {
      var k = !1, g = a[l];
      if (g !== a[l + 1] && (1 !== l || g !== g[0])) {
        if (c) {
          k = !0;
        } else {
          var q = l * d, m = q - d, n = q + d;
          for (g = 0; g !== d; ++g) {
            var t = b[q + g];
            if (t !== b[m + g] || t !== b[n + g]) {
              k = !0;
              break;
            }
          }
        }
      }
      if (k) {
        if (l !== f) {
          for (a[f] = a[l], k = l * d, q = f * d, g = 0; g !== d; ++g) {
            b[q + g] = b[k + g];
          }
        }
        ++f;
      }
    }
    if (0 < e) {
      a[f] = a[e];
      k = e * d;
      q = f * d;
      for (g = 0; g !== d; ++g) {
        b[q + g] = b[k + g];
      }
      ++f;
    }
    f !== a.length && (this.times = xa.arraySlice(a, 0, f), this.values = xa.arraySlice(b, 0, f * d));
    return this;
  }, clone:function() {
    var a = xa.arraySlice(this.times, 0), b = xa.arraySlice(this.values, 0);
    a = new this.constructor(this.name, a, b);
    a.createInterpolant = this.createInterpolant;
    return a;
  }});
  Vd.prototype = Object.assign(Object.create(Da.prototype), {constructor:Vd, ValueTypeName:"bool", ValueBufferType:Array, DefaultInterpolation:2300, InterpolantFactoryMethodLinear:void 0, InterpolantFactoryMethodSmooth:void 0});
  Wd.prototype = Object.assign(Object.create(Da.prototype), {constructor:Wd, ValueTypeName:"color"});
  Cc.prototype = Object.assign(Object.create(Da.prototype), {constructor:Cc, ValueTypeName:"number"});
  Xd.prototype = Object.assign(Object.create(Na.prototype), {constructor:Xd, interpolate_:function(a, b, d, c) {
    var h = this.resultBuffer, f = this.sampleValues, l = this.valueSize;
    a *= l;
    b = (d - b) / (c - b);
    for (d = a + l; a !== d; a += 4) {
      e.slerpFlat(h, 0, f, a - l, f, a, b);
    }
    return h;
  }});
  xd.prototype = Object.assign(Object.create(Da.prototype), {constructor:xd, ValueTypeName:"quaternion", DefaultInterpolation:2301, InterpolantFactoryMethodLinear:function(a) {
    return new Xd(this.times, this.values, this.getValueSize(), a);
  }, InterpolantFactoryMethodSmooth:void 0});
  Yd.prototype = Object.assign(Object.create(Da.prototype), {constructor:Yd, ValueTypeName:"string", ValueBufferType:Array, DefaultInterpolation:2300, InterpolantFactoryMethodLinear:void 0, InterpolantFactoryMethodSmooth:void 0});
  Dc.prototype = Object.assign(Object.create(Da.prototype), {constructor:Dc, ValueTypeName:"vector"});
  Object.assign(Ta, {parse:function(a) {
    for (var b = [], h = a.tracks, d = 1 / (a.fps || 1), c = 0, f = h.length; c !== f; ++c) {
      b.push(yg(h[c]).scale(d));
    }
    return new Ta(a.name, a.duration, b);
  }, toJSON:function(a) {
    var b = [], h = a.tracks;
    a = {name:a.name, duration:a.duration, tracks:b, uuid:a.uuid};
    for (var d = 0, c = h.length; d !== c; ++d) {
      b.push(Da.toJSON(h[d]));
    }
    return a;
  }, CreateFromMorphTargetSequence:function(a, b, d, c) {
    for (var h = b.length, f = [], e = 0; e < h; e++) {
      var l = [], k = [];
      l.push((e + h - 1) % h, e, (e + 1) % h);
      k.push(0, 1, 0);
      var g = xa.getKeyframeOrder(l);
      l = xa.sortedArray(l, 1, g);
      k = xa.sortedArray(k, 1, g);
      c || 0 !== l[0] || (l.push(h), k.push(k[0]));
      f.push((new Cc(".morphTargetInfluences[" + b[e].name + "]", l, k)).scale(1 / d));
    }
    return new Ta(a, -1, f);
  }, findByName:function(a, b) {
    var h = a;
    Array.isArray(a) || (h = a.geometry && a.geometry.animations || a.animations);
    for (a = 0; a < h.length; a++) {
      if (h[a].name === b) {
        return h[a];
      }
    }
    return null;
  }, CreateClipsFromMorphTargetSequences:function(a, b, d) {
    for (var h = {}, c = /^([\w-]*?)([\d]+)$/, f = 0, e = a.length; f < e; f++) {
      var l = a[f], k = l.name.match(c);
      if (k && 1 < k.length) {
        var g = k[1];
        (k = h[g]) || (h[g] = k = []);
        k.push(l);
      }
    }
    a = [];
    for (g in h) {
      a.push(Ta.CreateFromMorphTargetSequence(g, h[g], b, d));
    }
    return a;
  }, parseAnimation:function(a, b) {
    if (!a) {
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    }
    var h = function(a, b, h, d, c) {
      if (0 !== h.length) {
        var f = [], e = [];
        xa.flattenJSON(h, f, e, d);
        0 !== f.length && c.push(new a(b, f, e));
      }
    }, d = [], c = a.name || "default", f = a.length || -1, e = a.fps || 30;
    a = a.hierarchy || [];
    for (var l = 0; l < a.length; l++) {
      var k = a[l].keys;
      if (k && 0 !== k.length) {
        if (k[0].morphTargets) {
          f = {};
          for (var g = 0; g < k.length; g++) {
            if (k[g].morphTargets) {
              for (var q = 0; q < k[g].morphTargets.length; q++) {
                f[k[g].morphTargets[q]] = -1;
              }
            }
          }
          for (var m in f) {
            var n = [], t = [];
            for (q = 0; q !== k[g].morphTargets.length; ++q) {
              var u = k[g];
              n.push(u.time);
              t.push(u.morphTarget === m ? 1 : 0);
            }
            d.push(new Cc(".morphTargetInfluence[" + m + "]", n, t));
          }
          f = f.length * (e || 1);
        } else {
          g = ".bones[" + b[l].name + "]", h(Dc, g + ".position", k, "pos", d), h(xd, g + ".quaternion", k, "rot", d), h(Dc, g + ".scale", k, "scl", d);
        }
      }
    }
    return 0 === d.length ? null : new Ta(c, f, d);
  }});
  Object.assign(Ta.prototype, {resetDuration:function() {
    for (var a = 0, b = 0, d = this.tracks.length; b !== d; ++b) {
      var c = this.tracks[b];
      a = Math.max(a, c.times[c.times.length - 1]);
    }
    this.duration = a;
    return this;
  }, trim:function() {
    for (var a = 0; a < this.tracks.length; a++) {
      this.tracks[a].trim(0, this.duration);
    }
    return this;
  }, validate:function() {
    for (var a = !0, b = 0; b < this.tracks.length; b++) {
      a = a && this.tracks[b].validate();
    }
    return a;
  }, optimize:function() {
    for (var a = 0; a < this.tracks.length; a++) {
      this.tracks[a].optimize();
    }
    return this;
  }, clone:function() {
    for (var a = [], b = 0; b < this.tracks.length; b++) {
      a.push(this.tracks[b].clone());
    }
    return new Ta(this.name, this.duration, a);
  }});
  var fc = {enabled:!1, files:{}, add:function(a, b) {
    !1 !== this.enabled && (this.files[a] = b);
  }, get:function(a) {
    if (!1 !== this.enabled) {
      return this.files[a];
    }
  }, remove:function(a) {
    delete this.files[a];
  }, clear:function() {
    this.files = {};
  }}, La = new Ae, eb = {};
  Object.assign(Za.prototype, {load:function(a, b, d, c) {
    void 0 === a && (a = "");
    void 0 !== this.path && (a = this.path + a);
    a = this.manager.resolveURL(a);
    var h = this, f = fc.get(a);
    if (void 0 !== f) {
      return h.manager.itemStart(a), setTimeout(function() {
        b && b(f);
        h.manager.itemEnd(a);
      }, 0), f;
    }
    if (void 0 !== eb[a]) {
      eb[a].push({onLoad:b, onProgress:d, onError:c});
    } else {
      var e = a.match(/^data:(.*?)(;base64)?,(.*)$/);
      if (e) {
        d = e[1];
        var l = !!e[2];
        e = e[3];
        e = decodeURIComponent(e);
        l && (e = atob(e));
        try {
          var k = (this.responseType || "").toLowerCase();
          switch(k) {
            case "arraybuffer":
            case "blob":
              var g = new Uint8Array(e.length);
              for (l = 0; l < e.length; l++) {
                g[l] = e.charCodeAt(l);
              }
              var q = "blob" === k ? new Blob([g.buffer], {type:d}) : g.buffer;
              break;
            case "document":
              q = (new DOMParser).parseFromString(e, d);
              break;
            case "json":
              q = JSON.parse(e);
              break;
            default:
              q = e;
          }
          setTimeout(function() {
            b && b(q);
            h.manager.itemEnd(a);
          }, 0);
        } catch (ag) {
          setTimeout(function() {
            c && c(ag);
            h.manager.itemError(a);
            h.manager.itemEnd(a);
          }, 0);
        }
      } else {
        eb[a] = [];
        eb[a].push({onLoad:b, onProgress:d, onError:c});
        var m = new XMLHttpRequest;
        m.open("GET", a, !0);
        m.addEventListener("load", function(b) {
          var d = this.response;
          fc.add(a, d);
          var c = eb[a];
          delete eb[a];
          if (200 === this.status || 0 === this.status) {
            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
            for (var f = 0, e = c.length; f < e; f++) {
              var l = c[f];
              if (l.onLoad) {
                l.onLoad(d);
              }
            }
          } else {
            f = 0;
            for (e = c.length; f < e; f++) {
              if (l = c[f], l.onError) {
                l.onError(b);
              }
            }
            h.manager.itemError(a);
          }
          h.manager.itemEnd(a);
        }, !1);
        m.addEventListener("progress", function(b) {
          for (var h = eb[a], d = 0, c = h.length; d < c; d++) {
            var f = h[d];
            if (f.onProgress) {
              f.onProgress(b);
            }
          }
        }, !1);
        m.addEventListener("error", function(b) {
          var d = eb[a];
          delete eb[a];
          for (var c = 0, f = d.length; c < f; c++) {
            var e = d[c];
            if (e.onError) {
              e.onError(b);
            }
          }
          h.manager.itemError(a);
          h.manager.itemEnd(a);
        }, !1);
        m.addEventListener("abort", function(b) {
          var d = eb[a];
          delete eb[a];
          for (var c = 0, f = d.length; c < f; c++) {
            var e = d[c];
            if (e.onError) {
              e.onError(b);
            }
          }
          h.manager.itemError(a);
          h.manager.itemEnd(a);
        }, !1);
        void 0 !== this.responseType && (m.responseType = this.responseType);
        void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials);
        m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
        for (l in this.requestHeader) {
          m.setRequestHeader(l, this.requestHeader[l]);
        }
        m.send(null);
      }
      h.manager.itemStart(a);
      return m;
    }
  }, setPath:function(a) {
    this.path = a;
    return this;
  }, setResponseType:function(a) {
    this.responseType = a;
    return this;
  }, setWithCredentials:function(a) {
    this.withCredentials = a;
    return this;
  }, setMimeType:function(a) {
    this.mimeType = a;
    return this;
  }, setRequestHeader:function(a) {
    this.requestHeader = a;
    return this;
  }});
  Object.assign(Gf.prototype, {load:function(a, b, d, c) {
    var h = this, f = new Za(h.manager);
    f.setPath(h.path);
    f.load(a, function(a) {
      b(h.parse(JSON.parse(a)));
    }, d, c);
  }, parse:function(a, b) {
    for (var h = [], d = 0; d < a.length; d++) {
      var c = Ta.parse(a[d]);
      h.push(c);
    }
    b(h);
  }, setPath:function(a) {
    this.path = a;
    return this;
  }});
  Object.assign(Hf.prototype, {load:function(a, b, d, c) {
    function h(h) {
      k.load(a[h], function(a) {
        a = f._parser(a, !0);
        e[h] = {width:a.width, height:a.height, format:a.format, mipmaps:a.mipmaps};
        g += 1;
        6 === g && (1 === a.mipmapCount && (l.minFilter = 1006), l.format = a.format, l.needsUpdate = !0, b && b(l));
      }, d, c);
    }
    var f = this, e = [], l = new oc;
    l.image = e;
    var k = new Za(this.manager);
    k.setPath(this.path);
    k.setResponseType("arraybuffer");
    if (Array.isArray(a)) {
      for (var g = 0, q = 0, m = a.length; q < m; ++q) {
        h(q);
      }
    } else {
      k.load(a, function(a) {
        a = f._parser(a, !0);
        if (a.isCubemap) {
          for (var h = a.mipmaps.length / a.mipmapCount, d = 0; d < h; d++) {
            e[d] = {mipmaps:[]};
            for (var c = 0; c < a.mipmapCount; c++) {
              e[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + c]), e[d].format = a.format, e[d].width = a.width, e[d].height = a.height;
            }
          }
        } else {
          l.image.width = a.width, l.image.height = a.height, l.mipmaps = a.mipmaps;
        }
        1 === a.mipmapCount && (l.minFilter = 1006);
        l.format = a.format;
        l.needsUpdate = !0;
        b && b(l);
      }, d, c);
    }
    return l;
  }, setPath:function(a) {
    this.path = a;
    return this;
  }});
  Object.assign(Be.prototype, {load:function(a, b, d, c) {
    var h = this, f = new l, e = new Za(this.manager);
    e.setResponseType("arraybuffer");
    e.setPath(this.path);
    e.load(a, function(a) {
      if (a = h._parser(a)) {
        void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, f.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001, f.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006, f.minFilter = void 0 !== a.minFilter ? a.minFilter : 1008, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), 
        void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount && (f.minFilter = 1006), f.needsUpdate = !0, b && b(f, a);
      }
    }, d, c);
    return f;
  }, setPath:function(a) {
    this.path = a;
    return this;
  }});
  Object.assign(yd.prototype, {crossOrigin:"anonymous", load:function(a, b, d, c) {
    function h() {
      k.removeEventListener("load", h, !1);
      k.removeEventListener("error", f, !1);
      fc.add(a, this);
      b && b(this);
      e.manager.itemEnd(a);
    }
    function f(b) {
      k.removeEventListener("load", h, !1);
      k.removeEventListener("error", f, !1);
      c && c(b);
      e.manager.itemError(a);
      e.manager.itemEnd(a);
    }
    void 0 === a && (a = "");
    void 0 !== this.path && (a = this.path + a);
    a = this.manager.resolveURL(a);
    var e = this, l = fc.get(a);
    if (void 0 !== l) {
      return e.manager.itemStart(a), setTimeout(function() {
        b && b(l);
        e.manager.itemEnd(a);
      }, 0), l;
    }
    var k = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    k.addEventListener("load", h, !1);
    k.addEventListener("error", f, !1);
    "data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (k.crossOrigin = this.crossOrigin);
    e.manager.itemStart(a);
    k.src = a;
    return k;
  }, setCrossOrigin:function(a) {
    this.crossOrigin = a;
    return this;
  }, setPath:function(a) {
    this.path = a;
    return this;
  }});
  Object.assign(Ce.prototype, {crossOrigin:"anonymous", load:function(a, b, d, c) {
    function h(h) {
      e.load(a[h], function(a) {
        f.images[h] = a;
        l++;
        6 === l && (f.needsUpdate = !0, b && b(f));
      }, void 0, c);
    }
    var f = new za, e = new yd(this.manager);
    e.setCrossOrigin(this.crossOrigin);
    e.setPath(this.path);
    var l = 0;
    for (d = 0; d < a.length; ++d) {
      h(d);
    }
    return f;
  }, setCrossOrigin:function(a) {
    this.crossOrigin = a;
    return this;
  }, setPath:function(a) {
    this.path = a;
    return this;
  }});
  Object.assign(Zd.prototype, {crossOrigin:"anonymous", load:function(a, b, d, c) {
    var h = new n, f = new yd(this.manager);
    f.setCrossOrigin(this.crossOrigin);
    f.setPath(this.path);
    f.load(a, function(d) {
      h.image = d;
      d = 0 < a.search(/\.jpe?g($|\?)/i) || 0 === a.search(/^data:image\/jpeg/);
      h.format = d ? 1022 : 1023;
      h.needsUpdate = !0;
      void 0 !== b && b(h);
    }, d, c);
    return h;
  }, setCrossOrigin:function(a) {
    this.crossOrigin = a;
    return this;
  }, setPath:function(a) {
    this.path = a;
    return this;
  }});
  Object.assign(da.prototype, {getPoint:function() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }, getPointAt:function(a, b) {
    a = this.getUtoTmapping(a);
    return this.getPoint(a, b);
  }, getPoints:function(a) {
    void 0 === a && (a = 5);
    for (var b = [], h = 0; h <= a; h++) {
      b.push(this.getPoint(h / a));
    }
    return b;
  }, getSpacedPoints:function(a) {
    void 0 === a && (a = 5);
    for (var b = [], h = 0; h <= a; h++) {
      b.push(this.getPointAt(h / a));
    }
    return b;
  }, getLength:function() {
    var a = this.getLengths();
    return a[a.length - 1];
  }, getLengths:function(a) {
    void 0 === a && (a = this.arcLengthDivisions);
    if (this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = !1;
    var b = [], h = this.getPoint(0), d, c = 0;
    b.push(0);
    for (d = 1; d <= a; d++) {
      var f = this.getPoint(d / a);
      c += f.distanceTo(h);
      b.push(c);
      h = f;
    }
    return this.cacheArcLengths = b;
  }, updateArcLengths:function() {
    this.needsUpdate = !0;
    this.getLengths();
  }, getUtoTmapping:function(a, b) {
    var h = this.getLengths(), d = h.length;
    b = b ? b : a * h[d - 1];
    for (var c = 0, f = d - 1, e; c <= f;) {
      if (a = Math.floor(c + (f - c) / 2), e = h[a] - b, 0 > e) {
        c = a + 1;
      } else {
        if (0 < e) {
          f = a - 1;
        } else {
          f = a;
          break;
        }
      }
    }
    a = f;
    if (h[a] === b) {
      return a / (d - 1);
    }
    c = h[a];
    return (a + (b - c) / (h[a + 1] - c)) / (d - 1);
  }, getTangent:function(a) {
    var b = a - 1E-4;
    a += 1E-4;
    0 > b && (b = 0);
    1 < a && (a = 1);
    b = this.getPoint(b);
    return this.getPoint(a).clone().sub(b).normalize();
  }, getTangentAt:function(a) {
    a = this.getUtoTmapping(a);
    return this.getTangent(a);
  }, computeFrenetFrames:function(a, d) {
    var h = new f, c = [], e = [], l = [], k = new f, g = new b, q;
    for (q = 0; q <= a; q++) {
      var m = q / a;
      c[q] = this.getTangentAt(m);
      c[q].normalize();
    }
    e[0] = new f;
    l[0] = new f;
    q = Number.MAX_VALUE;
    m = Math.abs(c[0].x);
    var n = Math.abs(c[0].y), t = Math.abs(c[0].z);
    m <= q && (q = m, h.set(1, 0, 0));
    n <= q && (q = n, h.set(0, 1, 0));
    t <= q && h.set(0, 0, 1);
    k.crossVectors(c[0], h).normalize();
    e[0].crossVectors(c[0], k);
    l[0].crossVectors(c[0], e[0]);
    for (q = 1; q <= a; q++) {
      e[q] = e[q - 1].clone(), l[q] = l[q - 1].clone(), k.crossVectors(c[q - 1], c[q]), k.length() > Number.EPSILON && (k.normalize(), h = Math.acos(ia.clamp(c[q - 1].dot(c[q]), -1, 1)), e[q].applyMatrix4(g.makeRotationAxis(k, h))), l[q].crossVectors(c[q], e[q]);
    }
    if (!0 === d) {
      for (h = Math.acos(ia.clamp(e[0].dot(e[a]), -1, 1)), h /= a, 0 < c[0].dot(k.crossVectors(e[0], e[a])) && (h = -h), q = 1; q <= a; q++) {
        e[q].applyMatrix4(g.makeRotationAxis(c[q], h * q)), l[q].crossVectors(c[q], e[q]);
      }
    }
    return {tangents:c, normals:e, binormals:l};
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.arcLengthDivisions = a.arcLengthDivisions;
    return this;
  }, toJSON:function() {
    var a = {metadata:{version:4.5, type:"Curve", generator:"Curve.toJSON"}};
    a.arcLengthDivisions = this.arcLengthDivisions;
    a.type = this.type;
    return a;
  }, fromJSON:function(a) {
    this.arcLengthDivisions = a.arcLengthDivisions;
    return this;
  }});
  Oa.prototype = Object.create(da.prototype);
  Oa.prototype.constructor = Oa;
  Oa.prototype.isEllipseCurve = !0;
  Oa.prototype.getPoint = function(a, b) {
    b = b || new g;
    for (var h = 2 * Math.PI, d = this.aEndAngle - this.aStartAngle, c = Math.abs(d) < Number.EPSILON; 0 > d;) {
      d += h;
    }
    for (; d > h;) {
      d -= h;
    }
    d < Number.EPSILON && (d = c ? 0 : h);
    !0 !== this.aClockwise || c || (d = d === h ? -h : d - h);
    h = this.aStartAngle + a * d;
    a = this.aX + this.xRadius * Math.cos(h);
    var f = this.aY + this.yRadius * Math.sin(h);
    0 !== this.aRotation && (h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), c = a - this.aX, f -= this.aY, a = c * h - f * d + this.aX, f = c * d + f * h + this.aY);
    return b.set(a, f);
  };
  Oa.prototype.copy = function(a) {
    da.prototype.copy.call(this, a);
    this.aX = a.aX;
    this.aY = a.aY;
    this.xRadius = a.xRadius;
    this.yRadius = a.yRadius;
    this.aStartAngle = a.aStartAngle;
    this.aEndAngle = a.aEndAngle;
    this.aClockwise = a.aClockwise;
    this.aRotation = a.aRotation;
    return this;
  };
  Oa.prototype.toJSON = function() {
    var a = da.prototype.toJSON.call(this);
    a.aX = this.aX;
    a.aY = this.aY;
    a.xRadius = this.xRadius;
    a.yRadius = this.yRadius;
    a.aStartAngle = this.aStartAngle;
    a.aEndAngle = this.aEndAngle;
    a.aClockwise = this.aClockwise;
    a.aRotation = this.aRotation;
    return a;
  };
  Oa.prototype.fromJSON = function(a) {
    da.prototype.fromJSON.call(this, a);
    this.aX = a.aX;
    this.aY = a.aY;
    this.xRadius = a.xRadius;
    this.yRadius = a.yRadius;
    this.aStartAngle = a.aStartAngle;
    this.aEndAngle = a.aEndAngle;
    this.aClockwise = a.aClockwise;
    this.aRotation = a.aRotation;
    return this;
  };
  Ec.prototype = Object.create(Oa.prototype);
  Ec.prototype.constructor = Ec;
  Ec.prototype.isArcCurve = !0;
  var le = new f, Ze = new De, $e = new De, af = new De;
  Ea.prototype = Object.create(da.prototype);
  Ea.prototype.constructor = Ea;
  Ea.prototype.isCatmullRomCurve3 = !0;
  Ea.prototype.getPoint = function(a, b) {
    b = b || new f;
    var h = this.points, d = h.length;
    a *= d - (this.closed ? 0 : 1);
    var c = Math.floor(a);
    a -= c;
    this.closed ? c += 0 < c ? 0 : (Math.floor(Math.abs(c) / d) + 1) * d : 0 === a && c === d - 1 && (c = d - 2, a = 1);
    if (this.closed || 0 < c) {
      var e = h[(c - 1) % d];
    } else {
      le.subVectors(h[0], h[1]).add(h[0]), e = le;
    }
    var l = h[c % d], k = h[(c + 1) % d];
    this.closed || c + 2 < d ? h = h[(c + 2) % d] : (le.subVectors(h[d - 1], h[d - 2]).add(h[d - 1]), h = le);
    if ("centripetal" === this.curveType || "chordal" === this.curveType) {
      var g = "chordal" === this.curveType ? .5 : .25;
      d = Math.pow(e.distanceToSquared(l), g);
      c = Math.pow(l.distanceToSquared(k), g);
      g = Math.pow(k.distanceToSquared(h), g);
      1E-4 > c && (c = 1);
      1E-4 > d && (d = c);
      1E-4 > g && (g = c);
      Ze.initNonuniformCatmullRom(e.x, l.x, k.x, h.x, d, c, g);
      $e.initNonuniformCatmullRom(e.y, l.y, k.y, h.y, d, c, g);
      af.initNonuniformCatmullRom(e.z, l.z, k.z, h.z, d, c, g);
    } else {
      "catmullrom" === this.curveType && (Ze.initCatmullRom(e.x, l.x, k.x, h.x, this.tension), $e.initCatmullRom(e.y, l.y, k.y, h.y, this.tension), af.initCatmullRom(e.z, l.z, k.z, h.z, this.tension));
    }
    b.set(Ze.calc(a), $e.calc(a), af.calc(a));
    return b;
  };
  Ea.prototype.copy = function(a) {
    da.prototype.copy.call(this, a);
    this.points = [];
    for (var b = 0, h = a.points.length; b < h; b++) {
      this.points.push(a.points[b].clone());
    }
    this.closed = a.closed;
    this.curveType = a.curveType;
    this.tension = a.tension;
    return this;
  };
  Ea.prototype.toJSON = function() {
    var a = da.prototype.toJSON.call(this);
    a.points = [];
    for (var b = 0, d = this.points.length; b < d; b++) {
      a.points.push(this.points[b].toArray());
    }
    a.closed = this.closed;
    a.curveType = this.curveType;
    a.tension = this.tension;
    return a;
  };
  Ea.prototype.fromJSON = function(a) {
    da.prototype.fromJSON.call(this, a);
    this.points = [];
    for (var b = 0, h = a.points.length; b < h; b++) {
      var d = a.points[b];
      this.points.push((new f).fromArray(d));
    }
    this.closed = a.closed;
    this.curveType = a.curveType;
    this.tension = a.tension;
    return this;
  };
  $a.prototype = Object.create(da.prototype);
  $a.prototype.constructor = $a;
  $a.prototype.isCubicBezierCurve = !0;
  $a.prototype.getPoint = function(a, b) {
    b = b || new g;
    var h = this.v0, d = this.v1, c = this.v2, f = this.v3;
    b.set(Ad(a, h.x, d.x, c.x, f.x), Ad(a, h.y, d.y, c.y, f.y));
    return b;
  };
  $a.prototype.copy = function(a) {
    da.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    this.v3.copy(a.v3);
    return this;
  };
  $a.prototype.toJSON = function() {
    var a = da.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    a.v3 = this.v3.toArray();
    return a;
  };
  $a.prototype.fromJSON = function(a) {
    da.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    this.v3.fromArray(a.v3);
    return this;
  };
  mb.prototype = Object.create(da.prototype);
  mb.prototype.constructor = mb;
  mb.prototype.isCubicBezierCurve3 = !0;
  mb.prototype.getPoint = function(a, b) {
    b = b || new f;
    var h = this.v0, d = this.v1, c = this.v2, e = this.v3;
    b.set(Ad(a, h.x, d.x, c.x, e.x), Ad(a, h.y, d.y, c.y, e.y), Ad(a, h.z, d.z, c.z, e.z));
    return b;
  };
  mb.prototype.copy = function(a) {
    da.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    this.v3.copy(a.v3);
    return this;
  };
  mb.prototype.toJSON = function() {
    var a = da.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    a.v3 = this.v3.toArray();
    return a;
  };
  mb.prototype.fromJSON = function(a) {
    da.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    this.v3.fromArray(a.v3);
    return this;
  };
  Ma.prototype = Object.create(da.prototype);
  Ma.prototype.constructor = Ma;
  Ma.prototype.isLineCurve = !0;
  Ma.prototype.getPoint = function(a, b) {
    b = b || new g;
    1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
    return b;
  };
  Ma.prototype.getPointAt = function(a, b) {
    return this.getPoint(a, b);
  };
  Ma.prototype.getTangent = function() {
    return this.v2.clone().sub(this.v1).normalize();
  };
  Ma.prototype.copy = function(a) {
    da.prototype.copy.call(this, a);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  Ma.prototype.toJSON = function() {
    var a = da.prototype.toJSON.call(this);
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  Ma.prototype.fromJSON = function(a) {
    da.prototype.fromJSON.call(this, a);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  ab.prototype = Object.create(da.prototype);
  ab.prototype.constructor = ab;
  ab.prototype.isLineCurve3 = !0;
  ab.prototype.getPoint = function(a, b) {
    b = b || new f;
    1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
    return b;
  };
  ab.prototype.getPointAt = function(a, b) {
    return this.getPoint(a, b);
  };
  ab.prototype.copy = function(a) {
    da.prototype.copy.call(this, a);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  ab.prototype.toJSON = function() {
    var a = da.prototype.toJSON.call(this);
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  ab.prototype.fromJSON = function(a) {
    da.prototype.fromJSON.call(this, a);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  bb.prototype = Object.create(da.prototype);
  bb.prototype.constructor = bb;
  bb.prototype.isQuadraticBezierCurve = !0;
  bb.prototype.getPoint = function(a, b) {
    b = b || new g;
    var h = this.v0, d = this.v1, c = this.v2;
    b.set(zd(a, h.x, d.x, c.x), zd(a, h.y, d.y, c.y));
    return b;
  };
  bb.prototype.copy = function(a) {
    da.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  bb.prototype.toJSON = function() {
    var a = da.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  bb.prototype.fromJSON = function(a) {
    da.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  nb.prototype = Object.create(da.prototype);
  nb.prototype.constructor = nb;
  nb.prototype.isQuadraticBezierCurve3 = !0;
  nb.prototype.getPoint = function(a, b) {
    b = b || new f;
    var h = this.v0, d = this.v1, c = this.v2;
    b.set(zd(a, h.x, d.x, c.x), zd(a, h.y, d.y, c.y), zd(a, h.z, d.z, c.z));
    return b;
  };
  nb.prototype.copy = function(a) {
    da.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  nb.prototype.toJSON = function() {
    var a = da.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  nb.prototype.fromJSON = function(a) {
    da.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  cb.prototype = Object.create(da.prototype);
  cb.prototype.constructor = cb;
  cb.prototype.isSplineCurve = !0;
  cb.prototype.getPoint = function(a, b) {
    b = b || new g;
    var h = this.points, d = (h.length - 1) * a;
    a = Math.floor(d);
    d -= a;
    var c = h[0 === a ? a : a - 1], f = h[a], e = h[a > h.length - 2 ? h.length - 1 : a + 1];
    h = h[a > h.length - 3 ? h.length - 1 : a + 2];
    b.set(If(d, c.x, f.x, e.x, h.x), If(d, c.y, f.y, e.y, h.y));
    return b;
  };
  cb.prototype.copy = function(a) {
    da.prototype.copy.call(this, a);
    this.points = [];
    for (var b = 0, h = a.points.length; b < h; b++) {
      this.points.push(a.points[b].clone());
    }
    return this;
  };
  cb.prototype.toJSON = function() {
    var a = da.prototype.toJSON.call(this);
    a.points = [];
    for (var b = 0, d = this.points.length; b < d; b++) {
      a.points.push(this.points[b].toArray());
    }
    return a;
  };
  cb.prototype.fromJSON = function(a) {
    da.prototype.fromJSON.call(this, a);
    this.points = [];
    for (var b = 0, h = a.points.length; b < h; b++) {
      var d = a.points[b];
      this.points.push((new g).fromArray(d));
    }
    return this;
  };
  var bf = Object.freeze({ArcCurve:Ec, CatmullRomCurve3:Ea, CubicBezierCurve:$a, CubicBezierCurve3:mb, EllipseCurve:Oa, LineCurve:Ma, LineCurve3:ab, QuadraticBezierCurve:bb, QuadraticBezierCurve3:nb, SplineCurve:cb});
  yb.prototype = Object.assign(Object.create(da.prototype), {constructor:yb, add:function(a) {
    this.curves.push(a);
  }, closePath:function() {
    var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
    a.equals(b) || this.curves.push(new Ma(b, a));
  }, getPoint:function(a) {
    var b = a * this.getLength(), h = this.getCurveLengths();
    for (a = 0; a < h.length;) {
      if (h[a] >= b) {
        return b = h[a] - b, a = this.curves[a], h = a.getLength(), a.getPointAt(0 === h ? 0 : 1 - b / h);
      }
      a++;
    }
    return null;
  }, getLength:function() {
    var a = this.getCurveLengths();
    return a[a.length - 1];
  }, updateArcLengths:function() {
    this.needsUpdate = !0;
    this.cacheLengths = null;
    this.getCurveLengths();
  }, getCurveLengths:function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    for (var a = [], b = 0, d = 0, c = this.curves.length; d < c; d++) {
      b += this.curves[d].getLength(), a.push(b);
    }
    return this.cacheLengths = a;
  }, getSpacedPoints:function(a) {
    void 0 === a && (a = 40);
    for (var b = [], h = 0; h <= a; h++) {
      b.push(this.getPoint(h / a));
    }
    this.autoClose && b.push(b[0]);
    return b;
  }, getPoints:function(a) {
    a = a || 12;
    for (var b = [], h, d = 0, c = this.curves; d < c.length; d++) {
      var f = c[d];
      f = f.getPoints(f && f.isEllipseCurve ? 2 * a : f && (f.isLineCurve || f.isLineCurve3) ? 1 : f && f.isSplineCurve ? a * f.points.length : a);
      for (var e = 0; e < f.length; e++) {
        var l = f[e];
        h && h.equals(l) || (b.push(l), h = l);
      }
    }
    this.autoClose && 1 < b.length && !b[b.length - 1].equals(b[0]) && b.push(b[0]);
    return b;
  }, copy:function(a) {
    da.prototype.copy.call(this, a);
    this.curves = [];
    for (var b = 0, h = a.curves.length; b < h; b++) {
      this.curves.push(a.curves[b].clone());
    }
    this.autoClose = a.autoClose;
    return this;
  }, toJSON:function() {
    var a = da.prototype.toJSON.call(this);
    a.autoClose = this.autoClose;
    a.curves = [];
    for (var b = 0, d = this.curves.length; b < d; b++) {
      a.curves.push(this.curves[b].toJSON());
    }
    return a;
  }, fromJSON:function(a) {
    da.prototype.fromJSON.call(this, a);
    this.autoClose = a.autoClose;
    this.curves = [];
    for (var b = 0, h = a.curves.length; b < h; b++) {
      var d = a.curves[b];
      this.curves.push((new bf[d.type]).fromJSON(d));
    }
    return this;
  }});
  db.prototype = Object.assign(Object.create(yb.prototype), {constructor:db, setFromPoints:function(a) {
    this.moveTo(a[0].x, a[0].y);
    for (var b = 1, h = a.length; b < h; b++) {
      this.lineTo(a[b].x, a[b].y);
    }
  }, moveTo:function(a, b) {
    this.currentPoint.set(a, b);
  }, lineTo:function(a, b) {
    var h = new Ma(this.currentPoint.clone(), new g(a, b));
    this.curves.push(h);
    this.currentPoint.set(a, b);
  }, quadraticCurveTo:function(a, b, d, c) {
    a = new bb(this.currentPoint.clone(), new g(a, b), new g(d, c));
    this.curves.push(a);
    this.currentPoint.set(d, c);
  }, bezierCurveTo:function(a, b, d, c, f, e) {
    a = new $a(this.currentPoint.clone(), new g(a, b), new g(d, c), new g(f, e));
    this.curves.push(a);
    this.currentPoint.set(f, e);
  }, splineThru:function(a) {
    var b = [this.currentPoint.clone()].concat(a);
    b = new cb(b);
    this.curves.push(b);
    this.currentPoint.copy(a[a.length - 1]);
  }, arc:function(a, b, d, c, f, e) {
    this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, d, c, f, e);
  }, absarc:function(a, b, d, c, f, e) {
    this.absellipse(a, b, d, d, c, f, e);
  }, ellipse:function(a, b, d, c, f, e, l, k) {
    this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, d, c, f, e, l, k);
  }, absellipse:function(a, b, d, c, f, e, l, k) {
    a = new Oa(a, b, d, c, f, e, l, k);
    0 < this.curves.length && (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y));
    this.curves.push(a);
    a = a.getPoint(1);
    this.currentPoint.copy(a);
  }, copy:function(a) {
    yb.prototype.copy.call(this, a);
    this.currentPoint.copy(a.currentPoint);
    return this;
  }, toJSON:function() {
    var a = yb.prototype.toJSON.call(this);
    a.currentPoint = this.currentPoint.toArray();
    return a;
  }, fromJSON:function(a) {
    yb.prototype.fromJSON.call(this, a);
    this.currentPoint.fromArray(a.currentPoint);
    return this;
  }});
  Lb.prototype = Object.assign(Object.create(db.prototype), {constructor:Lb, getPointsHoles:function(a) {
    for (var b = [], h = 0, d = this.holes.length; h < d; h++) {
      b[h] = this.holes[h].getPoints(a);
    }
    return b;
  }, extractPoints:function(a) {
    return {shape:this.getPoints(a), holes:this.getPointsHoles(a)};
  }, copy:function(a) {
    db.prototype.copy.call(this, a);
    this.holes = [];
    for (var b = 0, h = a.holes.length; b < h; b++) {
      this.holes.push(a.holes[b].clone());
    }
    return this;
  }, toJSON:function() {
    var a = db.prototype.toJSON.call(this);
    a.uuid = this.uuid;
    a.holes = [];
    for (var b = 0, d = this.holes.length; b < d; b++) {
      a.holes.push(this.holes[b].toJSON());
    }
    return a;
  }, fromJSON:function(a) {
    db.prototype.fromJSON.call(this, a);
    this.uuid = a.uuid;
    this.holes = [];
    for (var b = 0, h = a.holes.length; b < h; b++) {
      var d = a.holes[b];
      this.holes.push((new db).fromJSON(d));
    }
    return this;
  }});
  ta.prototype = Object.assign(Object.create(G.prototype), {constructor:ta, isLight:!0, copy:function(a) {
    G.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.intensity = a.intensity;
    return this;
  }, toJSON:function(a) {
    a = G.prototype.toJSON.call(this, a);
    a.object.color = this.color.getHex();
    a.object.intensity = this.intensity;
    void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex());
    void 0 !== this.distance && (a.object.distance = this.distance);
    void 0 !== this.angle && (a.object.angle = this.angle);
    void 0 !== this.decay && (a.object.decay = this.decay);
    void 0 !== this.penumbra && (a.object.penumbra = this.penumbra);
    void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON());
    return a;
  }});
  $d.prototype = Object.assign(Object.create(ta.prototype), {constructor:$d, isHemisphereLight:!0, copy:function(a) {
    ta.prototype.copy.call(this, a);
    this.groundColor.copy(a.groundColor);
    return this;
  }});
  Object.assign(ec.prototype, {copy:function(a) {
    this.camera = a.camera.clone();
    this.bias = a.bias;
    this.radius = a.radius;
    this.mapSize.copy(a.mapSize);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, toJSON:function() {
    var a = {};
    0 !== this.bias && (a.bias = this.bias);
    1 !== this.radius && (a.radius = this.radius);
    if (512 !== this.mapSize.x || 512 !== this.mapSize.y) {
      a.mapSize = this.mapSize.toArray();
    }
    a.camera = this.camera.toJSON(!1).object;
    delete a.camera.matrix;
    return a;
  }});
  ae.prototype = Object.assign(Object.create(ec.prototype), {constructor:ae, isSpotLightShadow:!0, update:function(a) {
    var b = this.camera, h = 2 * ia.RAD2DEG * a.angle, d = this.mapSize.width / this.mapSize.height;
    a = a.distance || b.far;
    if (h !== b.fov || d !== b.aspect || a !== b.far) {
      b.fov = h, b.aspect = d, b.far = a, b.updateProjectionMatrix();
    }
  }});
  be.prototype = Object.assign(Object.create(ta.prototype), {constructor:be, isSpotLight:!0, copy:function(a) {
    ta.prototype.copy.call(this, a);
    this.distance = a.distance;
    this.angle = a.angle;
    this.penumbra = a.penumbra;
    this.decay = a.decay;
    this.target = a.target.clone();
    this.shadow = a.shadow.clone();
    return this;
  }});
  ce.prototype = Object.assign(Object.create(ta.prototype), {constructor:ce, isPointLight:!0, copy:function(a) {
    ta.prototype.copy.call(this, a);
    this.distance = a.distance;
    this.decay = a.decay;
    this.shadow = a.shadow.clone();
    return this;
  }});
  Bd.prototype = Object.assign(Object.create(jb.prototype), {constructor:Bd, isOrthographicCamera:!0, copy:function(a, b) {
    jb.prototype.copy.call(this, a, b);
    this.left = a.left;
    this.right = a.right;
    this.top = a.top;
    this.bottom = a.bottom;
    this.near = a.near;
    this.far = a.far;
    this.zoom = a.zoom;
    this.view = null === a.view ? null : Object.assign({}, a.view);
    return this;
  }, setViewOffset:function(a, b, d, c, f, e) {
    null === this.view && (this.view = {enabled:!0, fullWidth:1, fullHeight:1, offsetX:0, offsetY:0, width:1, height:1});
    this.view.enabled = !0;
    this.view.fullWidth = a;
    this.view.fullHeight = b;
    this.view.offsetX = d;
    this.view.offsetY = c;
    this.view.width = f;
    this.view.height = e;
    this.updateProjectionMatrix();
  }, clearViewOffset:function() {
    null !== this.view && (this.view.enabled = !1);
    this.updateProjectionMatrix();
  }, updateProjectionMatrix:function() {
    var a = (this.right - this.left) / (2 * this.zoom), b = (this.top - this.bottom) / (2 * this.zoom), d = (this.right + this.left) / 2, c = (this.top + this.bottom) / 2, f = d - a;
    d += a;
    a = c + b;
    b = c - b;
    if (null !== this.view && this.view.enabled) {
      d = this.zoom / (this.view.width / this.view.fullWidth);
      b = this.zoom / (this.view.height / this.view.fullHeight);
      var e = (this.right - this.left) / this.view.width;
      c = (this.top - this.bottom) / this.view.height;
      f += this.view.offsetX / d * e;
      d = f + this.view.width / d * e;
      a -= this.view.offsetY / b * c;
      b = a - this.view.height / b * c;
    }
    this.projectionMatrix.makeOrthographic(f, d, a, b, this.near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  }, toJSON:function(a) {
    a = G.prototype.toJSON.call(this, a);
    a.object.zoom = this.zoom;
    a.object.left = this.left;
    a.object.right = this.right;
    a.object.top = this.top;
    a.object.bottom = this.bottom;
    a.object.near = this.near;
    a.object.far = this.far;
    null !== this.view && (a.object.view = Object.assign({}, this.view));
    return a;
  }});
  de.prototype = Object.assign(Object.create(ec.prototype), {constructor:de});
  ee.prototype = Object.assign(Object.create(ta.prototype), {constructor:ee, isDirectionalLight:!0, copy:function(a) {
    ta.prototype.copy.call(this, a);
    this.target = a.target.clone();
    this.shadow = a.shadow.clone();
    return this;
  }});
  fe.prototype = Object.assign(Object.create(ta.prototype), {constructor:fe, isAmbientLight:!0});
  ge.prototype = Object.assign(Object.create(ta.prototype), {constructor:ge, isRectAreaLight:!0, copy:function(a) {
    ta.prototype.copy.call(this, a);
    this.width = a.width;
    this.height = a.height;
    return this;
  }, toJSON:function(a) {
    a = ta.prototype.toJSON.call(this, a);
    a.object.width = this.width;
    a.object.height = this.height;
    return a;
  }});
  Object.assign(he.prototype, {load:function(a, b, d, c) {
    var h = this, f = new Za(h.manager);
    f.setPath(h.path);
    f.load(a, function(a) {
      b(h.parse(JSON.parse(a)));
    }, d, c);
  }, parse:function(a) {
    function h(a) {
      void 0 === d[a] && console.warn("THREE.MaterialLoader: Undefined texture", a);
      return d[a];
    }
    var d = this.textures, c = new Cg[a.type];
    void 0 !== a.uuid && (c.uuid = a.uuid);
    void 0 !== a.name && (c.name = a.name);
    void 0 !== a.color && c.color.setHex(a.color);
    void 0 !== a.roughness && (c.roughness = a.roughness);
    void 0 !== a.metalness && (c.metalness = a.metalness);
    void 0 !== a.emissive && c.emissive.setHex(a.emissive);
    void 0 !== a.specular && c.specular.setHex(a.specular);
    void 0 !== a.shininess && (c.shininess = a.shininess);
    void 0 !== a.clearCoat && (c.clearCoat = a.clearCoat);
    void 0 !== a.clearCoatRoughness && (c.clearCoatRoughness = a.clearCoatRoughness);
    void 0 !== a.vertexColors && (c.vertexColors = a.vertexColors);
    void 0 !== a.fog && (c.fog = a.fog);
    void 0 !== a.flatShading && (c.flatShading = a.flatShading);
    void 0 !== a.blending && (c.blending = a.blending);
    void 0 !== a.combine && (c.combine = a.combine);
    void 0 !== a.side && (c.side = a.side);
    void 0 !== a.opacity && (c.opacity = a.opacity);
    void 0 !== a.transparent && (c.transparent = a.transparent);
    void 0 !== a.alphaTest && (c.alphaTest = a.alphaTest);
    void 0 !== a.depthTest && (c.depthTest = a.depthTest);
    void 0 !== a.depthWrite && (c.depthWrite = a.depthWrite);
    void 0 !== a.colorWrite && (c.colorWrite = a.colorWrite);
    void 0 !== a.wireframe && (c.wireframe = a.wireframe);
    void 0 !== a.wireframeLinewidth && (c.wireframeLinewidth = a.wireframeLinewidth);
    void 0 !== a.wireframeLinecap && (c.wireframeLinecap = a.wireframeLinecap);
    void 0 !== a.wireframeLinejoin && (c.wireframeLinejoin = a.wireframeLinejoin);
    void 0 !== a.rotation && (c.rotation = a.rotation);
    1 !== a.linewidth && (c.linewidth = a.linewidth);
    void 0 !== a.dashSize && (c.dashSize = a.dashSize);
    void 0 !== a.gapSize && (c.gapSize = a.gapSize);
    void 0 !== a.scale && (c.scale = a.scale);
    void 0 !== a.polygonOffset && (c.polygonOffset = a.polygonOffset);
    void 0 !== a.polygonOffsetFactor && (c.polygonOffsetFactor = a.polygonOffsetFactor);
    void 0 !== a.polygonOffsetUnits && (c.polygonOffsetUnits = a.polygonOffsetUnits);
    void 0 !== a.skinning && (c.skinning = a.skinning);
    void 0 !== a.morphTargets && (c.morphTargets = a.morphTargets);
    void 0 !== a.dithering && (c.dithering = a.dithering);
    void 0 !== a.visible && (c.visible = a.visible);
    void 0 !== a.userData && (c.userData = a.userData);
    if (void 0 !== a.uniforms) {
      for (var e in a.uniforms) {
        var l = a.uniforms[e];
        c.uniforms[e] = {};
        switch(l.type) {
          case "t":
            c.uniforms[e].value = h(l.value);
            break;
          case "c":
            c.uniforms[e].value = (new z).setHex(l.value);
            break;
          case "v2":
            c.uniforms[e].value = (new g).fromArray(l.value);
            break;
          case "v3":
            c.uniforms[e].value = (new f).fromArray(l.value);
            break;
          case "v4":
            c.uniforms[e].value = (new p).fromArray(l.value);
            break;
          case "m3":
            c.uniforms[e].value = (new k).fromArray(l.value);
          case "m4":
            c.uniforms[e].value = (new b).fromArray(l.value);
            break;
          default:
            c.uniforms[e].value = l.value;
        }
      }
    }
    void 0 !== a.defines && (c.defines = a.defines);
    void 0 !== a.vertexShader && (c.vertexShader = a.vertexShader);
    void 0 !== a.fragmentShader && (c.fragmentShader = a.fragmentShader);
    if (void 0 !== a.extensions) {
      for (var q in a.extensions) {
        c.extensions[q] = a.extensions[q];
      }
    }
    void 0 !== a.shading && (c.flatShading = 1 === a.shading);
    void 0 !== a.size && (c.size = a.size);
    void 0 !== a.sizeAttenuation && (c.sizeAttenuation = a.sizeAttenuation);
    void 0 !== a.map && (c.map = h(a.map));
    void 0 !== a.alphaMap && (c.alphaMap = h(a.alphaMap), c.transparent = !0);
    void 0 !== a.bumpMap && (c.bumpMap = h(a.bumpMap));
    void 0 !== a.bumpScale && (c.bumpScale = a.bumpScale);
    void 0 !== a.normalMap && (c.normalMap = h(a.normalMap));
    void 0 !== a.normalMapType && (c.normalMapType = a.normalMapType);
    void 0 !== a.normalScale && (e = a.normalScale, !1 === Array.isArray(e) && (e = [e, e]), c.normalScale = (new g).fromArray(e));
    void 0 !== a.displacementMap && (c.displacementMap = h(a.displacementMap));
    void 0 !== a.displacementScale && (c.displacementScale = a.displacementScale);
    void 0 !== a.displacementBias && (c.displacementBias = a.displacementBias);
    void 0 !== a.roughnessMap && (c.roughnessMap = h(a.roughnessMap));
    void 0 !== a.metalnessMap && (c.metalnessMap = h(a.metalnessMap));
    void 0 !== a.emissiveMap && (c.emissiveMap = h(a.emissiveMap));
    void 0 !== a.emissiveIntensity && (c.emissiveIntensity = a.emissiveIntensity);
    void 0 !== a.specularMap && (c.specularMap = h(a.specularMap));
    void 0 !== a.envMap && (c.envMap = h(a.envMap));
    void 0 !== a.envMapIntensity && (c.envMapIntensity = a.envMapIntensity);
    void 0 !== a.reflectivity && (c.reflectivity = a.reflectivity);
    void 0 !== a.lightMap && (c.lightMap = h(a.lightMap));
    void 0 !== a.lightMapIntensity && (c.lightMapIntensity = a.lightMapIntensity);
    void 0 !== a.aoMap && (c.aoMap = h(a.aoMap));
    void 0 !== a.aoMapIntensity && (c.aoMapIntensity = a.aoMapIntensity);
    void 0 !== a.gradientMap && (c.gradientMap = h(a.gradientMap));
    return c;
  }, setPath:function(a) {
    this.path = a;
    return this;
  }, setTextures:function(a) {
    this.textures = a;
    return this;
  }});
  var cf = {decodeText:function(a) {
    if ("undefined" !== typeof TextDecoder) {
      return (new TextDecoder).decode(a);
    }
    for (var b = "", h = 0, d = a.length; h < d; h++) {
      b += String.fromCharCode(a[h]);
    }
    return decodeURIComponent(escape(b));
  }, extractUrlBase:function(a) {
    var b = a.lastIndexOf("/");
    return -1 === b ? "./" : a.substr(0, b + 1);
  }};
  Object.assign(Ee.prototype, {load:function(a, b, d, c) {
    var h = this, f = new Za(h.manager);
    f.setPath(h.path);
    f.load(a, function(a) {
      b(h.parse(JSON.parse(a)));
    }, d, c);
  }, parse:function(a) {
    var b = new O, h = a.data.index;
    if (void 0 !== h) {
      var d = new df[h.type](h.array);
      b.setIndex(new K(d, 1));
    }
    h = a.data.attributes;
    for (var c in h) {
      var e = h[c];
      d = new df[e.type](e.array);
      d = new K(d, e.itemSize, e.normalized);
      void 0 !== e.name && (d.name = e.name);
      b.addAttribute(c, d);
    }
    var l = a.data.morphAttributes;
    if (l) {
      for (c in l) {
        var k = l[c], g = [];
        h = 0;
        for (var q = k.length; h < q; h++) {
          e = k[h], d = new df[e.type](e.array), d = new K(d, e.itemSize, e.normalized), void 0 !== e.name && (d.name = e.name), g.push(d);
        }
        b.morphAttributes[c] = g;
      }
    }
    c = a.data.groups || a.data.drawcalls || a.data.offsets;
    if (void 0 !== c) {
      for (h = 0, e = c.length; h !== e; ++h) {
        d = c[h], b.addGroup(d.start, d.count, d.materialIndex);
      }
    }
    h = a.data.boundingSphere;
    void 0 !== h && (c = new f, void 0 !== h.center && c.fromArray(h.center), b.boundingSphere = new w(c, h.radius));
    a.name && (b.name = a.name);
    a.userData && (b.userData = a.userData);
    return b;
  }, setPath:function(a) {
    this.path = a;
    return this;
  }});
  var df = {Int8Array:Int8Array, Uint8Array:Uint8Array, Uint8ClampedArray:"undefined" !== typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array:Int16Array, Uint16Array:Uint16Array, Int32Array:Int32Array, Uint32Array:Uint32Array, Float32Array:Float32Array, Float64Array:Float64Array};
  Object.assign(Fe.prototype, {crossOrigin:"anonymous", load:function(a, b, d, c) {
    var h = this, f = void 0 === this.path ? cf.extractUrlBase(a) : this.path;
    this.resourcePath = this.resourcePath || f;
    f = new Za(h.manager);
    f.setPath(this.path);
    f.load(a, function(d) {
      var f = null;
      try {
        f = JSON.parse(d);
      } catch (Ia) {
        void 0 !== c && c(Ia);
        console.error("THREE:ObjectLoader: Can't parse " + a + ".", Ia.message);
        return;
      }
      d = f.metadata;
      void 0 === d || void 0 === d.type || "geometry" === d.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + a) : h.parse(f, b);
    }, d, c);
  }, setPath:function(a) {
    this.path = a;
    return this;
  }, setResourcePath:function(a) {
    this.resourcePath = a;
    return this;
  }, setCrossOrigin:function(a) {
    this.crossOrigin = a;
    return this;
  }, parse:function(a, b) {
    var h = this.parseShape(a.shapes);
    h = this.parseGeometries(a.geometries, h);
    var d = this.parseImages(a.images, function() {
      void 0 !== b && b(c);
    });
    d = this.parseTextures(a.textures, d);
    d = this.parseMaterials(a.materials, d);
    var c = this.parseObject(a.object, h, d);
    a.animations && (c.animations = this.parseAnimations(a.animations));
    void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(c);
    return c;
  }, parseShape:function(a) {
    var b = {};
    if (void 0 !== a) {
      for (var h = 0, d = a.length; h < d; h++) {
        var c = (new Lb).fromJSON(a[h]);
        b[c.uuid] = c;
      }
    }
    return b;
  }, parseGeometries:function(a, b) {
    var h = {};
    if (void 0 !== a) {
      for (var d = new Ee, c = 0, f = a.length; c < f; c++) {
        var e = a[c];
        switch(e.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            var l = new Ha[e.type](e.width, e.height, e.widthSegments, e.heightSegments);
            break;
          case "BoxGeometry":
          case "BoxBufferGeometry":
          case "CubeGeometry":
            l = new Ha[e.type](e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
            break;
          case "CircleGeometry":
          case "CircleBufferGeometry":
            l = new Ha[e.type](e.radius, e.segments, e.thetaStart, e.thetaLength);
            break;
          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            l = new Ha[e.type](e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
            break;
          case "ConeGeometry":
          case "ConeBufferGeometry":
            l = new Ha[e.type](e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
            break;
          case "SphereGeometry":
          case "SphereBufferGeometry":
            l = new Ha[e.type](e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
            break;
          case "DodecahedronGeometry":
          case "DodecahedronBufferGeometry":
          case "IcosahedronGeometry":
          case "IcosahedronBufferGeometry":
          case "OctahedronGeometry":
          case "OctahedronBufferGeometry":
          case "TetrahedronGeometry":
          case "TetrahedronBufferGeometry":
            l = new Ha[e.type](e.radius, e.detail);
            break;
          case "RingGeometry":
          case "RingBufferGeometry":
            l = new Ha[e.type](e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
            break;
          case "TorusGeometry":
          case "TorusBufferGeometry":
            l = new Ha[e.type](e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
            break;
          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            l = new Ha[e.type](e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
            break;
          case "TubeGeometry":
          case "TubeBufferGeometry":
            l = new Ha[e.type]((new bf[e.path.type]).fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed);
            break;
          case "LatheGeometry":
          case "LatheBufferGeometry":
            l = new Ha[e.type](e.points, e.segments, e.phiStart, e.phiLength);
            break;
          case "PolyhedronGeometry":
          case "PolyhedronBufferGeometry":
            l = new Ha[e.type](e.vertices, e.indices, e.radius, e.details);
            break;
          case "ShapeGeometry":
          case "ShapeBufferGeometry":
            l = [];
            for (var k = 0, g = e.shapes.length; k < g; k++) {
              var q = b[e.shapes[k]];
              l.push(q);
            }
            l = new Ha[e.type](l, e.curveSegments);
            break;
          case "ExtrudeGeometry":
          case "ExtrudeBufferGeometry":
            l = [];
            k = 0;
            for (g = e.shapes.length; k < g; k++) {
              q = b[e.shapes[k]], l.push(q);
            }
            k = e.options.extrudePath;
            void 0 !== k && (e.options.extrudePath = (new bf[k.type]).fromJSON(k));
            l = new Ha[e.type](l, e.options);
            break;
          case "BufferGeometry":
            l = d.parse(e);
            break;
          case "Geometry":
            "THREE" in window && "LegacyJSONLoader" in THREE ? l = (new THREE.LegacyJSONLoader).parse(e, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
            break;
          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + e.type + '"');
            continue;
        }
        l.uuid = e.uuid;
        void 0 !== e.name && (l.name = e.name);
        !0 === l.isBufferGeometry && void 0 !== e.userData && (l.userData = e.userData);
        h[e.uuid] = l;
      }
    }
    return h;
  }, parseMaterials:function(a, b) {
    var h = {}, d = {};
    if (void 0 !== a) {
      var c = new he;
      c.setTextures(b);
      b = 0;
      for (var f = a.length; b < f; b++) {
        var e = a[b];
        if ("MultiMaterial" === e.type) {
          for (var l = [], k = 0; k < e.materials.length; k++) {
            var g = e.materials[k];
            void 0 === h[g.uuid] && (h[g.uuid] = c.parse(g));
            l.push(h[g.uuid]);
          }
          d[e.uuid] = l;
        } else {
          void 0 === h[e.uuid] && (h[e.uuid] = c.parse(e)), d[e.uuid] = h[e.uuid];
        }
      }
    }
    return d;
  }, parseAnimations:function(a) {
    for (var b = [], h = 0; h < a.length; h++) {
      var d = a[h], c = Ta.parse(d);
      void 0 !== d.uuid && (c.uuid = d.uuid);
      b.push(c);
    }
    return b;
  }, parseImages:function(a, b) {
    function h(a) {
      d.manager.itemStart(a);
      return f.load(a, function() {
        d.manager.itemEnd(a);
      }, void 0, function() {
        d.manager.itemError(a);
        d.manager.itemEnd(a);
      });
    }
    var d = this, c = {};
    if (void 0 !== a && 0 < a.length) {
      b = new Ae(b);
      var f = new yd(b);
      f.setCrossOrigin(this.crossOrigin);
      b = 0;
      for (var e = a.length; b < e; b++) {
        var l = a[b], k = l.url;
        if (Array.isArray(k)) {
          c[l.uuid] = [];
          for (var g = 0, q = k.length; g < q; g++) {
            var m = k[g];
            m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(m) ? m : d.resourcePath + m;
            c[l.uuid].push(h(m));
          }
        } else {
          m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : d.resourcePath + l.url, c[l.uuid] = h(m);
        }
      }
    }
    return c;
  }, parseTextures:function(a, b) {
    function h(a, b) {
      if ("number" === typeof a) {
        return a;
      }
      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a);
      return b[a];
    }
    var d = {};
    if (void 0 !== a) {
      for (var c = 0, f = a.length; c < f; c++) {
        var e = a[c];
        void 0 === e.image && console.warn('THREE.ObjectLoader: No "image" specified for', e.uuid);
        void 0 === b[e.image] && console.warn("THREE.ObjectLoader: Undefined image", e.image);
        var l = Array.isArray(b[e.image]) ? new za(b[e.image]) : new n(b[e.image]);
        l.needsUpdate = !0;
        l.uuid = e.uuid;
        void 0 !== e.name && (l.name = e.name);
        void 0 !== e.mapping && (l.mapping = h(e.mapping, Dg));
        void 0 !== e.offset && l.offset.fromArray(e.offset);
        void 0 !== e.repeat && l.repeat.fromArray(e.repeat);
        void 0 !== e.center && l.center.fromArray(e.center);
        void 0 !== e.rotation && (l.rotation = e.rotation);
        void 0 !== e.wrap && (l.wrapS = h(e.wrap[0], Vf), l.wrapT = h(e.wrap[1], Vf));
        void 0 !== e.format && (l.format = e.format);
        void 0 !== e.type && (l.type = e.type);
        void 0 !== e.encoding && (l.encoding = e.encoding);
        void 0 !== e.minFilter && (l.minFilter = h(e.minFilter, Wf));
        void 0 !== e.magFilter && (l.magFilter = h(e.magFilter, Wf));
        void 0 !== e.anisotropy && (l.anisotropy = e.anisotropy);
        void 0 !== e.flipY && (l.flipY = e.flipY);
        void 0 !== e.premultiplyAlpha && (l.premultiplyAlpha = e.premultiplyAlpha);
        void 0 !== e.unpackAlignment && (l.unpackAlignment = e.unpackAlignment);
        d[e.uuid] = l;
      }
    }
    return d;
  }, parseObject:function(a, b, d) {
    function h(a) {
      void 0 === b[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a);
      return b[a];
    }
    function c(a) {
      if (void 0 !== a) {
        if (Array.isArray(a)) {
          for (var b = [], h = 0, c = a.length; h < c; h++) {
            var f = a[h];
            void 0 === d[f] && console.warn("THREE.ObjectLoader: Undefined material", f);
            b.push(d[f]);
          }
          return b;
        }
        void 0 === d[a] && console.warn("THREE.ObjectLoader: Undefined material", a);
        return d[a];
      }
    }
    switch(a.type) {
      case "Scene":
        var f = new Pd;
        void 0 !== a.background && Number.isInteger(a.background) && (f.background = new z(a.background));
        void 0 !== a.fog && ("Fog" === a.fog.type ? f.fog = new lc(a.fog.color, a.fog.near, a.fog.far) : "FogExp2" === a.fog.type && (f.fog = new kc(a.fog.color, a.fog.density)));
        break;
      case "PerspectiveCamera":
        f = new va(a.fov, a.aspect, a.near, a.far);
        void 0 !== a.focus && (f.focus = a.focus);
        void 0 !== a.zoom && (f.zoom = a.zoom);
        void 0 !== a.filmGauge && (f.filmGauge = a.filmGauge);
        void 0 !== a.filmOffset && (f.filmOffset = a.filmOffset);
        void 0 !== a.view && (f.view = Object.assign({}, a.view));
        break;
      case "OrthographicCamera":
        f = new Bd(a.left, a.right, a.top, a.bottom, a.near, a.far);
        void 0 !== a.zoom && (f.zoom = a.zoom);
        void 0 !== a.view && (f.view = Object.assign({}, a.view));
        break;
      case "AmbientLight":
        f = new fe(a.color, a.intensity);
        break;
      case "DirectionalLight":
        f = new ee(a.color, a.intensity);
        break;
      case "PointLight":
        f = new ce(a.color, a.intensity, a.distance, a.decay);
        break;
      case "RectAreaLight":
        f = new ge(a.color, a.intensity, a.width, a.height);
        break;
      case "SpotLight":
        f = new be(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay);
        break;
      case "HemisphereLight":
        f = new $d(a.color, a.groundColor, a.intensity);
        break;
      case "SkinnedMesh":
        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
      case "Mesh":
        f = h(a.geometry);
        var e = c(a.material);
        f = f.bones && 0 < f.bones.length ? new $c(f, e) : new ca(f, e);
        void 0 !== a.drawMode && f.setDrawMode(a.drawMode);
        break;
      case "LOD":
        f = new Zc;
        break;
      case "Line":
        f = new wa(h(a.geometry), c(a.material), a.mode);
        break;
      case "LineLoop":
        f = new Rd(h(a.geometry), c(a.material));
        break;
      case "LineSegments":
        f = new pa(h(a.geometry), c(a.material));
        break;
      case "PointCloud":
      case "Points":
        f = new nc(h(a.geometry), c(a.material));
        break;
      case "Sprite":
        f = new Yc(c(a.material));
        break;
      case "Group":
        f = new jc;
        break;
      default:
        f = new G;
    }
    f.uuid = a.uuid;
    void 0 !== a.name && (f.name = a.name);
    void 0 !== a.matrix ? (f.matrix.fromArray(a.matrix), void 0 !== a.matrixAutoUpdate && (f.matrixAutoUpdate = a.matrixAutoUpdate), f.matrixAutoUpdate && f.matrix.decompose(f.position, f.quaternion, f.scale)) : (void 0 !== a.position && f.position.fromArray(a.position), void 0 !== a.rotation && f.rotation.fromArray(a.rotation), void 0 !== a.quaternion && f.quaternion.fromArray(a.quaternion), void 0 !== a.scale && f.scale.fromArray(a.scale));
    void 0 !== a.castShadow && (f.castShadow = a.castShadow);
    void 0 !== a.receiveShadow && (f.receiveShadow = a.receiveShadow);
    a.shadow && (void 0 !== a.shadow.bias && (f.shadow.bias = a.shadow.bias), void 0 !== a.shadow.radius && (f.shadow.radius = a.shadow.radius), void 0 !== a.shadow.mapSize && f.shadow.mapSize.fromArray(a.shadow.mapSize), void 0 !== a.shadow.camera && (f.shadow.camera = this.parseObject(a.shadow.camera)));
    void 0 !== a.visible && (f.visible = a.visible);
    void 0 !== a.frustumCulled && (f.frustumCulled = a.frustumCulled);
    void 0 !== a.renderOrder && (f.renderOrder = a.renderOrder);
    void 0 !== a.userData && (f.userData = a.userData);
    void 0 !== a.layers && (f.layers.mask = a.layers);
    if (void 0 !== a.children) {
      e = a.children;
      for (var l = 0; l < e.length; l++) {
        f.add(this.parseObject(e[l], b, d));
      }
    }
    if ("LOD" === a.type) {
      for (a = a.levels, e = 0; e < a.length; e++) {
        l = a[e];
        var k = f.getObjectByProperty("uuid", l.object);
        void 0 !== k && f.addLevel(k, l.distance);
      }
    }
    return f;
  }});
  var Dg = {UVMapping:300, CubeReflectionMapping:301, CubeRefractionMapping:302, EquirectangularReflectionMapping:303, EquirectangularRefractionMapping:304, SphericalReflectionMapping:305, CubeUVReflectionMapping:306, CubeUVRefractionMapping:307}, Vf = {RepeatWrapping:1E3, ClampToEdgeWrapping:1001, MirroredRepeatWrapping:1002}, Wf = {NearestFilter:1003, NearestMipMapNearestFilter:1004, NearestMipMapLinearFilter:1005, LinearFilter:1006, LinearMipMapNearestFilter:1007, LinearMipMapLinearFilter:1008};
  Ge.prototype = {constructor:Ge, setOptions:function(a) {
    this.options = a;
    return this;
  }, load:function(a, b, d, c) {
    void 0 === a && (a = "");
    void 0 !== this.path && (a = this.path + a);
    a = this.manager.resolveURL(a);
    var h = this, f = fc.get(a);
    if (void 0 !== f) {
      return h.manager.itemStart(a), setTimeout(function() {
        b && b(f);
        h.manager.itemEnd(a);
      }, 0), f;
    }
    fetch(a).then(function(a) {
      return a.blob();
    }).then(function(a) {
      return createImageBitmap(a, h.options);
    }).then(function(d) {
      fc.add(a, d);
      b && b(d);
      h.manager.itemEnd(a);
    }).catch(function(b) {
      c && c(b);
      h.manager.itemError(a);
      h.manager.itemEnd(a);
    });
    h.manager.itemStart(a);
  }, setCrossOrigin:function() {
    return this;
  }, setPath:function(a) {
    this.path = a;
    return this;
  }};
  Object.assign(He.prototype, {moveTo:function(a, b) {
    this.currentPath = new db;
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(a, b);
  }, lineTo:function(a, b) {
    this.currentPath.lineTo(a, b);
  }, quadraticCurveTo:function(a, b, d, c) {
    this.currentPath.quadraticCurveTo(a, b, d, c);
  }, bezierCurveTo:function(a, b, d, c, f, e) {
    this.currentPath.bezierCurveTo(a, b, d, c, f, e);
  }, splineThru:function(a) {
    this.currentPath.splineThru(a);
  }, toShapes:function(a, b) {
    function d(a) {
      for (var b = [], d = 0, h = a.length; d < h; d++) {
        var c = a[d], f = new Lb;
        f.curves = c.curves;
        b.push(f);
      }
      return b;
    }
    function h(a, b) {
      for (var d = b.length, h = !1, c = d - 1, f = 0; f < d; c = f++) {
        var e = b[c], l = b[f], k = l.x - e.x, g = l.y - e.y;
        if (Math.abs(g) > Number.EPSILON) {
          if (0 > g && (e = b[f], k = -k, l = b[c], g = -g), !(a.y < e.y || a.y > l.y)) {
            if (a.y === e.y) {
              if (a.x === e.x) {
                return !0;
              }
            } else {
              c = g * (a.x - e.x) - k * (a.y - e.y);
              if (0 === c) {
                return !0;
              }
              0 > c || (h = !h);
            }
          }
        } else {
          if (a.y === e.y && (l.x <= a.x && a.x <= e.x || e.x <= a.x && a.x <= l.x)) {
            return !0;
          }
        }
      }
      return h;
    }
    var c = wb.isClockWise, f = this.subPaths;
    if (0 === f.length) {
      return [];
    }
    if (!0 === b) {
      return d(f);
    }
    b = [];
    if (1 === f.length) {
      var e = f[0], l = new Lb;
      l.curves = e.curves;
      b.push(l);
      return b;
    }
    var k = !c(f[0].getPoints());
    k = a ? !k : k;
    l = [];
    var g = [], q = [], m = 0;
    g[m] = void 0;
    q[m] = [];
    for (var n = 0, t = f.length; n < t; n++) {
      e = f[n];
      var u = e.getPoints(), p = c(u);
      (p = a ? !p : p) ? (!k && g[m] && m++, g[m] = {s:new Lb, p:u}, g[m].s.curves = e.curves, k && m++, q[m] = []) : q[m].push({h:e, p:u[0]});
    }
    if (!g[0]) {
      return d(f);
    }
    if (1 < g.length) {
      n = !1;
      a = [];
      c = 0;
      for (f = g.length; c < f; c++) {
        l[c] = [];
      }
      c = 0;
      for (f = g.length; c < f; c++) {
        for (e = q[c], p = 0; p < e.length; p++) {
          k = e[p];
          m = !0;
          for (u = 0; u < g.length; u++) {
            h(k.p, g[u].p) && (c !== u && a.push({froms:c, tos:u, hole:p}), m ? (m = !1, l[u].push(k)) : n = !0);
          }
          m && l[c].push(k);
        }
      }
      0 < a.length && (n || (q = l));
    }
    n = 0;
    for (c = g.length; n < c; n++) {
      for (l = g[n].s, b.push(l), a = q[n], f = 0, e = a.length; f < e; f++) {
        l.holes.push(a[f].h);
      }
    }
    return b;
  }});
  Object.assign(Ie.prototype, {isFont:!0, generateShapes:function(a, b) {
    void 0 === b && (b = 100);
    var d = [], h = b;
    b = this.data;
    var c = Array.from ? Array.from(a) : String(a).split("");
    h /= b.resolution;
    var f = (b.boundingBox.yMax - b.boundingBox.yMin + b.underlineThickness) * h;
    a = [];
    for (var e = 0, l = 0, k = 0; k < c.length; k++) {
      var g = c[k];
      if ("\n" === g) {
        e = 0, l -= f;
      } else {
        var q = h, m = e, n = l;
        if (g = b.glyphs[g] || b.glyphs["?"]) {
          var t = new He;
          if (g.o) {
            for (var u = g._cachedOutline || (g._cachedOutline = g.o.split(" ")), p = 0, v = u.length; p < v;) {
              switch(u[p++]) {
                case "m":
                  var r = u[p++] * q + m, w = u[p++] * q + n;
                  t.moveTo(r, w);
                  break;
                case "l":
                  r = u[p++] * q + m;
                  w = u[p++] * q + n;
                  t.lineTo(r, w);
                  break;
                case "q":
                  var z = u[p++] * q + m, y = u[p++] * q + n, x = u[p++] * q + m, D = u[p++] * q + n;
                  t.quadraticCurveTo(x, D, z, y);
                  break;
                case "b":
                  z = u[p++] * q + m, y = u[p++] * q + n, x = u[p++] * q + m, D = u[p++] * q + n, r = u[p++] * q + m, w = u[p++] * q + n, t.bezierCurveTo(x, D, r, w, z, y);
              }
            }
          }
          q = {offsetX:g.ha * q, path:t};
        } else {
          q = void 0;
        }
        e += q.offsetX;
        a.push(q.path);
      }
    }
    b = 0;
    for (c = a.length; b < c; b++) {
      Array.prototype.push.apply(d, a[b].toShapes());
    }
    return d;
  }});
  Object.assign(Jf.prototype, {load:function(a, b, d, c) {
    var h = this, f = new Za(this.manager);
    f.setPath(this.path);
    f.load(a, function(a) {
      try {
        var d = JSON.parse(a);
      } catch (Ia) {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), d = JSON.parse(a.substring(65, a.length - 2));
      }
      a = h.parse(d);
      b && b(a);
    }, d, c);
  }, parse:function(a) {
    return new Ie(a);
  }, setPath:function(a) {
    this.path = a;
    return this;
  }});
  Cd.Handlers = {handlers:[], add:function(a, b) {
    this.handlers.push(a, b);
  }, get:function(a) {
    for (var b = this.handlers, d = 0, h = b.length; d < h; d += 2) {
      var c = b[d + 1];
      if (b[d].test(a)) {
        return c;
      }
    }
    return null;
  }};
  Object.assign(Cd.prototype, {crossOrigin:"anonymous", onLoadStart:function() {
  }, onLoadProgress:function() {
  }, onLoadComplete:function() {
  }, initMaterials:function(a, b, d) {
    for (var h = [], c = 0; c < a.length; ++c) {
      h[c] = this.createMaterial(a[c], b, d);
    }
    return h;
  }, createMaterial:function() {
    var a = {NoBlending:0, NormalBlending:1, AdditiveBlending:2, SubtractiveBlending:3, MultiplyBlending:4, CustomBlending:5}, b = new z, d = new Zd, c = new he;
    return function(h, f, e) {
      function l(a, b, h, c, l) {
        a = f + a;
        var g = Cd.Handlers.get(a);
        null !== g ? a = g.load(a) : (d.setCrossOrigin(e), a = d.load(a));
        void 0 !== b && (a.repeat.fromArray(b), 1 !== b[0] && (a.wrapS = 1E3), 1 !== b[1] && (a.wrapT = 1E3));
        void 0 !== h && a.offset.fromArray(h);
        void 0 !== c && ("repeat" === c[0] && (a.wrapS = 1E3), "mirror" === c[0] && (a.wrapS = 1002), "repeat" === c[1] && (a.wrapT = 1E3), "mirror" === c[1] && (a.wrapT = 1002));
        void 0 !== l && (a.anisotropy = l);
        b = ia.generateUUID();
        k[b] = a;
        return b;
      }
      var k = {}, g = {uuid:ia.generateUUID(), type:"MeshLambertMaterial"}, q;
      for (q in h) {
        var m = h[q];
        switch(q) {
          case "DbgColor":
          case "DbgIndex":
          case "opticalDensity":
          case "illumination":
            break;
          case "DbgName":
            g.name = m;
            break;
          case "blending":
            g.blending = a[m];
            break;
          case "colorAmbient":
          case "mapAmbient":
            console.warn("THREE.Loader.createMaterial:", q, "is no longer supported.");
            break;
          case "colorDiffuse":
            g.color = b.fromArray(m).getHex();
            break;
          case "colorSpecular":
            g.specular = b.fromArray(m).getHex();
            break;
          case "colorEmissive":
            g.emissive = b.fromArray(m).getHex();
            break;
          case "specularCoef":
            g.shininess = m;
            break;
          case "shading":
            "basic" === m.toLowerCase() && (g.type = "MeshBasicMaterial");
            "phong" === m.toLowerCase() && (g.type = "MeshPhongMaterial");
            "standard" === m.toLowerCase() && (g.type = "MeshStandardMaterial");
            break;
          case "mapDiffuse":
            g.map = l(m, h.mapDiffuseRepeat, h.mapDiffuseOffset, h.mapDiffuseWrap, h.mapDiffuseAnisotropy);
            break;
          case "mapDiffuseRepeat":
          case "mapDiffuseOffset":
          case "mapDiffuseWrap":
          case "mapDiffuseAnisotropy":
            break;
          case "mapEmissive":
            g.emissiveMap = l(m, h.mapEmissiveRepeat, h.mapEmissiveOffset, h.mapEmissiveWrap, h.mapEmissiveAnisotropy);
            break;
          case "mapEmissiveRepeat":
          case "mapEmissiveOffset":
          case "mapEmissiveWrap":
          case "mapEmissiveAnisotropy":
            break;
          case "mapLight":
            g.lightMap = l(m, h.mapLightRepeat, h.mapLightOffset, h.mapLightWrap, h.mapLightAnisotropy);
            break;
          case "mapLightRepeat":
          case "mapLightOffset":
          case "mapLightWrap":
          case "mapLightAnisotropy":
            break;
          case "mapAO":
            g.aoMap = l(m, h.mapAORepeat, h.mapAOOffset, h.mapAOWrap, h.mapAOAnisotropy);
            break;
          case "mapAORepeat":
          case "mapAOOffset":
          case "mapAOWrap":
          case "mapAOAnisotropy":
            break;
          case "mapBump":
            g.bumpMap = l(m, h.mapBumpRepeat, h.mapBumpOffset, h.mapBumpWrap, h.mapBumpAnisotropy);
            break;
          case "mapBumpScale":
            g.bumpScale = m;
            break;
          case "mapBumpRepeat":
          case "mapBumpOffset":
          case "mapBumpWrap":
          case "mapBumpAnisotropy":
            break;
          case "mapNormal":
            g.normalMap = l(m, h.mapNormalRepeat, h.mapNormalOffset, h.mapNormalWrap, h.mapNormalAnisotropy);
            break;
          case "mapNormalFactor":
            g.normalScale = m;
            break;
          case "mapNormalRepeat":
          case "mapNormalOffset":
          case "mapNormalWrap":
          case "mapNormalAnisotropy":
            break;
          case "mapSpecular":
            g.specularMap = l(m, h.mapSpecularRepeat, h.mapSpecularOffset, h.mapSpecularWrap, h.mapSpecularAnisotropy);
            break;
          case "mapSpecularRepeat":
          case "mapSpecularOffset":
          case "mapSpecularWrap":
          case "mapSpecularAnisotropy":
            break;
          case "mapMetalness":
            g.metalnessMap = l(m, h.mapMetalnessRepeat, h.mapMetalnessOffset, h.mapMetalnessWrap, h.mapMetalnessAnisotropy);
            break;
          case "mapMetalnessRepeat":
          case "mapMetalnessOffset":
          case "mapMetalnessWrap":
          case "mapMetalnessAnisotropy":
            break;
          case "mapRoughness":
            g.roughnessMap = l(m, h.mapRoughnessRepeat, h.mapRoughnessOffset, h.mapRoughnessWrap, h.mapRoughnessAnisotropy);
            break;
          case "mapRoughnessRepeat":
          case "mapRoughnessOffset":
          case "mapRoughnessWrap":
          case "mapRoughnessAnisotropy":
            break;
          case "mapAlpha":
            g.alphaMap = l(m, h.mapAlphaRepeat, h.mapAlphaOffset, h.mapAlphaWrap, h.mapAlphaAnisotropy);
            break;
          case "mapAlphaRepeat":
          case "mapAlphaOffset":
          case "mapAlphaWrap":
          case "mapAlphaAnisotropy":
            break;
          case "flipSided":
            g.side = 1;
            break;
          case "doubleSided":
            g.side = 2;
            break;
          case "transparency":
            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
            g.opacity = m;
            break;
          case "depthTest":
          case "depthWrite":
          case "colorWrite":
          case "opacity":
          case "reflectivity":
          case "transparent":
          case "visible":
          case "wireframe":
            g[q] = m;
            break;
          case "vertexColors":
            !0 === m && (g.vertexColors = 2);
            "face" === m && (g.vertexColors = 1);
            break;
          default:
            console.error("THREE.Loader.createMaterial: Unsupported", q, m);
        }
      }
      "MeshBasicMaterial" === g.type && delete g.emissive;
      "MeshPhongMaterial" !== g.type && delete g.specular;
      1 > g.opacity && (g.transparent = !0);
      c.setTextures(k);
      return c.parse(g);
    };
  }()});
  var me, Me = {getContext:function() {
    void 0 === me && (me = new (window.AudioContext || window.webkitAudioContext));
    return me;
  }, setContext:function(a) {
    me = a;
  }};
  Object.assign(Je.prototype, {load:function(a, b, d, c) {
    var h = new Za(this.manager);
    h.setResponseType("arraybuffer");
    h.setPath(this.path);
    h.load(a, function(a) {
      a = a.slice(0);
      Me.getContext().decodeAudioData(a, function(a) {
        b(a);
      });
    }, d, c);
  }, setPath:function(a) {
    this.path = a;
    return this;
  }});
  Object.assign(Kf.prototype, {update:function() {
    var a, d, c, f, e, l, k, g, q = new b, m = new b;
    return function(b) {
      if (a !== this || d !== b.focus || c !== b.fov || f !== b.aspect * this.aspect || e !== b.near || l !== b.far || k !== b.zoom || g !== this.eyeSep) {
        a = this;
        d = b.focus;
        c = b.fov;
        f = b.aspect * this.aspect;
        e = b.near;
        l = b.far;
        k = b.zoom;
        var h = b.projectionMatrix.clone();
        g = this.eyeSep / 2;
        var n = g * e / d, t = e * Math.tan(ia.DEG2RAD * c * .5) / k;
        m.elements[12] = -g;
        q.elements[12] = g;
        var u = -t * f + n, p = t * f + n;
        h.elements[0] = 2 * e / (p - u);
        h.elements[8] = (p + u) / (p - u);
        this.cameraL.projectionMatrix.copy(h);
        u = -t * f - n;
        p = t * f - n;
        h.elements[0] = 2 * e / (p - u);
        h.elements[8] = (p + u) / (p - u);
        this.cameraR.projectionMatrix.copy(h);
      }
      this.cameraL.matrixWorld.copy(b.matrixWorld).multiply(m);
      this.cameraR.matrixWorld.copy(b.matrixWorld).multiply(q);
    };
  }()});
  Dd.prototype = Object.create(G.prototype);
  Dd.prototype.constructor = Dd;
  Object.assign(Ke.prototype, {start:function() {
    this.oldTime = this.startTime = ("undefined" === typeof performance ? Date : performance).now();
    this.elapsedTime = 0;
    this.running = !0;
  }, stop:function() {
    this.getElapsedTime();
    this.autoStart = this.running = !1;
  }, getElapsedTime:function() {
    this.getDelta();
    return this.elapsedTime;
  }, getDelta:function() {
    var a = 0;
    if (this.autoStart && !this.running) {
      return this.start(), 0;
    }
    if (this.running) {
      var b = ("undefined" === typeof performance ? Date : performance).now();
      a = (b - this.oldTime) / 1E3;
      this.oldTime = b;
      this.elapsedTime += a;
    }
    return a;
  }});
  Le.prototype = Object.assign(Object.create(G.prototype), {constructor:Le, getInput:function() {
    return this.gain;
  }, removeFilter:function() {
    null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null);
    return this;
  }, getFilter:function() {
    return this.filter;
  }, setFilter:function(a) {
    null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination);
    this.filter = a;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  }, getMasterVolume:function() {
    return this.gain.gain.value;
  }, setMasterVolume:function(a) {
    this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01);
    return this;
  }, updateMatrixWorld:function() {
    var a = new f, b = new e, d = new f, c = new f, l = new Ke;
    return function(h) {
      G.prototype.updateMatrixWorld.call(this, h);
      h = this.context.listener;
      var f = this.up;
      this.timeDelta = l.getDelta();
      this.matrixWorld.decompose(a, b, d);
      c.set(0, 0, -1).applyQuaternion(b);
      if (h.positionX) {
        var e = this.context.currentTime + this.timeDelta;
        h.positionX.linearRampToValueAtTime(a.x, e);
        h.positionY.linearRampToValueAtTime(a.y, e);
        h.positionZ.linearRampToValueAtTime(a.z, e);
        h.forwardX.linearRampToValueAtTime(c.x, e);
        h.forwardY.linearRampToValueAtTime(c.y, e);
        h.forwardZ.linearRampToValueAtTime(c.z, e);
        h.upX.linearRampToValueAtTime(f.x, e);
        h.upY.linearRampToValueAtTime(f.y, e);
        h.upZ.linearRampToValueAtTime(f.z, e);
      } else {
        h.setPosition(a.x, a.y, a.z), h.setOrientation(c.x, c.y, c.z, f.x, f.y, f.z);
      }
    };
  }()});
  Fc.prototype = Object.assign(Object.create(G.prototype), {constructor:Fc, getOutput:function() {
    return this.gain;
  }, setNodeSource:function(a) {
    this.hasPlaybackControl = !1;
    this.sourceType = "audioNode";
    this.source = a;
    this.connect();
    return this;
  }, setMediaElementSource:function(a) {
    this.hasPlaybackControl = !1;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(a);
    this.connect();
    return this;
  }, setBuffer:function(a) {
    this.buffer = a;
    this.sourceType = "buffer";
    this.autoplay && this.play();
    return this;
  }, play:function() {
    if (!0 === this.isPlaying) {
      console.warn("THREE.Audio: Audio is already playing.");
    } else {
      if (!1 === this.hasPlaybackControl) {
        console.warn("THREE.Audio: this Audio has no playback control.");
      } else {
        var a = this.context.createBufferSource();
        a.buffer = this.buffer;
        a.loop = this.loop;
        a.onended = this.onEnded.bind(this);
        this.startTime = this.context.currentTime;
        a.start(this.startTime, this.offset);
        this.isPlaying = !0;
        this.source = a;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
      }
    }
  }, pause:function() {
    if (!1 === this.hasPlaybackControl) {
      console.warn("THREE.Audio: this Audio has no playback control.");
    } else {
      return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
    }
  }, stop:function() {
    if (!1 === this.hasPlaybackControl) {
      console.warn("THREE.Audio: this Audio has no playback control.");
    } else {
      return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
    }
  }, connect:function() {
    if (0 < this.filters.length) {
      this.source.connect(this.filters[0]);
      for (var a = 1, b = this.filters.length; a < b; a++) {
        this.filters[a - 1].connect(this.filters[a]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    return this;
  }, disconnect:function() {
    if (0 < this.filters.length) {
      this.source.disconnect(this.filters[0]);
      for (var a = 1, b = this.filters.length; a < b; a++) {
        this.filters[a - 1].disconnect(this.filters[a]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    return this;
  }, getFilters:function() {
    return this.filters;
  }, setFilters:function(a) {
    a || (a = []);
    !0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a;
    return this;
  }, setDetune:function(a) {
    this.detune = a;
    if (void 0 !== this.source.detune) {
      return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this;
    }
  }, getDetune:function() {
    return this.detune;
  }, getFilter:function() {
    return this.getFilters()[0];
  }, setFilter:function(a) {
    return this.setFilters(a ? [a] : []);
  }, setPlaybackRate:function(a) {
    if (!1 === this.hasPlaybackControl) {
      console.warn("THREE.Audio: this Audio has no playback control.");
    } else {
      return this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
    }
  }, getPlaybackRate:function() {
    return this.playbackRate;
  }, onEnded:function() {
    this.isPlaying = !1;
  }, getLoop:function() {
    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }, setLoop:function(a) {
    if (!1 === this.hasPlaybackControl) {
      console.warn("THREE.Audio: this Audio has no playback control.");
    } else {
      return this.loop = a, !0 === this.isPlaying && (this.source.loop = this.loop), this;
    }
  }, getVolume:function() {
    return this.gain.gain.value;
  }, setVolume:function(a) {
    this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01);
    return this;
  }});
  Ne.prototype = Object.assign(Object.create(Fc.prototype), {constructor:Ne, getOutput:function() {
    return this.panner;
  }, getRefDistance:function() {
    return this.panner.refDistance;
  }, setRefDistance:function(a) {
    this.panner.refDistance = a;
    return this;
  }, getRolloffFactor:function() {
    return this.panner.rolloffFactor;
  }, setRolloffFactor:function(a) {
    this.panner.rolloffFactor = a;
    return this;
  }, getDistanceModel:function() {
    return this.panner.distanceModel;
  }, setDistanceModel:function(a) {
    this.panner.distanceModel = a;
    return this;
  }, getMaxDistance:function() {
    return this.panner.maxDistance;
  }, setMaxDistance:function(a) {
    this.panner.maxDistance = a;
    return this;
  }, setDirectionalCone:function(a, b, d) {
    this.panner.coneInnerAngle = a;
    this.panner.coneOuterAngle = b;
    this.panner.coneOuterGain = d;
    return this;
  }, updateMatrixWorld:function() {
    var a = new f, b = new e, d = new f, c = new f;
    return function(h) {
      G.prototype.updateMatrixWorld.call(this, h);
      if (!0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
        if (this.matrixWorld.decompose(a, b, d), c.set(0, 0, 1).applyQuaternion(b), h = this.panner, h.positionX) {
          var f = this.context.currentTime + this.listener.timeDelta;
          h.positionX.linearRampToValueAtTime(a.x, f);
          h.positionY.linearRampToValueAtTime(a.y, f);
          h.positionZ.linearRampToValueAtTime(a.z, f);
          h.orientationX.linearRampToValueAtTime(c.x, f);
          h.orientationY.linearRampToValueAtTime(c.y, f);
          h.orientationZ.linearRampToValueAtTime(c.z, f);
        } else {
          h.setPosition(a.x, a.y, a.z), h.setOrientation(c.x, c.y, c.z);
        }
      }
    };
  }()});
  Object.assign(Oe.prototype, {getFrequencyData:function() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }, getAverageFrequency:function() {
    for (var a = 0, b = this.getFrequencyData(), d = 0; d < b.length; d++) {
      a += b[d];
    }
    return a / b.length;
  }});
  Object.assign(Pe.prototype, {accumulate:function(a, b) {
    var d = this.buffer, h = this.valueSize;
    a = a * h + h;
    var c = this.cumulativeWeight;
    if (0 === c) {
      for (c = 0; c !== h; ++c) {
        d[a + c] = d[c];
      }
      c = b;
    } else {
      c += b, this._mixBufferRegion(d, a, 0, b / c, h);
    }
    this.cumulativeWeight = c;
  }, apply:function(a) {
    var b = this.valueSize, d = this.buffer;
    a = a * b + b;
    var h = this.cumulativeWeight, c = this.binding;
    this.cumulativeWeight = 0;
    1 > h && this._mixBufferRegion(d, a, 3 * b, 1 - h, b);
    h = b;
    for (var f = b + b; h !== f; ++h) {
      if (d[h] !== d[h + b]) {
        c.setValue(d, a);
        break;
      }
    }
  }, saveOriginalState:function() {
    var a = this.buffer, b = this.valueSize, d = 3 * b;
    this.binding.getValue(a, d);
    for (var c = b; c !== d; ++c) {
      a[c] = a[d + c % b];
    }
    this.cumulativeWeight = 0;
  }, restoreOriginalState:function() {
    this.binding.setValue(this.buffer, 3 * this.valueSize);
  }, _select:function(a, b, d, c, f) {
    if (.5 <= c) {
      for (c = 0; c !== f; ++c) {
        a[b + c] = a[d + c];
      }
    }
  }, _slerp:function(a, b, d, c) {
    e.slerpFlat(a, b, a, b, a, d, c);
  }, _lerp:function(a, b, d, c, f) {
    for (var h = 1 - c, e = 0; e !== f; ++e) {
      var l = b + e;
      a[l] = a[l] * h + a[d + e] * c;
    }
  }});
  Object.assign(Lf.prototype, {getValue:function(a, b) {
    this.bind();
    var d = this._bindings[this._targetGroup.nCachedObjects_];
    void 0 !== d && d.getValue(a, b);
  }, setValue:function(a, b) {
    for (var d = this._bindings, h = this._targetGroup.nCachedObjects_, c = d.length; h !== c; ++h) {
      d[h].setValue(a, b);
    }
  }, bind:function() {
    for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, d = a.length; b !== d; ++b) {
      a[b].bind();
    }
  }, unbind:function() {
    for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, d = a.length; b !== d; ++b) {
      a[b].unbind();
    }
  }});
  Object.assign(Fa, {Composite:Lf, create:function(a, b, d) {
    return a && a.isAnimationObjectGroup ? new Fa.Composite(a, b, d) : new Fa(a, b, d);
  }, sanitizeNodeName:function() {
    var a = /[\[\]\.:\/]/g;
    return function(b) {
      return b.replace(/\s/g, "_").replace(a, "");
    };
  }(), parseTrackName:function() {
    var a = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", b = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
    a = /(WCOD+)?/.source.replace("WCOD", a);
    var d = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), c = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), f = new RegExp("^" + b + a + d + c + "$"), e = ["material", "materials", "bones"];
    return function(a) {
      var b = f.exec(a);
      if (!b) {
        throw Error("PropertyBinding: Cannot parse trackName: " + a);
      }
      b = {nodeName:b[2], objectName:b[3], objectIndex:b[4], propertyName:b[5], propertyIndex:b[6]};
      var d = b.nodeName && b.nodeName.lastIndexOf(".");
      if (void 0 !== d && -1 !== d) {
        var h = b.nodeName.substring(d + 1);
        -1 !== e.indexOf(h) && (b.nodeName = b.nodeName.substring(0, d), b.objectName = h);
      }
      if (null === b.propertyName || 0 === b.propertyName.length) {
        throw Error("PropertyBinding: can not parse propertyName from trackName: " + a);
      }
      return b;
    };
  }(), findNode:function(a, b) {
    if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) {
      return a;
    }
    if (a.skeleton) {
      var d = a.skeleton.getBoneByName(b);
      if (void 0 !== d) {
        return d;
      }
    }
    if (a.children) {
      var h = function(a) {
        for (var d = 0; d < a.length; d++) {
          var c = a[d];
          if (c.name === b || c.uuid === b || (c = h(c.children))) {
            return c;
          }
        }
        return null;
      };
      if (a = h(a.children)) {
        return a;
      }
    }
    return null;
  }});
  Object.assign(Fa.prototype, {_getValue_unavailable:function() {
  }, _setValue_unavailable:function() {
  }, BindingType:{Direct:0, EntireArray:1, ArrayElement:2, HasFromToArray:3}, Versioning:{None:0, NeedsUpdate:1, MatrixWorldNeedsUpdate:2}, GetterByBindingType:[function(a, b) {
    a[b] = this.node[this.propertyName];
  }, function(a, b) {
    for (var d = this.resolvedProperty, h = 0, c = d.length; h !== c; ++h) {
      a[b++] = d[h];
    }
  }, function(a, b) {
    a[b] = this.resolvedProperty[this.propertyIndex];
  }, function(a, b) {
    this.resolvedProperty.toArray(a, b);
  }], SetterByBindingTypeAndVersioning:[[function(a, b) {
    this.targetObject[this.propertyName] = a[b];
  }, function(a, b) {
    this.targetObject[this.propertyName] = a[b];
    this.targetObject.needsUpdate = !0;
  }, function(a, b) {
    this.targetObject[this.propertyName] = a[b];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }], [function(a, b) {
    for (var d = this.resolvedProperty, h = 0, c = d.length; h !== c; ++h) {
      d[h] = a[b++];
    }
  }, function(a, b) {
    for (var d = this.resolvedProperty, h = 0, c = d.length; h !== c; ++h) {
      d[h] = a[b++];
    }
    this.targetObject.needsUpdate = !0;
  }, function(a, b) {
    for (var d = this.resolvedProperty, h = 0, c = d.length; h !== c; ++h) {
      d[h] = a[b++];
    }
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }], [function(a, b) {
    this.resolvedProperty[this.propertyIndex] = a[b];
  }, function(a, b) {
    this.resolvedProperty[this.propertyIndex] = a[b];
    this.targetObject.needsUpdate = !0;
  }, function(a, b) {
    this.resolvedProperty[this.propertyIndex] = a[b];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }], [function(a, b) {
    this.resolvedProperty.fromArray(a, b);
  }, function(a, b) {
    this.resolvedProperty.fromArray(a, b);
    this.targetObject.needsUpdate = !0;
  }, function(a, b) {
    this.resolvedProperty.fromArray(a, b);
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }]], getValue:function(a, b) {
    this.bind();
    this.getValue(a, b);
  }, setValue:function(a, b) {
    this.bind();
    this.setValue(a, b);
  }, bind:function() {
    var a = this.node, b = this.parsedPath, d = b.objectName, c = b.propertyName, f = b.propertyIndex;
    a || (this.node = a = Fa.findNode(this.rootNode, b.nodeName) || this.rootNode);
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (a) {
      if (d) {
        var e = b.objectIndex;
        switch(d) {
          case "materials":
            if (!a.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!a.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            a = a.material.materials;
            break;
          case "bones":
            if (!a.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            a = a.skeleton.bones;
            for (d = 0; d < a.length; d++) {
              if (a[d].name === e) {
                e = d;
                break;
              }
            }
            break;
          default:
            if (void 0 === a[d]) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            a = a[d];
        }
        if (void 0 !== e) {
          if (void 0 === a[e]) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, a);
            return;
          }
          a = a[e];
        }
      }
      e = a[c];
      if (void 0 === e) {
        console.error("THREE.PropertyBinding: Trying to update property for track: " + b.nodeName + "." + c + " but it wasn't found.", a);
      } else {
        b = this.Versioning.None;
        this.targetObject = a;
        void 0 !== a.needsUpdate ? b = this.Versioning.NeedsUpdate : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate);
        d = this.BindingType.Direct;
        if (void 0 !== f) {
          if ("morphTargetInfluences" === c) {
            if (!a.geometry) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              return;
            }
            if (a.geometry.isBufferGeometry) {
              if (!a.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              for (d = 0; d < this.node.geometry.morphAttributes.position.length; d++) {
                if (a.geometry.morphAttributes.position[d].name === f) {
                  f = d;
                  break;
                }
              }
            } else {
              if (!a.geometry.morphTargets) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                return;
              }
              for (d = 0; d < this.node.geometry.morphTargets.length; d++) {
                if (a.geometry.morphTargets[d].name === f) {
                  f = d;
                  break;
                }
              }
            }
          }
          d = this.BindingType.ArrayElement;
          this.resolvedProperty = e;
          this.propertyIndex = f;
        } else {
          void 0 !== e.fromArray && void 0 !== e.toArray ? (d = this.BindingType.HasFromToArray, this.resolvedProperty = e) : Array.isArray(e) ? (d = this.BindingType.EntireArray, this.resolvedProperty = e) : this.propertyName = c;
        }
        this.getValue = this.GetterByBindingType[d];
        this.setValue = this.SetterByBindingTypeAndVersioning[d][b];
      }
    } else {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
    }
  }, unbind:function() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }});
  Object.assign(Fa.prototype, {_getValue_unbound:Fa.prototype.getValue, _setValue_unbound:Fa.prototype.setValue});
  Object.assign(Mf.prototype, {isAnimationObjectGroup:!0, add:function() {
    for (var a = this._objects, b = a.length, d = this.nCachedObjects_, c = this._indicesByUUID, f = this._paths, e = this._parsedPaths, l = this._bindings, k = l.length, g = void 0, q = 0, m = arguments.length; q !== m; ++q) {
      var n = arguments[q], t = n.uuid, u = c[t];
      if (void 0 === u) {
        u = b++;
        c[t] = u;
        a.push(n);
        t = 0;
        for (var p = k; t !== p; ++t) {
          l[t].push(new Fa(n, f[t], e[t]));
        }
      } else {
        if (u < d) {
          g = a[u];
          var v = --d;
          p = a[v];
          c[p.uuid] = u;
          a[u] = p;
          c[t] = v;
          a[v] = n;
          t = 0;
          for (p = k; t !== p; ++t) {
            var w = l[t], z = w[u];
            w[u] = w[v];
            void 0 === z && (z = new Fa(n, f[t], e[t]));
            w[v] = z;
          }
        } else {
          a[u] !== g && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
        }
      }
    }
    this.nCachedObjects_ = d;
  }, remove:function() {
    for (var a = this._objects, b = this.nCachedObjects_, d = this._indicesByUUID, c = this._bindings, f = c.length, e = 0, l = arguments.length; e !== l; ++e) {
      var k = arguments[e], g = k.uuid, q = d[g];
      if (void 0 !== q && q >= b) {
        var m = b++, n = a[m];
        d[n.uuid] = q;
        a[q] = n;
        d[g] = m;
        a[m] = k;
        k = 0;
        for (g = f; k !== g; ++k) {
          n = c[k];
          var t = n[q];
          n[q] = n[m];
          n[m] = t;
        }
      }
    }
    this.nCachedObjects_ = b;
  }, uncache:function() {
    for (var a = this._objects, b = a.length, d = this.nCachedObjects_, c = this._indicesByUUID, f = this._bindings, e = f.length, l = 0, k = arguments.length; l !== k; ++l) {
      var g = arguments[l].uuid, q = c[g];
      if (void 0 !== q) {
        if (delete c[g], q < d) {
          g = --d;
          var m = a[g], n = --b, t = a[n];
          c[m.uuid] = q;
          a[q] = m;
          c[t.uuid] = g;
          a[g] = t;
          a.pop();
          m = 0;
          for (t = e; m !== t; ++m) {
            var u = f[m], p = u[n];
            u[q] = u[g];
            u[g] = p;
            u.pop();
          }
        } else {
          for (n = --b, t = a[n], c[t.uuid] = q, a[q] = t, a.pop(), m = 0, t = e; m !== t; ++m) {
            u = f[m], u[q] = u[n], u.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = d;
  }, subscribe_:function(a, b) {
    var d = this._bindingsIndicesByPath, h = d[a], c = this._bindings;
    if (void 0 !== h) {
      return c[h];
    }
    var f = this._paths, e = this._parsedPaths, l = this._objects, k = this.nCachedObjects_, g = Array(l.length);
    h = c.length;
    d[a] = h;
    f.push(a);
    e.push(b);
    c.push(g);
    d = k;
    for (h = l.length; d !== h; ++d) {
      g[d] = new Fa(l[d], a, b);
    }
    return g;
  }, unsubscribe_:function(a) {
    var b = this._bindingsIndicesByPath, d = b[a];
    if (void 0 !== d) {
      var h = this._paths, c = this._parsedPaths, f = this._bindings, e = f.length - 1, l = f[e];
      b[a[e]] = d;
      f[d] = l;
      f.pop();
      c[d] = c[e];
      c.pop();
      h[d] = h[e];
      h.pop();
    }
  }});
  Object.assign(Nf.prototype, {play:function() {
    this._mixer._activateAction(this);
    return this;
  }, stop:function() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }, reset:function() {
    this.paused = !1;
    this.enabled = !0;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }, isRunning:function() {
    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
  }, isScheduled:function() {
    return this._mixer._isActiveAction(this);
  }, startAt:function(a) {
    this._startTime = a;
    return this;
  }, setLoop:function(a, b) {
    this.loop = a;
    this.repetitions = b;
    return this;
  }, setEffectiveWeight:function(a) {
    this.weight = a;
    this._effectiveWeight = this.enabled ? a : 0;
    return this.stopFading();
  }, getEffectiveWeight:function() {
    return this._effectiveWeight;
  }, fadeIn:function(a) {
    return this._scheduleFading(a, 0, 1);
  }, fadeOut:function(a) {
    return this._scheduleFading(a, 1, 0);
  }, crossFadeFrom:function(a, b, d) {
    a.fadeOut(b);
    this.fadeIn(b);
    if (d) {
      d = this._clip.duration;
      var h = a._clip.duration, c = d / h;
      a.warp(1, h / d, b);
      this.warp(c, 1, b);
    }
    return this;
  }, crossFadeTo:function(a, b, d) {
    return a.crossFadeFrom(this, b, d);
  }, stopFading:function() {
    var a = this._weightInterpolant;
    null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a));
    return this;
  }, setEffectiveTimeScale:function(a) {
    this.timeScale = a;
    this._effectiveTimeScale = this.paused ? 0 : a;
    return this.stopWarping();
  }, getEffectiveTimeScale:function() {
    return this._effectiveTimeScale;
  }, setDuration:function(a) {
    this.timeScale = this._clip.duration / a;
    return this.stopWarping();
  }, syncWith:function(a) {
    this.time = a.time;
    this.timeScale = a.timeScale;
    return this.stopWarping();
  }, halt:function(a) {
    return this.warp(this._effectiveTimeScale, 0, a);
  }, warp:function(a, b, d) {
    var h = this._mixer, c = h.time, f = this._timeScaleInterpolant, e = this.timeScale;
    null === f && (this._timeScaleInterpolant = f = h._lendControlInterpolant());
    h = f.parameterPositions;
    f = f.sampleValues;
    h[0] = c;
    h[1] = c + d;
    f[0] = a / e;
    f[1] = b / e;
    return this;
  }, stopWarping:function() {
    var a = this._timeScaleInterpolant;
    null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a));
    return this;
  }, getMixer:function() {
    return this._mixer;
  }, getClip:function() {
    return this._clip;
  }, getRoot:function() {
    return this._localRoot || this._mixer._root;
  }, _update:function(a, b, d, c) {
    if (this.enabled) {
      var h = this._startTime;
      if (null !== h) {
        b = (a - h) * d;
        if (0 > b || 0 === d) {
          return;
        }
        this._startTime = null;
        b *= d;
      }
      b *= this._updateTimeScale(a);
      d = this._updateTime(b);
      a = this._updateWeight(a);
      if (0 < a) {
        b = this._interpolants;
        h = this._propertyBindings;
        for (var f = 0, e = b.length; f !== e; ++f) {
          b[f].evaluate(d), h[f].accumulate(c, a);
        }
      }
    } else {
      this._updateWeight(a);
    }
  }, _updateWeight:function(a) {
    var b = 0;
    if (this.enabled) {
      b = this.weight;
      var d = this._weightInterpolant;
      if (null !== d) {
        var h = d.evaluate(a)[0];
        b *= h;
        a > d.parameterPositions[1] && (this.stopFading(), 0 === h && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = b;
  }, _updateTimeScale:function(a) {
    var b = 0;
    if (!this.paused) {
      b = this.timeScale;
      var d = this._timeScaleInterpolant;
      if (null !== d) {
        var h = d.evaluate(a)[0];
        b *= h;
        a > d.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b);
      }
    }
    return this._effectiveTimeScale = b;
  }, _updateTime:function(a) {
    var b = this.time + a, d = this._clip.duration, h = this.loop, c = this._loopCount, f = 2202 === h;
    if (0 === a) {
      return -1 === c ? b : f && 1 === (c & 1) ? d - b : b;
    }
    if (2200 === h) {
      a: {
        if (-1 === c && (this._loopCount = 0, this._setEndings(!0, !0, !1)), b >= d) {
          b = d;
        } else {
          if (0 > b) {
            b = 0;
          } else {
            break a;
          }
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1;
        this._mixer.dispatchEvent({type:"finished", action:this, direction:0 > a ? -1 : 1});
      }
    } else {
      -1 === c && (0 <= a ? (c = 0, this._setEndings(!0, 0 === this.repetitions, f)) : this._setEndings(0 === this.repetitions, !0, f));
      if (b >= d || 0 > b) {
        h = Math.floor(b / d);
        b -= d * h;
        c += Math.abs(h);
        var e = this.repetitions - c;
        0 >= e ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, b = 0 < a ? d : 0, this._mixer.dispatchEvent({type:"finished", action:this, direction:0 < a ? 1 : -1})) : (1 === e ? (a = 0 > a, this._setEndings(a, !a, f)) : this._setEndings(!1, !1, f), this._loopCount = c, this._mixer.dispatchEvent({type:"loop", action:this, loopDelta:h}));
      }
      if (f && 1 === (c & 1)) {
        return this.time = b, d - b;
      }
    }
    return this.time = b;
  }, _setEndings:function(a, b, d) {
    var h = this._interpolantSettings;
    d ? (h.endingStart = 2401, h.endingEnd = 2401) : (h.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, h.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
  }, _scheduleFading:function(a, b, d) {
    var h = this._mixer, c = h.time, f = this._weightInterpolant;
    null === f && (this._weightInterpolant = f = h._lendControlInterpolant());
    h = f.parameterPositions;
    f = f.sampleValues;
    h[0] = c;
    f[0] = b;
    h[1] = c + a;
    f[1] = d;
    return this;
  }});
  Qe.prototype = Object.assign(Object.create(c.prototype), {constructor:Qe, _bindAction:function(a, b) {
    var d = a._localRoot || this._root, h = a._clip.tracks, c = h.length, f = a._propertyBindings;
    a = a._interpolants;
    var e = d.uuid, l = this._bindingsByRootAndName, k = l[e];
    void 0 === k && (k = {}, l[e] = k);
    for (l = 0; l !== c; ++l) {
      var g = h[l], q = g.name, m = k[q];
      if (void 0 === m) {
        m = f[l];
        if (void 0 !== m) {
          null === m._cacheIndex && (++m.referenceCount, this._addInactiveBinding(m, e, q));
          continue;
        }
        m = new Pe(Fa.create(d, q, b && b._propertyBindings[l].binding.parsedPath), g.ValueTypeName, g.getValueSize());
        ++m.referenceCount;
        this._addInactiveBinding(m, e, q);
      }
      f[l] = m;
      a[l].resultBuffer = m.buffer;
    }
  }, _activateAction:function(a) {
    if (!this._isActiveAction(a)) {
      if (null === a._cacheIndex) {
        var b = (a._localRoot || this._root).uuid, d = a._clip.uuid, h = this._actionsByClip[d];
        this._bindAction(a, h && h.knownActions[0]);
        this._addInactiveAction(a, d, b);
      }
      b = a._propertyBindings;
      d = 0;
      for (h = b.length; d !== h; ++d) {
        var c = b[d];
        0 === c.useCount++ && (this._lendBinding(c), c.saveOriginalState());
      }
      this._lendAction(a);
    }
  }, _deactivateAction:function(a) {
    if (this._isActiveAction(a)) {
      for (var b = a._propertyBindings, d = 0, h = b.length; d !== h; ++d) {
        var c = b[d];
        0 === --c.useCount && (c.restoreOriginalState(), this._takeBackBinding(c));
      }
      this._takeBackAction(a);
    }
  }, _initMemoryManager:function() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    var a = this;
    this.stats = {actions:{get total() {
      return a._actions.length;
    }, get inUse() {
      return a._nActiveActions;
    }}, bindings:{get total() {
      return a._bindings.length;
    }, get inUse() {
      return a._nActiveBindings;
    }}, controlInterpolants:{get total() {
      return a._controlInterpolants.length;
    }, get inUse() {
      return a._nActiveControlInterpolants;
    }}};
  }, _isActiveAction:function(a) {
    a = a._cacheIndex;
    return null !== a && a < this._nActiveActions;
  }, _addInactiveAction:function(a, b, d) {
    var h = this._actions, c = this._actionsByClip, f = c[b];
    void 0 === f ? (f = {knownActions:[a], actionByRoot:{}}, a._byClipCacheIndex = 0, c[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, b.push(a));
    a._cacheIndex = h.length;
    h.push(a);
    f.actionByRoot[d] = a;
  }, _removeInactiveAction:function(a) {
    var b = this._actions, d = b[b.length - 1], h = a._cacheIndex;
    d._cacheIndex = h;
    b[h] = d;
    b.pop();
    a._cacheIndex = null;
    b = a._clip.uuid;
    d = this._actionsByClip;
    h = d[b];
    var c = h.knownActions, f = c[c.length - 1], e = a._byClipCacheIndex;
    f._byClipCacheIndex = e;
    c[e] = f;
    c.pop();
    a._byClipCacheIndex = null;
    delete h.actionByRoot[(a._localRoot || this._root).uuid];
    0 === c.length && delete d[b];
    this._removeInactiveBindingsForAction(a);
  }, _removeInactiveBindingsForAction:function(a) {
    a = a._propertyBindings;
    for (var b = 0, d = a.length; b !== d; ++b) {
      var h = a[b];
      0 === --h.referenceCount && this._removeInactiveBinding(h);
    }
  }, _lendAction:function(a) {
    var b = this._actions, d = a._cacheIndex, h = this._nActiveActions++, c = b[h];
    a._cacheIndex = h;
    b[h] = a;
    c._cacheIndex = d;
    b[d] = c;
  }, _takeBackAction:function(a) {
    var b = this._actions, d = a._cacheIndex, h = --this._nActiveActions, c = b[h];
    a._cacheIndex = h;
    b[h] = a;
    c._cacheIndex = d;
    b[d] = c;
  }, _addInactiveBinding:function(a, b, d) {
    var h = this._bindingsByRootAndName, c = h[b], f = this._bindings;
    void 0 === c && (c = {}, h[b] = c);
    c[d] = a;
    a._cacheIndex = f.length;
    f.push(a);
  }, _removeInactiveBinding:function(a) {
    var b = this._bindings, d = a.binding, h = d.rootNode.uuid;
    d = d.path;
    var c = this._bindingsByRootAndName, f = c[h], e = b[b.length - 1];
    a = a._cacheIndex;
    e._cacheIndex = a;
    b[a] = e;
    b.pop();
    delete f[d];
    a: {
      for (var l in f) {
        break a;
      }
      delete c[h];
    }
  }, _lendBinding:function(a) {
    var b = this._bindings, d = a._cacheIndex, h = this._nActiveBindings++, c = b[h];
    a._cacheIndex = h;
    b[h] = a;
    c._cacheIndex = d;
    b[d] = c;
  }, _takeBackBinding:function(a) {
    var b = this._bindings, d = a._cacheIndex, h = --this._nActiveBindings, c = b[h];
    a._cacheIndex = h;
    b[h] = a;
    c._cacheIndex = d;
    b[d] = c;
  }, _lendControlInterpolant:function() {
    var a = this._controlInterpolants, b = this._nActiveControlInterpolants++, d = a[b];
    void 0 === d && (d = new wd(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), d.__cacheIndex = b, a[b] = d);
    return d;
  }, _takeBackControlInterpolant:function(a) {
    var b = this._controlInterpolants, d = a.__cacheIndex, h = --this._nActiveControlInterpolants, c = b[h];
    a.__cacheIndex = h;
    b[h] = a;
    c.__cacheIndex = d;
    b[d] = c;
  }, _controlInterpolantsResultBuffer:new Float32Array(1), clipAction:function(a, b) {
    var d = b || this._root, h = d.uuid;
    d = "string" === typeof a ? Ta.findByName(d, a) : a;
    a = null !== d ? d.uuid : a;
    var c = this._actionsByClip[a], f = null;
    if (void 0 !== c) {
      f = c.actionByRoot[h];
      if (void 0 !== f) {
        return f;
      }
      f = c.knownActions[0];
      null === d && (d = f._clip);
    }
    if (null === d) {
      return null;
    }
    b = new Nf(this, d, b);
    this._bindAction(b, f);
    this._addInactiveAction(b, a, h);
    return b;
  }, existingAction:function(a, b) {
    var d = b || this._root;
    b = d.uuid;
    d = "string" === typeof a ? Ta.findByName(d, a) : a;
    a = this._actionsByClip[d ? d.uuid : a];
    return void 0 !== a ? a.actionByRoot[b] || null : null;
  }, stopAllAction:function() {
    for (var a = this._actions, b = this._nActiveActions, d = this._bindings, c = this._nActiveBindings, f = this._nActiveBindings = this._nActiveActions = 0; f !== b; ++f) {
      a[f].reset();
    }
    for (f = 0; f !== c; ++f) {
      d[f].useCount = 0;
    }
    return this;
  }, update:function(a) {
    a *= this.timeScale;
    for (var b = this._actions, d = this._nActiveActions, h = this.time += a, c = Math.sign(a), f = this._accuIndex ^= 1, e = 0; e !== d; ++e) {
      b[e]._update(h, a, c, f);
    }
    a = this._bindings;
    b = this._nActiveBindings;
    for (e = 0; e !== b; ++e) {
      a[e].apply(f);
    }
    return this;
  }, getRoot:function() {
    return this._root;
  }, uncacheClip:function(a) {
    var b = this._actions;
    a = a.uuid;
    var d = this._actionsByClip, h = d[a];
    if (void 0 !== h) {
      h = h.knownActions;
      for (var c = 0, f = h.length; c !== f; ++c) {
        var e = h[c];
        this._deactivateAction(e);
        var l = e._cacheIndex, k = b[b.length - 1];
        e._cacheIndex = null;
        e._byClipCacheIndex = null;
        k._cacheIndex = l;
        b[l] = k;
        b.pop();
        this._removeInactiveBindingsForAction(e);
      }
      delete d[a];
    }
  }, uncacheRoot:function(a) {
    a = a.uuid;
    var b = this._actionsByClip;
    for (h in b) {
      var d = b[h].actionByRoot[a];
      void 0 !== d && (this._deactivateAction(d), this._removeInactiveAction(d));
    }
    var h = this._bindingsByRootAndName[a];
    if (void 0 !== h) {
      for (var c in h) {
        a = h[c], a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
    }
  }, uncacheAction:function(a, b) {
    a = this.existingAction(a, b);
    null !== a && (this._deactivateAction(a), this._removeInactiveAction(a));
  }});
  ie.prototype.clone = function() {
    return new ie(void 0 === this.value.clone ? this.value : this.value.clone());
  };
  Re.prototype = Object.assign(Object.create(O.prototype), {constructor:Re, isInstancedBufferGeometry:!0, copy:function(a) {
    O.prototype.copy.call(this, a);
    this.maxInstancedCount = a.maxInstancedCount;
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }});
  Se.prototype = Object.assign(Object.create(Pb.prototype), {constructor:Se, isInstancedInterleavedBuffer:!0, copy:function(a) {
    Pb.prototype.copy.call(this, a);
    this.meshPerAttribute = a.meshPerAttribute;
    return this;
  }});
  Te.prototype = Object.assign(Object.create(K.prototype), {constructor:Te, isInstancedBufferAttribute:!0, copy:function(a) {
    K.prototype.copy.call(this, a);
    this.meshPerAttribute = a.meshPerAttribute;
    return this;
  }});
  Object.assign(Of.prototype, {linePrecision:1, set:function(a, b) {
    this.ray.set(a, b);
  }, setFromCamera:function(a, b) {
    b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize()) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
  }, intersectObject:function(a, b, d) {
    d = d || [];
    Ue(a, this, d, b);
    d.sort(Pf);
    return d;
  }, intersectObjects:function(a, b, d) {
    d = d || [];
    if (!1 === Array.isArray(a)) {
      return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), d;
    }
    for (var h = 0, c = a.length; h < c; h++) {
      Ue(a[h], this, d, b);
    }
    d.sort(Pf);
    return d;
  }});
  Object.assign(Qf.prototype, {set:function(a, b, d) {
    this.radius = a;
    this.phi = b;
    this.theta = d;
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.radius = a.radius;
    this.phi = a.phi;
    this.theta = a.theta;
    return this;
  }, makeSafe:function() {
    this.phi = Math.max(1E-6, Math.min(Math.PI - 1E-6, this.phi));
    return this;
  }, setFromVector3:function(a) {
    return this.setFromCartesianCoords(a.x, a.y, a.z);
  }, setFromCartesianCoords:function(a, b, d) {
    this.radius = Math.sqrt(a * a + b * b + d * d);
    0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a, d), this.phi = Math.acos(ia.clamp(b / this.radius, -1, 1)));
    return this;
  }});
  Object.assign(Rf.prototype, {set:function(a, b, d) {
    this.radius = a;
    this.theta = b;
    this.y = d;
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.radius = a.radius;
    this.theta = a.theta;
    this.y = a.y;
    return this;
  }, setFromVector3:function(a) {
    return this.setFromCartesianCoords(a.x, a.y, a.z);
  }, setFromCartesianCoords:function(a, b, d) {
    this.radius = Math.sqrt(a * a + d * d);
    this.theta = Math.atan2(a, d);
    this.y = b;
    return this;
  }});
  Object.assign(Ve.prototype, {set:function(a, b) {
    this.min.copy(a);
    this.max.copy(b);
    return this;
  }, setFromPoints:function(a) {
    this.makeEmpty();
    for (var b = 0, d = a.length; b < d; b++) {
      this.expandByPoint(a[b]);
    }
    return this;
  }, setFromCenterAndSize:function() {
    var a = new g;
    return function(b, d) {
      d = a.copy(d).multiplyScalar(.5);
      this.min.copy(b).sub(d);
      this.max.copy(b).add(d);
      return this;
    };
  }(), clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.min.copy(a.min);
    this.max.copy(a.max);
    return this;
  }, makeEmpty:function() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }, isEmpty:function() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }, getCenter:function(a) {
    void 0 === a && (console.warn("THREE.Box2: .getCenter() target is now required"), a = new g);
    return this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5);
  }, getSize:function(a) {
    void 0 === a && (console.warn("THREE.Box2: .getSize() target is now required"), a = new g);
    return this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min);
  }, expandByPoint:function(a) {
    this.min.min(a);
    this.max.max(a);
    return this;
  }, expandByVector:function(a) {
    this.min.sub(a);
    this.max.add(a);
    return this;
  }, expandByScalar:function(a) {
    this.min.addScalar(-a);
    this.max.addScalar(a);
    return this;
  }, containsPoint:function(a) {
    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0;
  }, containsBox:function(a) {
    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y;
  }, getParameter:function(a, b) {
    void 0 === b && (console.warn("THREE.Box2: .getParameter() target is now required"), b = new g);
    return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y));
  }, intersectsBox:function(a) {
    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0;
  }, clampPoint:function(a, b) {
    void 0 === b && (console.warn("THREE.Box2: .clampPoint() target is now required"), b = new g);
    return b.copy(a).clamp(this.min, this.max);
  }, distanceToPoint:function() {
    var a = new g;
    return function(b) {
      return a.copy(b).clamp(this.min, this.max).sub(b).length();
    };
  }(), intersect:function(a) {
    this.min.max(a.min);
    this.max.min(a.max);
    return this;
  }, union:function(a) {
    this.min.min(a.min);
    this.max.max(a.max);
    return this;
  }, translate:function(a) {
    this.min.add(a);
    this.max.add(a);
    return this;
  }, equals:function(a) {
    return a.min.equals(this.min) && a.max.equals(this.max);
  }});
  Object.assign(We.prototype, {set:function(a, b) {
    this.start.copy(a);
    this.end.copy(b);
    return this;
  }, clone:function() {
    return (new this.constructor).copy(this);
  }, copy:function(a) {
    this.start.copy(a.start);
    this.end.copy(a.end);
    return this;
  }, getCenter:function(a) {
    void 0 === a && (console.warn("THREE.Line3: .getCenter() target is now required"), a = new f);
    return a.addVectors(this.start, this.end).multiplyScalar(.5);
  }, delta:function(a) {
    void 0 === a && (console.warn("THREE.Line3: .delta() target is now required"), a = new f);
    return a.subVectors(this.end, this.start);
  }, distanceSq:function() {
    return this.start.distanceToSquared(this.end);
  }, distance:function() {
    return this.start.distanceTo(this.end);
  }, at:function(a, b) {
    void 0 === b && (console.warn("THREE.Line3: .at() target is now required"), b = new f);
    return this.delta(b).multiplyScalar(a).add(this.start);
  }, closestPointToPointParameter:function() {
    var a = new f, b = new f;
    return function(d, c) {
      a.subVectors(d, this.start);
      b.subVectors(this.end, this.start);
      d = b.dot(b);
      d = b.dot(a) / d;
      c && (d = ia.clamp(d, 0, 1));
      return d;
    };
  }(), closestPointToPoint:function(a, b, d) {
    a = this.closestPointToPointParameter(a, b);
    void 0 === d && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), d = new f);
    return this.delta(d).multiplyScalar(a).add(this.start);
  }, applyMatrix4:function(a) {
    this.start.applyMatrix4(a);
    this.end.applyMatrix4(a);
    return this;
  }, equals:function(a) {
    return a.start.equals(this.start) && a.end.equals(this.end);
  }});
  Ed.prototype = Object.create(G.prototype);
  Ed.prototype.constructor = Ed;
  Ed.prototype.isImmediateRenderObject = !0;
  Fd.prototype = Object.create(pa.prototype);
  Fd.prototype.constructor = Fd;
  Fd.prototype.update = function() {
    var a = new f, b = new f, d = new k;
    return function() {
      var c = ["a", "b", "c"];
      this.object.updateMatrixWorld(!0);
      d.getNormalMatrix(this.object.matrixWorld);
      var h = this.object.matrixWorld, f = this.geometry.attributes.position, e = this.object.geometry;
      if (e && e.isGeometry) {
        for (var l = e.vertices, k = e.faces, g = e = 0, q = k.length; g < q; g++) {
          for (var m = k[g], n = 0, t = m.vertexNormals.length; n < t; n++) {
            var u = m.vertexNormals[n];
            a.copy(l[m[c[n]]]).applyMatrix4(h);
            b.copy(u).applyMatrix3(d).normalize().multiplyScalar(this.size).add(a);
            f.setXYZ(e, a.x, a.y, a.z);
            e += 1;
            f.setXYZ(e, b.x, b.y, b.z);
            e += 1;
          }
        }
      } else {
        if (e && e.isBufferGeometry) {
          for (c = e.attributes.position, l = e.attributes.normal, n = e = 0, t = c.count; n < t; n++) {
            a.set(c.getX(n), c.getY(n), c.getZ(n)).applyMatrix4(h), b.set(l.getX(n), l.getY(n), l.getZ(n)), b.applyMatrix3(d).normalize().multiplyScalar(this.size).add(a), f.setXYZ(e, a.x, a.y, a.z), e += 1, f.setXYZ(e, b.x, b.y, b.z), e += 1;
          }
        }
      }
      f.needsUpdate = !0;
    };
  }();
  Gc.prototype = Object.create(G.prototype);
  Gc.prototype.constructor = Gc;
  Gc.prototype.dispose = function() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  };
  Gc.prototype.update = function() {
    var a = new f;
    return function() {
      this.light.updateMatrixWorld();
      var b = this.light.distance ? this.light.distance : 1E3, d = b * Math.tan(this.light.angle);
      this.cone.scale.set(d, d, b);
      a.setFromMatrixPosition(this.light.target.matrixWorld);
      this.cone.lookAt(a);
      void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
    };
  }();
  Hc.prototype = Object.create(pa.prototype);
  Hc.prototype.constructor = Hc;
  Hc.prototype.updateMatrixWorld = function() {
    var a = new f, d = new b, c = new b;
    return function(b) {
      var h = this.bones, f = this.geometry, e = f.getAttribute("position");
      c.getInverse(this.root.matrixWorld);
      for (var l = 0, k = 0; l < h.length; l++) {
        var g = h[l];
        g.parent && g.parent.isBone && (d.multiplyMatrices(c, g.matrixWorld), a.setFromMatrixPosition(d), e.setXYZ(k, a.x, a.y, a.z), d.multiplyMatrices(c, g.parent.matrixWorld), a.setFromMatrixPosition(d), e.setXYZ(k + 1, a.x, a.y, a.z), k += 2);
      }
      f.getAttribute("position").needsUpdate = !0;
      G.prototype.updateMatrixWorld.call(this, b);
    };
  }();
  Ic.prototype = Object.create(ca.prototype);
  Ic.prototype.constructor = Ic;
  Ic.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
  };
  Ic.prototype.update = function() {
    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  };
  Jc.prototype = Object.create(wa.prototype);
  Jc.prototype.constructor = Jc;
  Jc.prototype.update = function() {
    this.scale.set(.5 * this.light.width, .5 * this.light.height, 1);
    if (void 0 !== this.color) {
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      var a = this.material.color, b = Math.max(a.r, a.g, a.b);
      1 < b && a.multiplyScalar(1 / b);
      this.children[0].material.color.copy(this.material.color);
    }
  };
  Jc.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  };
  Kc.prototype = Object.create(G.prototype);
  Kc.prototype.constructor = Kc;
  Kc.prototype.dispose = function() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  };
  Kc.prototype.update = function() {
    var a = new f, b = new z, d = new z;
    return function() {
      var c = this.children[0];
      if (void 0 !== this.color) {
        this.material.color.set(this.color);
      } else {
        var h = c.geometry.getAttribute("color");
        b.copy(this.light.color);
        d.copy(this.light.groundColor);
        for (var f = 0, e = h.count; f < e; f++) {
          var l = f < e / 2 ? b : d;
          h.setXYZ(f, l.r, l.g, l.b);
        }
        h.needsUpdate = !0;
      }
      c.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
    };
  }();
  Gd.prototype = Object.create(pa.prototype);
  Gd.prototype.constructor = Gd;
  je.prototype = Object.create(pa.prototype);
  je.prototype.constructor = je;
  Lc.prototype = Object.create(wa.prototype);
  Lc.prototype.constructor = Lc;
  Lc.prototype.update = function() {
    function a(a, b, c, h) {
      c = (b - a) / c;
      u.setXYZ(g, 0, 0, 0);
      q++;
      for (m = a; m < b; m += c) {
        n = g + q, u.setXYZ(n, Math.sin(m) * d, 0, Math.cos(m) * d), u.setXYZ(n + 1, Math.sin(Math.min(m + c, b)) * d, 0, Math.cos(Math.min(m + c, b)) * d), u.setXYZ(n + 2, 0, 0, 0), q += 3;
      }
      t.addGroup(g, q, h);
      g += q;
      q = 0;
    }
    var b = this.audio, d = this.range, c = this.divisionsInnerAngle, f = this.divisionsOuterAngle, e = ia.degToRad(b.panner.coneInnerAngle);
    b = ia.degToRad(b.panner.coneOuterAngle);
    var l = e / 2, k = b / 2, g = 0, q = 0, m, n, t = this.geometry, u = t.attributes.position;
    t.clearGroups();
    a(-k, -l, f, 0);
    a(-l, l, c, 1);
    a(l, k, f, 0);
    u.needsUpdate = !0;
    e === b && (this.material[0].visible = !1);
  };
  Lc.prototype.dispose = function() {
    this.geometry.dispose();
    this.material[0].dispose();
    this.material[1].dispose();
  };
  Hd.prototype = Object.create(pa.prototype);
  Hd.prototype.constructor = Hd;
  Hd.prototype.update = function() {
    var a = new f, b = new f, d = new k;
    return function() {
      this.object.updateMatrixWorld(!0);
      d.getNormalMatrix(this.object.matrixWorld);
      var c = this.object.matrixWorld, h = this.geometry.attributes.position, f = this.object.geometry, e = f.vertices;
      f = f.faces;
      for (var l = 0, k = 0, g = f.length; k < g; k++) {
        var q = f[k], m = q.normal;
        a.copy(e[q.a]).add(e[q.b]).add(e[q.c]).divideScalar(3).applyMatrix4(c);
        b.copy(m).applyMatrix3(d).normalize().multiplyScalar(this.size).add(a);
        h.setXYZ(l, a.x, a.y, a.z);
        l += 1;
        h.setXYZ(l, b.x, b.y, b.z);
        l += 1;
      }
      h.needsUpdate = !0;
    };
  }();
  Mc.prototype = Object.create(G.prototype);
  Mc.prototype.constructor = Mc;
  Mc.prototype.dispose = function() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  };
  Mc.prototype.update = function() {
    var a = new f, b = new f, d = new f;
    return function() {
      a.setFromMatrixPosition(this.light.matrixWorld);
      b.setFromMatrixPosition(this.light.target.matrixWorld);
      d.subVectors(b, a);
      this.lightPlane.lookAt(b);
      void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color));
      this.targetLine.lookAt(b);
      this.targetLine.scale.z = d.length();
    };
  }();
  Id.prototype = Object.create(pa.prototype);
  Id.prototype.constructor = Id;
  Id.prototype.update = function() {
    function a(a, h, f, l) {
      c.set(h, f, l).unproject(e);
      a = d[a];
      if (void 0 !== a) {
        for (h = b.getAttribute("position"), f = 0, l = a.length; f < l; f++) {
          h.setXYZ(a[f], c.x, c.y, c.z);
        }
      }
    }
    var b, d, c = new f, e = new jb;
    return function() {
      b = this.geometry;
      d = this.pointMap;
      e.projectionMatrix.copy(this.camera.projectionMatrix);
      a("c", 0, 0, -1);
      a("t", 0, 0, 1);
      a("n1", -1, -1, -1);
      a("n2", 1, -1, -1);
      a("n3", -1, 1, -1);
      a("n4", 1, 1, -1);
      a("f1", -1, -1, 1);
      a("f2", 1, -1, 1);
      a("f3", -1, 1, 1);
      a("f4", 1, 1, 1);
      a("u1", .7, 1.1, -1);
      a("u2", -.7, 1.1, -1);
      a("u3", 0, 2, -1);
      a("cf1", -1, 0, 1);
      a("cf2", 1, 0, 1);
      a("cf3", 0, -1, 1);
      a("cf4", 0, 1, 1);
      a("cn1", -1, 0, -1);
      a("cn2", 1, 0, -1);
      a("cn3", 0, -1, -1);
      a("cn4", 0, 1, -1);
      b.getAttribute("position").needsUpdate = !0;
    };
  }();
  zb.prototype = Object.create(pa.prototype);
  zb.prototype.constructor = zb;
  zb.prototype.update = function() {
    var a = new u;
    return function(b) {
      void 0 !== b && console.warn("THREE.BoxHelper: .update() has no longer arguments.");
      void 0 !== this.object && a.setFromObject(this.object);
      if (!a.isEmpty()) {
        b = a.min;
        var d = a.max, c = this.geometry.attributes.position, h = c.array;
        h[0] = d.x;
        h[1] = d.y;
        h[2] = d.z;
        h[3] = b.x;
        h[4] = d.y;
        h[5] = d.z;
        h[6] = b.x;
        h[7] = b.y;
        h[8] = d.z;
        h[9] = d.x;
        h[10] = b.y;
        h[11] = d.z;
        h[12] = d.x;
        h[13] = d.y;
        h[14] = b.z;
        h[15] = b.x;
        h[16] = d.y;
        h[17] = b.z;
        h[18] = b.x;
        h[19] = b.y;
        h[20] = b.z;
        h[21] = d.x;
        h[22] = b.y;
        h[23] = b.z;
        c.needsUpdate = !0;
        this.geometry.computeBoundingSphere();
      }
    };
  }();
  zb.prototype.setFromObject = function(a) {
    this.object = a;
    this.update();
    return this;
  };
  zb.prototype.copy = function(a) {
    pa.prototype.copy.call(this, a);
    this.object = a.object;
    return this;
  };
  zb.prototype.clone = function() {
    return (new this.constructor).copy(this);
  };
  Jd.prototype = Object.create(pa.prototype);
  Jd.prototype.constructor = Jd;
  Jd.prototype.updateMatrixWorld = function(a) {
    var b = this.box;
    b.isEmpty() || (b.getCenter(this.position), b.getSize(this.scale), this.scale.multiplyScalar(.5), G.prototype.updateMatrixWorld.call(this, a));
  };
  Kd.prototype = Object.create(wa.prototype);
  Kd.prototype.constructor = Kd;
  Kd.prototype.updateMatrixWorld = function(a) {
    var b = -this.plane.constant;
    1E-8 > Math.abs(b) && (b = 1E-8);
    this.scale.set(.5 * this.size, .5 * this.size, b);
    this.children[0].material.side = 0 > b ? 1 : 0;
    this.lookAt(this.plane.normal);
    G.prototype.updateMatrixWorld.call(this, a);
  };
  var ke, Xe;
  Ab.prototype = Object.create(G.prototype);
  Ab.prototype.constructor = Ab;
  Ab.prototype.setDirection = function() {
    var a = new f, b;
    return function(d) {
      .99999 < d.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > d.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(d.z, 0, -d.x).normalize(), b = Math.acos(d.y), this.quaternion.setFromAxisAngle(a, b));
    };
  }();
  Ab.prototype.setLength = function(a, b, d) {
    void 0 === b && (b = .2 * a);
    void 0 === d && (d = .2 * b);
    this.line.scale.set(1, Math.max(0, a - b), 1);
    this.line.updateMatrix();
    this.cone.scale.set(d, b, d);
    this.cone.position.y = a;
    this.cone.updateMatrix();
  };
  Ab.prototype.setColor = function(a) {
    this.line.material.color.copy(a);
    this.cone.material.color.copy(a);
  };
  Ab.prototype.copy = function(a) {
    G.prototype.copy.call(this, a, !1);
    this.line.copy(a.line);
    this.cone.copy(a.cone);
    return this;
  };
  Ab.prototype.clone = function() {
    return (new this.constructor).copy(this);
  };
  Ld.prototype = Object.create(pa.prototype);
  Ld.prototype.constructor = Ld;
  da.create = function(a, b) {
    console.log("THREE.Curve.create() has been deprecated");
    a.prototype = Object.create(da.prototype);
    a.prototype.constructor = a;
    a.prototype.getPoint = b;
    return a;
  };
  Object.assign(yb.prototype, {createPointsGeometry:function(a) {
    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    a = this.getPoints(a);
    return this.createGeometry(a);
  }, createSpacedPointsGeometry:function(a) {
    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    a = this.getSpacedPoints(a);
    return this.createGeometry(a);
  }, createGeometry:function(a) {
    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    for (var b = new H, d = 0, c = a.length; d < c; d++) {
      var h = a[d];
      b.vertices.push(new f(h.x, h.y, h.z || 0));
    }
    return b;
  }});
  Object.assign(db.prototype, {fromPoints:function(a) {
    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
    this.setFromPoints(a);
  }});
  Tf.prototype = Object.create(Ea.prototype);
  Uf.prototype = Object.create(Ea.prototype);
  Ye.prototype = Object.create(Ea.prototype);
  Object.assign(Ye.prototype, {initFromArray:function() {
    console.error("THREE.Spline: .initFromArray() has been removed.");
  }, getControlPointsArray:function() {
    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
  }, reparametrizeByArcLength:function() {
    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
  }});
  Gd.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  };
  Hc.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
  };
  Object.assign(Cd.prototype, {extractUrlBase:function(a) {
    console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
    return cf.extractUrlBase(a);
  }});
  Object.assign(Fe.prototype, {setTexturePath:function(a) {
    console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
    return this.setResourcePath(a);
  }});
  Object.assign(Ve.prototype, {center:function(a) {
    console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
    return this.getCenter(a);
  }, empty:function() {
    console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  }, isIntersectionBox:function(a) {
    console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(a);
  }, size:function(a) {
    console.warn("THREE.Box2: .size() has been renamed to .getSize().");
    return this.getSize(a);
  }});
  Object.assign(u.prototype, {center:function(a) {
    console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
    return this.getCenter(a);
  }, empty:function() {
    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  }, isIntersectionBox:function(a) {
    console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(a);
  }, isIntersectionSphere:function(a) {
    console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(a);
  }, size:function(a) {
    console.warn("THREE.Box3: .size() has been renamed to .getSize().");
    return this.getSize(a);
  }});
  We.prototype.center = function(a) {
    console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
    return this.getCenter(a);
  };
  Object.assign(ia, {random16:function() {
    console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
    return Math.random();
  }, nearestPowerOfTwo:function(a) {
    console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
    return ia.floorPowerOfTwo(a);
  }, nextPowerOfTwo:function(a) {
    console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
    return ia.ceilPowerOfTwo(a);
  }});
  Object.assign(k.prototype, {flattenToArrayOffset:function(a, b) {
    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(a, b);
  }, multiplyVector3:function(a) {
    console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
    return a.applyMatrix3(this);
  }, multiplyVector3Array:function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  }, applyToBuffer:function(a) {
    console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
    return this.applyToBufferAttribute(a);
  }, applyToVector3Array:function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }});
  Object.assign(b.prototype, {extractPosition:function(a) {
    console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
    return this.copyPosition(a);
  }, flattenToArrayOffset:function(a, b) {
    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(a, b);
  }, getPosition:function() {
    var a;
    return function() {
      void 0 === a && (a = new f);
      console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
      return a.setFromMatrixColumn(this, 3);
    };
  }(), setRotationFromQuaternion:function(a) {
    console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
    return this.makeRotationFromQuaternion(a);
  }, multiplyToArray:function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  }, multiplyVector3:function(a) {
    console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return a.applyMatrix4(this);
  }, multiplyVector4:function(a) {
    console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return a.applyMatrix4(this);
  }, multiplyVector3Array:function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  }, rotateAxis:function(a) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
    a.transformDirection(this);
  }, crossVector:function(a) {
    console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return a.applyMatrix4(this);
  }, translate:function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  }, rotateX:function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  }, rotateY:function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  }, rotateZ:function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  }, rotateByAxis:function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  }, applyToBuffer:function(a) {
    console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
    return this.applyToBufferAttribute(a);
  }, applyToVector3Array:function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  }, makeFrustum:function(a, b, d, c, f, e) {
    console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
    return this.makePerspective(a, b, c, d, f, e);
  }});
  y.prototype.isIntersectionLine = function(a) {
    console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
    return this.intersectsLine(a);
  };
  e.prototype.multiplyVector3 = function(a) {
    console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
    return a.applyQuaternion(this);
  };
  Object.assign(ba.prototype, {isIntersectionBox:function(a) {
    console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(a);
  }, isIntersectionPlane:function(a) {
    console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
    return this.intersectsPlane(a);
  }, isIntersectionSphere:function(a) {
    console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(a);
  }});
  Object.assign(la.prototype, {area:function() {
    console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
    return this.getArea();
  }, barycoordFromPoint:function(a, b) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return this.getBarycoord(a, b);
  }, midpoint:function(a) {
    console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
    return this.getMidpoint(a);
  }, normal:function(a) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return this.getNormal(a);
  }, plane:function(a) {
    console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
    return this.getPlane(a);
  }});
  Object.assign(la, {barycoordFromPoint:function(a, b, d, c, f) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return la.getBarycoord(a, b, d, c, f);
  }, normal:function(a, b, d, c) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return la.getNormal(a, b, d, c);
  }});
  Object.assign(Lb.prototype, {extractAllPoints:function(a) {
    console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
    return this.extractPoints(a);
  }, extrude:function(a) {
    console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
    return new Tb(this, a);
  }, makeGeometry:function(a) {
    console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
    return new Vb(this, a);
  }});
  Object.assign(g.prototype, {fromAttribute:function(a, b, d) {
    console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(a, b, d);
  }, distanceToManhattan:function(a) {
    console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
    return this.manhattanDistanceTo(a);
  }, lengthManhattan:function() {
    console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  }});
  Object.assign(f.prototype, {setEulerFromRotationMatrix:function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  }, setEulerFromQuaternion:function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  }, getPositionFromMatrix:function(a) {
    console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
    return this.setFromMatrixPosition(a);
  }, getScaleFromMatrix:function(a) {
    console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
    return this.setFromMatrixScale(a);
  }, getColumnFromMatrix:function(a, b) {
    console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
    return this.setFromMatrixColumn(b, a);
  }, applyProjection:function(a) {
    console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
    return this.applyMatrix4(a);
  }, fromAttribute:function(a, b, d) {
    console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(a, b, d);
  }, distanceToManhattan:function(a) {
    console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
    return this.manhattanDistanceTo(a);
  }, lengthManhattan:function() {
    console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  }});
  Object.assign(p.prototype, {fromAttribute:function(a, b, d) {
    console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(a, b, d);
  }, lengthManhattan:function() {
    console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  }});
  Object.assign(H.prototype, {computeTangents:function() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  }, computeLineDistances:function() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  }});
  Object.assign(G.prototype, {getChildByName:function(a) {
    console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
    return this.getObjectByName(a);
  }, renderDepth:function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  }, translate:function(a, b) {
    console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
    return this.translateOnAxis(b, a);
  }, getWorldRotation:function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  }});
  Object.defineProperties(G.prototype, {eulerOrder:{get:function() {
    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
    return this.rotation.order;
  }, set:function(a) {
    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
    this.rotation.order = a;
  }}, useQuaternion:{get:function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  }, set:function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  }}});
  Object.defineProperties(Zc.prototype, {objects:{get:function() {
    console.warn("THREE.LOD: .objects has been renamed to .levels.");
    return this.levels;
  }}});
  Object.defineProperty(Qd.prototype, "useVertexTexture", {get:function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }, set:function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }});
  $c.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  };
  Object.defineProperty(da.prototype, "__arcLengthDivisions", {get:function() {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    return this.arcLengthDivisions;
  }, set:function(a) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    this.arcLengthDivisions = a;
  }});
  va.prototype.setLens = function(a, b) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    void 0 !== b && (this.filmGauge = b);
    this.setFocalLength(a);
  };
  Object.defineProperties(ta.prototype, {onlyShadow:{set:function() {
    console.warn("THREE.Light: .onlyShadow has been removed.");
  }}, shadowCameraFov:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
    this.shadow.camera.fov = a;
  }}, shadowCameraLeft:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
    this.shadow.camera.left = a;
  }}, shadowCameraRight:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
    this.shadow.camera.right = a;
  }}, shadowCameraTop:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
    this.shadow.camera.top = a;
  }}, shadowCameraBottom:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
    this.shadow.camera.bottom = a;
  }}, shadowCameraNear:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
    this.shadow.camera.near = a;
  }}, shadowCameraFar:{set:function(a) {
    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
    this.shadow.camera.far = a;
  }}, shadowCameraVisible:{set:function() {
    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
  }}, shadowBias:{set:function(a) {
    console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
    this.shadow.bias = a;
  }}, shadowDarkness:{set:function() {
    console.warn("THREE.Light: .shadowDarkness has been removed.");
  }}, shadowMapWidth:{set:function(a) {
    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
    this.shadow.mapSize.width = a;
  }}, shadowMapHeight:{set:function(a) {
    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
    this.shadow.mapSize.height = a;
  }}});
  Object.defineProperties(K.prototype, {length:{get:function() {
    console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
    return this.array.length;
  }}, copyIndicesArray:function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  }});
  Object.assign(O.prototype, {addIndex:function(a) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
    this.setIndex(a);
  }, addDrawCall:function(a, b, d) {
    void 0 !== d && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
    this.addGroup(a, b);
  }, clearDrawCalls:function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
    this.clearGroups();
  }, computeTangents:function() {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  }, computeOffsets:function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  }});
  Object.defineProperties(O.prototype, {drawcalls:{get:function() {
    console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
    return this.groups;
  }}, offsets:{get:function() {
    console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
    return this.groups;
  }}});
  Object.assign(kb.prototype, {getArrays:function() {
    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
  }, addShapeList:function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
  }, addShape:function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
  }});
  Object.defineProperties(ie.prototype, {dynamic:{set:function() {
    console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
  }}, onUpdate:{value:function() {
    console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
    return this;
  }}});
  Object.defineProperties(X.prototype, {wrapAround:{get:function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  }, set:function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  }}, overdraw:{get:function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  }, set:function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  }}, wrapRGB:{get:function() {
    console.warn("THREE.Material: .wrapRGB has been removed.");
    return new z;
  }}, shading:{get:function() {
    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
  }, set:function(a) {
    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    this.flatShading = 1 === a;
  }}});
  Object.defineProperties(Ya.prototype, {metal:{get:function() {
    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
    return !1;
  }, set:function() {
    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
  }}});
  Object.defineProperties(fa.prototype, {derivatives:{get:function() {
    console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
    return this.extensions.derivatives;
  }, set:function(a) {
    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
    this.extensions.derivatives = a;
  }}});
  Object.assign(ve.prototype, {clearTarget:function(a, b, d, c) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
    this.setRenderTarget(a);
    this.clear(b, d, c);
  }, animate:function(a) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
    this.setAnimationLoop(a);
  }, getCurrentRenderTarget:function() {
    console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
    return this.getRenderTarget();
  }, getMaxAnisotropy:function() {
    console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
    return this.capabilities.getMaxAnisotropy();
  }, getPrecision:function() {
    console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
    return this.capabilities.precision;
  }, resetGLState:function() {
    console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
    return this.state.reset();
  }, supportsFloatTextures:function() {
    console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
    return this.extensions.get("OES_texture_float");
  }, supportsHalfFloatTextures:function() {
    console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
    return this.extensions.get("OES_texture_half_float");
  }, supportsStandardDerivatives:function() {
    console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
    return this.extensions.get("OES_standard_derivatives");
  }, supportsCompressedTextureS3TC:function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
    return this.extensions.get("WEBGL_compressed_texture_s3tc");
  }, supportsCompressedTexturePVRTC:function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
    return this.extensions.get("WEBGL_compressed_texture_pvrtc");
  }, supportsBlendMinMax:function() {
    console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
    return this.extensions.get("EXT_blend_minmax");
  }, supportsVertexTextures:function() {
    console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
    return this.capabilities.vertexTextures;
  }, supportsInstancedArrays:function() {
    console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
    return this.extensions.get("ANGLE_instanced_arrays");
  }, enableScissorTest:function(a) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
    this.setScissorTest(a);
  }, initMaterial:function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  }, addPrePlugin:function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  }, addPostPlugin:function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  }, updateShadowMap:function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  }, setFaceCulling:function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  }});
  Object.defineProperties(ve.prototype, {shadowMapEnabled:{get:function() {
    return this.shadowMap.enabled;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
    this.shadowMap.enabled = a;
  }}, shadowMapType:{get:function() {
    return this.shadowMap.type;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
    this.shadowMap.type = a;
  }}, shadowMapCullFace:{get:function() {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
  }, set:function() {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
  }}});
  Object.defineProperties(rf.prototype, {cullFace:{get:function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  }, set:function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  }}, renderReverseSided:{get:function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
  }, set:function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
  }}, renderSingleSided:{get:function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  }, set:function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  }}});
  Object.defineProperties(m.prototype, {wrapS:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
    return this.texture.wrapS;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
    this.texture.wrapS = a;
  }}, wrapT:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
    return this.texture.wrapT;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
    this.texture.wrapT = a;
  }}, magFilter:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
    return this.texture.magFilter;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
    this.texture.magFilter = a;
  }}, minFilter:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
    return this.texture.minFilter;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
    this.texture.minFilter = a;
  }}, anisotropy:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
    return this.texture.anisotropy;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
    this.texture.anisotropy = a;
  }}, offset:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
    return this.texture.offset;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
    this.texture.offset = a;
  }}, repeat:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
    return this.texture.repeat;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
    this.texture.repeat = a;
  }}, format:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
    return this.texture.format;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
    this.texture.format = a;
  }}, type:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
    return this.texture.type;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
    this.texture.type = a;
  }}, generateMipmaps:{get:function() {
    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
    return this.texture.generateMipmaps;
  }, set:function(a) {
    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
    this.texture.generateMipmaps = a;
  }}});
  Object.defineProperties(wf.prototype, {standing:{set:function() {
    console.warn("THREE.WebVRManager: .standing has been removed.");
  }}, userHeight:{set:function() {
    console.warn("THREE.WebVRManager: .userHeight has been removed.");
  }}});
  Fc.prototype.load = function(a) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    var b = this;
    (new Je).load(a, function(a) {
      b.setBuffer(a);
    });
    return this;
  };
  Oe.prototype.getData = function() {
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
    return this.getFrequencyData();
  };
  Dd.prototype.updateCubeMap = function(a, b) {
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
    return this.update(a, b);
  };
  Mb.crossOrigin = void 0;
  Mb.loadTexture = function(a, b, d, c) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    var h = new Zd;
    h.setCrossOrigin(this.crossOrigin);
    a = h.load(a, d, void 0, c);
    b && (a.mapping = b);
    return a;
  };
  Mb.loadTextureCube = function(a, b, d, c) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    var h = new Ce;
    h.setCrossOrigin(this.crossOrigin);
    a = h.load(a, d, void 0, c);
    b && (a.mapping = b);
    return a;
  };
  Mb.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  };
  Mb.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  };
  a.WebGLMultisampleRenderTarget = t;
  a.WebGLRenderTargetCube = d;
  a.WebGLRenderTarget = m;
  a.WebGLRenderer = ve;
  a.ShaderLib = fb;
  a.UniformsLib = ea;
  a.UniformsUtils = zg;
  a.ShaderChunk = na;
  a.FogExp2 = kc;
  a.Fog = lc;
  a.Scene = Pd;
  a.Sprite = Yc;
  a.LOD = Zc;
  a.SkinnedMesh = $c;
  a.Skeleton = Qd;
  a.Bone = we;
  a.Mesh = ca;
  a.LineSegments = pa;
  a.LineLoop = Rd;
  a.Line = wa;
  a.Points = nc;
  a.Group = jc;
  a.VideoTexture = xe;
  a.DataTexture = l;
  a.DataTexture3D = Ja;
  a.CompressedTexture = oc;
  a.CubeTexture = za;
  a.CanvasTexture = ad;
  a.DepthTexture = bd;
  a.Texture = n;
  a.AnimationLoader = Gf;
  a.CompressedTextureLoader = Hf;
  a.DataTextureLoader = Be;
  a.CubeTextureLoader = Ce;
  a.TextureLoader = Zd;
  a.ObjectLoader = Fe;
  a.MaterialLoader = he;
  a.BufferGeometryLoader = Ee;
  a.DefaultLoadingManager = La;
  a.LoadingManager = Ae;
  a.ImageLoader = yd;
  a.ImageBitmapLoader = Ge;
  a.FontLoader = Jf;
  a.FileLoader = Za;
  a.Loader = Cd;
  a.LoaderUtils = cf;
  a.Cache = fc;
  a.AudioLoader = Je;
  a.SpotLightShadow = ae;
  a.SpotLight = be;
  a.PointLight = ce;
  a.RectAreaLight = ge;
  a.HemisphereLight = $d;
  a.DirectionalLightShadow = de;
  a.DirectionalLight = ee;
  a.AmbientLight = fe;
  a.LightShadow = ec;
  a.Light = ta;
  a.StereoCamera = Kf;
  a.PerspectiveCamera = va;
  a.OrthographicCamera = Bd;
  a.CubeCamera = Dd;
  a.ArrayCamera = Wc;
  a.Camera = jb;
  a.AudioListener = Le;
  a.PositionalAudio = Ne;
  a.AudioContext = Me;
  a.AudioAnalyser = Oe;
  a.Audio = Fc;
  a.VectorKeyframeTrack = Dc;
  a.StringKeyframeTrack = Yd;
  a.QuaternionKeyframeTrack = xd;
  a.NumberKeyframeTrack = Cc;
  a.ColorKeyframeTrack = Wd;
  a.BooleanKeyframeTrack = Vd;
  a.PropertyMixer = Pe;
  a.PropertyBinding = Fa;
  a.KeyframeTrack = Da;
  a.AnimationUtils = xa;
  a.AnimationObjectGroup = Mf;
  a.AnimationMixer = Qe;
  a.AnimationClip = Ta;
  a.Uniform = ie;
  a.InstancedBufferGeometry = Re;
  a.BufferGeometry = O;
  a.Geometry = H;
  a.InterleavedBufferAttribute = Xc;
  a.InstancedInterleavedBuffer = Se;
  a.InterleavedBuffer = Pb;
  a.InstancedBufferAttribute = Te;
  a.Face3 = D;
  a.Object3D = G;
  a.Raycaster = Of;
  a.Layers = B;
  a.EventDispatcher = c;
  a.Clock = Ke;
  a.QuaternionLinearInterpolant = Xd;
  a.LinearInterpolant = wd;
  a.DiscreteInterpolant = Ud;
  a.CubicInterpolant = Td;
  a.Interpolant = Na;
  a.Triangle = la;
  a.Math = ia;
  a.Spherical = Qf;
  a.Cylindrical = Rf;
  a.Plane = y;
  a.Frustum = x;
  a.Sphere = w;
  a.Ray = ba;
  a.Matrix4 = b;
  a.Matrix3 = k;
  a.Box3 = u;
  a.Box2 = Ve;
  a.Line3 = We;
  a.Euler = E;
  a.Vector4 = p;
  a.Vector3 = f;
  a.Vector2 = g;
  a.Quaternion = e;
  a.Color = z;
  a.ImmediateRenderObject = Ed;
  a.VertexNormalsHelper = Fd;
  a.SpotLightHelper = Gc;
  a.SkeletonHelper = Hc;
  a.PointLightHelper = Ic;
  a.RectAreaLightHelper = Jc;
  a.HemisphereLightHelper = Kc;
  a.GridHelper = Gd;
  a.PolarGridHelper = je;
  a.PositionalAudioHelper = Lc;
  a.FaceNormalsHelper = Hd;
  a.DirectionalLightHelper = Mc;
  a.CameraHelper = Id;
  a.BoxHelper = zb;
  a.Box3Helper = Jd;
  a.PlaneHelper = Kd;
  a.ArrowHelper = Ab;
  a.AxesHelper = Ld;
  a.Shape = Lb;
  a.Path = db;
  a.ShapePath = He;
  a.Font = Ie;
  a.CurvePath = yb;
  a.Curve = da;
  a.ImageUtils = Mb;
  a.ShapeUtils = wb;
  a.WebGLUtils = sf;
  a.WireframeGeometry = pc;
  a.ParametricGeometry = cd;
  a.ParametricBufferGeometry = qc;
  a.TetrahedronGeometry = ed;
  a.TetrahedronBufferGeometry = rc;
  a.OctahedronGeometry = fd;
  a.OctahedronBufferGeometry = Qb;
  a.IcosahedronGeometry = gd;
  a.IcosahedronBufferGeometry = sc;
  a.DodecahedronGeometry = hd;
  a.DodecahedronBufferGeometry = tc;
  a.PolyhedronGeometry = dd;
  a.PolyhedronBufferGeometry = Ka;
  a.TubeGeometry = id;
  a.TubeBufferGeometry = Rb;
  a.TorusKnotGeometry = jd;
  a.TorusKnotBufferGeometry = uc;
  a.TorusGeometry = kd;
  a.TorusBufferGeometry = vc;
  a.TextGeometry = pd;
  a.TextBufferGeometry = wc;
  a.SphereGeometry = qd;
  a.SphereBufferGeometry = Ub;
  a.RingGeometry = rd;
  a.RingBufferGeometry = xc;
  a.PlaneGeometry = ha;
  a.PlaneBufferGeometry = ja;
  a.LatheGeometry = sd;
  a.LatheBufferGeometry = yc;
  a.ShapeGeometry = Vb;
  a.ShapeBufferGeometry = Wb;
  a.ExtrudeGeometry = Tb;
  a.ExtrudeBufferGeometry = kb;
  a.EdgesGeometry = zc;
  a.ConeGeometry = td;
  a.ConeBufferGeometry = ud;
  a.CylinderGeometry = Xb;
  a.CylinderBufferGeometry = xb;
  a.CircleGeometry = vd;
  a.CircleBufferGeometry = Ac;
  a.BoxGeometry = P;
  a.CubeGeometry = P;
  a.BoxBufferGeometry = ka;
  a.ShadowMaterial = Yb;
  a.SpriteMaterial = Kb;
  a.RawShaderMaterial = Bc;
  a.ShaderMaterial = fa;
  a.PointsMaterial = Xa;
  a.MeshPhysicalMaterial = Zb;
  a.MeshStandardMaterial = lb;
  a.MeshPhongMaterial = Ya;
  a.MeshToonMaterial = $b;
  a.MeshNormalMaterial = ac;
  a.MeshLambertMaterial = bc;
  a.MeshDepthMaterial = Ib;
  a.MeshDistanceMaterial = Jb;
  a.MeshBasicMaterial = ma;
  a.MeshMatcapMaterial = cc;
  a.LineDashedMaterial = dc;
  a.LineBasicMaterial = ra;
  a.Material = X;
  a.Float64BufferAttribute = S;
  a.Float32BufferAttribute = N;
  a.Uint32BufferAttribute = U;
  a.Int32BufferAttribute = aa;
  a.Uint16BufferAttribute = Q;
  a.Int16BufferAttribute = J;
  a.Uint8ClampedBufferAttribute = R;
  a.Uint8BufferAttribute = L;
  a.Int8BufferAttribute = I;
  a.BufferAttribute = K;
  a.ArcCurve = Ec;
  a.CatmullRomCurve3 = Ea;
  a.CubicBezierCurve = $a;
  a.CubicBezierCurve3 = mb;
  a.EllipseCurve = Oa;
  a.LineCurve = Ma;
  a.LineCurve3 = ab;
  a.QuadraticBezierCurve = bb;
  a.QuadraticBezierCurve3 = nb;
  a.SplineCurve = cb;
  a.REVISION = "102dev";
  a.MOUSE = {LEFT:0, MIDDLE:1, RIGHT:2};
  a.CullFaceNone = 0;
  a.CullFaceBack = 1;
  a.CullFaceFront = 2;
  a.CullFaceFrontBack = 3;
  a.FrontFaceDirectionCW = 0;
  a.FrontFaceDirectionCCW = 1;
  a.BasicShadowMap = 0;
  a.PCFShadowMap = 1;
  a.PCFSoftShadowMap = 2;
  a.FrontSide = 0;
  a.BackSide = 1;
  a.DoubleSide = 2;
  a.FlatShading = 1;
  a.SmoothShading = 2;
  a.NoColors = 0;
  a.FaceColors = 1;
  a.VertexColors = 2;
  a.NoBlending = 0;
  a.NormalBlending = 1;
  a.AdditiveBlending = 2;
  a.SubtractiveBlending = 3;
  a.MultiplyBlending = 4;
  a.CustomBlending = 5;
  a.AddEquation = 100;
  a.SubtractEquation = 101;
  a.ReverseSubtractEquation = 102;
  a.MinEquation = 103;
  a.MaxEquation = 104;
  a.ZeroFactor = 200;
  a.OneFactor = 201;
  a.SrcColorFactor = 202;
  a.OneMinusSrcColorFactor = 203;
  a.SrcAlphaFactor = 204;
  a.OneMinusSrcAlphaFactor = 205;
  a.DstAlphaFactor = 206;
  a.OneMinusDstAlphaFactor = 207;
  a.DstColorFactor = 208;
  a.OneMinusDstColorFactor = 209;
  a.SrcAlphaSaturateFactor = 210;
  a.NeverDepth = 0;
  a.AlwaysDepth = 1;
  a.LessDepth = 2;
  a.LessEqualDepth = 3;
  a.EqualDepth = 4;
  a.GreaterEqualDepth = 5;
  a.GreaterDepth = 6;
  a.NotEqualDepth = 7;
  a.MultiplyOperation = 0;
  a.MixOperation = 1;
  a.AddOperation = 2;
  a.NoToneMapping = 0;
  a.LinearToneMapping = 1;
  a.ReinhardToneMapping = 2;
  a.Uncharted2ToneMapping = 3;
  a.CineonToneMapping = 4;
  a.ACESFilmicToneMapping = 5;
  a.UVMapping = 300;
  a.CubeReflectionMapping = 301;
  a.CubeRefractionMapping = 302;
  a.EquirectangularReflectionMapping = 303;
  a.EquirectangularRefractionMapping = 304;
  a.SphericalReflectionMapping = 305;
  a.CubeUVReflectionMapping = 306;
  a.CubeUVRefractionMapping = 307;
  a.RepeatWrapping = 1E3;
  a.ClampToEdgeWrapping = 1001;
  a.MirroredRepeatWrapping = 1002;
  a.NearestFilter = 1003;
  a.NearestMipMapNearestFilter = 1004;
  a.NearestMipMapLinearFilter = 1005;
  a.LinearFilter = 1006;
  a.LinearMipMapNearestFilter = 1007;
  a.LinearMipMapLinearFilter = 1008;
  a.UnsignedByteType = 1009;
  a.ByteType = 1010;
  a.ShortType = 1011;
  a.UnsignedShortType = 1012;
  a.IntType = 1013;
  a.UnsignedIntType = 1014;
  a.FloatType = 1015;
  a.HalfFloatType = 1016;
  a.UnsignedShort4444Type = 1017;
  a.UnsignedShort5551Type = 1018;
  a.UnsignedShort565Type = 1019;
  a.UnsignedInt248Type = 1020;
  a.AlphaFormat = 1021;
  a.RGBFormat = 1022;
  a.RGBAFormat = 1023;
  a.LuminanceFormat = 1024;
  a.LuminanceAlphaFormat = 1025;
  a.RGBEFormat = 1023;
  a.DepthFormat = 1026;
  a.DepthStencilFormat = 1027;
  a.RedFormat = 1028;
  a.RGB_S3TC_DXT1_Format = 33776;
  a.RGBA_S3TC_DXT1_Format = 33777;
  a.RGBA_S3TC_DXT3_Format = 33778;
  a.RGBA_S3TC_DXT5_Format = 33779;
  a.RGB_PVRTC_4BPPV1_Format = 35840;
  a.RGB_PVRTC_2BPPV1_Format = 35841;
  a.RGBA_PVRTC_4BPPV1_Format = 35842;
  a.RGBA_PVRTC_2BPPV1_Format = 35843;
  a.RGB_ETC1_Format = 36196;
  a.RGBA_ASTC_4x4_Format = 37808;
  a.RGBA_ASTC_5x4_Format = 37809;
  a.RGBA_ASTC_5x5_Format = 37810;
  a.RGBA_ASTC_6x5_Format = 37811;
  a.RGBA_ASTC_6x6_Format = 37812;
  a.RGBA_ASTC_8x5_Format = 37813;
  a.RGBA_ASTC_8x6_Format = 37814;
  a.RGBA_ASTC_8x8_Format = 37815;
  a.RGBA_ASTC_10x5_Format = 37816;
  a.RGBA_ASTC_10x6_Format = 37817;
  a.RGBA_ASTC_10x8_Format = 37818;
  a.RGBA_ASTC_10x10_Format = 37819;
  a.RGBA_ASTC_12x10_Format = 37820;
  a.RGBA_ASTC_12x12_Format = 37821;
  a.LoopOnce = 2200;
  a.LoopRepeat = 2201;
  a.LoopPingPong = 2202;
  a.InterpolateDiscrete = 2300;
  a.InterpolateLinear = 2301;
  a.InterpolateSmooth = 2302;
  a.ZeroCurvatureEnding = 2400;
  a.ZeroSlopeEnding = 2401;
  a.WrapAroundEnding = 2402;
  a.TrianglesDrawMode = 0;
  a.TriangleStripDrawMode = 1;
  a.TriangleFanDrawMode = 2;
  a.LinearEncoding = 3E3;
  a.sRGBEncoding = 3001;
  a.GammaEncoding = 3007;
  a.RGBEEncoding = 3002;
  a.LogLuvEncoding = 3003;
  a.RGBM7Encoding = 3004;
  a.RGBM16Encoding = 3005;
  a.RGBDEncoding = 3006;
  a.BasicDepthPacking = 3200;
  a.RGBADepthPacking = 3201;
  a.TangentSpaceNormalMap = 0;
  a.ObjectSpaceNormalMap = 1;
  a.Face4 = function(a, b, d, c, f, e, l) {
    console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
    return new D(a, b, d, f, e, l);
  };
  a.LineStrip = 0;
  a.LinePieces = 1;
  a.MeshFaceMaterial = function(a) {
    console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
    return a;
  };
  a.MultiMaterial = function(a) {
    void 0 === a && (a = []);
    console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
    a.isMultiMaterial = !0;
    a.materials = a;
    a.clone = function() {
      return a.slice();
    };
    return a;
  };
  a.PointCloud = function(a, b) {
    console.warn("THREE.PointCloud has been renamed to THREE.Points.");
    return new nc(a, b);
  };
  a.Particle = function(a) {
    console.warn("THREE.Particle has been renamed to THREE.Sprite.");
    return new Yc(a);
  };
  a.ParticleSystem = function(a, b) {
    console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
    return new nc(a, b);
  };
  a.PointCloudMaterial = function(a) {
    console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
    return new Xa(a);
  };
  a.ParticleBasicMaterial = function(a) {
    console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
    return new Xa(a);
  };
  a.ParticleSystemMaterial = function(a) {
    console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
    return new Xa(a);
  };
  a.Vertex = function(a, b, d) {
    console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
    return new f(a, b, d);
  };
  a.DynamicBufferAttribute = function(a, b) {
    console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");
    return (new K(a, b)).setDynamic(!0);
  };
  a.Int8Attribute = function(a, b) {
    console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
    return new I(a, b);
  };
  a.Uint8Attribute = function(a, b) {
    console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
    return new L(a, b);
  };
  a.Uint8ClampedAttribute = function(a, b) {
    console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
    return new R(a, b);
  };
  a.Int16Attribute = function(a, b) {
    console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
    return new J(a, b);
  };
  a.Uint16Attribute = function(a, b) {
    console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
    return new Q(a, b);
  };
  a.Int32Attribute = function(a, b) {
    console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
    return new aa(a, b);
  };
  a.Uint32Attribute = function(a, b) {
    console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
    return new U(a, b);
  };
  a.Float32Attribute = function(a, b) {
    console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
    return new N(a, b);
  };
  a.Float64Attribute = function(a, b) {
    console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
    return new S(a, b);
  };
  a.ClosedSplineCurve3 = Tf;
  a.SplineCurve3 = Uf;
  a.Spline = Ye;
  a.AxisHelper = function(a) {
    console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
    return new Ld(a);
  };
  a.BoundingBoxHelper = function(a, b) {
    console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
    return new zb(a, b);
  };
  a.EdgesHelper = function(a, b) {
    console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
    return new pa(new zc(a.geometry), new ra({color:void 0 !== b ? b : 16777215}));
  };
  a.WireframeHelper = function(a, b) {
    console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
    return new pa(new pc(a.geometry), new ra({color:void 0 !== b ? b : 16777215}));
  };
  a.XHRLoader = function(a) {
    console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
    return new Za(a);
  };
  a.BinaryTextureLoader = function(a) {
    console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
    return new Be(a);
  };
  a.GeometryUtils = {merge:function(a, b, d) {
    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
    if (b.isMesh) {
      b.matrixAutoUpdate && b.updateMatrix();
      var c = b.matrix;
      b = b.geometry;
    }
    a.merge(b, c, d);
  }, center:function(a) {
    console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
    return a.center();
  }};
  a.Projector = function() {
    console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");
    this.projectVector = function(a, b) {
      console.warn("THREE.Projector: .projectVector() is now vector.project().");
      a.project(b);
    };
    this.unprojectVector = function(a, b) {
      console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
      a.unproject(b);
    };
    this.pickingRay = function() {
      console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
    };
  };
  a.CanvasRenderer = function() {
    console.error("THREE.CanvasRenderer has been removed");
  };
  a.JSONLoader = function() {
    console.error("THREE.JSONLoader has been removed.");
  };
  a.SceneUtils = {createMultiMaterialObject:function() {
    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
  }, detach:function() {
    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
  }, attach:function() {
    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
  }};
  a.LensFlare = function() {
    console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js");
  };
  Object.defineProperty(a, "__esModule", {value:!0});
});
(function() {
  function a() {
    this.tolerance = -1;
    this.faces = [];
    this.newFaces = [];
    this.assigned = new e;
    this.unassigned = new e;
    this.vertices = [];
  }
  function c() {
    this.normal = new THREE.Vector3;
    this.midpoint = new THREE.Vector3;
    this.constant = this.area = 0;
    this.outside = null;
    this.mark = 0;
    this.edge = null;
  }
  function g(a, b) {
    this.vertex = a;
    this.twin = this.next = this.prev = null;
    this.face = b;
  }
  function b(a) {
    this.point = a;
    this.face = this.next = this.prev = null;
  }
  function e() {
    this.tail = this.head = null;
  }
  Object.assign(a.prototype, {setFromPoints:function(a) {
    !0 !== Array.isArray(a) && console.error("THREE.QuickHull: Points parameter is not an array.");
    4 > a.length && console.error("THREE.QuickHull: The algorithm needs at least four points.");
    this.makeEmpty();
    for (var c = 0, f = a.length; c < f; c++) {
      this.vertices.push(new b(a[c]));
    }
    this.compute();
    return this;
  }, setFromObject:function(a) {
    var b = [];
    a.updateMatrixWorld(!0);
    a.traverse(function(a) {
      var c;
      var f = a.geometry;
      if (void 0 !== f) {
        if (f.isGeometry) {
          var e = f.vertices;
          f = 0;
          for (c = e.length; f < c; f++) {
            var d = e[f].clone();
            d.applyMatrix4(a.matrixWorld);
            b.push(d);
          }
        } else {
          if (f.isBufferGeometry && (e = f.attributes.position, void 0 !== e)) {
            for (f = 0, c = e.count; f < c; f++) {
              d = new THREE.Vector3, d.fromBufferAttribute(e, f).applyMatrix4(a.matrixWorld), b.push(d);
            }
          }
        }
      }
    });
    return this.setFromPoints(b);
  }, makeEmpty:function() {
    this.faces = [];
    this.vertices = [];
    return this;
  }, addVertexToFace:function(a, b) {
    a.face = b;
    null === b.outside ? this.assigned.append(a) : this.assigned.insertBefore(b.outside, a);
    b.outside = a;
    return this;
  }, removeVertexFromFace:function(a, b) {
    a === b.outside && (b.outside = null !== a.next && a.next.face === b ? a.next : null);
    this.assigned.remove(a);
    return this;
  }, removeAllVerticesFromFace:function(a) {
    if (null !== a.outside) {
      for (var b = a.outside, c = a.outside; null !== c.next && c.next.face === a;) {
        c = c.next;
      }
      this.assigned.removeSubList(b, c);
      b.prev = c.next = null;
      a.outside = null;
      return b;
    }
  }, deleteFaceVertices:function(a, b) {
    a = this.removeAllVerticesFromFace(a);
    if (void 0 !== a) {
      if (void 0 === b) {
        this.unassigned.appendChain(a);
      } else {
        do {
          var c = a.next;
          b.distanceToPoint(a.point) > this.tolerance ? this.addVertexToFace(a, b) : this.unassigned.append(a);
          a = c;
        } while (null !== a);
      }
    }
    return this;
  }, resolveUnassignedPoints:function(a) {
    if (!1 === this.unassigned.isEmpty()) {
      var b = this.unassigned.first();
      do {
        for (var c = b.next, f = this.tolerance, e = null, g = 0; g < a.length; g++) {
          var d = a[g];
          if (0 === d.mark) {
            var l = d.distanceToPoint(b.point);
            l > f && (f = l, e = d);
            if (f > 1E3 * this.tolerance) {
              break;
            }
          }
        }
        null !== e && this.addVertexToFace(b, e);
        b = c;
      } while (null !== b);
    }
    return this;
  }, computeExtremes:function() {
    var a = new THREE.Vector3, b = new THREE.Vector3, c = [], e = [], g, t, d;
    for (g = 0; 3 > g; g++) {
      c[g] = e[g] = this.vertices[0];
    }
    a.copy(this.vertices[0].point);
    b.copy(this.vertices[0].point);
    g = 0;
    for (t = this.vertices.length; g < t; g++) {
      var l = this.vertices[g], u = l.point;
      for (d = 0; 3 > d; d++) {
        u.getComponent(d) < a.getComponent(d) && (a.setComponent(d, u.getComponent(d)), c[d] = l);
      }
      for (d = 0; 3 > d; d++) {
        u.getComponent(d) > b.getComponent(d) && (b.setComponent(d, u.getComponent(d)), e[d] = l);
      }
    }
    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(a.x), Math.abs(b.x)) + Math.max(Math.abs(a.y), Math.abs(b.y)) + Math.max(Math.abs(a.z), Math.abs(b.z)));
    return {min:c, max:e};
  }, computeInitialHull:function() {
    var a, b, e;
    return function() {
      void 0 === a && (a = new THREE.Line3, b = new THREE.Plane, e = new THREE.Vector3);
      var f = this.vertices, k = this.computeExtremes(), g = k.min, d = k.max, l, n, w = 0;
      for (k = n = 0; 3 > k; k++) {
        var y = d[k].point.getComponent(k) - g[k].point.getComponent(k);
        y > w && (w = y, n = k);
      }
      g = g[n];
      d = d[n];
      w = 0;
      a.set(g.point, d.point);
      k = 0;
      for (l = this.vertices.length; k < l; k++) {
        var x = f[k];
        if (x !== g && x !== d && (a.closestPointToPoint(x.point, !0, e), y = e.distanceToSquared(x.point), y > w)) {
          w = y;
          var q = x;
        }
      }
      w = -1;
      b.setFromCoplanarPoints(g.point, d.point, q.point);
      k = 0;
      for (l = this.vertices.length; k < l; k++) {
        if (x = f[k], x !== g && x !== d && x !== q && (y = Math.abs(b.distanceToPoint(x.point)), y > w)) {
          w = y;
          var v = x;
        }
      }
      y = [];
      if (0 > b.distanceToPoint(v.point)) {
        for (y.push(c.create(g, d, q), c.create(v, d, g), c.create(v, q, d), c.create(v, g, q)), k = 0; 3 > k; k++) {
          n = (k + 1) % 3, y[k + 1].getEdge(2).setTwin(y[0].getEdge(n)), y[k + 1].getEdge(1).setTwin(y[n + 1].getEdge(0));
        }
      } else {
        for (y.push(c.create(g, q, d), c.create(v, g, d), c.create(v, d, q), c.create(v, q, g)), k = 0; 3 > k; k++) {
          n = (k + 1) % 3, y[k + 1].getEdge(2).setTwin(y[0].getEdge((3 - k) % 3)), y[k + 1].getEdge(0).setTwin(y[n + 1].getEdge(1));
        }
      }
      for (k = 0; 4 > k; k++) {
        this.faces.push(y[k]);
      }
      k = 0;
      for (l = f.length; k < l; k++) {
        if (x = f[k], x !== g && x !== d && x !== q && x !== v) {
          w = this.tolerance;
          var z = null;
          for (n = 0; 4 > n; n++) {
            y = this.faces[n].distanceToPoint(x.point), y > w && (w = y, z = this.faces[n]);
          }
          null !== z && this.addVertexToFace(x, z);
        }
      }
      return this;
    };
  }(), reindexFaces:function() {
    for (var a = [], b = 0; b < this.faces.length; b++) {
      var c = this.faces[b];
      0 === c.mark && a.push(c);
    }
    this.faces = a;
    return this;
  }, nextVertexToAdd:function() {
    if (!1 === this.assigned.isEmpty()) {
      var a = 0, b = this.assigned.first().face, c = b.outside;
      do {
        var e = b.distanceToPoint(c.point);
        if (e > a) {
          a = e;
          var g = c;
        }
        c = c.next;
      } while (null !== c && c.face === b);
      return g;
    }
  }, computeHorizon:function(a, b, c, e) {
    this.deleteFaceVertices(c);
    c.mark = 1;
    c = null === b ? b = c.getEdge(0) : b.next;
    do {
      var f = c.twin, k = f.face;
      0 === k.mark && (k.distanceToPoint(a) > this.tolerance ? this.computeHorizon(a, f, k, e) : e.push(c));
      c = c.next;
    } while (c !== b);
    return this;
  }, addAdjoiningFace:function(a, b) {
    a = c.create(a, b.tail(), b.head());
    this.faces.push(a);
    a.getEdge(-1).setTwin(b.twin);
    return a.getEdge(0);
  }, addNewFaces:function(a, b) {
    this.newFaces = [];
    for (var c = null, f = null, e = 0; e < b.length; e++) {
      var k = this.addAdjoiningFace(a, b[e]);
      null === c ? c = k : k.next.setTwin(f);
      this.newFaces.push(k.face);
      f = k;
    }
    c.next.setTwin(f);
    return this;
  }, addVertexToHull:function(a) {
    var b = [];
    this.unassigned.clear();
    this.removeVertexFromFace(a, a.face);
    this.computeHorizon(a.point, null, a.face, b);
    this.addNewFaces(a, b);
    this.resolveUnassignedPoints(this.newFaces);
    return this;
  }, cleanup:function() {
    this.assigned.clear();
    this.unassigned.clear();
    this.newFaces = [];
    return this;
  }, compute:function() {
    var a;
    for (this.computeInitialHull(); void 0 !== (a = this.nextVertexToAdd());) {
      this.addVertexToHull(a);
    }
    this.reindexFaces();
    this.cleanup();
    return this;
  }});
  Object.assign(c, {create:function(a, b, e) {
    var f = new c;
    a = new g(a, f);
    b = new g(b, f);
    e = new g(e, f);
    a.next = e.prev = b;
    b.next = a.prev = e;
    e.next = b.prev = a;
    f.edge = a;
    return f.compute();
  }});
  Object.assign(c.prototype, {getEdge:function(a) {
    for (var b = this.edge; 0 < a;) {
      b = b.next, a--;
    }
    for (; 0 > a;) {
      b = b.prev, a++;
    }
    return b;
  }, compute:function() {
    var a;
    return function() {
      void 0 === a && (a = new THREE.Triangle);
      var b = this.edge.tail(), c = this.edge.head(), f = this.edge.next.head();
      a.set(b.point, c.point, f.point);
      a.getNormal(this.normal);
      a.getMidpoint(this.midpoint);
      this.area = a.getArea();
      this.constant = this.normal.dot(this.midpoint);
      return this;
    };
  }(), distanceToPoint:function(a) {
    return this.normal.dot(a) - this.constant;
  }});
  Object.assign(g.prototype, {head:function() {
    return this.vertex;
  }, tail:function() {
    return this.prev ? this.prev.vertex : null;
  }, length:function() {
    var a = this.head(), b = this.tail();
    return null !== b ? b.point.distanceTo(a.point) : -1;
  }, lengthSquared:function() {
    var a = this.head(), b = this.tail();
    return null !== b ? b.point.distanceToSquared(a.point) : -1;
  }, setTwin:function(a) {
    this.twin = a;
    a.twin = this;
    return this;
  }});
  Object.assign(e.prototype, {first:function() {
    return this.head;
  }, last:function() {
    return this.tail;
  }, clear:function() {
    this.head = this.tail = null;
    return this;
  }, insertBefore:function(a, b) {
    b.prev = a.prev;
    b.next = a;
    null === b.prev ? this.head = b : b.prev.next = b;
    a.prev = b;
    return this;
  }, insertAfter:function(a, b) {
    b.prev = a;
    b.next = a.next;
    null === b.next ? this.tail = b : b.next.prev = b;
    a.next = b;
    return this;
  }, append:function(a) {
    null === this.head ? this.head = a : this.tail.next = a;
    a.prev = this.tail;
    a.next = null;
    this.tail = a;
    return this;
  }, appendChain:function(a) {
    null === this.head ? this.head = a : this.tail.next = a;
    for (a.prev = this.tail; null !== a.next;) {
      a = a.next;
    }
    this.tail = a;
    return this;
  }, remove:function(a) {
    null === a.prev ? this.head = a.next : a.prev.next = a.next;
    null === a.next ? this.tail = a.prev : a.next.prev = a.prev;
    return this;
  }, removeSubList:function(a, b) {
    null === a.prev ? this.head = b.next : a.prev.next = b.next;
    null === b.next ? this.tail = a.prev : b.next.prev = a.prev;
    return this;
  }, isEmpty:function() {
    return null === this.head;
  }});
  THREE.QuickHull = a;
})();
var SimplexNoise = function(a) {
  void 0 == a && (a = Math);
  this.grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]];
  this.grad4 = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, 
  -1, 0]];
  this.p = [];
  for (var c = 0; 256 > c; c++) {
    this.p[c] = Math.floor(256 * a.random());
  }
  this.perm = [];
  for (c = 0; 512 > c; c++) {
    this.perm[c] = this.p[c & 255];
  }
  this.simplex = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 
  0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]];
};
SimplexNoise.prototype.dot = function(a, c, g) {
  return a[0] * c + a[1] * g;
};
SimplexNoise.prototype.dot3 = function(a, c, g, b) {
  return a[0] * c + a[1] * g + a[2] * b;
};
SimplexNoise.prototype.dot4 = function(a, c, g, b, e) {
  return a[0] * c + a[1] * g + a[2] * b + a[3] * e;
};
SimplexNoise.prototype.noise = function(a, c) {
  var g = .5 * (a + c) * (Math.sqrt(3) - 1), b = Math.floor(a + g), e = Math.floor(c + g);
  g = (3 - Math.sqrt(3)) / 6;
  var f = (b + e) * g;
  a -= b - f;
  var k = c - (e - f);
  if (a > k) {
    var n = 1;
    var p = 0;
  } else {
    n = 0, p = 1;
  }
  f = a - n + g;
  var m = k - p + g;
  c = a - 1 + 2 * g;
  g = k - 1 + 2 * g;
  var t = b & 255, d = e & 255;
  b = this.perm[t + this.perm[d]] % 12;
  e = this.perm[t + n + this.perm[d + p]] % 12;
  n = this.perm[t + 1 + this.perm[d + 1]] % 12;
  p = .5 - a * a - k * k;
  0 > p ? a = 0 : (p *= p, a = p * p * this.dot(this.grad3[b], a, k));
  k = .5 - f * f - m * m;
  0 > k ? f = 0 : (k *= k, f = k * k * this.dot(this.grad3[e], f, m));
  m = .5 - c * c - g * g;
  0 > m ? c = 0 : (m *= m, c = m * m * this.dot(this.grad3[n], c, g));
  return 70 * (a + f + c);
};
SimplexNoise.prototype.noise3d = function(a, c, g) {
  var b = 1 / 3 * (a + c + g), e = Math.floor(a + b), f = Math.floor(c + b), k = Math.floor(g + b);
  b = 1 / 6;
  var n = (e + f + k) * b;
  var p = a - (e - n);
  var m = c - (f - n);
  var t = g - (k - n), d, l;
  if (p >= m) {
    if (m >= t) {
      var u = 1;
      var w = d = 0;
      var y = l = 1;
      var x = 0;
    } else {
      p >= t ? (u = 1, w = d = 0) : (d = u = 0, w = 1), l = 1, y = 0, x = 1;
    }
  } else {
    m < t ? (d = u = 0, w = 1, l = 0, x = y = 1) : p < t ? (u = 0, d = 1, l = w = 0, x = y = 1) : (u = 0, d = 1, w = 0, y = l = 1, x = 0);
  }
  var q = p - u + b, v = m - d + b, z = t - w + b;
  n = p - l + 2 * b;
  a = m - y + 2 * b;
  var C = t - x + 2 * b;
  g = p - 1 + 3 * b;
  c = m - 1 + 3 * b;
  b = t - 1 + 3 * b;
  e &= 255;
  var A = f & 255, D = k & 255;
  f = this.perm[e + this.perm[A + this.perm[D]]] % 12;
  k = this.perm[e + u + this.perm[A + d + this.perm[D + w]]] % 12;
  l = this.perm[e + l + this.perm[A + y + this.perm[D + x]]] % 12;
  e = this.perm[e + 1 + this.perm[A + 1 + this.perm[D + 1]]] % 12;
  y = .6 - p * p - m * m - t * t;
  0 > y ? p = 0 : (y *= y, p = y * y * this.dot3(this.grad3[f], p, m, t));
  m = .6 - q * q - v * v - z * z;
  0 > m ? m = 0 : (m *= m, m = m * m * this.dot3(this.grad3[k], q, v, z));
  q = .6 - n * n - a * a - C * C;
  0 > q ? n = 0 : (q *= q, n = q * q * this.dot3(this.grad3[l], n, a, C));
  a = .6 - g * g - c * c - b * b;
  0 > a ? g = 0 : (a *= a, g = a * a * this.dot3(this.grad3[e], g, c, b));
  return 32 * (p + m + n + g);
};
SimplexNoise.prototype.noise4d = function(a, c, g, b) {
  var e = this.grad4, f = this.simplex, k = this.perm, n = (5 - Math.sqrt(5)) / 20;
  var p = (Math.sqrt(5) - 1) / 4 * (a + c + g + b);
  var m = Math.floor(a + p), t = Math.floor(c + p), d = Math.floor(g + p), l = Math.floor(b + p);
  p = (m + t + d + l) * n;
  a -= m - p;
  var u = c - (t - p);
  var w = g - (d - p);
  var y = b - (l - p);
  b = (a > u ? 32 : 0) + (a > w ? 16 : 0) + (u > w ? 8 : 0) + (a > y ? 4 : 0) + (u > y ? 2 : 0) + (w > y ? 1 : 0);
  var x = 3 <= f[b][0] ? 1 : 0;
  var q = 3 <= f[b][1] ? 1 : 0;
  var v = 3 <= f[b][2] ? 1 : 0;
  var z = 3 <= f[b][3] ? 1 : 0;
  var C = 2 <= f[b][0] ? 1 : 0;
  var A = 2 <= f[b][1] ? 1 : 0;
  var D = 2 <= f[b][2] ? 1 : 0;
  var E = 2 <= f[b][3] ? 1 : 0;
  var B = 1 <= f[b][0] ? 1 : 0;
  var G = 1 <= f[b][1] ? 1 : 0;
  var H = 1 <= f[b][2] ? 1 : 0;
  var K = 1 <= f[b][3] ? 1 : 0;
  var I = a - x + n, L = u - q + n, R = w - v + n, J = y - z + n, Q = a - C + 2 * n, aa = u - A + 2 * n, U = w - D + 2 * n, N = y - E + 2 * n;
  p = a - B + 3 * n;
  c = u - G + 3 * n;
  var S = w - H + 3 * n, V = y - K + 3 * n;
  f = a - 1 + 4 * n;
  b = u - 1 + 4 * n;
  g = w - 1 + 4 * n;
  n = y - 1 + 4 * n;
  m &= 255;
  t &= 255;
  var M = d & 255;
  l &= 255;
  d = k[m + k[t + k[M + k[l]]]] % 32;
  x = k[m + x + k[t + q + k[M + v + k[l + z]]]] % 32;
  C = k[m + C + k[t + A + k[M + D + k[l + E]]]] % 32;
  B = k[m + B + k[t + G + k[M + H + k[l + K]]]] % 32;
  k = k[m + 1 + k[t + 1 + k[M + 1 + k[l + 1]]]] % 32;
  l = .6 - a * a - u * u - w * w - y * y;
  0 > l ? a = 0 : (l *= l, a = l * l * this.dot4(e[d], a, u, w, y));
  u = .6 - I * I - L * L - R * R - J * J;
  0 > u ? u = 0 : (u *= u, u = u * u * this.dot4(e[x], I, L, R, J));
  w = .6 - Q * Q - aa * aa - U * U - N * N;
  0 > w ? w = 0 : (w *= w, w = w * w * this.dot4(e[C], Q, aa, U, N));
  Q = .6 - p * p - c * c - S * S - V * V;
  0 > Q ? p = 0 : (Q *= Q, p = Q * Q * this.dot4(e[B], p, c, S, V));
  c = .6 - f * f - b * b - g * g - n * n;
  0 > c ? e = 0 : (c *= c, e = c * c * this.dot4(e[k], f, b, g, n));
  return 27 * (a + u + w + p + e);
};
THREE.CopyShader = {uniforms:{tDiffuse:{value:null}, opacity:{value:1}}, vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform float opacity;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\ngl_FragColor = opacity * texel;\n}"};
THREE.BokehShader = {defines:{DEPTH_PACKING:1, PERSPECTIVE_CAMERA:1}, uniforms:{tColor:{value:null}, tDepth:{value:null}, focus:{value:1}, aspect:{value:1.0}, aperture:{value:.025}, maxblur:{value:1}, nearClip:{value:1}, farClip:{value:1E3}}, vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"#include <common>\nvarying vec2 vUv;\nuniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float maxblur;\nuniform float aperture;\nuniform float nearClip;\nuniform float farClip;\nuniform float focus;\nuniform float aspect;\n#include <packing>\nfloat getDepth( const in vec2 screenPosition ) {\n\t#if DEPTH_PACKING == 1\n\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t#else\n\treturn texture2D( tDepth, screenPosition ).x;\n\t#endif\n}\nfloat getViewZ( const in float depth ) {\n\t#if PERSPECTIVE_CAMERA == 1\n\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );\n\t#else\n\treturn orthographicDepthToViewZ( depth, nearClip, farClip );\n\t#endif\n}\nvoid main() {\nvec2 aspectcorrect = vec2( 1.0, aspect );\nfloat viewZ = getViewZ( getDepth( vUv ) );\nfloat factor = ( focus + viewZ );\nvec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\nvec2 dofblur9 = dofblur * 0.9;\nvec2 dofblur7 = dofblur * 0.7;\nvec2 dofblur4 = dofblur * 0.4;\nvec4 col = vec4( 0.0 );\ncol += texture2D( tColor, vUv.xy );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\ngl_FragColor = col / 41.0;\ngl_FragColor.a = 1.0;\n}"};
THREE.SAOShader = {defines:{NUM_SAMPLES:7, NUM_RINGS:4, NORMAL_TEXTURE:0, DIFFUSE_TEXTURE:0, DEPTH_PACKING:1, PERSPECTIVE_CAMERA:1}, uniforms:{tDepth:{type:"t", value:null}, tDiffuse:{type:"t", value:null}, tNormal:{type:"t", value:null}, size:{type:"v2", value:new THREE.Vector2(512, 512)}, cameraNear:{type:"f", value:1}, cameraFar:{type:"f", value:100}, cameraProjectionMatrix:{type:"m4", value:new THREE.Matrix4}, cameraInverseProjectionMatrix:{type:"m4", value:new THREE.Matrix4}, scale:{type:"f", 
value:1}, intensity:{type:"f", value:.1}, bias:{type:"f", value:.5}, minResolution:{type:"f", value:0}, kernelRadius:{type:"f", value:100}, randomSeed:{type:"f", value:0}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"#include <common>\nvarying vec2 vUv;\n#if DIFFUSE_TEXTURE == 1\nuniform sampler2D tDiffuse;\n#endif\nuniform sampler2D tDepth;\n#if NORMAL_TEXTURE == 1\nuniform sampler2D tNormal;\n#endif\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 cameraProjectionMatrix;\nuniform mat4 cameraInverseProjectionMatrix;\nuniform float scale;\nuniform float intensity;\nuniform float bias;\nuniform float kernelRadius;\nuniform float minResolution;\nuniform vec2 size;\nuniform float randomSeed;\n// RGBA depth\n#include <packing>\nvec4 getDefaultColor( const in vec2 screenPosition ) {\n\t#if DIFFUSE_TEXTURE == 1\n\treturn texture2D( tDiffuse, vUv );\n\t#else\n\treturn vec4( 1.0 );\n\t#endif\n}\nfloat getDepth( const in vec2 screenPosition ) {\n\t#if DEPTH_PACKING == 1\n\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t#else\n\treturn texture2D( tDepth, screenPosition ).x;\n\t#endif\n}\nfloat getViewZ( const in float depth ) {\n\t#if PERSPECTIVE_CAMERA == 1\n\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t#else\n\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t#endif\n}\nvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\tclipPosition *= clipW; // unprojection.\n\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n}\nvec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\n\t#if NORMAL_TEXTURE == 1\n\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\t#else\n\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\n\t#endif\n}\nfloat scaleDividedByCameraFar;\nfloat minResolutionMultipliedByCameraFar;\nfloat getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\n\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\n\tfloat viewDistance = length( viewDelta );\n\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\n\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\n}\n// moving costly divides into consts\nconst float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\nconst float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\nfloat getAmbientOcclusion( const in vec3 centerViewPosition ) {\n\t// precompute some variables require in getOcclusion.\n\tscaleDividedByCameraFar = scale / cameraFar;\n\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;\n\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );\n\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n\tfloat angle = rand( vUv + randomSeed ) * PI2;\n\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\n\tvec2 radiusStep = radius;\n\tfloat occlusionSum = 0.0;\n\tfloat weightSum = 0.0;\n\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;\n\t\tradius += radiusStep;\n\t\tangle += ANGLE_STEP;\n\t\tfloat sampleDepth = getDepth( sampleUv );\n\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfloat sampleViewZ = getViewZ( sampleDepth );\n\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );\n\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\n\t\tweightSum += 1.0;\n\t}\n\tif( weightSum == 0.0 ) discard;\n\treturn occlusionSum * ( intensity / weightSum );\n}\nvoid main() {\n\tfloat centerDepth = getDepth( vUv );\n\tif( centerDepth >= ( 1.0 - EPSILON ) ) {\n\t\tdiscard;\n\t}\n\tfloat centerViewZ = getViewZ( centerDepth );\n\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\n\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\n\tgl_FragColor = getDefaultColor( vUv );\n\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\n}"};
THREE.DepthLimitedBlurShader = {defines:{KERNEL_RADIUS:4, DEPTH_PACKING:1, PERSPECTIVE_CAMERA:1}, uniforms:{tDiffuse:{type:"t", value:null}, size:{type:"v2", value:new THREE.Vector2(512, 512)}, sampleUvOffsets:{type:"v2v", value:[new THREE.Vector2(0, 0)]}, sampleWeights:{type:"1fv", value:[1]}, tDepth:{type:"t", value:null}, cameraNear:{type:"f", value:10}, cameraFar:{type:"f", value:1E3}, depthCutoff:{type:"f", value:10}}, vertexShader:"#include <common>\nuniform vec2 size;\nvarying vec2 vUv;\nvarying vec2 vInvSize;\nvoid main() {\n\tvUv = uv;\n\tvInvSize = 1.0 / size;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", 
fragmentShader:"#include <common>\n#include <packing>\nuniform sampler2D tDiffuse;\nuniform sampler2D tDepth;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform float depthCutoff;\nuniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\nuniform float sampleWeights[ KERNEL_RADIUS + 1 ];\nvarying vec2 vUv;\nvarying vec2 vInvSize;\nfloat getDepth( const in vec2 screenPosition ) {\n\t#if DEPTH_PACKING == 1\n\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t#else\n\treturn texture2D( tDepth, screenPosition ).x;\n\t#endif\n}\nfloat getViewZ( const in float depth ) {\n\t#if PERSPECTIVE_CAMERA == 1\n\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t#else\n\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t#endif\n}\nvoid main() {\n\tfloat depth = getDepth( vUv );\n\tif( depth >= ( 1.0 - EPSILON ) ) {\n\t\tdiscard;\n\t}\n\tfloat centerViewZ = -getViewZ( depth );\n\tbool rBreak = false, lBreak = false;\n\tfloat weightSum = sampleWeights[0];\n\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\n\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\n\t\tfloat sampleWeight = sampleWeights[i];\n\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\n\t\tvec2 sampleUv = vUv + sampleUvOffset;\n\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\n\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\n\t\tif( ! rBreak ) {\n\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n\t\t\tweightSum += sampleWeight;\n\t\t}\n\t\tsampleUv = vUv - sampleUvOffset;\n\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\n\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\n\t\tif( ! lBreak ) {\n\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n\t\t\tweightSum += sampleWeight;\n\t\t}\n\t}\n\tgl_FragColor = diffuseSum / weightSum;\n}"};
THREE.BlurShaderUtils = {createSampleWeights:function(a, c) {
  for (var g = [], b = 0; b <= a; b++) {
    g.push(Math.exp(-(b * b) / (2 * c * c)) / (Math.sqrt(2 * Math.PI) * c));
  }
  return g;
}, createSampleOffsets:function(a, c) {
  for (var g = [], b = 0; b <= a; b++) {
    g.push(c.clone().multiplyScalar(b));
  }
  return g;
}, configure:function(a, c, g, b) {
  a.defines.KERNEL_RADIUS = c;
  a.uniforms.sampleUvOffsets.value = THREE.BlurShaderUtils.createSampleOffsets(c, b);
  a.uniforms.sampleWeights.value = THREE.BlurShaderUtils.createSampleWeights(c, g);
  a.needsUpdate = !0;
}};
THREE.UnpackDepthRGBAShader = {uniforms:{tDiffuse:{value:null}, opacity:{value:1}}, vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform float opacity;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\n#include <packing>\nvoid main() {\nfloat depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );\ngl_FragColor = vec4( vec3( depth ), opacity );\n}"};
THREE.ConvolutionShader = {defines:{KERNEL_SIZE_FLOAT:"25.0", KERNEL_SIZE_INT:"25"}, uniforms:{tDiffuse:{value:null}, uImageIncrement:{value:new THREE.Vector2(.001953125, 0)}, cKernel:{value:[]}}, vertexShader:"uniform vec2 uImageIncrement;\nvarying vec2 vUv;\nvoid main() {\nvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform float cKernel[ KERNEL_SIZE_INT ];\nuniform sampler2D tDiffuse;\nuniform vec2 uImageIncrement;\nvarying vec2 vUv;\nvoid main() {\nvec2 imageCoord = vUv;\nvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\nfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\nsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\nimageCoord += uImageIncrement;\n}\ngl_FragColor = sum;\n}", 
buildKernel:function(a) {
  var c, g, b = 2 * Math.ceil(3 * a) + 1;
  25 < b && (b = 25);
  var e = .5 * (b - 1);
  var f = Array(b);
  for (c = g = 0; c < b; ++c) {
    var k = c - e;
    f[c] = Math.exp(-(k * k) / ( 2. * a * a));
    g += f[c];
  }
  for (c = 0; c < b; ++c) {
    f[c] /= g;
  }
  return f;
}};
THREE.LuminosityHighPassShader = {shaderID:"luminosityHighPass", uniforms:{tDiffuse:{type:"t", value:null}, luminosityThreshold:{type:"f", value:1}, smoothWidth:{type:"f", value:1.0}, defaultColor:{type:"c", value:new THREE.Color(0)}, defaultOpacity:{type:"f", value:0}}, vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform sampler2D tDiffuse;\nuniform vec3 defaultColor;\nuniform float defaultOpacity;\nuniform float luminosityThreshold;\nuniform float smoothWidth;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\nvec3 luma = vec3( 0.299, 0.587, 0.114 );\nfloat v = dot( texel.xyz, luma );\nvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\nfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\ngl_FragColor = mix( outputColor, texel, alpha );\n}"};
THREE.FXAAShader = {uniforms:{tDiffuse:{value:null}, resolution:{value:new THREE.Vector2(1 / 1024, 1 / 512)}}, vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:'precision highp float;\n\nuniform sampler2D tDiffuse;\n\nuniform vec2 resolution;\n\nvarying vec2 vUv;\n\n// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n//----------------------------------------------------------------------------------\n// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n// SDK Version: v3.00\n// Email:       gameworks@nvidia.com\n// Site:        http://developer.nvidia.com/\n//\n// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//  * Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//  * Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//  * Neither the name of NVIDIA CORPORATION nor the names of its\n//    contributors may be used to endorse or promote products derived\n//    from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS\'\' AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//----------------------------------------------------------------------------------\n\n#define FXAA_PC 1\n#define FXAA_GLSL_100 1\n#define FXAA_QUALITY_PRESET 12\n\n#define FXAA_GREEN_AS_LUMA 1\n\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_PC_CONSOLE\n    //\n    // The console algorithm for PC is included\n    // for developers targeting really low spec machines.\n    // Likely better to just run FXAA_PC, and use a really low preset.\n    //\n    #define FXAA_PC_CONSOLE 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_120\n    #define FXAA_GLSL_120 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_130\n    #define FXAA_GLSL_130 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_3\n    #define FXAA_HLSL_3 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_4\n    #define FXAA_HLSL_4 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_5\n    #define FXAA_HLSL_5 0\n#endif\n/*==========================================================================*/\n#ifndef FXAA_GREEN_AS_LUMA\n    //\n    // For those using non-linear color,\n    // and either not able to get luma in alpha, or not wanting to,\n    // this enables FXAA to run using green as a proxy for luma.\n    // So with this enabled, no need to pack luma in alpha.\n    //\n    // This will turn off AA on anything which lacks some amount of green.\n    // Pure red and blue or combination of only R and B, will get no AA.\n    //\n    // Might want to lower the settings for both,\n    //    fxaaConsoleEdgeThresholdMin\n    //    fxaaQualityEdgeThresholdMin\n    // In order to insure AA does not get turned off on colors\n    // which contain a minor amount of green.\n    //\n    // 1 = On.\n    // 0 = Off.\n    //\n    #define FXAA_GREEN_AS_LUMA 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_EARLY_EXIT\n    //\n    // Controls algorithm\'s early exit path.\n    // On PS3 turning this ON adds 2 cycles to the shader.\n    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n    // Turning this off on console will result in a more blurry image.\n    // So this defaults to on.\n    //\n    // 1 = On.\n    // 0 = Off.\n    //\n    #define FXAA_EARLY_EXIT 1\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_DISCARD\n    //\n    // Only valid for PC OpenGL currently.\n    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n    //\n    // 1 = Use discard on pixels which don\'t need AA.\n    //     For APIs which enable concurrent TEX+ROP from same surface.\n    // 0 = Return unchanged color on pixels which don\'t need AA.\n    //\n    #define FXAA_DISCARD 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_FAST_PIXEL_OFFSET\n    //\n    // Used for GLSL 120 only.\n    //\n    // 1 = GL API supports fast pixel offsets\n    // 0 = do not use fast pixel offsets\n    //\n    #ifdef GL_EXT_gpu_shader4\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifndef FXAA_FAST_PIXEL_OFFSET\n        #define FXAA_FAST_PIXEL_OFFSET 0\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GATHER4_ALPHA\n    //\n    // 1 = API supports gather4 on alpha channel.\n    // 0 = API does not support gather4 on alpha channel.\n    //\n    #if (FXAA_HLSL_5 == 1)\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifndef FXAA_GATHER4_ALPHA\n        #define FXAA_GATHER4_ALPHA 0\n    #endif\n#endif\n\n\n/*============================================================================\n                        FXAA QUALITY - TUNING KNOBS\n------------------------------------------------------------------------------\nNOTE the other tuning knobs are now in the shader function inputs!\n============================================================================*/\n#ifndef FXAA_QUALITY_PRESET\n    //\n    // Choose the quality preset.\n    // This needs to be compiled into the shader as it effects code.\n    // Best option to include multiple presets is to\n    // in each shader define the preset, then include this file.\n    //\n    // OPTIONS\n    // -----------------------------------------------------------------------\n    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n    // 39       - no dither, very expensive\n    //\n    // NOTES\n    // -----------------------------------------------------------------------\n    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n    // 13 = about same speed as FXAA 3.9 and better than 12\n    // 23 = closest to FXAA 3.9 visually and performance wise\n    //  _ = the lowest digit is directly related to performance\n    // _  = the highest digit is directly related to style\n    //\n    #define FXAA_QUALITY_PRESET 12\n#endif\n\n\n/*============================================================================\n\n                           FXAA QUALITY - PRESETS\n\n============================================================================*/\n\n/*============================================================================\n                     FXAA QUALITY - MEDIUM DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n\n/*============================================================================\n                     FXAA QUALITY - LOW DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n/*============================================================================\n                     FXAA QUALITY - EXTREME QUALITY\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n\n\n/*============================================================================\n\n                                API PORTING\n\n============================================================================*/\n#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n    #define FxaaBool bool\n    #define FxaaDiscard discard\n    #define FxaaFloat float\n    #define FxaaFloat2 vec2\n    #define FxaaFloat3 vec3\n    #define FxaaFloat4 vec4\n    #define FxaaHalf float\n    #define FxaaHalf2 vec2\n    #define FxaaHalf3 vec3\n    #define FxaaHalf4 vec4\n    #define FxaaInt2 ivec2\n    #define FxaaSat(x) clamp(x, 0.0, 1.0)\n    #define FxaaTex sampler2D\n#else\n    #define FxaaBool bool\n    #define FxaaDiscard clip(-1)\n    #define FxaaFloat float\n    #define FxaaFloat2 float2\n    #define FxaaFloat3 float3\n    #define FxaaFloat4 float4\n    #define FxaaHalf half\n    #define FxaaHalf2 half2\n    #define FxaaHalf3 half3\n    #define FxaaHalf4 half4\n    #define FxaaSat(x) saturate(x)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_100 == 1)\n  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_120 == 1)\n    // Requires,\n    //  #version 120\n    // And at least,\n    //  #extension GL_EXT_gpu_shader4 : enable\n    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n    #if (FXAA_FAST_PIXEL_OFFSET == 1)\n        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n    #else\n        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n    #endif\n    #if (FXAA_GATHER4_ALPHA == 1)\n        // use #extension GL_ARB_gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_130 == 1)\n    // Requires "#version 130" or better\n    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n    #if (FXAA_GATHER4_ALPHA == 1)\n        // use #extension GL_ARB_gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_3 == 1)\n    #define FxaaInt2 float2\n    #define FxaaTex sampler2D\n    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_4 == 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_5 == 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n#endif\n\n\n/*============================================================================\n                   GREEN AS LUMA OPTION SUPPORT FUNCTION\n============================================================================*/\n#if (FXAA_GREEN_AS_LUMA == 0)\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n#else\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif\n\n\n\n\n/*============================================================================\n\n                             FXAA3 QUALITY - PC\n\n============================================================================*/\n#if (FXAA_PC == 1)\n/*--------------------------------------------------------------------------*/\nFxaaFloat4 FxaaPixelShader(\n    //\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = center of pixel\n    FxaaFloat2 pos,\n    //\n    // Used only for FXAA Console, and not used on the 360 version.\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy_} = upper left of pixel\n    // {_zw} = lower right of pixel\n    FxaaFloat4 fxaaConsolePosPos,\n    //\n    // Input color texture.\n    // {rgb_} = color in linear or perceptual color space\n    // if (FXAA_GREEN_AS_LUMA == 0)\n    //     {__a} = luma in perceptual color space (not linear)\n    FxaaTex tex,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for "tex".\n    // For 360, same texture, just alias with a 2nd sampler.\n    // This sampler needs to have an exponent bias of -1.\n    FxaaTex fxaaConsole360TexExpBiasNegOne,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for "tex".\n    // For 360, same texture, just alias with a 3nd sampler.\n    // This sampler needs to have an exponent bias of -2.\n    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n    //\n    // Only used on FXAA Quality.\n    // This must be from a constant/uniform.\n    // {x_} = 1.0/screenWidthInPixels\n    // {_y} = 1.0/screenHeightInPixels\n    FxaaFloat2 fxaaQualityRcpFrame,\n    //\n    // Only used on FXAA Console.\n    // This must be from a constant/uniform.\n    // This effects sub-pixel AA quality and inversely sharpness.\n    //   Where N ranges between,\n    //     N = 0.50 (default)\n    //     N = 0.33 (sharper)\n    // {x__} = -N/screenWidthInPixels\n    // {_y_} = -N/screenHeightInPixels\n    // {_z_} =  N/screenWidthInPixels\n    // {__w} =  N/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n    //\n    // Only used on FXAA Console.\n    // Not used on 360, but used on PS3 and PC.\n    // This must be from a constant/uniform.\n    // {x__} = -2.0/screenWidthInPixels\n    // {_y_} = -2.0/screenHeightInPixels\n    // {_z_} =  2.0/screenWidthInPixels\n    // {__w} =  2.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n    //\n    // Only used on FXAA Console.\n    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n    // This must be from a constant/uniform.\n    // {x__} =  8.0/screenWidthInPixels\n    // {_y_} =  8.0/screenHeightInPixels\n    // {_z_} = -4.0/screenWidthInPixels\n    // {__w} = -4.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // It is here now to allow easier tuning.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    FxaaFloat fxaaQualitySubpix,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    FxaaFloat fxaaQualityEdgeThreshold,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaQualityEdgeThresholdMin,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only three safe values here: 2 and 4 and 8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // For all other platforms can be a non-power of two.\n    //   8.0 is sharper (default!!!)\n    //   4.0 is softer\n    //   2.0 is really soft (good only for vector graphics inputs)\n    FxaaFloat fxaaConsoleEdgeSharpness,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only two safe values here: 1/4 and 1/8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // The console setting has a different mapping than the quality setting.\n    // Other platforms can use other values.\n    //   0.125 leaves less aliasing, but is softer (default!!!)\n    //   0.25 leaves more aliasing, and is sharper\n    FxaaFloat fxaaConsoleEdgeThreshold,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    // The console setting has a different mapping than the quality setting.\n    // This only applies when FXAA_EARLY_EXIT is 1.\n    // This does not apply to PS3,\n    // PS3 was simplified to avoid more shader instructions.\n    //   0.06 - faster but more aliasing in darks\n    //   0.05 - default\n    //   0.04 - slower and less aliasing in darks\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaConsoleEdgeThresholdMin,\n    //\n    // Extra constants for 360 FXAA Console only.\n    // Use zeros or anything else for other platforms.\n    // These must be in physical constant registers and NOT immediates.\n    // Immediates will result in compiler un-optimizing.\n    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n    FxaaFloat4 fxaaConsole360ConstDir\n) {\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    #if (FXAA_GATHER4_ALPHA == 1)\n        #if (FXAA_DISCARD == 0)\n            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n            #if (FXAA_GREEN_AS_LUMA == 0)\n                #define lumaM rgbyM.w\n            #else\n                #define lumaM rgbyM.y\n            #endif\n        #endif\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n        #else\n            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n        #endif\n        #if (FXAA_DISCARD == 1)\n            #define lumaM luma4A.w\n        #endif\n        #define lumaE luma4A.z\n        #define lumaS luma4A.x\n        #define lumaSE luma4A.y\n        #define lumaNW luma4B.w\n        #define lumaN luma4B.z\n        #define lumaW luma4B.x\n    #else\n        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            #define lumaM rgbyM.w\n        #else\n            #define lumaM rgbyM.y\n        #endif\n        #if (FXAA_GLSL_100 == 1)\n          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n        #else\n          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n        #endif\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n/*--------------------------------------------------------------------------*/\n    if(earlyExit)\n        #if (FXAA_DISCARD == 1)\n            FxaaDiscard;\n        #else\n            return rgbyM;\n        #endif\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_GATHER4_ALPHA == 0)\n        #if (FXAA_GLSL_100 == 1)\n          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n        #else\n          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n        #endif\n    #else\n        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n/*--------------------------------------------------------------------------*/\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n/*--------------------------------------------------------------------------*/\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n/*--------------------------------------------------------------------------*/\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n/*--------------------------------------------------------------------------*/\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n/*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n    #endif\n/*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n/*--------------------------------------------------------------------------*/\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n/*--------------------------------------------------------------------------*/\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n/*--------------------------------------------------------------------------*/\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n    #if (FXAA_DISCARD == 1)\n        return FxaaTexTop(tex, posM);\n    #else\n        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n    #endif\n}\n/*==========================================================================*/\n#endif\n\nvoid main() {\n  gl_FragColor = FxaaPixelShader(\n    vUv,\n    vec4(0.0),\n    tDiffuse,\n    tDiffuse,\n    tDiffuse,\n    resolution,\n    vec4(0.0),\n    vec4(0.0),\n    vec4(0.0),\n    0.75,\n    0.166,\n    0.0833,\n    0.0,\n    0.0,\n    0.0,\n    vec4(0.0)\n  );\n\n  // TODO avoid querying texture twice for same texel\n  gl_FragColor.a = texture2D(tDiffuse, vUv).a;\n}'};
THREE.SSAOShader = {defines:{PERSPECTIVE_CAMERA:1, KERNEL_SIZE:32}, uniforms:{tDiffuse:{value:null}, tNormal:{value:null}, tDepth:{value:null}, tNoise:{value:null}, kernel:{value:null}, cameraNear:{value:null}, cameraFar:{value:null}, resolution:{value:new THREE.Vector2}, cameraProjectionMatrix:{value:new THREE.Matrix4}, cameraInverseProjectionMatrix:{value:new THREE.Matrix4}, kernelRadius:{value:8}, minDistance:{value:.005}, maxDistance:{value:.05}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", 
fragmentShader:"uniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tDepth;\nuniform sampler2D tNoise;\nuniform vec3 kernel[ KERNEL_SIZE ];\nuniform vec2 resolution;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 cameraProjectionMatrix;\nuniform mat4 cameraInverseProjectionMatrix;\nuniform float kernelRadius;\nuniform float minDistance;\nuniform float maxDistance;\nvarying vec2 vUv;\n#include <packing>\nfloat getDepth( const in vec2 screenPosition ) {\n\treturn texture2D( tDepth, screenPosition ).x;\n}\nfloat getLinearDepth( const in vec2 screenPosition ) {\n\t#if PERSPECTIVE_CAMERA == 1\n\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\t#else\n\t\treturn texture2D( depthSampler, coord ).x;\n\t#endif\n}\nfloat getViewZ( const in float depth ) {\n\t#if PERSPECTIVE_CAMERA == 1\n\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t#else\n\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t#endif\n}\nvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\tclipPosition *= clipW; // unprojection.\n\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n}\nvec3 getViewNormal( const in vec2 screenPosition ) {\n\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n}\nvoid main() {\n\tfloat depth = getDepth( vUv );\n\tfloat viewZ = getViewZ( depth );\n\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\n\tvec3 viewNormal = getViewNormal( vUv );\n vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\n\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\n\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\n\tvec3 bitangent = cross( viewNormal, tangent );\n\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\n float occlusion = 0.0;\n for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\n\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];\n\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );\n\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\n\t\tsamplePointNDC /= samplePointNDC.w;\n\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\n\t\tfloat realDepth = getLinearDepth( samplePointUv );\n\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\n\t\tfloat delta = sampleDepth - realDepth;\n\t\tif ( delta > minDistance && delta < maxDistance ) {\n\t\t\tocclusion += 1.0;\n\t\t}\n\t}\n\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\n\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\n}"};
THREE.SSAODepthShader = {defines:{PERSPECTIVE_CAMERA:1}, uniforms:{tDepth:{value:null}, cameraNear:{value:null}, cameraFar:{value:null}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform sampler2D tDepth;\nuniform float cameraNear;\nuniform float cameraFar;\nvarying vec2 vUv;\n#include <packing>\nfloat getLinearDepth( const in vec2 screenPosition ) {\n\t#if PERSPECTIVE_CAMERA == 1\n\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\t#else\n\t\treturn texture2D( depthSampler, coord ).x;\n\t#endif\n}\nvoid main() {\n\tfloat depth = getLinearDepth( vUv );\n\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\n}"};
THREE.SSAOBlurShader = {uniforms:{tDiffuse:{value:null}, resolution:{value:new THREE.Vector2}}, vertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvoid main() {\n\tvec2 texelSize = ( 1.0 / resolution );\n\tfloat result = 0.0;\n\tfor ( int i = - 2; i <= 2; i ++ ) {\n\t\tfor ( int j = - 2; j <= 2; j ++ ) {\n\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\n\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\n\t\t}\n\t}\n\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\n}"};
THREE.FilmShader = {uniforms:{tDiffuse:{value:null}, time:{value:0}, nIntensity:{value:.5}, sIntensity:{value:.05}, sCount:{value:4096}, grayscale:{value:1}}, vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"#include <common>\nuniform float time;\nuniform bool grayscale;\nuniform float nIntensity;\nuniform float sIntensity;\nuniform float sCount;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 cTextureScreen = texture2D( tDiffuse, vUv );\nfloat dx = rand( vUv + time );\nvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\nvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\ncResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\ncResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\nif( grayscale ) {\ncResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\n}\ngl_FragColor =  vec4( cResult, cTextureScreen.a );\n}"};
THREE.DotScreenShader = {uniforms:{tDiffuse:{value:null}, tSize:{value:new THREE.Vector2(256, 256)}, center:{value:new THREE.Vector2(.5, .5)}, angle:{value:1.57}, scale:{value:1}}, vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform vec2 center;\nuniform float angle;\nuniform float scale;\nuniform vec2 tSize;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nfloat pattern() {\nfloat s = sin( angle ), c = cos( angle );\nvec2 tex = vUv * tSize - center;\nvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\nreturn ( sin( point.x ) * sin( point.y ) ) * 4.0;\n}\nvoid main() {\nvec4 color = texture2D( tDiffuse, vUv );\nfloat average = ( color.r + color.g + color.b ) / 3.0;\ngl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\n}"};
THREE.LuminosityShader = {uniforms:{tDiffuse:{value:null}}, vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"#include <common>\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\nfloat l = linearToRelativeLuminance( texel.rgb );\ngl_FragColor = vec4( l, l, l, texel.w );\n}"};
THREE.SobelOperatorShader = {uniforms:{tDiffuse:{value:null}, resolution:{value:new THREE.Vector2}}, vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvoid main() {\nvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );\nconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );\nconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );\nfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;\nfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;\nfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;\nfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;\nfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;\nfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;\nfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;\nfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;\nfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;\nfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + \nGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + \nGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; \nfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + \nGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + \nGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; \nfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );\ngl_FragColor = vec4( vec3( G ), 1 );\n}"};
THREE.ColorifyShader = {uniforms:{tDiffuse:{value:null}, color:{value:new THREE.Color(16777215)}}, vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform vec3 color;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\nvec3 luma = vec3( 0.299, 0.587, 0.114 );\nfloat v = dot( texel.xyz, luma );\ngl_FragColor = vec4( v * color, texel.w );\n}"};
THREE.ToneMapShader = {uniforms:{tDiffuse:{value:null}, averageLuminance:{value:1}, luminanceMap:{value:null}, maxLuminance:{value:16}, minLuminance:{value:.01}, middleGrey:{value:.6}}, vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"#include <common>\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nuniform float middleGrey;\nuniform float minLuminance;\nuniform float maxLuminance;\n#ifdef ADAPTED_LUMINANCE\nuniform sampler2D luminanceMap;\n#else\nuniform float averageLuminance;\n#endif\nvec3 ToneMap( vec3 vColor ) {\n#ifdef ADAPTED_LUMINANCE\nfloat fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;\n#else\nfloat fLumAvg = averageLuminance;\n#endif\nfloat fLumPixel = linearToRelativeLuminance( vColor );\nfloat fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );\nfloat fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);\nreturn fLumCompressed * vColor;\n}\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\ngl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );\n}"};
THREE.TechnicolorShader = {uniforms:{tDiffuse:{value:null}}, vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );\nvec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);\ngl_FragColor = newTex;\n}"};
THREE.HueSaturationShader = {uniforms:{tDiffuse:{value:null}, hue:{value:0}, saturation:{value:0}}, vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform sampler2D tDiffuse;\nuniform float hue;\nuniform float saturation;\nvarying vec2 vUv;\nvoid main() {\ngl_FragColor = texture2D( tDiffuse, vUv );\nfloat angle = hue * 3.14159265;\nfloat s = sin(angle), c = cos(angle);\nvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\nfloat len = length(gl_FragColor.rgb);\ngl_FragColor.rgb = vec3(\ndot(gl_FragColor.rgb, weights.xyz),\ndot(gl_FragColor.rgb, weights.zxy),\ndot(gl_FragColor.rgb, weights.yzx)\n);\nfloat average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\nif (saturation > 0.0) {\ngl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\n} else {\ngl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);\n}\n}"};
THREE.EffectComposer = function(a, c) {
  this.renderer = a;
  void 0 === c && (c = {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBAFormat, stencilBuffer:!1}, a = a.getDrawingBufferSize(new THREE.Vector2), c = new THREE.WebGLRenderTarget(a.width, a.height, c), c.texture.name = "EffectComposer.rt1");
  this.renderTarget1 = c;
  this.renderTarget2 = c.clone();
  this.renderTarget2.texture.name = "EffectComposer.rt2";
  this.writeBuffer = this.renderTarget1;
  this.readBuffer = this.renderTarget2;
  this.passes = [];
  void 0 === THREE.CopyShader && console.error("THREE.EffectComposer relies on THREE.CopyShader");
  void 0 === THREE.ShaderPass && console.error("THREE.EffectComposer relies on THREE.ShaderPass");
  this.copyPass = new THREE.ShaderPass(THREE.CopyShader);
  this._previousFrameTime = Date.now();
};
Object.assign(THREE.EffectComposer.prototype, {swapBuffers:function() {
  var a = this.readBuffer;
  this.readBuffer = this.writeBuffer;
  this.writeBuffer = a;
}, addPass:function(a) {
  this.passes.push(a);
  var c = this.renderer.getDrawingBufferSize(new THREE.Vector2);
  a.setSize(c.width, c.height);
}, insertPass:function(a, c) {
  this.passes.splice(c, 0, a);
}, render:function(a) {
  void 0 === a && (a = .001 * (Date.now() - this._previousFrameTime));
  this._previousFrameTime = Date.now();
  var c = this.renderer.getRenderTarget(), g = !1, b, e = this.passes.length;
  for (b = 0; b < e; b++) {
    var f = this.passes[b];
    if (!1 !== f.enabled) {
      f.render(this.renderer, this.writeBuffer, this.readBuffer, a, g);
      if (f.needsSwap) {
        if (g) {
          var k = this.renderer.context;
          k.stencilFunc(k.NOTEQUAL, 1, 4294967295);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, a);
          k.stencilFunc(k.EQUAL, 1, 4294967295);
        }
        this.swapBuffers();
      }
      void 0 !== THREE.MaskPass && (f instanceof THREE.MaskPass ? g = !0 : f instanceof THREE.ClearMaskPass && (g = !1));
    }
  }
  this.renderer.setRenderTarget(c);
}, reset:function(a) {
  if (void 0 === a) {
    var c = this.renderer.getDrawingBufferSize(new THREE.Vector2);
    a = this.renderTarget1.clone();
    a.setSize(c.width, c.height);
  }
  this.renderTarget1.dispose();
  this.renderTarget2.dispose();
  this.renderTarget1 = a;
  this.renderTarget2 = a.clone();
  this.writeBuffer = this.renderTarget1;
  this.readBuffer = this.renderTarget2;
}, setSize:function(a, c) {
  this.renderTarget1.setSize(a, c);
  this.renderTarget2.setSize(a, c);
  for (var g = 0; g < this.passes.length; g++) {
    this.passes[g].setSize(a, c);
  }
}});
THREE.Pass = function() {
  this.needsSwap = this.enabled = !0;
  this.renderToScreen = this.clear = !1;
};
Object.assign(THREE.Pass.prototype, {setSize:function(a, c) {
}, render:function(a, c, g, b, e) {
  console.error("THREE.Pass: .render() must be implemented in derived pass.");
}});
THREE.RenderPass = function(a, c, g, b, e) {
  THREE.Pass.call(this);
  this.scene = a;
  this.camera = c;
  this.overrideMaterial = g;
  this.clearColor = b;
  this.clearAlpha = void 0 !== e ? e : 0;
  this.clear = !0;
  this.needsSwap = this.clearDepth = !1;
};
THREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {constructor:THREE.RenderPass, render:function(a, c, g, b, e) {
  c = a.autoClear;
  a.autoClear = !1;
  this.scene.overrideMaterial = this.overrideMaterial;
  if (this.clearColor) {
    var f = a.getClearColor().getHex();
    var k = a.getClearAlpha();
    a.setClearColor(this.clearColor, this.clearAlpha);
  }
  this.clearDepth && a.clearDepth();
  a.setRenderTarget(this.renderToScreen ? null : g);
  this.clear && a.clear();
  a.render(this.scene, this.camera);
  this.clearColor && a.setClearColor(f, k);
  this.scene.overrideMaterial = null;
  a.autoClear = c;
}});
THREE.ShaderPass = function(a, c) {
  THREE.Pass.call(this);
  this.textureID = void 0 !== c ? c : "tDiffuse";
  a instanceof THREE.ShaderMaterial ? (this.uniforms = a.uniforms, this.material = a) : a && (this.uniforms = THREE.UniformsUtils.clone(a.uniforms), this.material = new THREE.ShaderMaterial({defines:Object.assign({}, a.defines), uniforms:this.uniforms, vertexShader:a.vertexShader, fragmentShader:a.fragmentShader}));
  this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  this.scene = new THREE.Scene;
  this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
  this.quad.frustumCulled = !1;
  this.scene.add(this.quad);
};
THREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {constructor:THREE.ShaderPass, render:function(a, c, g, b, e) {
  this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = g.texture);
  this.quad.material = this.material;
  this.renderToScreen ? a.setRenderTarget(null) : (a.setRenderTarget(c), this.clear && a.clear());
  a.render(this.scene, this.camera);
}});
THREE.MaskPass = function(a, c) {
  THREE.Pass.call(this);
  this.scene = a;
  this.camera = c;
  this.clear = !0;
  this.inverse = this.needsSwap = !1;
};
THREE.MaskPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {constructor:THREE.MaskPass, render:function(a, c, g, b, e) {
  b = a.context;
  e = a.state;
  e.buffers.color.setMask(!1);
  e.buffers.depth.setMask(!1);
  e.buffers.color.setLocked(!0);
  e.buffers.depth.setLocked(!0);
  if (this.inverse) {
    var f = 0;
    var k = 1;
  } else {
    f = 1, k = 0;
  }
  e.buffers.stencil.setTest(!0);
  e.buffers.stencil.setOp(b.REPLACE, b.REPLACE, b.REPLACE);
  e.buffers.stencil.setFunc(b.ALWAYS, f, 4294967295);
  e.buffers.stencil.setClear(k);
  a.setRenderTarget(g);
  this.clear && a.clear();
  a.render(this.scene, this.camera);
  a.setRenderTarget(c);
  this.clear && a.clear();
  a.render(this.scene, this.camera);
  e.buffers.color.setLocked(!1);
  e.buffers.depth.setLocked(!1);
  e.buffers.stencil.setFunc(b.EQUAL, 1, 4294967295);
  e.buffers.stencil.setOp(b.KEEP, b.KEEP, b.KEEP);
}});
THREE.ClearMaskPass = function() {
  THREE.Pass.call(this);
  this.needsSwap = !1;
};
THREE.ClearMaskPass.prototype = Object.create(THREE.Pass.prototype);
Object.assign(THREE.ClearMaskPass.prototype, {render:function(a, c, g, b, e) {
  a.state.buffers.stencil.setTest(!1);
}});
THREE.NURBSCurve = function(a, c, g, b, e) {
  THREE.Curve.call(this);
  this.degree = a;
  this.knots = c;
  this.controlPoints = [];
  this.startKnot = b || 0;
  this.endKnot = e || this.knots.length - 1;
  for (a = 0; a < g.length; ++a) {
    c = g[a], this.controlPoints[a] = new THREE.Vector4(c.x, c.y, c.z, c.w);
  }
};
THREE.NURBSCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.NURBSCurve.prototype.constructor = THREE.NURBSCurve;
THREE.NURBSCurve.prototype.getPoint = function(a) {
  a = THREE.NURBSUtils.calcBSplinePoint(this.degree, this.knots, this.controlPoints, this.knots[this.startKnot] + a * (this.knots[this.endKnot] - this.knots[this.startKnot]));
  1 != a.w && a.divideScalar(a.w);
  return new THREE.Vector3(a.x, a.y, a.z);
};
THREE.NURBSCurve.prototype.getTangent = function(a) {
  a = THREE.NURBSUtils.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, this.knots[0] + a * (this.knots[this.knots.length - 1] - this.knots[0]), 1)[1].clone();
  a.normalize();
  return a;
};
THREE.NURBSSurface = function(a, c, g, b, e) {
  this.degree1 = a;
  this.degree2 = c;
  this.knots1 = g;
  this.knots2 = b;
  this.controlPoints = [];
  a = g.length - a - 1;
  c = b.length - c - 1;
  for (b = 0; b < a; ++b) {
    for (this.controlPoints[b] = [], g = 0; g < c; ++g) {
      var f = e[b][g];
      this.controlPoints[b][g] = new THREE.Vector4(f.x, f.y, f.z, f.w);
    }
  }
};
THREE.NURBSSurface.prototype = {constructor:THREE.NURBSSurface, getPoint:function(a, c, g) {
  THREE.NURBSUtils.calcSurfacePoint(this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, this.knots1[0] + a * (this.knots1[this.knots1.length - 1] - this.knots1[0]), this.knots2[0] + c * (this.knots2[this.knots2.length - 1] - this.knots2[0]), g);
}};
THREE.NURBSUtils = {findSpan:function(a, c, g) {
  var b = g.length - a - 1;
  if (c >= g[b]) {
    return b - 1;
  }
  if (c <= g[a]) {
    return a;
  }
  for (var e = Math.floor((a + b) / 2); c < g[e] || c >= g[e + 1];) {
    c < g[e] ? b = e : a = e, e = Math.floor((a + b) / 2);
  }
  return e;
}, calcBasisFunctions:function(a, c, g, b) {
  for (var e = [], f = [], k = [], n = e[0] = 1; n <= g; ++n) {
    f[n] = c - b[a + 1 - n];
    k[n] = b[a + n] - c;
    for (var p = 0, m = 0; m < n; ++m) {
      var t = k[m + 1], d = f[n - m], l = e[m] / (t + d);
      e[m] = p + t * l;
      p = d * l;
    }
    e[n] = p;
  }
  return e;
}, calcBSplinePoint:function(a, c, g, b) {
  var e = this.findSpan(a, b, c);
  c = this.calcBasisFunctions(e, b, a, c);
  b = new THREE.Vector4(0, 0, 0, 0);
  for (var f = 0; f <= a; ++f) {
    var k = g[e - a + f], n = c[f], p = k.w * n;
    b.x += k.x * p;
    b.y += k.y * p;
    b.z += k.z * p;
    b.w += k.w * n;
  }
  return b;
}, calcBasisFunctionDerivatives:function(a, c, g, b, e) {
  for (var f = [], k = 0; k <= g; ++k) {
    f[k] = 0;
  }
  var n = [];
  for (k = 0; k <= b; ++k) {
    n[k] = f.slice(0);
  }
  var p = [];
  for (k = 0; k <= g; ++k) {
    p[k] = f.slice(0);
  }
  p[0][0] = 1;
  var m = f.slice(0), t = f.slice(0);
  for (k = 1; k <= g; ++k) {
    m[k] = c - e[a + 1 - k];
    t[k] = e[a + k] - c;
    for (var d = 0, l = 0; l < k; ++l) {
      var u = t[l + 1], w = m[k - l];
      p[k][l] = u + w;
      var y = p[l][k - 1] / p[k][l];
      p[l][k] = d + u * y;
      d = w * y;
    }
    p[k][k] = d;
  }
  for (k = 0; k <= g; ++k) {
    n[0][k] = p[k][g];
  }
  for (l = 0; l <= g; ++l) {
    a = 0;
    c = 1;
    e = [];
    for (k = 0; k <= g; ++k) {
      e[k] = f.slice(0);
    }
    for (m = e[0][0] = 1; m <= b; ++m) {
      t = 0;
      d = l - m;
      u = g - m;
      l >= m && (e[c][0] = e[a][0] / p[u + 1][d], t = e[c][0] * p[d][u]);
      w = l - 1 <= u ? m - 1 : g - l;
      for (k = -1 <= d ? 1 : -d; k <= w; ++k) {
        e[c][k] = (e[a][k] - e[a][k - 1]) / p[u + 1][d + k], t += e[c][k] * p[d + k][u];
      }
      l <= u && (e[c][m] = -e[a][m - 1] / p[u + 1][l], t += e[c][m] * p[l][u]);
      n[m][l] = t;
      k = a;
      a = c;
      c = k;
    }
  }
  l = g;
  for (m = 1; m <= b; ++m) {
    for (k = 0; k <= g; ++k) {
      n[m][k] *= l;
    }
    l *= g - m;
  }
  return n;
}, calcBSplineDerivatives:function(a, c, g, b, e) {
  var f = e < a ? e : a, k = [], n = this.findSpan(a, b, c);
  c = this.calcBasisFunctionDerivatives(n, b, a, f, c);
  b = [];
  for (var p = 0; p < g.length; ++p) {
    var m = g[p].clone(), t = m.w;
    m.x *= t;
    m.y *= t;
    m.z *= t;
    b[p] = m;
  }
  for (g = 0; g <= f; ++g) {
    m = b[n - a].clone().multiplyScalar(c[g][0]);
    for (p = 1; p <= a; ++p) {
      m.add(b[n - a + p].clone().multiplyScalar(c[g][p]));
    }
    k[g] = m;
  }
  for (g = f + 1; g <= e + 1; ++g) {
    k[g] = new THREE.Vector4(0, 0, 0);
  }
  return k;
}, calcKoverI:function(a, c) {
  for (var g = 1, b = 2; b <= a; ++b) {
    g *= b;
  }
  var e = 1;
  for (b = 2; b <= c; ++b) {
    e *= b;
  }
  for (b = 2; b <= a - c; ++b) {
    e *= b;
  }
  return g / e;
}, calcRationalCurveDerivatives:function(a) {
  for (var c = a.length, g = [], b = [], e = 0; e < c; ++e) {
    var f = a[e];
    g[e] = new THREE.Vector3(f.x, f.y, f.z);
    b[e] = f.w;
  }
  a = [];
  for (f = 0; f < c; ++f) {
    var k = g[f].clone();
    for (e = 1; e <= f; ++e) {
      k.sub(a[f - e].clone().multiplyScalar(this.calcKoverI(f, e) * b[e]));
    }
    a[f] = k.divideScalar(b[0]);
  }
  return a;
}, calcNURBSDerivatives:function(a, c, g, b, e) {
  a = this.calcBSplineDerivatives(a, c, g, b, e);
  return this.calcRationalCurveDerivatives(a);
}, calcSurfacePoint:function(a, c, g, b, e, f, k, n) {
  var p = this.findSpan(a, f, g), m = this.findSpan(c, k, b);
  g = this.calcBasisFunctions(p, f, a, g);
  b = this.calcBasisFunctions(m, k, c, b);
  k = [];
  for (f = 0; f <= c; ++f) {
    k[f] = new THREE.Vector4(0, 0, 0, 0);
    for (var t = 0; t <= a; ++t) {
      var d = e[p - a + t][m - c + f].clone(), l = d.w;
      d.x *= l;
      d.y *= l;
      d.z *= l;
      k[f].add(d.multiplyScalar(g[t]));
    }
  }
  a = new THREE.Vector4(0, 0, 0, 0);
  for (f = 0; f <= c; ++f) {
    a.add(k[f].multiplyScalar(b[f]));
  }
  a.divideScalar(a.w);
  n.set(a.x, a.y, a.z);
}};
THREE.Lensflare = function() {
  THREE.Mesh.call(this, THREE.Lensflare.Geometry, new THREE.MeshBasicMaterial({opacity:0, transparent:!0}));
  this.type = "Lensflare";
  this.frustumCulled = !1;
  this.renderOrder = Infinity;
  var a = new THREE.Vector3, c = new THREE.DataTexture(new Uint8Array(768), 16, 16, THREE.RGBFormat);
  c.minFilter = THREE.NearestFilter;
  c.magFilter = THREE.NearestFilter;
  c.wrapS = THREE.ClampToEdgeWrapping;
  c.wrapT = THREE.ClampToEdgeWrapping;
  c.needsUpdate = !			0;
  var g = new THREE.DataTexture(new Uint8Array(768), 16, 16, THREE.RGBFormat);
  g.minFilter = THREE.NearestFilter;
  g.magFilter = THREE.NearestFilter;
  g.wrapS = THREE.ClampToEdgeWrapping;
  g.wrapT = THREE.ClampToEdgeWrapping;
  g.needsUpdate = !0;
  var b = THREE.Lensflare.Geometry, e = new THREE.RawShaderMaterial({uniforms:{scale:{value:null}, screenPosition:{value:null}}, vertexShader:"precision highp float;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nattribute vec3 position;\nvoid main() {\n\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n}", fragmentShader:"precision highp float;\nvoid main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n}", depthTest:!0, depthWrite:!1, transparent:!1}), 
  f = new THREE.RawShaderMaterial({uniforms:{map:{value:c}, scale:{value:null}, screenPosition:{value:null}}, vertexShader:"precision highp float;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\n\tvUV = uv;\n\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n}", fragmentShader:"precision highp float;\nuniform sampler2D map;\nvarying vec2 vUV;\nvoid main() {\n\tgl_FragColor = texture2D( map, vUV );\n}", 
  depthTest:!1, depthWrite:!1, transparent:!1}), k = new THREE.Mesh(b, e), n = [], p = THREE.LensflareElement.Shader, m = new THREE.RawShaderMaterial({uniforms:{map:{value:null}, occlusionMap:{value:g}, color:{value:new THREE.Color(16777215)}, scale:{value:new THREE.Vector2}, screenPosition:{value:new THREE.Vector3}}, vertexShader:p.vertexShader, fragmentShader:p.fragmentShader, blending:THREE.AdditiveBlending, transparent:!0, depthWrite:!1}), t = new THREE.Mesh(b, m);
  this.addElement = function(a) {
    n.push(a);
  };
  var d = new THREE.Vector2, l = new THREE.Vector2, u = new THREE.Box2, w = new THREE.Vector4;
  this.onBeforeRender = function(p, x, q) {
    w.copy(p.getCurrentViewport());
    x = w.w / w.z;
    var v = w.z / 2, z = w.w / 2, y = 16 / w.w;
    d.set(y * x, y);
    u.min.set(w.x, w.y);
    u.max.set(w.x + (w.z - 16), w.y + (w.w - 16));
    a.setFromMatrixPosition(this.matrixWorld);
    a.applyMatrix4(q.matrixWorldInverse);
    a.applyMatrix4(q.projectionMatrix);
    l.x = w.x + a.x * v + v - 8;
    l.y = w.y + a.y * z + z - 8;
    if (u.containsPoint(l)) {
      p.copyFramebufferToTexture(l, c);
      v = e.uniforms;
      v.scale.value = d;
      v.screenPosition.value = a;
      p.renderBufferDirect(q, null, b, e, k, null);
      p.copyFramebufferToTexture(l, g);
      v = f.uniforms;
      v.scale.value = d;
      v.screenPosition.value = a;
      p.renderBufferDirect(q, null, b, f, k, null);
      z = 2 * -a.x;
      for (var A = 2 * -a.y, D = 0, E = n.length; D < E; D++) {
        x = n[D], v = m.uniforms, v.color.value.copy(x.color), v.map.value = x.texture, v.screenPosition.value.x = a.x + z * x.distance, v.screenPosition.value.y = a.y + A * x.distance, y = x.size / w.w, x = w.w / w.z, v.scale.value.set(y * x, y), m.uniformsNeedUpdate = !0, p.renderBufferDirect(q, null, b, m, t, null);
      }
    }
  };
  this.dispose = function() {
    e.dispose();
    f.dispose();
    m.dispose();
    c.dispose();
    g.dispose();
    for (var a = 0, b = n.length; a < b; a++) {
      n[a].texture.dispose();
    }
  };
};
THREE.Lensflare.prototype = Object.create(THREE.Mesh.prototype);
THREE.Lensflare.prototype.constructor = THREE.Lensflare;
THREE.Lensflare.prototype.isLensflare = !0;
THREE.LensflareElement = function(a, c, g, b) {
  this.texture = a;
  this.size = c || 1;
  this.distance = g || 0;
  this.color = b || new THREE.Color(16777215);
};
THREE.LensflareElement.Shader = {uniforms:{map:{value:null}, occlusionMap:{value:null}, color:{value:null}, scale:{value:null}, screenPosition:{value:null}}, vertexShader:"precision highp float;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform sampler2D occlusionMap;\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\n\tvUV = uv;\n\tvec2 pos = position.xy;\n\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\tvVisibility =        visibility.r / 9.0;\n\tvVisibility *= 1.0 - visibility.g / 9.0;\n\tvVisibility *=       visibility.b / 9.0;\n\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}", 
fragmentShader:"precision highp float;\nuniform sampler2D map;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\n\tvec4 texture = texture2D( map, vUV );\n\ttexture.a *= vVisibility;\n\tgl_FragColor = texture;\n\tgl_FragColor.rgb *= color;\n}"};
THREE.Lensflare.Geometry = function() {
  var a = new THREE.BufferGeometry, c = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);
  c = new THREE.InterleavedBuffer(c, 5);
  a.setIndex([0, 1, 2, 0, 2, 3]);
  a.addAttribute("position", new THREE.InterleavedBufferAttribute(c, 3, 0, !1));
  a.addAttribute("uv", new THREE.InterleavedBufferAttribute(c, 2, 3, !1));
  return a;
}();
THREE.Reflector = function(a, c) {
  THREE.Mesh.call(this, a);
  this.type = "Reflector";
  var g = this;
  c = c || {};
  a = void 0 !== c.color ? new THREE.Color(c.color) : new THREE.Color(8355711);
  var b = c.textureWidth || 512, e = c.textureHeight || 512, f = c.clipBias || 0, k = c.shader || THREE.Reflector.ReflectorShader, n = void 0 !== c.recursion ? c.recursion : 0, p = new THREE.Plane, m = new THREE.Vector3, t = new THREE.Vector3, d = new THREE.Vector3, l = new THREE.Matrix4, u = new THREE.Vector3(0, 0, -1), w = new THREE.Vector4, y = new THREE.Vector4, x = new THREE.Vector3, q = new THREE.Vector3, v = new THREE.Vector4, z = new THREE.Vector2, C = new THREE.Matrix4, A = new THREE.PerspectiveCamera, 
  D = new THREE.WebGLRenderTarget(b, e, {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBFormat, stencilBuffer:!1});
  THREE.Math.isPowerOfTwo(b) && THREE.Math.isPowerOfTwo(e) || (D.texture.generateMipmaps = !1);
  c = new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(k.uniforms), fragmentShader:k.fragmentShader, vertexShader:k.vertexShader});
  c.uniforms.tDiffuse.value = D.texture;
  c.uniforms.color.value = a;
  c.uniforms.textureMatrix.value = C;
  this.material = c;
  this.onBeforeRender = function(a, b, c) {
    if ("recursion" in c.userData) {
      if (c.userData.recursion === n) {
        return;
      }
      c.userData.recursion++;
    }
    t.setFromMatrixPosition(g.matrixWorld);
    d.setFromMatrixPosition(c.matrixWorld);
    l.extractRotation(g.matrixWorld);
    m.set(0, 0, 1);
    m.applyMatrix4(l);
    x.subVectors(t, d);
    if (!(0 < x.dot(m))) {
      x.reflect(m).negate();
      x.add(t);
      l.extractRotation(c.matrixWorld);
      u.set(0, 0, -1);
      u.applyMatrix4(l);
      u.add(d);
      q.subVectors(t, u);
      q.reflect(m).negate();
      q.add(t);
      A.position.copy(x);
      A.up.set(0, 1, 0);
      A.up.applyMatrix4(l);
      A.up.reflect(m);
      A.lookAt(q);
      A.far = c.far;
      A.updateMatrixWorld();
      A.projectionMatrix.copy(c.projectionMatrix);
      A.userData.recursion = 0;
      C.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
      C.multiply(A.projectionMatrix);
      C.multiply(A.matrixWorldInverse);
      C.multiply(g.matrixWorld);
      p.setFromNormalAndCoplanarPoint(m, t);
      p.applyMatrix4(A.matrixWorldInverse);
      w.set(p.normal.x, p.normal.y, p.normal.z, p.constant);
      var e = A.projectionMatrix;
      v.x = (Math.sign(w.x) + e.elements[8]) / e.elements[0];
      v.y = (Math.sign(w.y) + e.elements[9]) / e.elements[5];
      v.z = -1;
      v.w = (1 + e.elements[10]) / e.elements[14];
      w.multiplyScalar(2 / w.dot(v));
      e.elements[2] = w.x;
      e.elements[6] = w.y;
      e.elements[10] = w.z + 1 - f;
      e.elements[14] = w.w;
      g.visible = !1;
      e = a.getRenderTarget();
      var k = a.vr.enabled, B = a.shadowMap.autoUpdate;
      a.vr.enabled = !1;
      a.shadowMap.autoUpdate = !1;
      a.setRenderTarget(D);
      a.clear();
      a.render(b, A);
      a.vr.enabled = k;
      a.shadowMap.autoUpdate = B;
      a.setRenderTarget(e);
      b = c.bounds;
      void 0 !== b && (a.getSize(z), c = a.getPixelRatio(), y.x = b.x * z.width * c, y.y = b.y * z.height * c, y.z = b.z * z.width * c, y.w = b.w * z.height * c, a.state.viewport(y));
      g.visible = !0;
    }
  };
  this.getRenderTarget = function() {
    return D;
  };
};
THREE.Reflector.prototype = Object.create(THREE.Mesh.prototype);
THREE.Reflector.prototype.constructor = THREE.Reflector;
THREE.Reflector.ReflectorShader = {uniforms:{color:{type:"c", value:null}, tDiffuse:{type:"t", value:null}, textureMatrix:{type:"m4", value:null}}, vertexShader:"uniform mat4 textureMatrix;\nvarying vec4 vUv;\nvoid main() {\n\tvUv = textureMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform vec3 color;\nuniform sampler2D tDiffuse;\nvarying vec4 vUv;\nfloat blendOverlay( float base, float blend ) {\n\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n}\nvec3 blendOverlay( vec3 base, vec3 blend ) {\n\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n}\nvoid main() {\n\tvec4 base = texture2DProj( tDiffuse, vUv );\n\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n}"};
THREE.Refractor = function(a, c) {
  THREE.Mesh.call(this, a);
  this.type = "Refractor";
  var g = this;
  c = c || {};
  a = void 0 !== c.color ? new THREE.Color(c.color) : new THREE.Color(8355711);
  var b = c.textureWidth || 512, e = c.textureHeight || 512, f = c.clipBias || 0;
  c = c.shader || THREE.Refractor.RefractorShader;
  var k = new THREE.PerspectiveCamera;
  k.matrixAutoUpdate = !1;
  k.userData.refractor = !0;
  var n = new THREE.Plane, p = new THREE.Matrix4, m = new THREE.WebGLRenderTarget(b, e, {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBFormat, stencilBuffer:!1});
  THREE.Math.isPowerOfTwo(b) && THREE.Math.isPowerOfTwo(e) || (m.texture.generateMipmaps = !1);
  this.material = new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(c.uniforms), vertexShader:c.vertexShader, fragmentShader:c.fragmentShader, transparent:!0});
  this.material.uniforms.color.value = a;
  this.material.uniforms.tDiffuse.value = m.texture;
  this.material.uniforms.textureMatrix.value = p;
  var t = function() {
    var a = new THREE.Vector3, b = new THREE.Vector3, d = new THREE.Matrix4, c = new THREE.Vector3, f = new THREE.Vector3;
    return function(e) {
      a.setFromMatrixPosition(g.matrixWorld);
      b.setFromMatrixPosition(e.matrixWorld);
      c.subVectors(a, b);
      d.extractRotation(g.matrixWorld);
      f.set(0, 0, 1);
      f.applyMatrix4(d);
      return 0 > c.dot(f);
    };
  }(), d = function() {
    var a = new THREE.Vector3, b = new THREE.Vector3, d = new THREE.Quaternion, c = new THREE.Vector3;
    return function() {
      g.matrixWorld.decompose(b, d, c);
      a.set(0, 0, 1).applyQuaternion(d).normalize();
      a.negate();
      n.setFromNormalAndCoplanarPoint(a, b);
    };
  }(), l = function() {
    var a = new THREE.Plane, b = new THREE.Vector4, d = new THREE.Vector4;
    return function(c) {
      k.matrixWorld.copy(c.matrixWorld);
      k.matrixWorldInverse.getInverse(k.matrixWorld);
      k.projectionMatrix.copy(c.projectionMatrix);
      k.far = c.far;
      a.copy(n);
      a.applyMatrix4(k.matrixWorldInverse);
      b.set(a.normal.x, a.normal.y, a.normal.z, a.constant);
      c = k.projectionMatrix;
      d.x = (Math.sign(b.x) + c.elements[8]) / c.elements[0];
      d.y = (Math.sign(b.y) + c.elements[9]) / c.elements[5];
      d.z = -1;
      d.w = (1 + c.elements[10]) / c.elements[14];
      b.multiplyScalar(2 / b.dot(d));
      c.elements[2] = b.x;
      c.elements[6] = b.y;
      c.elements[10] = b.z + 1 - f;
      c.elements[14] = b.w;
    };
  }(), u = function() {
    var a = new THREE.Vector4, b = new THREE.Vector2;
    return function(d, c, f) {
      g.visible = !1;
      var e = d.getRenderTarget(), l = d.vr.enabled, q = d.shadowMap.autoUpdate;
      d.vr.enabled = !1;
      d.shadowMap.autoUpdate = !1;
      d.setRenderTarget(m);
      d.clear();
      d.render(c, k);
      d.vr.enabled = l;
      d.shadowMap.autoUpdate = q;
      d.setRenderTarget(e);
      c = f.bounds;
      void 0 !== c && (d.getSize(b), f = d.getPixelRatio(), a.x = c.x * b.width * f, a.y = c.y * b.height * f, a.z = c.z * b.width * f, a.w = c.w * b.height * f, d.state.viewport(a));
      g.visible = !0;
    };
  }();
  this.onBeforeRender = function(a, b, c) {
    !0 !== c.userData.refractor && !0 !== !t(c) && (d(), p.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), p.multiply(c.projectionMatrix), p.multiply(c.matrixWorldInverse), p.multiply(g.matrixWorld), l(c), u(a, b, c));
  };
  this.getRenderTarget = function() {
    return m;
  };
};
THREE.Refractor.prototype = Object.create(THREE.Mesh.prototype);
THREE.Refractor.prototype.constructor = THREE.Refractor;
THREE.Refractor.RefractorShader = {uniforms:{color:{type:"c", value:null}, tDiffuse:{type:"t", value:null}, textureMatrix:{type:"m4", value:null}}, vertexShader:"uniform mat4 textureMatrix;\nvarying vec4 vUv;\nvoid main() {\n\tvUv = textureMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform vec3 color;\nuniform sampler2D tDiffuse;\nvarying vec4 vUv;\nfloat blendOverlay( float base, float blend ) {\n\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n}\nvec3 blendOverlay( vec3 base, vec3 blend ) {\n\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n}\nvoid main() {\n\tvec4 base = texture2DProj( tDiffuse, vUv );\n\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n}"};
THREE.TTFLoader = function(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.reversed = !1;
};
THREE.TTFLoader.prototype = {constructor:THREE.TTFLoader, load:function(a, c, g, b) {
  var e = this, f = new THREE.FileLoader(this.manager);
  f.setPath(this.path);
  f.setResponseType("arraybuffer");
  f.load(a, function(a) {
    c(e.parse(a));
  }, g, b);
}, setPath:function(a) {
  this.path = a;
  return this;
}, parse:function(a) {
  function c(a) {
    var b = [], c;
    a.forEach(function(a) {
      "m" === a.type.toLowerCase() ? (c = [a], b.push(c)) : "z" !== a.type.toLowerCase() && c.push(a);
    });
    var f = [];
    b.forEach(function(a) {
      var b = {type:"m", x:a[a.length - 1].x, y:a[a.length - 1].y};
      f.push(b);
      for (var c = a.length - 1; 0 < c; c--) {
        var e = a[c];
        b = {type:e.type};
        void 0 !== e.x2 && void 0 !== e.y2 ? (b.x1 = e.x2, b.y1 = e.y2, b.x2 = e.x1, b.y2 = e.y1) : void 0 !== e.x1 && void 0 !== e.y1 && (b.x1 = e.x1, b.y1 = e.y1);
        b.x = a[c - 1].x;
        b.y = a[c - 1].y;
        f.push(b);
      }
    });
    return f;
  }
  return "undefined" === typeof opentype ? (console.warn("THREE.TTFLoader: The loader requires opentype.js. Make sure it's included before using the loader."), null) : function(a, b) {
    for (var e = Math.round, f = {}, k = 1E5 / (72 * (a.unitsPerEm || 2048)), g = 0; g < a.glyphs.length; g++) {
      var p = a.glyphs.glyphs[g];
      if (void 0 !== p.unicode) {
        var m = {ha:e(p.advanceWidth * k), x_min:e(p.xMin * k), x_max:e(p.xMax * k), o:""};
        b && (p.path.commands = c(p.path.commands));
        p.path.commands.forEach(function(a, b) {
          "c" === a.type.toLowerCase() && (a.type = "b");
          m.o += a.type.toLowerCase() + " ";
          void 0 !== a.x && void 0 !== a.y && (m.o += e(a.x * k) + " " + e(a.y * k) + " ");
          void 0 !== a.x1 && void 0 !== a.y1 && (m.o += e(a.x1 * k) + " " + e(a.y1 * k) + " ");
          void 0 !== a.x2 && void 0 !== a.y2 && (m.o += e(a.x2 * k) + " " + e(a.y2 * k) + " ");
        });
        f[String.fromCharCode(p.unicode)] = m;
      }
    }
    return {glyphs:f, familyName:a.familyName, ascender:e(a.ascender * k), descender:e(a.descender * k), underlinePosition:a.tables.post.underlinePosition, underlineThickness:a.tables.post.underlineThickness, boundingBox:{xMin:a.tables.head.xMin, xMax:a.tables.head.xMax, yMin:a.tables.head.yMin, yMax:a.tables.head.yMax}, resolution:1E3, original_font_information:a.tables.name};
  }(opentype.parse(a), this.reversed);
}};
(function(a, c) {
  if ("function" === typeof define && define.amd) {
    define(["long"], c);
  } else {
    if ("function" === typeof require && "object" === typeof module && module && module.exports) {
      a = module;
      try {
        var g = require("long");
      } catch (b) {
      }
      g = c(g);
      a.exports = g;
    } else {
      (a.dcodeIO = a.dcodeIO || {}).ByteBuffer = c(a.dcodeIO.Long);
    }
  }
})(this, function(a) {
  function c(a) {
    var b = 0;
    return function() {
      return b < a.length ? a.charCodeAt(b++) : null;
    };
  }
  function g() {
    var a = [], b = [];
    return function() {
      if (0 === arguments.length) {
        return b.join("") + p.apply(String, a);
      }
      1024 < a.length + arguments.length && (b.push(p.apply(String, a)), a.length = 0);
      Array.prototype.push.apply(a, arguments);
    };
  }
  function b(a, b, c, f, e) {
    var d = 8 * e - f - 1;
    var l = (1 << d) - 1, k = l >> 1, g = -7;
    e = c ? e - 1 : 0;
    var m = c ? -1 : 1, n = a[b + e];
    e += m;
    c = n & (1 << -g) - 1;
    n >>= -g;
    for (g += d; 0 < g; c = 256 * c + a[b + e], e += m, g -= 8) {
    }
    d = c & (1 << -g) - 1;
    c >>= -g;
    for (g += f; 0 < g; d = 256 * d + a[b + e], e += m, g -= 8) {
    }
    if (0 === c) {
      c = 1 - k;
    } else {
      if (c === l) {
        return d ? NaN : Infinity * (n ? -1 : 1);
      }
      d += Math.pow(2, f);
      c -= k;
    }
    return (n ? -1 : 1) * d * Math.pow(2, c - f);
  }
  function e(a, b, c, f, e, k) {
    var d, l = 8 * k - e - 1, g = (1 << l) - 1, m = g >> 1, n = 23 === e ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    k = f ? 0 : k - 1;
    var t = f ? 1 : -1, u = 0 > b || 0 === b && 0 > 1 / b ? 1 : 0;
    b = Math.abs(b);
    for (isNaN(b) || Infinity === b ? (b = isNaN(b) ? 1 : 0, f = g) : (f = Math.floor(Math.log(b) / Math.LN2), 1 > b * (d = Math.pow(2, -f)) && (f--, d *= 2), b = 1 <= f + m ? b + n / d : b + n * Math.pow(2, 1 - m), 2 <= b * d && (f++, d /= 2), f + m >= g ? (b = 0, f = g) : 1 <= f + m ? (b = (b * d - 1) * Math.pow(2, e), f += m) : (b = b * Math.pow(2, m - 1) * Math.pow(2, e), f = 0)); 8 <= e; a[c + k] = b & 255, k += t, b /= 256, e -= 8) {
    }
    f = f << e | b;
    for (l += e; 0 < l; a[c + k] = f & 255, k += t, f /= 256, l -= 8) {
    }
    a[c + k - t] |= 128 * u;
  }
  var f = function(a, b, c) {
    "undefined" === typeof a && (a = f.DEFAULT_CAPACITY);
    "undefined" === typeof b && (b = f.DEFAULT_ENDIAN);
    "undefined" === typeof c && (c = f.DEFAULT_NOASSERT);
    if (!c) {
      a |= 0;
      if (0 > a) {
        throw RangeError("Illegal capacity");
      }
      b = !!b;
      c = !!c;
    }
    this.buffer = 0 === a ? n : new ArrayBuffer(a);
    this.view = 0 === a ? null : new Uint8Array(this.buffer);
    this.offset = 0;
    this.markedOffset = -1;
    this.limit = a;
    this.littleEndian = b;
    this.noAssert = c;
  };
  f.VERSION = "5.0.1";
  f.LITTLE_ENDIAN = !0;
  f.BIG_ENDIAN = !1;
  f.DEFAULT_CAPACITY = 16;
  f.DEFAULT_ENDIAN = f.BIG_ENDIAN;
  f.DEFAULT_NOASSERT = !1;
  f.Long = a || null;
  var k = f.prototype;
  Object.defineProperty(k, "__isByteBuffer__", {value:!0, enumerable:!1, configurable:!1});
  var n = new ArrayBuffer(0), p = String.fromCharCode;
  f.accessor = function() {
    return Uint8Array;
  };
  f.allocate = function(a, b, c) {
    return new f(a, b, c);
  };
  f.concat = function(a, b, c, e) {
    if ("boolean" === typeof b || "string" !== typeof b) {
      e = c, c = b, b = void 0;
    }
    for (var d = 0, l = 0, k = a.length, g; l < k; ++l) {
      f.isByteBuffer(a[l]) || (a[l] = f.wrap(a[l], b)), g = a[l].limit - a[l].offset, 0 < g && (d += g);
    }
    if (0 === d) {
      return new f(0, c, e);
    }
    b = new f(d, c, e);
    for (l = 0; l < k;) {
      c = a[l++], g = c.limit - c.offset, 0 >= g || (b.view.set(c.view.subarray(c.offset, c.limit), b.offset), b.offset += g);
    }
    b.limit = b.offset;
    b.offset = 0;
    return b;
  };
  f.isByteBuffer = function(a) {
    return !0 === (a && a.__isByteBuffer__);
  };
  f.type = function() {
    return ArrayBuffer;
  };
  f.wrap = function(a, b, c, e) {
    "string" !== typeof b && (e = c, c = b, b = void 0);
    if ("string" === typeof a) {
      switch("undefined" === typeof b && (b = "utf8"), b) {
        case "base64":
          return f.fromBase64(a, c);
        case "hex":
          return f.fromHex(a, c);
        case "binary":
          return f.fromBinary(a, c);
        case "utf8":
          return f.fromUTF8(a, c);
        case "debug":
          return f.fromDebug(a, c);
        default:
          throw Error("Unsupported encoding: " + b);
      }
    }
    if (null === a || "object" !== typeof a) {
      throw TypeError("Illegal buffer");
    }
    if (f.isByteBuffer(a)) {
      return b = k.clone.call(a), b.markedOffset = -1, b;
    }
    if (a instanceof Uint8Array) {
      b = new f(0, c, e), 0 < a.length && (b.buffer = a.buffer, b.offset = a.byteOffset, b.limit = a.byteOffset + a.byteLength, b.view = new Uint8Array(a.buffer));
    } else {
      if (a instanceof ArrayBuffer) {
        b = new f(0, c, e), 0 < a.byteLength && (b.buffer = a, b.offset = 0, b.limit = a.byteLength, b.view = 0 < a.byteLength ? new Uint8Array(a) : null);
      } else {
        if ("[object Array]" === Object.prototype.toString.call(a)) {
          for (b = new f(a.length, c, e), b.limit = a.length, c = 0; c < a.length; ++c) {
            b.view[c] = a[c];
          }
        } else {
          throw TypeError("Illegal buffer");
        }
      }
    }
    return b;
  };
  k.writeBitSet = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if (!(a instanceof Array)) {
        throw TypeError("Illegal BitSet: Not an array");
      }
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
      }
    }
    var c = b, f = a.length, e = f >> 3, l = 0;
    for (b += this.writeVarint32(f, b); e--;) {
      var k = !!a[l++] & 1 | (!!a[l++] & 1) << 1 | (!!a[l++] & 1) << 2 | (!!a[l++] & 1) << 3 | (!!a[l++] & 1) << 4 | (!!a[l++] & 1) << 5 | (!!a[l++] & 1) << 6 | (!!a[l++] & 1) << 7;
      this.writeByte(k, b++);
    }
    if (l < f) {
      for (k = e = 0; l < f;) {
        k |= (!!a[l++] & 1) << e++;
      }
      this.writeByte(k, b++);
    }
    return d ? (this.offset = b, this) : b - c;
  };
  k.readBitSet = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    var d = this.readVarint32(a), c = d.value, f = c >> 3, e = 0, k = [];
    for (a += d.length; f--;) {
      d = this.readByte(a++), k[e++] = !!(d & 1), k[e++] = !!(d & 2), k[e++] = !!(d & 4), k[e++] = !!(d & 8), k[e++] = !!(d & 16), k[e++] = !!(d & 32), k[e++] = !!(d & 64), k[e++] = !!(d & 128);
    }
    if (e < c) {
      for (f = 0, d = this.readByte(a++); e < c;) {
        k[e++] = !!(d >> f++ & 1);
      }
    }
    b && (this.offset = a);
    return k;
  };
  k.readBytes = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + a > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+" + a + ") <= " + this.buffer.byteLength);
      }
    }
    b = this.slice(b, b + a);
    d && (this.offset += a);
    return b;
  };
  k.writeBytes = k.append;
  k.writeInt8 = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a |= 0;
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
      }
    }
    b += 1;
    var c = this.buffer.byteLength;
    b > c && this.resize((c *= 2) > b ? c : b);
    this.view[b - 1] = a;
    d && (this.offset += 1);
    return this;
  };
  k.writeByte = k.writeInt8;
  k.readInt8 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 1 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
      }
    }
    a = this.view[a];
    128 === (a & 128) && (a = -(255 - a + 1));
    b && (this.offset += 1);
    return a;
  };
  k.readByte = k.readInt8;
  k.writeUint8 = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a >>>= 0;
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
      }
    }
    b += 1;
    var c = this.buffer.byteLength;
    b > c && this.resize((c *= 2) > b ? c : b);
    this.view[b - 1] = a;
    d && (this.offset += 1);
    return this;
  };
  k.writeUInt8 = k.writeUint8;
  k.readUint8 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 1 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
      }
    }
    a = this.view[a];
    b && (this.offset += 1);
    return a;
  };
  k.readUInt8 = k.readUint8;
  k.writeInt16 = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a |= 0;
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
      }
    }
    b += 2;
    var c = this.buffer.byteLength;
    b > c && this.resize((c *= 2) > b ? c : b);
    b -= 2;
    this.littleEndian ? (this.view[b + 1] = (a & 65280) >>> 8, this.view[b] = a & 255) : (this.view[b] = (a & 65280) >>> 8, this.view[b + 1] = a & 255);
    d && (this.offset += 2);
    return this;
  };
  k.writeShort = k.writeInt16;
  k.readInt16 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 2 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+2) <= " + this.buffer.byteLength);
      }
    }
    var d = 0;
    this.littleEndian ? (d = this.view[a], d |= this.view[a + 1] << 8) : (d = this.view[a] << 8, d |= this.view[a + 1]);
    32768 === (d & 32768) && (d = -(65535 - d + 1));
    b && (this.offset += 2);
    return d;
  };
  k.readShort = k.readInt16;
  k.writeUint16 = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a >>>= 0;
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
      }
    }
    b += 2;
    var c = this.buffer.byteLength;
    b > c && this.resize((c *= 2) > b ? c : b);
    b -= 2;
    this.littleEndian ? (this.view[b + 1] = (a & 65280) >>> 8, this.view[b] = a & 255) : (this.view[b] = (a & 65280) >>> 8, this.view[b + 1] = a & 255);
    d && (this.offset += 2);
    return this;
  };
  k.writeUInt16 = k.writeUint16;
  k.readUint16 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 2 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+2) <= " + this.buffer.byteLength);
      }
    }
    var d = 0;
    this.littleEndian ? (d = this.view[a], d |= this.view[a + 1] << 8) : (d = this.view[a] << 8, d |= this.view[a + 1]);
    b && (this.offset += 2);
    return d;
  };
  k.readUInt16 = k.readUint16;
  k.writeInt32 = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a |= 0;
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
      }
    }
    b += 4;
    var c = this.buffer.byteLength;
    b > c && this.resize((c *= 2) > b ? c : b);
    b -= 4;
    this.littleEndian ? (this.view[b + 3] = a >>> 24 & 255, this.view[b + 2] = a >>> 16 & 255, this.view[b + 1] = a >>> 8 & 255, this.view[b] = a & 255) : (this.view[b] = a >>> 24 & 255, this.view[b + 1] = a >>> 16 & 255, this.view[b + 2] = a >>> 8 & 255, this.view[b + 3] = a & 255);
    d && (this.offset += 4);
    return this;
  };
  k.writeInt = k.writeInt32;
  k.readInt32 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 4 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
      }
    }
    var d = 0;
    this.littleEndian ? (d = this.view[a + 2] << 16, d |= this.view[a + 1] << 8, d |= this.view[a], d += this.view[a + 3] << 24 >>> 0) : (d = this.view[a + 1] << 16, d |= this.view[a + 2] << 8, d |= this.view[a + 3], d += this.view[a] << 24 >>> 0);
    b && (this.offset += 4);
    return d | 0;
  };
  k.readInt = k.readInt32;
  k.writeUint32 = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a >>>= 0;
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
      }
    }
    b += 4;
    var c = this.buffer.byteLength;
    b > c && this.resize((c *= 2) > b ? c : b);
    b -= 4;
    this.littleEndian ? (this.view[b + 3] = a >>> 24 & 255, this.view[b + 2] = a >>> 16 & 255, this.view[b + 1] = a >>> 8 & 255, this.view[b] = a & 255) : (this.view[b] = a >>> 24 & 255, this.view[b + 1] = a >>> 16 & 255, this.view[b + 2] = a >>> 8 & 255, this.view[b + 3] = a & 255);
    d && (this.offset += 4);
    return this;
  };
  k.writeUInt32 = k.writeUint32;
  k.readUint32 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 4 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
      }
    }
    var d = 0;
    this.littleEndian ? (d = this.view[a + 2] << 16, d |= this.view[a + 1] << 8, d |= this.view[a], d += this.view[a + 3] << 24 >>> 0) : (d = this.view[a + 1] << 16, d |= this.view[a + 2] << 8, d |= this.view[a + 3], d += this.view[a] << 24 >>> 0);
    b && (this.offset += 4);
    return d;
  };
  k.readUInt32 = k.readUint32;
  a && (k.writeInt64 = function(b, c) {
    var d = "undefined" === typeof c;
    d && (c = this.offset);
    if (!this.noAssert) {
      if ("number" === typeof b) {
        b = a.fromNumber(b);
      } else {
        if ("string" === typeof b) {
          b = a.fromString(b);
        } else {
          if (!(b && b instanceof a)) {
            throw TypeError("Illegal value: " + b + " (not an integer or Long)");
          }
        }
      }
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    "number" === typeof b ? b = a.fromNumber(b) : "string" === typeof b && (b = a.fromString(b));
    c += 8;
    var f = this.buffer.byteLength;
    c > f && this.resize((f *= 2) > c ? f : c);
    c -= 8;
    f = b.low;
    b = b.high;
    this.littleEndian ? (this.view[c + 3] = f >>> 24 & 255, this.view[c + 2] = f >>> 16 & 255, this.view[c + 1] = f >>> 8 & 255, this.view[c] = f & 255, c += 4, this.view[c + 3] = b >>> 24 & 255, this.view[c + 2] = b >>> 16 & 255, this.view[c + 1] = b >>> 8 & 255, this.view[c] = b & 255) : (this.view[c] = b >>> 24 & 255, this.view[c + 1] = b >>> 16 & 255, this.view[c + 2] = b >>> 8 & 255, this.view[c + 3] = b & 255, c += 4, this.view[c] = f >>> 24 & 255, this.view[c + 1] = f >>> 16 & 255, this.view[c + 
    2] = f >>> 8 & 255, this.view[c + 3] = f & 255);
    d && (this.offset += 8);
    return this;
  }, k.writeLong = k.writeInt64, k.readInt64 = function(b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 8 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+8) <= " + this.buffer.byteLength);
      }
    }
    var c = 0, f = 0;
    this.littleEndian ? (c = this.view[b + 2] << 16, c |= this.view[b + 1] << 8, c |= this.view[b], c += this.view[b + 3] << 24 >>> 0, b += 4, f = this.view[b + 2] << 16, f |= this.view[b + 1] << 8, f |= this.view[b], f += this.view[b + 3] << 24 >>> 0) : (f = this.view[b + 1] << 16, f |= this.view[b + 2] << 8, f |= this.view[b + 3], f += this.view[b] << 24 >>> 0, b += 4, c = this.view[b + 1] << 16, c |= this.view[b + 2] << 8, c |= this.view[b + 3], c += this.view[b] << 24 >>> 0);
    b = new a(c, f, !1);
    d && (this.offset += 8);
    return b;
  }, k.readLong = k.readInt64, k.writeUint64 = function(b, c) {
    var d = "undefined" === typeof c;
    d && (c = this.offset);
    if (!this.noAssert) {
      if ("number" === typeof b) {
        b = a.fromNumber(b);
      } else {
        if ("string" === typeof b) {
          b = a.fromString(b);
        } else {
          if (!(b && b instanceof a)) {
            throw TypeError("Illegal value: " + b + " (not an integer or Long)");
          }
        }
      }
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    "number" === typeof b ? b = a.fromNumber(b) : "string" === typeof b && (b = a.fromString(b));
    c += 8;
    var f = this.buffer.byteLength;
    c > f && this.resize((f *= 2) > c ? f : c);
    c -= 8;
    f = b.low;
    b = b.high;
    this.littleEndian ? (this.view[c + 3] = f >>> 24 & 255, this.view[c + 2] = f >>> 16 & 255, this.view[c + 1] = f >>> 8 & 255, this.view[c] = f & 255, c += 4, this.view[c + 3] = b >>> 24 & 255, this.view[c + 2] = b >>> 16 & 255, this.view[c + 1] = b >>> 8 & 255, this.view[c] = b & 255) : (this.view[c] = b >>> 24 & 255, this.view[c + 1] = b >>> 16 & 255, this.view[c + 2] = b >>> 8 & 255, this.view[c + 3] = b & 255, c += 4, this.view[c] = f >>> 24 & 255, this.view[c + 1] = f >>> 16 & 255, this.view[c + 
    2] = f >>> 8 & 255, this.view[c + 3] = f & 255);
    d && (this.offset += 8);
    return this;
  }, k.writeUInt64 = k.writeUint64, k.readUint64 = function(b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 8 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+8) <= " + this.buffer.byteLength);
      }
    }
    var c = 0, f = 0;
    this.littleEndian ? (c = this.view[b + 2] << 16, c |= this.view[b + 1] << 8, c |= this.view[b], c += this.view[b + 3] << 24 >>> 0, b += 4, f = this.view[b + 2] << 16, f |= this.view[b + 1] << 8, f |= this.view[b], f += this.view[b + 3] << 24 >>> 0) : (f = this.view[b + 1] << 16, f |= this.view[b + 2] << 8, f |= this.view[b + 3], f += this.view[b] << 24 >>> 0, b += 4, c = this.view[b + 1] << 16, c |= this.view[b + 2] << 8, c |= this.view[b + 3], c += this.view[b] << 24 >>> 0);
    b = new a(c, f, !0);
    d && (this.offset += 8);
    return b;
  }, k.readUInt64 = k.readUint64);
  k.writeFloat32 = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a) {
        throw TypeError("Illegal value: " + a + " (not a number)");
      }
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
      }
    }
    b += 4;
    var c = this.buffer.byteLength;
    b > c && this.resize((c *= 2) > b ? c : b);
    e(this.view, a, b - 4, this.littleEndian, 23, 4);
    d && (this.offset += 4);
    return this;
  };
  k.writeFloat = k.writeFloat32;
  k.readFloat32 = function(a) {
    var d = "undefined" === typeof a;
    d && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 4 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
      }
    }
    a = b(this.view, a, this.littleEndian, 23, 4);
    d && (this.offset += 4);
    return a;
  };
  k.readFloat = k.readFloat32;
  k.writeFloat64 = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a) {
        throw TypeError("Illegal value: " + a + " (not a number)");
      }
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
      }
    }
    b += 8;
    var c = this.buffer.byteLength;
    b > c && this.resize((c *= 2) > b ? c : b);
    e(this.view, a, b - 8, this.littleEndian, 52, 8);
    d && (this.offset += 8);
    return this;
  };
  k.writeDouble = k.writeFloat64;
  k.readFloat64 = function(a) {
    var d = "undefined" === typeof a;
    d && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 8 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+8) <= " + this.buffer.byteLength);
      }
    }
    a = b(this.view, a, this.littleEndian, 52, 8);
    d && (this.offset += 8);
    return a;
  };
  k.readDouble = k.readFloat64;
  f.MAX_VARINT32_BYTES = 5;
  f.calculateVarint32 = function(a) {
    a >>>= 0;
    return 128 > a ? 1 : 16384 > a ? 2 : 2097152 > a ? 3 : 268435456 > a ? 4 : 5;
  };
  f.zigZagEncode32 = function(a) {
    return ((a |= 0) << 1 ^ a >> 31) >>> 0;
  };
  f.zigZagDecode32 = function(a) {
    return a >>> 1 ^ -(a & 1) | 0;
  };
  k.writeVarint32 = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a |= 0;
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
      }
    }
    var c = f.calculateVarint32(a);
    b += c;
    var e = this.buffer.byteLength;
    b > e && this.resize((e *= 2) > b ? e : b);
    b -= c;
    for (a >>>= 0; 128 <= a;) {
      e = a & 127 | 128, this.view[b++] = e, a >>>= 7;
    }
    this.view[b++] = a;
    return d ? (this.offset = b, this) : c;
  };
  k.writeVarint32ZigZag = function(a, b) {
    return this.writeVarint32(f.zigZagEncode32(a), b);
  };
  k.readVarint32 = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 1 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
      }
    }
    var d = 0, c = 0;
    do {
      if (!this.noAssert && a > this.limit) {
        throw a = Error("Truncated"), a.truncated = !0, a;
      }
      var f = this.view[a++];
      5 > d && (c |= (f & 127) << 7 * d);
      ++d;
    } while (0 !== (f & 128));
    c |= 0;
    return b ? (this.offset = a, c) : {value:c, length:d};
  };
  k.readVarint32ZigZag = function(a) {
    a = this.readVarint32(a);
    "object" === typeof a ? a.value = f.zigZagDecode32(a.value) : a = f.zigZagDecode32(a);
    return a;
  };
  a && (f.MAX_VARINT64_BYTES = 10, f.calculateVarint64 = function(b) {
    "number" === typeof b ? b = a.fromNumber(b) : "string" === typeof b && (b = a.fromString(b));
    var d = b.toInt() >>> 0, c = b.shiftRightUnsigned(28).toInt() >>> 0;
    b = b.shiftRightUnsigned(56).toInt() >>> 0;
    return 0 == b ? 0 == c ? 16384 > d ? 128 > d ? 1 : 2 : 2097152 > d ? 3 : 4 : 16384 > c ? 128 > c ? 5 : 6 : 2097152 > c ? 7 : 8 : 128 > b ? 9 : 10;
  }, f.zigZagEncode64 = function(b) {
    "number" === typeof b ? b = a.fromNumber(b, !1) : "string" === typeof b ? b = a.fromString(b, !1) : !1 !== b.unsigned && (b = b.toSigned());
    return b.shiftLeft(1).xor(b.shiftRight(63)).toUnsigned();
  }, f.zigZagDecode64 = function(b) {
    "number" === typeof b ? b = a.fromNumber(b, !1) : "string" === typeof b ? b = a.fromString(b, !1) : !1 !== b.unsigned && (b = b.toSigned());
    return b.shiftRightUnsigned(1).xor(b.and(a.ONE).toSigned().negate()).toSigned();
  }, k.writeVarint64 = function(b, c) {
    var d = "undefined" === typeof c;
    d && (c = this.offset);
    if (!this.noAssert) {
      if ("number" === typeof b) {
        b = a.fromNumber(b);
      } else {
        if ("string" === typeof b) {
          b = a.fromString(b);
        } else {
          if (!(b && b instanceof a)) {
            throw TypeError("Illegal value: " + b + " (not an integer or Long)");
          }
        }
      }
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    "number" === typeof b ? b = a.fromNumber(b, !1) : "string" === typeof b ? b = a.fromString(b, !1) : !1 !== b.unsigned && (b = b.toSigned());
    var e = f.calculateVarint64(b), k = b.toInt() >>> 0, l = b.shiftRightUnsigned(28).toInt() >>> 0;
    b = b.shiftRightUnsigned(56).toInt() >>> 0;
    c += e;
    var g = this.buffer.byteLength;
    c > g && this.resize((g *= 2) > c ? g : c);
    c -= e;
    switch(e) {
      case 10:
        this.view[c + 9] = b >>> 7 & 1;
      case 9:
        this.view[c + 8] = 9 !== e ? b | 128 : b & 127;
      case 8:
        this.view[c + 7] = 8 !== e ? l >>> 21 | 128 : l >>> 21 & 127;
      case 7:
        this.view[c + 6] = 7 !== e ? l >>> 14 | 128 : l >>> 14 & 127;
      case 6:
        this.view[c + 5] = 6 !== e ? l >>> 7 | 128 : l >>> 7 & 127;
      case 5:
        this.view[c + 4] = 5 !== e ? l | 128 : l & 127;
      case 4:
        this.view[c + 3] = 4 !== e ? k >>> 21 | 128 : k >>> 21 & 127;
      case 3:
        this.view[c + 2] = 3 !== e ? k >>> 14 | 128 : k >>> 14 & 127;
      case 2:
        this.view[c + 1] = 2 !== e ? k >>> 7 | 128 : k >>> 7 & 127;
      case 1:
        this.view[c] = 1 !== e ? k | 128 : k & 127;
    }
    return d ? (this.offset += e, this) : e;
  }, k.writeVarint64ZigZag = function(a, b) {
    return this.writeVarint64(f.zigZagEncode64(a), b);
  }, k.readVarint64 = function(b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 1 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+1) <= " + this.buffer.byteLength);
      }
    }
    var c = b, f = 0, e = 0;
    var k = this.view[b++];
    var g = k & 127;
    if (k & 128 && (k = this.view[b++], g |= (k & 127) << 7, k & 128 || this.noAssert && "undefined" === typeof k) && (k = this.view[b++], g |= (k & 127) << 14, k & 128 || this.noAssert && "undefined" === typeof k) && (k = this.view[b++], g |= (k & 127) << 21, k & 128 || this.noAssert && "undefined" === typeof k) && (k = this.view[b++], f = k & 127, k & 128 || this.noAssert && "undefined" === typeof k) && (k = this.view[b++], f |= (k & 127) << 7, k & 128 || this.noAssert && "undefined" === typeof k) && 
    (k = this.view[b++], f |= (k & 127) << 14, k & 128 || this.noAssert && "undefined" === typeof k) && (k = this.view[b++], f |= (k & 127) << 21, k & 128 || this.noAssert && "undefined" === typeof k) && (k = this.view[b++], e = k & 127, k & 128 || this.noAssert && "undefined" === typeof k) && (k = this.view[b++], e |= (k & 127) << 7, k & 128 || this.noAssert && "undefined" === typeof k)) {
      throw Error("Buffer overrun");
    }
    g = a.fromBits(g | f << 28, f >>> 4 | e << 24, !1);
    return d ? (this.offset = b, g) : {value:g, length:b - c};
  }, k.readVarint64ZigZag = function(b) {
    (b = this.readVarint64(b)) && b.value instanceof a ? b.value = f.zigZagDecode64(b.value) : b = f.zigZagDecode64(b);
    return b;
  });
  k.writeCString = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    var f, e = a.length;
    if (!this.noAssert) {
      if ("string" !== typeof a) {
        throw TypeError("Illegal str: Not a string");
      }
      for (f = 0; f < e; ++f) {
        if (0 === a.charCodeAt(f)) {
          throw RangeError("Illegal str: Contains NULL-characters");
        }
      }
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
      }
    }
    e = t.calculateUTF16asUTF8(c(a))[1];
    b += e + 1;
    f = this.buffer.byteLength;
    b > f && this.resize((f *= 2) > b ? f : b);
    b -= e + 1;
    t.encodeUTF16toUTF8(c(a), function(a) {
      this.view[b++] = a;
    }.bind(this));
    this.view[b++] = 0;
    return d ? (this.offset = b, this) : e;
  };
  k.readCString = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 1 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
      }
    }
    var d = a, c, f = -1;
    t.decodeUTF8toUTF16(function() {
      if (0 === f) {
        return null;
      }
      if (a >= this.limit) {
        throw RangeError("Illegal range: Truncated data, " + a + " < " + this.limit);
      }
      f = this.view[a++];
      return 0 === f ? null : f;
    }.bind(this), c = g(), !0);
    return b ? (this.offset = a, c()) : {string:c(), length:a - d};
  };
  k.writeIString = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("string" !== typeof a) {
        throw TypeError("Illegal str: Not a string");
      }
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
      }
    }
    var f = b;
    var e = t.calculateUTF16asUTF8(c(a), this.noAssert)[1];
    b += 4 + e;
    var k = this.buffer.byteLength;
    b > k && this.resize((k *= 2) > b ? k : b);
    b -= 4 + e;
    this.littleEndian ? (this.view[b + 3] = e >>> 24 & 255, this.view[b + 2] = e >>> 16 & 255, this.view[b + 1] = e >>> 8 & 255, this.view[b] = e & 255) : (this.view[b] = e >>> 24 & 255, this.view[b + 1] = e >>> 16 & 255, this.view[b + 2] = e >>> 8 & 255, this.view[b + 3] = e & 255);
    b += 4;
    t.encodeUTF16toUTF8(c(a), function(a) {
      this.view[b++] = a;
    }.bind(this));
    if (b !== f + 4 + e) {
      throw RangeError("Illegal range: Truncated data, " + b + " == " + (b + 4 + e));
    }
    return d ? (this.offset = b, this) : b - f;
  };
  k.readIString = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 4 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
      }
    }
    var c = a, d = this.readUint32(a);
    d = this.readUTF8String(d, f.METRICS_BYTES, a += 4);
    a += d.length;
    return b ? (this.offset = a, d.string) : {string:d.string, length:a - c};
  };
  f.METRICS_CHARS = "c";
  f.METRICS_BYTES = "b";
  k.writeUTF8String = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
      }
    }
    var f = b;
    var e = t.calculateUTF16asUTF8(c(a))[1];
    b += e;
    var k = this.buffer.byteLength;
    b > k && this.resize((k *= 2) > b ? k : b);
    b -= e;
    t.encodeUTF16toUTF8(c(a), function(a) {
      this.view[b++] = a;
    }.bind(this));
    return d ? (this.offset = b, this) : b - f;
  };
  k.writeString = k.writeUTF8String;
  f.calculateUTF8Chars = function(a) {
    return t.calculateUTF16asUTF8(c(a))[0];
  };
  f.calculateUTF8Bytes = function(a) {
    return t.calculateUTF16asUTF8(c(a))[1];
  };
  f.calculateString = f.calculateUTF8Bytes;
  k.readUTF8String = function(a, b, c) {
    "number" === typeof b && (c = b, b = void 0);
    var d = "undefined" === typeof c;
    d && (c = this.offset);
    "undefined" === typeof b && (b = f.METRICS_CHARS);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal length: " + a + " (not an integer)");
      }
      a |= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    var e = 0, k = c;
    if (b === f.METRICS_CHARS) {
      var l = g();
      t.decodeUTF8(function() {
        return e < a && c < this.limit ? this.view[c++] : null;
      }.bind(this), function(a) {
        ++e;
        t.UTF8toUTF16(a, l);
      });
      if (e !== a) {
        throw RangeError("Illegal range: Truncated data, " + e + " == " + a);
      }
      return d ? (this.offset = c, l()) : {string:l(), length:c - k};
    }
    if (b === f.METRICS_BYTES) {
      if (!this.noAssert) {
        if ("number" !== typeof c || 0 !== c % 1) {
          throw TypeError("Illegal offset: " + c + " (not an integer)");
        }
        c >>>= 0;
        if (0 > c || c + a > this.buffer.byteLength) {
          throw RangeError("Illegal offset: 0 <= " + c + " (+" + a + ") <= " + this.buffer.byteLength);
        }
      }
      var m = c + a;
      t.decodeUTF8toUTF16(function() {
        return c < m ? this.view[c++] : null;
      }.bind(this), l = g(), this.noAssert);
      if (c !== m) {
        throw RangeError("Illegal range: Truncated data, " + c + " == " + m);
      }
      return d ? (this.offset = c, l()) : {string:l(), length:c - k};
    }
    throw TypeError("Unsupported metrics: " + b);
  };
  k.readString = k.readUTF8String;
  k.writeVString = function(a, b) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    if (!this.noAssert) {
      if ("string" !== typeof a) {
        throw TypeError("Illegal str: Not a string");
      }
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: " + b + " (not an integer)");
      }
      b >>>= 0;
      if (0 > b || b + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
      }
    }
    var e = b;
    var k = t.calculateUTF16asUTF8(c(a), this.noAssert)[1];
    var l = f.calculateVarint32(k);
    b += l + k;
    var g = this.buffer.byteLength;
    b > g && this.resize((g *= 2) > b ? g : b);
    b -= l + k;
    b += this.writeVarint32(k, b);
    t.encodeUTF16toUTF8(c(a), function(a) {
      this.view[b++] = a;
    }.bind(this));
    if (b !== e + k + l) {
      throw RangeError("Illegal range: Truncated data, " + b + " == " + (b + k + l));
    }
    return d ? (this.offset = b, this) : b - e;
  };
  k.readVString = function(a) {
    var b = "undefined" === typeof a;
    b && (a = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 1 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
      }
    }
    var c = a, d = this.readVarint32(a);
    d = this.readUTF8String(d.value, f.METRICS_BYTES, a += d.length);
    a += d.length;
    return b ? (this.offset = a, d.string) : {string:d.string, length:a - c};
  };
  k.append = function(a, b, c) {
    if ("number" === typeof b || "string" !== typeof b) {
      c = b, b = void 0;
    }
    var d = "undefined" === typeof c;
    d && (c = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    a instanceof f || (a = f.wrap(a, b));
    b = a.limit - a.offset;
    if (0 >= b) {
      return this;
    }
    c += b;
    var e = this.buffer.byteLength;
    c > e && this.resize((e *= 2) > c ? e : c);
    c -= b;
    this.view.set(a.view.subarray(a.offset, a.limit), c);
    a.offset += b;
    d && (this.offset += b);
    return this;
  };
  k.appendTo = function(a, b) {
    a.append(this, b);
    return this;
  };
  k.assert = function(a) {
    this.noAssert = !a;
    return this;
  };
  k.capacity = function() {
    return this.buffer.byteLength;
  };
  k.clear = function() {
    this.offset = 0;
    this.limit = this.buffer.byteLength;
    this.markedOffset = -1;
    return this;
  };
  k.clone = function(a) {
    var b = new f(0, this.littleEndian, this.noAssert);
    a ? (b.buffer = new ArrayBuffer(this.buffer.byteLength), b.view = new Uint8Array(b.buffer)) : (b.buffer = this.buffer, b.view = this.view);
    b.offset = this.offset;
    b.markedOffset = this.markedOffset;
    b.limit = this.limit;
    return b;
  };
  k.compact = function(a, b) {
    "undefined" === typeof a && (a = this.offset);
    "undefined" === typeof b && (b = this.limit);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal begin: Not an integer");
      }
      a >>>= 0;
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal end: Not an integer");
      }
      b >>>= 0;
      if (0 > a || a > b || b > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
      }
    }
    if (0 === a && b === this.buffer.byteLength) {
      return this;
    }
    var c = b - a;
    if (0 === c) {
      return this.buffer = n, this.view = null, 0 <= this.markedOffset && (this.markedOffset -= a), this.limit = this.offset = 0, this;
    }
    var d = new ArrayBuffer(c), f = new Uint8Array(d);
    f.set(this.view.subarray(a, b));
    this.buffer = d;
    this.view = f;
    0 <= this.markedOffset && (this.markedOffset -= a);
    this.offset = 0;
    this.limit = c;
    return this;
  };
  k.copy = function(a, b) {
    "undefined" === typeof a && (a = this.offset);
    "undefined" === typeof b && (b = this.limit);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal begin: Not an integer");
      }
      a >>>= 0;
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal end: Not an integer");
      }
      b >>>= 0;
      if (0 > a || a > b || b > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
      }
    }
    if (a === b) {
      return new f(0, this.littleEndian, this.noAssert);
    }
    var c = b - a, d = new f(c, this.littleEndian, this.noAssert);
    d.offset = 0;
    d.limit = c;
    0 <= d.markedOffset && (d.markedOffset -= a);
    this.copyTo(d, 0, a, b);
    return d;
  };
  k.copyTo = function(a, b, c, e) {
    var d, k;
    if (!this.noAssert && !f.isByteBuffer(a)) {
      throw TypeError("Illegal target: Not a ByteBuffer");
    }
    b = (k = "undefined" === typeof b) ? a.offset : b | 0;
    c = (d = "undefined" === typeof c) ? this.offset : c | 0;
    e = "undefined" === typeof e ? this.limit : e | 0;
    if (0 > b || b > a.buffer.byteLength) {
      throw RangeError("Illegal target range: 0 <= " + b + " <= " + a.buffer.byteLength);
    }
    if (0 > c || e > this.buffer.byteLength) {
      throw RangeError("Illegal source range: 0 <= " + c + " <= " + this.buffer.byteLength);
    }
    var l = e - c;
    if (0 === l) {
      return a;
    }
    a.ensureCapacity(b + l);
    a.view.set(this.view.subarray(c, e), b);
    d && (this.offset += l);
    k && (a.offset += l);
    return this;
  };
  k.ensureCapacity = function(a) {
    var b = this.buffer.byteLength;
    return b < a ? this.resize((b *= 2) > a ? b : a) : this;
  };
  k.fill = function(a, b, c) {
    var d = "undefined" === typeof b;
    d && (b = this.offset);
    "string" === typeof a && 0 < a.length && (a = a.charCodeAt(0));
    "undefined" === typeof b && (b = this.offset);
    "undefined" === typeof c && (c = this.limit);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal value: " + a + " (not an integer)");
      }
      a |= 0;
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal begin: Not an integer");
      }
      b >>>= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal end: Not an integer");
      }
      c >>>= 0;
      if (0 > b || b > c || c > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + b + " <= " + c + " <= " + this.buffer.byteLength);
      }
    }
    if (b >= c) {
      return this;
    }
    for (; b < c;) {
      this.view[b++] = a;
    }
    d && (this.offset = b);
    return this;
  };
  k.flip = function() {
    this.limit = this.offset;
    this.offset = 0;
    return this;
  };
  k.mark = function(a) {
    a = "undefined" === typeof a ? this.offset : a;
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal offset: " + a + " (not an integer)");
      }
      a >>>= 0;
      if (0 > a || a + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + a + " (+0) <= " + this.buffer.byteLength);
      }
    }
    this.markedOffset = a;
    return this;
  };
  k.order = function(a) {
    if (!this.noAssert && "boolean" !== typeof a) {
      throw TypeError("Illegal littleEndian: Not a boolean");
    }
    this.littleEndian = !!a;
    return this;
  };
  k.LE = function(a) {
    this.littleEndian = "undefined" !== typeof a ? !!a : !0;
    return this;
  };
  k.BE = function(a) {
    this.littleEndian = "undefined" !== typeof a ? !a : !1;
    return this;
  };
  k.prepend = function(a, b, c) {
    if ("number" === typeof b || "string" !== typeof b) {
      c = b, b = void 0;
    }
    var d = "undefined" === typeof c;
    d && (c = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal offset: " + c + " (not an integer)");
      }
      c >>>= 0;
      if (0 > c || c + 0 > this.buffer.byteLength) {
        throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
      }
    }
    a instanceof f || (a = f.wrap(a, b));
    b = a.limit - a.offset;
    if (0 >= b) {
      return this;
    }
    var e = b - c;
    if (0 < e) {
      var k = new ArrayBuffer(this.buffer.byteLength + e), l = new Uint8Array(k);
      l.set(this.view.subarray(c, this.buffer.byteLength), b);
      this.buffer = k;
      this.view = l;
      this.offset += e;
      0 <= this.markedOffset && (this.markedOffset += e);
      this.limit += e;
      c += e;
    } else {
      new Uint8Array(this.buffer);
    }
    this.view.set(a.view.subarray(a.offset, a.limit), c - b);
    a.offset = a.limit;
    d && (this.offset -= b);
    return this;
  };
  k.prependTo = function(a, b) {
    a.prepend(this, b);
    return this;
  };
  k.printDebug = function(a) {
    "function" !== typeof a && (a = console.log.bind(console));
    a(this.toString() + "\n-------------------------------------------------------------------\n" + this.toDebug(!0));
  };
  k.remaining = function() {
    return this.limit - this.offset;
  };
  k.reset = function() {
    0 <= this.markedOffset ? (this.offset = this.markedOffset, this.markedOffset = -1) : this.offset = 0;
    return this;
  };
  k.resize = function(a) {
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal capacity: " + a + " (not an integer)");
      }
      a |= 0;
      if (0 > a) {
        throw RangeError("Illegal capacity: 0 <= " + a);
      }
    }
    if (this.buffer.byteLength < a) {
      a = new ArrayBuffer(a);
      var b = new Uint8Array(a);
      b.set(this.view);
      this.buffer = a;
      this.view = b;
    }
    return this;
  };
  k.reverse = function(a, b) {
    "undefined" === typeof a && (a = this.offset);
    "undefined" === typeof b && (b = this.limit);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal begin: Not an integer");
      }
      a >>>= 0;
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal end: Not an integer");
      }
      b >>>= 0;
      if (0 > a || a > b || b > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
      }
    }
    if (a === b) {
      return this;
    }
    Array.prototype.reverse.call(this.view.subarray(a, b));
    return this;
  };
  k.skip = function(a) {
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal length: " + a + " (not an integer)");
      }
      a |= 0;
    }
    var b = this.offset + a;
    if (!this.noAssert && (0 > b || b > this.buffer.byteLength)) {
      throw RangeError("Illegal length: 0 <= " + this.offset + " + " + a + " <= " + this.buffer.byteLength);
    }
    this.offset = b;
    return this;
  };
  k.slice = function(a, b) {
    "undefined" === typeof a && (a = this.offset);
    "undefined" === typeof b && (b = this.limit);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal begin: Not an integer");
      }
      a >>>= 0;
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal end: Not an integer");
      }
      b >>>= 0;
      if (0 > a || a > b || b > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
      }
    }
    var c = this.clone();
    c.offset = a;
    c.limit = b;
    return c;
  };
  k.toBuffer = function(a) {
    var b = this.offset, c = this.limit;
    if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal offset: Not an integer");
      }
      b >>>= 0;
      if ("number" !== typeof c || 0 !== c % 1) {
        throw TypeError("Illegal limit: Not an integer");
      }
      c >>>= 0;
      if (0 > b || b > c || c > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + b + " <= " + c + " <= " + this.buffer.byteLength);
      }
    }
    if (!a && 0 === b && c === this.buffer.byteLength) {
      return this.buffer;
    }
    if (b === c) {
      return n;
    }
    a = new ArrayBuffer(c - b);
    (new Uint8Array(a)).set((new Uint8Array(this.buffer)).subarray(b, c), 0);
    return a;
  };
  k.toArrayBuffer = k.toBuffer;
  k.toString = function(a, b, c) {
    if ("undefined" === typeof a) {
      return "ByteBufferAB(offset=" + this.offset + ",markedOffset=" + this.markedOffset + ",limit=" + this.limit + ",capacity=" + this.capacity() + ")";
    }
    "number" === typeof a && (c = b = a = "utf8");
    switch(a) {
      case "utf8":
        return this.toUTF8(b, c);
      case "base64":
        return this.toBase64(b, c);
      case "hex":
        return this.toHex(b, c);
      case "binary":
        return this.toBinary(b, c);
      case "debug":
        return this.toDebug();
      case "columns":
        return this.toColumns();
      default:
        throw Error("Unsupported encoding: " + a);
    }
  };
  var m = function() {
    for (var a = {}, b = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47], c = [], f = 0, e = b.length; f < e; ++f) {
      c[b[f]] = f;
    }
    a.encode = function(a, c) {
      for (var d, f; null !== (d = a());) {
        c(b[d >> 2 & 63]), f = (d & 3) << 4, null !== (d = a()) ? (f |= d >> 4 & 15, c(b[(f | d >> 4 & 15) & 63]), f = (d & 15) << 2, null !== (d = a()) ? (c(b[(f | d >> 6 & 3) & 63]), c(b[d & 63])) : (c(b[f & 63]), c(61))) : (c(b[f & 63]), c(61), c(61));
      }
    };
    a.decode = function(a, b) {
      function d(a) {
        throw Error("Illegal character code: " + a);
      }
      for (var f, e, k; null !== (f = a());) {
        if (e = c[f], "undefined" === typeof e && d(f), null !== (f = a()) && (k = c[f], "undefined" === typeof k && d(f), b(e << 2 >>> 0 | (k & 48) >> 4), null !== (f = a()))) {
          e = c[f];
          if ("undefined" === typeof e) {
            if (61 === f) {
              break;
            } else {
              d(f);
            }
          }
          b((k & 15) << 4 >>> 0 | (e & 60) >> 2);
          if (null !== (f = a())) {
            k = c[f];
            if ("undefined" === typeof k) {
              if (61 === f) {
                break;
              } else {
                d(f);
              }
            }
            b((e & 3) << 6 >>> 0 | k);
          }
        }
      }
    };
    a.test = function(a) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(a);
    };
    return a;
  }();
  k.toBase64 = function(a, b) {
    "undefined" === typeof a && (a = this.offset);
    "undefined" === typeof b && (b = this.limit);
    a |= 0;
    b |= 0;
    if (0 > a || b > this.capacity || a > b) {
      throw RangeError("begin, end");
    }
    var c;
    m.encode(function() {
      return a < b ? this.view[a++] : null;
    }.bind(this), c = g());
    return c();
  };
  f.fromBase64 = function(a, b) {
    if ("string" !== typeof a) {
      throw TypeError("str");
    }
    var d = new f(a.length / 4 * 3, b), e = 0;
    m.decode(c(a), function(a) {
      d.view[e++] = a;
    });
    d.limit = e;
    return d;
  };
  f.btoa = function(a) {
    return f.fromBinary(a).toBase64();
  };
  f.atob = function(a) {
    return f.fromBase64(a).toBinary();
  };
  k.toBinary = function(a, b) {
    "undefined" === typeof a && (a = this.offset);
    "undefined" === typeof b && (b = this.limit);
    a |= 0;
    b |= 0;
    if (0 > a || b > this.capacity() || a > b) {
      throw RangeError("begin, end");
    }
    if (a === b) {
      return "";
    }
    for (var c = [], d = []; a < b;) {
      c.push(this.view[a++]), 1024 <= c.length && (d.push(String.fromCharCode.apply(String, c)), c = []);
    }
    return d.join("") + String.fromCharCode.apply(String, c);
  };
  f.fromBinary = function(a, b) {
    if ("string" !== typeof a) {
      throw TypeError("str");
    }
    for (var c = 0, d = a.length, e = new f(d, b); c < d;) {
      b = a.charCodeAt(c);
      if (255 < b) {
        throw RangeError("illegal char code: " + b);
      }
      e.view[c++] = b;
    }
    e.limit = d;
    return e;
  };
  k.toDebug = function(a) {
    for (var b = -1, c = this.buffer.byteLength, d, f = "", e = "", k = ""; b < c;) {
      -1 !== b && (d = this.view[b], f = 16 > d ? f + ("0" + d.toString(16).toUpperCase()) : f + d.toString(16).toUpperCase(), a && (e += 32 < d && 127 > d ? String.fromCharCode(d) : "."));
      ++b;
      if (a && 0 < b && 0 === b % 16 && b !== c) {
        for (; 51 > f.length;) {
          f += " ";
        }
        k += f + e + "\n";
        f = e = "";
      }
      f = b === this.offset && b === this.limit ? f + (b === this.markedOffset ? "!" : "|") : b === this.offset ? f + (b === this.markedOffset ? "[" : "<") : b === this.limit ? f + (b === this.markedOffset ? "]" : ">") : f + (b === this.markedOffset ? "'" : a || 0 !== b && b !== c ? " " : "");
    }
    if (a && " " !== f) {
      for (; 51 > f.length;) {
        f += " ";
      }
      k += f + e + "\n";
    }
    return a ? k : f;
  };
  f.fromDebug = function(a, b, c) {
    var d = a.length;
    b = new f((d + 1) / 3 | 0, b, c);
    for (var e = 0, k = 0, g, l = !1, m = !1, n = !1, t = !1, p = !1; e < d;) {
      switch(g = a.charAt(e++)) {
        case "!":
          if (!c) {
            if (m || n || t) {
              p = !0;
              break;
            }
            m = n = t = !0;
          }
          b.offset = b.markedOffset = b.limit = k;
          l = !1;
          break;
        case "|":
          if (!c) {
            if (m || t) {
              p = !0;
              break;
            }
            m = t = !0;
          }
          b.offset = b.limit = k;
          l = !1;
          break;
        case "[":
          if (!c) {
            if (m || n) {
              p = !0;
              break;
            }
            m = n = !0;
          }
          b.offset = b.markedOffset = k;
          l = !1;
          break;
        case "<":
          if (!c) {
            if (m) {
              p = !0;
              break;
            }
            m = !0;
          }
          b.offset = k;
          l = !1;
          break;
        case "]":
          if (!c) {
            if (t || n) {
              p = !0;
              break;
            }
            t = n = !0;
          }
          b.limit = b.markedOffset = k;
          l = !1;
          break;
        case ">":
          if (!c) {
            if (t) {
              p = !0;
              break;
            }
            t = ! 0;
          }
          b.limit = k;
          l = !1;
          break;
        case "'":
          if (!c) {
            if (n) {
              p = !0;
              break;
            }
            n = !0;
          }
          b.markedOffset = k;
          l = !1;
          break;
        case " ":
          l = !1;
          break;
        default:
          if (!c && l) {
            p = !0;
          } else {
            g = parseInt(g + a.charAt(e++), 16);
            if (!c && (isNaN(g) || 0 > g || 255 < g)) {
              throw TypeError("Illegal str: Not a debug encoded string");
            }
            b.view[k++] = g;
            l = !0;
          }
      }
      if (p) {
        throw TypeError("Illegal str: Invalid symbol at " + e);
      }
    }
    if (!c) {
      if (!m || !t) {
        throw TypeError("Illegal str: Missing offset or limit");
      }
      if (k < b.buffer.byteLength) {
        throw TypeError("Illegal str: Not a debug encoded string (is it hex?) " + k + " < " + d);
      }
    }
    return b;
  };
  k.toHex = function(a, b) {
    a = "undefined" === typeof a ? this.offset : a;
    b = "undefined" === typeof b ? this.limit : b;
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal begin: Not an integer");
      }
      a >>>= 0;
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal end: Not an integer");
      }
      b >>>= 0;
      if (0 > a || a > b || b > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
      }
    }
    for (var c = Array(b - a), d; a < b;) {
      d = this.view[a++], 16 > d ? c.push("0", d.toString(16)) : c.push(d.toString(16));
    }
    return c.join("");
  };
  f.fromHex = function(a, b, c) {
    if (!c) {
      if ("string" !== typeof a) {
        throw TypeError("Illegal str: Not a string");
      }
      if (0 !== a.length % 2) {
        throw TypeError("Illegal str: Length not a multiple of 2");
      }
    }
    var d = a.length;
    b = new f(d / 2 | 0, b);
    for (var e, k = 0, g = 0; k < d; k += 2) {
      e = parseInt(a.substring(k, k + 2), 16);
      if (!c && (!isFinite(e) || 0 > e || 255 < e)) {
        throw TypeError("Illegal str: Contains non-hex characters");
      }
      b.view[g++] = e;
    }
    b.limit = g;
    return b;
  };
  var t = function() {
    var a = {MAX_CODEPOINT:1114111, encodeUTF8:function(a, b) {
      var c = null;
      for ("number" === typeof a && (c = a, a = function() {
        return null;
      }); null !== c || null !== (c = a());) {
        128 > c ? b(c & 127) : (2048 > c ? b(c >> 6 & 31 | 192) : (65536 > c ? b(c >> 12 & 15 | 224) : (b(c >> 18 & 7 | 240), b(c >> 12 & 63 | 128)), b(c >> 6 & 63 | 128)), b(c & 63 | 128)), c = null;
      }
    }, decodeUTF8:function(a, b) {
      for (var c, d, f, e, k = function(a) {
        a = a.slice(0, a.indexOf(null));
        var b = Error(a.toString());
        b.name = "TruncatedError";
        b.bytes = a;
        throw b;
      }; null !== (c = a());) {
        if (0 === (c & 128)) {
          b(c);
        } else {
          if (192 === (c & 224)) {
            null === (d = a()) && k([c, d]), b((c & 31) << 6 | d & 63);
          } else {
            if (224 === (c & 240)) {
              null !== (d = a()) && null !== (f = a()) || k([c, d, f]), b((c & 15) << 12 | (d & 63) << 6 | f & 63);
            } else {
              if (240 === (c & 248)) {
                null !== (d = a()) && null !== (f = a()) && null !== (e = a()) || k([c, d, f, e]), b((c & 7) << 18 | (d & 63) << 12 | (f & 63) << 6 | e & 63);
              } else {
                throw RangeError("Illegal starting byte: " + c);
              }
            }
          }
        }
      }
    }, UTF16toUTF8:function(a, b) {
      for (var c, d = null; null !== (c = null !== d ? d : a());) {
        55296 <= c && 57343 >= c && null !== (d = a()) && 56320 <= d && 57343 >= d ? (b(1024 * (c - 55296) + d - 56320 + 65536), d = null) : b(c);
      }
      null !== d && b(d);
    }, UTF8toUTF16:function(a, b) {
      var c = null;
      for ("number" === typeof a && (c = a, a = function() {
        return null;
      }); null !== c || null !== (c = a());) {
        65535 >= c ? b(c) : (c -= 65536, b((c >> 10) + 55296), b(c % 1024 + 56320)), c = null;
      }
    }, encodeUTF16toUTF8:function(b, c) {
      a.UTF16toUTF8(b, function(b) {
        a.encodeUTF8(b, c);
      });
    }, decodeUTF8toUTF16:function(b, c) {
      a.decodeUTF8(b, function(b) {
        a.UTF8toUTF16(b, c);
      });
    }, calculateCodePoint:function(a) {
      return 128 > a ? 1 : 2048 > a ? 2 : 65536 > a ? 3 : 4;
    }, calculateUTF8:function(a) {
      for (var b, c = 0; null !== (b = a());) {
        c += 128 > b ? 1 : 2048 > b ? 2 : 65536 > b ? 3 : 4;
      }
      return c;
    }, calculateUTF16asUTF8:function(b) {
      var c = 0, d = 0;
      a.UTF16toUTF8(b, function(a) {
        ++c;
        d += 128 > a ? 1 : 2048 > a ? 2 : 65536 > a ? 3 : 4;
      });
      return [c, d];
    }};
    return a;
  }();
  k.toUTF8 = function(a, b) {
    "undefined" === typeof a && (a = this.offset);
    "undefined" === typeof b && (b = this.limit);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) {
        throw TypeError("Illegal begin: Not an integer");
      }
      a >>>= 0;
      if ("number" !== typeof b || 0 !== b % 1) {
        throw TypeError("Illegal end: Not an integer");
      }
      b >>>= 0;
      if (0 > a || a > b || b > this.buffer.byteLength) {
        throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
      }
    }
    var c;
    try {
      t.decodeUTF8toUTF16(function() {
        return a < b ? this.view[a++] : null;
      }.bind(this), c = g());
    } catch (w) {
      if (a !== b) {
        throw RangeError("Illegal range: Truncated data, " + a + " != " + b);
      }
    }
    return c();
  };
  f.fromUTF8 = function(a, b, e) {
    if (!e && "string" !== typeof a) {
      throw TypeError("Illegal str: Not a string");
    }
    var d = new f(t.calculateUTF16asUTF8(c(a), !0)[1], b, e), k = 0;
    t.encodeUTF16toUTF8(c(a), function(a) {
      d.view[k++] = a;
    });
    d.limit = k;
    return d;
  };
  return f;
});
(function(a, c) {
  "function" === typeof define && define.amd ? define([], c) : "function" === typeof require && "object" === typeof module && module && module.exports ? module.exports = c() : (a.dcodeIO = a.dcodeIO || {}).Long = c();
})(this, function() {
  function a(a, b, c) {
    this.low = a | 0;
    this.high = b | 0;
    this.unsigned = !!c;
  }
  function c(a) {
    return !0 === (a && a.__isLong__);
  }
  function g(a, b) {
    var c;
    if (b) {
      a >>>= 0;
      if (c = 0 <= a && 256 > a) {
        if (b = p[a]) {
          return b;
        }
      }
      b = e(a, 0 > (a | 0) ? -1 : 0, !0);
      c && (p[a] = b);
    } else {
      a |= 0;
      if (c = -128 <= a && 128 > a) {
        if (b = n[a]) {
          return b;
        }
      }
      b = e(a, 0 > a ? -1 : 0, !1);
      c && (n[a] = b);
    }
    return b;
  }
  function b(a, c) {
    if (isNaN(a) || !isFinite(a)) {
      return c ? w : u;
    }
    if (c) {
      if (0 > a) {
        return w;
      }
      if (a >= t) {
        return z;
      }
    } else {
      if (a <= -d) {
        return C;
      }
      if (a + 1 >= d) {
        return v;
      }
    }
    return 0 > a ? b(-a, c).neg() : e(a % 4294967296 | 0, a / 4294967296 | 0, c);
  }
  function e(b, c, d) {
    return new a(b, c, d);
  }
  function f(a, c, d) {
    if (0 === a.length) {
      throw Error("empty string");
    }
    if ("NaN" === a || "Infinity" === a || "+Infinity" === a || "-Infinity" === a) {
      return u;
    }
    "number" === typeof c ? (d = c, c = !1) : c = !!c;
    d = d || 10;
    if (2 > d || 36 < d) {
      throw RangeError("radix");
    }
    var e;
    if (0 < (e = a.indexOf("-"))) {
      throw Error("interior hyphen");
    }
    if (0 === e) {
      return f(a.substring(1), c, d).neg();
    }
    e = b(m(d, 8));
    for (var k = u, g = 0; g < a.length; g += 8) {
      var l = Math.min(8, a.length - g), q = parseInt(a.substring(g, g + l), d);
      8 > l ? (l = b(m(d, l)), k = k.mul(l).add(b(q))) : (k = k.mul(e), k = k.add(b(q)));
    }
    k.unsigned = c;
    return k;
  }
  function k(c) {
    return c instanceof a ? c : "number" === typeof c ? b(c) : "string" === typeof c ? f(c) : e(c.low, c.high, c.unsigned);
  }
  Object.defineProperty(a.prototype, "__isLong__", {value:!0, enumerable:!1, configurable:!1});
  a.isLong = c;
  var n = {}, p = {};
  a.fromInt = g;
  a.fromNumber = b;
  a.fromBits = e;
  var m = Math.pow;
  a.fromString = f;
  a.fromValue = k;
  var t = 4294967296 * 4294967296, d = t / 2, l = g(16777216), u = g(0);
  a.ZERO = u;
  var w = g(0, !0);
  a.UZERO = w;
  var y = g(1);
  a.ONE = y;
  var x = g(1, !0);
  a.UONE = x;
  var q = g(-1);
  a.NEG_ONE = q;
  var v = e(-1, 2147483647, !1);
  a.MAX_VALUE = v;
  var z = e(-1, -1, !0);
  a.MAX_UNSIGNED_VALUE = z;
  var C = e(0, -2147483648, !1);
  a.MIN_VALUE = C;
  var A = a.prototype;
  A.toInt = function() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  A.toNumber = function() {
    return this.unsigned ? 4294967296 * (this.high >>> 0) + (this.low >>> 0) : 4294967296 * this.high + (this.low >>> 0);
  };
  A.toString = function(a) {
    a = a || 10;
    if (2 > a || 36 < a) {
      throw RangeError("radix");
    }
    if (this.isZero()) {
      return "0";
    }
    if (this.isNegative()) {
      if (this.eq(C)) {
        var c = b(a), d = this.div(c);
        c = d.mul(c).sub(this);
        return d.toString(a) + c.toInt().toString(a);
      }
      return "-" + this.neg().toString(a);
    }
    d = b(m(a, 6), this.unsigned);
    c = this;
    for (var f = "";;) {
      var e = c.div(d), k = (c.sub(e.mul(d)).toInt() >>> 0).toString(a);
      c = e;
      if (c.isZero()) {
        return k + f;
      }
      for (; 6 > k.length;) {
        k = "0" + k;
      }
      f = "" + k + f;
    }
  };
  A.getHighBits = function() {
    return this.high;
  };
  A.getHighBitsUnsigned = function() {
    return this.high >>> 0;
  };
  A.getLowBits = function() {
    return this.low;
  };
  A.getLowBitsUnsigned = function() {
    return this.low >>> 0;
  };
  A.getNumBitsAbs = function() {
    if (this.isNegative()) {
      return this.eq(C) ? 64 : this.neg().getNumBitsAbs();
    }
    for (var a = 0 != this.high ? this.high : this.low, b = 31; 0 < b && 0 == (a & 1 << b); b--) {
    }
    return 0 != this.high ? b + 33 : b + 1;
  };
  A.isZero = function() {
    return 0 === this.high && 0 === this.low;
  };
  A.isNegative = function() {
    return !this.unsigned && 0 > this.high;
  };
  A.isPositive = function() {
    return this.unsigned || 0 <= this.high;
  };
  A.isOdd = function() {
    return 1 === (this.low & 1);
  };
  A.isEven = function() {
    return 0 === (this.low & 1);
  };
  A.equals = function(a) {
    c(a) || (a = k(a));
    return this.unsigned !== a.unsigned && 1 === this.high >>> 31 && 1 === a.high >>> 31 ? !1 : this.high === a.high && this.low === a.low;
  };
  A.eq = A.equals;
  A.notEquals = function(a) {
    return !this.eq(a);
  };
  A.neq = A.notEquals;
  A.lessThan = function(a) {
    return 0 > this.comp(a);
  };
  A.lt = A.lessThan;
  A.lessThanOrEqual = function(a) {
    return 0 >= this.comp(a);
  };
  A.lte = A.lessThanOrEqual;
  A.greaterThan = function(a) {
    return 0 < this.comp(a);
  };
  A.gt = A.greaterThan;
  A.greaterThanOrEqual = function(a) {
    return 0 <= this.comp(a);
  };
  A.gte = A.greaterThanOrEqual;
  A.compare = function(a) {
    c(a) || (a = k(a));
    if (this.eq(a)) {
      return 0;
    }
    var b = this.isNegative(), d = a.isNegative();
    return b && !d ? -1 : !b && d ? 1 : this.unsigned ? a.high >>> 0 > this.high >>> 0 || a.high === this.high && a.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(a).isNegative() ? -1 : 1;
  };
  A.comp = A.compare;
  A.negate = function() {
    return !this.unsigned && this.eq(C) ? C : this.not().add(y);
  };
  A.neg = A.negate;
  A.add = function(a) {
    c(a) || (a = k(a));
    var b = this.high >>> 16, d = this.high & 65535, f = this.low >>> 16, g = a.high >>> 16, l = a.high & 65535, q = a.low >>> 16;
    var m = (this.low & 65535) + (a.low & 65535);
    a = (m >>> 16) + (f + q);
    f = (a >>> 16) + (d + l);
    d = (f >>> 16) + (b + g) & 65535;
    return e((a & 65535) << 16 | m & 65535, d << 16 | f & 65535, this.unsigned);
  };
  A.subtract = function(a) {
    c(a) || (a = k(a));
    return this.add(a.neg());
  };
  A.sub = A.subtract;
  A.multiply = function(a) {
    if (this.isZero()) {
      return u;
    }
    c(a) || (a = k(a));
    if (a.isZero()) {
      return u;
    }
    if (this.eq(C)) {
      return a.isOdd() ? C : u;
    }
    if (a.eq(C)) {
      return this.isOdd() ? C : u;
    }
    if (this.isNegative()) {
      return a.isNegative() ? this.neg().mul(a.neg()) : this.neg().mul(a).neg();
    }
    if (a.isNegative()) {
      return this.mul(a.neg()).neg();
    }
    if (this.lt(l) && a.lt(l)) {
      return b(this.toNumber() * a.toNumber(), this.unsigned);
    }
    var d = this.high >>> 16, f = this.high & 65535, g = this.low >>> 16, q = this.low & 65535, m = a.high >>> 16, n = a.high & 65535, t = a.low >>> 16;
    a = a.low & 65535;
    var p = q * a;
    var v = (p >>> 16) + g * a;
    var w = v >>> 16;
    v = (v & 65535) + q * t;
    w += v >>> 16;
    w += f * a;
    var z = w >>> 16;
    w = (w & 65535) + g * t;
    z += w >>> 16;
    w = (w & 65535) + q * n;
    return e((v & 65535) << 16 | p & 65535, (z + (w >>> 16) + (d * a + f * t + g * n + q * m) & 65535) << 16 | w & 65535, this.unsigned);
  };
  A.mul = A.multiply;
  A.divide = function(a) {
    c(a) || (a = k(a));
    if (a.isZero()) {
      throw Error("division by zero");
    }
    if (this.isZero()) {
      return this.unsigned ? w : u;
    }
    if (this.unsigned) {
      a.unsigned || (a = a.toUnsigned());
      if (a.gt(this)) {
        return w;
      }
      if (a.gt(this.shru(1))) {
        return x;
      }
      var d = w;
    } else {
      if (this.eq(C)) {
        if (a.eq(y) || a.eq(q)) {
          return C;
        }
        if (a.eq(C)) {
          return y;
        }
        var f = this.shr(1).div(a).shl(1);
        if (f.eq(u)) {
          return a.isNegative() ? y : q;
        }
        var e = this.sub(a.mul(f));
        return f.add(e.div(a));
      }
      if (a.eq(C)) {
        return this.unsigned ? w : u;
      }
      if (this.isNegative()) {
        return a.isNegative() ? this.neg().div(a.neg()) : this.neg().div(a).neg();
      }
      if (a.isNegative()) {
        return this.div(a.neg()).neg();
      }
      d = u;
    }
    for (e = this; e.gte(a);) {
      f = Math.max(1, Math.floor(e.toNumber() / a.toNumber()));
      var g = Math.ceil(Math.log(f) / Math.LN2);
      g = 48 >= g ? 1 : m(2, g - 48);
      for (var l = b(f), n = l.mul(a); n.isNegative() || n.gt(e);) {
        f -= g, l = b(f, this.unsigned), n = l.mul(a);
      }
      l.isZero() && (l = y);
      d = d.add(l);
      e = e.sub(n);
    }
    return d;
  };
  A.div = A.divide;
  A.modulo = function(a) {
    c(a) || (a = k(a));
    return this.sub(this.div(a).mul(a));
  };
  A.mod = A.modulo;
  A.not = function() {
    return e(~this.low, ~this.high, this.unsigned);
  };
  A.and = function(a) {
    c(a) || (a = k(a));
    return e(this.low & a.low, this.high & a.high, this.unsigned);
  };
  A.or = function(a) {
    c(a) || (a = k(a));
    return e(this.low | a.low, this.high | a.high, this.unsigned);
  };
  A.xor = function(a) {
    c(a) || (a = k(a));
    return e(this.low ^ a.low, this.high ^ a.high, this.unsigned);
  };
  A.shiftLeft = function(a) {
    c(a) && (a = a.toInt());
    return 0 === (a &= 63) ? this : 32 > a ? e(this.low << a, this.high << a | this.low >>> 32 - a, this.unsigned) : e(0, this.low << a - 32, this.unsigned);
  };
  A.shl = A.shiftLeft;
  A.shiftRight = function(a) {
    c(a) && (a = a.toInt());
    return 0 === (a &= 63) ? this : 32 > a ? e(this.low >>> a | this.high << 32 - a, this.high >> a, this.unsigned) : e(this.high >> a - 32, 0 <= this.high ? 0 : -1, this.unsigned);
  };
  A.shr = A.shiftRight;
  A.shiftRightUnsigned = function(a) {
    c(a) && (a = a.toInt());
    a &= 63;
    if (0 === a) {
      return this;
    }
    var b = this.high;
    return 32 > a ? e(this.low >>> a | b << 32 - a, b >>> a, this.unsigned) : 32 === a ? e(b, 0, this.unsigned) : e(b >>> a - 32, 0, this.unsigned);
  };
  A.shru = A.shiftRightUnsigned;
  A.toSigned = function() {
    return this.unsigned ? e(this.low, this.high, !1) : this;
  };
  A.toUnsigned = function() {
    return this.unsigned ? this : e(this.low, this.high, !0);
  };
  A.toBytes = function(a) {
    return a ? this.toBytesLE() : this.toBytesBE();
  };
  A.toBytesLE = function() {
    var a = this.high, b = this.low;
    return [b & 255, b >>> 8 & 255, b >>> 16 & 255, b >>> 24 & 255, a & 255, a >>> 8 & 255, a >>> 16 & 255, a >>> 24 & 255];
  };
  A.toBytesBE = function() {
    var a = this.high, b = this.low;
    return [a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, a & 255, b >>> 24 & 255, b >>> 16 & 255, b >>> 8 & 255, b & 255];
  };
  return a;
});
(function(a) {
  function c(a) {
    if (!a) {
      throw Error("PSON requires ByteBuffer.js: Get it at https://github.com/dcodeIO/ByteBuffer.js");
    }
    var b = {T:{ZERO:0, MAX:239, NULL:240, TRUE:241, FALSE:242, EOBJECT:243, EARRAY:244, ESTRING:245, OBJECT:246, ARRAY:247, INTEGER:248, LONG:249, FLOAT:250, DOUBLE:251, STRING:252, STRING_ADD:253, STRING_GET:254, BINARY:255}};
    b.Encoder = function(a, b) {
      var c = new a(4);
      c.length = 4;
      var f = a.Long, e = function(a, b, c) {
        this.dict = {};
        this.next = 0;
        if (a && Array.isArray(a)) {
          for (; this.next < a.length;) {
            this.dict[a[this.next]] = this.next++;
          }
        }
        this.progressive = !!b;
        this.options = c || {};
      };
      e.prototype.encode = function(b, c) {
        var d = !1;
        c || (c = new a, d = !0);
        var f = c.littleEndian;
        try {
          return this._encodeValue(b, c.LE()), c.littleEndian = f, d ? c.flip() : c;
        } catch (u) {
          throw c.littleEndian = f, u;
        }
      };
      e.prototype._encodeValue = function(e, k, d) {
        if (null === e) {
          k.writeUint8(b.NULL);
        } else {
          switch(typeof e) {
            case "function":
              e = e.toString();
            case "string":
              0 === e.length ? k.writeUint8(b.ESTRING) : this.dict.hasOwnProperty(e) ? (k.writeUint8(b.STRING_GET), k.writeVarint32(this.dict[e])) : (k.writeUint8(b.STRING), k.writeVString(e));
              break;
            case "number":
              d = parseInt(e);
              e === d ? (d = a.zigZagEncode32(e), d <= b.MAX ? k.writeUint8(d) : (k.writeUint8(b.INTEGER), k.writeVarint32ZigZag(e))) : (c.writeFloat32(e, 0), e === c.readFloat32(0) ? (k.writeUint8(b.FLOAT), k.writeFloat32(e)) : (k.writeUint8(b.DOUBLE), k.writeFloat64(e)));
              break;
            case "boolean":
              k.writeUint8(e ? b.TRUE : b.FALSE);
              break;
            case "object":
              var g;
              if (Array.isArray(e)) {
                if (0 === e.length) {
                  k.writeUint8(b.EARRAY);
                } else {
                  for (k.writeUint8(b.ARRAY), k.writeVarint32(e.length), g = 0; g < e.length; g++) {
                    this._encodeValue(e[g], k);
                  }
                }
              } else {
                if (f && e instanceof f) {
                  k.writeUint8(b.LONG), k.writeVarint64ZigZag(e);
                } else {
                  try {
                    e = a.wrap(e), k.writeUint8(b.BINARY), k.writeVarint32(e.remaining()), k.append(e);
                  } catch (y) {
                    var m = Object.keys(e), n = 0;
                    for (g = 0; g < m.length; g++) {
                      "undefined" !== typeof e[m[g]] && n++;
                    }
                    if (0 === n) {
                      k.writeUint8(b.EOBJECT);
                    } else {
                      for (k.writeUint8(b.OBJECT), k.writeVarint32(n), d || (d = !!e._PSON_EXCL_), g = 0; g < m.length; g++) {
                        n = m[g], "undefined" !== typeof e[n] && (this.dict.hasOwnProperty(n) ? (k.writeUint8(b.STRING_GET), k.writeVarint32(this.dict[n])) : (this.progressive && !d ? (this.dict[n] = this.next++, k.writeUint8(b.STRING_ADD)) : k.writeUint8(b.STRING), k.writeVString(n)), this._encodeValue(e[n], k));
                      }
                    }
                  }
                }
              }
              break;
            case "undefined":
              k.writeUint8(b.NULL);
          }
        }
      };
      return e;
    }(a, b.T);
    b.Decoder = function(a, b) {
      var c = a.Long, f = function(a, b, c) {
        this.dict = a && Array.isArray(a) ? a : [];
        this.progressive = !!b;
        this.options = c || {};
      };
      f.prototype.decode = function(b) {
        b instanceof a || (b = a.wrap(b));
        var c = b.littleEndian;
        try {
          var f = this._decodeValue(b.LE());
          b.littleEndian = c;
          return f;
        } catch (d) {
          throw b.littleEndian = c, d;
        }
      };
      f.prototype._decodeValue = function(f) {
        var e = f.readUint8();
        if (e <= b.MAX) {
          return a.zigZagDecode32(e);
        }
        switch(e) {
          case b.NULL:
            return null;
          case b.TRUE:
            return !0;
          case b.FALSE:
            return !1;
          case b.EOBJECT:
            return {};
          case b.EARRAY:
            return [];
          case b.ESTRING:
            return "";
          case b.OBJECT:
            e = f.readVarint32();
            for (var k = {}; 0 <= --e;) {
              k[this._decodeValue(f)] = this._decodeValue(f);
            }
            return k;
          case b.ARRAY:
            e = f.readVarint32();
            for (k = []; 0 <= --e;) {
              k.push(this._decodeValue(f));
            }
            return k;
          case b.INTEGER:
            return f.readVarint32ZigZag();
          case b.LONG:
            return c ? f.readVarint64ZigZag() : f.readVarint32ZigZag();
          case b.FLOAT:
            return f.readFloat32();
          case b.DOUBLE:
            return f.readFloat64();
          case b.STRING:
            return f.readVString();
          case b.STRING_ADD:
            return f = f.readVString(), this.dict.push(f), f;
          case b.STRING_GET:
            return this.dict[f.readVarint32()];
          case b.BINARY:
            return e = f.readVarint32(), k = f.slice(f.offset, f.offset + e), f.offset += e, k;
          default:
            throw Error("Illegal type at " + f.offset + ": " + e);
        }
      };
      return f;
    }(a, b.T);
    b.Pair = function() {
      var a = function() {
      };
      a.prototype.encode = function(a) {
        return this.encoder.encode(a);
      };
      a.prototype.toArrayBuffer = function(a) {
        return this.encoder.encode(a).toArrayBuffer();
      };
      a.prototype.toBuffer = function(a) {
        return this.encoder.encode(a).toBuffer();
      };
      a.prototype.decode = function(a) {
        return this.decoder.decode(a);
      };
      return a;
    }();
    b.StaticPair = function(a, b, c) {
      var f = function(f, e) {
        a.call(this);
        this.encoder = new b(f, !1, e);
        this.decoder = new c(f, !1, e);
      };
      f.prototype = Object.create(a.prototype);
      return f;
    }(b.Pair, b.Encoder, b.Decoder);
    b.ProgressivePair = function(a, c, k) {
      var f = function(b, f) {
        a.call(this);
        this.encoder = new c(b, !0, f);
        this.decoder = new k(b, !0, f);
      };
      f.prototype = Object.create(a.prototype);
      f.prototype.exclude = function(a) {
        b.exclude(a);
      };
      f.prototype.include = function(a) {
        b.include(a);
      };
      return f;
    }(b.Pair, b.Encoder, b.Decoder);
    b.exclude = function(a) {
      "object" === typeof a && Object.defineProperty(a, "_PSON_EXCL_", {value:!0, enumerable:!1, configurable:!0});
    };
    b.include = function(a) {
      "object" === typeof a && delete a._PSON_EXCL_;
    };
    return b;
  }
  "undefined" != typeof module && module.exports ? module.exports = c(require("bytebuffer")) : "undefined" != typeof define && define.amd ? define("PSON", ["ByteBuffer"], c) : (a.dcodeIO || (a.dcodeIO = {}), a.dcodeIO.PSON = c(a.dcodeIO.ByteBuffer));
})(this);
(function e$jscomp$0(a, c, g) {
  function e(k, p) {
    if (!c[k]) {
      if (!a[k]) {
        var m = "function" == typeof require && require;
        if (!p && m) {
          return m(k, !0);
        }
        if (f) {
          return f(k, !0);
        }
        p = Error("Cannot find module '" + k + "'");
        throw p.code = "MODULE_NOT_FOUND", p;
      }
      p = c[k] = {exports:{}};
      a[k][0].call(p.exports, function(c) {
        var d = a[k][1][c];
        return e(d ? d : c);
      }, p, p.exports, e$jscomp$0, a, c, g);
    }
    return c[k].exports;
  }
  for (var f = "function" == typeof require && require, k = 0; k < g.length; k++) {
    e(g[k]);
  }
  return e;
})({1:[function(a, c, g) {
  var b = Object.prototype.toString;
  c.exports = function(a) {
    return a.BYTES_PER_ELEMENT && "[object ArrayBuffer]" === b.call(a.buffer) || Array.isArray(a);
  };
}, {}], 2:[function(a, c, g) {
  c.exports = function(a, c) {
    return "number" === typeof a ? a : "number" === typeof c ? c : 0;
  };
}, {}], 3:[function(a, c, g) {
  c.exports = function(a) {
    switch(a) {
      case "int8":
        return Int8Array;
      case "int16":
        return Int16Array;
      case "int32":
        return Int32Array;
      case "uint8":
        return Uint8Array;
      case "uint16":
        return Uint16Array;
      case "uint32":
        return Uint32Array;
      case "float32":
        return Float32Array;
      case "float64":
        return Float64Array;
      case "array":
        return Array;
      case "uint8_clamped":
        return Uint8ClampedArray;
    }
  };
}, {}], 4:[function(a, c, g) {
  var b = a("dtype");
  c.exports = function(a, c, k) {
    if (!a) {
      throw new TypeError("must specify data as first parameter");
    }
    k = +(k || 0) | 0;
    if (Array.isArray(a) && Array.isArray(a[0])) {
      var f = a[0].length, e = a.length * f;
      c && "string" !== typeof c || (c = new (b(c || "float32"))(e + k));
      var g = c.length - k;
      if (e !== g) {
        throw Error("source length " + e + " (" + f + "x" + a.length + ") does not match destination length " + g);
      }
      for (e = 0; e < a.length; e++) {
        for (g = 0; g < f; g++) {
          c[k++] = a[e][g];
        }
      }
    } else {
      c && "string" !== typeof c ? c.set(a, k) : (c = b(c || "float32"), 0 === k ? c = new c(a) : (c = new c(a.length + k), c.set(a, k)));
    }
    return c;
  };
}, {dtype:3}], 5:[function(a, c, g) {
  c.exports = function(a) {
    if (!a || "string" !== typeof a) {
      throw Error("must specify property for indexof search");
    }
    return new Function("array", "value", "start", ["start = start || 0\nfor (var i=start; i<array.length; i++)", '  if (array[i]["' + a + '"] === value)', "      return i\nreturn -1"].join("\n"));
  };
}, {}], 6:[function(a, c, g) {
  c.exports = "function" === typeof Object.create ? function(a, c) {
    a.super_ = c;
    a.prototype = Object.create(c.prototype, {constructor:{value:a, enumerable:!1, writable:!0, configurable:!0}});
  } : function(a, c) {
    a.super_ = c;
    var b = function() {
    };
    b.prototype = c.prototype;
    a.prototype = new b;
    a.prototype.constructor = a;
  };
}, {}], 7:[function(a, c, g) {
  function b(a) {
    return !!a.constructor && "function" === typeof a.constructor.isBuffer && a.constructor.isBuffer(a);
  }
  c.exports = function(a) {
    return null != a && (b(a) || "function" === typeof a.readFloatLE && "function" === typeof a.slice && b(a.slice(0, 0)) || !!a._isBuffer);
  };
}, {}], 8:[function(a, c, g) {
  function b(a) {
    this.glyphs = [];
    this._measure = this.computeMetrics.bind(this);
    this.update(a);
  }
  function e(a, b) {
    if (!a.chars || 0 === a.chars.length) {
      return null;
    }
    b = d(a.chars, b);
    return 0 <= b ? a.chars[b] : null;
  }
  function f(a) {
    for (var b = 0; b < u.length; b++) {
      var c = u[b].charCodeAt(0);
      c = d(a.chars, c);
      if (0 <= c) {
        return a.chars[c].height;
      }
    }
    return 0;
  }
  function k(a) {
    for (var b = 0; b < y.length; b++) {
      var c = y[b].charCodeAt(0);
      c = d(a.chars, c);
      if (0 <= c) {
        return a.chars[c].height;
      }
    }
    return 0;
  }
  function n(a, b, c) {
    if (!a.kernings || 0 === a.kernings.length) {
      return 0;
    }
    a = a.kernings;
    for (var d = 0; d < a.length; d++) {
      var f = a[d];
      if (f.first === b && f.second === c) {
        return f.amount;
      }
    }
    return 0;
  }
  function p(a) {
    return "center" === a ? 1 : "right" === a ? 2 : 0;
  }
  var m = a("word-wrapper"), t = a("xtend"), d = a("indexof-property")("id"), l = a("as-number"), u = "xeaonsrcumvwz".split(""), w = ["m", "w"], y = "HINEFKLTUVWXYZ".split("");
  c.exports = function(a) {
    return new b(a);
  };
  b.prototype.update = function(a) {
    this._opt = a = t({measure:this._measure}, a);
    this._opt.tabSize = l(this._opt.tabSize, 4);
    if (!a.font) {
      throw Error("must provide a valid bitmap font");
    }
    var b = this.glyphs, c = a.text || "", d = a.font;
    this._setupSpaceGlyphs(d);
    var e = m.lines(c, a), g = a.width || 0;
    b.length = 0;
    var u = e.reduce(function(a, b) {
      return Math.max(a, b.width, g);
    }, 0), w = 0, y = 0, x = l(a.lineHeight, d.common.lineHeight), H = d.common.base, K = x - H, I = a.letterSpacing || 0;
    a = x * e.length - K;
    var L = p(this._opt.align);
    y -= a;
    this._width = u;
    this._height = a;
    this._descender = x - H;
    this._baseline = H;
    this._xHeight = f(d);
    this._capHeight = k(d);
    this._lineHeight = x;
    this._ascender = x - K - this._xHeight;
    var R = this;
    e.forEach(function(a, f) {
      var e = a.end, k = a.width;
      for (a = a.start; a < e; a++) {
        var g = c.charCodeAt(a);
        if (g = R.getGlyph(d, g)) {
          l && (w += n(d, l.id, g.id));
          var l = w;
          1 === L ? l += (u - k) / 2 : 2 === L && (l += u - k);
          b.push({position:[l, y], data:g, index:a, line:f});
          w += g.xadvance + I;
          l = g;
        }
      }
      y += x;
      w = 0;
    });
    this._linesTotal = e.length;
  };
  b.prototype._setupSpaceGlyphs = function(a) {
    this._fallbackTabGlyph = this._fallbackSpaceGlyph = null;
    if (a.chars && 0 !== a.chars.length) {
      var b;
      if (!(b = e(a, 32))) {
        a: {
          for (b = 0; b < w.length; b++) {
            var c = w[b].charCodeAt(0);
            c = d(a.chars, c);
            if (0 <= c) {
              b = a.chars[c];
              break a;
            }
          }
          b = 0;
        }
      }
      a = b || a.chars[0];
      b = this._opt.tabSize * a.xadvance;
      this._fallbackSpaceGlyph = a;
      this._fallbackTabGlyph = t(a, {x:0, y:0, xadvance:b, id:9, xoffset:0, yoffset:0, width:0, height:0});
    }
  };
  b.prototype.getGlyph = function(a, b) {
    return (a = e(a, b)) ? a : 9 === b ? this._fallbackTabGlyph : 32 === b ? this._fallbackSpaceGlyph : null;
  };
  b.prototype.computeMetrics = function(a, b, c, d) {
    var f = this._opt.letterSpacing || 0, e = this._opt.font, k = 0, g = 0, l = 0;
    if (!e.chars || 0 === e.chars.length) {
      return {start:b, end:b, width:0};
    }
    c = Math.min(a.length, c);
    for (var q = b; q < c; q++) {
      var m = a.charCodeAt(q);
      if (m = this.getGlyph(e, m)) {
        var t = v ? n(e, v.id, m.id) : 0;
        k += t;
        t = k + m.xadvance + f;
        var p = k + m.width;
        if (p >= d || t >= d) {
          break;
        }
        k = t;
        g = p;
        var v = m;
      }
      l++;
    }
    v && (g += v.xoffset);
    return {start:b, end:b + l, width:g};
  };
  "width height descender ascender xHeight baseline capHeight lineHeight".split(" ").forEach(function(a) {
    Object.defineProperty(b.prototype, a, {get:(new Function(["return function " + a + "() {", "  return this._" + a, "}"].join("\n")))(), configurable:!0});
  });
}, {"as-number":2, "indexof-property":5, "word-wrapper":15, xtend:16}], 9:[function(a, c, g) {
  var b = Object.prototype.hasOwnProperty, e = Object.prototype.propertyIsEnumerable;
  c.exports = function() {
    try {
      if (!Object.assign) {
        return !1;
      }
      var a = new String("abc");
      a[5] = "de";
      if ("5" === Object.getOwnPropertyNames(a)[0]) {
        return !1;
      }
      var b = {};
      for (a = 0; 10 > a; a++) {
        b["_" + String.fromCharCode(a)] = a;
      }
      if ("0123456789" !== Object.getOwnPropertyNames(b).map(function(a) {
        return b[a];
      }).join("")) {
        return !1;
      }
      var c = {};
      "abcdefghijklmnopqrst".split("").forEach(function(a) {
        c[a] = a;
      });
      return "abcdefghijklmnopqrst" !== Object.keys(Object.assign({}, c)).join("") ? !1 : !0;
    } catch (p) {
      return !1;
    }
  }() ? Object.assign : function(a, c) {
    if (null === a || void 0 === a) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    var f = Object(a);
    for (var k, g = 1; g < arguments.length; g++) {
      var t = Object(arguments[g]);
      for (var d in t) {
        b.call(t, d) && (f[d] = t[d]);
      }
      if (Object.getOwnPropertySymbols) {
        k = Object.getOwnPropertySymbols(t);
        for (var l = 0; l < k.length; l++) {
          e.call(t, k[l]) && (f[k[l]] = t[k[l]]);
        }
      }
    }
    return f;
  };
}, {}], 10:[function(a, c, g) {
  var b = a("dtype"), e = a("an-array"), f = a("is-buffer"), k = [0, 2, 3], n = [2, 1, 3];
  c.exports = function(a, c) {
    a && (e(a) || f(a)) || (c = a || {}, a = null);
    c = "number" === typeof c ? {count:c} : c || {};
    var g = "string" === typeof c.type ? c.type : "uint16", d = c.start || 0, l = !1 !== c.clockwise ? k : n, m = l[0], p = l[1];
    l = l[2];
    c = 6 * ("number" === typeof c.count ? c.count : 1);
    a = a || new (b(g))(c);
    for (var y = g = 0; g < c; g += 6, y += 4) {
      var x = g + d;
      a[x + 0] = y + 0;
      a[x + 1] = y + 1;
      a[x + 2] = y + 2;
      a[x + 3] = y + m;
      a[x + 4] = y + p;
      a[x + 5] = y + l;
    }
    return a;
  };
}, {"an-array":1, dtype:3, "is-buffer":7}], 11:[function(a, c, g) {
  function b(a) {
    t.call(this);
    "string" === typeof a && (a = {text:a});
    this._opt = n({}, a);
    a && this.update(a);
  }
  var e = a("layout-bmfont-text");
  g = a("inherits");
  var f = a("quad-indices"), k = a("three-buffer-vertex-data"), n = a("object-assign"), p = a("./lib/vertices"), m = a("./lib/utils"), t = THREE.BufferGeometry;
  c.exports = function(a) {
    return new b(a);
  };
  g(b, t);
  b.prototype.update = function(a) {
    "string" === typeof a && (a = {text:a});
    a = n({}, this._opt, a);
    if (!a.font) {
      throw new TypeError("must specify a { font } in options");
    }
    this.layout = e(a);
    var b = !1 !== a.flipY, c = a.font, d = c.common.scaleW, g = c.common.scaleH;
    this.visibleGlyphs = c = this.layout.glyphs.filter(function(a) {
      a = a.data;
      return 0 < a.width * a.height;
    });
    var m = p.positions(c);
    b = p.uvs(c, d, g, b);
    d = f({clockwise:!0, type:"uint16", count:c.length});
    k.index(this, d, 1, "uint16");
    k.attr(this, "position", m, 2);
    k.attr(this, "uv", b, 2);
    !a.multipage && "page" in this.attributes ? this.removeAttribute("page") : a.multipage && (a = p.pages(c), k.attr(this, "page", a, 1));
  };
  b.prototype.computeBoundingSphere = function() {
    null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
    var a = this.attributes.position.array, b = this.attributes.position.itemSize;
    !a || !b || 2 > a.length ? (this.boundingSphere.radius = 0, this.boundingSphere.center.set(0, 0, 0)) : (m.computeSphere(a, this.boundingSphere), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.'));
  };
  b.prototype.computeBoundingBox = function() {
    null === this.boundingBox && (this.boundingBox = new THREE.Box3);
    var a = this.boundingBox, b = this.attributes.position.array, c = this.attributes.position.itemSize;
    !b || !c || 2 > b.length ? a.makeEmpty() : m.computeBox(b, a);
  };
}, {"./lib/utils":12, "./lib/vertices":13, inherits:6, "layout-bmfont-text":8, "object-assign":9, "quad-indices":10, "three-buffer-vertex-data":14}], 12:[function(a, c, g) {
  function b(a) {
    var b = a.length / 2;
    e.min[0] = a[0];
    e.min[1] = a[1];
    e.max[0] = a[0];
    e.max[1] = a[1];
    for (var c = 0; c < b; c++) {
      var f = a[2 * c], g = a[2 * c + 1];
      e.min[0] = Math.min(f, e.min[0]);
      e.min[1] = Math.min(g, e.min[1]);
      e.max[0] = Math.max(f, e.max[0]);
      e.max[1] = Math.max(g, e.max[1]);
    }
  }
  var e = {min:[0, 0], max:[0, 0]};
  c.exports.computeBox = function(a, c) {
    b(a);
    c.min.set(e.min[0], e.min[1], 0);
    c.max.set(e.max[0], e.max[1], 0);
  };
  c.exports.computeSphere = function(a, c) {
    b(a);
    a = e.min[0];
    var f = e.min[1], k = e.max[0] - a, g = e.max[1] - f, t = Math.sqrt(k * k + g * g);
    c.center.set(a + k / 2, f + g / 2, 0);
    c.radius = t / 2;
  };
}, {}], 13:[function(a, c, g) {
  c.exports.pages = function(a) {
    var b = new Float32Array(4 * a.length), c = 0;
    a.forEach(function(a) {
      a = a.data.page || 0;
      b[c++] = a;
      b[c++] = a;
      b[c++] = a;
      b[c++] = a;
    });
    return b;
  };
  c.exports.uvs = function(a, c, f, k) {
    var b = new Float32Array(8 * a.length), e = 0;
    a.forEach(function(a) {
      a = a.data;
      var g = a.y + a.height, d = a.x / c, l = a.y / f, m = (a.x + a.width) / c, n = g / f;
      k && (l = (f - a.y) / f, n = (f - g) / f);
      b[e++] = d;
      b[e++] = l;
      b[e++] = d;
      b[e++] = n;
      b[e++] = m;
      b[e++] = n;
      b[e++] = m;
      b[e++] = l;
    });
    return b;
  };
  c.exports.positions = function(a) {
    var b = new Float32Array(8 * a.length), c = 0;
    a.forEach(function(a) {
      var f = a.data, e = a.position[0] + f.xoffset;
      a = a.position[1] + f.yoffset;
      var k = f.width;
      f = f.height;
      b[c++] = e;
      b[c++] = a;
      b[c++] = e;
      b[c++] = a + f;
      b[c++] = e + k;
      b[c++] = a + f;
      b[c++] = e + k;
      b[c++] = a;
    });
    return b;
  };
}, {}], 14:[function(a, c, g) {
  function b(a, b, c, g) {
    b = b || [];
    var f;
    if (!(f = !a)) {
      if (f = b, a.itemSize === c && a.array) {
        var k = a.array.length;
        f = Array.isArray(f) && Array.isArray(f[0]) ? k !== f.length * c : k !== f.length;
      } else {
        f = !0;
      }
    }
    if (f) {
      return b = e(b, g), a = new THREE.BufferAttribute(b, c), a.needsUpdate = !0, a;
    }
    e(b, a.array);
    a.needsUpdate = !0;
    return null;
  }
  var e = a("flatten-vertex-data");
  c.exports.attr = function(a, c, e, g, m) {
    "number" !== typeof g && (g = 3);
    "string" !== typeof m && (m = "float32");
    if (Array.isArray(e) && Array.isArray(e[0]) && e[0].length !== g) {
      throw Error("Nested vertex array has unexpected size; expected " + g + " but found " + e[0].length);
    }
    var f = a.getAttribute(c);
    (e = b(f, e, g, m)) && a.addAttribute(c, e);
  };
  c.exports.index = function(a, c, e, g) {
    "number" !== typeof e && (e = 1);
    "string" !== typeof g && (g = "uint16");
    var f = !a.index && "function" !== typeof a.setIndex, k = f ? a.getAttribute("index") : a.index;
    if (c = b(k, c, e, g)) {
      f ? a.addAttribute("index", c) : a.index = c;
    }
  };
}, {"flatten-vertex-data":4}], 15:[function(a, c, g) {
  function b(a, b, c, f) {
    return {start:b, end:b + Math.min(f, c - b)};
  }
  var e = /\n/, f = /\s/;
  c.exports = function(a, b) {
    return c.exports.lines(a, b).map(function(b) {
      return a.substring(b.start, b.end);
    }).join("\n");
  };
  c.exports.lines = function(a, c) {
    c = c || {};
    if (0 === c.width && "nowrap" !== c.mode) {
      return [];
    }
    a = a || "";
    var k = "number" === typeof c.width ? c.width : Number.MAX_VALUE, g = Math.max(0, c.start || 0), n = "number" === typeof c.end ? c.end : a.length, d = c.mode;
    c = c.measure || b;
    if ("pre" === d) {
      var l = [];
      for (d = g; g < n && g < a.length; g++) {
        var u = a.charAt(g);
        if ((u = e.test(u)) || g === n - 1) {
          d = c(a, d, u ? g : g + 1, k), l.push(d), d = g + 1;
        }
      }
      return l;
    }
    l = g;
    g = [];
    "nowrap" === d && (k = Number.MAX_VALUE);
    for (; l < n && l < a.length;) {
      d = n;
      u = a.indexOf("\n", l);
      for (d = -1 === u || u > d ? d : u; l < d && f.test(a.charAt(l));) {
        l++;
      }
      u = c(a, l, d, k);
      var w = l + (u.end - u.start);
      u = w + 1;
      if (w < d) {
        for (; w > l && !f.test(a.charAt(w));) {
          w--;
        }
        if (w === l) {
          u > l + 1 && u--, w = u;
        } else {
          for (u = w; w > l && f.test(a.charAt(w - 1));) {
            w--;
          }
        }
      }
      w >= l && (l = c(a, l, w, k), g.push(l));
      l = u;
    }
    return g;
  };
}, {}], 16:[function(a, c, g) {
  c.exports = function() {
    for (var a = {}, c = 0; c < arguments.length; c++) {
      var k = arguments[c], g;
      for (g in k) {
        b.call(k, g) && (a[g] = k[g]);
      }
    }
    return a;
  };
  var b = Object.prototype.hasOwnProperty;
}, {}], 17:[function(a, c, g) {
  window.createGeometry = a("three-bmfont-text");
}, {"three-bmfont-text":11}]}, {}, [17]);
!function(a) {
  if ("object" == typeof exports && "undefined" != typeof module) {
    module.exports = a();
  } else {
    var c;
    "undefined" != typeof window ? c = window : "undefined" != typeof global ? c = global : "undefined" != typeof self && (c = self);
    c.CANNON = a();
  }
}(function() {
  return function e(c, g, b) {
    function f(n, m) {
      if (!g[n]) {
        if (!c[n]) {
          var t = "function" == typeof require && require;
          if (!m && t) {
            return t(n, !0);
          }
          if (k) {
            return k(n, !0);
          }
          throw Error("Cannot find module '" + n + "'");
        }
        m = g[n] = {exports:{}};
        c[n][0].call(m.exports, function(b) {
          var d = c[n][1][b];
          return f(d ? d : b);
        }, m, m.exports, e, c, g, b);
      }
      return g[n].exports;
    }
    for (var k = "function" == typeof require && require, n = 0; n < b.length; n++) {
      f(b[n]);
    }
    return f;
  }({1:[function(c, g) {
    g.exports = {name:"cannon", version:"0.6.2", description:"A lightweight 3D physics engine written in JavaScript.", homepage:"https://github.com/schteppe/cannon.js", author:"Stefan Hedman <schteppe@gmail.com> (http://steffe.se)", keywords:["cannon.js", "cannon", "physics", "engine", "3d"], main:"./build/cannon.js", engines:{node:"*"}, repository:{type:"git", url:"https://github.com/schteppe/cannon.js.git"}, bugs:{url:"https://github.com/schteppe/cannon.js/issues"}, licenses:[{type:"MIT"}], devDependencies:{jshint:"latest", 
    "uglify-js":"latest", nodeunit:"^0.9.0", grunt:"~0.4.0", "grunt-contrib-jshint":"~0.1.1", "grunt-contrib-nodeunit":"^0.4.1", "grunt-contrib-concat":"~0.1.3", "grunt-contrib-uglify":"^0.5.1", "grunt-browserify":"^2.1.4", "grunt-contrib-yuidoc":"^0.5.2", browserify:"*"}, dependencies:{}};
  }, {}], 2:[function(c, g) {
    g.exports = {version:c("../package.json").version, AABB:c("./collision/AABB"), ArrayCollisionMatrix:c("./collision/ArrayCollisionMatrix"), Body:c("./objects/Body"), Box:c("./shapes/Box"), Broadphase:c("./collision/Broadphase"), Constraint:c("./constraints/Constraint"), ContactEquation:c("./equations/ContactEquation"), Narrowphase:c("./world/Narrowphase"), ConeTwistConstraint:c("./constraints/ConeTwistConstraint"), ContactMaterial:c("./material/ContactMaterial"), ConvexPolyhedron:c("./shapes/ConvexPolyhedron"), 
    Cylinder:c("./shapes/Cylinder"), DistanceConstraint:c("./constraints/DistanceConstraint"), Equation:c("./equations/Equation"), EventTarget:c("./utils/EventTarget"), FrictionEquation:c("./equations/FrictionEquation"), GSSolver:c("./solver/GSSolver"), GridBroadphase:c("./collision/GridBroadphase"), Heightfield:c("./shapes/Heightfield"), HingeConstraint:c("./constraints/HingeConstraint"), LockConstraint:c("./constraints/LockConstraint"), Mat3:c("./math/Mat3"), Material:c("./material/Material"), 
    NaiveBroadphase:c("./collision/NaiveBroadphase"), ObjectCollisionMatrix:c("./collision/ObjectCollisionMatrix"), Pool:c("./utils/Pool"), Particle:c("./shapes/Particle"), Plane:c("./shapes/Plane"), PointToPointConstraint:c("./constraints/PointToPointConstraint"), Quaternion:c("./math/Quaternion"), Ray:c("./collision/Ray"), RaycastVehicle:c("./objects/RaycastVehicle"), RaycastResult:c("./collision/RaycastResult"), RigidVehicle:c("./objects/RigidVehicle"), RotationalEquation:c("./equations/RotationalEquation"), 
    RotationalMotorEquation:c("./equations/RotationalMotorEquation"), SAPBroadphase:c("./collision/SAPBroadphase"), SPHSystem:c("./objects/SPHSystem"), Shape:c("./shapes/Shape"), Solver:c("./solver/Solver"), Sphere:c("./shapes/Sphere"), SplitSolver:c("./solver/SplitSolver"), Spring:c("./objects/Spring"), Trimesh:c("./shapes/Trimesh"), Vec3:c("./math/Vec3"), Vec3Pool:c("./utils/Vec3Pool"), World:c("./world/World")};
  }, {"../package.json":1, "./collision/AABB":3, "./collision/ArrayCollisionMatrix":4, "./collision/Broadphase":5, "./collision/GridBroadphase":6, "./collision/NaiveBroadphase":7, "./collision/ObjectCollisionMatrix":8, "./collision/Ray":9, "./collision/RaycastResult":10, "./collision/SAPBroadphase":11, "./constraints/ConeTwistConstraint":12, "./constraints/Constraint":13, "./constraints/DistanceConstraint":14, "./constraints/HingeConstraint":15, "./constraints/LockConstraint":16, "./constraints/PointToPointConstraint":17, 
  "./equations/ContactEquation":19, "./equations/Equation":20, "./equations/FrictionEquation":21, "./equations/RotationalEquation":22, "./equations/RotationalMotorEquation":23, "./material/ContactMaterial":24, "./material/Material":25, "./math/Mat3":27, "./math/Quaternion":28, "./math/Vec3":30, "./objects/Body":31, "./objects/RaycastVehicle":32, "./objects/RigidVehicle":33, "./objects/SPHSystem":34, "./objects/Spring":35, "./shapes/Box":37, "./shapes/ConvexPolyhedron":38, "./shapes/Cylinder":39, 
  "./shapes/Heightfield":40, "./shapes/Particle":41, "./shapes/Plane":42, "./shapes/Shape":43, "./shapes/Sphere":44, "./shapes/Trimesh":45, "./solver/GSSolver":46, "./solver/Solver":47, "./solver/SplitSolver":48, "./utils/EventTarget":49, "./utils/Pool":51, "./utils/Vec3Pool":54, "./world/Narrowphase":55, "./world/World":56}], 3:[function(c, g) {
    function b(b) {
      b = b || {};
      this.lowerBound = new e;
      b.lowerBound && this.lowerBound.copy(b.lowerBound);
      this.upperBound = new e;
      b.upperBound && this.upperBound.copy(b.upperBound);
    }
    var e = c("../math/Vec3");
    c("../utils/Utils");
    g.exports = b;
    var f = new e;
    b.prototype.setFromPoints = function(b, c, e, k) {
      var d = this.lowerBound, g = this.upperBound;
      d.copy(b[0]);
      e && e.vmult(d, d);
      g.copy(d);
      for (var m = 1; m < b.length; m++) {
        var n = b[m];
        e && (e.vmult(n, f), n = f);
        n.x > g.x && (g.x = n.x);
        n.x < d.x && (d.x = n.x);
        n.y > g.y && (g.y = n.y);
        n.y < d.y && (d.y = n.y);
        n.z > g.z && (g.z = n.z);
        n.z < d.z && (d.z = n.z);
      }
      return c && (c.vadd(d, d), c.vadd(g, g)), k && (d.x -= k, d.y -= k, d.z -= k, g.x += k, g.y += k, g.z += k), this;
    };
    b.prototype.copy = function(b) {
      return this.lowerBound.copy(b.lowerBound), this.upperBound.copy(b.upperBound), this;
    };
    b.prototype.clone = function() {
      return (new b).copy(this);
    };
    b.prototype.extend = function(b) {
      var c = b.lowerBound.x;
      this.lowerBound.x > c && (this.lowerBound.x = c);
      c = b.upperBound.x;
      this.upperBound.x < c && (this.upperBound.x = c);
      c = b.lowerBound.y;
      this.lowerBound.y > c && (this.lowerBound.y = c);
      c = b.upperBound.y;
      this.upperBound.y < c && (this.upperBound.y = c);
      c = b.lowerBound.z;
      this.lowerBound.z > c && (this.lowerBound.z = c);
      c = b.upperBound.z;
      this.upperBound.z < c && (this.upperBound.z = c);
    };
    b.prototype.overlaps = function(b) {
      var c = this.lowerBound, f = this.upperBound, e = b.lowerBound;
      b = b.upperBound;
      return (e.x <= f.x && f.x <= b.x || c.x <= b.x && b.x <= f.x) && (e.y <= f.y && f.y <= b.y || c.y <= b.y && b.y <= f.y) && (e.z <= f.z && f.z <= b.z || c.z <= b.z && b.z <= f.z);
    };
    b.prototype.contains = function(b) {
      var c = this.lowerBound, f = this.upperBound, e = b.lowerBound;
      b = b.upperBound;
      return c.x <= e.x && f.x >= b.x && c.y <= e.y && f.y >= b.y && c.z <= e.z && f.z >= b.z;
    };
    b.prototype.getCorners = function(b, c, f, e, d, k, g, w) {
      var l = this.lowerBound, m = this.upperBound;
      b.copy(l);
      c.set(m.x, l.y, l.z);
      f.set(m.x, m.y, l.z);
      e.set(l.x, m.y, m.z);
      d.set(m.x, l.y, l.z);
      k.set(l.x, m.y, l.z);
      g.set(l.x, l.y, m.z);
      w.copy(m);
    };
    var k = [new e, new e, new e, new e, new e, new e, new e, new e];
    b.prototype.toLocalFrame = function(b, c) {
      this.getCorners(k[0], k[1], k[2], k[3], k[4], k[5], k[6], k[7]);
      for (var f = 0; 8 !== f; f++) {
        var e = k[f];
        b.pointToLocal(e, e);
      }
      return c.setFromPoints(k);
    };
    b.prototype.toWorldFrame = function(b, c) {
      this.getCorners(k[0], k[1], k[2], k[3], k[4], k[5], k[6], k[7]);
      for (var f = 0; 8 !== f; f++) {
        var e = k[f];
        b.pointToWorld(e, e);
      }
      return c.setFromPoints(k);
    };
  }, {"../math/Vec3":30, "../utils/Utils":53}], 4:[function(c, g) {
    function b() {
      this.matrix = [];
    }
    g.exports = b;
    b.prototype.get = function(b, c) {
      if (b = b.index, c = c.index, c > b) {
        var f = c;
        c = b;
        b = f;
      }
      return this.matrix[(b * (b + 1) >> 1) + c - 1];
    };
    b.prototype.set = function(b, c, k) {
      if (b = b.index, c = c.index, c > b) {
        var f = c;
        c = b;
        b = f;
      }
      this.matrix[(b * (b + 1) >> 1) + c - 1] = k ? 1 : 0;
    };
    b.prototype.reset = function() {
      for (var b = 0, c = this.matrix.length; b !== c; b++) {
        this.matrix[b] = 0;
      }
    };
    b.prototype.setNumObjects = function(b) {
      this.matrix.length = b * (b - 1) >> 1;
    };
  }, {}], 5:[function(c, g) {
    function b() {
      this.world = null;
      this.useBoundingBoxes = !1;
      this.dirty = !0;
    }
    var e = c("../objects/Body"), f = c("../math/Vec3"), k = c("../math/Quaternion");
    c("../shapes/Shape");
    c("../shapes/Plane");
    g.exports = b;
    b.prototype.collisionPairs = function() {
      throw Error("collisionPairs not implemented for this BroadPhase class!");
    };
    var n = e.STATIC | e.KINEMATIC;
    b.prototype.needBroadphaseCollision = function(b, c) {
      return 0 === (b.collisionFilterGroup & c.collisionFilterMask) || 0 === (c.collisionFilterGroup & b.collisionFilterMask) ? !1 : 0 === (b.type & n) && b.sleepState !== e.SLEEPING || 0 === (c.type & n) && c.sleepState !== e.SLEEPING ? !0 : !1;
    };
    b.prototype.intersectionTest = function(b, c, d, f) {
      this.useBoundingBoxes ? this.doBoundingBoxBroadphase(b, c, d, f) : this.doBoundingSphereBroadphase(b, c, d, f);
    };
    var p = new f;
    new f;
    new k;
    new f;
    b.prototype.doBoundingSphereBroadphase = function(b, c, d, f) {
      c.position.vsub(b.position, p);
      var e = Math.pow(b.boundingRadius + c.boundingRadius, 2), k = p.norm2();
      e > k && (d.push(b), f.push(c));
    };
    b.prototype.doBoundingBoxBroadphase = function(b, c, d, f) {
      b.aabbNeedsUpdate && b.computeAABB();
      c.aabbNeedsUpdate && c.computeAABB();
      b.aabb.overlaps(c.aabb) && (d.push(b), f.push(c));
    };
    var m = {keys:[]}, t = [], d = [];
    b.prototype.makePairsUnique = function(b, c) {
      for (var f = b.length, e = 0; e !== f; e++) {
        t[e] = b[e], d[e] = c[e];
      }
      b.length = 0;
      for (e = c.length = 0; e !== f; e++) {
        var k = t[e].id, g = d[e].id;
        k = g > k ? k + "," + g : g + "," + k;
        m[k] = e;
        m.keys.push(k);
      }
      for (e = 0; e !== m.keys.length; e++) {
        k = m.keys.pop(), f = m[k], b.push(t[f]), c.push(d[f]), delete m[k];
      }
    };
    b.prototype.setWorld = function() {
    };
    var l = new f;
    b.boundingSphereCheck = function(b, c) {
      return b.position.vsub(c.position, l), Math.pow(b.shape.boundingSphereRadius + c.shape.boundingSphereRadius, 2) > l.norm2();
    };
    b.prototype.aabbQuery = function() {
      return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), [];
    };
  }, {"../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "../shapes/Plane":42, "../shapes/Shape":43}], 6:[function(c, g) {
    function b(b, c, k, d, g) {
      e.apply(this);
      this.nx = k || 10;
      this.ny = d || 10;
      this.nz = g || 10;
      this.aabbMin = b || new f(100, 100, 100);
      this.aabbMax = c || new f(-100, -100, -100);
      b = this.nx * this.ny * this.nz;
      if (0 >= b) {
        throw "GridBroadphase: Each dimension's n must be >0";
      }
      this.bins = [];
      this.binLengths = [];
      this.bins.length = b;
      this.binLengths.length = b;
      for (c = 0; b > c; c++) {
        this.bins[c] = [], this.binLengths[c] = 0;
      }
    }
    g.exports = b;
    var e = c("./Broadphase"), f = c("../math/Vec3"), k = c("../shapes/Shape");
    b.prototype = new e;
    b.prototype.constructor = b;
    var n = new f;
    new f;
    b.prototype.collisionPairs = function(b, c, f) {
      function d(b, c, d, f, e, k, g) {
        b = (b - B) * K | 0;
        c = (c - G) * I | 0;
        d = (d - H) * L | 0;
        f = S((f - B) * K);
        e = S((e - G) * I);
        k = S((k - H) * L);
        0 > b ? b = 0 : b >= t && (b = t - 1);
        0 > c ? c = 0 : c >= p && (c = p - 1);
        0 > d ? d = 0 : d >= q && (d = q - 1);
        0 > f ? f = 0 : f >= t && (f = t - 1);
        0 > e ? e = 0 : e >= p && (e = p - 1);
        0 > k ? k = 0 : k >= q && (k = q - 1);
        b *= v;
        c *= z;
        d *= C;
        f *= v;
        e *= z;
        for (k *= C; f >= b; b += v) {
          for (var l = c; e >= l; l += z) {
            for (var m = d; k >= m; m += C) {
              var n = b + l + m;
              U[n][N[n]++] = g;
            }
          }
        }
      }
      var e = b.numObjects();
      b = b.bodies;
      var g = this.aabbMax, m = this.aabbMin, t = this.nx, p = this.ny, q = this.nz, v = p * q, z = q, C = 1, A = g.x, D = g.y, E = g.z, B = m.x, G = m.y, H = m.z, K = t / (A - B), I = p / (D - G), L = q / (E - H);
      A = (A - B) / t;
      var R = (D - G) / p;
      E = (E - H) / q;
      var J = .5 * Math.sqrt(A * A + R * R + E * E);
      D = k.types;
      var Q = D.SPHERE, aa = D.PLANE, U = (D.BOX, D.COMPOUND, D.CONVEXPOLYHEDRON, this.bins), N = this.binLengths;
      D = this.bins.length;
      for (m = 0; m !== D; m++) {
        N[m] = 0;
      }
      var S = Math.ceil;
      m = Math.min;
      g = Math.max;
      for (m = 0; m !== e; m++) {
        g = b[m];
        var V = g.shape;
        switch(V.type) {
          case Q:
            var M = g.position.x, O = g.position.y, P = g.position.z;
            V = V.radius;
            d(M - V, O - V, P - V, M + V, O + V, P + V, g);
            break;
          case aa:
            V.worldNormalNeedsUpdate && V.computeWorldNormal(g.quaternion);
            P = V.worldNormal;
            V = G + .5 * R - g.position.y;
            var ka = H + .5 * E - g.position.z, ha = n;
            ha.set(B + .5 * A - g.position.x, V, ka);
            for (var ja = M = 0; M !== t; M++, ja += v, ha.y = V, ha.x += A) {
              for (var X = O = 0; O !== p; O++, X += z, ha.z = ka, ha.y += R) {
                for (var fa = 0, ba = 0; fa !== q; fa++, ba += C, ha.z += E) {
                  if (ha.dot(P) < J) {
                    var la = ja + X + ba;
                    U[la][N[la]++] = g;
                  }
                }
              }
            }
            break;
          default:
            g.aabbNeedsUpdate && g.computeAABB(), d(g.aabb.lowerBound.x, g.aabb.lowerBound.y, g.aabb.lowerBound.z, g.aabb.upperBound.x, g.aabb.upperBound.y, g.aabb.upperBound.z, g);
        }
      }
      for (m = 0; m !== D; m++) {
        if (e = N[m], 1 < e) {
          for (b = U[m], M = 0; M !== e; M++) {
            for (g = b[M], O = 0; O !== M; O++) {
              A = b[O], this.needBroadphaseCollision(g, A) && this.intersectionTest(g, A, c, f);
            }
          }
        }
      }
      this.makePairsUnique(c, f);
    };
  }, {"../math/Vec3":30, "../shapes/Shape":43, "./Broadphase":5}], 7:[function(c, g) {
    function b() {
      e.apply(this);
    }
    g.exports = b;
    var e = c("./Broadphase");
    c = c("./AABB");
    b.prototype = new e;
    b.prototype.constructor = b;
    b.prototype.collisionPairs = function(b, c, e) {
      var f, k = b.bodies, g = k.length;
      for (b = 0; b !== g; b++) {
        for (f = 0; f !== b; f++) {
          var d = k[b];
          var l = k[f];
          this.needBroadphaseCollision(d, l) && this.intersectionTest(d, l, c, e);
        }
      }
    };
    new c;
    b.prototype.aabbQuery = function(b, c, e) {
      e = e || [];
      for (var f = 0; f < b.bodies.length; f++) {
        var k = b.bodies[f];
        k.aabbNeedsUpdate && k.computeAABB();
        k.aabb.overlaps(c) && e.push(k);
      }
      return e;
    };
  }, {"./AABB":3, "./Broadphase":5}], 8:[function(c, g) {
    function b() {
      this.matrix = {};
    }
    g.exports = b;
    b.prototype.get = function(b, c) {
      if (b = b.id, c = c.id, c > b) {
        var f = c;
        c = b;
        b = f;
      }
      return b + "-" + c in this.matrix;
    };
    b.prototype.set = function(b, c, k) {
      if (b = b.id, c = c.id, c > b) {
        var f = c;
        c = b;
        b = f;
      }
      k ? this.matrix[b + "-" + c] = !0 : delete this.matrix[b + "-" + c];
    };
    b.prototype.reset = function() {
      this.matrix = {};
    };
    b.prototype.setNumObjects = function() {
    };
  }, {}], 9:[function(c, g) {
    function b(c, d) {
      this.from = c ? c.clone() : new f;
      this.to = d ? d.clone() : new f;
      this._direction = new f;
      this.precision = 1E-4;
      this.checkCollisionResponse = !0;
      this.skipBackfaces = !1;
      this.collisionFilterGroup = this.collisionFilterMask = -1;
      this.mode = b.ANY;
      this.result = new n;
      this.hasHit = !1;
      this.callback = function() {
      };
    }
    function e(b, c, f, e) {
      e.vsub(c, Q);
      f.vsub(c, d);
      b.vsub(c, l);
      var k, g;
      b = Q.dot(Q);
      c = Q.dot(d);
      f = Q.dot(l);
      e = d.dot(d);
      var q = d.dot(l);
      return 0 <= (k = e * f - c * q) && 0 <= (g = b * q - c * f) && b * e - c * c > k + g;
    }
    g.exports = b;
    var f = c("../math/Vec3");
    g = c("../math/Quaternion");
    var k = c("../math/Transform"), n = (c("../shapes/ConvexPolyhedron"), c("../shapes/Box"), c("../collision/RaycastResult")), p = c("../shapes/Shape");
    c = c("../collision/AABB");
    b.prototype.constructor = b;
    b.CLOSEST = 1;
    b.ANY = 2;
    b.ALL = 4;
    var m = new c, t = [];
    b.prototype.intersectWorld = function(c, d) {
      return this.mode = d.mode || b.ANY, this.result = d.result || new n, this.skipBackfaces = !!d.skipBackfaces, this.collisionFilterMask = "undefined" != typeof d.collisionFilterMask ? d.collisionFilterMask : -1, this.collisionFilterGroup = "undefined" != typeof d.collisionFilterGroup ? d.collisionFilterGroup : -1, d.from && this.from.copy(d.from), d.to && this.to.copy(d.to), this.callback = d.callback || function() {
      }, this.hasHit = !1, this.result.reset(), this._updateDirection(), this.getAABB(m), t.length = 0, c.broadphase.aabbQuery(c, m, t), this.intersectBodies(t), this.hasHit;
    };
    var d = new f, l = new f;
    b.pointInTriangle = e;
    var u = new f, w = new g;
    b.prototype.intersectBody = function(b, c) {
      c && (this.result = c, this._updateDirection());
      c = this.checkCollisionResponse;
      if ((!c || b.collisionResponse) && 0 !== (this.collisionFilterGroup & b.collisionFilterMask) && 0 !== (b.collisionFilterGroup & this.collisionFilterMask)) {
        for (var d = 0, f = b.shapes.length; f > d; d++) {
          var e = b.shapes[d];
          if ((!c || e.collisionResponse) && (b.quaternion.mult(b.shapeOrientations[d], w), b.quaternion.vmult(b.shapeOffsets[d], u), u.vadd(b.position, u), this.intersectShape(e, w, u, b), this.result._shouldStop)) {
            break;
          }
        }
      }
    };
    b.prototype.intersectBodies = function(b, c) {
      c && (this.result = c, this._updateDirection());
      c = 0;
      for (var d = b.length; !this.result._shouldStop && d > c; c++) {
        this.intersectBody(b[c]);
      }
    };
    b.prototype._updateDirection = function() {
      this.to.vsub(this.from, this._direction);
      this._direction.normalize();
    };
    b.prototype.intersectShape = function(b, c, d, f) {
      var e = this.from, k = this._direction;
      d.vsub(e, Q);
      var g = Q.dot(k);
      k.mult(g, aa);
      aa.vadd(e, aa);
      d.distanceTo(aa) > b.boundingSphereRadius || (e = this[b.type]) && e.call(this, b, c, d, f);
    };
    var y = (new f, new f, new f), x = new f, q = new f, v = new f;
    new f;
    new n;
    b.prototype.intersectBox = function(b, c, d, f) {
      return this.intersectConvex(b.convexPolyhedronRepresentation, c, d, f);
    };
    b.prototype[p.types.BOX] = b.prototype.intersectBox;
    b.prototype.intersectPlane = function(b, c, d, e) {
      var k = this.from, g = this.to, l = this._direction, q = new f(0, 0, 1);
      c.vmult(q, q);
      var m = new f;
      k.vsub(d, m);
      c = m.dot(q);
      g.vsub(d, m);
      m = m.dot(q);
      if (!(0 < c * m || k.distanceTo(g) < c || (m = q.dot(l), Math.abs(m) < this.precision))) {
        var n = new f;
        g = new f;
        c = new f;
        k.vsub(d, n);
        d = -q.dot(n) / m;
        l.scale(d, g);
        k.vadd(g, c);
        this.reportIntersection(q, c, b, e, -1);
      }
    };
    b.prototype[p.types.PLANE] = b.prototype.intersectPlane;
    b.prototype.getAABB = function(b) {
      var c = this.to, d = this.from;
      b.lowerBound.x = Math.min(c.x, d.x);
      b.lowerBound.y = Math.min(c.y, d.y);
      b.lowerBound.z = Math.min(c.z, d.z);
      b.upperBound.x = Math.max(c.x, d.x);
      b.upperBound.y = Math.max(c.y, d.y);
      b.upperBound.z = Math.max(c.z, d.z);
    };
    var z = {faceList:[0]};
    b.prototype.intersectHeightfield = function(c, d, e, g) {
      var l = (c.data, c.elementSize, new f), q = new b(this.from, this.to);
      k.pointToLocalFrame(e, d, q.from, q.from);
      k.pointToLocalFrame(e, d, q.to, q.to);
      var m = [], n = null, t = null, p = null, v = null, u = c.getIndexOfPosition(q.from.x, q.from.y, m, !1);
      if (u && (n = m[0], t = m[1], p = m[0], v = m[1]), u = c.getIndexOfPosition(q.to.x, q.to.y, m, !1), u && ((null === n || m[0] < n) && (n = m[0]), (null === p || m[0] > p) && (p = m[0]), (null === t || m[1] < t) && (t = m[1]), (null === v || m[1] > v) && (v = m[1])), null !== n) {
        for (q = [], c.getRectMinMax(n, t, p, v, q), n = (q[0], q[1], n); p >= n; n++) {
          for (q = t; v >= q; q++) {
            if (this.result._shouldStop || (c.getConvexTrianglePillar(n, q, !1), k.pointToWorldFrame(e, d, c.pillarOffset, l), this.intersectConvex(c.pillarConvex, d, l, g, z), this.result._shouldStop)) {
              return;
            }
            c.getConvexTrianglePillar(n, q, !0);
            k.pointToWorldFrame(e, d, c.pillarOffset, l);
            this.intersectConvex(c.pillarConvex, d, l, g, z);
          }
        }
      }
    };
    b.prototype[p.types.HEIGHTFIELD] = b.prototype.intersectHeightfield;
    var C = new f, A = new f;
    b.prototype.intersectSphere = function(b, c, d, f) {
      c = this.from;
      var e = this.to, k = Math.pow(e.x - c.x, 2) + Math.pow(e.y - c.y, 2) + Math.pow(e.z - c.z, 2), g = 2 * ((e.x - c.x) * (c.x - d.x) + (e.y - c.y) * (c.y - d.y) + (e.z - c.z) * (c.z - d.z)), l = Math.pow(g, 2) - 4 * k * (Math.pow(c.x - d.x, 2) + Math.pow(c.y - d.y, 2) + Math.pow(c.z - d.z, 2) - Math.pow(b.radius, 2));
      if (!(0 > l)) {
        if (0 === l) {
          c.lerp(e, l, C), C.vsub(d, A), A.normalize(), this.reportIntersection(A, C, b, f, -1);
        } else {
          var q = (-g - Math.sqrt(l)) / (2 * k);
          k = (-g + Math.sqrt(l)) / (2 * k);
          (0 <= q && 1 >= q && (c.lerp(e, q, C), C.vsub(d, A), A.normalize(), this.reportIntersection(A, C, b, f, -1)), this.result._shouldStop) || 0 <= k && 1 >= k && (c.lerp(e, k, C), C.vsub(d, A), A.normalize(), this.reportIntersection(A, C, b, f, -1));
        }
      }
    };
    b.prototype[p.types.SPHERE] = b.prototype.intersectSphere;
    var D = new f, E = (new f, new f, new f);
    b.prototype.intersectConvex = function(b, c, d, f, k) {
      k = k && k.faceList || null;
      for (var g = b.faces, l = b.vertices, m = b.faceNormals, n = this._direction, t = this.from, p = t.distanceTo(this.to), u = k ? k.length : g.length, w = this.result, z = 0; !w._shouldStop && u > z; z++) {
        var C = k ? k[z] : z, B = g[C], A = m[C], G = c, M = d;
        E.copy(l[B[0]]);
        G.vmult(E, E);
        E.vadd(M, E);
        E.vsub(t, E);
        G.vmult(A, D);
        A = n.dot(D);
        if (!(Math.abs(A) < this.precision || (A = D.dot(E) / A, 0 > A))) {
          for (n.mult(A, y), y.vadd(t, y), x.copy(l[B[0]]), G.vmult(x, x), M.vadd(x, x), A = 1; !w._shouldStop && A < B.length - 1; A++) {
            q.copy(l[B[A]]);
            v.copy(l[B[A + 1]]);
            G.vmult(q, q);
            G.vmult(v, v);
            M.vadd(q, q);
            M.vadd(v, v);
            var H = y.distanceTo(t);
            !e(y, x, q, v) && !e(y, q, x, v) || H > p || this.reportIntersection(D, y, b, f, C);
          }
        }
      }
    };
    b.prototype[p.types.CONVEXPOLYHEDRON] = b.prototype.intersectConvex;
    var B = new f, G = new f, H = new f, K = new f, I = new f, L = new f, R = (new c, []), J = new k;
    b.prototype.intersectTrimesh = function(b, c, d, f, g) {
      g = (g && g.faceList || null, b.indices);
      var l = (b.vertices, b.faceNormals, this.from), m = this.to, n = this._direction;
      J.position.copy(d);
      J.quaternion.copy(c);
      k.vectorToLocalFrame(d, c, n, G);
      k.pointToLocalFrame(d, c, l, H);
      k.pointToLocalFrame(d, c, m, K);
      l = H.distanceSquared(K);
      b.tree.rayQuery(this, J, R);
      m = 0;
      for (n = R.length; !this.result._shouldStop && m !== n; m++) {
        var t = R[m];
        b.getNormal(t, B);
        b.getVertex(g[3 * t], x);
        x.vsub(H, E);
        var p = G.dot(B);
        p = B.dot(E) / p;
        0 > p || (G.scale(p, y), y.vadd(H, y), b.getVertex(g[3 * t + 1], q), b.getVertex(g[3 * t + 2], v), p = y.distanceSquared(H), !e(y, q, x, v) && !e(y, x, q, v) || p > l || (k.vectorToWorldFrame(c, B, I), k.pointToWorldFrame(d, c, y, L), this.reportIntersection(I, L, b, f, t)));
      }
      R.length = 0;
    };
    b.prototype[p.types.TRIMESH] = b.prototype.intersectTrimesh;
    b.prototype.reportIntersection = function(c, d, f, e, k) {
      var g = this.from, l = this.to, q = g.distanceTo(d), m = this.result;
      if (!(this.skipBackfaces && 0 < c.dot(this._direction))) {
        switch(m.hitFaceIndex = "undefined" != typeof k ? k : -1, this.mode) {
          case b.ALL:
            this.hasHit = !0;
            m.set(g, l, c, d, f, e, q);
            m.hasHit = !0;
            this.callback(m);
            break;
          case b.CLOSEST:
            (q < m.distance || !m.hasHit) && (this.hasHit = !0, m.hasHit = !0, m.set(g, l, c, d, f, e, q));
            break;
          case b.ANY:
            this.hasHit = !0, m.hasHit = !0, m.set(g, l, c, d, f, e, q), m._shouldStop = !0;
        }
      }
    };
    var Q = new f, aa = new f;
  }, {"../collision/AABB":3, "../collision/RaycastResult":10, "../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "../shapes/Box":37, "../shapes/ConvexPolyhedron":38, "../shapes/Shape":43}], 10:[function(c, g) {
    function b() {
      this.rayFromWorld = new e;
      this.rayToWorld = new e;
      this.hitNormalWorld = new e;
      this.hitPointWorld = new e;
      this.hasHit = !1;
      this.body = this.shape = null;
      this.distance = this.hitFaceIndex = -1;
      this._shouldStop = !1;
    }
    var e = c("../math/Vec3");
    g.exports = b;
    b.prototype.reset = function() {
      this.rayFromWorld.setZero();
      this.rayToWorld.setZero();
      this.hitNormalWorld.setZero();
      this.hitPointWorld.setZero();
      this.hasHit = !1;
      this.body = this.shape = null;
      this.distance = this.hitFaceIndex = -1;
      this._shouldStop = !1;
    };
    b.prototype.abort = function() {
      this._shouldStop = !0;
    };
    b.prototype.set = function(b, c, e, g, m, t, d) {
      this.rayFromWorld.copy(b);
      this.rayToWorld.copy(c);
      this.hitNormalWorld.copy(e);
      this.hitPointWorld.copy(g);
      this.shape = m;
      this.body = t;
      this.distance = d;
    };
  }, {"../math/Vec3":30}], 11:[function(c, g) {
    function b(b) {
      e.apply(this);
      this.axisList = [];
      this.world = null;
      this.axisIndex = 0;
      var c = this.axisList;
      this._addBodyHandler = function(b) {
        c.push(b.body);
      };
      this._removeBodyHandler = function(b) {
        b = c.indexOf(b.body);
        -1 !== b && c.splice(b, 1);
      };
      b && this.setWorld(b);
    }
    var e = (c("../shapes/Shape"), c("../collision/Broadphase"));
    g.exports = b;
    b.prototype = new e;
    b.prototype.setWorld = function(b) {
      for (var c = this.axisList.length = 0; c < b.bodies.length; c++) {
        this.axisList.push(b.bodies[c]);
      }
      b.removeEventListener("addBody", this._addBodyHandler);
      b.removeEventListener("removeBody", this._removeBodyHandler);
      b.addEventListener("addBody", this._addBodyHandler);
      b.addEventListener("removeBody", this._removeBodyHandler);
      this.world = b;
      this.dirty = !0;
    };
    b.insertionSortX = function(b) {
      for (var c = 1, f = b.length; f > c; c++) {
        for (var e = b[c], g = c - 1; 0 <= g && !(b[g].aabb.lowerBound.x <= e.aabb.lowerBound.x); g--) {
          b[g + 1] = b[g];
        }
        b[g + 1] = e;
      }
      return b;
    };
    b.insertionSortY = function(b) {
      for (var c = 1, e = b.length; e > c; c++) {
        for (var f = b[c], g = c - 1; 0 <= g && !(b[g].aabb.lowerBound.y <= f.aabb.lowerBound.y); g--) {
          b[g + 1] = b[g];
        }
        b[g + 1] = f;
      }
      return b;
    };
    b.insertionSortZ = function(b) {
      for (var c = 1, e = b.length; e > c; c++) {
        for (var f = b[c], g = c - 1; 0 <= g && !(b[g].aabb.lowerBound.z <= f.aabb.lowerBound.z); g--) {
          b[g + 1] = b[g];
        }
        b[g + 1] = f;
      }
      return b;
    };
    b.prototype.collisionPairs = function(c, e, g) {
      var f, k = this.axisList, n = k.length, d = this.axisIndex;
      this.dirty && (this.sortList(), this.dirty = !1);
      for (c = 0; c !== n; c++) {
        var l = k[c];
        for (f = c + 1; n > f; f++) {
          var u = k[f];
          if (this.needBroadphaseCollision(l, u)) {
            if (!b.checkBounds(l, u, d)) {
              break;
            }
            this.intersectionTest(l, u, e, g);
          }
        }
      }
    };
    b.prototype.sortList = function() {
      for (var c = this.axisList, e = this.axisIndex, g = c.length, p = 0; p !== g; p++) {
        var m = c[p];
        m.aabbNeedsUpdate && m.computeAABB();
      }
      0 === e ? b.insertionSortX(c) : 1 === e ? b.insertionSortY(c) : 2 === e && b.insertionSortZ(c);
    };
    b.checkBounds = function(b, c, e) {
      var f, k;
      0 === e ? (f = b.position.x, k = c.position.x) : 1 === e ? (f = b.position.y, k = c.position.y) : 2 === e && (f = b.position.z, k = c.position.z);
      return f + b.boundingRadius > k - c.boundingRadius;
    };
    b.prototype.autoDetectAxis = function() {
      for (var b = 0, c = 0, e = 0, g = 0, m = 0, t = 0, d = this.axisList, l = d.length, u = 1 / l, w = 0; w !== l; w++) {
        var y = d[w], x = y.position.x;
        b += x;
        c += x * x;
        x = y.position.y;
        e += x;
        g += x * x;
        y = y.position.z;
        m += y;
        t += y * y;
      }
      b = c - b * b * u;
      e = g - e * e * u;
      m = t - m * m * u;
      this.axisIndex = b > e ? b > m ? 0 : 2 : e > m ? 1 : 2;
    };
    b.prototype.aabbQuery = function(b, c, e) {
      e = e || [];
      this.dirty && (this.sortList(), this.dirty = !1);
      b = this.axisIndex;
      var f = "x";
      1 === b && (f = "y");
      2 === b && (f = "z");
      b = this.axisList;
      for (f = (c.lowerBound[f], c.upperBound[f], 0); f < b.length; f++) {
        var k = b[f];
        k.aabbNeedsUpdate && k.computeAABB();
        k.aabb.overlaps(c) && e.push(k);
      }
      return e;
    };
  }, {"../collision/Broadphase":5, "../shapes/Shape":43}], 12:[function(c, g) {
    function b(b, c, g) {
      g = g || {};
      var d = "undefined" != typeof g.maxForce ? g.maxForce : 1E6, l = g.pivotA ? g.pivotA.clone() : new n, m = g.pivotB ? g.pivotB.clone() : new n;
      this.axisA = g.axisA ? g.axisA.clone() : new n;
      this.axisB = g.axisB ? g.axisB.clone() : new n;
      e.call(this, b, l, c, m, d);
      this.collideConnected = !!g.collideConnected;
      this.angle = "undefined" != typeof g.angle ? g.angle : 0;
      l = this.coneEquation = new f(b, c, g);
      b = this.twistEquation = new k(b, c, g);
      this.twistAngle = "undefined" != typeof g.twistAngle ? g.twistAngle : 0;
      l.maxForce = 0;
      l.minForce = -d;
      b.maxForce = 0;
      b.minForce = -d;
      this.equations.push(l, b);
    }
    g.exports = b;
    var e = (c("./Constraint"), c("./PointToPointConstraint")), f = c("../equations/ConeEquation"), k = c("../equations/RotationalEquation"), n = (c("../equations/ContactEquation"), c("../math/Vec3"));
    b.prototype = new e;
    b.constructor = b;
    new n;
    new n;
    b.prototype.update = function() {
      var b = this.bodyA, c = this.bodyB, f = this.coneEquation, d = this.twistEquation;
      e.prototype.update.call(this);
      b.vectorToWorldFrame(this.axisA, f.axisA);
      c.vectorToWorldFrame(this.axisB, f.axisB);
      this.axisA.tangents(d.axisA, d.axisA);
      b.vectorToWorldFrame(d.axisA, d.axisA);
      this.axisB.tangents(d.axisB, d.axisB);
      c.vectorToWorldFrame(d.axisB, d.axisB);
      f.angle = this.angle;
      d.maxAngle = this.twistAngle;
    };
  }, {"../equations/ConeEquation":18, "../equations/ContactEquation":19, "../equations/RotationalEquation":22, "../math/Vec3":30, "./Constraint":13, "./PointToPointConstraint":17}], 13:[function(c, g) {
    function b(c, k, g) {
      g = e.defaults(g, {collideConnected:!0, wakeUpBodies:!0});
      this.equations = [];
      this.bodyA = c;
      this.bodyB = k;
      this.id = b.idCounter++;
      this.collideConnected = g.collideConnected;
      g.wakeUpBodies && (c && c.wakeUp(), k && k.wakeUp());
    }
    g.exports = b;
    var e = c("../utils/Utils");
    b.prototype.update = function() {
      throw Error("method update() not implmemented in this Constraint subclass!");
    };
    b.prototype.enable = function() {
      for (var b = this.equations, c = 0; c < b.length; c++) {
        b[c].enabled = !0;
      }
    };
    b.prototype.disable = function() {
      for (var b = this.equations, c = 0; c < b.length; c++) {
        b[c].enabled = !1;
      }
    };
    b.idCounter = 0;
  }, {"../utils/Utils":53}], 14:[function(c, g) {
    function b(b, c, g, m) {
      e.call(this, b, c);
      "undefined" == typeof g && (g = b.position.distanceTo(c.position));
      "undefined" == typeof m && (m = 1E6);
      this.distance = g;
      b = this.distanceEquation = new f(b, c);
      this.equations.push(b);
      b.minForce = -m;
      b.maxForce = m;
    }
    g.exports = b;
    var e = c("./Constraint"), f = c("../equations/ContactEquation");
    b.prototype = new e;
    b.prototype.update = function() {
      var b = this.distanceEquation, c = .5 * this.distance, e = b.ni;
      this.bodyB.position.vsub(this.bodyA.position, e);
      e.normalize();
      e.mult(c, b.ri);
      e.mult(-c, b.rj);
    };
  }, {"../equations/ContactEquation":19, "./Constraint":13}], 15:[function(c, g) {
    function b(b, c, g) {
      g = g || {};
      var d = "undefined" != typeof g.maxForce ? g.maxForce : 1E6, l = g.pivotA ? g.pivotA.clone() : new n, m = g.pivotB ? g.pivotB.clone() : new n;
      e.call(this, b, l, c, m, d);
      (this.axisA = g.axisA ? g.axisA.clone() : new n(1, 0, 0)).normalize();
      (this.axisB = g.axisB ? g.axisB.clone() : new n(1, 0, 0)).normalize();
      l = this.rotationalEquation1 = new f(b, c, g);
      g = this.rotationalEquation2 = new f(b, c, g);
      b = this.motorEquation = new k(b, c, d);
      b.enabled = !1;
      this.equations.push(l, g, b);
    }
    g.exports = b;
    var e = (c("./Constraint"), c("./PointToPointConstraint")), f = c("../equations/RotationalEquation"), k = c("../equations/RotationalMotorEquation"), n = (c("../equations/ContactEquation"), c("../math/Vec3"));
    b.prototype = new e;
    b.constructor = b;
    b.prototype.enableMotor = function() {
      this.motorEquation.enabled = !0;
    };
    b.prototype.disableMotor = function() {
      this.motorEquation.enabled = !1;
    };
    b.prototype.setMotorSpeed = function(b) {
      this.motorEquation.targetVelocity = b;
    };
    b.prototype.setMotorMaxForce = function(b) {
      this.motorEquation.maxForce = b;
      this.motorEquation.minForce = -b;
    };
    var p = new n, m = new n;
    b.prototype.update = function() {
      var b = this.bodyA, c = this.bodyB, f = this.motorEquation, k = this.rotationalEquation1, g = this.rotationalEquation2, n = this.axisA, x = this.axisB;
      e.prototype.update.call(this);
      b.quaternion.vmult(n, p);
      c.quaternion.vmult(x, m);
      p.tangents(k.axisA, g.axisA);
      k.axisB.copy(m);
      g.axisB.copy(m);
      this.motorEquation.enabled && (b.quaternion.vmult(this.axisA, f.axisA), c.quaternion.vmult(this.axisB, f.axisB));
    };
  }, {"../equations/ContactEquation":19, "../equations/RotationalEquation":22, "../equations/RotationalMotorEquation":23, "../math/Vec3":30, "./Constraint":13, "./PointToPointConstraint":17}], 16:[function(c, g) {
    function b(b, c, g) {
      g = g || {};
      var m = "undefined" != typeof g.maxForce ? g.maxForce : 1E6, d = new k, l = new k, n = new k;
      b.position.vadd(c.position, n);
      n.scale(.5, n);
      c.pointToLocalFrame(n, l);
      b.pointToLocalFrame(n, d);
      e.call(this, b, d, c, l, m);
      m = this.rotationalEquation1 = new f(b, c, g);
      d = this.rotationalEquation2 = new f(b, c, g);
      b = this.rotationalEquation3 = new f(b, c, g);
      this.equations.push(m, d, b);
    }
    g.exports = b;
    var e = (c("./Constraint"), c("./PointToPointConstraint")), f = c("../equations/RotationalEquation"), k = (c("../equations/RotationalMotorEquation"), c("../equations/ContactEquation"), c("../math/Vec3"));
    b.prototype = new e;
    b.constructor = b;
    new k;
    new k;
    b.prototype.update = function() {
      var b = this.bodyA, c = this.bodyB, f = (this.motorEquation, this.rotationalEquation1), g = this.rotationalEquation2, d = this.rotationalEquation3;
      e.prototype.update.call(this);
      b.vectorToWorldFrame(k.UNIT_X, f.axisA);
      c.vectorToWorldFrame(k.UNIT_Y, f.axisB);
      b.vectorToWorldFrame(k.UNIT_Y, g.axisA);
      c.vectorToWorldFrame(k.UNIT_Z, g.axisB);
      b.vectorToWorldFrame(k.UNIT_Z, d.axisA);
      c.vectorToWorldFrame(k.UNIT_X, d.axisB);
    };
  }, {"../equations/ContactEquation":19, "../equations/RotationalEquation":22, "../equations/RotationalMotorEquation":23, "../math/Vec3":30, "./Constraint":13, "./PointToPointConstraint":17}], 17:[function(c, g) {
    function b(b, c, g, t, d) {
      e.call(this, b, g);
      d = "undefined" != typeof d ? d : 1E6;
      this.pivotA = c ? c.clone() : new k;
      this.pivotB = t ? t.clone() : new k;
      c = this.equationX = new f(b, g);
      t = this.equationY = new f(b, g);
      b = this.equationZ = new f(b, g);
      this.equations.push(c, t, b);
      c.minForce = t.minForce = b.minForce = -d;
      c.maxForce = t.maxForce = b.maxForce = d;
      c.ni.set(1, 0, 0);
      t.ni.set(0, 1, 0);
      b.ni.set(0, 0, 1);
    }
    g.exports = b;
    var e = c("./Constraint"), f = c("../equations/ContactEquation"), k = c("../math/Vec3");
    b.prototype = new e;
    b.prototype.update = function() {
      var b = this.bodyB, c = this.equationX, e = this.equationY, f = this.equationZ;
      this.bodyA.quaternion.vmult(this.pivotA, c.ri);
      b.quaternion.vmult(this.pivotB, c.rj);
      e.ri.copy(c.ri);
      e.rj.copy(c.rj);
      f.ri.copy(c.ri);
      f.rj.copy(c.rj);
    };
  }, {"../equations/ContactEquation":19, "../math/Vec3":30, "./Constraint":13}], 18:[function(c, g) {
    function b(b, c, k) {
      k = k || {};
      var d = "undefined" != typeof k.maxForce ? k.maxForce : 1E6;
      f.call(this, b, c, -d, d);
      this.axisA = k.axisA ? k.axisA.clone() : new e(1, 0, 0);
      this.axisB = k.axisB ? k.axisB.clone() : new e(0, 1, 0);
      this.angle = "undefined" != typeof k.angle ? k.angle : 0;
    }
    g.exports = b;
    var e = c("../math/Vec3"), f = (c("../math/Mat3"), c("./Equation"));
    b.prototype = new f;
    b.prototype.constructor = b;
    var k = new e, n = new e;
    b.prototype.computeB = function(b) {
      var c = this.a, e = this.b, d = this.axisA, f = this.axisB, g = this.jacobianElementA, p = this.jacobianElementB;
      d.cross(f, k);
      f.cross(d, n);
      g.rotational.copy(n);
      p.rotational.copy(k);
      d = Math.cos(this.angle) - d.dot(f);
      f = this.computeGW();
      g = this.computeGiMf();
      return -d * c - f * e - b * g;
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 19:[function(c, g) {
    function b(b, c, d) {
      e.call(this, b, c, 0, "undefined" != typeof d ? d : 1E6);
      this.restitution = 0;
      this.ri = new f;
      this.rj = new f;
      this.ni = new f;
    }
    g.exports = b;
    var e = c("./Equation"), f = c("../math/Vec3");
    c("../math/Mat3");
    b.prototype = new e;
    b.prototype.constructor = b;
    var k = new f, n = new f, p = new f;
    b.prototype.computeB = function(b) {
      var c = this.a, d = this.b, e = this.bi, f = this.bj, g = this.ri, l = this.rj, m = e.velocity, t = e.angularVelocity, u = (e.force, e.torque, f.velocity), w = f.angularVelocity, G = (f.force, f.torque, p), H = this.jacobianElementA, K = this.jacobianElementB, I = this.ni;
      g.cross(I, k);
      l.cross(I, n);
      I.negate(H.spatial);
      k.negate(H.rotational);
      K.spatial.copy(I);
      K.rotational.copy(n);
      G.copy(f.position);
      G.vadd(l, G);
      G.vsub(e.position, G);
      G.vsub(g, G);
      e = I.dot(G);
      f = this.restitution + 1;
      m = f * u.dot(I) - f * m.dot(I) + w.dot(n) - t.dot(k);
      t = this.computeGiMf();
      return -e * c - m * d - b * t;
    };
    var m = new f, t = new f, d = new f, l = new f, u = new f;
    b.prototype.getImpactVelocityAlongNormal = function() {
      return this.bi.position.vadd(this.ri, d), this.bj.position.vadd(this.rj, l), this.bi.getVelocityAtWorldPoint(d, m), this.bj.getVelocityAtWorldPoint(l, t), m.vsub(t, u), this.ni.dot(u);
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 20:[function(c, g) {
    function b(c, d, f, k) {
      this.id = b.id++;
      this.minForce = "undefined" == typeof f ? -1E6 : f;
      this.maxForce = "undefined" == typeof k ? 1E6 : k;
      this.bi = c;
      this.bj = d;
      this.eps = this.b = this.a = 0;
      this.jacobianElementA = new e;
      this.jacobianElementB = new e;
      this.enabled = !0;
      this.setSpookParams(1E7, 4, 1 / 60);
    }
    g.exports = b;
    var e = c("../math/JacobianElement");
    c = c("../math/Vec3");
    b.prototype.constructor = b;
    b.id = 0;
    b.prototype.setSpookParams = function(b, c, d) {
      this.a = 4 / (d * (1 + 4 * c));
      this.b = 4 * c / (1 + 4 * c);
      this.eps = 4 / (d * d * b * (1 + 4 * c));
    };
    b.prototype.computeB = function(b, c, d) {
      var e = this.computeGW(), f = this.computeGq(), k = this.computeGiMf();
      return -f * b - e * c - k * d;
    };
    b.prototype.computeGq = function() {
      var b = this.jacobianElementB, c = this.bj.position;
      return this.jacobianElementA.spatial.dot(this.bi.position) + b.spatial.dot(c);
    };
    var f = new c;
    b.prototype.computeGW = function() {
      var b = this.jacobianElementB, c = this.bi, d = this.bj, e = d.velocity;
      d = d.angularVelocity || f;
      return this.jacobianElementA.multiplyVectors(c.velocity, c.angularVelocity || f) + b.multiplyVectors(e, d);
    };
    b.prototype.computeGWlambda = function() {
      var b = this.jacobianElementB, c = this.bi, d = this.bj, e = d.vlambda;
      d = d.wlambda || f;
      return this.jacobianElementA.multiplyVectors(c.vlambda, c.wlambda || f) + b.multiplyVectors(e, d);
    };
    var k = new c, n = new c, p = new c, m = new c;
    b.prototype.computeGiMf = function() {
      var b = this.jacobianElementA, c = this.jacobianElementB, d = this.bi, e = this.bj, f = d.force, g = d.torque, t = e.force, z = e.torque, C = d.invMassSolve, A = e.invMassSolve;
      return d.invInertiaWorldSolve ? d.invInertiaWorldSolve.vmult(g, p) : p.set(0, 0, 0), e.invInertiaWorldSolve ? e.invInertiaWorldSolve.vmult(z, m) : m.set(0, 0, 0), f.mult(C, k), t.mult(A, n), b.multiplyVectors(k, p) + c.multiplyVectors(n, m);
    };
    var t = new c;
    b.prototype.computeGiMGt = function() {
      var b = this.jacobianElementA, c = this.jacobianElementB, d = this.bi, e = this.bj, f = d.invInertiaWorldSolve, k = e.invInertiaWorldSolve;
      d = d.invMassSolve + e.invMassSolve;
      return f && (f.vmult(b.rotational, t), d += t.dot(b.rotational)), k && (k.vmult(c.rotational, t), d += t.dot(c.rotational)), d;
    };
    var d = new c;
    new c;
    new c;
    new c;
    new c;
    new c;
    b.prototype.addToWlambda = function(b) {
      var c = this.jacobianElementA, e = this.jacobianElementB, f = this.bi, k = this.bj;
      c.spatial.mult(f.invMassSolve * b, d);
      f.vlambda.vadd(d, f.vlambda);
      e.spatial.mult(k.invMassSolve * b, d);
      k.vlambda.vadd(d, k.vlambda);
      f.invInertiaWorldSolve && (f.invInertiaWorldSolve.vmult(c.rotational, d), d.mult(b, d), f.wlambda.vadd(d, f.wlambda));
      k.invInertiaWorldSolve && (k.invInertiaWorldSolve.vmult(e.rotational, d), d.mult(b, d), k.wlambda.vadd(d, k.wlambda));
    };
    b.prototype.computeC = function() {
      return this.computeGiMGt() + this.eps;
    };
  }, {"../math/JacobianElement":26, "../math/Vec3":30}], 21:[function(c, g) {
    function b(b, c, k) {
      e.call(this, b, c, -k, k);
      this.ri = new f;
      this.rj = new f;
      this.t = new f;
    }
    g.exports = b;
    var e = c("./Equation"), f = c("../math/Vec3");
    c("../math/Mat3");
    b.prototype = new e;
    b.prototype.constructor = b;
    var k = new f, n = new f;
    b.prototype.computeB = function(b) {
      var c = (this.a, this.b), e = (this.bi, this.bj, this.ri), d = this.rj, f = this.t;
      e.cross(f, k);
      d.cross(f, n);
      e = this.jacobianElementA;
      d = this.jacobianElementB;
      f.negate(e.spatial);
      k.negate(e.rotational);
      d.spatial.copy(f);
      d.rotational.copy(n);
      f = this.computeGW();
      e = this.computeGiMf();
      return -f * c - b * e;
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 22:[function(c, g) {
    function b(b, c, k) {
      k = k || {};
      var d = "undefined" != typeof k.maxForce ? k.maxForce : 1E6;
      f.call(this, b, c, -d, d);
      this.axisA = k.axisA ? k.axisA.clone() : new e(1, 0, 0);
      this.axisB = k.axisB ? k.axisB.clone() : new e(0, 1, 0);
      this.maxAngle = Math.PI / 2;
    }
    g.exports = b;
    var e = c("../math/Vec3"), f = (c("../math/Mat3"), c("./Equation"));
    b.prototype = new f;
    b.prototype.constructor = b;
    var k = new e, n = new e;
    b.prototype.computeB = function(b) {
      var c = this.a, e = this.b, d = this.axisA, f = this.axisB, g = this.jacobianElementA, p = this.jacobianElementB;
      d.cross(f, k);
      f.cross(d, n);
      g.rotational.copy(n);
      p.rotational.copy(k);
      d = Math.cos(this.maxAngle) - d.dot(f);
      f = this.computeGW();
      g = this.computeGiMf();
      return -d * c - f * e - b * g;
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 23:[function(c, g) {
    function b(b, c, g) {
      g = "undefined" != typeof g ? g : 1E6;
      f.call(this, b, c, -g, g);
      this.axisA = new e;
      this.axisB = new e;
      this.targetVelocity = 0;
    }
    g.exports = b;
    var e = c("../math/Vec3"), f = (c("../math/Mat3"), c("./Equation"));
    b.prototype = new f;
    b.prototype.constructor = b;
    b.prototype.computeB = function(b) {
      var c = (this.a, this.b), e = (this.bi, this.bj, this.axisA), f = this.axisB, k = this.jacobianElementB;
      this.jacobianElementA.rotational.copy(e);
      f.negate(k.rotational);
      e = this.computeGW() - this.targetVelocity;
      f = this.computeGiMf();
      return -e * c - b * f;
    };
  }, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 24:[function(c, g) {
    function b(c, k, g) {
      g = e.defaults(g, {friction:.3, restitution:.3, contactEquationStiffness:1E7, contactEquationRelaxation:3, frictionEquationStiffness:1E7, frictionEquationRelaxation:3});
      this.id = b.idCounter++;
      this.materials = [c, k];
      this.friction = g.friction;
      this.restitution = g.restitution;
      this.contactEquationStiffness = g.contactEquationStiffness;
      this.contactEquationRelaxation = g.contactEquationRelaxation;
      this.frictionEquationStiffness = g.frictionEquationStiffness;
      this.frictionEquationRelaxation = g.frictionEquationRelaxation;
    }
    var e = c("../utils/Utils");
    g.exports = b;
    b.idCounter = 0;
  }, {"../utils/Utils":53}], 25:[function(c, g) {
    function b(c) {
      var e = "";
      c = c || {};
      "string" == typeof c ? (e = c, c = {}) : "object" == typeof c && (e = "");
      this.name = e;
      this.id = b.idCounter++;
      this.friction = "undefined" != typeof c.friction ? c.friction : -1;
      this.restitution = "undefined" != typeof c.restitution ? c.restitution : -1;
    }
    g.exports = b;
    b.idCounter = 0;
  }, {}], 26:[function(c, g) {
    function b() {
      this.spatial = new e;
      this.rotational = new e;
    }
    g.exports = b;
    var e = c("./Vec3");
    b.prototype.multiplyElement = function(b) {
      return b.spatial.dot(this.spatial) + b.rotational.dot(this.rotational);
    };
    b.prototype.multiplyVectors = function(b, c) {
      return b.dot(this.spatial) + c.dot(this.rotational);
    };
  }, {"./Vec3":30}], 27:[function(c, g) {
    function b(b) {
      this.elements = b ? b : [0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    g.exports = b;
    var e = c("./Vec3");
    b.prototype.identity = function() {
      var b = this.elements;
      b[0] = 1;
      b[1] = 0;
      b[2] = 0;
      b[3] = 0;
      b[4] = 1;
      b[5] = 0;
      b[6] = 0;
      b[7] = 0;
      b[8] = 1;
    };
    b.prototype.setZero = function() {
      var b = this.elements;
      b[0] = 0;
      b[1] = 0;
      b[2] = 0;
      b[3] = 0;
      b[4] = 0;
      b[5] = 0;
      b[6] = 0;
      b[7] = 0;
      b[8] = 0;
    };
    b.prototype.setTrace = function(b) {
      var c = this.elements;
      c[0] = b.x;
      c[4] = b.y;
      c[8] = b.z;
    };
    b.prototype.getTrace = function(b) {
      b = b || new e;
      var c = this.elements;
      b.x = c[0];
      b.y = c[4];
      b.z = c[8];
    };
    b.prototype.vmult = function(b, c) {
      c = c || new e;
      var f = this.elements, k = b.x, g = b.y;
      b = b.z;
      return c.x = f[0] * k + f[1] * g + f[2] * b, c.y = f[3] * k + f[4] * g + f[5] * b, c.z = f[6] * k + f[7] * g + f[8] * b, c;
    };
    b.prototype.smult = function(b) {
      for (var c = 0; c < this.elements.length; c++) {
        this.elements[c] *= b;
      }
    };
    b.prototype.mmult = function(c, e) {
      e = e || new b;
      for (var f = 0; 3 > f; f++) {
        for (var k = 0; 3 > k; k++) {
          for (var g = 0, t = 0; 3 > t; t++) {
            g += c.elements[f + 3 * t] * this.elements[t + 3 * k];
          }
          e.elements[f + 3 * k] = g;
        }
      }
      return e;
    };
    b.prototype.scale = function(c, e) {
      e = e || new b;
      for (var f = this.elements, k = e.elements, g = 0; 3 !== g; g++) {
        k[3 * g] = c.x * f[3 * g], k[3 * g + 1] = c.y * f[3 * g + 1], k[3 * g + 2] = c.z * f[3 * g + 2];
      }
      return e;
    };
    b.prototype.solve = function(b, c) {
      c = c || new e;
      for (var f = [], k = 0; 12 > k; k++) {
        f.push(0);
      }
      var g;
      for (k = 0; 3 > k; k++) {
        for (g = 0; 3 > g; g++) {
          f[k + 4 * g] = this.elements[k + 3 * g];
        }
      }
      f[3] = b.x;
      f[7] = b.y;
      f[11] = b.z;
      var t = 3, d = t;
      do {
        if (k = d - t, 0 === f[k + 4 * k]) {
          for (g = k + 1; d > g; g++) {
            if (0 !== f[k + 4 * g]) {
              var l = 4;
              do {
                var u = 4 - l;
                f[u + 4 * k] += f[u + 4 * g];
              } while (--l);
              break;
            }
          }
        }
        if (0 !== f[k + 4 * k]) {
          for (g = k + 1; d > g; g++) {
            var w = f[k + 4 * g] / f[k + 4 * k];
            l = 4;
            do {
              u = 4 - l, f[u + 4 * g] = k >= u ? 0 : f[u + 4 * g] - f[u + 4 * k] * w;
            } while (--l);
          }
        }
      } while (--t);
      if (c.z = f[11] / f[10], c.y = (f[7] - f[6] * c.z) / f[5], c.x = (f[3] - f[2] * c.z - f[1] * c.y) / f[0], isNaN(c.x) || isNaN(c.y) || isNaN(c.z) || 1 / 0 === c.x || 1 / 0 === c.y || 1 / 0 === c.z) {
        throw "Could not solve equation! Got x=[" + c.toString() + "], b=[" + b.toString() + "], A=[" + this.toString() + "]";
      }
      return c;
    };
    b.prototype.e = function(b, c, e) {
      return void 0 === e ? this.elements[c + 3 * b] : void(this.elements[c + 3 * b] = e);
    };
    b.prototype.copy = function(b) {
      for (var c = 0; c < b.elements.length; c++) {
        this.elements[c] = b.elements[c];
      }
      return this;
    };
    b.prototype.toString = function() {
      for (var b = "", c = 0; 9 > c; c++) {
        b += this.elements[c] + ",";
      }
      return b;
    };
    b.prototype.reverse = function(c) {
      c = c || new b;
      for (var e = [], f = 0; 18 > f; f++) {
        e.push(0);
      }
      var g;
      for (f = 0; 3 > f; f++) {
        for (g = 0; 3 > g; g++) {
          e[f + 6 * g] = this.elements[f + 3 * g];
        }
      }
      e[3] = 1;
      e[9] = 0;
      e[15] = 0;
      e[4] = 0;
      e[10] = 1;
      e[16] = 0;
      e[5] = 0;
      e[11] = 0;
      e[17] = 1;
      var m = 3, t = m;
      do {
        if (f = t - m, 0 === e[f + 6 * f]) {
          for (g = f + 1; t > g; g++) {
            if (0 !== e[f + 6 * g]) {
              var d = 6;
              do {
                var l = 6 - d;
                e[l + 6 * f] += e[l + 6 * g];
              } while (--d);
              break;
            }
          }
        }
        if (0 !== e[f + 6 * f]) {
          for (g = f + 1; t > g; g++) {
            var u = e[f + 6 * g] / e[f + 6 * f];
            d = 6;
            do {
              l = 6 - d, e[l + 6 * g] = f >= l ? 0 : e[l + 6 * g] - e[l + 6 * f] * u;
            } while (--d);
          }
        }
      } while (--m);
      f = 2;
      do {
        g = f - 1;
        do {
          u = e[f + 6 * g] / e[f + 6 * f];
          d = 6;
          do {
            l = 6 - d, e[l + 6 * g] -= e[l + 6 * f] * u;
          } while (--d);
        } while (g--);
      } while (--f);
      f = 2;
      do {
        u = 1 / e[f + 6 * f];
        d = 6;
        do {
          l = 6 - d, e[l + 6 * f] *= u;
        } while (--d);
      } while (f--);
      f = 2;
      do {
        g = 2;
        do {
          if (l = e[3 + g + 6 * f], isNaN(l) || 1 / 0 === l) {
            throw "Could not reverse! A=[" + this.toString() + "]";
          }
          c.e(f, g, l);
        } while (g--);
      } while (f--);
      return c;
    };
    b.prototype.setRotationFromQuaternion = function(b) {
      var c = b.x, e = b.y, f = b.z, g = b.w, t = c + c, d = e + e, l = f + f;
      b = c * t;
      var u = c * d;
      c *= l;
      var w = e * d;
      e *= l;
      f *= l;
      t *= g;
      d *= g;
      g *= l;
      l = this.elements;
      return l[0] = 1 - (w + f), l[1] = u - g, l[2] = c + d, l[3] = u + g, l[4] = 1 - (b + f), l[5] = e - t, l[6] = c - d, l[7] = e + t, l[8] = 1 - (b + w), this;
    };
    b.prototype.transpose = function(c) {
      c = c || new b;
      for (var e = c.elements, f = this.elements, g = 0; 3 !== g; g++) {
        for (var m = 0; 3 !== m; m++) {
          e[3 * g + m] = f[3 * m + g];
        }
      }
      return c;
    };
  }, {"./Vec3":30}], 28:[function(c, g) {
    function b(b, c, e, f) {
      this.x = void 0 !== b ? b : 0;
      this.y = void 0 !== c ? c : 0;
      this.z = void 0 !== e ? e : 0;
      this.w = void 0 !== f ? f : 1;
    }
    g.exports = b;
    var e = c("./Vec3");
    b.prototype.set = function(b, c, e, f) {
      this.x = b;
      this.y = c;
      this.z = e;
      this.w = f;
    };
    b.prototype.toString = function() {
      return this.x + "," + this.y + "," + this.z + "," + this.w;
    };
    b.prototype.toArray = function() {
      return [this.x, this.y, this.z, this.w];
    };
    b.prototype.setFromAxisAngle = function(b, c) {
      var d = Math.sin(.5 * c);
      this.x = b.x * d;
      this.y = b.y * d;
      this.z = b.z * d;
      this.w = Math.cos(.5 * c);
    };
    b.prototype.toAxisAngle = function(b) {
      b = b || new e;
      this.normalize();
      var c = 2 * Math.acos(this.w), f = Math.sqrt(1 - this.w * this.w);
      return .001 > f ? (b.x = this.x, b.y = this.y, b.z = this.z) : (b.x = this.x / f, b.y = this.y / f, b.z = this.z / f), [b, c];
    };
    var f = new e, k = new e;
    b.prototype.setFromVectors = function(b, c) {
      if (b.isAntiparallelTo(c)) {
        b.tangents(f, k), this.setFromAxisAngle(f, Math.PI);
      } else {
        var d = b.cross(c);
        this.x = d.x;
        this.y = d.y;
        this.z = d.z;
        this.w = Math.sqrt(Math.pow(b.norm(), 2) * Math.pow(c.norm(), 2)) + b.dot(c);
        this.normalize();
      }
    };
    var n = new e, p = new e, m = new e;
    b.prototype.mult = function(c, d) {
      d = d || new b;
      var e = this.w;
      return n.set(this.x, this.y, this.z), p.set(c.x, c.y, c.z), d.w = e * c.w - n.dot(p), n.cross(p, m), d.x = e * p.x + c.w * n.x + m.x, d.y = e * p.y + c.w * n.y + m.y, d.z = e * p.z + c.w * n.z + m.z, d;
    };
    b.prototype.inverse = function(c) {
      var d = this.x, e = this.y, f = this.z, k = this.w;
      c = c || new b;
      this.conjugate(c);
      d = 1 / (d * d + e * e + f * f + k * k);
      return c.x *= d, c.y *= d, c.z *= d, c.w *= d, c;
    };
    b.prototype.conjugate = function(c) {
      return c = c || new b, c.x = -this.x, c.y = -this.y, c.z = -this.z, c.w = this.w, c;
    };
    b.prototype.normalize = function() {
      var b = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      0 === b ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (b = 1 / b, this.x *= b, this.y *= b, this.z *= b, this.w *= b);
    };
    b.prototype.normalizeFast = function() {
      var b = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
      0 === b ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= b, this.y *= b, this.z *= b, this.w *= b);
    };
    b.prototype.vmult = function(b, c) {
      c = c || new e;
      var d = b.x, f = b.y, k = b.z;
      b = this.x;
      var g = this.y, m = this.z, q = this.w, n = q * d + g * k - m * f, t = q * f + m * d - b * k, p = q * k + b * f - g * d;
      d = -b * d - g * f - m * k;
      return c.x = n * q + d * -b + t * -m - p * -g, c.y = t * q + d * -g + p * -b - n * -m, c.z = p * q + d * -m + n * -g - t * -b, c;
    };
    b.prototype.copy = function(b) {
      return this.x = b.x, this.y = b.y, this.z = b.z, this.w = b.w, this;
    };
    b.prototype.toEuler = function(b, c) {
      c = c || "YZX";
      var d, e, f, k = this.x, g = this.y, q = this.z, m = this.w;
      switch(c) {
        case "YZX":
          c = k * g + q * m;
          if (.499 < c && (d = 2 * Math.atan2(k, m), e = Math.PI / 2, f = 0), -.499 > c && (d = -2 * Math.atan2(k, m), e = -Math.PI / 2, f = 0), isNaN(d)) {
            f = q * q, d = Math.atan2(2 * g * m - 2 * k * q, 1 - 2 * g * g - 2 * f), e = Math.asin(2 * c), f = Math.atan2(2 * k * m - 2 * g * q, 1 - 2 * k * k - 2 * f);
          }
          break;
        default:
          throw Error("Euler order " + c + " not supported yet.");
      }
      b.y = d;
      b.z = e;
      b.x = f;
    };
    b.prototype.setFromEuler = function(b, c, e, f) {
      f = f || "XYZ";
      var d = Math.cos(b / 2), k = Math.cos(c / 2), g = Math.cos(e / 2);
      b = Math.sin(b / 2);
      c = Math.sin(c / 2);
      e = Math.sin(e / 2);
      return "XYZ" === f ? (this.x = b * k * g + d * c * e, this.y = d * c * g - b * k * e, this.z = d * k * e + b * c * g, this.w = d * k * g - b * c * e) : "YXZ" === f ? (this.x = b * k * g + d * c * e, this.y = d * c * g - b * k * e, this.z = d * k * e - b * c * g, this.w = d * k * g + b * c * e) : "ZXY" === f ? (this.x = b * k * g - d * c * e, this.y = d * c * g + b * k * e, this.z = d * k * e + b * c * g, this.w = d * k * g - b * c * e) : "ZYX" === f ? (this.x = b * k * g - d * c * e, this.y = 
      d * c * g + b * k * e, this.z = d * k * e - b * c * g, this.w = d * k * g + b * c * e) : "YZX" === f ? (this.x = b * k * g + d * c * e, this.y = d * c * g + b * k * e, this.z = d * k * e - b * c * g, this.w = d * k * g - b * c * e) : "XZY" === f && (this.x = b * k * g - d * c * e, this.y = d * c * g - b * k * e, this.z = d * k * e + b * c * g, this.w = d * k * g + b * c * e), this;
    };
    b.prototype.clone = function() {
      return new b(this.x, this.y, this.z, this.w);
    };
  }, {"./Vec3":30}], 29:[function(c, g) {
    function b(b) {
      b = b || {};
      this.position = new e;
      b.position && this.position.copy(b.position);
      this.quaternion = new f;
      b.quaternion && this.quaternion.copy(b.quaternion);
    }
    var e = c("./Vec3"), f = c("./Quaternion");
    g.exports = b;
    var k = new f;
    b.pointToLocalFrame = function(b, c, f, g) {
      g = g || new e;
      return f.vsub(b, g), c.conjugate(k), k.vmult(g, g), g;
    };
    b.prototype.pointToLocal = function(c, e) {
      return b.pointToLocalFrame(this.position, this.quaternion, c, e);
    };
    b.pointToWorldFrame = function(b, c, f, k) {
      k = k || new e;
      return c.vmult(f, k), k.vadd(b, k), k;
    };
    b.prototype.pointToWorld = function(c, e) {
      return b.pointToWorldFrame(this.position, this.quaternion, c, e);
    };
    b.prototype.vectorToWorldFrame = function(b, c) {
      c = c || new e;
      return this.quaternion.vmult(b, c), c;
    };
    b.vectorToWorldFrame = function(b, c, e) {
      return b.vmult(c, e), e;
    };
    b.vectorToLocalFrame = function(b, c, f, k) {
      k = k || new e;
      return c.w *= -1, c.vmult(f, k), c.w *= -1, k;
    };
  }, {"./Quaternion":28, "./Vec3":30}], 30:[function(c, g) {
    function b(b, c, e) {
      this.x = b || 0;
      this.y = c || 0;
      this.z = e || 0;
    }
    g.exports = b;
    var e = c("./Mat3");
    b.ZERO = new b(0, 0, 0);
    b.UNIT_X = new b(1, 0, 0);
    b.UNIT_Y = new b(0, 1, 0);
    b.UNIT_Z = new b(0, 0, 1);
    b.prototype.cross = function(c, e) {
      var f = c.x, d = c.y;
      c = c.z;
      var k = this.x, g = this.y, m = this.z;
      return e = e || new b, e.x = g * c - m * d, e.y = m * f - k * c, e.z = k * d - g * f, e;
    };
    b.prototype.set = function(b, c, e) {
      return this.x = b, this.y = c, this.z = e, this;
    };
    b.prototype.setZero = function() {
      this.x = this.y = this.z = 0;
    };
    b.prototype.vadd = function(c, e) {
      return e ? (e.x = c.x + this.x, e.y = c.y + this.y, e.z = c.z + this.z, void 0) : new b(this.x + c.x, this.y + c.y, this.z + c.z);
    };
    b.prototype.vsub = function(c, e) {
      return e ? (e.x = this.x - c.x, e.y = this.y - c.y, e.z = this.z - c.z, void 0) : new b(this.x - c.x, this.y - c.y, this.z - c.z);
    };
    b.prototype.crossmat = function() {
      return new e([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
    };
    b.prototype.normalize = function() {
      var b = this.x, c = this.y, e = this.z;
      b = Math.sqrt(b * b + c * c + e * e);
      0 < b ? (c = 1 / b, this.x *= c, this.y *= c, this.z *= c) : this.z = this.y = this.x = 0;
      return b;
    };
    b.prototype.unit = function(c) {
      c = c || new b;
      var e = this.x, f = this.y, d = this.z, k = Math.sqrt(e * e + f * f + d * d);
      return 0 < k ? (k = 1 / k, c.x = e * k, c.y = f * k, c.z = d * k) : (c.x = 1, c.y = 0, c.z = 0), c;
    };
    b.prototype.norm = function() {
      var b = this.x, c = this.y, e = this.z;
      return Math.sqrt(b * b + c * c + e * e);
    };
    b.prototype.length = b.prototype.norm;
    b.prototype.norm2 = function() {
      return this.dot(this);
    };
    b.prototype.lengthSquared = b.prototype.norm2;
    b.prototype.distanceTo = function(b) {
      var c = this.x, e = this.y, d = this.z, f = b.x, k = b.y;
      b = b.z;
      return Math.sqrt((f - c) * (f - c) + (k - e) * (k - e) + (b - d) * (b - d));
    };
    b.prototype.distanceSquared = function(b) {
      var c = this.x, e = this.y, d = this.z, f = b.x, k = b.y;
      b = b.z;
      return (f - c) * (f - c) + (k - e) * (k - e) + (b - d) * (b - d);
    };
    b.prototype.mult = function(c, e) {
      e = e || new b;
      var f = this.y, d = this.z;
      return e.x = c * this.x, e.y = c * f, e.z = c * d, e;
    };
    b.prototype.scale = b.prototype.mult;
    b.prototype.dot = function(b) {
      return this.x * b.x + this.y * b.y + this.z * b.z;
    };
    b.prototype.isZero = function() {
      return 0 === this.x && 0 === this.y && 0 === this.z;
    };
    b.prototype.negate = function(c) {
      return c = c || new b, c.x = -this.x, c.y = -this.y, c.z = -this.z, c;
    };
    var f = new b, k = new b;
    b.prototype.tangents = function(b, c) {
      var e = this.norm();
      0 < e ? (e = 1 / e, f.set(this.x * e, this.y * e, this.z * e), .9 > Math.abs(f.x) ? (k.set(1, 0, 0), f.cross(k, b)) : (k.set(0, 1, 0), f.cross(k, b)), f.cross(b, c)) : (b.set(1, 0, 0), c.set(0, 1, 0));
    };
    b.prototype.toString = function() {
      return this.x + "," + this.y + "," + this.z;
    };
    b.prototype.toArray = function() {
      return [this.x, this.y, this.z];
    };
    b.prototype.copy = function(b) {
      return this.x = b.x, this.y = b.y, this.z = b.z, this;
    };
    b.prototype.lerp = function(b, c, e) {
      var d = this.x, f = this.y, k = this.z;
      e.x = d + (b.x - d) * c;
      e.y = f + (b.y - f) * c;
      e.z = k + (b.z - k) * c;
    };
    b.prototype.almostEquals = function(b, c) {
      return void 0 === c && (c = 1E-6), Math.abs(this.x - b.x) > c || Math.abs(this.y - b.y) > c || Math.abs(this.z - b.z) > c ? !1 : !0;
    };
    b.prototype.almostZero = function(b) {
      return void 0 === b && (b = 1E-6), Math.abs(this.x) > b || Math.abs(this.y) > b || Math.abs(this.z) > b ? !1 : !0;
    };
    var n = new b;
    b.prototype.isAntiparallelTo = function(b, c) {
      return this.negate(n), n.almostEquals(b, c);
    };
    b.prototype.clone = function() {
      return new b(this.x, this.y, this.z);
    };
  }, {"./Mat3":27}], 31:[function(c, g) {
    function b(c) {
      c = c || {};
      e.apply(this);
      this.id = b.idCounter++;
      this.postStep = this.preStep = this.world = null;
      this.vlambda = new f;
      this.collisionFilterGroup = "number" == typeof c.collisionFilterGroup ? c.collisionFilterGroup : 1;
      this.collisionFilterMask = "number" == typeof c.collisionFilterMask ? c.collisionFilterMask : 1;
      this.collisionResponse = !0;
      this.position = new f;
      c.position && this.position.copy(c.position);
      this.previousPosition = new f;
      this.initPosition = new f;
      this.velocity = new f;
      c.velocity && this.velocity.copy(c.velocity);
      this.initVelocity = new f;
      this.force = new f;
      var d = "number" == typeof c.mass ? c.mass : 0;
      this.mass = d;
      this.invMass = 0 < d ? 1 / d : 0;
      this.material = c.material || null;
      this.linearDamping = "number" == typeof c.linearDamping ? c.linearDamping : .01;
      this.type = 0 >= d ? b.STATIC : b.DYNAMIC;
      typeof c.type == typeof b.STATIC && (this.type = c.type);
      this.allowSleep = "undefined" != typeof c.allowSleep ? c.allowSleep : !0;
      this.sleepState = 0;
      this.sleepSpeedLimit = "undefined" != typeof c.sleepSpeedLimit ? c.sleepSpeedLimit : .1;
      this.sleepTimeLimit = "undefined" != typeof c.sleepTimeLimit ? c.sleepTimeLimit : 1;
      this.timeLastSleepy = 0;
      this._wakeUpAfterNarrowphase = !1;
      this.torque = new f;
      this.quaternion = new n;
      c.quaternion && this.quaternion.copy(c.quaternion);
      this.initQuaternion = new n;
      this.angularVelocity = new f;
      c.angularVelocity && this.angularVelocity.copy(c.angularVelocity);
      this.initAngularVelocity = new f;
      this.interpolatedPosition = new f;
      this.interpolatedQuaternion = new n;
      this.shapes = [];
      this.shapeOffsets = [];
      this.shapeOrientations = [];
      this.inertia = new f;
      this.invInertia = new f;
      this.invInertiaWorld = new k;
      this.invMassSolve = 0;
      this.invInertiaSolve = new f;
      this.invInertiaWorldSolve = new k;
      this.fixedRotation = "undefined" != typeof c.fixedRotation ? c.fixedRotation : !1;
      this.angularDamping = "undefined" != typeof c.angularDamping ? c.angularDamping : .01;
      this.aabb = new p;
      this.aabbNeedsUpdate = !0;
      this.wlambda = new f;
      c.shape && this.addShape(c.shape);
      this.updateMassProperties();
    }
    g.exports = b;
    var e = c("../utils/EventTarget"), f = (c("../shapes/Shape"), c("../math/Vec3")), k = c("../math/Mat3"), n = c("../math/Quaternion"), p = (c("../material/Material"), c("../collision/AABB")), m = c("../shapes/Box");
    b.prototype = new e;
    b.prototype.constructor = b;
    b.DYNAMIC = 1;
    b.STATIC = 2;
    b.KINEMATIC = 4;
    b.AWAKE = 0;
    b.SLEEPY = 1;
    b.SLEEPING = 2;
    b.idCounter = 0;
    b.prototype.wakeUp = function() {
      var c = this.sleepState;
      this.sleepState = 0;
      c === b.SLEEPING && this.dispatchEvent({type:"wakeup"});
    };
    b.prototype.sleep = function() {
      this.sleepState = b.SLEEPING;
      this.velocity.set(0, 0, 0);
      this.angularVelocity.set(0, 0, 0);
    };
    b.sleepyEvent = {type:"sleepy"};
    b.sleepEvent = {type:"sleep"};
    b.prototype.sleepTick = function(c) {
      if (this.allowSleep) {
        var d = this.sleepState, e = this.velocity.norm2() + this.angularVelocity.norm2(), f = Math.pow(this.sleepSpeedLimit, 2);
        d === b.AWAKE && f > e ? (this.sleepState = b.SLEEPY, this.timeLastSleepy = c, this.dispatchEvent(b.sleepyEvent)) : d === b.SLEEPY && e > f ? this.wakeUp() : d === b.SLEEPY && c - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), this.dispatchEvent(b.sleepEvent));
      }
    };
    b.prototype.updateSolveMassProperties = function() {
      this.sleepState === b.SLEEPING || this.type === b.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld));
    };
    b.prototype.pointToLocalFrame = function(b, c) {
      c = c || new f;
      return b.vsub(this.position, c), this.quaternion.conjugate().vmult(c, c), c;
    };
    b.prototype.vectorToLocalFrame = function(b, c) {
      c = c || new f;
      return this.quaternion.conjugate().vmult(b, c), c;
    };
    b.prototype.pointToWorldFrame = function(b, c) {
      c = c || new f;
      return this.quaternion.vmult(b, c), c.vadd(this.position, c), c;
    };
    b.prototype.vectorToWorldFrame = function(b, c) {
      c = c || new f;
      return this.quaternion.vmult(b, c), c;
    };
    var t = new f, d = new n;
    b.prototype.addShape = function(b, c, d) {
      var e = new f, k = new n;
      return c && e.copy(c), d && k.copy(d), this.shapes.push(b), this.shapeOffsets.push(e), this.shapeOrientations.push(k), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, this;
    };
    b.prototype.updateBoundingRadius = function() {
      for (var b = this.shapes, c = this.shapeOffsets, d = b.length, e = 0, f = 0; f !== d; f++) {
        var k = b[f];
        k.updateBoundingSphereRadius();
        var g = c[f].norm();
        k = k.boundingSphereRadius;
        g + k > e && (e = g + k);
      }
      this.boundingRadius = e;
    };
    var l = new p;
    b.prototype.computeAABB = function() {
      for (var b = this.shapes, c = this.shapeOffsets, e = this.shapeOrientations, f = b.length, k = this.quaternion, g = this.aabb, q = 0; q !== f; q++) {
        var m = b[q];
        e[q].mult(k, d);
        d.vmult(c[q], t);
        t.vadd(this.position, t);
        m.calculateWorldAABB(t, d, l.lowerBound, l.upperBound);
        0 === q ? g.copy(l) : g.extend(l);
      }
      this.aabbNeedsUpdate = !1;
    };
    var u = new k, w = new k;
    new k;
    b.prototype.updateInertiaWorld = function(b) {
      var c = this.invInertia;
      if (c.x !== c.y || c.y !== c.z || b) {
        u.setRotationFromQuaternion(this.quaternion), u.transpose(w), u.scale(c, u), u.mmult(w, this.invInertiaWorld);
      }
    };
    var y = new f, x = new f;
    b.prototype.applyForce = function(c, d) {
      this.type === b.DYNAMIC && (d.vsub(this.position, y), y.cross(c, x), this.force.vadd(c, this.force), this.torque.vadd(x, this.torque));
    };
    var q = new f, v = new f;
    b.prototype.applyLocalForce = function(c, d) {
      this.type === b.DYNAMIC && (this.vectorToWorldFrame(c, q), this.pointToWorldFrame(d, v), this.applyForce(q, v));
    };
    var z = new f, C = new f, A = new f;
    b.prototype.applyImpulse = function(c, d) {
      this.type === b.DYNAMIC && (d.vsub(this.position, z), C.copy(c), C.mult(this.invMass, C), this.velocity.vadd(C, this.velocity), z.cross(c, A), this.invInertiaWorld.vmult(A, A), this.angularVelocity.vadd(A, this.angularVelocity));
    };
    var D = new f, E = new f;
    b.prototype.applyLocalImpulse = function(c, d) {
      this.type === b.DYNAMIC && (this.vectorToWorldFrame(c, D), this.pointToWorldFrame(d, E), this.applyImpulse(D, E));
    };
    var B = new f;
    b.prototype.updateMassProperties = function() {
      this.invMass = 0 < this.mass ? 1 / this.mass : 0;
      var b = this.inertia, c = this.fixedRotation;
      this.computeAABB();
      B.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);
      m.calculateInertia(B, this.mass, b);
      this.invInertia.set(0 < b.x && !c ? 1 / b.x : 0, 0 < b.y && !c ? 1 / b.y : 0, 0 < b.z && !c ? 1 / b.z : 0);
      this.updateInertiaWorld(!0);
    };
    b.prototype.getVelocityAtWorldPoint = function(b, c) {
      var d = new f;
      return b.vsub(this.position, d), this.angularVelocity.cross(d, c), this.velocity.vadd(c, c), c;
    };
  }, {"../collision/AABB":3, "../material/Material":25, "../math/Mat3":27, "../math/Quaternion":28, "../math/Vec3":30, "../shapes/Box":37, "../shapes/Shape":43, "../utils/EventTarget":49}], 32:[function(c, g) {
    function b(b) {
      this.chassisBody = b.chassisBody;
      this.wheelInfos = [];
      this.sliding = !1;
      this.world = null;
      this.indexRightAxis = "undefined" != typeof b.indexRightAxis ? b.indexRightAxis : 1;
      this.indexForwardAxis = "undefined" != typeof b.indexForwardAxis ? b.indexForwardAxis : 0;
      this.indexUpAxis = "undefined" != typeof b.indexUpAxis ? b.indexUpAxis : 2;
    }
    function e(b, c, d) {
      var e = A, f = D, k = E, g = B;
      return c.vsub(b.position, e), e.cross(d, f), b.invInertiaWorld.vmult(f, g), g.cross(e, k), b.invMass + d.dot(k);
    }
    var f = (c("./Body"), c("../math/Vec3")), k = c("../math/Quaternion"), n = (c("../collision/RaycastResult"), c("../collision/Ray")), p = c("../objects/WheelInfo");
    g.exports = b;
    var m = (new f, new f, new f, new f), t = new f, d = new f;
    new n;
    b.prototype.addWheel = function(b) {
      b = b || {};
      b = new p(b);
      var c = this.wheelInfos.length;
      return this.wheelInfos.push(b), c;
    };
    b.prototype.setSteeringValue = function(b, c) {
      this.wheelInfos[c].steering = b;
    };
    new f;
    b.prototype.applyEngineForce = function(b, c) {
      this.wheelInfos[c].engineForce = b;
    };
    b.prototype.setBrake = function(b, c) {
      this.wheelInfos[c].brake = b;
    };
    b.prototype.addToWorld = function(b) {
      this.constraints;
      b.add(this.chassisBody);
      var c = this;
      this.preStepCallback = function() {
        c.updateVehicle(b.dt);
      };
      b.addEventListener("preStep", this.preStepCallback);
      this.world = b;
    };
    b.prototype.getVehicleAxisWorld = function(b, c) {
      c.set(0 === b ? 1 : 0, 1 === b ? 1 : 0, 2 === b ? 1 : 0);
      this.chassisBody.vectorToWorldFrame(c, c);
    };
    b.prototype.updateVehicle = function(b) {
      for (var c = this.wheelInfos, d = c.length, e = this.chassisBody, k = 0; d > k; k++) {
        this.updateWheelTransform(k);
      }
      this.currentVehicleSpeedKmHour = 3.6 * e.velocity.norm();
      k = new f;
      this.getVehicleAxisWorld(this.indexForwardAxis, k);
      0 > k.dot(e.velocity) && (this.currentVehicleSpeedKmHour *= -1);
      for (k = 0; d > k; k++) {
        this.castRay(c[k]);
      }
      this.updateSuspension(b);
      var g = new f, l = new f;
      for (k = 0; d > k; k++) {
        var q = c[k], m = q.suspensionForce;
        m > q.maxSuspensionForce && (m = q.maxSuspensionForce);
        q.raycastResult.hitNormalWorld.scale(m * b, g);
        q.raycastResult.hitPointWorld.vsub(e.position, l);
        e.applyImpulse(g, q.raycastResult.hitPointWorld);
      }
      this.updateFriction(b);
      g = new f;
      l = new f;
      m = new f;
      for (k = 0; d > k; k++) {
        q = c[k];
        e.getVelocityAtWorldPoint(q.chassisConnectionPointWorld, m);
        var n = 1;
        switch(this.indexUpAxis) {
          case 1:
            n = -1;
        }
        if (q.isInContact) {
          this.getVehicleAxisWorld(this.indexForwardAxis, l);
          var t = l.dot(q.raycastResult.hitNormalWorld);
          q.raycastResult.hitNormalWorld.scale(t, g);
          l.vsub(g, l);
          t = l.dot(m);
          q.deltaRotation = n * t * b / q.radius;
        }
        !q.sliding && q.isInContact || 0 === q.engineForce || !q.useCustomSlidingRotationalSpeed || (q.deltaRotation = (0 < q.engineForce ? 1 : -1) * q.customSlidingRotationalSpeed * b);
        Math.abs(q.brake) > Math.abs(q.engineForce) && (q.deltaRotation = 0);
        q.rotation += q.deltaRotation;
        q.deltaRotation *= .99;
      }
    };
    b.prototype.updateSuspension = function() {
      for (var b = this.chassisBody.mass, c = this.wheelInfos, d = c.length, e = 0; d > e; e++) {
        var f = c[e];
        if (f.isInContact) {
          var k = f.suspensionStiffness * (f.suspensionRestLength - f.suspensionLength) * f.clippedInvContactDotSuspension;
          var g = f.suspensionRelativeVelocity;
          k -= (0 > g ? f.dampingCompression : f.dampingRelaxation) * g;
          f.suspensionForce = k * b;
          0 > f.suspensionForce && (f.suspensionForce = 0);
        } else {
          f.suspensionForce = 0;
        }
      }
    };
    b.prototype.removeFromWorld = function(b) {
      this.constraints;
      b.remove(this.chassisBody);
      b.removeEventListener("preStep", this.preStepCallback);
      this.world = null;
    };
    var l = new f, u = new f;
    b.prototype.castRay = function(b) {
      this.updateWheelTransformWorld(b);
      var c = this.chassisBody, d = -1;
      b.directionWorld.scale(b.suspensionRestLength + b.radius, l);
      var e = b.chassisConnectionPointWorld;
      e.vadd(l, u);
      var k = b.raycastResult;
      k.reset();
      var g = c.collisionResponse;
      c.collisionResponse = !1;
      this.world.rayTest(e, u, k);
      c.collisionResponse = g;
      e = k.body;
      (b.raycastResult.groundObject = 0, e) ? (d = k.distance, b.raycastResult.hitNormalWorld = k.hitNormalWorld, b.isInContact = !0, b.suspensionLength = k.distance - b.radius, k = b.suspensionRestLength - b.maxSuspensionTravel, e = b.suspensionRestLength + b.maxSuspensionTravel, b.suspensionLength < k && (b.suspensionLength = k), b.suspensionLength > e && (b.suspensionLength = e, b.raycastResult.reset()), k = b.raycastResult.hitNormalWorld.dot(b.directionWorld), e = new f, c.getVelocityAtWorldPoint(b.raycastResult.hitPointWorld, 
      e), c = b.raycastResult.hitNormalWorld.dot(e), -.1 <= k ? (b.suspensionRelativeVelocity = 0, b.clippedInvContactDotSuspension = 10) : (k = -1 / k, b.suspensionRelativeVelocity = c * k, b.clippedInvContactDotSuspension = k)) : (b.suspensionLength = b.suspensionRestLength + 0 * b.maxSuspensionTravel, b.suspensionRelativeVelocity = 0, b.directionWorld.scale(-1, b.raycastResult.hitNormalWorld), b.clippedInvContactDotSuspension = 1);
      return d;
    };
    b.prototype.updateWheelTransformWorld = function(b) {
      b.isInContact = !1;
      var c = this.chassisBody;
      c.pointToWorldFrame(b.chassisConnectionPointLocal, b.chassisConnectionPointWorld);
      c.vectorToWorldFrame(b.directionLocal, b.directionWorld);
      c.vectorToWorldFrame(b.axleLocal, b.axleWorld);
    };
    b.prototype.updateWheelTransform = function(b) {
      b = this.wheelInfos[b];
      this.updateWheelTransformWorld(b);
      b.directionLocal.scale(-1, m);
      t.copy(b.axleLocal);
      m.cross(t, d);
      d.normalize();
      t.normalize();
      var c = b.steering, e = new k;
      e.setFromAxisAngle(m, c);
      c = new k;
      c.setFromAxisAngle(t, b.rotation);
      var f = b.worldTransform.quaternion;
      this.chassisBody.quaternion.mult(e, f);
      f.mult(c, f);
      f.normalize();
      e = b.worldTransform.position;
      e.copy(b.directionWorld);
      e.scale(b.suspensionLength, e);
      e.vadd(b.chassisConnectionPointWorld, e);
    };
    var w = [new f(1, 0, 0), new f(0, 1, 0), new f(0, 0, 1)];
    b.prototype.getWheelTransformWorld = function(b) {
      return this.wheelInfos[b].worldTransform;
    };
    var y = new f, x = [], q = [];
    b.prototype.updateFriction = function(b) {
      for (var c = this.wheelInfos, d = c.length, k = this.chassisBody, g = 0, l = 0; d > l; l++) {
        var m = c[l], n = m.raycastResult.body;
        n && g++;
        m.sideImpulse = 0;
        m.forwardImpulse = 0;
        q[l] || (q[l] = new f);
        x[l] || (x[l] = new f);
      }
      for (l = 0; d > l; l++) {
        if (m = c[l], n = m.raycastResult.body) {
          var t = x[l];
          this.getWheelTransformWorld(l).vectorToWorldFrame(w[this.indexRightAxis], t);
          g = m.raycastResult.hitNormalWorld;
          var u = t.dot(g);
          g.scale(u, y);
          t.vsub(y, t);
          t.normalize();
          g.cross(t, q[l]);
          q[l].normalize();
          g = m;
          u = k;
          var p = m.raycastResult.hitPointWorld, B = m.raycastResult.hitPointWorld;
          if (1.1 < t.norm2()) {
            n = 0;
          } else {
            var D = G, A = H, E = K;
            u.getVelocityAtWorldPoint(p, D);
            n.getVelocityAtWorldPoint(B, A);
            D.vsub(A, E);
            n = -.2 * t.dot(E) * (1 / (u.invMass + n.invMass));
          }
          g.sideImpulse = n;
          m.sideImpulse *= 1;
        }
      }
      this.sliding = !1;
      for (l = 0; d > l; l++) {
        m = c[l];
        n = m.raycastResult.body;
        p = 0;
        if (m.slipInfo = 1, n) {
          g = m.brake ? m.brake : 0;
          A = k;
          B = n;
          t = m.raycastResult.hitPointWorld;
          D = q[l];
          p = g;
          u = 0;
          E = t;
          var I = v, X = z, fa = C;
          A.getVelocityAtWorldPoint(E, I);
          B.getVelocityAtWorldPoint(E, X);
          I.vsub(X, fa);
          E = D.dot(fa);
          A = e(A, t, D);
          B = e(B, t, D);
          p = (u = 1 / (A + B) * -E, u > p && (u = p), -p > u && (u = -p), u);
          p += m.engineForce * b;
          g /= p;
          m.slipInfo *= g;
        }
        if (m.forwardImpulse = 0, m.skidInfo = 1, n) {
          if (m.skidInfo = 1, n = m.suspensionForce * b * m.frictionSlip, g = n * n, m.forwardImpulse = p, u = .5 * m.forwardImpulse, p = 1 * m.sideImpulse, u = u * u + p * p, m.sliding = !1, u > g) {
            this.sliding = !0, m.sliding = !0, g = n / Math.sqrt(u), m.skidInfo *= g;
          }
        }
      }
      if (this.sliding) {
        for (l = 0; d > l; l++) {
          m = c[l], 0 !== m.sideImpulse && 1 > m.skidInfo && (m.forwardImpulse *= m.skidInfo, m.sideImpulse *= m.skidInfo);
        }
      }
      for (l = 0; d > l; l++) {
        m = c[l];
        b = new f;
        if (b.copy(m.raycastResult.hitPointWorld), 0 !== m.forwardImpulse) {
          n = new f, q[l].scale(m.forwardImpulse, n), k.applyImpulse(n, b);
        }
        0 !== m.sideImpulse && (n = m.raycastResult.body, g = new f, g.copy(m.raycastResult.hitPointWorld), u = new f, x[l].scale(m.sideImpulse, u), k.pointToLocalFrame(b, b), b["xyz"[this.indexUpAxis]] *= m.rollInfluence, k.pointToWorldFrame(b, b), k.applyImpulse(u, b), u.scale(-1, u), n.applyImpulse(u, g));
      }
    };
    var v = new f, z = new f, C = new f, A = new f, D = new f, E = new f, B = new f, G = new f, H = new f, K = new f;
  }, {"../collision/Ray":9, "../collision/RaycastResult":10, "../math/Quaternion":28, "../math/Vec3":30, "../objects/WheelInfo":36, "./Body":31}], 33:[function(c, g) {
    function b(b) {
      (this.wheelBodies = [], this.coordinateSystem = "undefined" == typeof b.coordinateSystem ? new n(1, 2, 3) : b.coordinateSystem.clone(), this.chassisBody = b.chassisBody, this.chassisBody) || (b = new k(new n(5, 2, .5)), this.chassisBody = new e(1, b));
      this.constraints = [];
      this.wheelAxes = [];
      this.wheelForces = [];
    }
    var e = c("./Body"), f = c("../shapes/Sphere"), k = c("../shapes/Box"), n = c("../math/Vec3"), p = c("../constraints/HingeConstraint");
    g.exports = b;
    b.prototype.addWheel = function(b) {
      b = b || {};
      var c = b.body;
      c || (c = new e(1, new f(1.2)));
      this.wheelBodies.push(c);
      this.wheelForces.push(0);
      var d = (new n, "undefined" != typeof b.position ? b.position.clone() : new n), k = new n;
      this.chassisBody.pointToWorldFrame(d, k);
      c.position.set(k.x, k.y, k.z);
      b = "undefined" != typeof b.axis ? b.axis.clone() : new n(0, 1, 0);
      this.wheelAxes.push(b);
      c = new p(this.chassisBody, c, {pivotA:d, axisA:b, pivotB:n.ZERO, axisB:b, collideConnected:!1});
      return this.constraints.push(c), this.wheelBodies.length - 1;
    };
    b.prototype.setSteeringValue = function(b, c) {
      var d = this.wheelAxes[c], e = Math.cos(b);
      b = Math.sin(b);
      var f = d.x;
      d = d.y;
      this.constraints[c].axisA.set(e * f - b * d, b * f + e * d, 0);
    };
    b.prototype.setMotorSpeed = function(b, c) {
      c = this.constraints[c];
      c.enableMotor();
      c.motorTargetVelocity = b;
    };
    b.prototype.disableMotor = function(b) {
      this.constraints[b].disableMotor();
    };
    var m = new n;
    b.prototype.setWheelForce = function(b, c) {
      this.wheelForces[c] = b;
    };
    b.prototype.applyWheelForce = function(b, c) {
      var d = this.wheelBodies[c], e = d.torque;
      this.wheelAxes[c].scale(b, m);
      d.vectorToWorldFrame(m, m);
      e.vadd(m, e);
    };
    b.prototype.addToWorld = function(b) {
      for (var c = this.constraints, d = this.wheelBodies.concat([this.chassisBody]), e = 0; e < d.length; e++) {
        b.add(d[e]);
      }
      for (e = 0; e < c.length; e++) {
        b.addConstraint(c[e]);
      }
      b.addEventListener("preStep", this._update.bind(this));
    };
    b.prototype._update = function() {
      for (var b = this.wheelForces, c = 0; c < b.length; c++) {
        this.applyWheelForce(b[c], c);
      }
    };
    b.prototype.removeFromWorld = function(b) {
      for (var c = this.constraints, d = this.wheelBodies.concat([this.chassisBody]), e = 0; e < d.length; e++) {
        b.remove(d[e]);
      }
      for (e = 0; e < c.length; e++) {
        b.removeConstraint(c[e]);
      }
    };
    var t = new n;
    b.prototype.getWheelSpeed = function(b) {
      var c = this.wheelBodies[b].angularVelocity;
      return this.chassisBody.vectorToWorldFrame(this.wheelAxes[b], t), c.dot(t);
    };
  }, {"../constraints/HingeConstraint":15, "../math/Vec3":30, "../shapes/Box":37, "../shapes/Sphere":44, "./Body":31}], 34:[function(c, g) {
    function b() {
      this.particles = [];
      this.speedOfSound = this.smoothingRadius = this.density = 1;
      this.viscosity = .01;
      this.eps = 1E-6;
      this.pressures = [];
      this.densities = [];
      this.neighbors = [];
    }
    g.exports = b;
    g = (c("../shapes/Shape"), c("../math/Vec3"));
    c("../math/Quaternion");
    c("../shapes/Particle");
    c("../objects/Body");
    c("../material/Material");
    b.prototype.add = function(b) {
      this.particles.push(b);
      this.neighbors.length < this.particles.length && this.neighbors.push([]);
    };
    b.prototype.remove = function(b) {
      b = this.particles.indexOf(b);
      -1 !== b && (this.particles.splice(b, 1), this.neighbors.length > this.particles.length && this.neighbors.pop());
    };
    var e = new g;
    b.prototype.getNeighbors = function(b, c) {
      for (var d = this.particles.length, f = b.id, k = this.smoothingRadius * this.smoothingRadius, g = 0; g !== d; g++) {
        var l = this.particles[g];
        l.position.vsub(b.position, e);
        f !== l.id && e.norm2() < k && c.push(l);
      }
    };
    var f = new g, k = new g, n = new g, p = new g, m = new g, t = new g;
    b.prototype.update = function() {
      for (var b = this.particles.length, c = this.speedOfSound, e = this.eps, g = 0; g !== b; g++) {
        var y = this.particles[g], x = this.neighbors[g];
        x.length = 0;
        this.getNeighbors(y, x);
        x.push(this.particles[g]);
        for (var q = x.length, v = 0, z = 0; z !== q; z++) {
          y.position.vsub(x[z].position, f);
          var C = f.norm();
          C = this.w(C);
          v += x[z].mass * C;
        }
        this.densities[g] = v;
        this.pressures[g] = c * c * (this.densities[g] - this.density);
      }
      for (g = 0; g !== b; g++) {
        c = this.particles[g];
        k.set(0, 0, 0);
        n.set(0, 0, 0);
        x = this.neighbors[g];
        q = x.length;
        for (z = 0; z !== q; z++) {
          v = x[z], c.position.vsub(v.position, m), C = m.norm(), y = -v.mass * (this.pressures[g] / (this.densities[g] * this.densities[g] + e) + this.pressures[z] / (this.densities[z] * this.densities[z] + e)), this.gradw(m, p), p.mult(y, p), k.vadd(p, k), v.velocity.vsub(c.velocity, t), t.mult(1 / (1E-4 + this.densities[g] * this.densities[z]) * this.viscosity * v.mass, t), y = this.nablaw(C), t.mult(y, t), n.vadd(t, n);
        }
        n.mult(c.mass, n);
        k.mult(c.mass, k);
        c.force.vadd(n, c.force);
        c.force.vadd(k, c.force);
      }
    };
    b.prototype.w = function(b) {
      var c = this.smoothingRadius;
      return 315 / (64 * Math.PI * Math.pow(c, 9)) * Math.pow(c * c - b * b, 3);
    };
    b.prototype.gradw = function(b, c) {
      var d = b.norm(), e = this.smoothingRadius;
      b.mult(945 / (32 * Math.PI * Math.pow(e, 9)) * Math.pow(e * e - d * d, 2), c);
    };
    b.prototype.nablaw = function(b) {
      var c = this.smoothingRadius;
      return 945 / (32 * Math.PI * Math.pow(c, 9)) * (c * c - b * b) * (7 * b * b - 3 * c * c);
    };
  }, {"../material/Material":25, "../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "../shapes/Particle":41, "../shapes/Shape":43}], 35:[function(c, g) {
    function b(b, c, d) {
      d = d || {};
      this.restLength = "number" == typeof d.restLength ? d.restLength : 1;
      this.stiffness = d.stiffness || 100;
      this.damping = d.damping || 1;
      this.bodyA = b;
      this.bodyB = c;
      this.localAnchorA = new e;
      this.localAnchorB = new e;
      d.localAnchorA && this.localAnchorA.copy(d.localAnchorA);
      d.localAnchorB && this.localAnchorB.copy(d.localAnchorB);
      d.worldAnchorA && this.setWorldAnchorA(d.worldAnchorA);
      d.worldAnchorB && this.setWorldAnchorB(d.worldAnchorB);
    }
    var e = c("../math/Vec3");
    g.exports = b;
    b.prototype.setWorldAnchorA = function(b) {
      this.bodyA.pointToLocalFrame(b, this.localAnchorA);
    };
    b.prototype.setWorldAnchorB = function(b) {
      this.bodyB.pointToLocalFrame(b, this.localAnchorB);
    };
    b.prototype.getWorldAnchorA = function(b) {
      this.bodyA.pointToWorldFrame(this.localAnchorA, b);
    };
    b.prototype.getWorldAnchorB = function(b) {
      this.bodyB.pointToWorldFrame(this.localAnchorB, b);
    };
    var f = new e, k = new e, n = new e, p = new e, m = new e, t = new e, d = new e, l = new e, u = new e, w = new e, y = new e;
    b.prototype.applyForce = function() {
      var b = this.stiffness, c = this.damping, e = this.restLength, g = this.bodyA, C = this.bodyB;
      this.getWorldAnchorA(m);
      this.getWorldAnchorB(t);
      m.vsub(g.position, d);
      t.vsub(C.position, l);
      t.vsub(m, f);
      var A = f.norm();
      k.copy(f);
      k.normalize();
      C.velocity.vsub(g.velocity, n);
      C.angularVelocity.cross(l, y);
      n.vadd(y, n);
      g.angularVelocity.cross(d, y);
      n.vsub(y, n);
      k.mult(-b * (A - e) - c * n.dot(k), p);
      g.force.vsub(p, g.force);
      C.force.vadd(p, C.force);
      d.cross(p, u);
      l.cross(p, w);
      g.torque.vsub(u, g.torque);
      C.torque.vadd(w, C.torque);
    };
  }, {"../math/Vec3":30}], 36:[function(c, g) {
    function b(b) {
      b = n.defaults(b, {chassisConnectionPointLocal:new e, chassisConnectionPointWorld:new e, directionLocal:new e, directionWorld:new e, axleLocal:new e, axleWorld:new e, suspensionRestLength:1, suspensionMaxLength:2, radius:1, suspensionStiffness:100, dampingCompression:10, dampingRelaxation:10, frictionSlip:1E4, steering:0, rotation:0, deltaRotation:0, rollInfluence:.01, maxSuspensionForce:Number.MAX_VALUE, isFrontWheel:!0, clippedInvContactDotSuspension:1, suspensionRelativeVelocity:0, suspensionForce:0, 
      skidInfo:0, suspensionLength:0, maxSuspensionTravel:1, useCustomSlidingRotationalSpeed:!1, customSlidingRotationalSpeed:-.1});
      this.maxSuspensionTravel = b.maxSuspensionTravel;
      this.customSlidingRotationalSpeed = b.customSlidingRotationalSpeed;
      this.useCustomSlidingRotationalSpeed = b.useCustomSlidingRotationalSpeed;
      this.sliding = !1;
      this.chassisConnectionPointLocal = b.chassisConnectionPointLocal.clone();
      this.chassisConnectionPointWorld = b.chassisConnectionPointWorld.clone();
      this.directionLocal = b.directionLocal.clone();
      this.directionWorld = b.directionWorld.clone();
      this.axleLocal = b.axleLocal.clone();
      this.axleWorld = b.axleWorld.clone();
      this.suspensionRestLength = b.suspensionRestLength;
      this.suspensionMaxLength = b.suspensionMaxLength;
      this.radius = b.radius;
      this.suspensionStiffness = b.suspensionStiffness;
      this.dampingCompression = b.dampingCompression;
      this.dampingRelaxation = b.dampingRelaxation;
      this.frictionSlip = b.frictionSlip;
      this.deltaRotation = this.rotation = this.steering = 0;
      this.rollInfluence = b.rollInfluence;
      this.maxSuspensionForce = b.maxSuspensionForce;
      this.brake = this.engineForce = 0;
      this.isFrontWheel = b.isFrontWheel;
      this.clippedInvContactDotSuspension = 1;
      this.forwardImpulse = this.sideImpulse = this.suspensionLength = this.skidInfo = this.suspensionForce = this.suspensionRelativeVelocity = 0;
      this.raycastResult = new k;
      this.worldTransform = new f;
      this.isInContact = !1;
    }
    var e = c("../math/Vec3"), f = c("../math/Transform"), k = c("../collision/RaycastResult"), n = c("../utils/Utils");
    g.exports = b;
    var p = new e, m = new e;
    p = new e;
    b.prototype.updateWheel = function(b) {
      var c = this.raycastResult;
      if (this.isInContact) {
        var e = c.hitNormalWorld.dot(c.directionWorld);
        c.hitPointWorld.vsub(b.position, m);
        b.getVelocityAtWorldPoint(m, p);
        b = c.hitNormalWorld.dot(p);
        -.1 <= e ? (this.suspensionRelativeVelocity = 0, this.clippedInvContactDotSuspension = 10) : (e = -1 / e, this.suspensionRelativeVelocity = b * e, this.clippedInvContactDotSuspension = e);
      } else {
        c.suspensionLength = this.suspensionRestLength, this.suspensionRelativeVelocity = 0, c.directionWorld.scale(-1, c.hitNormalWorld), this.clippedInvContactDotSuspension = 1;
      }
    };
  }, {"../collision/RaycastResult":10, "../math/Transform":29, "../math/Vec3":30, "../utils/Utils":53}], 37:[function(c, g) {
    function b(b) {
      e.call(this);
      this.type = e.types.BOX;
      this.halfExtents = b;
      this.convexPolyhedronRepresentation = null;
      this.updateConvexPolyhedronRepresentation();
      this.updateBoundingSphereRadius();
    }
    g.exports = b;
    var e = c("./Shape"), f = c("../math/Vec3"), k = c("./ConvexPolyhedron");
    b.prototype = new e;
    b.prototype.constructor = b;
    b.prototype.updateConvexPolyhedronRepresentation = function() {
      var b = this.halfExtents.x, c = this.halfExtents.y, d = this.halfExtents.z;
      b = [new f(-b, -c, -d), new f(b, -c, -d), new f(b, c, -d), new f(-b, c, -d), new f(-b, -c, d), new f(b, -c, d), new f(b, c, d), new f(-b, c, d)];
      this.convexPolyhedronRepresentation = b = (new f(0, 0, 1), new f(0, 1, 0), new f(1, 0, 0), new k(b, [[3, 2, 1, 0], [4, 5, 6, 7], [5, 4, 0, 1], [2, 3, 7, 6], [0, 4, 7, 3], [1, 2, 6, 5]]));
      b.material = this.material;
    };
    b.prototype.calculateLocalInertia = function(c, e) {
      return e = e || new f, b.calculateInertia(this.halfExtents, c, e), e;
    };
    b.calculateInertia = function(b, c, d) {
      d.x = 1 / 12 * c * (4 * b.y * b.y + 4 * b.z * b.z);
      d.y = 1 / 12 * c * (4 * b.x * b.x + 4 * b.z * b.z);
      d.z = 1 / 12 * c * (4 * b.y * b.y + 4 * b.x * b.x);
    };
    b.prototype.getSideNormals = function(b, c) {
      var d = this.halfExtents;
      if (b[0].set(d.x, 0, 0), b[1].set(0, d.y, 0), b[2].set(0, 0, d.z), b[3].set(-d.x, 0, 0), b[4].set(0, -d.y, 0), b[5].set(0, 0, -d.z), void 0 !== c) {
        for (d = 0; d !== b.length; d++) {
          c.vmult(b[d], b[d]);
        }
      }
      return b;
    };
    b.prototype.volume = function() {
      return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
    };
    b.prototype.updateBoundingSphereRadius = function() {
      this.boundingSphereRadius = this.halfExtents.norm();
    };
    var n = new f;
    new f;
    b.prototype.forEachWorldCorner = function(b, c, d) {
      var e = this.halfExtents;
      e = [[e.x, e.y, e.z], [-e.x, e.y, e.z], [-e.x, -e.y, e.z], [-e.x, -e.y, -e.z], [e.x, -e.y, -e.z], [e.x, e.y, -e.z], [-e.x, e.y, -e.z], [e.x, -e.y, e.z]];
      for (var f = 0; f < e.length; f++) {
        n.set(e[f][0], e[f][1], e[f][2]), c.vmult(n, n), b.vadd(n, n), d(n.x, n.y, n.z);
      }
    };
    var p = [new f, new f, new f, new f, new f, new f, new f, new f];
    b.prototype.calculateWorldAABB = function(b, c, d, e) {
      var f = this.halfExtents;
      p[0].set(f.x, f.y, f.z);
      p[1].set(-f.x, f.y, f.z);
      p[2].set(-f.x, -f.y, f.z);
      p[3].set(-f.x, -f.y, -f.z);
      p[4].set(f.x, -f.y, -f.z);
      p[5].set(f.x, f.y, -f.z);
      p[6].set(-f.x, f.y, -f.z);
      p[7].set(f.x, -f.y, f.z);
      var k = p[0];
      c.vmult(k, k);
      b.vadd(k, k);
      e.copy(k);
      d.copy(k);
      for (f = 1; 8 > f; f++) {
        k = p[f];
        c.vmult(k, k);
        b.vadd(k, k);
        var g = k.x, l = k.y;
        k = k.z;
        g > e.x && (e.x = g);
        l > e.y && (e.y = l);
        k > e.z && (e.z = k);
        g < d.x && (d.x = g);
        l < d.y && (d.y = l);
        k < d.z && (d.z = k);
      }
    };
  }, {"../math/Vec3":30, "./ConvexPolyhedron":38, "./Shape":43}], 38:[function(c, g) {
    function b(b, c, d) {
      e.call(this);
      this.type = e.types.CONVEXPOLYHEDRON;
      this.vertices = b || [];
      this.worldVertices = [];
      this.worldVerticesNeedsUpdate = !0;
      this.faces = c || [];
      this.faceNormals = [];
      this.computeNormals();
      this.worldFaceNormalsNeedsUpdate = !0;
      this.worldFaceNormals = [];
      this.uniqueEdges = [];
      this.uniqueAxes = d ? d.slice() : null;
      this.computeEdges();
      this.updateBoundingSphereRadius();
    }
    g.exports = b;
    var e = c("./Shape"), f = c("../math/Vec3"), k = (c("../math/Quaternion"), c("../math/Transform"));
    b.prototype = new e;
    b.prototype.constructor = b;
    var n = new f;
    b.prototype.computeEdges = function() {
      for (var b = this.faces, c = this.vertices, d = (c.length, this.uniqueEdges), e = d.length = 0; e !== b.length; e++) {
        for (var f = b[e], k = f.length, g = 0; g !== k; g++) {
          c[f[g]].vsub(c[f[(g + 1) % k]], n);
          n.normalize();
          for (var l = !1, q = 0; q !== d.length; q++) {
            if (d[q].almostEquals(n) || d[q].almostEquals(n)) {
              l = !0;
              break;
            }
          }
          l || d.push(n.clone());
        }
      }
    };
    b.prototype.computeNormals = function() {
      this.faceNormals.length = this.faces.length;
      for (var b = 0; b < this.faces.length; b++) {
        for (var c = 0; c < this.faces[b].length; c++) {
          if (!this.vertices[this.faces[b][c]]) {
            throw Error("Vertex " + this.faces[b][c] + " not found!");
          }
        }
        c = this.faceNormals[b] || new f;
        this.getFaceNormal(b, c);
        c.negate(c);
        this.faceNormals[b] = c;
        if (0 > c.dot(this.vertices[this.faces[b][0]])) {
          for (console.error(".faceNormals[" + b + "] = Vec3(" + c.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule."), c = 0; c < this.faces[b].length; c++) {
            console.warn(".vertices[" + this.faces[b][c] + "] = Vec3(" + this.vertices[this.faces[b][c]].toString() + ")");
          }
        }
      }
    };
    var p = new f, m = new f;
    b.computeNormal = function(b, c, d, e) {
      c.vsub(b, m);
      d.vsub(c, p);
      p.cross(m, e);
      e.isZero() || e.normalize();
    };
    b.prototype.getFaceNormal = function(c, d) {
      c = this.faces[c];
      return b.computeNormal(this.vertices[c[0]], this.vertices[c[1]], this.vertices[c[2]], d);
    };
    var t = new f;
    b.prototype.clipAgainstHull = function(b, c, d, e, k, g, l, q, m) {
      for (var n = -1, v = -Number.MAX_VALUE, p = 0; p < d.faces.length; p++) {
        t.copy(d.faceNormals[p]);
        k.vmult(t, t);
        var u = t.dot(g);
        u > v && (v = u, n = p);
      }
      v = [];
      p = d.faces[n];
      u = p.length;
      for (var z = 0; u > z; z++) {
        var w = d.vertices[p[z]], y = new f;
        y.copy(w);
        k.vmult(y, y);
        e.vadd(y, y);
        v.push(y);
      }
      0 <= n && this.clipFaceAgainstHull(g, b, c, v, l, q, m);
    };
    var d = new f, l = new f, u = new f, w = new f, y = new f, x = new f;
    b.prototype.findSeparatingAxis = function(b, c, e, f, k, g, q, m) {
      var n = Number.MAX_VALUE, t = 0;
      if (this.uniqueAxes) {
        for (var v = 0; v !== this.uniqueAxes.length; v++) {
          e.vmult(this.uniqueAxes[v], d);
          var p = this.testSepAxis(d, b, c, e, f, k);
          if (!1 === p) {
            return !1;
          }
          n > p && (n = p, g.copy(d));
        }
      } else {
        var z = q ? q.length : this.faces.length;
        for (v = 0; z > v; v++) {
          p = q ? q[v] : v;
          d.copy(this.faceNormals[p]);
          e.vmult(d, d);
          p = this.testSepAxis(d, b, c, e, f, k);
          if (!1 === p) {
            return !1;
          }
          n > p && (n = p, g.copy(d));
        }
      }
      if (b.uniqueAxes) {
        for (v = 0; v !== b.uniqueAxes.length; v++) {
          k.vmult(b.uniqueAxes[v], l);
          t++;
          p = this.testSepAxis(l, b, c, e, f, k);
          if (!1 === p) {
            return !1;
          }
          n > p && (n = p, g.copy(l));
        }
      } else {
        for (q = m ? m.length : b.faces.length, v = 0; q > v; v++) {
          p = m ? m[v] : v;
          l.copy(b.faceNormals[p]);
          k.vmult(l, l);
          t++;
          p = this.testSepAxis(l, b, c, e, f, k);
          if (!1 === p) {
            return !1;
          }
          n > p && (n = p, g.copy(l));
        }
      }
      for (m = 0; m !== this.uniqueEdges.length; m++) {
        for (e.vmult(this.uniqueEdges[m], w), t = 0; t !== b.uniqueEdges.length; t++) {
          if (k.vmult(b.uniqueEdges[t], y), w.cross(y, x), !x.almostZero()) {
            x.normalize();
            v = this.testSepAxis(x, b, c, e, f, k);
            if (!1 === v) {
              return !1;
            }
            n > v && (n = v, g.copy(x));
          }
        }
      }
      return f.vsub(c, u), 0 < u.dot(g) && g.negate(g), !0;
    };
    var q = [], v = [];
    b.prototype.testSepAxis = function(c, d, e, f, k, g) {
      b.project(this, c, e, f, q);
      b.project(d, c, k, g, v);
      e = q[0];
      c = q[1];
      d = v[0];
      f = v[1];
      if (f > e || c > d) {
        return !1;
      }
      e -= f;
      c = d - c;
      return c > e ? e : c;
    };
    var z = new f, C = new f;
    b.prototype.calculateLocalInertia = function(b, c) {
      this.computeLocalAABB(z, C);
      var d = C.x - z.x, e = C.y - z.y, f = C.z - z.z;
      c.x = 1 / 12 * b * (4 * e * e + 4 * f * f);
      c.y = 1 / 12 * b * (4 * d * d + 4 * f * f);
      c.z = 1 / 12 * b * (4 * e * e + 4 * d * d);
    };
    b.prototype.getPlaneConstantOfFace = function(b) {
      return -this.faceNormals[b].dot(this.vertices[this.faces[b][0]]);
    };
    var A = new f, D = new f, E = new f, B = new f, G = new f, H = new f, K = new f, I = new f;
    b.prototype.clipFaceAgainstHull = function(b, c, d, e, f, k, g) {
      for (var l = [], q = -1, m = Number.MAX_VALUE, n = 0; n < this.faces.length; n++) {
        A.copy(this.faceNormals[n]);
        d.vmult(A, A);
        var t = A.dot(b);
        m > t && (m = t, q = n);
      }
      if (!(0 > q)) {
        b = this.faces[q];
        b.connectedFaces = [];
        for (m = 0; m < this.faces.length; m++) {
          for (n = 0; n < this.faces[m].length; n++) {
            -1 !== b.indexOf(this.faces[m][n]) && m !== q && -1 === b.connectedFaces.indexOf(m) && b.connectedFaces.push(m);
          }
        }
        m = (e.length, b.length);
        for (n = 0; m > n; n++) {
          t = this.vertices[b[n]];
          t.vsub(this.vertices[b[(n + 1) % m]], D);
          E.copy(D);
          d.vmult(E, E);
          c.vadd(E, E);
          B.copy(this.faceNormals[q]);
          d.vmult(B, B);
          c.vadd(B, B);
          E.cross(B, G);
          G.negate(G);
          H.copy(t);
          d.vmult(H, H);
          c.vadd(H, H);
          t = (-H.dot(G), b.connectedFaces[n]);
          K.copy(this.faceNormals[t]);
          t = this.getPlaneConstantOfFace(t);
          I.copy(K);
          d.vmult(I, I);
          t -= I.dot(c);
          for (this.clipFaceAgainstPlane(e, l, I, t); e.length;) {
            e.shift();
          }
          for (; l.length;) {
            e.push(l.shift());
          }
        }
        K.copy(this.faceNormals[q]);
        t = this.getPlaneConstantOfFace(q);
        I.copy(K);
        d.vmult(I, I);
        t -= I.dot(c);
        for (m = 0; m < e.length; m++) {
          if (c = I.dot(e[m]) + t, f >= c && (console.log("clamped: depth=" + c + " to minDist=" + (f + "")), c = f), k >= c) {
            d = e[m], 0 >= c && g.push({point:d, normal:I, depth:c});
          }
        }
      }
    };
    b.prototype.clipFaceAgainstPlane = function(b, c, d, e) {
      var k, g = b.length;
      if (2 > g) {
        return c;
      }
      var l = b[b.length - 1], q = b[0];
      var m = d.dot(l) + e;
      for (var n = 0; g > n; n++) {
        if (q = b[n], k = d.dot(q) + e, 0 > m) {
          if (0 > k) {
            var t = new f;
            t.copy(q);
          } else {
            t = new f, l.lerp(q, m / (m - k), t);
          }
          c.push(t);
        } else {
          0 > k && (t = new f, l.lerp(q, m / (m - k), t), c.push(t), c.push(q));
        }
        l = q;
        m = k;
      }
      return c;
    };
    b.prototype.computeWorldVertices = function(b, c) {
      for (var d = this.vertices.length; this.worldVertices.length < d;) {
        this.worldVertices.push(new f);
      }
      for (var e = this.vertices, k = this.worldVertices, g = 0; g !== d; g++) {
        c.vmult(e[g], k[g]), b.vadd(k[g], k[g]);
      }
      this.worldVerticesNeedsUpdate = !1;
    };
    new f;
    b.prototype.computeLocalAABB = function(b, c) {
      var d = this.vertices.length, e = this.vertices;
      b.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      c.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
      for (var f = 0; d > f; f++) {
        var k = e[f];
        k.x < b.x ? b.x = k.x : k.x > c.x && (c.x = k.x);
        k.y < b.y ? b.y = k.y : k.y > c.y && (c.y = k.y);
        k.z < b.z ? b.z = k.z : k.z > c.z && (c.z = k.z);
      }
    };
    b.prototype.computeWorldFaceNormals = function(b) {
      for (var c = this.faceNormals.length; this.worldFaceNormals.length < c;) {
        this.worldFaceNormals.push(new f);
      }
      for (var d = this.faceNormals, e = this.worldFaceNormals, k = 0; k !== c; k++) {
        b.vmult(d[k], e[k]);
      }
      this.worldFaceNormalsNeedsUpdate = !1;
    };
    b.prototype.updateBoundingSphereRadius = function() {
      for (var b = 0, c = this.vertices, d = 0, e = c.length; d !== e; d++) {
        var f = c[d].norm2();
        f > b && (b = f);
      }
      this.boundingSphereRadius = Math.sqrt(b);
    };
    var L = new f;
    b.prototype.calculateWorldAABB = function(b, c, d, e) {
      for (var f, k, g, l, q, m, n = this.vertices.length, t = this.vertices, v = 0; n > v; v++) {
        L.copy(t[v]);
        c.vmult(L, L);
        b.vadd(L, L);
        var p = L;
        p.x < f || void 0 === f ? f = p.x : (p.x > l || void 0 === l) && (l = p.x);
        p.y < k || void 0 === k ? k = p.y : (p.y > q || void 0 === q) && (q = p.y);
        p.z < g || void 0 === g ? g = p.z : (p.z > m || void 0 === m) && (m = p.z);
      }
      d.set(f, k, g);
      e.set(l, q, m);
    };
    b.prototype.volume = function() {
      return 4 * Math.PI * this.boundingSphereRadius / 3;
    };
    b.prototype.getAveragePointLocal = function(b) {
      b = b || new f;
      for (var c = this.vertices.length, d = this.vertices, e = 0; c > e; e++) {
        b.vadd(d[e], b);
      }
      return b.mult(1 / c, b), b;
    };
    b.prototype.transformAllPoints = function(b, c) {
      var d = this.vertices.length, e = this.vertices;
      if (c) {
        for (var f = 0; d > f; f++) {
          var k = e[f];
          c.vmult(k, k);
        }
        for (f = 0; f < this.faceNormals.length; f++) {
          k = this.faceNormals[f], c.vmult(k, k);
        }
      }
      if (b) {
        for (f = 0; d > f; f++) {
          k = e[f], k.vadd(b, k);
        }
      }
    };
    var R = new f, J = new f, Q = new f;
    b.prototype.pointIsInside = function(b) {
      var c = this.vertices, d = this.faces, e = this.faceNormals, f = this.faces.length;
      this.getAveragePointLocal(R);
      for (var k = 0; f > k; k++) {
        var g = (this.faces[k].length, e[k]);
        var l = c[d[k][0]], q = J;
        b.vsub(l, q);
        q = g.dot(q);
        var m = Q;
        R.vsub(l, m);
        g = g.dot(m);
        if (0 > q && 0 < g || 0 < q && 0 > g) {
          return !1;
        }
      }
      return -1;
    };
    var aa = (new f, new f), U = new f;
    b.project = function(b, c, d, e, f) {
      var g = b.vertices.length;
      b = b.vertices;
      U.setZero();
      k.vectorToLocalFrame(d, e, c, aa);
      k.pointToLocalFrame(d, e, U, U);
      e = U.dot(aa);
      d = c = b[0].dot(aa);
      for (var l = 1; g > l; l++) {
        var q = b[l].dot(aa);
        q > c && (c = q);
        d > q && (d = q);
      }
      if (d -= e, c -= e, d > c) {
        g = d, d = c, c = g;
      }
      f[0] = c;
      f[1] = d;
    };
  }, {"../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "./Shape":43}], 39:[function(c, g) {
    function b(b, c, g, t) {
      var d = [], l = [], m = [], n = [], p = [], x = Math.cos, q = Math.sin;
      d.push(new f(c * x(0), c * q(0), .5 * -g));
      n.push(0);
      d.push(new f(b * x(0), b * q(0), .5 * g));
      p.push(1);
      for (var v = 0; t > v; v++) {
        var z = 2 * Math.PI / t * (v + 1), C = 2 * Math.PI / t * (v + .5);
        t - 1 > v ? (d.push(new f(c * x(z), c * q(z), .5 * -g)), n.push(2 * v + 2), d.push(new f(b * x(z), b * q(z), .5 * g)), p.push(2 * v + 3), m.push([2 * v + 2, 2 * v + 3, 2 * v + 1, 2 * v])) : m.push([0, 1, 2 * v + 1, 2 * v]);
        (1 === t % 2 || t / 2 > v) && l.push(new f(x(C), q(C), 0));
      }
      m.push(p);
      l.push(new f(0, 0, 1));
      b = [];
      for (v = 0; v < n.length; v++) {
        b.push(n[n.length - v - 1]);
      }
      m.push(b);
      this.type = e.types.CONVEXPOLYHEDRON;
      k.call(this, d, m, l);
    }
    g.exports = b;
    var e = c("./Shape"), f = c("../math/Vec3"), k = (c("../math/Quaternion"), c("./ConvexPolyhedron"));
    b.prototype = new k;
  }, {"../math/Quaternion":28, "../math/Vec3":30, "./ConvexPolyhedron":38, "./Shape":43}], 40:[function(c, g) {
    function b(b, c) {
      c = n.defaults(c, {maxValue:null, minValue:null, elementSize:1});
      this.data = b;
      this.maxValue = c.maxValue;
      this.minValue = c.minValue;
      this.elementSize = c.elementSize;
      null === c.minValue && this.updateMinValue();
      null === c.maxValue && this.updateMaxValue();
      this.cacheEnabled = !0;
      e.call(this);
      this.pillarConvex = new f;
      this.pillarOffset = new k;
      this.type = e.types.HEIGHTFIELD;
      this.updateBoundingSphereRadius();
      this._cachedPillars = {};
    }
    var e = c("./Shape"), f = c("./ConvexPolyhedron"), k = c("../math/Vec3"), n = c("../utils/Utils");
    g.exports = b;
    b.prototype = new e;
    b.prototype.update = function() {
      this._cachedPillars = {};
    };
    b.prototype.updateMinValue = function() {
      for (var b = this.data, c = b[0][0], e = 0; e !== b.length; e++) {
        for (var d = 0; d !== b[e].length; d++) {
          var f = b[e][d];
          c > f && (c = f);
        }
      }
      this.minValue = c;
    };
    b.prototype.updateMaxValue = function() {
      for (var b = this.data, c = b[0][0], e = 0; e !== b.length; e++) {
        for (var d = 0; d !== b[e].length; d++) {
          var f = b[e][d];
          f > c && (c = f);
        }
      }
      this.maxValue = c;
    };
    b.prototype.setHeightValueAtIndex = function(b, c, e) {
      this.data[b][c] = e;
      this.clearCachedConvexTrianglePillar(b, c, !1);
      0 < b && (this.clearCachedConvexTrianglePillar(b - 1, c, !0), this.clearCachedConvexTrianglePillar(b - 1, c, !1));
      0 < c && (this.clearCachedConvexTrianglePillar(b, c - 1, !0), this.clearCachedConvexTrianglePillar(b, c - 1, !1));
      0 < c && 0 < b && this.clearCachedConvexTrianglePillar(b - 1, c - 1, !0);
    };
    b.prototype.getRectMinMax = function(b, c, e, d, f) {
      f = f || [];
      for (var k = this.data, g = this.minValue; e >= b; b++) {
        for (var l = c; d >= l; l++) {
          var m = k[b][l];
          m > g && (g = m);
        }
      }
      f[0] = this.minValue;
      f[1] = g;
    };
    b.prototype.getIndexOfPosition = function(b, c, e, d) {
      var f = this.elementSize, k = this.data;
      b = Math.floor(b / f);
      c = Math.floor(c / f);
      return e[0] = b, e[1] = c, d && (0 > b && (b = 0), 0 > c && (c = 0), b >= k.length - 1 && (b = k.length - 1), c >= k[0].length - 1 && (c = k[0].length - 1)), 0 > b || 0 > c || b >= k.length - 1 || c >= k[0].length - 1 ? !1 : !0;
    };
    b.prototype.getHeightAt = function(b, c, e) {
      var d = [];
      this.getIndexOfPosition(b, c, d, e);
      b = [];
      return this.getRectMinMax(d[0], d[1] + 1, d[0], d[1] + 1, b), (b[0] + b[1]) / 2;
    };
    b.prototype.getCacheConvexTrianglePillarKey = function(b, c, e) {
      return b + "_" + c + "_" + (e ? 1 : 0);
    };
    b.prototype.getCachedConvexTrianglePillar = function(b, c, e) {
      return this._cachedPillars[this.getCacheConvexTrianglePillarKey(b, c, e)];
    };
    b.prototype.setCachedConvexTrianglePillar = function(b, c, e, d, f) {
      this._cachedPillars[this.getCacheConvexTrianglePillarKey(b, c, e)] = {convex:d, offset:f};
    };
    b.prototype.clearCachedConvexTrianglePillar = function(b, c, e) {
      delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(b, c, e)];
    };
    b.prototype.getConvexTrianglePillar = function(b, c, e) {
      var d = this.pillarConvex, g = this.pillarOffset;
      if (this.cacheEnabled) {
        var m = this.getCachedConvexTrianglePillar(b, c, e);
        if (m) {
          return this.pillarConvex = m.convex, void(this.pillarOffset = m.offset);
        }
        d = new f;
        g = new k;
        this.pillarConvex = d;
        this.pillarOffset = g;
      }
      m = this.data;
      var n = this.elementSize, t = d.faces;
      d.vertices.length = 6;
      for (var p = 0; 6 > p; p++) {
        d.vertices[p] || (d.vertices[p] = new k);
      }
      t.length = 5;
      for (p = 0; 5 > p; p++) {
        t[p] || (t[p] = []);
      }
      p = d.vertices;
      var q = (Math.min(m[b][c], m[b + 1][c], m[b][c + 1], m[b + 1][c + 1]) - this.minValue) / 2 + this.minValue;
      e ? (g.set((b + .75) * n, (c + .75) * n, q), p[0].set(.25 * n, .25 * n, m[b + 1][c + 1] - q), p[1].set(-.75 * n, .25 * n, m[b][c + 1] - q), p[2].set(.25 * n, -.75 * n, m[b + 1][c] - q), p[3].set(.25 * n, .25 * n, -q - 1), p[4].set(-.75 * n, .25 * n, -q - 1), p[5].set(.25 * n, -.75 * n, -q - 1), t[0][0] = 0, t[0][1] = 1, t[0][2] = 2, t[1][0] = 5, t[1][1] = 4, t[1][2] = 3, t[2][0] = 2, t[2][1] = 5, t[2][2] = 3, t[2][3] = 0, t[3][0] = 3, t[3][1] = 4, t[3][2] = 1, t[3][3] = 0, t[4][0] = 1, t[4][1] = 
      4, t[4][2] = 5, t[4][3] = 2) : (g.set((b + .25) * n, (c + .25) * n, q), p[0].set(-.25 * n, -.25 * n, m[b][c] - q), p[1].set(.75 * n, -.25 * n, m[b + 1][c] - q), p[2].set(-.25 * n, .75 * n, m[b][c + 1] - q), p[3].set(-.25 * n, -.25 * n, -q - 1), p[4].set(.75 * n, -.25 * n, -q - 1), p[5].set(-.25 * n, .75 * n, -q - 1), t[0][0] = 0, t[0][1] = 1, t[0][2] = 2, t[1][0] = 5, t[1][1] = 4, t[1][2] = 3, t[2][0] = 0, t[2][1] = 2, t[2][2] = 5, t[2][3] = 3, t[3][0] = 1, t[3][1] = 0, t[3][2] = 3, t[3][3] = 
      4, t[4][0] = 4, t[4][1] = 5, t[4][2] = 2, t[4][3] = 1);
      d.computeNormals();
      d.computeEdges();
      d.updateBoundingSphereRadius();
      this.setCachedConvexTrianglePillar(b, c, e, d, g);
    };
    b.prototype.calculateLocalInertia = function(b, c) {
      return c = c || new k, c.set(0, 0, 0), c;
    };
    b.prototype.volume = function() {
      return Number.MAX_VALUE;
    };
    b.prototype.calculateWorldAABB = function(b, c, e, d) {
      e.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
      d.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    };
    b.prototype.updateBoundingSphereRadius = function() {
      var b = this.data, c = this.elementSize;
      this.boundingSphereRadius = (new k(b.length * c, b[0].length * c, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue)))).norm();
    };
  }, {"../math/Vec3":30, "../utils/Utils":53, "./ConvexPolyhedron":38, "./Shape":43}], 41:[function(c, g) {
    function b() {
      e.call(this);
      this.type = e.types.PARTICLE;
    }
    g.exports = b;
    var e = c("./Shape"), f = c("../math/Vec3");
    b.prototype = new e;
    b.prototype.constructor = b;
    b.prototype.calculateLocalInertia = function(b, c) {
      return c = c || new f, c.set(0, 0, 0), c;
    };
    b.prototype.volume = function() {
      return 0;
    };
    b.prototype.updateBoundingSphereRadius = function() {
      this.boundingSphereRadius = 0;
    };
    b.prototype.calculateWorldAABB = function(b, c, e, f) {
      e.copy(b);
      f.copy(b);
    };
  }, {"../math/Vec3":30, "./Shape":43}], 42:[function(c, g) {
    function b() {
      e.call(this);
      this.type = e.types.PLANE;
      this.worldNormal = new f;
      this.worldNormalNeedsUpdate = !0;
      this.boundingSphereRadius = Number.MAX_VALUE;
    }
    g.exports = b;
    var e = c("./Shape"), f = c("../math/Vec3");
    b.prototype = new e;
    b.prototype.constructor = b;
    b.prototype.computeWorldNormal = function(b) {
      var c = this.worldNormal;
      c.set(0, 0, 1);
      b.vmult(c, c);
      this.worldNormalNeedsUpdate = !1;
    };
    b.prototype.calculateLocalInertia = function(b, c) {
      return c || new f;
    };
    b.prototype.volume = function() {
      return Number.MAX_VALUE;
    };
    var k = new f;
    b.prototype.calculateWorldAABB = function(b, c, e, f) {
      k.set(0, 0, 1);
      c.vmult(k, k);
      c = Number.MAX_VALUE;
      e.set(-c, -c, -c);
      f.set(c, c, c);
      1 === k.x && (f.x = b.x);
      1 === k.y && (f.y = b.y);
      1 === k.z && (f.z = b.z);
      -1 === k.x && (e.x = b.x);
      -1 === k.y && (e.y = b.y);
      -1 === k.z && (e.z = b.z);
    };
    b.prototype.updateBoundingSphereRadius = function() {
      this.boundingSphereRadius = Number.MAX_VALUE;
    };
  }, {"../math/Vec3":30, "./Shape":43}], 43:[function(c, g) {
    function b() {
      this.id = b.idCounter++;
      this.boundingSphereRadius = this.type = 0;
      this.collisionResponse = !0;
      this.material = null;
    }
    g.exports = b;
    b = c("./Shape");
    c("../math/Vec3");
    c("../math/Quaternion");
    c("../material/Material");
    b.prototype.constructor = b;
    b.prototype.updateBoundingSphereRadius = function() {
      throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
    };
    b.prototype.volume = function() {
      throw "volume() not implemented for shape type " + this.type;
    };
    b.prototype.calculateLocalInertia = function() {
      throw "calculateLocalInertia() not implemented for shape type " + this.type;
    };
    b.idCounter = 0;
    b.types = {SPHERE:1, PLANE:2, BOX:4, COMPOUND:8, CONVEXPOLYHEDRON:16, HEIGHTFIELD:32, PARTICLE:64, CYLINDER:128, TRIMESH:256};
  }, {"../material/Material":25, "../math/Quaternion":28, "../math/Vec3":30, "./Shape":43}], 44:[function(c, g) {
    function b(b) {
      if (e.call(this), this.radius = void 0 !== b ? Number(b) : 1, this.type = e.types.SPHERE, 0 > this.radius) {
        throw Error("The sphere radius cannot be negative.");
      }
      this.updateBoundingSphereRadius();
    }
    g.exports = b;
    var e = c("./Shape"), f = c("../math/Vec3");
    b.prototype = new e;
    b.prototype.constructor = b;
    b.prototype.calculateLocalInertia = function(b, c) {
      c = c || new f;
      b = 2 * b * this.radius * this.radius / 5;
      return c.x = b, c.y = b, c.z = b, c;
    };
    b.prototype.volume = function() {
      return 4 * Math.PI * this.radius / 3;
    };
    b.prototype.updateBoundingSphereRadius = function() {
      this.boundingSphereRadius = this.radius;
    };
    b.prototype.calculateWorldAABB = function(b, c, e, f) {
      c = this.radius;
      for (var k = ["x", "y", "z"], d = 0; d < k.length; d++) {
        var g = k[d];
        e[g] = b[g] - c;
        f[g] = b[g] + c;
      }
    };
  }, {"../math/Vec3":30, "./Shape":43}], 45:[function(c, g) {
    function b(b, c) {
      e.call(this);
      this.type = e.types.TRIMESH;
      this.vertices = new Float32Array(b);
      this.indices = new Int16Array(c);
      this.normals = new Float32Array(c.length);
      this.aabb = new n;
      this.edges = null;
      this.scale = new f(1, 1, 1);
      this.tree = new p;
      this.updateEdges();
      this.updateNormals();
      this.updateAABB();
      this.updateBoundingSphereRadius();
      this.updateTree();
    }
    g.exports = b;
    var e = c("./Shape"), f = c("../math/Vec3"), k = (c("../math/Quaternion"), c("../math/Transform")), n = c("../collision/AABB"), p = c("../utils/Octree");
    b.prototype = new e;
    b.prototype.constructor = b;
    var m = new f;
    b.prototype.updateTree = function() {
      var b = this.tree;
      b.reset();
      b.aabb.copy(this.aabb);
      var c = this.scale;
      b.aabb.lowerBound.x *= 1 / c.x;
      b.aabb.lowerBound.y *= 1 / c.y;
      b.aabb.lowerBound.z *= 1 / c.z;
      b.aabb.upperBound.x *= 1 / c.x;
      b.aabb.upperBound.y *= 1 / c.y;
      b.aabb.upperBound.z *= 1 / c.z;
      c = new n;
      for (var d = new f, e = new f, k = new f, g = [d, e, k], q = 0; q < this.indices.length / 3; q++) {
        var l = 3 * q;
        this._getUnscaledVertex(this.indices[l], d);
        this._getUnscaledVertex(this.indices[l + 1], e);
        this._getUnscaledVertex(this.indices[l + 2], k);
        c.setFromPoints(g);
        b.insert(c, q);
      }
      b.removeEmptyNodes();
    };
    var t = new n;
    b.prototype.getTrianglesInAABB = function(b, c) {
      t.copy(b);
      var d = this.scale;
      b = d.x;
      var e = d.y;
      d = d.z;
      var f = t.lowerBound, k = t.upperBound;
      return f.x /= b, f.y /= e, f.z /= d, k.x /= b, k.y /= e, k.z /= d, this.tree.aabbQuery(t, c);
    };
    b.prototype.setScale = function(b) {
      var c = b.x === b.y === b.z;
      this.scale.x === this.scale.y === this.scale.z && c || this.updateNormals();
      this.scale.copy(b);
      this.updateAABB();
      this.updateBoundingSphereRadius();
    };
    b.prototype.updateNormals = function() {
      for (var c = this.normals, d = 0; d < this.indices.length / 3; d++) {
        var e = 3 * d, f = this.indices[e + 1], k = this.indices[e + 2];
        this.getVertex(this.indices[e], y);
        this.getVertex(f, x);
        this.getVertex(k, q);
        b.computeNormal(x, y, q, m);
        c[e] = m.x;
        c[e + 1] = m.y;
        c[e + 2] = m.z;
      }
    };
    b.prototype.updateEdges = function() {
      for (var b = {}, c = function() {
        b[k > f ? f + "_" + k : k + "_" + f] = !0;
      }, d = 0; d < this.indices.length / 3; d++) {
        var e = 3 * d, f = this.indices[e], k = this.indices[e + 1];
        e = this.indices[e + 2];
        c(f, k);
        c(k, e);
        c(e, f);
      }
      c = Object.keys(b);
      this.edges = new Int16Array(2 * c.length);
      for (d = 0; d < c.length; d++) {
        e = c[d].split("_"), this.edges[2 * d] = parseInt(e[0], 10), this.edges[2 * d + 1] = parseInt(e[1], 10);
      }
    };
    b.prototype.getEdgeVertex = function(b, c, d) {
      this.getVertex(this.edges[2 * b + (c ? 1 : 0)], d);
    };
    var d = new f, l = new f;
    b.prototype.getEdgeVector = function(b, c) {
      this.getEdgeVertex(b, 0, d);
      this.getEdgeVertex(b, 1, l);
      l.vsub(d, c);
    };
    var u = new f, w = new f;
    b.computeNormal = function(b, c, d, e) {
      c.vsub(b, w);
      d.vsub(c, u);
      u.cross(w, e);
      e.isZero() || e.normalize();
    };
    var y = new f, x = new f, q = new f;
    b.prototype.getVertex = function(b, c) {
      var d = this.scale;
      return this._getUnscaledVertex(b, c), c.x *= d.x, c.y *= d.y, c.z *= d.z, c;
    };
    b.prototype._getUnscaledVertex = function(b, c) {
      b *= 3;
      var d = this.vertices;
      return c.set(d[b], d[b + 1], d[b + 2]);
    };
    b.prototype.getWorldVertex = function(b, c, d, e) {
      return this.getVertex(b, e), k.pointToWorldFrame(c, d, e, e), e;
    };
    b.prototype.getTriangleVertices = function(b, c, d, e) {
      b *= 3;
      this.getVertex(this.indices[b], c);
      this.getVertex(this.indices[b + 1], d);
      this.getVertex(this.indices[b + 2], e);
    };
    b.prototype.getNormal = function(b, c) {
      b *= 3;
      return c.set(this.normals[b], this.normals[b + 1], this.normals[b + 2]);
    };
    var v = new n;
    b.prototype.calculateLocalInertia = function(b, c) {
      this.computeLocalAABB(v);
      var d = v.upperBound.x - v.lowerBound.x, e = v.upperBound.y - v.lowerBound.y, f = v.upperBound.z - v.lowerBound.z;
      return c.set(1 / 12 * b * (4 * e * e + 4 * f * f), 1 / 12 * b * (4 * d * d + 4 * f * f), 1 / 12 * b * (4 * e * e + 4 * d * d));
    };
    var z = new f;
    b.prototype.computeLocalAABB = function(b) {
      var c = b.lowerBound;
      b = b.upperBound;
      var d = this.vertices.length, e = (this.vertices, z);
      this.getVertex(0, e);
      c.copy(e);
      b.copy(e);
      for (var f = 0; f !== d; f++) {
        this.getVertex(f, e), e.x < c.x ? c.x = e.x : e.x > b.x && (b.x = e.x), e.y < c.y ? c.y = e.y : e.y > b.y && (b.y = e.y), e.z < c.z ? c.z = e.z : e.z > b.z && (b.z = e.z);
      }
    };
    b.prototype.updateAABB = function() {
      this.computeLocalAABB(this.aabb);
    };
    b.prototype.updateBoundingSphereRadius = function() {
      var b = 0, c = this.vertices, d = new f, e = 0;
      for (c = c.length / 3; e !== c; e++) {
        this.getVertex(e, d);
        var k = d.norm2();
        k > b && (b = k);
      }
      this.boundingSphereRadius = Math.sqrt(b);
    };
    var C = (new f, new k), A = new n;
    b.prototype.calculateWorldAABB = function(b, c, d, e) {
      C.position = b;
      C.quaternion = c;
      this.aabb.toWorldFrame(C, A);
      d.copy(A.lowerBound);
      e.copy(A.upperBound);
    };
    b.prototype.volume = function() {
      return 4 * Math.PI * this.boundingSphereRadius / 3;
    };
    b.createTorus = function(c, d, e, f, k) {
      c = c || 1;
      d = d || .5;
      e = e || 8;
      f = f || 6;
      k = k || 2 * Math.PI;
      for (var g = [], q = [], l = 0; e >= l; l++) {
        for (var m = 0; f >= m; m++) {
          var n = m / f * k, t = l / e * Math.PI * 2;
          g.push((c + d * Math.cos(t)) * Math.cos(n), (c + d * Math.cos(t)) * Math.sin(n), d * Math.sin(t));
        }
      }
      for (l = 1; e >= l; l++) {
        for (m = 1; f >= m; m++) {
          c = (f + 1) * (l - 1) + m - 1, d = (f + 1) * (l - 1) + m, k = (f + 1) * l + m, q.push((f + 1) * l + m - 1, c, k), q.push(c, d, k);
        }
      }
      return new b(g, q);
    };
  }, {"../collision/AABB":3, "../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "../utils/Octree":50, "./Shape":43}], 46:[function(c, g) {
    function b() {
      e.call(this);
      this.iterations = 10;
      this.tolerance = 1E-7;
    }
    g.exports = b;
    var e = (c("../math/Vec3"), c("../math/Quaternion"), c("./Solver"));
    b.prototype = new e;
    var f = [], k = [], n = [];
    b.prototype.solve = function(b, c) {
      var e, d = 0, g = this.iterations, m = this.tolerance * this.tolerance, p = this.equations, y = p.length;
      c = c.bodies;
      var x = c.length;
      if (0 !== y) {
        for (e = 0; e !== x; e++) {
          c[e].updateSolveMassProperties();
        }
      }
      k.length = y;
      n.length = y;
      f.length = y;
      for (e = 0; e !== y; e++) {
        var q = p[e];
        f[e] = 0;
        n[e] = q.computeB(b);
        k[e] = 1 / q.computeC();
      }
      if (0 !== y) {
        for (e = 0; e !== x; e++) {
          q = c[e], d = q.wlambda, q.vlambda.set(0, 0, 0), d && d.set(0, 0, 0);
        }
        for (d = 0; d !== g; d++) {
          for (var v = e = 0; v !== y; v++) {
            q = p[v];
            var z = n[v];
            var C = k[v];
            b = f[v];
            var A = q.computeGWlambda();
            z = C * (z - A - q.eps * b);
            b + z < q.minForce ? z = q.minForce - b : b + z > q.maxForce && (z = q.maxForce - b);
            f[v] += z;
            e += 0 < z ? z : -z;
            q.addToWlambda(z);
          }
          if (m > e * e) {
            break;
          }
        }
        for (e = 0; e !== x; e++) {
          q = c[e], g = q.velocity, m = q.angularVelocity, g.vadd(q.vlambda, g), m && m.vadd(q.wlambda, m);
        }
      }
      return d;
    };
  }, {"../math/Quaternion":28, "../math/Vec3":30, "./Solver":47}], 47:[function(c, g) {
    function b() {
      this.equations = [];
    }
    g.exports = b;
    b.prototype.solve = function() {
      return 0;
    };
    b.prototype.addEquation = function(b) {
      b.enabled && this.equations.push(b);
    };
    b.prototype.removeEquation = function(b) {
      var c = this.equations;
      b = c.indexOf(b);
      -1 !== b && c.splice(b, 1);
    };
    b.prototype.removeAllEquations = function() {
      this.equations.length = 0;
    };
  }, {}], 48:[function(c, g) {
    function b(b) {
      n.call(this);
      this.iterations = 10;
      this.tolerance = 1E-7;
      this.subsolver = b;
      this.nodes = [];
      for (this.nodePool = []; 128 > this.nodePool.length;) {
        this.nodePool.push(this.createNode());
      }
    }
    function e(b) {
      for (var c = b.length, e = 0; e !== c; e++) {
        var f = b[e];
        if (!(f.visited || f.body.type & d)) {
          return f;
        }
      }
      return !1;
    }
    function f(b, c, d) {
      c.push(b.body);
      c = b.eqs.length;
      for (var e = 0; e !== c; e++) {
        var f = b.eqs[e];
        -1 === d.indexOf(f) && d.push(f);
      }
    }
    function k(b, c) {
      return c.id - b.id;
    }
    g.exports = b;
    var n = (c("../math/Vec3"), c("../math/Quaternion"), c("./Solver"));
    c = c("../objects/Body");
    b.prototype = new n;
    var p = [], m = [], t = {bodies:[]}, d = c.STATIC, l = [];
    b.prototype.createNode = function() {
      return {body:null, children:[], eqs:[], visited:!1};
    };
    b.prototype.solve = function(b, c) {
      var d = this.nodePool, g = c.bodies, q = this.equations, n = q.length, u = g.length;
      for (c = this.subsolver; d.length < u;) {
        d.push(this.createNode());
      }
      p.length = u;
      for (var w = 0; u > w; w++) {
        p[w] = d[w];
      }
      for (w = 0; w !== u; w++) {
        d = p[w], d.body = g[w], d.children.length = 0, d.eqs.length = 0, d.visited = !1;
      }
      for (d = 0; d !== n; d++) {
        u = q[d];
        w = g.indexOf(u.bi);
        var A = g.indexOf(u.bj);
        w = p[w];
        A = p[A];
        w.children.push(A);
        w.eqs.push(u);
        A.children.push(w);
        A.eqs.push(u);
      }
      g = 0;
      q = m;
      c.tolerance = this.tolerance;
      for (c.iterations = this.iterations; w = e(p);) {
        q.length = 0;
        t.bodies.length = 0;
        u = w;
        w = f;
        n = t.bodies;
        d = q;
        l.push(u);
        u.visited = !0;
        for (w(u, n, d); l.length;) {
          for (A = l.pop(); u = e(A.children);) {
            u.visited = !0, w(u, n, d), l.push(u);
          }
        }
        n = q.length;
        q = q.sort(k);
        for (w = 0; w !== n; w++) {
          c.addEquation(q[w]);
        }
        c.solve(b, t);
        c.removeAllEquations();
        g++;
      }
      return g;
    };
  }, {"../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "./Solver":47}], 49:[function(c, g) {
    c = function() {
    };
    g.exports = c;
    c.prototype = {constructor:c, addEventListener:function(b, c) {
      void 0 === this._listeners && (this._listeners = {});
      var e = this._listeners;
      return void 0 === e[b] && (e[b] = []), -1 === e[b].indexOf(c) && e[b].push(c), this;
    }, hasEventListener:function(b, c) {
      if (void 0 === this._listeners) {
        return !1;
      }
      var e = this._listeners;
      return void 0 !== e[b] && -1 !== e[b].indexOf(c) ? !0 : !1;
    }, removeEventListener:function(b, c) {
      if (void 0 === this._listeners) {
        return this;
      }
      var e = this._listeners;
      if (void 0 === e[b]) {
        return this;
      }
      c = e[b].indexOf(c);
      return -1 !== c && e[b].splice(c, 1), this;
    }, dispatchEvent:function(b) {
      if (void 0 === this._listeners) {
        return this;
      }
      var c = this._listeners[b.type];
      if (void 0 !== c) {
        b.target = this;
        for (var f = 0, k = c.length; k > f; f++) {
          c[f].call(this, b);
        }
      }
      return this;
    }};
  }, {}], 50:[function(c, g) {
    function b(b) {
      b = b || {};
      this.root = b.root || null;
      this.aabb = b.aabb ? b.aabb.clone() : new f;
      this.data = [];
      this.children = [];
    }
    function e(c, e) {
      e = e || {};
      e.root = null;
      e.aabb = c;
      b.call(this, e);
      this.maxDepth = "undefined" != typeof e.maxDepth ? e.maxDepth : 8;
    }
    var f = c("../collision/AABB"), k = c("../math/Vec3");
    g.exports = e;
    e.prototype = new b;
    b.prototype.reset = function() {
      this.children.length = this.data.length = 0;
    };
    b.prototype.insert = function(b, c, d) {
      var e = this.data;
      if (d = d || 0, !this.aabb.contains(b)) {
        return !1;
      }
      var f = this.children;
      if (d < (this.maxDepth || this.root.maxDepth)) {
        var k = !1;
        f.length || (this.subdivide(), k = !0);
        for (var g = 0; 8 !== g; g++) {
          if (f[g].insert(b, c, d + 1)) {
            return !0;
          }
        }
        k && (f.length = 0);
      }
      return e.push(c), !0;
    };
    var n = new k;
    b.prototype.subdivide = function() {
      var c = this.aabb, e = c.lowerBound, d = c.upperBound;
      c = this.children;
      c.push(new b({aabb:new f({lowerBound:new k(0, 0, 0)})}), new b({aabb:new f({lowerBound:new k(1, 0, 0)})}), new b({aabb:new f({lowerBound:new k(1, 1, 0)})}), new b({aabb:new f({lowerBound:new k(1, 1, 1)})}), new b({aabb:new f({lowerBound:new k(0, 1, 1)})}), new b({aabb:new f({lowerBound:new k(0, 0, 1)})}), new b({aabb:new f({lowerBound:new k(1, 0, 1)})}), new b({aabb:new f({lowerBound:new k(0, 1, 0)})}));
      d.vsub(e, n);
      n.scale(.5, n);
      d = this.root || this;
      for (var g = 0; 8 !== g; g++) {
        var p = c[g];
        p.root = d;
        var w = p.aabb.lowerBound;
        w.x *= n.x;
        w.y *= n.y;
        w.z *= n.z;
        w.vadd(e, w);
        w.vadd(n, p.aabb.upperBound);
      }
    };
    b.prototype.aabbQuery = function(b, c) {
      for (var d = (this.data, this.children, [this]); d.length;) {
        var e = d.pop();
        e.aabb.overlaps(b) && Array.prototype.push.apply(c, e.data);
        Array.prototype.push.apply(d, e.children);
      }
      return c;
    };
    var p = new f;
    b.prototype.rayQuery = function(b, c, d) {
      return b.getAABB(p), p.toLocalFrame(c, p), this.aabbQuery(p, d), d;
    };
    b.prototype.removeEmptyNodes = function() {
      for (var b = [this]; b.length;) {
        for (var c = b.pop(), d = c.children.length - 1; 0 <= d; d--) {
          c.children[d].data.length || c.children.splice(d, 1);
        }
        Array.prototype.push.apply(b, c.children);
      }
    };
  }, {"../collision/AABB":3, "../math/Vec3":30}], 51:[function(c, g) {
    function b() {
      this.objects = [];
      this.type = Object;
    }
    g.exports = b;
    b.prototype.release = function() {
      for (var b = arguments.length, c = 0; c !== b; c++) {
        this.objects.push(arguments[c]);
      }
    };
    b.prototype.get = function() {
      return 0 === this.objects.length ? this.constructObject() : this.objects.pop();
    };
    b.prototype.constructObject = function() {
      throw Error("constructObject() not implemented in this Pool subclass yet!");
    };
  }, {}], 52:[function(c, g) {
    function b() {
      this.data = {keys:[]};
    }
    g.exports = b;
    b.prototype.get = function(b, c) {
      if (b > c) {
        var e = c;
        c = b;
        b = e;
      }
      return this.data[b + "-" + c];
    };
    b.prototype.set = function(b, c, k) {
      if (b > c) {
        var e = c;
        c = b;
        b = e;
      }
      e = b + "-" + c;
      this.get(b, c) || this.data.keys.push(e);
      this.data[e] = k;
    };
    b.prototype.reset = function() {
      for (var b = this.data, c = b.keys; 0 < c.length;) {
        var k = c.pop();
        delete b[k];
      }
    };
  }, {}], 53:[function(c, g) {
    function b() {
    }
    g.exports = b;
    b.defaults = function(b, c) {
      b = b || {};
      for (var e in c) {
        e in b || (b[e] = c[e]);
      }
      return b;
    };
  }, {}], 54:[function(c, g) {
    function b() {
      f.call(this);
      this.type = e;
    }
    g.exports = b;
    var e = c("../math/Vec3"), f = c("./Pool");
    b.prototype = new f;
    b.prototype.constructObject = function() {
      return new e;
    };
  }, {"../math/Vec3":30, "./Pool":51}], 55:[function(c, g) {
    function b(b) {
      this.contactPointPool = [];
      this.frictionEquationPool = [];
      this.result = [];
      this.frictionResult = [];
      this.v3pool = new m;
      this.world = b;
      this.currentContactMaterial = null;
      this.enableFrictionReduction = !1;
    }
    g.exports = b;
    g = c("../collision/AABB");
    var e = c("../shapes/Shape"), f = c("../collision/Ray"), k = c("../math/Vec3"), n = c("../math/Transform"), p = (c("../shapes/ConvexPolyhedron"), c("../math/Quaternion")), m = (c("../solver/Solver"), c("../utils/Vec3Pool")), t = c("../equations/ContactEquation"), d = c("../equations/FrictionEquation");
    b.prototype.createContactEquation = function(b, c, d, e, f, k) {
      var g;
      this.contactPointPool.length ? (g = this.contactPointPool.pop(), g.bi = b, g.bj = c) : g = new t(b, c);
      g.enabled = b.collisionResponse && c.collisionResponse && d.collisionResponse && e.collisionResponse;
      var q = this.currentContactMaterial;
      g.restitution = q.restitution;
      g.setSpookParams(q.contactEquationStiffness, q.contactEquationRelaxation, this.world.dt);
      b = d.material || b.material;
      c = e.material || c.material;
      return b && c && 0 <= b.restitution && 0 <= c.restitution && (g.restitution = b.restitution * c.restitution), g.si = f || d, g.sj = k || e, g;
    };
    b.prototype.createFrictionEquationsFromContact = function(b, c) {
      var e = b.bi, f = b.bj, k = this.world, g = this.currentContactMaterial, q = g.friction, l = b.si.material || e.material, m = b.sj.material || f.material;
      if (l && m && 0 <= l.friction && 0 <= m.friction && (q = l.friction * m.friction), 0 < q) {
        q *= k.gravity.length();
        l = e.invMass + f.invMass;
        0 < l && (l = 1 / l);
        var n = this.frictionEquationPool;
        m = n.length ? n.pop() : new d(e, f, q * l);
        n = n.length ? n.pop() : new d(e, f, q * l);
        return m.bi = n.bi = e, m.bj = n.bj = f, m.minForce = n.minForce = -q * l, m.maxForce = n.maxForce = q * l, m.ri.copy(b.ri), m.rj.copy(b.rj), n.ri.copy(b.ri), n.rj.copy(b.rj), b.ni.tangents(m.t, n.t), m.setSpookParams(g.frictionEquationStiffness, g.frictionEquationRelaxation, k.dt), n.setSpookParams(g.frictionEquationStiffness, g.frictionEquationRelaxation, k.dt), m.enabled = n.enabled = b.enabled, c.push(m, n), !0;
      }
      return !1;
    };
    var l = new k, u = new k, w = new k;
    b.prototype.createFrictionFromAverage = function(b) {
      var c = this.result[this.result.length - 1];
      if (this.createFrictionEquationsFromContact(c, this.frictionResult) && 1 !== b) {
        var d = this.frictionResult[this.frictionResult.length - 2], e = this.frictionResult[this.frictionResult.length - 1];
        l.setZero();
        u.setZero();
        w.setZero();
        for (var f = c.bi, k = (c.bj, 0); k !== b; k++) {
          c = this.result[this.result.length - 1 - k], c.bodyA !== f ? (l.vadd(c.ni, l), u.vadd(c.ri, u), w.vadd(c.rj, w)) : (l.vsub(c.ni, l), u.vadd(c.rj, u), w.vadd(c.ri, w));
        }
        b = 1 / b;
        u.scale(b, d.ri);
        w.scale(b, d.rj);
        e.ri.copy(d.ri);
        e.rj.copy(d.rj);
        l.normalize();
        l.tangents(d.t, e.t);
      }
    };
    var y = new k, x = new k, q = new p, v = new p;
    b.prototype.getContacts = function(b, c, d, e, f, k, g) {
      this.contactPointPool = f;
      this.frictionEquationPool = g;
      this.result = e;
      this.frictionResult = k;
      e = 0;
      for (f = b.length; e !== f; e++) {
        k = b[e];
        g = c[e];
        var l = null;
        k.material && g.material && (l = d.getContactMaterial(k.material, g.material) || null);
        for (var m = 0; m < k.shapes.length; m++) {
          k.quaternion.mult(k.shapeOrientations[m], q);
          k.quaternion.vmult(k.shapeOffsets[m], y);
          y.vadd(k.position, y);
          for (var n = k.shapes[m], t = 0; t < g.shapes.length; t++) {
            g.quaternion.mult(g.shapeOrientations[t], v);
            g.quaternion.vmult(g.shapeOffsets[t], x);
            x.vadd(g.position, x);
            var p = g.shapes[t];
            if (!(y.distanceTo(x) > n.boundingSphereRadius + p.boundingSphereRadius)) {
              var u = null;
              n.material && p.material && (u = d.getContactMaterial(n.material, p.material) || null);
              this.currentContactMaterial = u || l || d.defaultContactMaterial;
              (u = this[n.type | p.type]) && (n.type < p.type ? u.call(this, n, p, y, x, q, v, k, g, n, p) : u.call(this, p, n, x, y, v, q, g, k, n, p));
            }
          }
        }
      }
    };
    b.prototype[e.types.BOX | e.types.BOX] = b.prototype.boxBox = function(b, c, d, e, f, k, g, q) {
      b.convexPolyhedronRepresentation.material = b.material;
      c.convexPolyhedronRepresentation.material = c.material;
      b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
      c.convexPolyhedronRepresentation.collisionResponse = c.collisionResponse;
      this.convexConvex(b.convexPolyhedronRepresentation, c.convexPolyhedronRepresentation, d, e, f, k, g, q, b, c);
    };
    b.prototype[e.types.BOX | e.types.CONVEXPOLYHEDRON] = b.prototype.boxConvex = function(b, c, d, e, f, k, g, q) {
      b.convexPolyhedronRepresentation.material = b.material;
      b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
      this.convexConvex(b.convexPolyhedronRepresentation, c, d, e, f, k, g, q, b, c);
    };
    b.prototype[e.types.BOX | e.types.PARTICLE] = b.prototype.boxParticle = function(b, c, d, e, f, k, g, q) {
      b.convexPolyhedronRepresentation.material = b.material;
      b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
      this.convexParticle(b.convexPolyhedronRepresentation, c, d, e, f, k, g, q, b, c);
    };
    b.prototype[e.types.SPHERE] = b.prototype.sphereSphere = function(b, c, d, e, f, k, g, q) {
      f = this.createContactEquation(g, q, b, c);
      e.vsub(d, f.ni);
      f.ni.normalize();
      f.ri.copy(f.ni);
      f.rj.copy(f.ni);
      f.ri.mult(b.radius, f.ri);
      f.rj.mult(-c.radius, f.rj);
      f.ri.vadd(d, f.ri);
      f.ri.vsub(g.position, f.ri);
      f.rj.vadd(e, f.rj);
      f.rj.vsub(q.position, f.rj);
      this.result.push(f);
      this.createFrictionEquationsFromContact(f, this.frictionResult);
    };
    var z = new k, C = new k, A = new k;
    b.prototype[e.types.PLANE | e.types.TRIMESH] = b.prototype.planeTrimesh = function(b, c, d, e, f, g, q, l) {
      var m = new k;
      z.set(0, 0, 1);
      f.vmult(z, z);
      for (f = 0; f < c.vertices.length / 3; f++) {
        c.getVertex(f, m);
        var t = new k;
        t.copy(m);
        n.pointToWorldFrame(e, g, t, m);
        t = C;
        m.vsub(d, t);
        if (0 >= z.dot(t)) {
          var v = this.createContactEquation(q, l, b, c);
          v.ni.copy(z);
          var p = A;
          z.scale(t.dot(z), p);
          m.vsub(p, p);
          v.ri.copy(p);
          v.ri.vsub(q.position, v.ri);
          v.rj.copy(m);
          v.rj.vsub(l.position, v.rj);
          this.result.push(v);
          this.createFrictionEquationsFromContact(v, this.frictionResult);
        }
      }
    };
    var D = new k, E = new k, B = (new k, new k), G = new k, H = new k, K = new k, I = new k, L = new k, R = new k, J = new k, Q = new k, aa = new k, U = new k, N = new g, S = [];
    b.prototype[e.types.SPHERE | e.types.TRIMESH] = b.prototype.sphereTrimesh = function(b, c, d, e, k, g, q, l) {
      n.pointToLocalFrame(e, g, d, R);
      k = b.radius;
      N.lowerBound.set(R.x - k, R.y - k, R.z - k);
      N.upperBound.set(R.x + k, R.y + k, R.z + k);
      c.getTrianglesInAABB(N, S);
      var m = b.radius * b.radius;
      for (k = 0; k < S.length; k++) {
        for (var t = 0; 3 > t; t++) {
          if (c.getVertex(c.indices[3 * S[k] + t], B), B.vsub(R, E), E.norm2() <= m) {
            G.copy(B);
            n.pointToWorldFrame(e, g, G, B);
            B.vsub(d, E);
            var v = this.createContactEquation(q, l, b, c);
            v.ni.copy(E);
            v.ni.normalize();
            v.ri.copy(v.ni);
            v.ri.scale(b.radius, v.ri);
            v.ri.vadd(d, v.ri);
            v.ri.vsub(q.position, v.ri);
            v.rj.copy(B);
            v.rj.vsub(l.position, v.rj);
            this.result.push(v);
            this.createFrictionEquationsFromContact(v, this.frictionResult);
          }
        }
      }
      for (k = 0; k < S.length; k++) {
        for (t = 0; 3 > t; t++) {
          c.getVertex(c.indices[3 * S[k] + t], H), c.getVertex(c.indices[3 * S[k] + (t + 1) % 3], K), K.vsub(H, I), R.vsub(K, J), d = J.dot(I), R.vsub(H, J), v = J.dot(I), 0 < v && 0 > d && (R.vsub(H, J), L.copy(I), L.normalize(), v = J.dot(L), L.scale(v, J), J.vadd(H, J), d = J.distanceTo(R), d < b.radius && (v = this.createContactEquation(q, l, b, c), J.vsub(R, v.ni), v.ni.normalize(), v.ni.scale(b.radius, v.ri), n.pointToWorldFrame(e, g, J, J), J.vsub(l.position, v.rj), n.vectorToWorldFrame(g, 
          v.ni, v.ni), n.vectorToWorldFrame(g, v.ri, v.ri), this.result.push(v), this.createFrictionEquationsFromContact(v, this.frictionResult)));
        }
      }
      k = 0;
      for (t = S.length; k !== t; k++) {
        if (c.getTriangleVertices(S[k], Q, aa, U), c.getNormal(S[k], D), R.vsub(Q, J), d = J.dot(D), D.scale(d, J), R.vsub(J, J), d = J.distanceTo(R), f.pointInTriangle(J, Q, aa, U) && d < b.radius) {
          v = this.createContactEquation(q, l, b, c), J.vsub(R, v.ni), v.ni.normalize(), v.ni.scale(b.radius, v.ri), n.pointToWorldFrame(e, g, J, J), J.vsub(l.position, v.rj), n.vectorToWorldFrame(g, v.ni, v.ni), n.vectorToWorldFrame(g, v.ri, v.ri), this.result.push(v), this.createFrictionEquationsFromContact(v, this.frictionResult);
        }
      }
      S.length = 0;
    };
    var V = new k, M = new k;
    b.prototype[e.types.SPHERE | e.types.PLANE] = b.prototype.spherePlane = function(b, c, d, e, f, k, g, q) {
      c = this.createContactEquation(g, q, b, c);
      if (c.ni.set(0, 0, 1), k.vmult(c.ni, c.ni), c.ni.negate(c.ni), c.ni.normalize(), c.ni.mult(b.radius, c.ri), d.vsub(e, V), c.ni.mult(c.ni.dot(V), M), V.vsub(M, c.rj), -V.dot(c.ni) <= b.radius) {
        b = c.ri, k = c.rj, b.vadd(d, b), b.vsub(g.position, b), k.vadd(e, k), k.vsub(q.position, k), this.result.push(c), this.createFrictionEquationsFromContact(c, this.frictionResult);
      }
    };
    var O = new k, P = new k, ka = new k, ha = new k, ja = new k, X = new k, fa = new k, ba = [new k, new k, new k, new k, new k, new k], la = new k, ma = new k, ca = new k, Ua = new k;
    b.prototype[e.types.SPHERE | e.types.BOX] = b.prototype.sphereBox = function(b, c, d, e, f, k, g, q) {
      f = this.v3pool;
      d.vsub(e, ha);
      c.getSideNormals(ba, k);
      k = b.radius;
      for (var l = !1, m = null, n = 0, v = 0, t = 0, p = null, u = 0, z = ba.length; u !== z && !1 === l; u++) {
        var w = ja;
        w.copy(ba[u]);
        var y = w.norm();
        w.normalize();
        var x = ha.dot(w);
        if (y + k > x && 0 < x) {
          var C = X, A = fa;
          C.copy(ba[(u + 1) % 3]);
          A.copy(ba[(u + 2) % 3]);
          var B = C.norm(), D = A.norm();
          C.normalize();
          A.normalize();
          var E = ha.dot(C), M = ha.dot(A);
          B > E && E > -B && D > M && M > -D && (x = Math.abs(x - y - k), (null === p || p > x) && (p = x, v = E, t = M, m = y, ma.copy(w), ca.copy(C), Ua.copy(A), n++));
        }
      }
      n && (l = !0, n = this.createContactEquation(g, q, b, c), ma.mult(-k, n.ri), n.ni.copy(ma), n.ni.negate(n.ni), ma.mult(m, ma), ca.mult(v, ca), ma.vadd(ca, ma), Ua.mult(t, Ua), ma.vadd(Ua, n.rj), n.ri.vadd(d, n.ri), n.ri.vsub(g.position, n.ri), n.rj.vadd(e, n.rj), n.rj.vsub(q.position, n.rj), this.result.push(n), this.createFrictionEquationsFromContact(n, this.frictionResult));
      x = f.get();
      for (m = 0; 2 !== m && !l; m++) {
        for (v = 0; 2 !== v && !l; v++) {
          for (t = 0; 2 !== t && !l; t++) {
            if (x.set(0, 0, 0), m ? x.vadd(ba[0], x) : x.vsub(ba[0], x), v ? x.vadd(ba[1], x) : x.vsub(ba[1], x), t ? x.vadd(ba[2], x) : x.vsub(ba[2], x), e.vadd(x, la), la.vsub(d, la), la.norm2() < k * k) {
              l = !0, n = this.createContactEquation(g, q, b, c), n.ri.copy(la), n.ri.normalize(), n.ni.copy(n.ri), n.ri.mult(k, n.ri), n.rj.copy(x), n.ri.vadd(d, n.ri), n.ri.vsub(g.position, n.ri), n.rj.vadd(e, n.rj), n.rj.vsub(q.position, n.rj), this.result.push(n), this.createFrictionEquationsFromContact(n, this.frictionResult);
            }
          }
        }
      }
      f.release(x);
      p = f.get();
      u = f.get();
      n = f.get();
      z = f.get();
      x = f.get();
      w = ba.length;
      for (m = 0; m !== w && !l; m++) {
        for (v = 0; v !== w && !l; v++) {
          if (m % 3 !== v % 3) {
            ba[v].cross(ba[m], p);
            p.normalize();
            ba[m].vadd(ba[v], u);
            n.copy(d);
            n.vsub(u, n);
            n.vsub(e, n);
            y = n.dot(p);
            p.mult(y, z);
            for (t = 0; t === m % 3 || t === v % 3;) {
              t++;
            }
            x.copy(d);
            x.vsub(z, x);
            x.vsub(u, x);
            x.vsub(e, x);
            y = Math.abs(y);
            C = x.norm();
            y < ba[t].norm() && k > C && (l = !0, t = this.createContactEquation(g, q, b, c), u.vadd(z, t.rj), t.rj.copy(t.rj), x.negate(t.ni), t.ni.normalize(), t.ri.copy(t.rj), t.ri.vadd(e, t.ri), t.ri.vsub(d, t.ri), t.ri.normalize(), t.ri.mult(k, t.ri), t.ri.vadd(d, t.ri), t.ri.vsub(g.position, t.ri), t.rj.vadd(e, t.rj), t.rj.vsub(q.position, t.rj), this.result.push(t), this.createFrictionEquationsFromContact(t, this.frictionResult));
          }
        }
      }
      f.release(p, u, n, z, x);
    };
    var ob = new k, pb = new k, qb = new k, rb = new k, ne = new k, oe = new k, pe = new k, qe = new k, re = new k, se = new k;
    b.prototype[e.types.SPHERE | e.types.CONVEXPOLYHEDRON] = b.prototype.sphereConvex = function(b, c, d, e, f, k, g, q) {
      f = this.v3pool;
      d.vsub(e, ob);
      for (var l = c.faceNormals, m = c.faces, n = c.vertices, t = b.radius, v = 0; v !== n.length; v++) {
        var p = ne;
        k.vmult(n[v], p);
        e.vadd(p, p);
        var u = rb;
        if (p.vsub(d, u), u.norm2() < t * t) {
          return b = this.createContactEquation(g, q, b, c), b.ri.copy(u), b.ri.normalize(), b.ni.copy(b.ri), b.ri.mult(t, b.ri), p.vsub(e, b.rj), b.ri.vadd(d, b.ri), b.ri.vsub(g.position, b.ri), b.rj.vadd(e, b.rj), b.rj.vsub(q.position, b.rj), this.result.push(b), void this.createFrictionEquationsFromContact(b, this.frictionResult);
        }
      }
      v = 0;
      for (p = m.length; v !== p; v++) {
        u = m[v];
        var z = oe;
        k.vmult(l[v], z);
        var w = pe;
        k.vmult(n[u[0]], w);
        w.vadd(e, w);
        var y = qe;
        z.mult(-t, y);
        d.vadd(y, y);
        var x = re;
        y.vsub(w, x);
        y = x.dot(z);
        x = se;
        if (d.vsub(w, x), 0 > y && 0 < x.dot(z)) {
          w = [];
          x = 0;
          for (var C = u.length; x !== C; x++) {
            var A = f.get();
            k.vmult(n[u[x]], A);
            e.vadd(A, A);
            w.push(A);
          }
          a: {
            x = w;
            C = z;
            A = d;
            for (var B = null, D = x.length, E = 0; E !== D; E++) {
              var M = x[E], G = O;
              x[(E + 1) % D].vsub(M, G);
              var H = P;
              G.cross(C, H);
              G = ka;
              A.vsub(M, G);
              M = H.dot(G);
              if (!(null === B || 0 < M && !0 === B || 0 >= M && !1 === B)) {
                x = !1;
                break a;
              }
              null === B && (B = 0 < M);
            }
            x = !0;
          }
          if (x) {
            b = this.createContactEquation(g, q, b, c);
            z.mult(-t, b.ri);
            z.negate(b.ni);
            c = f.get();
            z.mult(-y, c);
            k = f.get();
            z.mult(-t, k);
            d.vsub(e, b.rj);
            b.rj.vadd(k, b.rj);
            b.rj.vadd(c, b.rj);
            b.rj.vadd(e, b.rj);
            b.rj.vsub(q.position, b.rj);
            b.ri.vadd(d, b.ri);
            b.ri.vsub(g.position, b.ri);
            f.release(c);
            f.release(k);
            this.result.push(b);
            this.createFrictionEquationsFromContact(b, this.frictionResult);
            x = 0;
            for (u = w.length; x !== u; x++) {
              f.release(w[x]);
            }
            break;
          }
          for (x = 0; x !== u.length; x++) {
            z = f.get();
            y = f.get();
            k.vmult(n[u[(x + 1) % u.length]], z);
            k.vmult(n[u[(x + 2) % u.length]], y);
            e.vadd(z, z);
            e.vadd(y, y);
            D = pb;
            y.vsub(z, D);
            B = qb;
            D.unit(B);
            C = f.get();
            A = f.get();
            d.vsub(z, A);
            E = A.dot(B);
            B.mult(E, C);
            C.vadd(z, C);
            B = f.get();
            if (C.vsub(d, B), 0 < E && E * E < D.norm2() && B.norm2() < t * t) {
              b = this.createContactEquation(g, q, b, c);
              C.vsub(e, b.rj);
              C.vsub(d, b.ni);
              b.ni.normalize();
              b.ni.mult(t, b.ri);
              b.rj.vadd(e, b.rj);
              b.rj.vsub(q.position, b.rj);
              b.ri.vadd(d, b.ri);
              b.ri.vsub(g.position, b.ri);
              this.result.push(b);
              this.createFrictionEquationsFromContact(b, this.frictionResult);
              x = 0;
              for (u = w.length; x !== u; x++) {
                f.release(w[x]);
              }
              return f.release(z), f.release(y), f.release(C), f.release(B), void f.release(A);
            }
            f.release(z);
            f.release(y);
            f.release(C);
            f.release(B);
            f.release(A);
          }
          x = 0;
          for (u = w.length; x !== u; x++) {
            f.release(w[x]);
          }
        }
      }
    };
    new k;
    new k;
    b.prototype[e.types.PLANE | e.types.BOX] = b.prototype.planeBox = function(b, c, d, e, f, k, g, q) {
      c.convexPolyhedronRepresentation.material = c.material;
      c.convexPolyhedronRepresentation.collisionResponse = c.collisionResponse;
      this.planeConvex(b, c.convexPolyhedronRepresentation, d, e, f, k, g, q);
    };
    var za = new k, Ja = new k, gb = new k, qa = new k;
    b.prototype[e.types.PLANE | e.types.CONVEXPOLYHEDRON] = b.prototype.planeConvex = function(b, c, d, e, f, k, g, q) {
      Ja.set(0, 0, 1);
      f.vmult(Ja, Ja);
      for (var l = f = 0; l !== c.vertices.length; l++) {
        if (za.copy(c.vertices[l]), k.vmult(za, za), e.vadd(za, za), za.vsub(d, gb), 0 >= Ja.dot(gb)) {
          var m = this.createContactEquation(g, q, b, c), n = qa;
          Ja.mult(Ja.dot(gb), n);
          za.vsub(n, n);
          n.vsub(d, m.ri);
          m.ni.copy(Ja);
          za.vsub(e, m.rj);
          m.ri.vadd(d, m.ri);
          m.ri.vsub(g.position, m.ri);
          m.rj.vadd(e, m.rj);
          m.rj.vsub(q.position, m.rj);
          this.result.push(m);
          f++;
          this.enableFrictionReduction || this.createFrictionEquationsFromContact(m, this.frictionResult);
        }
      }
      this.enableFrictionReduction && f && this.createFrictionFromAverage(f);
    };
    var ua = new k, Nb = new k;
    b.prototype[e.types.CONVEXPOLYHEDRON] = b.prototype.convexConvex = function(b, c, d, e, f, k, g, q, l, m, n, t) {
      if (!(d.distanceTo(e) > b.boundingSphereRadius + c.boundingSphereRadius) && b.findSeparatingAxis(c, d, f, e, k, ua, n, t)) {
        n = [];
        b.clipAgainstHull(d, f, c, e, k, ua, -100, 100, n);
        for (k = f = 0; k !== n.length; k++) {
          t = this.createContactEquation(g, q, b, c, l, m);
          var v = t.ri, p = t.rj;
          ua.negate(t.ni);
          n[k].normal.negate(Nb);
          Nb.mult(n[k].depth, Nb);
          n[k].point.vadd(Nb, v);
          p.copy(n[k].point);
          v.vsub(d, v);
          p.vsub(e, p);
          v.vadd(d, v);
          v.vsub(g.position, v);
          p.vadd(e, p);
          p.vsub(q.position, p);
          this.result.push(t);
          f++;
          this.enableFrictionReduction || this.createFrictionEquationsFromContact(t, this.frictionResult);
        }
        this.enableFrictionReduction && f && this.createFrictionFromAverage(f);
      }
    };
    var sb = new k, Md = new k, gc = new k;
    b.prototype[e.types.PLANE | e.types.PARTICLE] = b.prototype.planeParticle = function(b, c, d, e, f, k, g, q) {
      sb.set(0, 0, 1);
      g.quaternion.vmult(sb, sb);
      e.vsub(g.position, Md);
      0 >= sb.dot(Md) && (b = this.createContactEquation(q, g, c, b), b.ni.copy(sb), b.ni.negate(b.ni), b.ri.set(0, 0, 0), sb.mult(sb.dot(e), gc), e.vsub(gc, gc), b.rj.copy(gc), this.result.push(b), this.createFrictionEquationsFromContact(b, this.frictionResult));
    };
    var Bb = new k;
    b.prototype[e.types.PARTICLE | e.types.SPHERE] = b.prototype.sphereParticle = function(b, c, d, e, f, k, g, q) {
      Bb.set(0, 0, 1);
      e.vsub(d, Bb);
      Bb.norm2() <= b.radius * b.radius && (c = this.createContactEquation(q, g, c, b), Bb.normalize(), c.rj.copy(Bb), c.rj.mult(b.radius, c.rj), c.ni.copy(Bb), c.ni.negate(c.ni), c.ri.set(0, 0, 0), this.result.push(c), this.createFrictionEquationsFromContact(c, this.frictionResult));
    };
    var Nd = new p, Cb = new k, Oc = (new k, new k), Od = new k, Db = new k;
    b.prototype[e.types.PARTICLE | e.types.CONVEXPOLYHEDRON] = b.prototype.convexParticle = function(b, c, d, e, f, k, g, q) {
      var l = -1;
      k = null;
      var m = 0;
      if (Cb.copy(e), Cb.vsub(d, Cb), f.conjugate(Nd), Nd.vmult(Cb, Cb), b.pointIsInside(Cb)) {
        b.worldVerticesNeedsUpdate && b.computeWorldVertices(d, f);
        b.worldFaceNormalsNeedsUpdate && b.computeWorldFaceNormals(f);
        f = 0;
        for (var n = b.faces.length; f !== n; f++) {
          var t = b.worldFaceNormals[f];
          e.vsub(b.worldVertices[b.faces[f][0]], Od);
          var v = -t.dot(Od);
          (null === k || Math.abs(v) < Math.abs(k)) && (k = v, l = f, Oc.copy(t), m++);
        }
        -1 !== l ? (b = this.createContactEquation(q, g, c, b), Oc.mult(k, Db), Db.vadd(e, Db), Db.vsub(d, Db), b.rj.copy(Db), Oc.negate(b.ni), b.ri.set(0, 0, 0), c = b.ri, k = b.rj, c.vadd(e, c), c.vsub(q.position, c), k.vadd(d, k), k.vsub(g.position, k), this.result.push(b), this.createFrictionEquationsFromContact(b, this.frictionResult)) : console.warn("Point found inside convex, but did not find penetrating face!");
      }
    };
    b.prototype[e.types.BOX | e.types.HEIGHTFIELD] = b.prototype.boxHeightfield = function(b, c, d, e, f, k, g, q) {
      b.convexPolyhedronRepresentation.material = b.material;
      b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
      this.convexHeightfield(b.convexPolyhedronRepresentation, c, d, e, f, k, g, q);
    };
    var tb = new k, Eb = new k, Pc = [0];
    b.prototype[e.types.CONVEXPOLYHEDRON | e.types.HEIGHTFIELD] = b.prototype.convexHeightfield = function(b, c, d, e, f, k, g, q) {
      var l = c.data, m = c.elementSize, t = b.boundingSphereRadius;
      n.pointToLocalFrame(e, k, d, tb);
      var v = Math.floor((tb.x - t) / m) - 1, p = Math.ceil((tb.x + t) / m) + 1, u = Math.floor((tb.y - t) / m) - 1;
      m = Math.ceil((tb.y + t) / m) + 1;
      if (!(0 > p || 0 > m || v > l.length || u > l[0].length)) {
        0 > v && (v = 0);
        0 > p && (p = 0);
        0 > u && (u = 0);
        0 > m && (m = 0);
        v >= l.length && (v = l.length - 1);
        p >= l.length && (p = l.length - 1);
        m >= l[0].length && (m = l[0].length - 1);
        u >= l[0].length && (u = l[0].length - 1);
        l = [];
        c.getRectMinMax(v, u, p, m, l);
        var z = l[0];
        if (!(tb.z - t > l[1] || tb.z + t < z)) {
          for (t = v; p > t; t++) {
            for (v = u; m > v; v++) {
              c.getConvexTrianglePillar(t, v, !1), n.pointToWorldFrame(e, k, c.pillarOffset, Eb), d.distanceTo(Eb) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.convexConvex(b, c.pillarConvex, d, Eb, f, k, g, q, null, null, Pc, null), c.getConvexTrianglePillar(t, v, !0), n.pointToWorldFrame(e, k, c.pillarOffset, Eb), d.distanceTo(Eb) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.convexConvex(b, c.pillarConvex, d, Eb, f, k, g, q, null, null, Pc, null);
            }
          }
        }
      }
    };
    var hb = new k, ub = new k;
    b.prototype[e.types.SPHERE | e.types.HEIGHTFIELD] = b.prototype.sphereHeightfield = function(b, c, d, e, f, k, g, q) {
      var l = c.data, m = b.radius, t = c.elementSize;
      n.pointToLocalFrame(e, k, d, hb);
      var v = Math.floor((hb.x - m) / t) - 1, p = Math.ceil((hb.x + m) / t) + 1, u = Math.floor((hb.y - m) / t) - 1;
      t = Math.ceil((hb.y + m) / t) + 1;
      if (!(0 > p || 0 > t || v > l.length || t > l[0].length)) {
        0 > v && (v = 0);
        0 > p && (p = 0);
        0 > u && (u = 0);
        0 > t && (t = 0);
        v >= l.length && (v = l.length - 1);
        p >= l.length && (p = l.length - 1);
        t >= l[0].length && (t = l[0].length - 1);
        u >= l[0].length && (u = l[0].length - 1);
        l = [];
        c.getRectMinMax(v, u, p, t, l);
        var z = l[0];
        if (!(hb.z - m > l[1] || hb.z + m < z)) {
          for (m = this.result; p > v; v++) {
            for (l = u; t > l; l++) {
              if (z = m.length, c.getConvexTrianglePillar(v, l, !1), n.pointToWorldFrame(e, k, c.pillarOffset, ub), d.distanceTo(ub) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.sphereConvex(b, c.pillarConvex, d, ub, f, k, g, q), c.getConvexTrianglePillar(v, l, !0), n.pointToWorldFrame(e, k, c.pillarOffset, ub), d.distanceTo(ub) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.sphereConvex(b, c.pillarConvex, d, ub, f, k, g, q), 2 < m.length - z) {
                return;
              }
            }
          }
        }
      }
    };
  }, {"../collision/AABB":3, "../collision/Ray":9, "../equations/ContactEquation":19, "../equations/FrictionEquation":21, "../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "../shapes/ConvexPolyhedron":38, "../shapes/Shape":43, "../solver/Solver":47, "../utils/Vec3Pool":54}], 56:[function(c, g) {
    function b() {
      p.apply(this);
      this.dt = -1;
      this.allowSleep = !1;
      this.contacts = [];
      this.frictionEquations = [];
      this.quatNormalizeSkip = 0;
      this.quatNormalizeFast = !1;
      this.stepnumber = this.time = 0;
      this.default_dt = 1 / 60;
      this.nextId = 0;
      this.gravity = new f;
      this.broadphase = new q;
      this.bodies = [];
      this.solver = new k;
      this.constraints = [];
      this.narrowphase = new n(this);
      this.collisionMatrix = new m;
      this.collisionMatrixPrevious = new m;
      this.materials = [];
      this.contactmaterials = [];
      this.contactMaterialTable = new u;
      this.defaultMaterial = new t("default");
      this.defaultContactMaterial = new d(this.defaultMaterial, this.defaultMaterial, {friction:.3, restitution:0});
      this.doProfiling = !1;
      this.profile = {solve:0, makeContactConstraints:0, broadphase:0, integrate:0, narrowphase:0};
      this.subsystems = [];
      this.addBodyEvent = {type:"addBody", body:null};
      this.removeBodyEvent = {type:"removeBody", body:null};
    }
    g.exports = b;
    var e = c("../shapes/Shape"), f = c("../math/Vec3");
    g = c("../math/Quaternion");
    var k = c("../solver/GSSolver"), n = (c("../utils/Vec3Pool"), c("../equations/ContactEquation"), c("../equations/FrictionEquation"), c("./Narrowphase")), p = c("../utils/EventTarget"), m = c("../collision/ArrayCollisionMatrix"), t = c("../material/Material"), d = c("../material/ContactMaterial"), l = c("../objects/Body"), u = c("../utils/TupleDictionary"), w = c("../collision/RaycastResult"), y = c("../collision/AABB"), x = c("../collision/Ray"), q = c("../collision/NaiveBroadphase");
    b.prototype = new p;
    var v = (new y, new x);
    if (b.prototype.getContactMaterial = function(b, c) {
      return this.contactMaterialTable.get(b.id, c.id);
    }, b.prototype.numObjects = function() {
      return this.bodies.length;
    }, b.prototype.collisionMatrixTick = function() {
      var b = this.collisionMatrixPrevious;
      this.collisionMatrixPrevious = this.collisionMatrix;
      this.collisionMatrix = b;
      this.collisionMatrix.reset();
    }, b.prototype.add = b.prototype.addBody = function(b) {
      -1 === this.bodies.indexOf(b) && (b.index = this.bodies.length, this.bodies.push(b), b.world = this, b.initPosition.copy(b.position), b.initVelocity.copy(b.velocity), b.timeLastSleepy = this.time, b instanceof l && (b.initAngularVelocity.copy(b.angularVelocity), b.initQuaternion.copy(b.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), this.addBodyEvent.body = b, this.dispatchEvent(this.addBodyEvent));
    }, b.prototype.addConstraint = function(b) {
      this.constraints.push(b);
    }, b.prototype.removeConstraint = function(b) {
      b = this.constraints.indexOf(b);
      -1 !== b && this.constraints.splice(b, 1);
    }, b.prototype.rayTest = function(b, c, d) {
      d instanceof w ? this.raycastClosest(b, c, {skipBackfaces:!0}, d) : this.raycastAll(b, c, {skipBackfaces:!0}, d);
    }, b.prototype.raycastAll = function(b, c, d, e) {
      return d.mode = x.ALL, d.from = b, d.to = c, d.callback = e, v.intersectWorld(this, d);
    }, b.prototype.raycastAny = function(b, c, d, e) {
      return d.mode = x.ANY, d.from = b, d.to = c, d.result = e, v.intersectWorld(this, d);
    }, b.prototype.raycastClosest = function(b, c, d, e) {
      return d.mode = x.CLOSEST, d.from = b, d.to = c, d.result = e, v.intersectWorld(this, d);
    }, b.prototype.remove = function(b) {
      b.world = null;
      var c = this.bodies.length - 1, d = this.bodies, e = d.indexOf(b);
      if (-1 !== e) {
        d.splice(e, 1);
        for (e = 0; e !== d.length; e++) {
          d[e].index = e;
        }
        this.collisionMatrix.setNumObjects(c);
        this.removeBodyEvent.body = b;
        this.dispatchEvent(this.removeBodyEvent);
      }
    }, b.prototype.removeBody = b.prototype.remove, b.prototype.addMaterial = function(b) {
      this.materials.push(b);
    }, b.prototype.addContactMaterial = function(b) {
      this.contactmaterials.push(b);
      this.contactMaterialTable.set(b.materials[0].id, b.materials[1].id, b);
    }, "undefined" == typeof performance && (performance = {}), !performance.now) {
      var z = Date.now();
      performance.timing && performance.timing.navigationStart && (z = performance.timing.navigationStart);
      performance.now = function() {
        return Date.now() - z;
      };
    }
    var C = new f;
    b.prototype.step = function(b, c, d) {
      if (d = d || 10, c = c || 0, 0 === c) {
        this.internalStep(b), this.time += b;
      } else {
        var e = Math.floor((this.time + c) / b) - Math.floor(this.time / b);
        e = Math.min(e, d);
        d = performance.now();
        for (var f = 0; f !== e && (this.internalStep(b), !(performance.now() - d > 1E3 * b)); f++) {
        }
        this.time += c;
        b = this.time % b / b;
        c = this.bodies;
        for (e = 0; e !== c.length; e++) {
          d = c[e], d.type !== l.STATIC && d.sleepState !== l.SLEEPING ? (d.position.vsub(d.previousPosition, C), C.scale(b, C), d.position.vadd(C, d.interpolatedPosition)) : (d.interpolatedPosition.copy(d.position), d.interpolatedQuaternion.copy(d.quaternion));
        }
      }
    };
    var A = {type:"postStep"}, D = {type:"preStep"}, E = {type:"collide", body:null, contact:null}, B = [], G = [], H = [], K = [], I = (new f, new f, new f, new f, new f, new f, new f, new f, new f, new g, new g), L = new g, R = new f;
    b.prototype.internalStep = function(b) {
      this.dt = b;
      var c, d = this.contacts, f = this.numObjects(), k = this.bodies, g = this.solver, q = this.gravity, m = this.doProfiling, n = this.profile, t = l.DYNAMIC, v = this.constraints, p = (q.norm(), q.x), u = q.y, z = q.z;
      m && (c = performance.now());
      for (q = 0; q !== f; q++) {
        var w = k[q];
        if (w.type & t) {
          var y = w.force;
          w = w.mass;
          y.x += w * p;
          y.y += w * u;
          y.z += w * z;
        }
      }
      q = 0;
      for (w = this.subsystems.length; q !== w; q++) {
        this.subsystems[q].update();
      }
      m && (c = performance.now());
      H.length = 0;
      K.length = 0;
      this.broadphase.collisionPairs(this, H, K);
      m && (n.broadphase = performance.now() - c);
      w = v.length;
      for (q = 0; q !== w; q++) {
        if (p = v[q], !p.collideConnected) {
          for (u = H.length - 1; 0 <= u; --u) {
            (p.bodyA === H[u] && p.bodyB === K[u] || p.bodyB === H[u] && p.bodyA === K[u]) && (H.splice(u, 1), K.splice(u, 1));
          }
        }
      }
      this.collisionMatrixTick();
      m && (c = performance.now());
      w = d.length;
      for (q = 0; q !== w; q++) {
        B.push(d[q]);
      }
      d.length = 0;
      w = this.frictionEquations.length;
      for (q = 0; q !== w; q++) {
        G.push(this.frictionEquations[q]);
      }
      this.frictionEquations.length = 0;
      this.narrowphase.getContacts(H, K, this, d, B, this.frictionEquations, G);
      m && (n.narrowphase = performance.now() - c);
      m && (c = performance.now());
      for (q = 0; q < this.frictionEquations.length; q++) {
        g.addEquation(this.frictionEquations[q]);
      }
      q = d.length;
      for (u = 0; u !== q; u++) {
        p = d[u], w = p.bi, z = p.bj, p.si, p.sj, w.material && z.material && this.getContactMaterial(w.material, z.material), (w.material && z.material && 0 <= w.material.restitution && 0 <= z.material.restitution && (p.restitution = w.material.restitution * z.material.restitution), g.addEquation(p), w.allowSleep && w.type === l.DYNAMIC && w.sleepState === l.SLEEPING && z.sleepState === l.AWAKE && z.type !== l.STATIC) && z.velocity.norm2() + z.angularVelocity.norm2() >= 2 * Math.pow(z.sleepSpeedLimit, 
        2) && (w._wakeUpAfterNarrowphase = !0), z.allowSleep && z.type === l.DYNAMIC && z.sleepState === l.SLEEPING && w.sleepState === l.AWAKE && w.type !== l.STATIC && w.velocity.norm2() + w.angularVelocity.norm2() >= 2 * Math.pow(w.sleepSpeedLimit, 2) && (z._wakeUpAfterNarrowphase = !0), this.collisionMatrix.set(w, z, !0), this.collisionMatrixPrevious.get(w, z) || (E.body = z, E.contact = p, w.dispatchEvent(E), E.body = w, z.dispatchEvent(E));
      }
      m && (n.makeContactConstraints = performance.now() - c, c = performance.now());
      for (q = 0; q !== f; q++) {
        w = k[q], w._wakeUpAfterNarrowphase && (w.wakeUp(), w._wakeUpAfterNarrowphase = !1);
      }
      w = v.length;
      for (q = 0; q !== w; q++) {
        for (p = v[q], p.update(), u = 0, d = p.equations.length; u !== d; u++) {
          g.addEquation(p.equations[u]);
        }
      }
      g.solve(b, this);
      m && (n.solve = performance.now() - c);
      g.removeAllEquations();
      g = Math.pow;
      for (q = 0; q !== f; q++) {
        if (w = k[q], w.type & t && (v = g(1 - w.linearDamping, b), d = w.velocity, d.mult(v, d), v = w.angularVelocity)) {
          d = g(1 - w.angularDamping, b), v.mult(d, v);
        }
      }
      this.dispatchEvent(D);
      for (q = 0; q !== f; q++) {
        w = k[q], w.preStep && w.preStep.call(w);
      }
      m && (c = performance.now());
      t = l.DYNAMIC | l.KINEMATIC;
      g = 0 === this.stepnumber % (this.quatNormalizeSkip + 1);
      v = this.quatNormalizeFast;
      d = .5 * b;
      e.types.PLANE;
      e.types.CONVEXPOLYHEDRON;
      for (q = 0; q !== f; q++) {
        if (w = k[q], p = w.force, u = w.torque, w.type & t && w.sleepState !== l.SLEEPING) {
          z = w.velocity;
          y = w.angularVelocity;
          var x = w.position, C = w.quaternion, J = w.invMass, Ua = w.invInertiaWorld;
          z.x += p.x * J * b;
          z.y += p.y * J * b;
          z.z += p.z * J * b;
          w.angularVelocity && (Ua.vmult(u, R), R.mult(b, R), R.vadd(y, y));
          x.x += z.x * b;
          x.y += z.y * b;
          x.z += z.z * b;
          w.angularVelocity && (I.set(y.x, y.y, y.z, 0), I.mult(C, L), C.x += d * L.x, C.y += d * L.y, C.z += d * L.z, C.w += d * L.w, g && (v ? C.normalizeFast() : C.normalize()));
          w.aabb && (w.aabbNeedsUpdate = !0);
          w.updateInertiaWorld && w.updateInertiaWorld();
        }
      }
      this.clearForces();
      this.broadphase.dirty = !0;
      m && (n.integrate = performance.now() - c);
      this.time += b;
      this.stepnumber += 1;
      this.dispatchEvent(A);
      for (q = 0; q !== f; q++) {
        w = k[q], (b = w.postStep) && b.call(w);
      }
      if (this.allowSleep) {
        for (q = 0; q !== f; q++) {
          k[q].sleepTick(this.time);
        }
      }
    };
    b.prototype.clearForces = function() {
      for (var b = this.bodies, c = b.length, d = 0; d !== c; d++) {
        var e = b[d];
        e.force;
        e.torque;
        e.force.set(0, 0, 0);
        e.torque.set(0, 0, 0);
      }
    };
  }, {"../collision/AABB":3, "../collision/ArrayCollisionMatrix":4, "../collision/NaiveBroadphase":7, "../collision/Ray":9, "../collision/RaycastResult":10, "../equations/ContactEquation":19, "../equations/FrictionEquation":21, "../material/ContactMaterial":24, "../material/Material":25, "../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "../shapes/Shape":43, "../solver/GSSolver":46, "../utils/EventTarget":49, "../utils/TupleDictionary":52, "../utils/Vec3Pool":54, "./Narrowphase":55}]}, 
  {}, [2])(2);
});
!function(a, c, g) {
  function b(f, g) {
    if (!c[f]) {
      if (!a[f]) {
        var k = "function" == typeof require && require;
        if (!g && k) {
          return k(f, !0);
        }
        if (e) {
          return e(f, !0);
        }
        throw Error("Cannot find module '" + f + "'");
      }
      g = c[f] = {exports:{}};
      a[f][0].call(g.exports, function(c) {
        var e = a[f][1][c];
        return b(e ? e : c);
      }, g, g.exports);
    }
    return c[f].exports;
  }
  for (var e = "function" == typeof require && require, f = 0; f < g.length; f++) {
    b(g[f]);
  }
  return b;
}({1:[function(a, c) {
  var g = (a("./pointable"), a("gl-matrix")), b = g.vec3, e = g.mat3, f = g.mat4;
  a = (a("underscore"), c.exports = function(a, c) {
    this.finger = a;
    this._matrix = this._center = null;
    this.type = c.type;
    this.prevJoint = c.prevJoint;
    this.nextJoint = c.nextJoint;
    this.width = c.width;
    a = Array(3);
    b.sub(a, c.nextJoint, c.prevJoint);
    this.length = b.length(a);
    this.basis = c.basis;
  });
  a.prototype.left = function() {
    return this._left ? this._left : (this._left = 0 > e.determinant(this.basis[0].concat(this.basis[1]).concat(this.basis[2])), this._left);
  };
  a.prototype.matrix = function() {
    if (this._matrix) {
      return this._matrix;
    }
    var a = this.basis, b = this._matrix = f.create();
    return b[0] = a[0][0], b[1] = a[0][1], b[2] = a[0][2], b[4] = a[1][0], b[5] = a[1][1], b[6] = a[1][2], b[8] = a[2][0], b[9] = a[2][1], b[10] = a[2][2], b[3] = this.center()[0], b[7] = this.center()[1], b[11] = this.center()[2], this.left() && (b[0] *= -1, b[1] *= -1, b[2] *= -1), this._matrix;
  };
  a.prototype.lerp = function(a, c) {
    b.lerp(a, this.prevJoint, this.nextJoint, c);
  };
  a.prototype.center = function() {
    if (this._center) {
      return this._center;
    }
    var a = b.create();
    return this.lerp(a, .5), this._center = a, a;
  };
  a.prototype.direction = function() {
    return [-1 * this.basis[2][0], -1 * this.basis[2][1], -1 * this.basis[2][2]];
  };
}, {"./pointable":14, "gl-matrix":23, underscore:24}], 2:[function(a, c) {
  a = c.exports = function(a) {
    this.pos = 0;
    this._buf = [];
    this.size = a;
  };
  a.prototype.get = function(a) {
    return void 0 == a && (a = 0), a >= this.size ? void 0 : a >= this._buf.length ? void 0 : this._buf[(this.pos - a - 1) % this.size];
  };
  a.prototype.push = function(a) {
    return this._buf[this.pos % this.size] = a, this.pos++;
  };
}, {}], 3:[function(a, c) {
  var g = a("../protocol").chooseProtocol, b = a("events").EventEmitter, e = a("underscore"), f = c.exports = function(a) {
    this.opts = e.defaults(a || {}, {host:"127.0.0.1", enableGestures:!1, scheme:this.getScheme(), port:this.getPort(), background:!1, optimizeHMD:!1, requestProtocolVersion:f.defaultProtocolVersion});
    this.host = this.opts.host;
    this.port = this.opts.port;
    this.scheme = this.opts.scheme;
    this.protocolVersionVerified = !1;
    this.optimizeHMD = this.background = null;
    this.on("ready", function() {
      this.enableGestures(this.opts.enableGestures);
      this.setBackground(this.opts.background);
      this.setOptimizeHMD(this.opts.optimizeHMD);
      console.log(this.opts.optimizeHMD ? "Optimized for head mounted display usage." : "Optimized for desktop usage.");
    });
  };
  f.defaultProtocolVersion = 6;
  f.prototype.getUrl = function() {
    return this.scheme + "//" + this.host + ":" + this.port + "/v" + this.opts.requestProtocolVersion + ".json";
  };
  f.prototype.getScheme = function() {
    return "ws:";
  };
  f.prototype.getPort = function() {
    return 6437;
  };
  f.prototype.setBackground = function(a) {
    this.opts.background = a;
    this.protocol && this.protocol.sendBackground && this.background !== this.opts.background && (this.background = this.opts.background, this.protocol.sendBackground(this, this.opts.background));
  };
  f.prototype.setOptimizeHMD = function(a) {
    this.opts.optimizeHMD = a;
    this.protocol && this.protocol.sendOptimizeHMD && this.optimizeHMD !== this.opts.optimizeHMD && (this.optimizeHMD = this.opts.optimizeHMD, this.protocol.sendOptimizeHMD(this, this.opts.optimizeHMD));
  };
  f.prototype.handleOpen = function() {
    this.connected || (this.connected = !0, this.emit("connect"));
  };
  f.prototype.enableGestures = function(a) {
    this.gesturesEnabled = a ? !0 : !1;
    this.send(this.protocol.encode({enableGestures:this.gesturesEnabled}));
  };
  f.prototype.handleClose = function(a) {
    this.connected && (this.disconnect(), 1001 === a && 1 < this.opts.requestProtocolVersion && (this.protocolVersionVerified ? this.protocolVersionVerified = !1 : this.opts.requestProtocolVersion--), this.startReconnection());
  };
  f.prototype.startReconnection = function() {
    var a = this;
    this.reconnectionTimer || (this.reconnectionTimer = setInterval(function() {
      a.reconnect();
    }, 500));
  };
  f.prototype.stopReconnection = function() {
    this.reconnectionTimer = clearInterval(this.reconnectionTimer);
  };
  f.prototype.disconnect = function(a) {
    return a || this.stopReconnection(), this.socket ? (this.socket.close(), delete this.socket, delete this.protocol, delete this.background, delete this.optimizeHMD, delete this.focusedState, this.connected && (this.connected = !1, this.emit("disconnect")), !0) : void 0;
  };
  f.prototype.reconnect = function() {
    this.connected ? this.stopReconnection() : (this.disconnect(!0), this.connect());
  };
  f.prototype.handleData = function(a) {
    var b;
    a = JSON.parse(a);
    void 0 === this.protocol ? (b = this.protocol = g(a), this.protocolVersionVerified = !0, this.emit("ready")) : b = this.protocol(a);
    this.emit(b.type, b);
  };
  f.prototype.connect = function() {
    return this.socket ? void 0 : (this.socket = this.setupSocket(), !0);
  };
  f.prototype.send = function(a) {
    this.socket.send(a);
  };
  f.prototype.reportFocus = function(a) {
    this.connected && this.focusedState !== a && (this.focusedState = a, this.emit(this.focusedState ? "focus" : "blur"), this.protocol && this.protocol.sendFocused && this.protocol.sendFocused(this, this.focusedState));
  };
  e.extend(f.prototype, b.prototype);
}, {"../protocol":15, events:21, underscore:24}], 4:[function(a, c) {
  var g = c.exports = a("./base");
  a = a("underscore");
  c = c.exports = function(a) {
    g.call(this, a);
    var b = this;
    this.on("ready", function() {
      b.startFocusLoop();
    });
    this.on("disconnect", function() {
      b.stopFocusLoop();
    });
  };
  a.extend(c.prototype, g.prototype);
  c.__proto__ = g;
  c.prototype.useSecure = function() {
    return "https:" === location.protocol;
  };
  c.prototype.getScheme = function() {
    return this.useSecure() ? "wss:" : "ws:";
  };
  c.prototype.getPort = function() {
    return this.useSecure() ? 6436 : 6437;
  };
  c.prototype.setupSocket = function() {
    var a = this, c = new WebSocket(this.getUrl());
    return c.onopen = function() {
      a.handleOpen();
    }, c.onclose = function(b) {
      a.handleClose(b.code, b.reason);
    }, c.onmessage = function(b) {
      a.handleData(b.data);
    }, c.onerror = function() {
      a.useSecure() && "wss:" === a.scheme && (a.scheme = "ws:", a.port = 6437, a.disconnect(), a.connect());
    }, c;
  };
  c.prototype.startFocusLoop = function() {
    if (!this.focusDetectorTimer) {
      var a = this, c = null;
      c = "undefined" != typeof document.hidden ? "hidden" : "undefined" != typeof document.mozHidden ? "mozHidden" : "undefined" != typeof document.msHidden ? "msHidden" : "undefined" != typeof document.webkitHidden ? "webkitHidden" : void 0;
      void 0 === a.windowVisible && (a.windowVisible = void 0 === c ? !0 : !1 === document[c]);
      var f = window.addEventListener("focus", function() {
        a.windowVisible = !0;
        g();
      }), k = window.addEventListener("blur", function() {
        a.windowVisible = !1;
        g();
      });
      this.on("disconnect", function() {
        window.removeEventListener("focus", f);
        window.removeEventListener("blur", k);
      });
      var g = function() {
        a.reportFocus((void 0 === c ? !0 : !1 === document[c]) && a.windowVisible);
      };
      g();
      this.focusDetectorTimer = setInterval(g, 100);
    }
  };
  c.prototype.stopFocusLoop = function() {
    this.focusDetectorTimer && (clearTimeout(this.focusDetectorTimer), delete this.focusDetectorTimer);
  };
}, {"./base":3, underscore:24}], 5:[function(a, c) {
  var g = a("__browserify_process"), b = a("./frame"), e = a("./hand"), f = a("./pointable"), k = a("./finger"), n = a("./circular_buffer"), p = a("./pipeline"), m = a("events").EventEmitter, t = a("./gesture").gestureListener, d = a("./dialog"), l = a("underscore"), u = c.exports = function(c) {
    var d = this;
    c = l.defaults(c || {}, {inNode:"undefined" != typeof g && g.versions && g.versions.node});
    this.inNode = c.inNode;
    c = l.defaults(c || {}, {frameEventName:this.useAnimationLoop() ? "animationFrame" : "deviceFrame", suppressAnimationLoop:!this.useAnimationLoop(), loopWhileDisconnected:!0, useAllPlugins:!1, checkVersion:!0});
    this.animationFrameRequested = !1;
    this.onAnimationFrame = function(a) {
      d.lastConnectionFrame.valid && d.emit("animationFrame", d.lastConnectionFrame);
      d.emit("frameEnd", a);
      d.loopWhileDisconnected && (!1 !== d.connection.focusedState || d.connection.opts.background) ? window.requestAnimationFrame(d.onAnimationFrame) : d.animationFrameRequested = !1;
    };
    this.suppressAnimationLoop = c.suppressAnimationLoop;
    this.loopWhileDisconnected = c.loopWhileDisconnected;
    this.frameEventName = c.frameEventName;
    this.useAllPlugins = c.useAllPlugins;
    this.history = new n(200);
    this.lastConnectionFrame = this.lastValidFrame = this.lastFrame = b.Invalid;
    this.accumulatedGestures = [];
    this.checkVersion = c.checkVersion;
    this.connectionType = void 0 === c.connectionType ? a(this.inBrowser() ? "./connection/browser" : "./connection/node") : c.connectionType;
    this.connection = new this.connectionType(c);
    this.streamingCount = 0;
    this.devices = {};
    this.plugins = {};
    this._pluginPipelineSteps = {};
    this._pluginExtendedMethods = {};
    c.useAllPlugins && this.useRegisteredPlugins();
    this.setupFrameEvents(c);
    this.setupConnectionEvents();
    this.startAnimationLoop();
  };
  u.prototype.gesture = function(a, b) {
    a = t(this, a);
    return void 0 !== b && a.stop(b), a;
  };
  u.prototype.setBackground = function(a) {
    return this.connection.setBackground(a), this;
  };
  u.prototype.setOptimizeHMD = function(a) {
    return this.connection.setOptimizeHMD(a), this;
  };
  u.prototype.inBrowser = function() {
    return !this.inNode;
  };
  u.prototype.useAnimationLoop = function() {
    return this.inBrowser() && !this.inBackgroundPage();
  };
  u.prototype.inBackgroundPage = function() {
    return "undefined" != typeof chrome && chrome.extension && chrome.extension.getBackgroundPage && chrome.extension.getBackgroundPage() === window;
  };
  u.prototype.connect = function() {
    return this.connection.connect(), this;
  };
  u.prototype.streaming = function() {
    return 0 < this.streamingCount;
  };
  u.prototype.connected = function() {
    return !!this.connection.connected;
  };
  u.prototype.startAnimationLoop = function() {
    this.suppressAnimationLoop || this.animationFrameRequested || (this.animationFrameRequested = !0, window.requestAnimationFrame(this.onAnimationFrame));
  };
  u.prototype.disconnect = function() {
    return this.connection.disconnect(), this;
  };
  u.prototype.frame = function(a) {
    return this.history.get(a) || b.Invalid;
  };
  u.prototype.loop = function(a) {
    return a && ("function" == typeof a ? this.on(this.frameEventName, a) : this.setupFrameEvents(a)), this.connect();
  };
  u.prototype.addStep = function(a) {
    this.pipeline || (this.pipeline = new p(this));
    this.pipeline.addStep(a);
  };
  u.prototype.processFrame = function(a) {
    a.gestures && (this.accumulatedGestures = this.accumulatedGestures.concat(a.gestures));
    this.lastConnectionFrame = a;
    this.startAnimationLoop();
    this.emit("deviceFrame", a);
  };
  u.prototype.processFinishedFrame = function(a) {
    if (this.lastFrame = a, a.valid && (this.lastValidFrame = a), a.controller = this, a.historyIdx = this.history.push(a), a.gestures) {
      a.gestures = this.accumulatedGestures;
      this.accumulatedGestures = [];
      for (var c = 0; c != a.gestures.length; c++) {
        this.emit("gesture", a.gestures[c], a);
      }
    }
    this.pipeline && (a = this.pipeline.run(a), a || (a = b.Invalid));
    this.emit("frame", a);
    this.emitHandEvents(a);
  };
  u.prototype.emitHandEvents = function(a) {
    for (var b = 0; b < a.hands.length; b++) {
      this.emit("hand", a.hands[b]);
    }
  };
  u.prototype.setupFrameEvents = function(a) {
    a.frame && this.on("frame", a.frame);
    a.hand && this.on("hand", a.hand);
  };
  u.prototype.setupConnectionEvents = function() {
    var a = this;
    this.connection.on("frame", function(b) {
      a.processFrame(b);
    });
    this.on(this.frameEventName, function(b) {
      a.processFinishedFrame(b);
    });
    var b = function() {
      if (5 > a.connection.opts.requestProtocolVersion && 0 == a.streamingCount) {
        a.streamingCount = 1;
        var c = {attached:!0, streaming:!0, type:"unknown", id:"Lx00000000000"};
        a.devices[c.id] = c;
        a.emit("deviceAttached", c);
        a.emit("deviceStreaming", c);
        a.emit("streamingStarted", c);
        a.connection.removeListener("frame", b);
      }
    }, c = function() {
      if (0 < a.streamingCount) {
        for (var b in a.devices) {
          a.emit("deviceStopped", a.devices[b]), a.emit("deviceRemoved", a.devices[b]);
        }
        a.emit("streamingStopped", a.devices[b]);
        a.streamingCount = 0;
        for (b in a.devices) {
          delete a.devices[b];
        }
      }
    };
    this.connection.on("focus", function() {
      a.loopWhileDisconnected && a.startAnimationLoop();
      a.emit("focus");
    });
    this.connection.on("blur", function() {
      a.emit("blur");
    });
    this.connection.on("protocol", function(b) {
      b.on("beforeFrameCreated", function(b) {
        a.emit("beforeFrameCreated", b);
      });
      b.on("afterFrameCreated", function(b, c) {
        a.emit("afterFrameCreated", b, c);
      });
      a.emit("protocol", b);
    });
    this.connection.on("ready", function() {
      a.checkVersion && !a.inNode && a.checkOutOfDate();
      a.emit("ready");
    });
    this.connection.on("connect", function() {
      a.emit("connect");
      a.connection.removeListener("frame", b);
      a.connection.on("frame", b);
    });
    this.connection.on("disconnect", function() {
      a.emit("disconnect");
      c();
    });
    this.connection.on("deviceConnect", function(d) {
      d.state ? (a.emit("deviceConnected"), a.connection.removeListener("frame", b), a.connection.on("frame", b)) : (a.emit("deviceDisconnected"), c());
    });
    this.connection.on("deviceEvent", function(b) {
      b = b.state;
      var c = a.devices[b.id], d = {}, e;
      for (e in b) {
        c && c.hasOwnProperty(e) && c[e] == b[e] || (d[e] = !0);
      }
      a.devices[b.id] = b;
      d.attached && a.emit(b.attached ? "deviceAttached" : "deviceRemoved", b);
      d.streaming && (b.streaming ? (a.streamingCount++, a.emit("deviceStreaming", b), 1 == a.streamingCount && a.emit("streamingStarted", b), d.attached || a.emit("deviceConnected")) : d.attached && b.attached || (a.streamingCount--, a.emit("deviceStopped", b), 0 == a.streamingCount && a.emit("streamingStopped", b), a.emit("deviceDisconnected")));
    });
    this.on("newListener", function(a) {
      "deviceConnected" != a && "deviceDisconnected" != a || console.warn(a + " events are depricated.  Consider using 'streamingStarted/streamingStopped' or 'deviceStreaming/deviceStopped' instead");
    });
  };
  u.prototype.checkOutOfDate = function() {
    console.assert(this.connection && this.connection.protocol);
    var a = this.connection.protocol.serviceVersion, b = this.connection.protocol.version, c = this.connectionType.defaultProtocolVersion;
    return c > b ? (console.warn("Your Protocol Version is v" + b + ", this app was designed for v" + c), d.warnOutOfDate({sV:a, pV:b}), !0) : !1;
  };
  u._pluginFactories = {};
  u.plugin = function(a, b) {
    return this._pluginFactories[a] && console.warn('Plugin "' + a + '" already registered'), this._pluginFactories[a] = b;
  };
  u.plugins = function() {
    return l.keys(this._pluginFactories);
  };
  u.prototype.use = function(a, c) {
    var d, g;
    if (d = "function" == typeof a ? a : u._pluginFactories[a], !d) {
      throw "Leap Plugin " + a + " not found.";
    }
    if (c || (c = {}), this.plugins[a]) {
      return l.extend(this.plugins[a], c), this;
    }
    this.plugins[a] = c;
    c = d.call(this, c);
    for (g in c) {
      if (d = c[g], "function" == typeof d) {
        var m = a, n = g;
        -1 != ["beforeFrameCreated", "afterFrameCreated"].indexOf(n) ? this.on(n, d) : (this.pipeline || (this.pipeline = new p(this)), this._pluginPipelineSteps[m] || (this._pluginPipelineSteps[m] = []), this._pluginPipelineSteps[m].push(this.pipeline.addWrappedStep(n, d)));
      } else {
        m = a;
        n = g;
        switch(this._pluginExtendedMethods[m] || (this._pluginExtendedMethods[m] = []), n) {
          case "frame":
            n = b;
            break;
          case "hand":
            n = e;
            break;
          case "pointable":
            n = f;
            l.extend(k.prototype, d);
            l.extend(k.Invalid, d);
            break;
          case "finger":
            n = k;
            break;
          default:
            throw m + ' specifies invalid object type "' + n + '" for prototypical extension';
        }
        l.extend(n.prototype, d);
        l.extend(n.Invalid, d);
        this._pluginExtendedMethods[m].push([n, d]);
      }
    }
    return this;
  };
  u.prototype.stopUsing = function(a) {
    var b = this._pluginPipelineSteps[a];
    var c = this._pluginExtendedMethods[a], d;
    if (this.plugins[a]) {
      if (b) {
        for (d = 0; d < b.length; d++) {
          this.pipeline.removeStep(b[d]);
        }
      }
      if (c) {
        for (d = 0; d < c.length; d++) {
          b = c[d][0];
          var e = c[d][1];
          for (var f in e) {
            delete b.prototype[f], delete b.Invalid[f];
          }
        }
      }
      return delete this.plugins[a], this;
    }
  };
  u.prototype.useRegisteredPlugins = function() {
    for (var a in u._pluginFactories) {
      this.use(a);
    }
  };
  l.extend(u.prototype, m.prototype);
}, {"./circular_buffer":2, "./connection/browser":4, "./connection/node":20, "./dialog":6, "./finger":7, "./frame":8, "./gesture":9, "./hand":10, "./pipeline":13, "./pointable":14, __browserify_process:22, events:21, underscore:24}], 6:[function(a, c) {
  var g = a("__browserify_process"), b = c.exports = function(a, b) {
    this.options = b || {};
    this.message = a;
    this.createElement();
  };
  b.prototype.createElement = function() {
    this.element = document.createElement("div");
    this.element.className = "leapjs-dialog";
    this.element.style.position = "fixed";
    this.element.style.top = "8px";
    this.element.style.left = 0;
    this.element.style.right = 0;
    this.element.style.textAlign = "center";
    this.element.style.zIndex = 1E3;
    var a = document.createElement("div");
    this.element.appendChild(a);
    a.style.className = "leapjs-dialog";
    a.style.display = "inline-block";
    a.style.margin = "auto";
    a.style.padding = "8px";
    a.style.color = "#222";
    a.style.background = "#eee";
    a.style.borderRadius = "4px";
    a.style.border = "1px solid #999";
    a.style.textAlign = "left";
    a.style.cursor = "pointer";
    a.style.whiteSpace = "nowrap";
    a.style.transition = "box-shadow 1s linear";
    a.innerHTML = this.message;
    this.options.onclick && a.addEventListener("click", this.options.onclick);
    this.options.onmouseover && a.addEventListener("mouseover", this.options.onmouseover);
    this.options.onmouseout && a.addEventListener("mouseout", this.options.onmouseout);
    this.options.onmousemove && a.addEventListener("mousemove", this.options.onmousemove);
  };
  b.prototype.show = function() {
    return document.body.appendChild(this.element), this;
  };
  b.prototype.hide = function() {
    return document.body.removeChild(this.element), this;
  };
  b.warnOutOfDate = function(a) {
    a || (a = {});
    var c = "http://developer.leapmotion.com?";
    a.returnTo = window.location.href;
    for (var e in a) {
      c += e + "=" + encodeURIComponent(a[e]) + "&";
    }
    var g;
    return g = new b("This site requires Leap Motion Tracking V2.<button id='leapjs-accept-upgrade'  style='color: #444; transition: box-shadow 100ms linear; cursor: pointer; vertical-align: baseline; margin-left: 16px;'>Upgrade</button><button id='leapjs-decline-upgrade' style='color: #444; transition: box-shadow 100ms linear; cursor: pointer; vertical-align: baseline; margin-left: 8px; '>Not Now</button>", {onclick:function(a) {
      "leapjs-decline-upgrade" != a.target.id && (a = window.open(c, "_blank", "height=800,width=1000,location=1,menubar=1,resizable=1,status=1,toolbar=1,scrollbars=1"), window.focus && a.focus());
      return g.hide(), !0;
    }, onmousemove:function(a) {
      a.target == document.getElementById("leapjs-decline-upgrade") ? (document.getElementById("leapjs-decline-upgrade").style.color = "#000", document.getElementById("leapjs-decline-upgrade").style.boxShadow = "0px 0px 2px #5daa00", document.getElementById("leapjs-accept-upgrade").style.color = "#444", document.getElementById("leapjs-accept-upgrade").style.boxShadow = "none") : (document.getElementById("leapjs-accept-upgrade").style.color = "#000", document.getElementById("leapjs-accept-upgrade").style.boxShadow = 
      "0px 0px 2px #5daa00", document.getElementById("leapjs-decline-upgrade").style.color = "#444", document.getElementById("leapjs-decline-upgrade").style.boxShadow = "none");
    }, onmouseout:function() {
      document.getElementById("leapjs-decline-upgrade").style.color = "#444";
      document.getElementById("leapjs-decline-upgrade").style.boxShadow = "none";
      document.getElementById("leapjs-accept-upgrade").style.color = "#444";
      document.getElementById("leapjs-accept-upgrade").style.boxShadow = "none";
    }}), g.show();
  };
  b.hasWarnedBones = !1;
  b.warnBones = function() {
    this.hasWarnedBones || (this.hasWarnedBones = !0, console.warn("Your Leap Service is out of date"), "undefined" != typeof g && g.versions && g.versions.node || this.warnOutOfDate({reason:"bones"}));
  };
}, {__browserify_process:22}], 7:[function(a, c) {
  var g = a("./pointable"), b = a("./bone"), e = a("./dialog");
  a = a("underscore");
  c = c.exports = function(a) {
    g.call(this, a);
    this.dipPosition = a.dipPosition;
    this.pipPosition = a.pipPosition;
    this.mcpPosition = a.mcpPosition;
    this.carpPosition = a.carpPosition;
    this.extended = a.extended;
    this.type = a.type;
    this.finger = !0;
    this.positions = [this.carpPosition, this.mcpPosition, this.pipPosition, this.dipPosition, this.tipPosition];
    a.bases ? this.addBones(a) : e.warnBones();
  };
  a.extend(c.prototype, g.prototype);
  c.prototype.addBones = function(a) {
    this.metacarpal = new b(this, {type:0, width:this.width, prevJoint:this.carpPosition, nextJoint:this.mcpPosition, basis:a.bases[0]});
    this.proximal = new b(this, {type:1, width:this.width, prevJoint:this.mcpPosition, nextJoint:this.pipPosition, basis:a.bases[1]});
    this.medial = new b(this, {type:2, width:this.width, prevJoint:this.pipPosition, nextJoint:this.dipPosition, basis:a.bases[2]});
    this.distal = new b(this, {type:3, width:this.width, prevJoint:this.dipPosition, nextJoint:a.btipPosition, basis:a.bases[3]});
    this.bones = [this.metacarpal, this.proximal, this.medial, this.distal];
  };
  c.prototype.toString = function() {
    return "Finger [ id:" + this.id + " " + this.length + "mmx | width:" + this.width + "mm | direction:" + this.direction + " ]";
  };
  c.Invalid = {valid:!1};
}, {"./bone":1, "./dialog":6, "./pointable":14, underscore:24}], 8:[function(a, c) {
  var g = a("./hand"), b = a("./pointable"), e = a("./gesture").createGesture, f = a("gl-matrix"), k = f.mat3, n = f.vec3, p = a("./interaction_box"), m = a("./finger"), t = a("underscore");
  a = c.exports = function(a) {
    if (this.valid = !0, this.id = a.id, this.timestamp = a.timestamp, this.hands = [], this.handsMap = {}, this.pointables = [], this.tools = [], this.fingers = [], a.interactionBox && (this.interactionBox = new p(a.interactionBox)), this.gestures = [], this.pointablesMap = {}, this._translation = a.t, this._rotation = t.flatten(a.r), this._scaleFactor = a.s, this.data = a, this.type = "frame", this.currentFrameRate = a.currentFrameRate, a.gestures) {
      for (var b = 0, c = a.gestures.length; b != c; b++) {
        this.gestures.push(e(a.gestures[b]));
      }
    }
    this.postprocessData(a);
  };
  a.prototype.postprocessData = function(a) {
    a || (a = this.data);
    for (var c = 0, d = a.hands.length; c != d; c++) {
      var e = new g(a.hands[c]);
      e.frame = this;
      this.hands.push(e);
      this.handsMap[e.id] = e;
    }
    a.pointables = t.sortBy(a.pointables, function(a) {
      return a.id;
    });
    c = 0;
    for (d = a.pointables.length; c != d; c++) {
      e = a.pointables[c], e = e.dipPosition ? new m(e) : new b(e), e.frame = this, this.addPointable(e);
    }
  };
  a.prototype.addPointable = function(a) {
    if (this.pointables.push(a), this.pointablesMap[a.id] = a, (a.tool ? this.tools : this.fingers).push(a), void 0 !== a.handId && this.handsMap.hasOwnProperty(a.handId)) {
      var b = this.handsMap[a.handId];
      switch(b.pointables.push(a), (a.tool ? b.tools : b.fingers).push(a), a.type) {
        case 0:
          b.thumb = a;
          break;
        case 1:
          b.indexFinger = a;
          break;
        case 2:
          b.middleFinger = a;
          break;
        case 3:
          b.ringFinger = a;
          break;
        case 4:
          b.pinky = a;
      }
    }
  };
  a.prototype.tool = function(a) {
    a = this.pointable(a);
    return a.tool ? a : b.Invalid;
  };
  a.prototype.pointable = function(a) {
    return this.pointablesMap[a] || b.Invalid;
  };
  a.prototype.finger = function(a) {
    a = this.pointable(a);
    return a.tool ? b.Invalid : a;
  };
  a.prototype.hand = function(a) {
    return this.handsMap[a] || g.Invalid;
  };
  a.prototype.rotationAngle = function(a, b) {
    if (!this.valid || !a.valid) {
      return 0;
    }
    var c = this.rotationMatrix(a);
    c = Math.acos(.5 * (c[0] + c[4] + c[8] - 1));
    if (c = isNaN(c) ? 0 : c, void 0 !== b) {
      a = this.rotationAxis(a), c *= n.dot(a, n.normalize(n.create(), b));
    }
    return c;
  };
  a.prototype.rotationAxis = function(a) {
    return this.valid && a.valid ? n.normalize(n.create(), [this._rotation[7] - a._rotation[5], this._rotation[2] - a._rotation[6], this._rotation[3] - a._rotation[1]]) : n.create();
  };
  a.prototype.rotationMatrix = function(a) {
    if (!this.valid || !a.valid) {
      return k.create();
    }
    var b = k.transpose(k.create(), this._rotation);
    return k.multiply(k.create(), a._rotation, b);
  };
  a.prototype.scaleFactor = function(a) {
    return this.valid && a.valid ? Math.exp(this._scaleFactor - a._scaleFactor) : 1;
  };
  a.prototype.translation = function(a) {
    return this.valid && a.valid ? n.subtract(n.create(), this._translation, a._translation) : n.create();
  };
  a.prototype.toString = function() {
    var a = "Frame [ id:" + this.id + " | timestamp:" + this.timestamp + " | Hand count:(" + this.hands.length + ") | Pointable count:(" + this.pointables.length + ")";
    return this.gestures && (a += " | Gesture count:(" + this.gestures.length + ")"), a + " ]";
  };
  a.prototype.dump = function() {
    var a = "Frame Info:<br/>" + this.toString();
    a += "<br/><br/>Hands:<br/>";
    for (var b = 0, c = this.hands.length; b != c; b++) {
      a += "  " + this.hands[b].toString() + "<br/>";
    }
    a += "<br/><br/>Pointables:<br/>";
    b = 0;
    for (c = this.pointables.length; b != c; b++) {
      a += "  " + this.pointables[b].toString() + "<br/>";
    }
    if (this.gestures) {
      for (a += "<br/><br/>Gestures:<br/>", b = 0, c = this.gestures.length; b != c; b++) {
        a += "  " + this.gestures[b].toString() + "<br/>";
      }
    }
    return a += "<br/><br/>Raw JSON:<br/>", a + JSON.stringify(this.data);
  };
  a.Invalid = {valid:!1, hands:[], fingers:[], tools:[], gestures:[], pointables:[], pointable:function() {
    return b.Invalid;
  }, finger:function() {
    return b.Invalid;
  }, hand:function() {
    return g.Invalid;
  }, toString:function() {
    return "invalid frame";
  }, dump:function() {
    return this.toString();
  }, rotationAngle:function() {
    return 0;
  }, rotationMatrix:function() {
    return k.create();
  }, rotationAxis:function() {
    return n.create();
  }, scaleFactor:function() {
    return 1;
  }, translation:function() {
    return n.create();
  }};
}, {"./finger":7, "./gesture":9, "./hand":10, "./interaction_box":12, "./pointable":14, "gl-matrix":23, underscore:24}], 9:[function(a, c, g) {
  var b = a("gl-matrix").vec3;
  c = a("events").EventEmitter;
  var e = a("underscore"), f = (g.createGesture = function(a) {
    switch(a.type) {
      case "circle":
        var b = new k(a);
        break;
      case "swipe":
        b = new n(a);
        break;
      case "screenTap":
        b = new p(a);
        break;
      case "keyTap":
        b = new m(a);
        break;
      default:
        throw "unknown gesture type";
    }
    return b.id = a.id, b.handIds = a.handIds.slice(), b.pointableIds = a.pointableIds.slice(), b.duration = a.duration, b.state = a.state, b.type = a.type, b;
  }, g.gestureListener = function(a, b) {
    var c = {}, d = {};
    a.on("gesture", function(a, k) {
      if (a.type == b) {
        if (("start" == a.state || "stop" == a.state) && void 0 === d[a.id]) {
          var g = new f(a, k);
          d[a.id] = g;
          e.each(c, function(a, b) {
            g.on(b, a);
          });
        }
        d[a.id].update(a, k);
        "stop" == a.state && delete d[a.id];
      }
    });
    var k = {start:function(a) {
      return c.start = a, k;
    }, stop:function(a) {
      return c.stop = a, k;
    }, complete:function(a) {
      return c.stop = a, k;
    }, update:function(a) {
      return c.update = a, k;
    }};
    return k;
  }, g.Gesture = function(a, b) {
    this.gestures = [a];
    this.frames = [b];
  });
  f.prototype.update = function(a, b) {
    this.lastGesture = a;
    this.lastFrame = b;
    this.gestures.push(a);
    this.frames.push(b);
    this.emit(a.state, this);
  };
  f.prototype.translation = function() {
    return b.subtract(b.create(), this.lastGesture.startPosition, this.lastGesture.position);
  };
  e.extend(f.prototype, c.prototype);
  var k = function(a) {
    this.center = a.center;
    this.normal = a.normal;
    this.progress = a.progress;
    this.radius = a.radius;
  };
  k.prototype.toString = function() {
    return "CircleGesture [" + JSON.stringify(this) + "]";
  };
  var n = function(a) {
    this.startPosition = a.startPosition;
    this.position = a.position;
    this.direction = a.direction;
    this.speed = a.speed;
  };
  n.prototype.toString = function() {
    return "SwipeGesture [" + JSON.stringify(this) + "]";
  };
  var p = function(a) {
    this.position = a.position;
    this.direction = a.direction;
    this.progress = a.progress;
  };
  p.prototype.toString = function() {
    return "ScreenTapGesture [" + JSON.stringify(this) + "]";
  };
  var m = function(a) {
    this.position = a.position;
    this.direction = a.direction;
    this.progress = a.progress;
  };
  m.prototype.toString = function() {
    return "KeyTapGesture [" + JSON.stringify(this) + "]";
  };
}, {events:21, "gl-matrix":23, underscore:24}], 10:[function(a, c) {
  var g = a("./pointable"), b = a("./bone"), e = a("gl-matrix"), f = e.mat3, k = e.vec3, n = a("underscore");
  a = c.exports = function(a) {
    this.id = a.id;
    this.palmPosition = a.palmPosition;
    this.direction = a.direction;
    this.palmVelocity = a.palmVelocity;
    this.palmNormal = a.palmNormal;
    this.sphereCenter = a.sphereCenter;
    this.sphereRadius = a.sphereRadius;
    this.valid = !0;
    this.pointables = [];
    this.fingers = [];
    this.arm = a.armBasis ? new b(this, {type:4, width:a.armWidth, prevJoint:a.elbow, nextJoint:a.wrist, basis:a.armBasis}) : null;
    this.tools = [];
    this._translation = a.t;
    this._rotation = n.flatten(a.r);
    this._scaleFactor = a.s;
    this.timeVisible = a.timeVisible;
    this.stabilizedPalmPosition = a.stabilizedPalmPosition;
    this.type = a.type;
    this.grabStrength = a.grabStrength;
    this.pinchStrength = a.pinchStrength;
    this.confidence = a.confidence;
  };
  a.prototype.finger = function(a) {
    return (a = this.frame.finger(a)) && a.handId == this.id ? a : g.Invalid;
  };
  a.prototype.rotationAngle = function(a, b) {
    if (!this.valid || !a.valid || !a.hand(this.id).valid) {
      return 0;
    }
    var c = this.rotationMatrix(a);
    c = Math.acos(.5 * (c[0] + c[4] + c[8] - 1));
    if (c = isNaN(c) ? 0 : c, void 0 !== b) {
      a = this.rotationAxis(a), c *= k.dot(a, k.normalize(k.create(), b));
    }
    return c;
  };
  a.prototype.rotationAxis = function(a) {
    if (!this.valid || !a.valid) {
      return k.create();
    }
    a = a.hand(this.id);
    return a.valid ? k.normalize(k.create(), [this._rotation[7] - a._rotation[5], this._rotation[2] - a._rotation[6], this._rotation[3] - a._rotation[1]]) : k.create();
  };
  a.prototype.rotationMatrix = function(a) {
    if (!this.valid || !a.valid) {
      return f.create();
    }
    a = a.hand(this.id);
    if (!a.valid) {
      return f.create();
    }
    var b = f.transpose(f.create(), this._rotation);
    return f.multiply(f.create(), a._rotation, b);
  };
  a.prototype.scaleFactor = function(a) {
    if (!this.valid || !a.valid) {
      return 1;
    }
    a = a.hand(this.id);
    return a.valid ? Math.exp(this._scaleFactor - a._scaleFactor) : 1;
  };
  a.prototype.translation = function(a) {
    if (!this.valid || !a.valid) {
      return k.create();
    }
    a = a.hand(this.id);
    return a.valid ? [this._translation[0] - a._translation[0], this._translation[1] - a._translation[1], this._translation[2] - a._translation[2]] : k.create();
  };
  a.prototype.toString = function() {
    return "Hand (" + this.type + ") [ id: " + this.id + " | palm velocity:" + this.palmVelocity + " | sphere center:" + this.sphereCenter + " ] ";
  };
  a.prototype.pitch = function() {
    return Math.atan2(this.direction[1], -this.direction[2]);
  };
  a.prototype.yaw = function() {
    return Math.atan2(this.direction[0], -this.direction[2]);
  };
  a.prototype.roll = function() {
    return Math.atan2(this.palmNormal[0], -this.palmNormal[1]);
  };
  a.Invalid = {valid:!1, fingers:[], tools:[], pointables:[], left:!1, pointable:function() {
    return g.Invalid;
  }, finger:function() {
    return g.Invalid;
  }, toString:function() {
    return "invalid frame";
  }, dump:function() {
    return this.toString();
  }, rotationAngle:function() {
    return 0;
  }, rotationMatrix:function() {
    return f.create();
  }, rotationAxis:function() {
    return k.create();
  }, scaleFactor:function() {
    return 1;
  }, translation:function() {
    return k.create();
  }};
}, {"./bone":1, "./pointable":14, "gl-matrix":23, underscore:24}], 11:[function(a, c) {
  c.exports = {Controller:a("./controller"), Frame:a("./frame"), Gesture:a("./gesture"), Hand:a("./hand"), Pointable:a("./pointable"), Finger:a("./finger"), InteractionBox:a("./interaction_box"), CircularBuffer:a("./circular_buffer"), UI:a("./ui"), JSONProtocol:a("./protocol").JSONProtocol, glMatrix:a("gl-matrix"), mat3:a("gl-matrix").mat3, vec3:a("gl-matrix").vec3, loopController:void 0, version:a("./version.js"), _:a("underscore"), EventEmitter:a("events").EventEmitter, loop:function(a, b) {
    return a && void 0 === b && "[object Function]" === {}.toString.call(a) && (b = a, a = {}), this.loopController ? a && this.loopController.setupFrameEvents(a) : this.loopController = new this.Controller(a), this.loopController.loop(b), this.loopController;
  }, plugin:function(a, b) {
    this.Controller.plugin(a, b);
  }};
}, {"./circular_buffer":2, "./controller":5, "./finger":7, "./frame":8, "./gesture":9, "./hand":10, "./interaction_box":12, "./pointable":14, "./protocol":15, "./ui":16, "./version.js":19, events:21, "gl-matrix":23, underscore:24}], 12:[function(a, c) {
  var g = a("gl-matrix").vec3;
  a = c.exports = function(a) {
    this.valid = !0;
    this.center = a.center;
    this.size = a.size;
    this.width = a.size[0];
    this.height = a.size[1];
    this.depth = a.size[2];
  };
  a.prototype.denormalizePoint = function(a) {
    return g.fromValues((a[0] - .5) * this.size[0] + this.center[0], (a[1] - .5) * this.size[1] + this.center[1], (a[2] - .5) * this.size[2] + this.center[2]);
  };
  a.prototype.normalizePoint = function(a, c) {
    a = g.fromValues((a[0] - this.center[0]) / this.size[0] + .5, (a[1] - this.center[1]) / this.size[1] + .5, (a[2] - this.center[2]) / this.size[2] + .5);
    return c && (a[0] = Math.min(Math.max(a[0], 0), 1), a[1] = Math.min(Math.max(a[1], 0), 1), a[2] = Math.min(Math.max(a[2], 0), 1)), a;
  };
  a.prototype.toString = function() {
    return "InteractionBox [ width:" + this.width + " | height:" + this.height + " | depth:" + this.depth + " ]";
  };
  a.Invalid = {valid:!1};
}, {"gl-matrix":23}], 13:[function(a, c) {
  a = c.exports = function(a) {
    this.steps = [];
    this.controller = a;
  };
  a.prototype.addStep = function(a) {
    this.steps.push(a);
  };
  a.prototype.run = function(a) {
    for (var b = this.steps.length, c = 0; c != b && a; c++) {
      a = this.steps[c](a);
    }
    return a;
  };
  a.prototype.removeStep = function(a) {
    a = this.steps.indexOf(a);
    if (-1 === a) {
      throw "Step not found in pipeline";
    }
    this.steps.splice(a, 1);
  };
  a.prototype.addWrappedStep = function(a, b) {
    var c = this.controller, f = function(e) {
      var f;
      var k = "frame" == a ? [e] : e[a + "s"] || [];
      var g = 0;
      for (f = k.length; f > g; g++) {
        b.call(c, k[g]);
      }
      return e;
    };
    return this.addStep(f), f;
  };
}, {}], 14:[function(a, c) {
  a = a("gl-matrix");
  c = (a.vec3, c.exports = function(a) {
    this.valid = !0;
    this.id = a.id;
    this.handId = a.handId;
    this.length = a.length;
    this.tool = a.tool;
    this.width = a.width;
    this.direction = a.direction;
    this.stabilizedTipPosition = a.stabilizedTipPosition;
    this.tipPosition = a.tipPosition;
    this.tipVelocity = a.tipVelocity;
    this.touchZone = a.touchZone;
    this.touchDistance = a.touchDistance;
    this.timeVisible = a.timeVisible;
  });
  c.prototype.toString = function() {
    return "Pointable [ id:" + this.id + " " + this.length + "mmx | width:" + this.width + "mm | direction:" + this.direction + " ]";
  };
  c.prototype.hand = function() {
    return this.frame.hand(this.handId);
  };
  c.Invalid = {valid:!1};
}, {"gl-matrix":23}], 15:[function(a, c, g) {
  var b = a("./frame"), e = (a("./hand"), a("./pointable"), a("./finger"), a("underscore")), f = a("events").EventEmitter, k = function(a) {
    this.type = a.type;
    this.state = a.state;
  };
  g.chooseProtocol = function(a) {
    switch(a.version) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
        var b = n(a);
        b.sendBackground = function(a, c) {
          a.send(b.encode({background:c}));
        };
        b.sendFocused = function(a, c) {
          a.send(b.encode({focused:c}));
        };
        b.sendOptimizeHMD = function(a, c) {
          a.send(b.encode({optimizeHMD:c}));
        };
        break;
      default:
        throw "unrecognized version";
    }
    return b;
  };
  var n = g.JSONProtocol = function(a) {
    var c = function(a) {
      if (a.event) {
        return new k(a.event);
      }
      c.emit("beforeFrameCreated", a);
      var d = new b(a);
      return c.emit("afterFrameCreated", d, a), d;
    };
    return c.encode = function(a) {
      return JSON.stringify(a);
    }, c.version = a.version, c.serviceVersion = a.serviceVersion, c.versionLong = "Version " + a.version, c.type = "protocol", e.extend(c, f.prototype), c;
  };
}, {"./finger":7, "./frame":8, "./hand":10, "./pointable":14, events:21, underscore:24}], 16:[function(a, c, g) {
  g.UI = {Region:a("./ui/region"), Cursor:a("./ui/cursor")};
}, {"./ui/cursor":17, "./ui/region":18}], 17:[function(a, c) {
  c.exports = function() {
    return function(a) {
      var b = a.pointables.sort(function(a, b) {
        return a.z - b.z;
      })[0];
      return b && b.valid && (a.cursorPosition = b.tipPosition), a;
    };
  };
}, {}], 18:[function(a, c) {
  var g = a("events").EventEmitter;
  a = a("underscore");
  var b = c.exports = function(a, b) {
    this.start = new Vector(a);
    this.end = new Vector(b);
    this.enteredFrame = null;
  };
  b.prototype.hasPointables = function(a) {
    for (var b = 0; b != a.pointables.length; b++) {
      var c = a.pointables[b].tipPosition;
      if (c.x >= this.start.x && c.x <= this.end.x && c.y >= this.start.y && c.y <= this.end.y && c.z >= this.start.z && c.z <= this.end.z) {
        return !0;
      }
    }
    return !1;
  };
  b.prototype.listener = function(a) {
    var b = this;
    return a && a.nearThreshold && this.setupNearRegion(a.nearThreshold), function(a) {
      return b.updatePosition(a);
    };
  };
  b.prototype.clipper = function() {
    var a = this;
    return function(b) {
      return a.updatePosition(b), a.enteredFrame ? b : null;
    };
  };
  b.prototype.setupNearRegion = function(a) {
    a = this.nearRegion = new b([this.start.x - a, this.start.y - a, this.start.z - a], [this.end.x + a, this.end.y + a, this.end.z + a]);
    var c = this;
    a.on("enter", function(a) {
      c.emit("near", a);
    });
    a.on("exit", function(a) {
      c.emit("far", a);
    });
    c.on("exit", function(a) {
      c.emit("near", a);
    });
  };
  b.prototype.updatePosition = function(a) {
    return this.nearRegion && this.nearRegion.updatePosition(a), this.hasPointables(a) && null == this.enteredFrame ? (this.enteredFrame = a, this.emit("enter", this.enteredFrame)) : this.hasPointables(a) || null == this.enteredFrame || (this.enteredFrame = null, this.emit("exit", this.enteredFrame)), a;
  };
  b.prototype.normalize = function(a) {
    return new Vector([(a.x - this.start.x) / (this.end.x - this.start.x), (a.y - this.start.y) / (this.end.y - this.start.y), (a.z - this.start.z) / (this.end.z - this.start.z)]);
  };
  b.prototype.mapToXY = function(a, b, c) {
    a = this.normalize(a);
    var e = a.x, f = a.y;
    return 1 < e ? e = 1 : -1 > e && (e = -1), 1 < f ? f = 1 : -1 > f && (f = -1), [(e + 1) / 2 * b, (1 - f) / 2 * c, a.z];
  };
  a.extend(b.prototype, g.prototype);
}, {events:21, underscore:24}], 19:[function(a, c) {
  c.exports = {full:"0.6.4", major:0, minor:6, dot:4};
}, {}], 20:[function() {
}, {}], 21:[function(a, c, g) {
  a = a("__browserify_process");
  a.EventEmitter || (a.EventEmitter = function() {
  });
  g = g.EventEmitter = a.EventEmitter;
  var b = "function" == typeof Array.isArray ? Array.isArray : function(a) {
    return "[object Array]" === Object.prototype.toString.call(a);
  };
  g.prototype.setMaxListeners = function(a) {
    this._events || (this._events = {});
    this._events.maxListeners = a;
  };
  g.prototype.emit = function(a) {
    if ("error" === a && (!this._events || !this._events.error || b(this._events.error) && !this._events.error.length)) {
      throw arguments[1] instanceof Error ? arguments[1] : Error("Uncaught, unspecified 'error' event.");
    }
    if (!this._events) {
      return !1;
    }
    var c = this._events[a];
    if (!c) {
      return !1;
    }
    if ("function" == typeof c) {
      switch(arguments.length) {
        case 1:
          c.call(this);
          break;
        case 2:
          c.call(this, arguments[1]);
          break;
        case 3:
          c.call(this, arguments[1], arguments[2]);
          break;
        default:
          var e = Array.prototype.slice.call(arguments, 1);
          c.apply(this, e);
      }
      return !0;
    }
    if (b(c)) {
      e = Array.prototype.slice.call(arguments, 1);
      c = c.slice();
      for (var g = 0, p = c.length; p > g; g++) {
        c[g].apply(this, e);
      }
      return !0;
    }
    return !1;
  };
  g.prototype.addListener = function(a, c) {
    if ("function" != typeof c) {
      throw Error("addListener only takes instances of Function");
    }
    if (this._events || (this._events = {}), this.emit("newListener", a, c), this._events[a]) {
      if (b(this._events[a])) {
        if (!this._events[a].warned) {
          var e;
          (e = void 0 !== this._events.maxListeners ? this._events.maxListeners : 10) && 0 < e && this._events[a].length > e && (this._events[a].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[a].length), console.trace());
        }
        this._events[a].push(c);
      } else {
        this._events[a] = [this._events[a], c];
      }
    } else {
      this._events[a] = c;
    }
    return this;
  };
  g.prototype.on = g.prototype.addListener;
  g.prototype.once = function(a, b) {
    var c = this;
    return c.on(a, function p() {
      c.removeListener(a, p);
      b.apply(this, arguments);
    }), this;
  };
  g.prototype.removeListener = function(a, c) {
    if ("function" != typeof c) {
      throw Error("removeListener only takes instances of Function");
    }
    if (!this._events || !this._events[a]) {
      return this;
    }
    var e = this._events[a];
    if (b(e)) {
      a: {
        if (e.indexOf) {
          c = e.indexOf(c);
        } else {
          for (var f = 0; f < e.length; f++) {
            if (c === e[f]) {
              c = f;
              break a;
            }
          }
          c = -1;
        }
      }
      if (0 > c) {
        return this;
      }
      e.splice(c, 1);
      0 == e.length && delete this._events[a];
    } else {
      this._events[a] === c && delete this._events[a];
    }
    return this;
  };
  g.prototype.removeAllListeners = function(a) {
    return 0 === arguments.length ? (this._events = {}, this) : (a && this._events && this._events[a] && (this._events[a] = null), this);
  };
  g.prototype.listeners = function(a) {
    return this._events || (this._events = {}), this._events[a] || (this._events[a] = []), b(this._events[a]) || (this._events[a] = [this._events[a]]), this._events[a];
  };
  g.listenerCount = function(a, b) {
    return a._events && a._events[b] ? "function" == typeof a._events[b] ? 1 : a._events[b].length : 0;
  };
}, {__browserify_process:22}], 22:[function(a, c) {
  a = c.exports = {};
  a.nextTick = function() {
    if ("undefined" != typeof window && window.setImmediate) {
      return function(a) {
        return window.setImmediate(a);
      };
    }
    if ("undefined" != typeof window && window.postMessage && window.addEventListener) {
      var a = [];
      return window.addEventListener("message", function(b) {
        var c = b.source;
        (c === window || null === c) && "process-tick" === b.data && (b.stopPropagation(), 0 < a.length) && a.shift()();
      }, !0), function(b) {
        a.push(b);
        window.postMessage("process-tick", "*");
      };
    }
    return function(a) {
      setTimeout(a, 0);
    };
  }();
  a.title = "browser";
  a.browser = !0;
  a.env = {};
  a.argv = [];
  a.binding = function() {
    throw Error("process.binding is not supported");
  };
  a.cwd = function() {
    return "/";
  };
  a.chdir = function() {
    throw Error("process.chdir is not supported");
  };
}, {}], 23:[function(a, c, g) {
  !function(a) {
    var b;
    "undefined" == typeof g ? "function" == typeof define && "object" == typeof define.amd && define.amd ? (b = {}, define(function() {
      return b;
    })) : b = "undefined" != typeof window ? window : a : b = g;
    (function(a) {
      if (!b) {
        var b = 1E-6;
      }
      if (!c) {
        var c = "undefined" != typeof Float32Array ? Float32Array : Array;
      }
      if (!e) {
        var e = Math.random;
      }
      var f = {setMatrixArrayType:function(a) {
        c = a;
      }};
      "undefined" != typeof a && (a.glMatrix = f);
      var g = Math.PI / 180;
      f.toRadian = function(a) {
        return a * g;
      };
      var d = {create:function() {
        var a = new c(2);
        return a[0] = 0, a[1] = 0, a;
      }, clone:function(a) {
        var b = new c(2);
        return b[0] = a[0], b[1] = a[1], b;
      }, fromValues:function(a, b) {
        var d = new c(2);
        return d[0] = a, d[1] = b, d;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a;
      }, set:function(a, b, c) {
        return a[0] = b, a[1] = c, a;
      }, add:function(a, b, c) {
        return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a;
      }, subtract:function(a, b, c) {
        return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a;
      }};
      d.sub = d.subtract;
      d.multiply = function(a, b, c) {
        return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a;
      };
      d.mul = d.multiply;
      d.divide = function(a, b, c) {
        return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a;
      };
      d.div = d.divide;
      d.min = function(a, b, c) {
        return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a;
      };
      d.max = function(a, b, c) {
        return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a;
      };
      d.scale = function(a, b, c) {
        return a[0] = b[0] * c, a[1] = b[1] * c, a;
      };
      d.scaleAndAdd = function(a, b, c, d) {
        return a[0] = b[0] + c[0] * d, a[1] = b[1] + c[1] * d, a;
      };
      d.distance = function(a, b) {
        var c = b[0] - a[0];
        a = b[1] - a[1];
        return Math.sqrt(c * c + a * a);
      };
      d.dist = d.distance;
      d.squaredDistance = function(a, b) {
        var c = b[0] - a[0];
        a = b[1] - a[1];
        return c * c + a * a;
      };
      d.sqrDist = d.squaredDistance;
      d.length = function(a) {
        var b = a[0];
        a = a[1];
        return Math.sqrt(b * b + a * a);
      };
      d.len = d.length;
      d.squaredLength = function(a) {
        var b = a[0];
        a = a[1];
        return b * b + a * a;
      };
      d.sqrLen = d.squaredLength;
      d.negate = function(a, b) {
        return a[0] = -b[0], a[1] = -b[1], a;
      };
      d.normalize = function(a, b) {
        var c = b[0], d = b[1];
        c = c * c + d * d;
        return 0 < c && (c = 1 / Math.sqrt(c), a[0] = b[0] * c, a[1] = b[1] * c), a;
      };
      d.dot = function(a, b) {
        return a[0] * b[0] + a[1] * b[1];
      };
      d.cross = function(a, b, c) {
        b = b[0] * c[1] - b[1] * c[0];
        return a[0] = a[1] = 0, a[2] = b, a;
      };
      d.lerp = function(a, b, c, d) {
        var e = b[0];
        b = b[1];
        return a[0] = e + d * (c[0] - e), a[1] = b + d * (c[1] - b), a;
      };
      d.random = function(a, b) {
        b = b || 1;
        var c = 2 * e() * Math.PI;
        return a[0] = Math.cos(c) * b, a[1] = Math.sin(c) * b, a;
      };
      d.transformMat2 = function(a, b, c) {
        var d = b[0];
        b = b[1];
        return a[0] = c[0] * d + c[2] * b, a[1] = c[1] * d + c[3] * b, a;
      };
      d.transformMat2d = function(a, b, c) {
        var d = b[0];
        b = b[1];
        return a[0] = c[0] * d + c[2] * b + c[4], a[1] = c[1] * d + c[3] * b + c[5], a;
      };
      d.transformMat3 = function(a, b, c) {
        var d = b[0];
        b = b[1];
        return a[0] = c[0] * d + c[3] * b + c[6], a[1] = c[1] * d + c[4] * b + c[7], a;
      };
      d.transformMat4 = function(a, b, c) {
        var d = b[0];
        b = b[1];
        return a[0] = c[0] * d + c[4] * b + c[12], a[1] = c[1] * d + c[5] * b + c[13], a;
      };
      d.forEach = function() {
        var a = d.create();
        return function(b, c, d, e, f, k) {
          c || (c = 2);
          d || (d = 0);
          for (e = e ? Math.min(e * c + d, b.length) : b.length; e > d; d += c) {
            a[0] = b[d], a[1] = b[d + 1], f(a, a, k), b[d] = a[0], b[d + 1] = a[1];
          }
          return b;
        };
      }();
      d.str = function(a) {
        return "vec2(" + a[0] + ", " + a[1] + ")";
      };
      "undefined" != typeof a && (a.vec2 = d);
      var l = {create:function() {
        var a = new c(3);
        return a[0] = 0, a[1] = 0, a[2] = 0, a;
      }, clone:function(a) {
        var b = new c(3);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b;
      }, fromValues:function(a, b, d) {
        var e = new c(3);
        return e[0] = a, e[1] = b, e[2] = d, e;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a;
      }, set:function(a, b, c, d) {
        return a[0] = b, a[1] = c, a[2] = d, a;
      }, add:function(a, b, c) {
        return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a[2] = b[2] + c[2], a;
      }, subtract:function(a, b, c) {
        return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a[2] = b[2] - c[2], a;
      }};
      l.sub = l.subtract;
      l.multiply = function(a, b, c) {
        return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a[2] = b[2] * c[2], a;
      };
      l.mul = l.multiply;
      l.divide = function(a, b, c) {
        return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a[2] = b[2] / c[2], a;
      };
      l.div = l.divide;
      l.min = function(a, b, c) {
        return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a[2] = Math.min(b[2], c[2]), a;
      };
      l.max = function(a, b, c) {
        return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a[2] = Math.max(b[2], c[2]), a;
      };
      l.scale = function(a, b, c) {
        return a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a;
      };
      l.scaleAndAdd = function(a, b, c, d) {
        return a[0] = b[0] + c[0] * d, a[1] = b[1] + c[1] * d, a[2] = b[2] + c[2] * d, a;
      };
      l.distance = function(a, b) {
        var c = b[0] - a[0], d = b[1] - a[1];
        a = b[2] - a[2];
        return Math.sqrt(c * c + d * d + a * a);
      };
      l.dist = l.distance;
      l.squaredDistance = function(a, b) {
        var c = b[0] - a[0], d = b[1] - a[1];
        a = b[2] - a[2];
        return c * c + d * d + a * a;
      };
      l.sqrDist = l.squaredDistance;
      l.length = function(a) {
        var b = a[0], c = a[1];
        a = a[2];
        return Math.sqrt(b * b + c * c + a * a);
      };
      l.len = l.length;
      l.squaredLength = function(a) {
        var b = a[0], c = a[1];
        a = a[2];
        return b * b + c * c + a * a;
      };
      l.sqrLen = l.squaredLength;
      l.negate = function(a, b) {
        return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a;
      };
      l.normalize = function(a, b) {
        var c = b[0], d = b[1], e = b[2];
        c = c * c + d * d + e * e;
        return 0 < c && (c = 1 / Math.sqrt(c), a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c), a;
      };
      l.dot = function(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      };
      l.cross = function(a, b, c) {
        var d = b[0], e = b[1];
        b = b[2];
        var f = c[0], k = c[1];
        c = c[2];
        return a[0] = e * c - b * k, a[1] = b * f - d * c, a[2] = d * k - e * f, a;
      };
      l.lerp = function(a, b, c, d) {
        var e = b[0], f = b[1];
        b = b[2];
        return a[0] = e + d * (c[0] - e), a[1] = f + d * (c[1] - f), a[2] = b + d * (c[2] - b), a;
      };
      l.random = function(a, b) {
        b = b || 1;
        var c = 2 * e() * Math.PI, d = 2 * e() - 1, f = Math.sqrt(1 - d * d) * b;
        return a[0] = Math.cos(c) * f, a[1] = Math.sin(c) * f, a[2] = d * b, a;
      };
      l.transformMat4 = function(a, b, c) {
        var d = b[0], e = b[1];
        b = b[2];
        return a[0] = c[0] * d + c[4] * e + c[8] * b + c[12], a[1] = c[1] * d + c[5] * e + c[9] * b + c[13], a[2] = c[2] * d + c[6] * e + c[10] * b + c[14], a;
      };
      l.transformMat3 = function(a, b, c) {
        var d = b[0], e = b[1];
        b = b[2];
        return a[0] = d * c[0] + e * c[3] + b * c[6], a[1] = d * c[1] + e * c[4] + b * c[7], a[2] = d * c[2] + e * c[5] + b * c[8], a;
      };
      l.transformQuat = function(a, b, c) {
        var d = b[0], e = b[1], f = b[2];
        b = c[0];
        var k = c[1], g = c[2];
        c = c[3];
        var l = c * d + k * f - g * e, q = c * e + g * d - b * f, m = c * f + b * e - k * d;
        d = -b * d - k * e - g * f;
        return a[0] = l * c + d * -b + q * -g - m * -k, a[1] = q * c + d * -k + m * -b - l * -g, a[2] = m * c + d * -g + l * -k - q * -b, a;
      };
      l.rotateX = function(a, b, c, d) {
        var e = [], f = [];
        return e[0] = b[0] - c[0], e[1] = b[1] - c[1], e[2] = b[2] - c[2], f[0] = e[0], f[1] = e[1] * Math.cos(d) - e[2] * Math.sin(d), f[2] = e[1] * Math.sin(d) + e[2] * Math.cos(d), a[0] = f[0] + c[0], a[1] = f[1] + c[1], a[2] = f[2] + c[2], a;
      };
      l.rotateY = function(a, b, c, d) {
        var e = [], f = [];
        return e[0] = b[0] - c[0], e[1] = b[1] - c[1], e[2] = b[2] - c[2], f[0] = e[2] * Math.sin(d) + e[0] * Math.cos(d), f[1] = e[1], f[2] = e[2] * Math.cos(d) - e[0] * Math.sin(d), a[0] = f[0] + c[0], a[1] = f[1] + c[1], a[2] = f[2] + c[2], a;
      };
      l.rotateZ = function(a, b, c, d) {
        var e = [], f = [];
        return e[0] = b[0] - c[0], e[1] = b[1] - c[1], e[2] = b[2] - c[2], f[0] = e[0] * Math.cos(d) - e[1] * Math.sin(d), f[1] = e[0] * Math.sin(d) + e[1] * Math.cos(d), f[2] = e[2], a[0] = f[0] + c[0], a[1] = f[1] + c[1], a[2] = f[2] + c[2], a;
      };
      l.forEach = function() {
        var a = l.create();
        return function(b, c, d, e, f, k) {
          c || (c = 3);
          d || (d = 0);
          for (e = e ? Math.min(e * c + d, b.length) : b.length; e > d; d += c) {
            a[0] = b[d], a[1] = b[d + 1], a[2] = b[d + 2], f(a, a, k), b[d] = a[0], b[d + 1] = a[1], b[d + 2] = a[2];
          }
          return b;
        };
      }();
      l.str = function(a) {
        return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
      };
      "undefined" != typeof a && (a.vec3 = l);
      var u = {create:function() {
        var a = new c(4);
        return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 0, a;
      }, clone:function(a) {
        var b = new c(4);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b;
      }, fromValues:function(a, b, d, e) {
        var f = new c(4);
        return f[0] = a, f[1] = b, f[2] = d, f[3] = e, f;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a;
      }, set:function(a, b, c, d, e) {
        return a[0] = b, a[1] = c, a[2] = d, a[3] = e, a;
      }, add:function(a, b, c) {
        return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a[2] = b[2] + c[2], a[3] = b[3] + c[3], a;
      }, subtract:function(a, b, c) {
        return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a[2] = b[2] - c[2], a[3] = b[3] - c[3], a;
      }};
      u.sub = u.subtract;
      u.multiply = function(a, b, c) {
        return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a[2] = b[2] * c[2], a[3] = b[3] * c[3], a;
      };
      u.mul = u.multiply;
      u.divide = function(a, b, c) {
        return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a[2] = b[2] / c[2], a[3] = b[3] / c[3], a;
      };
      u.div = u.divide;
      u.min = function(a, b, c) {
        return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a[2] = Math.min(b[2], c[2]), a[3] = Math.min(b[3], c[3]), a;
      };
      u.max = function(a, b, c) {
        return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a[2] = Math.max(b[2], c[2]), a[3] = Math.max(b[3], c[3]), a;
      };
      u.scale = function(a, b, c) {
        return a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a[3] = b[3] * c, a;
      };
      u.scaleAndAdd = function(a, b, c, d) {
        return a[0] = b[0] + c[0] * d, a[1] = b[1] + c[1] * d, a[2] = b[2] + c[2] * d, a[3] = b[3] + c[3] * d, a;
      };
      u.distance = function(a, b) {
        var c = b[0] - a[0], d = b[1] - a[1], e = b[2] - a[2];
        a = b[3] - a[3];
        return Math.sqrt(c * c + d * d + e * e + a * a);
      };
      u.dist = u.distance;
      u.squaredDistance = function(a, b) {
        var c = b[0] - a[0], d = b[1] - a[1], e = b[2] - a[2];
        a = b[3] - a[3];
        return c * c + d * d + e * e + a * a;
      };
      u.sqrDist = u.squaredDistance;
      u.length = function(a) {
        var b = a[0], c = a[1], d = a[2];
        a = a[3];
        return Math.sqrt(b * b + c * c + d * d + a * a);
      };
      u.len = u.length;
      u.squaredLength = function(a) {
        var b = a[0], c = a[1], d = a[2];
        a = a[3];
        return b * b + c * c + d * d + a * a;
      };
      u.sqrLen = u.squaredLength;
      u.negate = function(a, b) {
        return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a[3] = -b[3], a;
      };
      u.normalize = function(a, b) {
        var c = b[0], d = b[1], e = b[2], f = b[3];
        c = c * c + d * d + e * e + f * f;
        return 0 < c && (c = 1 / Math.sqrt(c), a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a[3] = b[3] * c), a;
      };
      u.dot = function(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
      };
      u.lerp = function(a, b, c, d) {
        var e = b[0], f = b[1], k = b[2];
        b = b[3];
        return a[0] = e + d * (c[0] - e), a[1] = f + d * (c[1] - f), a[2] = k + d * (c[2] - k), a[3] = b + d * (c[3] - b), a;
      };
      u.random = function(a, b) {
        return b = b || 1, a[0] = e(), a[1] = e(), a[2] = e(), a[3] = e(), u.normalize(a, a), u.scale(a, a, b), a;
      };
      u.transformMat4 = function(a, b, c) {
        var d = b[0], e = b[1], f = b[2];
        b = b[3];
        return a[0] = c[0] * d + c[4] * e + c[8] * f + c[12] * b, a[1] = c[1] * d + c[5] * e + c[9] * f + c[13] * b, a[2] = c[2] * d + c[6] * e + c[10] * f + c[14] * b, a[3] = c[3] * d + c[7] * e + c[11] * f + c[15] * b, a;
      };
      u.transformQuat = function(a, b, c) {
        var d = b[0], e = b[1], f = b[2];
        b = c[0];
        var k = c[1], g = c[2];
        c = c[3];
        var l = c * d + k * f - g * e, q = c * e + g * d - b * f, m = c * f + b * e - k * d;
        d = -b * d - k * e - g * f;
        return a[0] = l * c + d * -b + q * -g - m * -k, a[1] = q * c + d * -k + m * -b - l * -g, a[2] = m * c + d * -g + l * -k - q * -b, a;
      };
      u.forEach = function() {
        var a = u.create();
        return function(b, c, d, e, f, k) {
          c || (c = 4);
          d || (d = 0);
          for (e = e ? Math.min(e * c + d, b.length) : b.length; e > d; d += c) {
            a[0] = b[d], a[1] = b[d + 1], a[2] = b[d + 2], a[3] = b[d + 3], f(a, a, k), b[d] = a[0], b[d + 1] = a[1], b[d + 2] = a[2], b[d + 3] = a[3];
          }
          return b;
        };
      }();
      u.str = function(a) {
        return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
      };
      "undefined" != typeof a && (a.vec4 = u);
      f = {create:function() {
        var a = new c(4);
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a;
      }, clone:function(a) {
        var b = new c(4);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a;
      }, identity:function(a) {
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a;
      }, transpose:function(a, b) {
        if (a === b) {
          var c = b[1];
          a[1] = b[2];
          a[2] = c;
        } else {
          a[0] = b[0], a[1] = b[2], a[2] = b[1], a[3] = b[3];
        }
        return a;
      }, invert:function(a, b) {
        var c = b[0], d = b[1], e = b[2];
        b = b[3];
        var f = c * b - e * d;
        return f ? (f = 1 / f, a[0] = b * f, a[1] = -d * f, a[2] = -e * f, a[3] = c * f, a) : null;
      }, adjoint:function(a, b) {
        var c = b[0];
        return a[0] = b[3], a[1] = -b[1], a[2] = -b[2], a[3] = c, a;
      }, determinant:function(a) {
        return a[0] * a[3] - a[2] * a[1];
      }, multiply:function(a, b, c) {
        var d = b[0], e = b[1], f = b[2];
        b = b[3];
        var k = c[0], g = c[1], l = c[2];
        c = c[3];
        return a[0] = d * k + f * g, a[1] = e * k + b * g, a[2] = d * l + f * c, a[3] = e * l + b * c, a;
      }};
      f.mul = f.multiply;
      f.rotate = function(a, b, c) {
        var d = b[0], e = b[1], f = b[2];
        b = b[3];
        var k = Math.sin(c);
        c = Math.cos(c);
        return a[0] = d * c + f * k, a[1] = e * c + b * k, a[2] = d * -k + f * c, a[3] = e * -k + b * c, a;
      };
      f.scale = function(a, b, c) {
        var d = b[1], e = b[2], f = b[3], k = c[0];
        c = c[1];
        return a[0] = b[0] * k, a[1] = d * k, a[2] = e * c, a[3] = f * c, a;
      };
      f.str = function(a) {
        return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
      };
      f.frob = function(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
      };
      f.LDU = function(a, b, c, d) {
        return a[2] = d[2] / d[0], c[0] = d[0], c[1] = d[1], c[3] = d[3] - a[2] * c[1], [a, b, c];
      };
      "undefined" != typeof a && (a.mat2 = f);
      f = {create:function() {
        var a = new c(6);
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a[4] = 0, a[5] = 0, a;
      }, clone:function(a) {
        var b = new c(6);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], a;
      }, identity:function(a) {
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a[4] = 0, a[5] = 0, a;
      }, invert:function(a, b) {
        var c = b[0], d = b[1], e = b[2], f = b[3], k = b[4];
        b = b[5];
        var g = c * f - d * e;
        return g ? (g = 1 / g, a[0] = f * g, a[1] = -d * g, a[2] = -e * g, a[3] = c * g, a[4] = (e * b - f * k) * g, a[5] = (d * k - c * b) * g, a) : null;
      }, determinant:function(a) {
        return a[0] * a[3] - a[1] * a[2];
      }, multiply:function(a, b, c) {
        var d = b[0], e = b[1], f = b[2], k = b[3], g = b[4];
        b = b[5];
        var l = c[0], m = c[1], n = c[2], q = c[3], t = c[4];
        c = c[5];
        return a[0] = d * l + f * m, a[1] = e * l + k * m, a[2] = d * n + f * q, a[3] = e * n + k * q, a[4] = d * t + f * c + g, a[5] = e * t + k * c + b, a;
      }};
      f.mul = f.multiply;
      f.rotate = function(a, b, c) {
        var d = b[0], e = b[1], f = b[2], k = b[3], g = b[4];
        b = b[5];
        var l = Math.sin(c);
        c = Math.cos(c);
        return a[0] = d * c + f * l, a[1] = e * c + k * l, a[2] = d * -l + f * c, a[3] = e * -l + k * c, a[4] = g, a[5] = b, a;
      };
      f.scale = function(a, b, c) {
        var d = b[1], e = b[2], f = b[3], k = b[4], g = b[5], l = c[0];
        c = c[1];
        return a[0] = b[0] * l, a[1] = d * l, a[2] = e * c, a[3] = f * c, a[4] = k, a[5] = g, a;
      };
      f.translate = function(a, b, c) {
        var d = b[0], e = b[1], f = b[2], k = b[3], g = b[4];
        b = b[5];
        var l = c[0];
        c = c[1];
        return a[0] = d, a[1] = e, a[2] = f, a[3] = k, a[4] = d * l + f * c + g, a[5] = e * l + k * c + b, a;
      };
      f.str = function(a) {
        return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
      };
      f.frob = function(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
      };
      "undefined" != typeof a && (a.mat2d = f);
      var w = {create:function() {
        var a = new c(9);
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 1, a[5] = 0, a[6] = 0, a[7] = 0, a[8] = 1, a;
      }, fromMat4:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[4], a[4] = b[5], a[5] = b[6], a[6] = b[8], a[7] = b[9], a[8] = b[10], a;
      }, clone:function(a) {
        var b = new c(9);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], b;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[8] = b[8], a;
      }, identity:function(a) {
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 1, a[5] = 0, a[6] = 0, a[7] = 0, a[8] = 1, a;
      }, transpose:function(a, b) {
        if (a === b) {
          var c = b[1], d = b[2], e = b[5];
          a[1] = b[3];
          a[2] = b[6];
          a[3] = c;
          a[5] = b[7];
          a[6] = d;
          a[7] = e;
        } else {
          a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], a[6] = b[2], a[7] = b[5], a[8] = b[8];
        }
        return a;
      }, invert:function(a, b) {
        var c = b[0], d = b[1], e = b[2], f = b[3], k = b[4], g = b[5], l = b[6], m = b[7];
        b = b[8];
        var n = b * k - g * m, q = -b * f + g * l, t = m * f - k * l, u = c * n + d * q + e * t;
        return u ? (u = 1 / u, a[0] = n * u, a[1] = (-b * d + e * m) * u, a[2] = (g * d - e * k) * u, a[3] = q * u, a[4] = (b * c - e * l) * u, a[5] = (-g * c + e * f) * u, a[6] = t * u, a[7] = (-m * c + d * l) * u, a[8] = (k * c - d * f) * u, a) : null;
      }, adjoint:function(a, b) {
        var c = b[0], d = b[1], e = b[2], f = b[3], k = b[4], g = b[5], l = b[6], m = b[7];
        b = b[8];
        return a[0] = k * b - g * m, a[1] = e * m - d * b, a[2] = d * g - e * k, a[3] = g * l - f * b, a[4] = c * b - e * l, a[5] = e * f - c * g, a[6] = f * m - k * l, a[7] = d * l - c * m, a[8] = c * k - d * f, a;
      }, determinant:function(a) {
        var b = a[3], c = a[4], d = a[5], e = a[6], f = a[7], k = a[8];
        return a[0] * (k * c - d * f) + a[1] * (-k * b + d * e) + a[2] * (f * b - c * e);
      }, multiply:function(a, b, c) {
        var d = b[0], e = b[1], f = b[2], k = b[3], g = b[4], l = b[5], m = b[6], n = b[7];
        b = b[8];
        var q = c[0], t = c[1], u = c[2], p = c[3], v = c[4], w = c[5], y = c[6], z = c[7];
        c = c[8];
        return a[0] = q * d + t * k + u * m, a[1] = q * e + t * g + u * n, a[2] = q * f + t * l + u * b, a[3] = p * d + v * k + w * m, a[4] = p * e + v * g + w * n, a[5] = p * f + v * l + w * b, a[6] = y * d + z * k + c * m, a[7] = y * e + z * g + c * n, a[8] = y * f + z * l + c * b, a;
      }};
      w.mul = w.multiply;
      w.translate = function(a, b, c) {
        var d = b[0], e = b[1], f = b[2], k = b[3], g = b[4], l = b[5], m = b[6], n = b[7];
        b = b[8];
        var q = c[0];
        c = c[1];
        return a[0] = d, a[1] = e, a[2] = f, a[3] = k, a[4] = g, a[5] = l, a[6] = q * d + c * k + m, a[7] = q * e + c * g + n, a[8] = q * f + c * l + b, a;
      };
      w.rotate = function(a, b, c) {
        var d = b[0], e = b[1], f = b[2], k = b[3], g = b[4], l = b[5], m = b[6], n = b[7];
        b = b[8];
        var q = Math.sin(c);
        c = Math.cos(c);
        return a[0] = c * d + q * k, a[1] = c * e + q * g, a[2] = c * f + q * l, a[3] = c * k - q * d, a[4] = c * g - q * e, a[5] = c * l - q * f, a[6] = m, a[7] = n, a[8] = b, a;
      };
      w.scale = function(a, b, c) {
        var d = c[0];
        c = c[1];
        return a[0] = d * b[0], a[1] = d * b[1], a[2] = d * b[2], a[3] = c * b[3], a[4] = c * b[4], a[5] = c * b[5], a[6] = b[6], a[7] = b[7], a[8] = b[8], a;
      };
      w.fromMat2d = function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = 0, a[3] = b[2], a[4] = b[3], a[5] = 0, a[6] = b[4], a[7] = b[5], a[8] = 1, a;
      };
      w.fromQuat = function(a, b) {
        var c = b[0], d = b[1], e = b[2];
        b = b[3];
        var f = c + c, k = d + d, g = e + e;
        c *= f;
        var l = d * f;
        d *= k;
        var m = e * f, n = e * k;
        e *= g;
        f *= b;
        k *= b;
        b *= g;
        return a[0] = 1 - d - e, a[3] = l - b, a[6] = m + k, a[1] = l + b, a[4] = 1 - c - e, a[7] = n - f, a[2] = m - k, a[5] = n + f, a[8] = 1 - c - d, a;
      };
      w.normalFromMat4 = function(a, b) {
        var c = b[0], d = b[1], e = b[2], f = b[3], k = b[4], g = b[5], l = b[6], m = b[7], n = b[8], q = b[9], t = b[10], u = b[11], p = b[12], v = b[13], w = b[14];
        b = b[15];
        var y = c * g - d * k, x = c * l - e * k, S = c * m - f * k, V = d * l - e * g, M = d * m - f * g, O = e * m - f * l, P = n * v - q * p, ka = n * w - t * p;
        n = n * b - u * p;
        var ha = q * w - t * v;
        q = q * b - u * v;
        t = t * b - u * w;
        return (u = y * t - x * q + S * ha + V * n - M * ka + O * P) ? (u = 1 / u, a[0] = (g * t - l * q + m * ha) * u, a[1] = (l * n - k * t - m * ka) * u, a[2] = (k * q - g * n + m * P) * u, a[3] = (e * q - d * t - f * ha) * u, a[4] = (c * t - e * n + f * ka) * u, a[5] = (d * n - c * q - f * P) * u, a[6] = (v * O - w * M + b * V) * u, a[7] = (w * S - p * O - b * x) * u, a[8] = (p * M - v * S + b * y) * u, a) : null;
      };
      w.str = function(a) {
        return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
      };
      w.frob = function(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
      };
      "undefined" != typeof a && (a.mat3 = w);
      var y = {create:function() {
        var a = new c(16);
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
      }, clone:function(a) {
        var b = new c(16);
        return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], b[9] = a[9], b[10] = a[10], b[11] = a[11], b[12] = a[12], b[13] = a[13], b[14] = a[14], b[15] = a[15], b;
      }, copy:function(a, b) {
        return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[8] = b[8], a[9] = b[9], a[10] = b[10], a[11] = b[11], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15], a;
      }, identity:function(a) {
        return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
      }, transpose:function(a, b) {
        if (a === b) {
          var c = b[1], d = b[2], e = b[3], f = b[6], k = b[7], g = b[11];
          a[1] = b[4];
          a[2] = b[8];
          a[3] = b[12];
          a[4] = c;
          a[6] = b[9];
          a[7] = b[13];
          a[8] = d;
          a[9] = f;
          a[11] = b[14];
          a[12] = e;
          a[13] = k;
          a[14] = g;
        } else {
          a[0] = b[0], a[1] = b[4], a[2] = b[8], a[3] = b[12], a[4] = b[1], a[5] = b[5], a[6] = b[9], a[7] = b[13], a[8] = b[2], a[9] = b[6], a[10] = b[10], a[11] = b[14], a[12] = b[3], a[13] = b[7], a[14] = b[11], a[15] = b[15];
        }
        return a;
      }, invert:function(a, b) {
        var c = b[0], d = b[1], e = b[2], f = b[3], k = b[4], g = b[5], l = b[6], m = b[7], n = b[8], t = b[9], q = b[10], u = b[11], p = b[12], v = b[13], w = b[14];
        b = b[15];
        var y = c * g - d * k, x = c * l - e * k, S = c * m - f * k, V = d * l - e * g, M = d * m - f * g, O = e * m - f * l, P = n * v - t * p, ka = n * w - q * p, ha = n * b - u * p, ja = t * w - q * v, X = t * b - u * v, fa = q * b - u * w, ba = y * fa - x * X + S * ja + V * ha - M * ka + O * P;
        return ba ? (ba = 1 / ba, a[0] = (g * fa - l * X + m * ja) * ba, a[1] = (e * X - d * fa - f * ja) * ba, a[2] = (v * O - w * M + b * V) * ba, a[3] = (q * M - t * O - u * V) * ba, a[4] = (l * ha - k * fa - m * ka) * ba, a[5] = (c * fa - e * ha + f * ka) * ba, a[6] = (w * S - p * O - b * x) * ba, a[7] = (n * O - q * S + u * x) * ba, a[8] = (k * X - g * ha + m * P) * ba, a[9] = (d * ha - c * X - f * P) * ba, a[10] = (p * M - v * S + b * y) * ba, a[11] = (t * S - n * M - u * y) * ba, a[12] = (g * 
        ka - k * ja - l * P) * ba, a[13] = (c * ja - d * ka + e * P) * ba, a[14] = (v * x - p * V - w * y) * ba, a[15] = (n * V - t * x + q * y) * ba, a) : null;
      }, adjoint:function(a, b) {
        var c = b[0], d = b[1], e = b[2], f = b[3], k = b[4], g = b[5], l = b[6], m = b[7], n = b[8], t = b[9], q = b[10], u = b[11], p = b[12], v = b[13], w = b[14];
        b = b[15];
        return a[0] = g * (q * b - u * w) - t * (l * b - m * w) + v * (l * u - m * q), a[1] = -(d * (q * b - u * w) - t * (e * b - f * w) + v * (e * u - f * q)), a[2] = d * (l * b - m * w) - g * (e * b - f * w) + v * (e * m - f * l), a[3] = -(d * (l * u - m * q) - g * (e * u - f * q) + t * (e * m - f * l)), a[4] = -(k * (q * b - u * w) - n * (l * b - m * w) + p * (l * u - m * q)), a[5] = c * (q * b - u * w) - n * (e * b - f * w) + p * (e * u - f * q), a[6] = -(c * (l * b - m * w) - k * (e * b - f * 
        w) + p * (e * m - f * l)), a[7] = c * (l * u - m * q) - k * (e * u - f * q) + n * (e * m - f * l), a[8] = k * (t * b - u * v) - n * (g * b - m * v) + p * (g * u - m * t), a[9] = -(c * (t * b - u * v) - n * (d * b - f * v) + p * (d * u - f * t)), a[10] = c * (g * b - m * v) - k * (d * b - f * v) + p * (d * m - f * g), a[11] = -(c * (g * u - m * t) - k * (d * u - f * t) + n * (d * m - f * g)), a[12] = -(k * (t * w - q * v) - n * (g * w - l * v) + p * (g * q - l * t)), a[13] = c * (t * w - q * 
        v) - n * (d * w - e * v) + p * (d * q - e * t), a[14] = -(c * (g * w - l * v) - k * (d * w - e * v) + p * (d * l - e * g)), a[15] = c * (g * q - l * t) - k * (d * q - e * t) + n * (d * l - e * g), a;
      }, determinant:function(a) {
        var b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], k = a[5], g = a[6], l = a[7], m = a[8], n = a[9], t = a[10], q = a[11], u = a[12], p = a[13], w = a[14];
        a = a[15];
        return (b * k - c * f) * (t * a - q * w) - (b * g - d * f) * (n * a - q * p) + (b * l - e * f) * (n * w - t * p) + (c * g - d * k) * (m * a - q * u) - (c * l - e * k) * (m * w - t * u) + (d * l - e * g) * (m * p - n * u);
      }, multiply:function(a, b, c) {
        var d = b[0], e = b[1], f = b[2], k = b[3], g = b[4], l = b[5], m = b[6], n = b[7], t = b[8], q = b[9], u = b[10], p = b[11], v = b[12], w = b[13], y = b[14];
        b = b[15];
        var x = c[0], z = c[1], V = c[2], M = c[3];
        return a[0] = x * d + z * g + V * t + M * v, a[1] = x * e + z * l + V * q + M * w, a[2] = x * f + z * m + V * u + M * y, a[3] = x * k + z * n + V * p + M * b, x = c[4], z = c[5], V = c[6], M = c[7], a[4] = x * d + z * g + V * t + M * v, a[5] = x * e + z * l + V * q + M * w, a[6] = x * f + z * m + V * u + M * y, a[7] = x * k + z * n + V * p + M * b, x = c[8], z = c[9], V = c[10], M = c[11], a[8] = x * d + z * g + V * t + M * v, a[9] = x * e + z * l + V * q + M * w, a[10] = x * f + z * m + 
        V * u + M * y, a[11] = x * k + z * n + V * p + M * b, x = c[12], z = c[13], V = c[14], M = c[15], a[12] = x * d + z * g + V * t + M * v, a[13] = x * e + z * l + V * q + M * w, a[14] = x * f + z * m + V * u + M * y, a[15] = x * k + z * n + V * p + M * b, a;
      }};
      y.mul = y.multiply;
      y.translate = function(a, b, c) {
        var d, e, f, k, g, l, m, n, t, q, u, p, v = c[0], w = c[1];
        c = c[2];
        return b === a ? (a[12] = b[0] * v + b[4] * w + b[8] * c + b[12], a[13] = b[1] * v + b[5] * w + b[9] * c + b[13], a[14] = b[2] * v + b[6] * w + b[10] * c + b[14], a[15] = b[3] * v + b[7] * w + b[11] * c + b[15]) : (d = b[0], e = b[1], f = b[2], k = b[3], g = b[4], l = b[5], m = b[6], n = b[7], t = b[8], q = b[9], u = b[10], p = b[11], a[0] = d, a[1] = e, a[2] = f, a[3] = k, a[4] = g, a[5] = l, a[6] = m, a[7] = n, a[8] = t, a[9] = q, a[10] = u, a[11] = p, a[12] = d * v + g * w + t * c + b[12], 
        a[13] = e * v + l * w + q * c + b[13], a[14] = f * v + m * w + u * c + b[14], a[15] = k * v + n * w + p * c + b[15]), a;
      };
      y.scale = function(a, b, c) {
        var d = c[0], e = c[1];
        c = c[2];
        return a[0] = b[0] * d, a[1] = b[1] * d, a[2] = b[2] * d, a[3] = b[3] * d, a[4] = b[4] * e, a[5] = b[5] * e, a[6] = b[6] * e, a[7] = b[7] * e, a[8] = b[8] * c, a[9] = b[9] * c, a[10] = b[10] * c, a[11] = b[11] * c, a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15], a;
      };
      y.rotate = function(a, c, d, e) {
        var f, k, g, l, m, n, t, q, u, p, v, w, y, x, z, C, V, M, O, P, ka, ha, ja, X, fa = e[0], ba = e[1];
        e = e[2];
        var la = Math.sqrt(fa * fa + ba * ba + e * e);
        return Math.abs(la) < b ? null : (la = 1 / la, fa *= la, ba *= la, e *= la, f = Math.sin(d), k = Math.cos(d), g = 1 - k, l = c[0], m = c[1], n = c[2], t = c[3], q = c[4], u = c[5], p = c[6], v = c[7], w = c[8], y = c[9], x = c[10], z = c[11], C = fa * fa * g + k, V = ba * fa * g + e * f, M = e * fa * g - ba * f, O = fa * ba * g - e * f, P = ba * ba * g + k, ka = e * ba * g + fa * f, ha = fa * e * g + ba * f, ja = ba * e * g - fa * f, X = e * e * g + k, a[0] = l * C + q * V + w * M, a[1] = 
        m * C + u * V + y * M, a[2] = n * C + p * V + x * M, a[3] = t * C + v * V + z * M, a[4] = l * O + q * P + w * ka, a[5] = m * O + u * P + y * ka, a[6] = n * O + p * P + x * ka, a[7] = t * O + v * P + z * ka, a[8] = l * ha + q * ja + w * X, a[9] = m * ha + u * ja + y * X, a[10] = n * ha + p * ja + x * X, a[11] = t * ha + v * ja + z * X, c !== a && (a[12] = c[12], a[13] = c[13], a[14] = c[14], a[15] = c[15]), a);
      };
      y.rotateX = function(a, b, c) {
        var d = Math.sin(c);
        c = Math.cos(c);
        var e = b[4], f = b[5], k = b[6], g = b[7], l = b[8], m = b[9], n = b[10], t = b[11];
        return b !== a && (a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[4] = e * c + l * d, a[5] = f * c + m * d, a[6] = k * c + n * d, a[7] = g * c + t * d, a[8] = l * c - e * d, a[9] = m * c - f * d, a[10] = n * c - k * d, a[11] = t * c - g * d, a;
      };
      y.rotateY = function(a, b, c) {
        var d = Math.sin(c);
        c = Math.cos(c);
        var e = b[0], f = b[1], k = b[2], g = b[3], l = b[8], m = b[9], n = b[10], t = b[11];
        return b !== a && (a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[0] = e * c - l * d, a[1] = f * c - m * d, a[2] = k * c - n * d, a[3] = g * c - t * d, a[8] = e * d + l * c, a[9] = f * d + m * c, a[10] = k * d + n * c, a[11] = g * d + t * c, a;
      };
      y.rotateZ = function(a, b, c) {
        var d = Math.sin(c);
        c = Math.cos(c);
        var e = b[0], f = b[1], k = b[2], g = b[3], l = b[4], m = b[5], n = b[6], t = b[7];
        return b !== a && (a[8] = b[8], a[9] = b[9], a[10] = b[10], a[11] = b[11], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[0] = e * c + l * d, a[1] = f * c + m * d, a[2] = k * c + n * d, a[3] = g * c + t * d, a[4] = l * c - e * d, a[5] = m * c - f * d, a[6] = n * c - k * d, a[7] = t * c - g * d, a;
      };
      y.fromRotationTranslation = function(a, b, c) {
        var d = b[0], e = b[1], f = b[2], k = b[3], g = d + d, l = e + e, m = f + f;
        b = d * g;
        var n = d * l;
        d *= m;
        var t = e * l;
        e *= m;
        f *= m;
        g *= k;
        l *= k;
        k *= m;
        return a[0] = 1 - (t + f), a[1] = n + k, a[2] = d - l, a[3] = 0, a[4] = n - k, a[5] = 1 - (b + f), a[6] = e + g, a[7] = 0, a[8] = d + l, a[9] = e - g, a[10] = 1 - (b + t), a[11] = 0, a[12] = c[0], a[13] = c[1], a[14] = c[2], a[15] = 1, a;
      };
      y.fromQuat = function(a, b) {
        var c = b[0], d = b[1], e = b[2];
        b = b[3];
        var f = c + c, k = d + d, g = e + e;
        c *= f;
        var l = d * f;
        d *= k;
        var m = e * f, n = e * k;
        e *= g;
        f *= b;
        k *= b;
        b *= g;
        return a[0] = 1 - d - e, a[1] = l + b, a[2] = m - k, a[3] = 0, a[4] = l - b, a[5] = 1 - c - e, a[6] = n + f, a[7] = 0, a[8] = m + k, a[9] = n - f, a[10] = 1 - c - d, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
      };
      y.frustum = function(a, b, c, d, e, f, k) {
        var g = 1 / (c - b), l = 1 / (e - d), m = 1 / (f - k);
        return a[0] = 2 * f * g, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 * f * l, a[6] = 0, a[7] = 0, a[8] = (c + b) * g, a[9] = (e + d) * l, a[10] = (k + f) * m, a[11] = -1, a[12] = 0, a[13] = 0, a[14] = k * f * 2 * m, a[15] = 0, a;
      };
      y.perspective = function(a, b, c, d, e) {
        b = 1 / Math.tan(b / 2);
        var f = 1 / (d - e);
        return a[0] = b / c, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = b, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = (e + d) * f, a[11] = -1, a[12] = 0, a[13] = 0, a[14] = 2 * e * d * f, a[15] = 0, a;
      };
      y.ortho = function(a, b, c, d, e, f, k) {
        var g = 1 / (b - c), l = 1 / (d - e), m = 1 / (f - k);
        return a[0] = -2 * g, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = -2 * l, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 2 * m, a[11] = 0, a[12] = (b + c) * g, a[13] = (e + d) * l, a[14] = (k + f) * m, a[15] = 1, a;
      };
      y.lookAt = function(a, c, d, e) {
        var f, k, g, l, m, n, t, u, p, q, w = c[0], v = c[1];
        c = c[2];
        var x = e[0], z = e[1];
        e = e[2];
        var C = d[0], S = d[1];
        d = d[2];
        return Math.abs(w - C) < b && Math.abs(v - S) < b && Math.abs(c - d) < b ? y.identity(a) : (t = w - C, u = v - S, p = c - d, q = 1 / Math.sqrt(t * t + u * u + p * p), t *= q, u *= q, p *= q, f = z * p - e * u, k = e * t - x * p, g = x * u - z * t, q = Math.sqrt(f * f + k * k + g * g), q ? (q = 1 / q, f *= q, k *= q, g *= q) : (f = 0, k = 0, g = 0), l = u * g - p * k, m = p * f - t * g, n = t * k - u * f, q = Math.sqrt(l * l + m * m + n * n), q ? (q = 1 / q, l *= q, m *= q, n *= q) : (l = 
        0, m = 0, n = 0), a[0] = f, a[1] = l, a[2] = t, a[3] = 0, a[4] = k, a[5] = m, a[6] = u, a[7] = 0, a[8] = g, a[9] = n, a[10] = p, a[11] = 0, a[12] = -(f * w + k * v + g * c), a[13] = -(l * w + m * v + n * c), a[14] = -(t * w + u * v + p * c), a[15] = 1, a);
      };
      y.str = function(a) {
        return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
      };
      y.frob = function(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
      };
      "undefined" != typeof a && (a.mat4 = y);
      var x = {create:function() {
        var a = new c(4);
        return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a;
      }};
      x.rotationTo = function() {
        var a = l.create(), b = l.fromValues(1, 0, 0), c = l.fromValues(0, 1, 0);
        return function(d, e, f) {
          var k = l.dot(e, f);
          return -.999999 > k ? (l.cross(a, b, e), 1E-6 > l.length(a) && l.cross(a, c, e), l.normalize(a, a), x.setAxisAngle(d, a, Math.PI), d) : .999999 < k ? (d[0] = 0, d[1] = 0, d[2] = 0, d[3] = 1, d) : (l.cross(a, e, f), d[0] = a[0], d[1] = a[1], d[2] = a[2], d[3] = 1 + k, x.normalize(d, d));
        };
      }();
      x.setAxes = function() {
        var a = w.create();
        return function(b, c, d, e) {
          return a[0] = d[0], a[3] = d[1], a[6] = d[2], a[1] = e[0], a[4] = e[1], a[7] = e[2], a[2] = -c[0], a[5] = -c[1], a[8] = -c[2], x.normalize(b, x.fromMat3(b, a));
        };
      }();
      x.clone = u.clone;
      x.fromValues = u.fromValues;
      x.copy = u.copy;
      x.set = u.set;
      x.identity = function(a) {
        return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a;
      };
      x.setAxisAngle = function(a, b, c) {
        c *= .5;
        var d = Math.sin(c);
        return a[0] = d * b[0], a[1] = d * b[1], a[2] = d * b[2], a[3] = Math.cos(c), a;
      };
      x.add = u.add;
      x.multiply = function(a, b, c) {
        var d = b[0], e = b[1], f = b[2];
        b = b[3];
        var k = c[0], g = c[1], l = c[2];
        c = c[3];
        return a[0] = d * c + b * k + e * l - f * g, a[1] = e * c + b * g + f * k - d * l, a[2] = f * c + b * l + d * g - e * k, a[3] = b * c - d * k - e * g - f * l, a;
      };
      x.mul = x.multiply;
      x.scale = u.scale;
      x.rotateX = function(a, b, c) {
        c *= .5;
        var d = b[0], e = b[1], f = b[2];
        b = b[3];
        var k = Math.sin(c);
        c = Math.cos(c);
        return a[0] = d * c + b * k, a[1] = e * c + f * k, a[2] = f * c - e * k, a[3] = b * c - d * k, a;
      };
      x.rotateY = function(a, b, c) {
        c *= .5;
        var d = b[0], e = b[1], f = b[2];
        b = b[3];
        var k = Math.sin(c);
        c = Math.cos(c);
        return a[0] = d * c - f * k, a[1] = e * c + b * k, a[2] = f * c + d * k, a[3] = b * c - e * k, a;
      };
      x.rotateZ = function(a, b, c) {
        c *= .5;
        var d = b[0], e = b[1], f = b[2];
        b = b[3];
        var k = Math.sin(c);
        c = Math.cos(c);
        return a[0] = d * c + e * k, a[1] = e * c - d * k, a[2] = f * c + b * k, a[3] = b * c - f * k, a;
      };
      x.calculateW = function(a, b) {
        var c = b[0], d = b[1];
        b = b[2];
        return a[0] = c, a[1] = d, a[2] = b, a[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - b * b)), a;
      };
      x.dot = u.dot;
      x.lerp = u.lerp;
      x.slerp = function(a, b, c, d) {
        var e, f, k, g, l, m = b[0], n = b[1], t = b[2];
        b = b[3];
        var u = c[0], p = c[1], q = c[2];
        c = c[3];
        return f = m * u + n * p + t * q + b * c, 0 > f && (f = -f, u = -u, p = -p, q = -q, c = -c), 1E-6 < 1 - f ? (e = Math.acos(f), k = Math.sin(e), g = Math.sin((1 - d) * e) / k, l = Math.sin(d * e) / k) : (g = 1 - d, l = d), a[0] = g * m + l * u, a[1] = g * n + l * p, a[2] = g * t + l * q, a[3] = g * b + l * c, a;
      };
      x.invert = function(a, b) {
        var c = b[0], d = b[1], e = b[2];
        b = b[3];
        var f = c * c + d * d + e * e + b * b;
        f = f ? 1 / f : 0;
        return a[0] = -c * f, a[1] = -d * f, a[2] = -e * f, a[3] = b * f, a;
      };
      x.conjugate = function(a, b) {
        return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a[3] = b[3], a;
      };
      x.length = u.length;
      x.len = x.length;
      x.squaredLength = u.squaredLength;
      x.sqrLen = x.squaredLength;
      x.normalize = u.normalize;
      x.fromMat3 = function(a, b) {
        var c = b[0] + b[4] + b[8];
        if (0 < c) {
          c = Math.sqrt(c + 1), a[3] = .5 * c, c = .5 / c, a[0] = (b[7] - b[5]) * c, a[1] = (b[2] - b[6]) * c, a[2] = (b[3] - b[1]) * c;
        } else {
          var d = 0;
          b[4] > b[0] && (d = 1);
          b[8] > b[3 * d + d] && (d = 2);
          var e = (d + 1) % 3, f = (d + 2) % 3;
          c = Math.sqrt(b[3 * d + d] - b[3 * e + e] - b[3 * f + f] + 1);
          a[d] = .5 * c;
          c = .5 / c;
          a[3] = (b[3 * f + e] - b[3 * e + f]) * c;
          a[e] = (b[3 * e + d] + b[3 * d + e]) * c;
          a[f] = (b[3 * f + d] + b[3 * d + f]) * c;
        }
        return a;
      };
      x.str = function(a) {
        return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
      };
      "undefined" != typeof a && (a.quat = x);
    })(b);
  }(this);
}, {}], 24:[function(a, c, g) {
  (function() {
    var a = this, e = a._, f = {}, k = Array.prototype, n = Object.prototype, p = k.push, m = k.slice, t = k.concat, d = n.toString, l = n.hasOwnProperty, u = k.forEach, w = k.map, y = k.reduce, x = k.reduceRight, q = k.filter, v = k.every, z = k.some, C = k.indexOf, A = k.lastIndexOf;
    n = Array.isArray;
    var D = Object.keys, E = Function.prototype.bind, B = function(a) {
      return a instanceof B ? a : this instanceof B ? void(this._wrapped = a) : new B(a);
    };
    "undefined" != typeof g ? ("undefined" != typeof c && c.exports && (g = c.exports = B), g._ = B) : a._ = B;
    B.VERSION = "1.4.4";
    var G = B.each = B.forEach = function(a, b, c) {
      if (null != a) {
        if (u && a.forEach === u) {
          a.forEach(b, c);
        } else {
          if (a.length === +a.length) {
            for (var d = 0, e = a.length; e > d && b.call(c, a[d], d, a) !== f; d++) {
            }
          } else {
            for (d in a) {
              if (B.has(a, d) && b.call(c, a[d], d, a) === f) {
                break;
              }
            }
          }
        }
      }
    };
    B.map = B.collect = function(a, b, c) {
      var d = [];
      return null == a ? d : w && a.map === w ? a.map(b, c) : (G(a, function(a, e, f) {
        d[d.length] = b.call(c, a, e, f);
      }), d);
    };
    B.reduce = B.foldl = B.inject = function(a, b, c, d) {
      var e = 2 < arguments.length;
      if (null == a && (a = []), y && a.reduce === y) {
        return d && (b = B.bind(b, d)), e ? a.reduce(b, c) : a.reduce(b);
      }
      if (G(a, function(a, f, k) {
        e ? c = b.call(d, c, a, f, k) : (c = a, e = !0);
      }), !e) {
        throw new TypeError("Reduce of empty array with no initial value");
      }
      return c;
    };
    B.reduceRight = B.foldr = function(a, b, c, d) {
      var e = 2 < arguments.length;
      if (null == a && (a = []), x && a.reduceRight === x) {
        return d && (b = B.bind(b, d)), e ? a.reduceRight(b, c) : a.reduceRight(b);
      }
      var f = a.length;
      if (f !== +f) {
        var k = B.keys(a);
        f = k.length;
      }
      if (G(a, function(g, l, m) {
        l = k ? k[--f] : --f;
        e ? c = b.call(d, c, a[l], l, m) : (c = a[l], e = !0);
      }), !e) {
        throw new TypeError("Reduce of empty array with no initial value");
      }
      return c;
    };
    B.find = B.detect = function(a, b, c) {
      var d;
      return H(a, function(a, e, f) {
        return b.call(c, a, e, f) ? (d = a, !0) : void 0;
      }), d;
    };
    B.filter = B.select = function(a, b, c) {
      var d = [];
      return null == a ? d : q && a.filter === q ? a.filter(b, c) : (G(a, function(a, e, f) {
        b.call(c, a, e, f) && (d[d.length] = a);
      }), d);
    };
    B.reject = function(a, b, c) {
      return B.filter(a, function(a, d, e) {
        return !b.call(c, a, d, e);
      }, c);
    };
    B.every = B.all = function(a, b, c) {
      b || (b = B.identity);
      var d = !0;
      return null == a ? d : v && a.every === v ? a.every(b, c) : (G(a, function(a, e, k) {
        return (d = d && b.call(c, a, e, k)) ? void 0 : f;
      }), !!d);
    };
    var H = B.some = B.any = function(a, b, c) {
      b || (b = B.identity);
      var d = !1;
      return null == a ? d : z && a.some === z ? a.some(b, c) : (G(a, function(a, e, k) {
        return d || (d = b.call(c, a, e, k)) ? f : void 0;
      }), !!d);
    };
    B.contains = B.include = function(a, b) {
      return null == a ? !1 : C && a.indexOf === C ? -1 != a.indexOf(b) : H(a, function(a) {
        return a === b;
      });
    };
    B.invoke = function(a, b) {
      var c = m.call(arguments, 2), d = B.isFunction(b);
      return B.map(a, function(a) {
        return (d ? b : a[b]).apply(a, c);
      });
    };
    B.pluck = function(a, b) {
      return B.map(a, function(a) {
        return a[b];
      });
    };
    B.where = function(a, b, c) {
      return B.isEmpty(b) ? c ? null : [] : B[c ? "find" : "filter"](a, function(a) {
        for (var c in b) {
          if (b[c] !== a[c]) {
            return !1;
          }
        }
        return !0;
      });
    };
    B.findWhere = function(a, b) {
      return B.where(a, b, !0);
    };
    B.max = function(a, b, c) {
      if (!b && B.isArray(a) && a[0] === +a[0] && 65535 > a.length) {
        return Math.max.apply(Math, a);
      }
      if (!b && B.isEmpty(a)) {
        return -1 / 0;
      }
      var d = {computed:-1 / 0, value:-1 / 0};
      return G(a, function(a, e, f) {
        e = b ? b.call(c, a, e, f) : a;
        e >= d.computed && (d = {value:a, computed:e});
      }), d.value;
    };
    B.min = function(a, b, c) {
      if (!b && B.isArray(a) && a[0] === +a[0] && 65535 > a.length) {
        return Math.min.apply(Math, a);
      }
      if (!b && B.isEmpty(a)) {
        return 1 / 0;
      }
      var d = {computed:1 / 0, value:1 / 0};
      return G(a, function(a, e, f) {
        e = b ? b.call(c, a, e, f) : a;
        e < d.computed && (d = {value:a, computed:e});
      }), d.value;
    };
    B.shuffle = function(a) {
      var b, c = 0, d = [];
      return G(a, function(a) {
        b = B.random(c++);
        d[c - 1] = d[b];
        d[b] = a;
      }), d;
    };
    var K = function(a) {
      return B.isFunction(a) ? a : function(b) {
        return b[a];
      };
    };
    B.sortBy = function(a, b, c) {
      var d = K(b);
      return B.pluck(B.map(a, function(a, b, e) {
        return {value:a, index:b, criteria:d.call(c, a, b, e)};
      }).sort(function(a, b) {
        var c = a.criteria, d = b.criteria;
        if (c !== d) {
          if (c > d || void 0 === c) {
            return 1;
          }
          if (d > c || void 0 === d) {
            return -1;
          }
        }
        return a.index < b.index ? -1 : 1;
      }), "value");
    };
    var I = function(a, b, c, d) {
      var e = {}, f = K(b || B.identity);
      return G(a, function(b, k) {
        k = f.call(c, b, k, a);
        d(e, k, b);
      }), e;
    };
    B.groupBy = function(a, b, c) {
      return I(a, b, c, function(a, b, c) {
        (B.has(a, b) ? a[b] : a[b] = []).push(c);
      });
    };
    B.countBy = function(a, b, c) {
      return I(a, b, c, function(a, b) {
        B.has(a, b) || (a[b] = 0);
        a[b]++;
      });
    };
    B.sortedIndex = function(a, b, c, d) {
      c = null == c ? B.identity : K(c);
      b = c.call(d, b);
      for (var e = 0, f = a.length; f > e;) {
        var k = e + f >>> 1;
        c.call(d, a[k]) < b ? e = k + 1 : f = k;
      }
      return e;
    };
    B.toArray = function(a) {
      return a ? B.isArray(a) ? m.call(a) : a.length === +a.length ? B.map(a, B.identity) : B.values(a) : [];
    };
    B.size = function(a) {
      return null == a ? 0 : a.length === +a.length ? a.length : B.keys(a).length;
    };
    B.first = B.head = B.take = function(a, b, c) {
      return null == a ? void 0 : null == b || c ? a[0] : m.call(a, 0, b);
    };
    B.initial = function(a, b, c) {
      return m.call(a, 0, a.length - (null == b || c ? 1 : b));
    };
    B.last = function(a, b, c) {
      return null == a ? void 0 : null == b || c ? a[a.length - 1] : m.call(a, Math.max(a.length - b, 0));
    };
    B.rest = B.tail = B.drop = function(a, b, c) {
      return m.call(a, null == b || c ? 1 : b);
    };
    B.compact = function(a) {
      return B.filter(a, B.identity);
    };
    var L = function(a, b, c) {
      return G(a, function(a) {
        B.isArray(a) ? b ? p.apply(c, a) : L(a, b, c) : c.push(a);
      }), c;
    };
    B.flatten = function(a, b) {
      return L(a, b, []);
    };
    B.without = function(a) {
      return B.difference(a, m.call(arguments, 1));
    };
    B.uniq = B.unique = function(a, b, c, d) {
      B.isFunction(b) && (d = c, c = b, b = !1);
      c = c ? B.map(a, c, d) : a;
      var e = [], f = [];
      return G(c, function(c, d) {
        (b ? d && f[f.length - 1] === c : B.contains(f, c)) || (f.push(c), e.push(a[d]));
      }), e;
    };
    B.union = function() {
      return B.uniq(t.apply(k, arguments));
    };
    B.intersection = function(a) {
      var b = m.call(arguments, 1);
      return B.filter(B.uniq(a), function(a) {
        return B.every(b, function(b) {
          return 0 <= B.indexOf(b, a);
        });
      });
    };
    B.difference = function(a) {
      var b = t.apply(k, m.call(arguments, 1));
      return B.filter(a, function(a) {
        return !B.contains(b, a);
      });
    };
    B.zip = function() {
      for (var a = m.call(arguments), b = B.max(B.pluck(a, "length")), c = Array(b), d = 0; b > d; d++) {
        c[d] = B.pluck(a, "" + d);
      }
      return c;
    };
    B.object = function(a, b) {
      if (null == a) {
        return {};
      }
      for (var c = {}, d = 0, e = a.length; e > d; d++) {
        b ? c[a[d]] = b[d] : c[a[d][0]] = a[d][1];
      }
      return c;
    };
    B.indexOf = function(a, b, c) {
      if (null == a) {
        return -1;
      }
      var d = 0, e = a.length;
      if (c) {
        if ("number" != typeof c) {
          return d = B.sortedIndex(a, b), a[d] === b ? d : -1;
        }
        d = 0 > c ? Math.max(0, e + c) : c;
      }
      if (C && a.indexOf === C) {
        return a.indexOf(b, c);
      }
      for (; e > d; d++) {
        if (a[d] === b) {
          return d;
        }
      }
      return -1;
    };
    B.lastIndexOf = function(a, b, c) {
      if (null == a) {
        return -1;
      }
      var d = null != c;
      if (A && a.lastIndexOf === A) {
        return d ? a.lastIndexOf(b, c) : a.lastIndexOf(b);
      }
      for (c = d ? c : a.length; c--;) {
        if (a[c] === b) {
          return c;
        }
      }
      return -1;
    };
    B.range = function(a, b, c) {
      1 >= arguments.length && (b = a || 0, a = 0);
      c = arguments[2] || 1;
      for (var d = Math.max(Math.ceil((b - a) / c), 0), e = 0, f = Array(d); d > e;) {
        f[e++] = a, a += c;
      }
      return f;
    };
    B.bind = function(a, b) {
      if (a.bind === E && E) {
        return E.apply(a, m.call(arguments, 1));
      }
      var c = m.call(arguments, 2);
      return function() {
        return a.apply(b, c.concat(m.call(arguments)));
      };
    };
    B.partial = function(a) {
      var b = m.call(arguments, 1);
      return function() {
        return a.apply(this, b.concat(m.call(arguments)));
      };
    };
    B.bindAll = function(a) {
      var b = m.call(arguments, 1);
      return 0 === b.length && (b = B.functions(a)), G(b, function(b) {
        a[b] = B.bind(a[b], a);
      }), a;
    };
    B.memoize = function(a, b) {
      var c = {};
      return b || (b = B.identity), function() {
        var d = b.apply(this, arguments);
        return B.has(c, d) ? c[d] : c[d] = a.apply(this, arguments);
      };
    };
    B.delay = function(a, b) {
      var c = m.call(arguments, 2);
      return setTimeout(function() {
        return a.apply(null, c);
      }, b);
    };
    B.defer = function(a) {
      return B.delay.apply(B, [a, 1].concat(m.call(arguments, 1)));
    };
    B.throttle = function(a, b) {
      var c, d, e, f, k = 0, g = function() {
        k = new Date;
        e = null;
        f = a.apply(c, d);
      };
      return function() {
        var l = new Date, m = b - (l - k);
        return c = this, d = arguments, 0 >= m ? (clearTimeout(e), e = null, k = l, f = a.apply(c, d)) : e || (e = setTimeout(g, m)), f;
      };
    };
    B.debounce = function(a, b, c) {
      var d, e;
      return function() {
        var f = this, k = arguments, g = c && !d;
        return clearTimeout(d), d = setTimeout(function() {
          d = null;
          c || (e = a.apply(f, k));
        }, b), g && (e = a.apply(f, k)), e;
      };
    };
    B.once = function(a) {
      var b, c = !1;
      return function() {
        return c ? b : (c = !0, b = a.apply(this, arguments), a = null, b);
      };
    };
    B.wrap = function(a, b) {
      return function() {
        var c = [a];
        return p.apply(c, arguments), b.apply(this, c);
      };
    };
    B.compose = function() {
      var a = arguments;
      return function() {
        for (var b = arguments, c = a.length - 1; 0 <= c; c--) {
          b = [a[c].apply(this, b)];
        }
        return b[0];
      };
    };
    B.after = function(a, b) {
      return 0 >= a ? b() : function() {
        return 1 > --a ? b.apply(this, arguments) : void 0;
      };
    };
    B.keys = D || function(a) {
      if (a !== Object(a)) {
        throw new TypeError("Invalid object");
      }
      var b = [], c;
      for (c in a) {
        B.has(a, c) && (b[b.length] = c);
      }
      return b;
    };
    B.values = function(a) {
      var b = [], c;
      for (c in a) {
        B.has(a, c) && b.push(a[c]);
      }
      return b;
    };
    B.pairs = function(a) {
      var b = [], c;
      for (c in a) {
        B.has(a, c) && b.push([c, a[c]]);
      }
      return b;
    };
    B.invert = function(a) {
      var b = {}, c;
      for (c in a) {
        B.has(a, c) && (b[a[c]] = c);
      }
      return b;
    };
    B.functions = B.methods = function(a) {
      var b = [], c;
      for (c in a) {
        B.isFunction(a[c]) && b.push(c);
      }
      return b.sort();
    };
    B.extend = function(a) {
      return G(m.call(arguments, 1), function(b) {
        if (b) {
          for (var c in b) {
            a[c] = b[c];
          }
        }
      }), a;
    };
    B.pick = function(a) {
      var b = {}, c = t.apply(k, m.call(arguments, 1));
      return G(c, function(c) {
        c in a && (b[c] = a[c]);
      }), b;
    };
    B.omit = function(a) {
      var b = {}, c = t.apply(k, m.call(arguments, 1)), d;
      for (d in a) {
        B.contains(c, d) || (b[d] = a[d]);
      }
      return b;
    };
    B.defaults = function(a) {
      return G(m.call(arguments, 1), function(b) {
        if (b) {
          for (var c in b) {
            null == a[c] && (a[c] = b[c]);
          }
        }
      }), a;
    };
    B.clone = function(a) {
      return B.isObject(a) ? B.isArray(a) ? a.slice() : B.extend({}, a) : a;
    };
    B.tap = function(a, b) {
      return b(a), a;
    };
    var R = function(a, b, c, e) {
      if (a === b) {
        return 0 !== a || 1 / a == 1 / b;
      }
      if (null == a || null == b) {
        return a === b;
      }
      a instanceof B && (a = a._wrapped);
      b instanceof B && (b = b._wrapped);
      var f = d.call(a);
      if (f != d.call(b)) {
        return !1;
      }
      switch(f) {
        case "[object String]":
          return a == String(b);
        case "[object Number]":
          return a != +a ? b != +b : 0 == a ? 1 / a == 1 / b : a == +b;
        case "[object Date]":
        case "[object Boolean]":
          return +a == +b;
        case "[object RegExp]":
          return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
      }
      if ("object" != typeof a || "object" != typeof b) {
        return !1;
      }
      for (var k = c.length; k--;) {
        if (c[k] == a) {
          return e[k] == b;
        }
      }
      c.push(a);
      e.push(b);
      k = 0;
      var g = !0;
      if ("[object Array]" == f) {
        if (k = a.length, g = k == b.length) {
          for (; k-- && (g = R(a[k], b[k], c, e));) {
          }
        }
      } else {
        f = a.constructor;
        var l = b.constructor;
        if (f !== l && !(B.isFunction(f) && f instanceof f && B.isFunction(l) && l instanceof l)) {
          return !1;
        }
        for (var m in a) {
          if (B.has(a, m) && (k++, !(g = B.has(b, m) && R(a[m], b[m], c, e)))) {
            break;
          }
        }
        if (g) {
          for (m in b) {
            if (B.has(b, m) && !k--) {
              break;
            }
          }
          g = !k;
        }
      }
      return c.pop(), e.pop(), g;
    };
    B.isEqual = function(a, b) {
      return R(a, b, [], []);
    };
    B.isEmpty = function(a) {
      if (null == a) {
        return !0;
      }
      if (B.isArray(a) || B.isString(a)) {
        return 0 === a.length;
      }
      for (var b in a) {
        if (B.has(a, b)) {
          return !1;
        }
      }
      return !0;
    };
    B.isElement = function(a) {
      return !(!a || 1 !== a.nodeType);
    };
    B.isArray = n || function(a) {
      return "[object Array]" == d.call(a);
    };
    B.isObject = function(a) {
      return a === Object(a);
    };
    G("Arguments Function String Number Date RegExp".split(" "), function(a) {
      B["is" + a] = function(b) {
        return d.call(b) == "[object " + a + "]";
      };
    });
    B.isArguments(arguments) || (B.isArguments = function(a) {
      return !(!a || !B.has(a, "callee"));
    });
    "function" != typeof/./ && (B.isFunction = function(a) {
      return "function" == typeof a;
    });
    B.isFinite = function(a) {
      return isFinite(a) && !isNaN(parseFloat(a));
    };
    B.isNaN = function(a) {
      return B.isNumber(a) && a != +a;
    };
    B.isBoolean = function(a) {
      return !0 === a || !1 === a || "[object Boolean]" == d.call(a);
    };
    B.isNull = function(a) {
      return null === a;
    };
    B.isUndefined = function(a) {
      return void 0 === a;
    };
    B.has = function(a, b) {
      return l.call(a, b);
    };
    B.noConflict = function() {
      return a._ = e, this;
    };
    B.identity = function(a) {
      return a;
    };
    B.times = function(a, b, c) {
      for (var d = Array(a), e = 0; a > e; e++) {
        d[e] = b.call(c, e);
      }
      return d;
    };
    B.random = function(a, b) {
      return null == b && (b = a, a = 0), a + Math.floor(Math.random() * (b - a + 1));
    };
    var J = {escape:{"&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#x27;", "/":"&#x2F;"}};
    J.unescape = B.invert(J.escape);
    var Q = {escape:new RegExp("[" + B.keys(J.escape).join("") + "]", "g"), unescape:new RegExp("(" + B.keys(J.unescape).join("|") + ")", "g")};
    B.each(["escape", "unescape"], function(a) {
      B[a] = function(b) {
        return null == b ? "" : ("" + b).replace(Q[a], function(b) {
          return J[a][b];
        });
      };
    });
    B.result = function(a, b) {
      if (null == a) {
        return null;
      }
      b = a[b];
      return B.isFunction(b) ? b.call(a) : b;
    };
    B.mixin = function(a) {
      G(B.functions(a), function(b) {
        var c = B[b] = a[b];
        B.prototype[b] = function() {
          var a = [this._wrapped];
          return p.apply(a, arguments), V.call(this, c.apply(B, a));
        };
      });
    };
    var aa = 0;
    B.uniqueId = function(a) {
      var b = ++aa + "";
      return a ? a + b : b;
    };
    B.templateSettings = {evaluate:/<%([\s\S]+?)%>/g, interpolate:/<%=([\s\S]+?)%>/g, escape:/<%-([\s\S]+?)%>/g};
    var U = /(.)^/, N = {"'":"'", "\\":"\\", "\r":"r", "\n":"n", "\t":"t", "\u2028":"u2028", "\u2029":"u2029"}, S = /\\|'|\r|\n|\t|\u2028|\u2029/g;
    B.template = function(a, b, c) {
      c = B.defaults({}, c, B.templateSettings);
      var d = new RegExp([(c.escape || U).source, (c.interpolate || U).source, (c.evaluate || U).source].join("|") + "|$", "g"), e = 0, f = "__p+='";
      a.replace(d, function(b, c, d, k, g) {
        return f += a.slice(e, g).replace(S, function(a) {
          return "\\" + N[a];
        }), c && (f += "'+\n((__t=(" + c + "))==null?'':_.escape(__t))+\n'"), d && (f += "'+\n((__t=(" + d + "))==null?'':__t)+\n'"), k && (f += "';\n" + k + "\n__p+='"), e = g + b.length, b;
      });
      f += "';\n";
      c.variable || (f = "with(obj||{}){\n" + f + "}\n");
      f = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + f + "return __p;\n";
      try {
        var k = new Function(c.variable || "obj", "_", f);
      } catch (fa) {
        throw fa.source = f, fa;
      }
      if (b) {
        return k(b, B);
      }
      b = function(a) {
        return k.call(this, a, B);
      };
      return b.source = "function(" + (c.variable || "obj") + "){\n" + f + "}", b;
    };
    B.chain = function(a) {
      return B(a).chain();
    };
    var V = function(a) {
      return this._chain ? B(a).chain() : a;
    };
    B.mixin(B);
    G("pop push reverse shift sort splice unshift".split(" "), function(a) {
      var b = k[a];
      B.prototype[a] = function() {
        var c = this._wrapped;
        return b.apply(c, arguments), "shift" != a && "splice" != a || 0 !== c.length || delete c[0], V.call(this, c);
      };
    });
    G(["concat", "join", "slice"], function(a) {
      var b = k[a];
      B.prototype[a] = function() {
        return V.call(this, b.apply(this._wrapped, arguments));
      };
    });
    B.extend(B.prototype, {chain:function() {
      return this._chain = !0, this;
    }, value:function() {
      return this._wrapped;
    }});
  }).call(this);
}, {}], 25:[function(a) {
  "undefined" != typeof window && "function" != typeof window.requestAnimationFrame && (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a) {
    setTimeout(a, 1E3 / 60);
  });
  Leap = a("../lib/index");
}, {"../lib/index":11}]}, {}, [25]);
var SPE = {distributions:{BOX:1, SPHERE:2, DISC:3}, valueOverLifetimeLength:4};
"function" == typeof define && define.amd ? define("spe", SPE) : "undefined" != typeof exports && "undefined" != typeof module && (module.exports = SPE);
SPE.TypedArrayHelper = function(a, c, g, b) {
  this.componentSize = g || 1;
  this.size = c || 1;
  this.TypedArrayConstructor = a || Float32Array;
  this.array = new a(c * this.componentSize);
  this.indexOffset = b || 0;
};
SPE.TypedArrayHelper.constructor = SPE.TypedArrayHelper;
SPE.TypedArrayHelper.prototype.setSize = function(a, c) {
  var g = this.array.length;
  return c || (a *= this.componentSize), g > a ? this.shrink(a) : a > g ? this.grow(a) : void console.info("TypedArray is already of size:", a + ".", "Will not resize.");
};
SPE.TypedArrayHelper.prototype.shrink = function(a) {
  return this.array = this.array.subarray(0, a), this.size = a, this;
};
SPE.TypedArrayHelper.prototype.grow = function(a) {
  var c = this.array, g = new this.TypedArrayConstructor(a);
  return g.set(c), this.array = g, this.size = a, this;
};
SPE.TypedArrayHelper.prototype.splice = function(a, c) {
  a *= this.componentSize;
  c *= this.componentSize;
  for (var g = [], b = this.array, e = b.length, f = 0; e > f; ++f) {
    (a > f || f >= c) && g.push(b[f]);
  }
  return this.setFromArray(0, g), this;
};
SPE.TypedArrayHelper.prototype.setFromArray = function(a, c) {
  var g = a + c.length;
  return g > this.array.length ? this.grow(g) : g < this.array.length && this.shrink(g), this.array.set(c, this.indexOffset + a), this;
};
SPE.TypedArrayHelper.prototype.setVec2 = function(a, c) {
  return this.setVec2Components(a, c.x, c.y);
};
SPE.TypedArrayHelper.prototype.setVec2Components = function(a, c, g) {
  var b = this.array;
  a = this.indexOffset + a * this.componentSize;
  return b[a] = c, b[a + 1] = g, this;
};
SPE.TypedArrayHelper.prototype.setVec3 = function(a, c) {
  return this.setVec3Components(a, c.x, c.y, c.z);
};
SPE.TypedArrayHelper.prototype.setVec3Components = function(a, c, g, b) {
  var e = this.array;
  a = this.indexOffset + a * this.componentSize;
  return e[a] = c, e[a + 1] = g, e[a + 2] = b, this;
};
SPE.TypedArrayHelper.prototype.setVec4 = function(a, c) {
  return this.setVec4Components(a, c.x, c.y, c.z, c.w);
};
SPE.TypedArrayHelper.prototype.setVec4Components = function(a, c, g, b, e) {
  var f = this.array;
  a = this.indexOffset + a * this.componentSize;
  return f[a] = c, f[a + 1] = g, f[a + 2] = b, f[a + 3] = e, this;
};
SPE.TypedArrayHelper.prototype.setMat3 = function(a, c) {
  return this.setFromArray(this.indexOffset + a * this.componentSize, c.elements);
};
SPE.TypedArrayHelper.prototype.setMat4 = function(a, c) {
  return this.setFromArray(this.indexOffset + a * this.componentSize, c.elements);
};
SPE.TypedArrayHelper.prototype.setColor = function(a, c) {
  return this.setVec3Components(a, c.r, c.g, c.b);
};
SPE.TypedArrayHelper.prototype.setNumber = function(a, c) {
  return this.array[this.indexOffset + a * this.componentSize] = c, this;
};
SPE.TypedArrayHelper.prototype.getValueAtIndex = function(a) {
  return this.array[this.indexOffset + a];
};
SPE.TypedArrayHelper.prototype.getComponentValueAtIndex = function(a) {
  return this.array.subarray(this.indexOffset + a * this.componentSize);
};
SPE.ShaderAttribute = function(a, c, g) {
  var b = SPE.ShaderAttribute.typeSizeMap;
  this.type = "string" == typeof a && b.hasOwnProperty(a) ? a : "f";
  this.componentSize = b[this.type];
  this.arrayType = g || Float32Array;
  this.bufferAttribute = this.typedArray = null;
  this.dynamicBuffer = !!c;
  this.updateMax = this.updateMin = 0;
};
SPE.ShaderAttribute.constructor = SPE.ShaderAttribute;
SPE.ShaderAttribute.typeSizeMap = {f:1, v2:2, v3:3, v4:4, c:3, m3:9, m4:16};
SPE.ShaderAttribute.prototype.setUpdateRange = function(a, c) {
  this.updateMin = Math.min(a * this.componentSize, this.updateMin * this.componentSize);
  this.updateMax = Math.max(c * this.componentSize, this.updateMax * this.componentSize);
};
SPE.ShaderAttribute.prototype.flagUpdate = function() {
  var a = this.bufferAttribute, c = a.updateRange;
  c.offset = this.updateMin;
  c.count = Math.min(this.updateMax - this.updateMin + this.componentSize, this.typedArray.array.length);
  a.needsUpdate = !0;
};
SPE.ShaderAttribute.prototype.resetUpdateRange = function() {
  this.updateMax = this.updateMin = 0;
};
SPE.ShaderAttribute.prototype.resetDynamic = function() {
  this.bufferAttribute.dynamic = this.dynamicBuffer;
};
SPE.ShaderAttribute.prototype.splice = function(a, c) {
  this.typedArray.splice(a, c);
  this.forceUpdateAll();
};
SPE.ShaderAttribute.prototype.forceUpdateAll = function() {
  this.bufferAttribute.array = this.typedArray.array;
  this.bufferAttribute.updateRange.offset = 0;
  this.bufferAttribute.updateRange.count = -1;
  this.bufferAttribute.dynamic = !1;
  this.bufferAttribute.needsUpdate = !0;
};
SPE.ShaderAttribute.prototype._ensureTypedArray = function(a) {
  null !== this.typedArray && this.typedArray.size === a * this.componentSize || (null !== this.typedArray && this.typedArray.size !== a ? this.typedArray.setSize(a) : null === this.typedArray && (this.typedArray = new SPE.TypedArrayHelper(this.arrayType, a, this.componentSize)));
};
SPE.ShaderAttribute.prototype._createBufferAttribute = function(a) {
  return this._ensureTypedArray(a), null !== this.bufferAttribute ? (this.bufferAttribute.array = this.typedArray.array, 81 <= parseFloat(THREE.REVISION) && (this.bufferAttribute.count = this.bufferAttribute.array.length / this.bufferAttribute.itemSize), void(this.bufferAttribute.needsUpdate = !0)) : (this.bufferAttribute = new THREE.BufferAttribute(this.typedArray.array, this.componentSize), void(this.bufferAttribute.dynamic = this.dynamicBuffer));
};
SPE.ShaderAttribute.prototype.getLength = function() {
  return null === this.typedArray ? 0 : this.typedArray.array.length;
};
SPE.shaderChunks = {defines:"#define PACKED_COLOR_SIZE 256.0\n#define PACKED_COLOR_DIVISOR 255.0", uniforms:"uniform float deltaTime;\nuniform float runTime;\nuniform sampler2D texture;\nuniform vec4 textureAnimation;\nuniform float scale;", attributes:"attribute vec4 acceleration;\nattribute vec3 velocity;\nattribute vec4 rotation;\nattribute vec3 rotationCenter;\nattribute vec4 params;\nattribute vec4 size;\nattribute vec4 angle;\nattribute vec4 color;\nattribute vec4 opacity;", varyings:"varying vec4 vColor;\n#ifdef SHOULD_ROTATE_TEXTURE\n    varying float vAngle;\n#endif\n#ifdef SHOULD_CALCULATE_SPRITE\n    varying vec4 vSpriteSheet;\n#endif", 
branchAvoidanceFunctions:"float when_gt(float x, float y) {\n    return max(sign(x - y), 0.0);\n}\nfloat when_lt(float x, float y) {\n    return min( max(1.0 - sign(x - y), 0.0), 1.0 );\n}\nfloat when_eq( float x, float y ) {\n    return 1.0 - abs( sign( x - y ) );\n}\nfloat when_ge(float x, float y) {\n  return 1.0 - when_lt(x, y);\n}\nfloat when_le(float x, float y) {\n  return 1.0 - when_gt(x, y);\n}\nfloat and(float a, float b) {\n    return a * b;\n}\nfloat or(float a, float b) {\n    return min(a + b, 1.0);\n}", 
unpackColor:"vec3 unpackColor( in float hex ) {\n   vec3 c = vec3( 0.0 );\n   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );\n   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );\n   float b = mod( hex, PACKED_COLOR_SIZE );\n   c.r = r / PACKED_COLOR_DIVISOR;\n   c.g = g / PACKED_COLOR_DIVISOR;\n   c.b = b / PACKED_COLOR_DIVISOR;\n   return c;\n}", unpackRotationAxis:"vec3 unpackRotationAxis( in float hex ) {\n   vec3 c = vec3( 0.0 );\n   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );\n   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );\n   float b = mod( hex, PACKED_COLOR_SIZE );\n   c.r = r / PACKED_COLOR_DIVISOR;\n   c.g = g / PACKED_COLOR_DIVISOR;\n   c.b = b / PACKED_COLOR_DIVISOR;\n   c *= vec3( 2.0 );\n   c -= vec3( 1.0 );\n   return c;\n}", 
floatOverLifetime:"float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {\n    highp float value = 0.0;\n    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );\n    float fIndex = 0.0;\n    float shouldApplyValue = 0.0;\n    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );\n\n    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {\n       fIndex = float( i );\n       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );\n       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );\n    }\n\n    return value;\n}", 
colorOverLifetime:"vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {\n    vec3 value = vec3( 0.0 );\n    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );\n    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );\n    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );\n    return value;\n}", 
paramFetchingFunctions:"float getAlive() {\n   return params.x;\n}\nfloat getAge() {\n   return params.y;\n}\nfloat getMaxAge() {\n   return params.z;\n}\nfloat getWiggle() {\n   return params.w;\n}", forceFetchingFunctions:"vec4 getPosition( in float age ) {\n   return modelViewMatrix * vec4( position, 1.0 );\n}\nvec3 getVelocity( in float age ) {\n   return velocity * age;\n}\nvec3 getAcceleration( in float age ) {\n   return acceleration.xyz * age;\n}", rotationFunctions:"#ifdef SHOULD_ROTATE_PARTICLES\n   mat4 getRotationMatrix( in vec3 axis, in float angle) {\n       axis = normalize(axis);\n       float s = sin(angle);\n       float c = cos(angle);\n       float oc = 1.0 - c;\n\n       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                   0.0,                                0.0,                                0.0,                                1.0);\n   }\n\n   vec3 getRotation( in vec3 pos, in float positionInTime ) {\n      if( rotation.y == 0.0 ) {\n           return pos;\n      }\n\n      vec3 axis = unpackRotationAxis( rotation.x );\n      vec3 center = rotationCenter;\n      vec3 translated;\n      mat4 rotationMatrix;\n      float angle = 0.0;\n      angle += when_eq( rotation.z, 0.0 ) * rotation.y;\n      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );\n      translated = rotationCenter - pos;\n      rotationMatrix = getRotationMatrix( axis, angle );\n      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );\n   }\n#endif", 
rotateTexture:"    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );\n\n    #ifdef SHOULD_ROTATE_TEXTURE\n       float x = gl_PointCoord.x - 0.5;\n       float y = 1.0 - gl_PointCoord.y - 0.5;\n       float c = cos( -vAngle );\n       float s = sin( -vAngle );\n       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );\n    #endif\n\n    #ifdef SHOULD_CALCULATE_SPRITE\n        float framesX = vSpriteSheet.x;\n        float framesY = vSpriteSheet.y;\n        float columnNorm = vSpriteSheet.z;\n        float rowNorm = vSpriteSheet.w;\n        vUv.x = gl_PointCoord.x * framesX + columnNorm;\n        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);\n    #endif\n\n    vec4 rotatedTexture = texture2D( texture, vUv );"};
SPE.shaders = {vertex:[SPE.shaderChunks.defines, SPE.shaderChunks.uniforms, SPE.shaderChunks.attributes, SPE.shaderChunks.varyings, THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, THREE.ShaderChunk.fog_pars_vertex, SPE.shaderChunks.branchAvoidanceFunctions, SPE.shaderChunks.unpackColor, SPE.shaderChunks.unpackRotationAxis, SPE.shaderChunks.floatOverLifetime, SPE.shaderChunks.colorOverLifetime, SPE.shaderChunks.paramFetchingFunctions, SPE.shaderChunks.forceFetchingFunctions, SPE.shaderChunks.rotationFunctions, 
"void main() {\n    highp float age = getAge();\n    highp float alive = getAlive();\n    highp float maxAge = getMaxAge();\n    highp float positionInTime = (age / maxAge);\n    highp float isAlive = when_gt( alive, 0.0 );\n    #ifdef SHOULD_WIGGLE_PARTICLES\n        float wiggleAmount = positionInTime * getWiggle();\n        float wiggleSin = isAlive * sin( wiggleAmount );\n        float wiggleCos = isAlive * cos( wiggleAmount );\n    #endif\n    vec3 vel = getVelocity( age );\n    vec3 accel = getAcceleration( age );\n    vec3 force = vec3( 0.0 );\n    vec3 pos = vec3( position );\n    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;\n    force += vel;\n    force *= drag;\n    force += accel * age;\n    pos += force;\n    #ifdef SHOULD_WIGGLE_PARTICLES\n        pos.x += wiggleSin;\n        pos.y += wiggleCos;\n        pos.z += wiggleSin;\n    #endif\n    #ifdef SHOULD_ROTATE_PARTICLES\n        pos = getRotation( pos, positionInTime );\n    #endif\n    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );\n    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;\n    #ifdef HAS_PERSPECTIVE\n        float perspective = scale / length( mvPosition.xyz );\n    #else\n        float perspective = 1.0;\n    #endif\n    float pointSizePerspective = pointSize * perspective;\n    #ifdef COLORIZE\n       vec3 c = isAlive * getColorOverLifetime(\n           positionInTime,\n           unpackColor( color.x ),\n           unpackColor( color.y ),\n           unpackColor( color.z ),\n           unpackColor( color.w )\n       );\n    #else\n       vec3 c = vec3(1.0);\n    #endif\n    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );\n    vColor = vec4( c, o );\n    #ifdef SHOULD_ROTATE_TEXTURE\n        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );\n    #endif\n    #ifdef SHOULD_CALCULATE_SPRITE\n        float framesX = textureAnimation.x;\n        float framesY = textureAnimation.y;\n        float loopCount = textureAnimation.w;\n        float totalFrames = textureAnimation.z;\n        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );\n        float column = floor(mod( frameNumber, framesX ));\n        float row = floor( (frameNumber - column) / framesX );\n        float columnNorm = column / framesX;\n        float rowNorm = row / framesY;\n        vSpriteSheet.x = 1.0 / framesX;\n        vSpriteSheet.y = 1.0 / framesY;\n        vSpriteSheet.z = columnNorm;\n        vSpriteSheet.w = rowNorm;\n    #endif\n    gl_PointSize = pointSizePerspective;\n    gl_Position = projectionMatrix * mvPosition;", 
THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.fog_vertex, "}"].join("\n"), fragment:[SPE.shaderChunks.uniforms, THREE.ShaderChunk.common, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, SPE.shaderChunks.varyings, SPE.shaderChunks.branchAvoidanceFunctions, "void main() {\n    vec3 outgoingLight = vColor.xyz;\n    \n    #ifdef ALPHATEST\n       if ( vColor.w < float(ALPHATEST) ) discard;\n    #endif", SPE.shaderChunks.rotateTexture, THREE.ShaderChunk.logdepthbuf_fragment, 
"    outgoingLight = vColor.xyz * rotatedTexture.xyz;\n    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );", THREE.ShaderChunk.fog_fragment, "}"].join("\n")};
SPE.utils = {types:{BOOLEAN:"boolean", STRING:"string", NUMBER:"number", OBJECT:"object"}, ensureTypedArg:function(a, c, g) {
  return typeof a === c ? a : g;
}, ensureArrayTypedArg:function(a, c, g) {
  if (Array.isArray(a)) {
    for (var b = a.length - 1; 0 <= b; --b) {
      if (typeof a[b] !== c) {
        return g;
      }
    }
    return a;
  }
  return this.ensureTypedArg(a, c, g);
}, ensureInstanceOf:function(a, c, g) {
  return void 0 !== c && a instanceof c ? a : g;
}, ensureArrayInstanceOf:function(a, c, g) {
  if (Array.isArray(a)) {
    for (var b = a.length - 1; 0 <= b; --b) {
      if (void 0 !== c && 0 == a[b] instanceof c) {
        return g;
      }
    }
    return a;
  }
  return this.ensureInstanceOf(a, c, g);
}, ensureValueOverLifetimeCompliance:function(a, c, g) {
  c = c || 3;
  g = g || 3;
  !1 === Array.isArray(a._value) && (a._value = [a._value]);
  !1 === Array.isArray(a._spread) && (a._spread = [a._spread]);
  var b = this.clamp(a._value.length, c, g);
  c = this.clamp(a._spread.length, c, g);
  b = Math.max(b, c);
  a._value.length !== b && (a._value = this.interpolateArray(a._value, b));
  a._spread.length !== b && (a._spread = this.interpolateArray(a._spread, b));
}, interpolateArray:function(a, c) {
  for (var g = a.length, b = ["function" == typeof a[0].clone ? a[0].clone() : a[0]], e = (g - 1) / (c - 1), f = 1; c - 1 > f; ++f) {
    var k = f * e, n = Math.floor(k);
    b[f] = this.lerpTypeAgnostic(a[n], a[Math.ceil(k)], k - n);
  }
  return b.push("function" == typeof a[g - 1].clone ? a[g - 1].clone() : a[g - 1]), b;
}, clamp:function(a, c, g) {
  return Math.max(c, Math.min(a, g));
}, zeroToEpsilon:function(a, c) {
  var g = a;
  return g = c ? 1E-4 * Math.random() : 1E-5, 0 > a && -1E-5 < a && (g = -g), g;
}, lerpTypeAgnostic:function(a, c, g) {
  var b, e = this.types;
  return typeof a === e.NUMBER && typeof c === e.NUMBER ? a + (c - a) * g : a instanceof THREE.Vector2 && c instanceof THREE.Vector2 ? (b = a.clone(), b.x = this.lerp(a.x, c.x, g), b.y = this.lerp(a.y, c.y, g), b) : a instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? (b = a.clone(), b.x = this.lerp(a.x, c.x, g), b.y = this.lerp(a.y, c.y, g), b.z = this.lerp(a.z, c.z, g), b) : a instanceof THREE.Vector4 && c instanceof THREE.Vector4 ? (b = a.clone(), b.x = this.lerp(a.x, c.x, g), b.y = this.lerp(a.y, 
  c.y, g), b.z = this.lerp(a.z, c.z, g), b.w = this.lerp(a.w, c.w, g), b) : a instanceof THREE.Color && c instanceof THREE.Color ? (b = a.clone(), b.r = this.lerp(a.r, c.r, g), b.g = this.lerp(a.g, c.g, g), b.b = this.lerp(a.b, c.b, g), b) : void console.warn("Invalid argument types, or argument types do not match:", a, c);
}, lerp:function(a, c, g) {
  return a + (c - a) * g;
}, roundToNearestMultiple:function(a, c) {
  var g = 0;
  return 0 === c ? a : (g = Math.abs(a) % c, 0 === g ? a : 0 > a ? -(Math.abs(a) - g) : a + c - g);
}, arrayValuesAreEqual:function(a) {
  for (var c = 0; c < a.length - 1; ++c) {
    if (a[c] !== a[c + 1]) {
      return !1;
    }
  }
  return !0;
}, randomFloat:function(a, c) {
  return a + c * (Math.random() - .5);
}, randomVector3:function(a, c, g, b, e) {
  var f = g.x + (Math.random() * b.x - .5 * b.x), k = g.y + (Math.random() * b.y - .5 * b.y);
  g = g.z + (Math.random() * b.z - .5 * b.z);
  e && (f = .5 * -e.x + this.roundToNearestMultiple(f, e.x), k = .5 * -e.y + this.roundToNearestMultiple(k, e.y), g = .5 * -e.z + this.roundToNearestMultiple(g, e.z));
  a.typedArray.setVec3Components(c, f, k, g);
}, randomColor:function(a, c, g, b) {
  var e = g.r + Math.random() * b.x, f = g.g + Math.random() * b.y;
  g = g.b + Math.random() * b.z;
  e = this.clamp(e, 0, 1);
  f = this.clamp(f, 0, 1);
  g = this.clamp(g, 0, 1);
  a.typedArray.setVec3Components(c, e, f, g);
}, randomColorAsHex:function() {
  var a = new THREE.Color;
  return function(c, g, b, e) {
    for (var f = b.length, k = [], n = 0; f > n; ++n) {
      var p = e[n];
      a.copy(b[n]);
      a.r += Math.random() * p.x - .5 * p.x;
      a.g += Math.random() * p.y - .5 * p.y;
      a.b += Math.random() * p.z - .5 * p.z;
      a.r = this.clamp(a.r, 0, 1);
      a.g = this.clamp(a.g, 0, 1);
      a.b = this.clamp(a.b, 0, 1);
      k.push(a.getHex());
    }
    c.typedArray.setVec4Components(g, k[0], k[1], k[2], k[3]);
  };
}(), randomVector3OnSphere:function(a, c, g, b, e, f, k, n) {
  n = 2 * Math.random() - 1;
  var p = 6.2832 * Math.random(), m = Math.sqrt(1 - n * n);
  b = this.randomFloat(b, e);
  k && (b = Math.round(b / k) * k);
  k = m * Math.cos(p) * b;
  p = m * Math.sin(p) * b;
  k *= f.x;
  p *= f.y;
  f = n * b * f.z;
  k += g.x;
  p += g.y;
  f += g.z;
  a.typedArray.setVec3Components(c, k, p, f);
}, seededRandom:function(a) {
  a = 1E4 * Math.sin(a);
  return a - (0 | a);
}, randomVector3OnDisc:function(a, c, g, b, e, f, k) {
  var n = 6.2832 * Math.random();
  b = Math.abs(this.randomFloat(b, e));
  k && (b = Math.round(b / k) * k);
  k = Math.cos(n) * b;
  n = Math.sin(n) * b;
  k *= f.x;
  n *= f.y;
  k += g.x;
  n += g.y;
  g = 0 + g.z;
  a.typedArray.setVec3Components(c, k, n, g);
}, randomDirectionVector3OnSphere:function() {
  var a = new THREE.Vector3;
  return function(c, g, b, e, f, k, n, p) {
    a.copy(k);
    a.x -= b;
    a.y -= e;
    a.z -= f;
    a.normalize().multiplyScalar(-this.randomFloat(n, p));
    c.typedArray.setVec3Components(g, a.x, a.y, a.z);
  };
}(), randomDirectionVector3OnDisc:function() {
  var a = new THREE.Vector3;
  return function(c, g, b, e, f, k, n, p) {
    a.copy(k);
    a.x -= b;
    a.y -= e;
    a.z -= f;
    a.normalize().multiplyScalar(-this.randomFloat(n, p));
    c.typedArray.setVec3Components(g, a.x, a.y, 0);
  };
}(), getPackedRotationAxis:function() {
  var a = new THREE.Vector3, c = new THREE.Vector3, g = new THREE.Color, b = new THREE.Vector3(1, 1, 1);
  return function(e, f) {
    return a.copy(e).normalize(), c.copy(f).normalize(), a.x += .5 * -f.x + Math.random() * f.x, a.y += .5 * -f.y + Math.random() * f.y, a.z += .5 * -f.z + Math.random() * f.z, a.normalize().add(b).multiplyScalar(.5), g.setRGB(a.x, a.y, a.z), g.getHex();
  };
}()};
SPE.Group = function(a) {
  var c = SPE.utils, g = c.types;
  a = c.ensureTypedArg(a, g.OBJECT, {});
  a.texture = c.ensureTypedArg(a.texture, g.OBJECT, {});
  this.uuid = THREE.Math.generateUUID();
  this.fixedTimeStep = c.ensureTypedArg(a.fixedTimeStep, g.NUMBER, .016);
  this.texture = c.ensureInstanceOf(a.texture.value, THREE.Texture, null);
  this.textureFrames = c.ensureInstanceOf(a.texture.frames, THREE.Vector2, new THREE.Vector2(1, 1));
  this.textureFrameCount = c.ensureTypedArg(a.texture.frameCount, g.NUMBER, this.textureFrames.x * this.textureFrames.y);
  this.textureLoop = c.ensureTypedArg(a.texture.loop, g.NUMBER, 1);
  this.textureFrames.max(new THREE.Vector2(1, 1));
  this.hasPerspective = c.ensureTypedArg(a.hasPerspective, g.BOOLEAN, !0);
  this.colorize = c.ensureTypedArg(a.colorize, g.BOOLEAN, !0);
  this.maxParticleCount = c.ensureTypedArg(a.maxParticleCount, g.NUMBER, null);
  this.blending = c.ensureTypedArg(a.blending, g.NUMBER, THREE.AdditiveBlending);
  this.transparent = c.ensureTypedArg(a.transparent, g.BOOLEAN, !0);
  this.alphaTest = parseFloat(c.ensureTypedArg(a.alphaTest, g.NUMBER, 0));
  this.depthWrite = c.ensureTypedArg(a.depthWrite, g.BOOLEAN, !1);
  this.depthTest = c.ensureTypedArg(a.depthTest, g.BOOLEAN, !0);
  this.fog = c.ensureTypedArg(a.fog, g.BOOLEAN, !0);
  this.scale = c.ensureTypedArg(a.scale, g.NUMBER, 300);
  this.emitters = [];
  this.emitterIDs = [];
  this._pool = [];
  this._poolCreationSettings = null;
  this._createNewWhenPoolEmpty = 0;
  this._attributesNeedDynamicReset = this._attributesNeedRefresh = !1;
  this.particleCount = 0;
  this.uniforms = {texture:{type:"t", value:this.texture}, textureAnimation:{type:"v4", value:new THREE.Vector4(this.textureFrames.x, this.textureFrames.y, this.textureFrameCount, Math.max(Math.abs(this.textureLoop), 1))}, fogColor:{type:"c", value:null}, fogNear:{type:"f", value:10}, fogFar:{type:"f", value:200}, fogDensity:{type:"f", value:.5}, deltaTime:{type:"f", value:0}, runTime:{type:"f", value:0}, scale:{type:"f", value:this.scale}};
  this.defines = {HAS_PERSPECTIVE:this.hasPerspective, COLORIZE:this.colorize, VALUE_OVER_LIFETIME_LENGTH:SPE.valueOverLifetimeLength, SHOULD_ROTATE_TEXTURE:!1, SHOULD_ROTATE_PARTICLES:!1, SHOULD_WIGGLE_PARTICLES:!1, SHOULD_CALCULATE_SPRITE:1 < this.textureFrames.x || 1 < this.textureFrames.y};
  this.attributes = {position:new SPE.ShaderAttribute("v3", !0), acceleration:new SPE.ShaderAttribute("v4", !0), velocity:new SPE.ShaderAttribute("v3", !0), rotation:new SPE.ShaderAttribute("v4", !0), rotationCenter:new SPE.ShaderAttribute("v3", !0), params:new SPE.ShaderAttribute("v4", !0), size:new SPE.ShaderAttribute("v4", !0), angle:new SPE.ShaderAttribute("v4", !0), color:new SPE.ShaderAttribute("v4", !0), opacity:new SPE.ShaderAttribute("v4", !0)};
  this.attributeKeys = Object.keys(this.attributes);
  this.attributeCount = this.attributeKeys.length;
  this.material = new THREE.ShaderMaterial({uniforms:this.uniforms, vertexShader:SPE.shaders.vertex, fragmentShader:SPE.shaders.fragment, blending:this.blending, transparent:this.transparent, alphaTest:this.alphaTest, depthWrite:this.depthWrite, depthTest:this.depthTest, defines:this.defines, fog:this.fog});
  this.geometry = new THREE.BufferGeometry;
  this.mesh = new THREE.Points(this.geometry, this.material);
  null === this.maxParticleCount && console.warn("SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.");
};
SPE.Group.constructor = SPE.Group;
SPE.Group.prototype._updateDefines = function() {
  var a = this.emitters, c = a.length - 1, g = this.defines;
  for (c; 0 <= c; --c) {
    var b = a[c];
    g.SHOULD_CALCULATE_SPRITE || (g.SHOULD_ROTATE_TEXTURE = g.SHOULD_ROTATE_TEXTURE || !!Math.max(Math.max.apply(null, b.angle.value), Math.max.apply(null, b.angle.spread)));
    g.SHOULD_ROTATE_PARTICLES = g.SHOULD_ROTATE_PARTICLES || !!Math.max(b.rotation.angle, b.rotation.angleSpread);
    g.SHOULD_WIGGLE_PARTICLES = g.SHOULD_WIGGLE_PARTICLES || !!Math.max(b.wiggle.value, b.wiggle.spread);
  }
  this.material.needsUpdate = !0;
};
SPE.Group.prototype._applyAttributesToGeometry = function() {
  var a, c, g = this.attributes, b = this.geometry, e = b.attributes, f;
  for (f in g) {
    g.hasOwnProperty(f) && (a = g[f], c = e[f], c ? c.array = a.typedArray.array : b.addAttribute(f, a.bufferAttribute), a.bufferAttribute.needsUpdate = !0);
  }
  this.geometry.setDrawRange(0, this.particleCount);
};
SPE.Group.prototype.addEmitter = function(a) {
  if (0 == a instanceof SPE.Emitter) {
    return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", a);
  }
  if (-1 < this.emitterIDs.indexOf(a.uuid)) {
    return void console.error("Emitter already exists in this group. Will not add again.");
  }
  if (null !== a.group) {
    return void console.error("Emitter already belongs to another group. Will not add to requested group.");
  }
  var c = this.attributes, g = this.particleCount, b = g + a.particleCount;
  this.particleCount = b;
  null !== this.maxParticleCount && this.particleCount > this.maxParticleCount && console.warn("SPE.Group: maxParticleCount exceeded. Requesting", this.particleCount, "particles, can support only", this.maxParticleCount);
  a._calculatePPSValue(a.maxAge._value + a.maxAge._spread);
  a._setBufferUpdateRanges(this.attributeKeys);
  a._setAttributeOffset(g);
  a.group = this;
  a.attributes = this.attributes;
  for (var e in c) {
    c.hasOwnProperty(e) && c[e]._createBufferAttribute(null !== this.maxParticleCount ? this.maxParticleCount : this.particleCount);
  }
  for (c = g; b > c; ++c) {
    a._assignPositionValue(c), a._assignForceValue(c, "velocity"), a._assignForceValue(c, "acceleration"), a._assignAbsLifetimeValue(c, "opacity"), a._assignAbsLifetimeValue(c, "size"), a._assignAngleValue(c), a._assignRotationValue(c), a._assignParamsValue(c), a._assignColorValue(c);
  }
  return this._applyAttributesToGeometry(), this.emitters.push(a), this.emitterIDs.push(a.uuid), this._updateDefines(a), this.material.needsUpdate = !0, this.geometry.needsUpdate = !0, this._attributesNeedRefresh = !0, this;
};
SPE.Group.prototype.removeEmitter = function(a) {
  var c = this.emitterIDs.indexOf(a.uuid);
  if (0 == a instanceof SPE.Emitter) {
    return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", a);
  }
  if (-1 === c) {
    return void console.error("Emitter does not exist in this group. Will not remove.");
  }
  for (var g = a.attributeOffset, b = g + a.particleCount, e = this.attributes.params.typedArray, f = g; b > f; ++f) {
    e.array[4 * f] = 0, e.array[4 * f + 1] = 0;
  }
  this.emitters.splice(c, 1);
  this.emitterIDs.splice(c, 1);
  for (var k in this.attributes) {
    this.attributes.hasOwnProperty(k) && this.attributes[k].splice(g, b);
  }
  this.particleCount -= a.particleCount;
  a._onRemove();
  this._attributesNeedRefresh = !0;
};
SPE.Group.prototype.getFromPool = function() {
  var a = this._pool, c = this._createNewWhenPoolEmpty;
  return a.length ? a.pop() : c ? (a = new SPE.Emitter(this._poolCreationSettings), this.addEmitter(a), a) : null;
};
SPE.Group.prototype.releaseIntoPool = function(a) {
  return 0 == a instanceof SPE.Emitter ? void console.error("Argument is not instanceof SPE.Emitter:", a) : (a.reset(), this._pool.unshift(a), this);
};
SPE.Group.prototype.getPool = function() {
  return this._pool;
};
SPE.Group.prototype.addPool = function(a, c, g) {
  this._poolCreationSettings = c;
  this._createNewWhenPoolEmpty = !!g;
  for (var b = 0; a > b; ++b) {
    g = Array.isArray(c) ? new SPE.Emitter(c[b]) : new SPE.Emitter(c), this.addEmitter(g), this.releaseIntoPool(g);
  }
  return this;
};
SPE.Group.prototype._triggerSingleEmitter = function(a) {
  var c = this.getFromPool(), g = this;
  return null === c ? void console.log("SPE.Group pool ran out.") : (a instanceof THREE.Vector3 && (c.position.value.copy(a), c.position.value = c.position.value), c.enable(), setTimeout(function() {
    c.disable();
    g.releaseIntoPool(c);
  }, 1E3 * Math.max(c.duration, c.maxAge.value + c.maxAge.spread)), this);
};
SPE.Group.prototype.triggerPoolEmitter = function(a, c) {
  if ("number" == typeof a && 1 < a) {
    for (var g = 0; a > g; ++g) {
      this._triggerSingleEmitter(c);
    }
  } else {
    this._triggerSingleEmitter(c);
  }
  return this;
};
SPE.Group.prototype._updateUniforms = function(a) {
  this.uniforms.runTime.value += a;
  this.uniforms.deltaTime.value = a;
};
SPE.Group.prototype._resetBufferRanges = function() {
  var a = this.attributeKeys, c = this.attributeCount - 1, g = this.attributes;
  for (c; 0 <= c; --c) {
    g[a[c]].resetUpdateRange();
  }
};
SPE.Group.prototype._updateBuffers = function(a) {
  var c = this.attributeKeys, g = this.attributeCount - 1, b = this.attributes, e = a.bufferUpdateRanges;
  for (g; 0 <= g; --g) {
    var f = c[g];
    a = e[f];
    f = b[f];
    f.setUpdateRange(a.min, a.max);
    f.flagUpdate();
  }
};
SPE.Group.prototype.tick = function(a) {
  var c = this.emitters, g = c.length, b = a || this.fixedTimeStep, e = this.attributeKeys, f = this.attributes;
  if (this._updateUniforms(b), this._resetBufferRanges(), 0 !== g || !1 !== this._attributesNeedRefresh || !1 !== this._attributesNeedDynamicReset) {
    for (a = 0; g > a; ++a) {
      var k = c[a];
      k.tick(b);
      this._updateBuffers(k);
    }
    if (!0 === this._attributesNeedDynamicReset) {
      for (a = this.attributeCount - 1; 0 <= a; --a) {
        f[e[a]].resetDynamic();
      }
      this._attributesNeedDynamicReset = !1;
    }
    if (!0 === this._attributesNeedRefresh) {
      for (a = this.attributeCount - 1; 0 <= a; --a) {
        f[e[a]].forceUpdateAll();
      }
      this._attributesNeedRefresh = !1;
      this._attributesNeedDynamicReset = !0;
    }
  }
};
SPE.Group.prototype.dispose = function() {
  return this.geometry.dispose(), this.material.dispose(), this;
};
SPE.Emitter = function(a) {
  var c = SPE.utils, g = c.types, b = SPE.valueOverLifetimeLength;
  a = c.ensureTypedArg(a, g.OBJECT, {});
  a.position = c.ensureTypedArg(a.position, g.OBJECT, {});
  a.velocity = c.ensureTypedArg(a.velocity, g.OBJECT, {});
  a.acceleration = c.ensureTypedArg(a.acceleration, g.OBJECT, {});
  a.radius = c.ensureTypedArg(a.radius, g.OBJECT, {});
  a.drag = c.ensureTypedArg(a.drag, g.OBJECT, {});
  a.rotation = c.ensureTypedArg(a.rotation, g.OBJECT, {});
  a.color = c.ensureTypedArg(a.color, g.OBJECT, {});
  a.opacity = c.ensureTypedArg(a.opacity, g.OBJECT, {});
  a.size = c.ensureTypedArg(a.size, g.OBJECT, {});
  a.angle = c.ensureTypedArg(a.angle, g.OBJECT, {});
  a.wiggle = c.ensureTypedArg(a.wiggle, g.OBJECT, {});
  a.maxAge = c.ensureTypedArg(a.maxAge, g.OBJECT, {});
  a.onParticleSpawn && console.warn("onParticleSpawn has been removed. Please set properties directly to alter values at runtime.");
  this.uuid = THREE.Math.generateUUID();
  this.type = c.ensureTypedArg(a.type, g.NUMBER, SPE.distributions.BOX);
  this.position = {_value:c.ensureInstanceOf(a.position.value, THREE.Vector3, new THREE.Vector3), _spread:c.ensureInstanceOf(a.position.spread, THREE.Vector3, new THREE.Vector3), _spreadClamp:c.ensureInstanceOf(a.position.spreadClamp, THREE.Vector3, new THREE.Vector3), _distribution:c.ensureTypedArg(a.position.distribution, g.NUMBER, this.type), _randomise:c.ensureTypedArg(a.position.randomise, g.BOOLEAN, !1), _radius:c.ensureTypedArg(a.position.radius, g.NUMBER, 10), _radiusScale:c.ensureInstanceOf(a.position.radiusScale, 
  THREE.Vector3, new THREE.Vector3(1, 1, 1)), _distributionClamp:c.ensureTypedArg(a.position.distributionClamp, g.NUMBER, 0)};
  this.velocity = {_value:c.ensureInstanceOf(a.velocity.value, THREE.Vector3, new THREE.Vector3), _spread:c.ensureInstanceOf(a.velocity.spread, THREE.Vector3, new THREE.Vector3), _distribution:c.ensureTypedArg(a.velocity.distribution, g.NUMBER, this.type), _randomise:c.ensureTypedArg(a.position.randomise, g.BOOLEAN, !1)};
  this.acceleration = {_value:c.ensureInstanceOf(a.acceleration.value, THREE.Vector3, new THREE.Vector3), _spread:c.ensureInstanceOf(a.acceleration.spread, THREE.Vector3, new THREE.Vector3), _distribution:c.ensureTypedArg(a.acceleration.distribution, g.NUMBER, this.type), _randomise:c.ensureTypedArg(a.position.randomise, g.BOOLEAN, !1)};
  this.drag = {_value:c.ensureTypedArg(a.drag.value, g.NUMBER, 0), _spread:c.ensureTypedArg(a.drag.spread, g.NUMBER, 0), _randomise:c.ensureTypedArg(a.position.randomise, g.BOOLEAN, !1)};
  this.wiggle = {_value:c.ensureTypedArg(a.wiggle.value, g.NUMBER, 0), _spread:c.ensureTypedArg(a.wiggle.spread, g.NUMBER, 0)};
  this.rotation = {_axis:c.ensureInstanceOf(a.rotation.axis, THREE.Vector3, new THREE.Vector3(0, 1, 0)), _axisSpread:c.ensureInstanceOf(a.rotation.axisSpread, THREE.Vector3, new THREE.Vector3), _angle:c.ensureTypedArg(a.rotation.angle, g.NUMBER, 0), _angleSpread:c.ensureTypedArg(a.rotation.angleSpread, g.NUMBER, 0), _static:c.ensureTypedArg(a.rotation["static"], g.BOOLEAN, !1), _center:c.ensureInstanceOf(a.rotation.center, THREE.Vector3, this.position._value.clone()), _randomise:c.ensureTypedArg(a.position.randomise, 
  g.BOOLEAN, !1)};
  this.maxAge = {_value:c.ensureTypedArg(a.maxAge.value, g.NUMBER, 2), _spread:c.ensureTypedArg(a.maxAge.spread, g.NUMBER, 0)};
  this.color = {_value:c.ensureArrayInstanceOf(a.color.value, THREE.Color, new THREE.Color), _spread:c.ensureArrayInstanceOf(a.color.spread, THREE.Vector3, new THREE.Vector3), _randomise:c.ensureTypedArg(a.position.randomise, g.BOOLEAN, !1)};
  this.opacity = {_value:c.ensureArrayTypedArg(a.opacity.value, g.NUMBER, 1), _spread:c.ensureArrayTypedArg(a.opacity.spread, g.NUMBER, 0), _randomise:c.ensureTypedArg(a.position.randomise, g.BOOLEAN, !1)};
  this.size = {_value:c.ensureArrayTypedArg(a.size.value, g.NUMBER, 1), _spread:c.ensureArrayTypedArg(a.size.spread, g.NUMBER, 0), _randomise:c.ensureTypedArg(a.position.randomise, g.BOOLEAN, !1)};
  this.angle = {_value:c.ensureArrayTypedArg(a.angle.value, g.NUMBER, 0), _spread:c.ensureArrayTypedArg(a.angle.spread, g.NUMBER, 0), _randomise:c.ensureTypedArg(a.position.randomise, g.BOOLEAN, !1)};
  this.particleCount = c.ensureTypedArg(a.particleCount, g.NUMBER, 100);
  this.duration = c.ensureTypedArg(a.duration, g.NUMBER, null);
  this.isStatic = c.ensureTypedArg(a.isStatic, g.BOOLEAN, !1);
  this.activeMultiplier = c.ensureTypedArg(a.activeMultiplier, g.NUMBER, 1);
  this.direction = c.ensureTypedArg(a.direction, g.NUMBER, 1);
  this.alive = c.ensureTypedArg(a.alive, g.BOOLEAN, !0);
  this.activeParticleCount = this.age = this.attributeEnd = this.attributeOffset = this.activationIndex = this.particlesPerSecond = 0;
  this.paramsArray = this.attributes = this.group = null;
  this.resetFlags = {position:c.ensureTypedArg(a.position.randomise, g.BOOLEAN, !1) || c.ensureTypedArg(a.radius.randomise, g.BOOLEAN, !1), velocity:c.ensureTypedArg(a.velocity.randomise, g.BOOLEAN, !1), acceleration:c.ensureTypedArg(a.acceleration.randomise, g.BOOLEAN, !1) || c.ensureTypedArg(a.drag.randomise, g.BOOLEAN, !1), rotation:c.ensureTypedArg(a.rotation.randomise, g.BOOLEAN, !1), rotationCenter:c.ensureTypedArg(a.rotation.randomise, g.BOOLEAN, !1), size:c.ensureTypedArg(a.size.randomise, 
  g.BOOLEAN, !1), color:c.ensureTypedArg(a.color.randomise, g.BOOLEAN, !1), opacity:c.ensureTypedArg(a.opacity.randomise, g.BOOLEAN, !1), angle:c.ensureTypedArg(a.angle.randomise, g.BOOLEAN, !1)};
  this.updateFlags = {};
  this.updateCounts = {};
  this.updateMap = {maxAge:"params", position:"position", velocity:"velocity", acceleration:"acceleration", drag:"acceleration", wiggle:"params", rotation:"rotation", size:"size", color:"color", opacity:"opacity", angle:"angle"};
  for (var e in this.updateMap) {
    this.updateMap.hasOwnProperty(e) && (this.updateCounts[this.updateMap[e]] = 0, this.updateFlags[this.updateMap[e]] = !1, this._createGetterSetters(this[e], e));
  }
  this.bufferUpdateRanges = {};
  this.attributeKeys = null;
  this.attributeCount = 0;
  c.ensureValueOverLifetimeCompliance(this.color, b, b);
  c.ensureValueOverLifetimeCompliance(this.opacity, b, b);
  c.ensureValueOverLifetimeCompliance(this.size, b, b);
  c.ensureValueOverLifetimeCompliance(this.angle, b, b);
};
SPE.Emitter.constructor = SPE.Emitter;
SPE.Emitter.prototype._createGetterSetters = function(a, c) {
  var g = this, b;
  for (b in a) {
    if (a.hasOwnProperty(b)) {
      var e = b.replace("_", "");
      Object.defineProperty(a, e, {get:function(a) {
        return function() {
          return this[a];
        };
      }(b), set:function(a) {
        return function(b) {
          var e = g.updateMap[c], f = this[a], k = SPE.valueOverLifetimeLength;
          "_rotationCenter" === a ? (g.updateFlags.rotationCenter = !0, g.updateCounts.rotationCenter = 0) : "_randomise" === a ? g.resetFlags[e] = b : (g.updateFlags[e] = !0, g.updateCounts[e] = 0);
          g.group._updateDefines();
          this[a] = b;
          Array.isArray(f) && SPE.utils.ensureValueOverLifetimeCompliance(g[c], k, k);
        };
      }(b)});
    }
  }
};
SPE.Emitter.prototype._setBufferUpdateRanges = function(a) {
  this.attributeKeys = a;
  this.attributeCount = a.length;
  for (var c = this.attributeCount - 1; 0 <= c; --c) {
    this.bufferUpdateRanges[a[c]] = {min:Number.POSITIVE_INFINITY, max:Number.NEGATIVE_INFINITY};
  }
};
SPE.Emitter.prototype._calculatePPSValue = function(a) {
  var c = this.particleCount;
  this.duration ? this.particlesPerSecond = c / (a < this.duration ? a : this.duration) : this.particlesPerSecond = c / a;
};
SPE.Emitter.prototype._setAttributeOffset = function(a) {
  this.activationIndex = this.attributeOffset = a;
  this.activationEnd = a + this.particleCount;
};
SPE.Emitter.prototype._assignValue = function(a, c) {
  switch(a) {
    case "position":
      this._assignPositionValue(c);
      break;
    case "velocity":
    case "acceleration":
      this._assignForceValue(c, a);
      break;
    case "size":
    case "opacity":
      this._assignAbsLifetimeValue(c, a);
      break;
    case "angle":
      this._assignAngleValue(c);
      break;
    case "params":
      this._assignParamsValue(c);
      break;
    case "rotation":
      this._assignRotationValue(c);
      break;
    case "color":
      this._assignColorValue(c);
  }
};
SPE.Emitter.prototype._assignPositionValue = function(a) {
  var c = SPE.distributions, g = SPE.utils, b = this.position, e = this.attributes.position, f = b._value, k = b._spread;
  switch(b._distribution) {
    case c.BOX:
      g.randomVector3(e, a, f, k, b._spreadClamp);
      break;
    case c.SPHERE:
      g.randomVector3OnSphere(e, a, f, b._radius, b._spread.x, b._radiusScale, b._spreadClamp.x, b._distributionClamp || this.particleCount);
      break;
    case c.DISC:
      g.randomVector3OnDisc(e, a, f, b._radius, b._spread.x, b._radiusScale, b._spreadClamp.x);
  }
};
SPE.Emitter.prototype._assignForceValue = function(a, c) {
  var g = SPE.distributions;
  var b = SPE.utils, e = this[c];
  var f = e._value;
  var k = e._spread;
  switch(e._distribution) {
    case g.BOX:
      b.randomVector3(this.attributes[c], a, f, k);
      break;
    case g.SPHERE:
      k = this.attributes.position.typedArray.array;
      var n = 3 * a;
      g = k[n];
      f = k[n + 1];
      k = k[n + 2];
      b.randomDirectionVector3OnSphere(this.attributes[c], a, g, f, k, this.position._value, e._value.x, e._spread.x);
      break;
    case g.DISC:
      k = this.attributes.position.typedArray.array, n = 3 * a, g = k[n], f = k[n + 1], k = k[n + 2], b.randomDirectionVector3OnDisc(this.attributes[c], a, g, f, k, this.position._value, e._value.x, e._spread.x);
  }
  "acceleration" === c && (c = b.clamp(b.randomFloat(this.drag._value, this.drag._spread), 0, 1), this.attributes.acceleration.typedArray.array[4 * a + 3] = c);
};
SPE.Emitter.prototype._assignAbsLifetimeValue = function(a, c) {
  var g, b = this.attributes[c].typedArray;
  c = this[c];
  var e = SPE.utils;
  e.arrayValuesAreEqual(c._value) && e.arrayValuesAreEqual(c._spread) ? (g = Math.abs(e.randomFloat(c._value[0], c._spread[0])), b.setVec4Components(a, g, g, g, g)) : b.setVec4Components(a, Math.abs(e.randomFloat(c._value[0], c._spread[0])), Math.abs(e.randomFloat(c._value[1], c._spread[1])), Math.abs(e.randomFloat(c._value[2], c._spread[2])), Math.abs(e.randomFloat(c._value[3], c._spread[3])));
};
SPE.Emitter.prototype._assignAngleValue = function(a) {
  var c, g = this.attributes.angle.typedArray, b = this.angle, e = SPE.utils;
  e.arrayValuesAreEqual(b._value) && e.arrayValuesAreEqual(b._spread) ? (c = e.randomFloat(b._value[0], b._spread[0]), g.setVec4Components(a, c, c, c, c)) : g.setVec4Components(a, e.randomFloat(b._value[0], b._spread[0]), e.randomFloat(b._value[1], b._spread[1]), e.randomFloat(b._value[2], b._spread[2]), e.randomFloat(b._value[3], b._spread[3]));
};
SPE.Emitter.prototype._assignParamsValue = function(a) {
  this.attributes.params.typedArray.setVec4Components(a, this.isStatic ? 1 : 0, 0, Math.abs(SPE.utils.randomFloat(this.maxAge._value, this.maxAge._spread)), SPE.utils.randomFloat(this.wiggle._value, this.wiggle._spread));
};
SPE.Emitter.prototype._assignRotationValue = function(a) {
  this.attributes.rotation.typedArray.setVec3Components(a, SPE.utils.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread), SPE.utils.randomFloat(this.rotation._angle, this.rotation._angleSpread), this.rotation._static ? 0 : 1);
  this.attributes.rotationCenter.typedArray.setVec3(a, this.rotation._center);
};
SPE.Emitter.prototype._assignColorValue = function(a) {
  SPE.utils.randomColorAsHex(this.attributes.color, a, this.color._value, this.color._spread);
};
SPE.Emitter.prototype._resetParticle = function(a) {
  for (var c, g, b = this.resetFlags, e = this.updateFlags, f = this.updateCounts, k = this.attributeKeys, n = this.attributeCount - 1; 0 <= n; --n) {
    c = k[n], g = e[c], !0 !== b[c] && !0 !== g || (this._assignValue(c, a), this._updateAttributeUpdateRange(c, a), !0 === g && f[c] === this.particleCount ? (e[c] = !1, f[c] = 0) : 1 == g && ++f[c]);
  }
};
SPE.Emitter.prototype._updateAttributeUpdateRange = function(a, c) {
  a = this.bufferUpdateRanges[a];
  a.min = Math.min(c, a.min);
  a.max = Math.max(c, a.max);
};
SPE.Emitter.prototype._resetBufferRanges = function() {
  var a = this.bufferUpdateRanges, c = this.bufferUpdateKeys, g = this.bufferUpdateCount - 1;
  for (g; 0 <= g; --g) {
    var b = c[g];
    a[b].min = Number.POSITIVE_INFINITY;
    a[b].max = Number.NEGATIVE_INFINITY;
  }
};
SPE.Emitter.prototype._onRemove = function() {
  this.activeParticleCount = this.activationIndex = this.attributeOffset = this.particlesPerSecond = 0;
  this.paramsArray = this.attributes = this.group = null;
  this.age = 0;
};
SPE.Emitter.prototype._decrementParticleCount = function() {
  --this.activeParticleCount;
};
SPE.Emitter.prototype._incrementParticleCount = function() {
  ++this.activeParticleCount;
};
SPE.Emitter.prototype._checkParticleAges = function(a, c, g, b) {
  for (var e, f, k, n = c - 1; n >= a; --n) {
    c = 4 * n, k = g[c], 0 !== k && (f = g[c + 1], e = g[c + 2], 1 === this.direction ? (f += b, f >= e && (f = 0, k = 0, this._decrementParticleCount())) : (f -= b, 0 >= f && (f = e, k = 0, this._decrementParticleCount())), g[c] = k, g[c + 1] = f, this._updateAttributeUpdateRange("params", n));
  }
};
SPE.Emitter.prototype._activateParticles = function(a, c, g, b) {
  for (var e, f, k = this.direction, n = a; c > n; ++n) {
    e = 4 * n, 0 != g[e] && 1 !== this.particleCount || (this._incrementParticleCount(), g[e] = 1, this._resetParticle(n), f = b * (n - a), g[e + 1] = -1 === k ? g[e + 2] - f : f, this._updateAttributeUpdateRange("params", n));
  }
};
SPE.Emitter.prototype.tick = function(a) {
  if (!this.isStatic) {
    null === this.paramsArray && (this.paramsArray = this.attributes.params.typedArray.array);
    var c = this.attributeOffset, g = c + this.particleCount, b = this.paramsArray, e = this.particlesPerSecond * this.activeMultiplier * a, f = this.activationIndex;
    if (this._resetBufferRanges(), this._checkParticleAges(c, g, b, a), !1 === this.alive) {
      return void(this.age = 0);
    }
    if (null !== this.duration && this.age > this.duration) {
      return this.alive = !1, void(this.age = 0);
    }
    f = 1 === this.particleCount ? f : 0 | f;
    var k = Math.min(f + e, this.activationEnd), n = k - this.activationIndex | 0;
    this._activateParticles(f, k, b, 0 < n ? a / n : 0);
    this.activationIndex += e;
    this.activationIndex > g && (this.activationIndex = c);
    this.age += a;
  }
};
SPE.Emitter.prototype.reset = function(a) {
  if (this.age = 0, this.alive = !1, !0 === a) {
    for (var c = this.attributeOffset, g = this.paramsArray, b = this.attributes.params.bufferAttribute, e = c + this.particleCount - 1; e >= c; --e) {
      a = 4 * e, g[a] = 0, g[a + 1] = 0;
    }
    b.updateRange.offset = 0;
    b.updateRange.count = -1;
    b.needsUpdate = !0;
  }
  return this;
};
SPE.Emitter.prototype.enable = function() {
  return this.alive = !0, this;
};
SPE.Emitter.prototype.disable = function() {
  return this.alive = !1, this;
};
SPE.Emitter.prototype.remove = function() {
  return null !== this.group ? this.group.removeEmitter(this) : console.error("Emitter does not belong to a group, cannot remove."), this;
};
var __extends = this && this.__extends || function(a, c) {
  function g() {
    this.constructor = a;
  }
  for (var b in c) {
    c.hasOwnProperty(b) && (a[b] = c[b]);
  }
  a.prototype = null === c ? Object.create(c) : (g.prototype = c.prototype, new g);
}, spine;
(function(a) {
  var c = function() {
    function a(a, b, c) {
      if (null == a) {
        throw Error("name cannot be null.");
      }
      if (null == b) {
        throw Error("timelines cannot be null.");
      }
      this.name = a;
      this.timelines = b;
      this.duration = c;
    }
    a.prototype.apply = function(a, b, c, e, f, k, g, m) {
      if (null == a) {
        throw Error("skeleton cannot be null.");
      }
      e && 0 != this.duration && (c %= this.duration, 0 < b && (b %= this.duration));
      e = this.timelines;
      for (var d = 0, l = e.length; d < l; d++) {
        e[d].apply(a, b, c, f, k, g, m);
      }
    };
    a.binarySearch = function(a, b, c) {
      void 0 === c && (c = 1);
      var d = 0, e = a.length / c - 2;
      if (0 == e) {
        return c;
      }
      for (var f = e >>> 1;;) {
        a[(f + 1) * c] <= b ? d = f + 1 : e = f;
        if (d == e) {
          return (d + 1) * c;
        }
        f = d + e >>> 1;
      }
    };
    a.linearSearch = function(a, b, c) {
      for (var d = 0, e = a.length - c; d <= e; d += c) {
        if (a[d] > b) {
          return d;
        }
      }
      return -1;
    };
    return a;
  }();
  a.Animation = c;
  (function(a) {
    a[a.setup = 0] = "setup";
    a[a.current = 1] = "current";
    a[a.currentLayered = 2] = "currentLayered";
  })(a.MixPose || (a.MixPose = {}));
  var g = a.MixPose;
  (function(a) {
    a[a["in"] = 0] = "in";
    a[a.out = 1] = "out";
  })(a.MixDirection || (a.MixDirection = {}));
  var b = a.MixDirection;
  (function(a) {
    a[a.rotate = 0] = "rotate";
    a[a.translate = 1] = "translate";
    a[a.scale = 2] = "scale";
    a[a.shear = 3] = "shear";
    a[a.attachment = 4] = "attachment";
    a[a.color = 5] = "color";
    a[a.deform = 6] = "deform";
    a[a.event = 7] = "event";
    a[a.drawOrder = 8] = "drawOrder";
    a[a.ikConstraint = 9] = "ikConstraint";
    a[a.transformConstraint = 10] = "transformConstraint";
    a[a.pathConstraintPosition = 11] = "pathConstraintPosition";
    a[a.pathConstraintSpacing = 12] = "pathConstraintSpacing";
    a[a.pathConstraintMix = 13] = "pathConstraintMix";
    a[a.twoColor = 14] = "twoColor";
  })(a.TimelineType || (a.TimelineType = {}));
  var e = a.TimelineType, f = function() {
    function b(c) {
      if (0 >= c) {
        throw Error("frameCount must be > 0: " + c);
      }
      this.curves = a.Utils.newFloatArray((c - 1) * b.BEZIER_SIZE);
    }
    b.prototype.getFrameCount = function() {
      return this.curves.length / b.BEZIER_SIZE + 1;
    };
    b.prototype.setLinear = function(a) {
      this.curves[a * b.BEZIER_SIZE] = b.LINEAR;
    };
    b.prototype.setStepped = function(a) {
      this.curves[a * b.BEZIER_SIZE] = b.STEPPED;
    };
    b.prototype.getCurveType = function(a) {
      a *= b.BEZIER_SIZE;
      if (a == this.curves.length) {
        return b.LINEAR;
      }
      a = this.curves[a];
      return a == b.LINEAR ? b.LINEAR : a == b.STEPPED ? b.STEPPED : b.BEZIER;
    };
    b.prototype.setCurve = function(a, c, e, f, k) {
      var d = .03 * (2 * -c + f), g = .03 * (2 * -e + k);
      f = .006 * (3 * (c - f) + 1);
      k = .006 * (3 * (e - k) + 1);
      var l = 2 * d + f, m = 2 * g + k;
      c = .3 * c + d + .16666667 * f;
      e = .3 * e + g + .16666667 * k;
      a *= b.BEZIER_SIZE;
      g = this.curves;
      g[a++] = b.BEZIER;
      d = c;
      for (var n = e, t = a + b.BEZIER_SIZE - 1; a < t; a += 2) {
        g[a] = d, g[a + 1] = n, c += l, e += m, l += f, m += k, d += c, n += e;
      }
    };
    b.prototype.getCurvePercent = function(c, d) {
      d = a.MathUtils.clamp(d, 0, 1);
      var e = this.curves;
      c *= b.BEZIER_SIZE;
      var f = e[c];
      if (f == b.LINEAR) {
        return d;
      }
      if (f == b.STEPPED) {
        return 0;
      }
      c++;
      f = 0;
      for (var k = c, g = c + b.BEZIER_SIZE - 1; c < g; c += 2) {
        if (f = e[c], f >= d) {
          return c == k ? g = k = 0 : (k = e[c - 2], g = e[c - 1]), g + (e[c + 1] - g) * (d - k) / (f - k);
        }
      }
      e = e[c - 1];
      return e + (1 - e) * (d - f) / (1 - f);
    };
    b.LINEAR = 0;
    b.STEPPED = 1;
    b.BEZIER = 2;
    b.BEZIER_SIZE = 19;
    return b;
  }();
  a.CurveTimeline = f;
  var k = function(b) {
    function f(c) {
      b.call(this, c);
      this.frames = a.Utils.newFloatArray(c << 1);
    }
    __extends(f, b);
    f.prototype.getPropertyId = function() {
      return (e.rotate << 24) + this.boneIndex;
    };
    f.prototype.setFrame = function(a, b, c) {
      a <<= 1;
      this.frames[a] = b;
      this.frames[a + f.ROTATION] = c;
    };
    f.prototype.apply = function(a, b, e, k, m, n, t) {
      b = this.frames;
      a = a.bones[this.boneIndex];
      if (e < b[0]) {
        switch(n) {
          case g.setup:
            a.rotation = a.data.rotation;
            break;
          case g.current:
            n = a.data.rotation - a.rotation, a.rotation += (n - 360 * (16384 - (16384.499999999996 - n / 360 | 0))) * m;
        }
      } else {
        if (e >= b[b.length - f.ENTRIES]) {
          n == g.setup ? a.rotation = a.data.rotation + b[b.length + f.PREV_ROTATION] * m : (n = a.data.rotation + b[b.length + f.PREV_ROTATION] - a.rotation, a.rotation += (n - 360 * (16384 - (16384.499999999996 - n / 360 | 0))) * m);
        } else {
          t = c.binarySearch(b, e, f.ENTRIES);
          k = b[t + f.PREV_ROTATION];
          var d = b[t];
          e = this.getCurvePercent((t >> 1) - 1, 1 - (e - d) / (b[t + f.PREV_TIME] - d));
          b = b[t + f.ROTATION] - k;
          b = k + (b - 360 * (16384 - (16384.499999999996 - b / 360 | 0))) * e;
          n == g.setup ? a.rotation = a.data.rotation + (b - 360 * (16384 - (16384.499999999996 - b / 360 | 0))) * m : (b = a.data.rotation + b - a.rotation, a.rotation += (b - 360 * (16384 - (16384.499999999996 - b / 360 | 0))) * m);
        }
      }
    };
    f.ENTRIES = 2;
    f.PREV_TIME = -2;
    f.PREV_ROTATION = -1;
    f.ROTATION = 1;
    return f;
  }(f);
  a.RotateTimeline = k;
  k = function(b) {
    function f(c) {
      b.call(this, c);
      this.frames = a.Utils.newFloatArray(c * f.ENTRIES);
    }
    __extends(f, b);
    f.prototype.getPropertyId = function() {
      return (e.translate << 24) + this.boneIndex;
    };
    f.prototype.setFrame = function(a, b, c, e) {
      a *= f.ENTRIES;
      this.frames[a] = b;
      this.frames[a + f.X] = c;
      this.frames[a + f.Y] = e;
    };
    f.prototype.apply = function(a, b, e, k, m, n, t) {
      b = this.frames;
      a = a.bones[this.boneIndex];
      if (e < b[0]) {
        switch(n) {
          case g.setup:
            a.x = a.data.x;
            a.y = a.data.y;
            break;
          case g.current:
            a.x += (a.data.x - a.x) * m, a.y += (a.data.y - a.y) * m;
        }
      } else {
        if (e >= b[b.length - f.ENTRIES]) {
          k = b[b.length + f.PREV_X], t = b[b.length + f.PREV_Y];
        } else {
          var d = c.binarySearch(b, e, f.ENTRIES);
          k = b[d + f.PREV_X];
          t = b[d + f.PREV_Y];
          var l = b[d];
          e = this.getCurvePercent(d / f.ENTRIES - 1, 1 - (e - l) / (b[d + f.PREV_TIME] - l));
          k += (b[d + f.X] - k) * e;
          t += (b[d + f.Y] - t) * e;
        }
        n == g.setup ? (a.x = a.data.x + k * m, a.y = a.data.y + t * m) : (a.x += (a.data.x + k - a.x) * m, a.y += (a.data.y + t - a.y) * m);
      }
    };
    f.ENTRIES = 3;
    f.PREV_TIME = -3;
    f.PREV_X = -2;
    f.PREV_Y = -1;
    f.X = 1;
    f.Y = 2;
    return f;
  }(f);
  a.TranslateTimeline = k;
  var n = function(f) {
    function k(a) {
      f.call(this, a);
    }
    __extends(k, f);
    k.prototype.getPropertyId = function() {
      return (e.scale << 24) + this.boneIndex;
    };
    k.prototype.apply = function(d, e, f, m, n, t, p) {
      var l = this.frames;
      d = d.bones[this.boneIndex];
      if (f < l[0]) {
        switch(t) {
          case g.setup:
            d.scaleX = d.data.scaleX;
            d.scaleY = d.data.scaleY;
            break;
          case g.current:
            d.scaleX += (d.data.scaleX - d.scaleX) * n, d.scaleY += (d.data.scaleY - d.scaleY) * n;
        }
      } else {
        if (f >= l[l.length - k.ENTRIES]) {
          e = l[l.length + k.PREV_X] * d.data.scaleX, m = l[l.length + k.PREV_Y] * d.data.scaleY;
        } else {
          var u = c.binarySearch(l, f, k.ENTRIES);
          e = l[u + k.PREV_X];
          m = l[u + k.PREV_Y];
          var q = l[u];
          f = this.getCurvePercent(u / k.ENTRIES - 1, 1 - (f - q) / (l[u + k.PREV_TIME] - q));
          e = (e + (l[u + k.X] - e) * f) * d.data.scaleX;
          m = (m + (l[u + k.Y] - m) * f) * d.data.scaleY;
        }
        1 == n ? (d.scaleX = e, d.scaleY = m) : (t == g.setup ? (t = d.data.scaleX, f = d.data.scaleY) : (t = d.scaleX, f = d.scaleY), p == b.out ? (e = Math.abs(e) * a.MathUtils.signum(t), m = Math.abs(m) * a.MathUtils.signum(f)) : (t = Math.abs(t) * a.MathUtils.signum(e), f = Math.abs(f) * a.MathUtils.signum(m)), d.scaleX = t + (e - t) * n, d.scaleY = f + (m - f) * n);
      }
    };
    return k;
  }(k);
  a.ScaleTimeline = n;
  k = function(a) {
    function b(b) {
      a.call(this, b);
    }
    __extends(b, a);
    b.prototype.getPropertyId = function() {
      return (e.shear << 24) + this.boneIndex;
    };
    b.prototype.apply = function(a, e, f, k, m, n, t) {
      e = this.frames;
      a = a.bones[this.boneIndex];
      if (f < e[0]) {
        switch(n) {
          case g.setup:
            a.shearX = a.data.shearX;
            a.shearY = a.data.shearY;
            break;
          case g.current:
            a.shearX += (a.data.shearX - a.shearX) * m, a.shearY += (a.data.shearY - a.shearY) * m;
        }
      } else {
        if (f >= e[e.length - b.ENTRIES]) {
          k = e[e.length + b.PREV_X], t = e[e.length + b.PREV_Y];
        } else {
          var d = c.binarySearch(e, f, b.ENTRIES);
          k = e[d + b.PREV_X];
          t = e[d + b.PREV_Y];
          var l = e[d];
          f = this.getCurvePercent(d / b.ENTRIES - 1, 1 - (f - l) / (e[d + b.PREV_TIME] - l));
          k += (e[d + b.X] - k) * f;
          t += (e[d + b.Y] - t) * f;
        }
        n == g.setup ? (a.shearX = a.data.shearX + k * m, a.shearY = a.data.shearY + t * m) : (a.shearX += (a.data.shearX + k - a.shearX) * m, a.shearY += (a.data.shearY + t - a.shearY) * m);
      }
    };
    return b;
  }(k);
  a.ShearTimeline = k;
  k = function(b) {
    function f(c) {
      b.call(this, c);
      this.frames = a.Utils.newFloatArray(c * f.ENTRIES);
    }
    __extends(f, b);
    f.prototype.getPropertyId = function() {
      return (e.color << 24) + this.slotIndex;
    };
    f.prototype.setFrame = function(a, b, c, e, k, g) {
      a *= f.ENTRIES;
      this.frames[a] = b;
      this.frames[a + f.R] = c;
      this.frames[a + f.G] = e;
      this.frames[a + f.B] = k;
      this.frames[a + f.A] = g;
    };
    f.prototype.apply = function(a, b, e, k, m, n, t) {
      a = a.slots[this.slotIndex];
      var d = this.frames;
      if (e < d[0]) {
        switch(n) {
          case g.setup:
            a.color.setFromColor(a.data.color);
            break;
          case g.current:
            e = a.color, n = a.data.color, e.add((n.r - e.r) * m, (n.g - e.g) * m, (n.b - e.b) * m, (n.a - e.a) * m);
        }
      } else {
        if (e >= d[d.length - f.ENTRIES]) {
          e = d.length;
          b = d[e + f.PREV_R];
          k = d[e + f.PREV_G];
          t = d[e + f.PREV_B];
          var l = d[e + f.PREV_A];
        } else {
          var p = c.binarySearch(d, e, f.ENTRIES);
          b = d[p + f.PREV_R];
          k = d[p + f.PREV_G];
          t = d[p + f.PREV_B];
          l = d[p + f.PREV_A];
          var u = d[p];
          e = this.getCurvePercent(p / f.ENTRIES - 1, 1 - (e - u) / (d[p + f.PREV_TIME] - u));
          b += (d[p + f.R] - b) * e;
          k += (d[p + f.G] - k) * e;
          t += (d[p + f.B] - t) * e;
          l += (d[p + f.A] - l) * e;
        }
        1 == m ? a.color.set(b, k, t, l) : (e = a.color, n == g.setup && e.setFromColor(a.data.color), e.add((b - e.r) * m, (k - e.g) * m, (t - e.b) * m, (l - e.a) * m));
      }
    };
    f.ENTRIES = 5;
    f.PREV_TIME = -5;
    f.PREV_R = -4;
    f.PREV_G = -3;
    f.PREV_B = -2;
    f.PREV_A = -1;
    f.R = 1;
    f.G = 2;
    f.B = 3;
    f.A = 4;
    return f;
  }(f);
  a.ColorTimeline = k;
  k = function(b) {
    function f(c) {
      b.call(this, c);
      this.frames = a.Utils.newFloatArray(c * f.ENTRIES);
    }
    __extends(f, b);
    f.prototype.getPropertyId = function() {
      return (e.twoColor << 24) + this.slotIndex;
    };
    f.prototype.setFrame = function(a, b, c, e, k, g, m, n, t) {
      a *= f.ENTRIES;
      this.frames[a] = b;
      this.frames[a + f.R] = c;
      this.frames[a + f.G] = e;
      this.frames[a + f.B] = k;
      this.frames[a + f.A] = g;
      this.frames[a + f.R2] = m;
      this.frames[a + f.G2] = n;
      this.frames[a + f.B2] = t;
    };
    f.prototype.apply = function(a, b, e, k, m, n, t) {
      a = a.slots[this.slotIndex];
      var d = this.frames;
      if (e < d[0]) {
        switch(n) {
          case g.setup:
            a.color.setFromColor(a.data.color);
            a.darkColor.setFromColor(a.data.darkColor);
            break;
          case g.current:
            e = a.color, d = a.darkColor, n = a.data.color, a = a.data.darkColor, e.add((n.r - e.r) * m, (n.g - e.g) * m, (n.b - e.b) * m, (n.a - e.a) * m), d.add((a.r - d.r) * m, (a.g - d.g) * m, (a.b - d.b) * m, 0);
        }
      } else {
        if (e >= d[d.length - f.ENTRIES]) {
          e = d.length;
          b = d[e + f.PREV_R];
          k = d[e + f.PREV_G];
          t = d[e + f.PREV_B];
          var l = d[e + f.PREV_A];
          var p = d[e + f.PREV_R2];
          var u = d[e + f.PREV_G2];
          var q = d[e + f.PREV_B2];
        } else {
          var w = c.binarySearch(d, e, f.ENTRIES);
          b = d[w + f.PREV_R];
          k = d[w + f.PREV_G];
          t = d[w + f.PREV_B];
          l = d[w + f.PREV_A];
          p = d[w + f.PREV_R2];
          u = d[w + f.PREV_G2];
          q = d[w + f.PREV_B2];
          var y = d[w];
          e = this.getCurvePercent(w / f.ENTRIES - 1, 1 - (e - y) / (d[w + f.PREV_TIME] - y));
          b += (d[w + f.R] - b) * e;
          k += (d[w + f.G] - k) * e;
          t += (d[w + f.B] - t) * e;
          l += (d[w + f.A] - l) * e;
          p += (d[w + f.R2] - p) * e;
          u += (d[w + f.G2] - u) * e;
          q += (d[w + f.B2] - q) * e;
        }
        1 == m ? (a.color.set(b, k, t, l), a.darkColor.set(p, u, q, 1)) : (e = a.color, d = a.darkColor, n == g.setup && (e.setFromColor(a.data.color), d.setFromColor(a.data.darkColor)), e.add((b - e.r) * m, (k - e.g) * m, (t - e.b) * m, (l - e.a) * m), d.add((p - d.r) * m, (u - d.g) * m, (q - d.b) * m, 0));
      }
    };
    f.ENTRIES = 8;
    f.PREV_TIME = -8;
    f.PREV_R = -7;
    f.PREV_G = -6;
    f.PREV_B = -5;
    f.PREV_A = -4;
    f.PREV_R2 = -3;
    f.PREV_G2 = -2;
    f.PREV_B2 = -1;
    f.R = 1;
    f.G = 2;
    f.B = 3;
    f.A = 4;
    f.R2 = 5;
    f.G2 = 6;
    f.B2 = 7;
    return f;
  }(f);
  a.TwoColorTimeline = k;
  k = function() {
    function f(b) {
      this.frames = a.Utils.newFloatArray(b);
      this.attachmentNames = Array(b);
    }
    f.prototype.getPropertyId = function() {
      return (e.attachment << 24) + this.slotIndex;
    };
    f.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    f.prototype.setFrame = function(a, b, c) {
      this.frames[a] = b;
      this.attachmentNames[a] = c;
    };
    f.prototype.apply = function(a, d, e, f, k, m, n) {
      d = a.slots[this.slotIndex];
      n == b.out && m == g.setup ? (e = d.data.attachmentName, d.setAttachment(null == e ? null : a.getAttachment(this.slotIndex, e))) : (n = this.frames, e < n[0] ? m == g.setup && (e = d.data.attachmentName, d.setAttachment(null == e ? null : a.getAttachment(this.slotIndex, e))) : (e = e >= n[n.length - 1] ? n.length - 1 : c.binarySearch(n, e, 1) - 1, e = this.attachmentNames[e], a.slots[this.slotIndex].setAttachment(null == e ? null : a.getAttachment(this.slotIndex, e))));
    };
    return f;
  }();
  a.AttachmentTimeline = k;
  var p = null;
  k = function(b) {
    function f(c) {
      b.call(this, c);
      this.frames = a.Utils.newFloatArray(c);
      this.frameVertices = Array(c);
      null == p && (p = a.Utils.newFloatArray(64));
    }
    __extends(f, b);
    f.prototype.getPropertyId = function() {
      return (e.deform << 27) + +this.attachment.id + this.slotIndex;
    };
    f.prototype.setFrame = function(a, b, c) {
      this.frames[a] = b;
      this.frameVertices[a] = c;
    };
    f.prototype.apply = function(b, e, f, k, m, n, t) {
      b = b.slots[this.slotIndex];
      var d = b.getAttachment();
      if (d instanceof a.VertexAttachment && d.applyDeform(this.attachment)) {
        e = b.attachmentVertices;
        0 == e.length && (m = 1);
        t = this.frameVertices;
        b = t[0].length;
        var l = this.frames;
        if (f < l[0]) {
          switch(n) {
            case g.setup:
              e.length = 0;
              break;
            case g.current:
              if (1 == m) {
                e.length = 0;
              } else {
                if (e = a.Utils.setArraySize(e, b), null == d.bones) {
                  for (n = d.vertices, k = 0; k < b; k++) {
                    e[k] += (n[k] - e[k]) * m;
                  }
                } else {
                  for (m = 1 - m, k = 0; k < b; k++) {
                    e[k] *= m;
                  }
                }
              }
          }
        } else {
          if (e = a.Utils.setArraySize(e, b), f >= l[l.length - 1]) {
            if (k = t[l.length - 1], 1 == m) {
              a.Utils.arrayCopy(k, 0, e, 0, b);
            } else {
              if (n == g.setup) {
                if (null == d.bones) {
                  for (t = d.vertices, f = 0; f < b; f++) {
                    n = t[f], e[f] = n + (k[f] - n) * m;
                  }
                } else {
                  for (n = 0; n < b; n++) {
                    e[n] = k[n] * m;
                  }
                }
              } else {
                for (n = 0; n < b; n++) {
                  e[n] += (k[n] - e[n]) * m;
                }
              }
            }
          } else {
            var p = c.binarySearch(l, f);
            k = t[p - 1];
            t = t[p];
            var u = l[p];
            f = this.getCurvePercent(p - 1, 1 - (f - u) / (l[p - 1] - u));
            if (1 == m) {
              for (m = 0; m < b; m++) {
                d = k[m], e[m] = d + (t[m] - d) * f;
              }
            } else {
              if (n == g.setup) {
                if (null == d.bones) {
                  for (l = d.vertices, p = 0; p < b; p++) {
                    d = k[p], n = l[p], e[p] = n + (d + (t[p] - d) * f - n) * m;
                  }
                } else {
                  for (n = 0; n < b; n++) {
                    d = k[n], e[n] = (d + (t[n] - d) * f) * m;
                  }
                }
              } else {
                for (n = 0; n < b; n++) {
                  d = k[n], e[n] += (d + (t[n] - d) * f - e[n]) * m;
                }
              }
            }
          }
        }
      }
    };
    return f;
  }(f);
  a.DeformTimeline = k;
  k = function() {
    function b(b) {
      this.frames = a.Utils.newFloatArray(b);
      this.events = Array(b);
    }
    b.prototype.getPropertyId = function() {
      return e.event << 24;
    };
    b.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    b.prototype.setFrame = function(a, b) {
      this.frames[a] = b.time;
      this.events[a] = b;
    };
    b.prototype.apply = function(a, b, e, f, k, g, m) {
      if (null != f) {
        var d = this.frames, l = this.frames.length;
        if (b > e) {
          this.apply(a, b, Number.MAX_VALUE, f, k, g, m), b = -1;
        } else {
          if (b >= d[l - 1]) {
            return;
          }
        }
        if (!(e < d[0])) {
          if (b < d[0]) {
            a = 0;
          } else {
            for (a = c.binarySearch(d, b), b = d[a]; 0 < a && d[a - 1] == b;) {
              a--;
            }
          }
          for (; a < l && e >= d[a]; a++) {
            f.push(this.events[a]);
          }
        }
      }
    };
    return b;
  }();
  a.EventTimeline = k;
  k = function() {
    function f(b) {
      this.frames = a.Utils.newFloatArray(b);
      this.drawOrders = Array(b);
    }
    f.prototype.getPropertyId = function() {
      return e.drawOrder << 24;
    };
    f.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    f.prototype.setFrame = function(a, b, c) {
      this.frames[a] = b;
      this.drawOrders[a] = c;
    };
    f.prototype.apply = function(e, d, f, k, m, n, p) {
      d = e.drawOrder;
      k = e.slots;
      if (p == b.out && n == g.setup) {
        a.Utils.arrayCopy(e.slots, 0, e.drawOrder, 0, e.slots.length);
      } else {
        if (p = this.frames, f < p[0]) {
          n == g.setup && a.Utils.arrayCopy(e.slots, 0, e.drawOrder, 0, e.slots.length);
        } else {
          if (e = f >= p[p.length - 1] ? p.length - 1 : c.binarySearch(p, f) - 1, e = this.drawOrders[e], null == e) {
            a.Utils.arrayCopy(k, 0, d, 0, k.length);
          } else {
            for (f = 0, n = e.length; f < n; f++) {
              d[f] = k[e[f]];
            }
          }
        }
      }
    };
    return f;
  }();
  a.DrawOrderTimeline = k;
  k = function(f) {
    function k(b) {
      f.call(this, b);
      this.frames = a.Utils.newFloatArray(b * k.ENTRIES);
    }
    __extends(k, f);
    k.prototype.getPropertyId = function() {
      return (e.ikConstraint << 24) + this.ikConstraintIndex;
    };
    k.prototype.setFrame = function(a, b, c, e) {
      a *= k.ENTRIES;
      this.frames[a] = b;
      this.frames[a + k.MIX] = c;
      this.frames[a + k.BEND_DIRECTION] = e;
    };
    k.prototype.apply = function(a, e, f, n, m, t, p) {
      e = this.frames;
      a = a.ikConstraints[this.ikConstraintIndex];
      if (f < e[0]) {
        switch(t) {
          case g.setup:
            a.mix = a.data.mix;
            a.bendDirection = a.data.bendDirection;
            break;
          case g.current:
            a.mix += (a.data.mix - a.mix) * m, a.bendDirection = a.data.bendDirection;
        }
      } else {
        if (f >= e[e.length - k.ENTRIES]) {
          t == g.setup ? (a.mix = a.data.mix + (e[e.length + k.PREV_MIX] - a.data.mix) * m, a.bendDirection = p == b.out ? a.data.bendDirection : e[e.length + k.PREV_BEND_DIRECTION]) : (a.mix += (e[e.length + k.PREV_MIX] - a.mix) * m, p == b.in && (a.bendDirection = e[e.length + k.PREV_BEND_DIRECTION]));
        } else {
          n = c.binarySearch(e, f, k.ENTRIES);
          var d = e[n + k.PREV_MIX], l = e[n];
          f = this.getCurvePercent(n / k.ENTRIES - 1, 1 - (f - l) / (e[n + k.PREV_TIME] - l));
          t == g.setup ? (a.mix = a.data.mix + (d + (e[n + k.MIX] - d) * f - a.data.mix) * m, a.bendDirection = p == b.out ? a.data.bendDirection : e[n + k.PREV_BEND_DIRECTION]) : (a.mix += (d + (e[n + k.MIX] - d) * f - a.mix) * m, p == b.in && (a.bendDirection = e[n + k.PREV_BEND_DIRECTION]));
        }
      }
    };
    k.ENTRIES = 3;
    k.PREV_TIME = -3;
    k.PREV_MIX = -2;
    k.PREV_BEND_DIRECTION = -1;
    k.MIX = 1;
    k.BEND_DIRECTION = 2;
    return k;
  }(f);
  a.IkConstraintTimeline = k;
  k = function(b) {
    function f(c) {
      b.call(this, c);
      this.frames = a.Utils.newFloatArray(c * f.ENTRIES);
    }
    __extends(f, b);
    f.prototype.getPropertyId = function() {
      return (e.transformConstraint << 24) + this.transformConstraintIndex;
    };
    f.prototype.setFrame = function(a, b, c, e, k, g) {
      a *= f.ENTRIES;
      this.frames[a] = b;
      this.frames[a + f.ROTATE] = c;
      this.frames[a + f.TRANSLATE] = e;
      this.frames[a + f.SCALE] = k;
      this.frames[a + f.SHEAR] = g;
    };
    f.prototype.apply = function(a, b, e, k, n, m, t) {
      b = this.frames;
      a = a.transformConstraints[this.transformConstraintIndex];
      if (e < b[0]) {
        switch(e = a.data, m) {
          case g.setup:
            a.rotateMix = e.rotateMix;
            a.translateMix = e.translateMix;
            a.scaleMix = e.scaleMix;
            a.shearMix = e.shearMix;
            break;
          case g.current:
            a.rotateMix += (e.rotateMix - a.rotateMix) * n, a.translateMix += (e.translateMix - a.translateMix) * n, a.scaleMix += (e.scaleMix - a.scaleMix) * n, a.shearMix += (e.shearMix - a.shearMix) * n;
        }
      } else {
        if (e >= b[b.length - f.ENTRIES]) {
          e = b.length;
          k = b[e + f.PREV_ROTATE];
          t = b[e + f.PREV_TRANSLATE];
          var d = b[e + f.PREV_SCALE];
          var l = b[e + f.PREV_SHEAR];
        } else {
          var p = c.binarySearch(b, e, f.ENTRIES);
          k = b[p + f.PREV_ROTATE];
          t = b[p + f.PREV_TRANSLATE];
          d = b[p + f.PREV_SCALE];
          l = b[p + f.PREV_SHEAR];
          var u = b[p];
          e = this.getCurvePercent(p / f.ENTRIES - 1, 1 - (e - u) / (b[p + f.PREV_TIME] - u));
          k += (b[p + f.ROTATE] - k) * e;
          t += (b[p + f.TRANSLATE] - t) * e;
          d += (b[p + f.SCALE] - d) * e;
          l += (b[p + f.SHEAR] - l) * e;
        }
        m == g.setup ? (e = a.data, a.rotateMix = e.rotateMix + (k - e.rotateMix) * n, a.translateMix = e.translateMix + (t - e.translateMix) * n, a.scaleMix = e.scaleMix + (d - e.scaleMix) * n, a.shearMix = e.shearMix + (l - e.shearMix) * n) : (a.rotateMix += (k - a.rotateMix) * n, a.translateMix += (t - a.translateMix) * n, a.scaleMix += (d - a.scaleMix) * n, a.shearMix += (l - a.shearMix) * n);
      }
    };
    f.ENTRIES = 5;
    f.PREV_TIME = -5;
    f.PREV_ROTATE = -4;
    f.PREV_TRANSLATE = -3;
    f.PREV_SCALE = -2;
    f.PREV_SHEAR = -1;
    f.ROTATE = 1;
    f.TRANSLATE = 2;
    f.SCALE = 3;
    f.SHEAR = 4;
    return f;
  }(f);
  a.TransformConstraintTimeline = k;
  k = function(b) {
    function f(c) {
      b.call(this, c);
      this.frames = a.Utils.newFloatArray(c * f.ENTRIES);
    }
    __extends(f, b);
    f.prototype.getPropertyId = function() {
      return (e.pathConstraintPosition << 24) + this.pathConstraintIndex;
    };
    f.prototype.setFrame = function(a, b, c) {
      a *= f.ENTRIES;
      this.frames[a] = b;
      this.frames[a + f.VALUE] = c;
    };
    f.prototype.apply = function(a, b, e, k, n, m, p) {
      b = this.frames;
      a = a.pathConstraints[this.pathConstraintIndex];
      if (e < b[0]) {
        switch(m) {
          case g.setup:
            a.position = a.data.position;
            break;
          case g.current:
            a.position += (a.data.position - a.position) * n;
        }
      } else {
        if (e >= b[b.length - f.ENTRIES]) {
          k = b[b.length + f.PREV_VALUE];
        } else {
          p = c.binarySearch(b, e, f.ENTRIES);
          k = b[p + f.PREV_VALUE];
          var d = b[p];
          e = this.getCurvePercent(p / f.ENTRIES - 1, 1 - (e - d) / (b[p + f.PREV_TIME] - d));
          k += (b[p + f.VALUE] - k) * e;
        }
        a.position = m == g.setup ? a.data.position + (k - a.data.position) * n : a.position + (k - a.position) * n;
      }
    };
    f.ENTRIES = 2;
    f.PREV_TIME = -2;
    f.PREV_VALUE = -1;
    f.VALUE = 1;
    return f;
  }(f);
  a.PathConstraintPositionTimeline = k;
  k = function(a) {
    function b(b) {
      a.call(this, b);
    }
    __extends(b, a);
    b.prototype.getPropertyId = function() {
      return (e.pathConstraintSpacing << 24) + this.pathConstraintIndex;
    };
    b.prototype.apply = function(a, e, f, k, n, m, p) {
      e = this.frames;
      a = a.pathConstraints[this.pathConstraintIndex];
      if (f < e[0]) {
        switch(m) {
          case g.setup:
            a.spacing = a.data.spacing;
            break;
          case g.current:
            a.spacing += (a.data.spacing - a.spacing) * n;
        }
      } else {
        if (f >= e[e.length - b.ENTRIES]) {
          k = e[e.length + b.PREV_VALUE];
        } else {
          p = c.binarySearch(e, f, b.ENTRIES);
          k = e[p + b.PREV_VALUE];
          var d = e[p];
          f = this.getCurvePercent(p / b.ENTRIES - 1, 1 - (f - d) / (e[p + b.PREV_TIME] - d));
          k += (e[p + b.VALUE] - k) * f;
        }
        a.spacing = m == g.setup ? a.data.spacing + (k - a.data.spacing) * n : a.spacing + (k - a.spacing) * n;
      }
    };
    return b;
  }(k);
  a.PathConstraintSpacingTimeline = k;
  f = function(b) {
    function f(c) {
      b.call(this, c);
      this.frames = a.Utils.newFloatArray(c * f.ENTRIES);
    }
    __extends(f, b);
    f.prototype.getPropertyId = function() {
      return (e.pathConstraintMix << 24) + this.pathConstraintIndex;
    };
    f.prototype.setFrame = function(a, b, c, e) {
      a *= f.ENTRIES;
      this.frames[a] = b;
      this.frames[a + f.ROTATE] = c;
      this.frames[a + f.TRANSLATE] = e;
    };
    f.prototype.apply = function(a, b, e, k, n, m, p) {
      b = this.frames;
      a = a.pathConstraints[this.pathConstraintIndex];
      if (e < b[0]) {
        switch(m) {
          case g.setup:
            a.rotateMix = a.data.rotateMix;
            a.translateMix = a.data.translateMix;
            break;
          case g.current:
            a.rotateMix += (a.data.rotateMix - a.rotateMix) * n, a.translateMix += (a.data.translateMix - a.translateMix) * n;
        }
      } else {
        if (e >= b[b.length - f.ENTRIES]) {
          k = b[b.length + f.PREV_ROTATE], p = b[b.length + f.PREV_TRANSLATE];
        } else {
          var d = c.binarySearch(b, e, f.ENTRIES);
          k = b[d + f.PREV_ROTATE];
          p = b[d + f.PREV_TRANSLATE];
          var l = b[d];
          e = this.getCurvePercent(d / f.ENTRIES - 1, 1 - (e - l) / (b[d + f.PREV_TIME] - l));
          k += (b[d + f.ROTATE] - k) * e;
          p += (b[d + f.TRANSLATE] - p) * e;
        }
        m == g.setup ? (a.rotateMix = a.data.rotateMix + (k - a.data.rotateMix) * n, a.translateMix = a.data.translateMix + (p - a.data.translateMix) * n) : (a.rotateMix += (k - a.rotateMix) * n, a.translateMix += (p - a.translateMix) * n);
      }
    };
    f.ENTRIES = 3;
    f.PREV_TIME = -3;
    f.PREV_ROTATE = -2;
    f.PREV_TRANSLATE = -1;
    f.ROTATE = 1;
    f.TRANSLATE = 2;
    return f;
  }(f);
  a.PathConstraintMixTimeline = f;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function c(c) {
      this.tracks = [];
      this.events = [];
      this.listeners = [];
      this.queue = new b(this);
      this.propertyIDs = new a.IntSet;
      this.mixingTo = [];
      this.animationsChanged = !1;
      this.timeScale = 1;
      this.trackEntryPool = new a.Pool(function() {
        return new g;
      });
      this.data = c;
    }
    c.prototype.update = function(a) {
      a *= this.timeScale;
      for (var b = this.tracks, c = 0, e = b.length; c < e; c++) {
        var d = b[c];
        if (null != d) {
          d.animationLast = d.nextAnimationLast;
          d.trackLast = d.nextTrackLast;
          var f = a * d.timeScale;
          if (0 < d.delay) {
            d.delay -= f;
            if (0 < d.delay) {
              continue;
            }
            f = -d.delay;
            d.delay = 0;
          }
          var k = d.next;
          if (null != k) {
            var g = d.trackLast - k.delay;
            if (0 <= g) {
              k.delay = 0;
              k.trackTime = g + a * k.timeScale;
              d.trackTime += f;
              for (this.setCurrent(c, k, !0); null != k.mixingFrom;) {
                k.mixTime += f, k = k.mixingFrom;
              }
              continue;
            }
          } else {
            if (d.trackLast >= d.trackEnd && null == d.mixingFrom) {
              b[c] = null;
              this.queue.end(d);
              this.disposeNext(d);
              continue;
            }
          }
          if (null != d.mixingFrom && this.updateMixingFrom(d, a)) {
            for (k = d.mixingFrom, d.mixingFrom = null; null != k;) {
              this.queue.end(k), k = k.mixingFrom;
            }
          }
          d.trackTime += f;
        }
      }
      this.queue.drain();
    };
    c.prototype.updateMixingFrom = function(a, b) {
      var c = a.mixingFrom;
      if (null == c) {
        return !0;
      }
      var e = this.updateMixingFrom(c, b);
      if (0 < a.mixTime && (a.mixTime >= a.mixDuration || 0 == a.timeScale)) {
        if (0 == c.totalAlpha || 0 == a.mixDuration) {
          a.mixingFrom = c.mixingFrom, a.interruptAlpha = c.interruptAlpha, this.queue.end(c);
        }
        return e;
      }
      c.animationLast = c.nextAnimationLast;
      c.trackLast = c.nextTrackLast;
      c.trackTime += b * c.timeScale;
      a.mixTime += b * a.timeScale;
      return !1;
    };
    c.prototype.apply = function(b) {
      if (null == b) {
        throw Error("skeleton cannot be null.");
      }
      this.animationsChanged && this._animationsChanged();
      for (var e = this.events, f = this.tracks, k = !1, d = 0, g = f.length; d < g; d++) {
        var n = f[d];
        if (!(null == n || 0 < n.delay)) {
          k = !0;
          var w = 0 == d ? a.MixPose.current : a.MixPose.currentLayered, y = n.alpha;
          null != n.mixingFrom ? y *= this.applyMixingFrom(n, b, w) : n.trackTime >= n.trackEnd && null == n.next && (y = 0);
          var x = n.animationLast, q = n.getAnimationTime(), v = n.animation.timelines.length, z = n.animation.timelines;
          if (1 == y) {
            for (var C = 0; C < v; C++) {
              z[C].apply(b, x, q, e, 1, a.MixPose.setup, a.MixDirection.in);
            }
          } else {
            var A = n.timelineData, D = 0 == n.timelinesRotation.length;
            D && a.Utils.setArraySize(n.timelinesRotation, v << 1, null);
            var E = n.timelinesRotation;
            for (C = 0; C < v; C++) {
              var B = z[C], G = A[C] >= c.FIRST ? a.MixPose.setup : w;
              B instanceof a.RotateTimeline ? this.applyRotateTimeline(B, b, q, y, G, E, C << 1, D) : B.apply(b, x, q, e, y, G, a.MixDirection.in);
            }
          }
          this.queueEvents(n, q);
          e.length = 0;
          n.nextAnimationLast = q;
          n.nextTrackLast = n.trackTime;
        }
      }
      this.queue.drain();
      return k;
    };
    c.prototype.applyMixingFrom = function(b, e, f) {
      var k = b.mixingFrom;
      null != k.mixingFrom && this.applyMixingFrom(k, e, f);
      if (0 == b.mixDuration) {
        var d = 1;
      } else {
        d = b.mixTime / b.mixDuration, 1 < d && (d = 1);
      }
      var g = d < k.eventThreshold ? this.events : null, n = d < k.attachmentThreshold, m = d < k.drawOrderThreshold, p = k.animationLast, x = k.getAnimationTime(), q = k.animation.timelines.length, v = k.animation.timelines, z = k.timelineData, C = k.timelineDipMix, A = 0 == k.timelinesRotation.length;
      A && a.Utils.setArraySize(k.timelinesRotation, q << 1, null);
      for (var D = k.timelinesRotation, E, B = k.alpha * b.interruptAlpha, G = B * (1 - d), H, K = k.totalAlpha = 0; K < q; K++) {
        var I = v[K];
        switch(z[K]) {
          case c.SUBSEQUENT:
            if (!n && I instanceof a.AttachmentTimeline) {
              continue;
            }
            if (!m && I instanceof a.DrawOrderTimeline) {
              continue;
            }
            E = f;
            H = G;
            break;
          case c.FIRST:
            E = a.MixPose.setup;
            H = G;
            break;
          case c.DIP:
            E = a.MixPose.setup;
            H = B;
            break;
          default:
            E = a.MixPose.setup;
            H = B;
            var L = C[K];
            H *= Math.max(0, 1 - L.mixTime / L.mixDuration);
        }
        k.totalAlpha += H;
        I instanceof a.RotateTimeline ? this.applyRotateTimeline(I, e, x, H, E, D, K << 1, A) : I.apply(e, p, x, g, H, E, a.MixDirection.out);
      }
      0 < b.mixDuration && this.queueEvents(k, x);
      this.events.length = 0;
      k.nextAnimationLast = x;
      k.nextTrackLast = k.trackTime;
      return d;
    };
    c.prototype.applyRotateTimeline = function(b, c, e, f, d, k, g, w) {
      w && (k[g] = 0);
      if (1 == f) {
        b.apply(c, 0, e, null, 1, d, a.MixDirection.in);
      } else {
        var l = b.frames;
        c = c.bones[b.boneIndex];
        if (e < l[0]) {
          d == a.MixPose.setup && (c.rotation = c.data.rotation);
        } else {
          if (e >= l[l.length - a.RotateTimeline.ENTRIES]) {
            l = c.data.rotation + l[l.length + a.RotateTimeline.PREV_ROTATION];
          } else {
            var n = a.Animation.binarySearch(l, e, a.RotateTimeline.ENTRIES), m = l[n + a.RotateTimeline.PREV_ROTATION], p = l[n];
            b = b.getCurvePercent((n >> 1) - 1, 1 - (e - p) / (l[n + a.RotateTimeline.PREV_TIME] - p));
            l = l[n + a.RotateTimeline.ROTATION] - m;
            l = m + (l - 360 * (16384 - (16384.499999999996 - l / 360 | 0))) * b + c.data.rotation;
            l -= 360 * (16384 - (16384.499999999996 - l / 360 | 0));
          }
          d = d == a.MixPose.setup ? c.data.rotation : c.rotation;
          l -= d;
          0 == l ? e = k[g] : (l -= 360 * (16384 - (16384.499999999996 - l / 360 | 0)), w ? (w = 0, e = l) : (w = k[g], e = k[g + 1]), m = 0 < l, b = 0 <= w, a.MathUtils.signum(e) != a.MathUtils.signum(l) && 90 >= Math.abs(e) && (180 < Math.abs(w) && (w += 360 * a.MathUtils.signum(w)), b = m), e = l + w - w % 360, b != m && (e += 360 * a.MathUtils.signum(w)), k[g] = e);
          k[g + 1] = l;
          d += e * f;
          c.rotation = d - 360 * (16384 - (16384.499999999996 - d / 360 | 0));
        }
      }
    };
    c.prototype.queueEvents = function(a, b) {
      for (var c = a.animationStart, e = a.animationEnd, d = e - c, f = a.trackLast % d, k = this.events, g = 0, n = k.length; g < n; g++) {
        var p = k[g];
        if (p.time < f) {
          break;
        }
        p.time > e || this.queue.event(a, p);
      }
      for ((a.loop ? f > a.trackTime % d : b >= e && a.animationLast < e) && this.queue.complete(a); g < n; g++) {
        k[g].time < c || this.queue.event(a, k[g]);
      }
    };
    c.prototype.clearTracks = function() {
      var a = this.queue.drainDisabled;
      this.queue.drainDisabled = !0;
      for (var b = 0, c = this.tracks.length; b < c; b++) {
        this.clearTrack(b);
      }
      this.tracks.length = 0;
      this.queue.drainDisabled = a;
      this.queue.drain();
    };
    c.prototype.clearTrack = function(a) {
      if (!(a >= this.tracks.length) && (a = this.tracks[a], null != a)) {
        this.queue.end(a);
        this.disposeNext(a);
        for (var b = a;;) {
          var c = b.mixingFrom;
          if (null == c) {
            break;
          }
          this.queue.end(c);
          b.mixingFrom = null;
          b = c;
        }
        this.tracks[a.trackIndex] = null;
        this.queue.drain();
      }
    };
    c.prototype.setCurrent = function(a, b, c) {
      var e = this.expandToIndex(a);
      this.tracks[a] = b;
      null != e && (c && this.queue.interrupt(e), b.mixingFrom = e, b.mixTime = 0, null != e.mixingFrom && 0 < e.mixDuration && (b.interruptAlpha *= Math.min(1, e.mixTime / e.mixDuration)), e.timelinesRotation.length = 0);
      this.queue.start(b);
    };
    c.prototype.setAnimation = function(a, b, c) {
      var e = this.data.skeletonData.findAnimation(b);
      if (null == e) {
        throw Error("Animation not found: " + b);
      }
      return this.setAnimationWith(a, e, c);
    };
    c.prototype.setAnimationWith = function(a, b, c) {
      if (null == b) {
        throw Error("animation cannot be null.");
      }
      var e = !0, d = this.expandToIndex(a);
      null != d && (-1 == d.nextTrackLast ? (this.tracks[a] = d.mixingFrom, this.queue.interrupt(d), this.queue.end(d), this.disposeNext(d), d = d.mixingFrom, e = !1) : this.disposeNext(d));
      b = this.trackEntry(a, b, c, d);
      this.setCurrent(a, b, e);
      this.queue.drain();
      return b;
    };
    c.prototype.addAnimation = function(a, b, c, e) {
      var d = this.data.skeletonData.findAnimation(b);
      if (null == d) {
        throw Error("Animation not found: " + b);
      }
      return this.addAnimationWith(a, d, c, e);
    };
    c.prototype.addAnimationWith = function(a, b, c, e) {
      if (null == b) {
        throw Error("animation cannot be null.");
      }
      var d = this.expandToIndex(a);
      if (null != d) {
        for (; null != d.next;) {
          d = d.next;
        }
      }
      c = this.trackEntry(a, b, c, d);
      null == d ? (this.setCurrent(a, c, !0), this.queue.drain()) : (d.next = c, 0 >= e && (a = d.animationEnd - d.animationStart, e = 0 != a ? e + (a * (1 + (d.trackTime / a | 0)) - this.data.getMix(d.animation, b)) : 0));
      c.delay = e;
      return c;
    };
    c.prototype.setEmptyAnimation = function(a, b) {
      a = this.setAnimationWith(a, c.emptyAnimation, !1);
      a.mixDuration = b;
      a.trackEnd = b;
      return a;
    };
    c.prototype.addEmptyAnimation = function(a, b, e) {
      0 >= e && (e -= b);
      a = this.addAnimationWith(a, c.emptyAnimation, !1, e);
      a.mixDuration = b;
      a.trackEnd = b;
      return a;
    };
    c.prototype.setEmptyAnimations = function(a) {
      var b = this.queue.drainDisabled;
      this.queue.drainDisabled = !0;
      for (var c = 0, e = this.tracks.length; c < e; c++) {
        var d = this.tracks[c];
        null != d && this.setEmptyAnimation(d.trackIndex, a);
      }
      this.queue.drainDisabled = b;
      this.queue.drain();
    };
    c.prototype.expandToIndex = function(b) {
      if (b < this.tracks.length) {
        return this.tracks[b];
      }
      a.Utils.ensureArrayCapacity(this.tracks, b - this.tracks.length + 1, null);
      this.tracks.length = b + 1;
      return null;
    };
    c.prototype.trackEntry = function(a, b, c, e) {
      var d = this.trackEntryPool.obtain();
      d.trackIndex = a;
      d.animation = b;
      d.loop = c;
      d.eventThreshold = 0;
      d.attachmentThreshold = 0;
      d.drawOrderThreshold = 0;
      d.animationStart = 0;
      d.animationEnd = b.duration;
      d.animationLast = -1;
      d.nextAnimationLast = -1;
      d.delay = 0;
      d.trackTime = 0;
      d.trackLast = -1;
      d.nextTrackLast = -1;
      d.trackEnd = Number.MAX_VALUE;
      d.timeScale = 1;
      d.alpha = 1;
      d.interruptAlpha = 1;
      d.mixTime = 0;
      d.mixDuration = null == e ? 0 : this.data.getMix(e.animation, b);
      return d;
    };
    c.prototype.disposeNext = function(a) {
      for (var b = a.next; null != b;) {
        this.queue.dispose(b), b = b.next;
      }
      a.next = null;
    };
    c.prototype._animationsChanged = function() {
      this.animationsChanged = !1;
      var a = this.propertyIDs;
      a.clear();
      for (var b = this.mixingTo, c = 0, e = this.tracks.length; c < e; c++) {
        var d = this.tracks[c];
        null != d && d.setTimelineData(null, b, a);
      }
    };
    c.prototype.getCurrent = function(a) {
      return a >= this.tracks.length ? null : this.tracks[a];
    };
    c.prototype.addListener = function(a) {
      if (null == a) {
        throw Error("listener cannot be null.");
      }
      this.listeners.push(a);
    };
    c.prototype.removeListener = function(a) {
      a = this.listeners.indexOf(a);
      0 <= a && this.listeners.splice(a, 1);
    };
    c.prototype.clearListeners = function() {
      this.listeners.length = 0;
    };
    c.prototype.clearListenerNotifications = function() {
      this.queue.clear();
    };
    c.emptyAnimation = new a.Animation("<empty>", [], 0);
    c.SUBSEQUENT = 0;
    c.FIRST = 1;
    c.DIP = 2;
    c.DIP_MIX = 3;
    return c;
  }();
  a.AnimationState = c;
  var g = function() {
    function b() {
      this.timelineData = [];
      this.timelineDipMix = [];
      this.timelinesRotation = [];
    }
    b.prototype.reset = function() {
      this.listener = this.animation = this.mixingFrom = this.next = null;
      this.timelineData.length = 0;
      this.timelineDipMix.length = 0;
      this.timelinesRotation.length = 0;
    };
    b.prototype.setTimelineData = function(b, e, f) {
      null != b && e.push(b);
      var k = null != this.mixingFrom ? this.mixingFrom.setTimelineData(this, e, f) : this;
      null != b && e.pop();
      var d = e.length - 1, g = this.animation.timelines, n = this.animation.timelines.length, m = a.Utils.setArraySize(this.timelineData, n);
      this.timelineDipMix.length = 0;
      var p = a.Utils.setArraySize(this.timelineDipMix, n), x = 0;
      a: for (; x < n; x++) {
        var q = g[x].getPropertyId();
        if (f.add(q)) {
          if (null != b && b.hasTimeline(q)) {
            for (var v = d; 0 <= v; v--) {
              var z = e[v];
              if (!z.hasTimeline(q) && 0 < z.mixDuration) {
                m[x] = c.DIP_MIX;
                p[x] = z;
                continue a;
              }
            }
            m[x] = c.DIP;
          } else {
            m[x] = c.FIRST;
          }
        } else {
          m[x] = c.SUBSEQUENT;
        }
      }
      return k;
    };
    b.prototype.hasTimeline = function(a) {
      for (var b = this.animation.timelines, c = 0, e = b.length; c < e; c++) {
        if (b[c].getPropertyId() == a) {
          return !0;
        }
      }
      return !1;
    };
    b.prototype.getAnimationTime = function() {
      if (this.loop) {
        var a = this.animationEnd - this.animationStart;
        return 0 == a ? this.animationStart : this.trackTime % a + this.animationStart;
      }
      return Math.min(this.trackTime + this.animationStart, this.animationEnd);
    };
    b.prototype.setAnimationLast = function(a) {
      this.nextAnimationLast = this.animationLast = a;
    };
    b.prototype.isComplete = function() {
      return this.trackTime >= this.animationEnd - this.animationStart;
    };
    b.prototype.resetRotationDirections = function() {
      this.timelinesRotation.length = 0;
    };
    return b;
  }();
  a.TrackEntry = g;
  var b = function() {
    function a(a) {
      this.objects = [];
      this.drainDisabled = !1;
      this.animState = a;
    }
    a.prototype.start = function(a) {
      this.objects.push(e.start);
      this.objects.push(a);
      this.animState.animationsChanged = !0;
    };
    a.prototype.interrupt = function(a) {
      this.objects.push(e.interrupt);
      this.objects.push(a);
    };
    a.prototype.end = function(a) {
      this.objects.push(e.end);
      this.objects.push(a);
      this.animState.animationsChanged = !0;
    };
    a.prototype.dispose = function(a) {
      this.objects.push(e.dispose);
      this.objects.push(a);
    };
    a.prototype.complete = function(a) {
      this.objects.push(e.complete);
      this.objects.push(a);
    };
    a.prototype.event = function(a, b) {
      this.objects.push(e.event);
      this.objects.push(a);
      this.objects.push(b);
    };
    a.prototype.drain = function() {
      if (!this.drainDisabled) {
        this.drainDisabled = !0;
        for (var a = this.objects, b = this.animState.listeners, c = 0; c < a.length; c += 2) {
          var f = a[c + 1];
          switch(a[c]) {
            case e.start:
              null != f.listener && f.listener.start && f.listener.start(f);
              for (var d = 0; d < b.length; d++) {
                b[d].start && b[d].start(f);
              }
              break;
            case e.interrupt:
              null != f.listener && f.listener.interrupt && f.listener.interrupt(f);
              for (d = 0; d < b.length; d++) {
                b[d].interrupt && b[d].interrupt(f);
              }
              break;
            case e.end:
              for (null != f.listener && f.listener.end && f.listener.end(f), d = 0; d < b.length; d++) {
                b[d].end && b[d].end(f);
              }
            case e.dispose:
              null != f.listener && f.listener.dispose && f.listener.dispose(f);
              for (d = 0; d < b.length; d++) {
                b[d].dispose && b[d].dispose(f);
              }
              this.animState.trackEntryPool.free(f);
              break;
            case e.complete:
              null != f.listener && f.listener.complete && f.listener.complete(f);
              for (d = 0; d < b.length; d++) {
                b[d].complete && b[d].complete(f);
              }
              break;
            case e.event:
              var k = a[c++ + 2];
              null != f.listener && f.listener.event && f.listener.event(f, k);
              for (d = 0; d < b.length; d++) {
                b[d].event && b[d].event(f, k);
              }
          }
        }
        this.clear();
        this.drainDisabled = !1;
      }
    };
    a.prototype.clear = function() {
      this.objects.length = 0;
    };
    return a;
  }();
  a.EventQueue = b;
  (function(a) {
    a[a.start = 0] = "start";
    a[a.interrupt = 1] = "interrupt";
    a[a.end = 2] = "end";
    a[a.dispose = 3] = "dispose";
    a[a.complete = 4] = "complete";
    a[a.event = 5] = "event";
  })(a.EventType || (a.EventType = {}));
  var e = a.EventType, f = function() {
    function a() {
    }
    a.prototype.start = function(a) {
    };
    a.prototype.interrupt = function(a) {
    };
    a.prototype.end = function(a) {
    };
    a.prototype.dispose = function(a) {
    };
    a.prototype.complete = function(a) {
    };
    a.prototype.event = function(a, b) {
    };
    return a;
  }();
  a.AnimationStateAdapter2 = f;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function a(a) {
      this.animationToMixTime = {};
      this.defaultMix = 0;
      if (null == a) {
        throw Error("skeletonData cannot be null.");
      }
      this.skeletonData = a;
    }
    a.prototype.setMix = function(a, c, f) {
      var b = this.skeletonData.findAnimation(a);
      if (null == b) {
        throw Error("Animation not found: " + a);
      }
      a = this.skeletonData.findAnimation(c);
      if (null == a) {
        throw Error("Animation not found: " + c);
      }
      this.setMixWith(b, a, f);
    };
    a.prototype.setMixWith = function(a, c, f) {
      if (null == a) {
        throw Error("from cannot be null.");
      }
      if (null == c) {
        throw Error("to cannot be null.");
      }
      this.animationToMixTime[a.name + c.name] = f;
    };
    a.prototype.getMix = function(a, c) {
      a = this.animationToMixTime[a.name + c.name];
      return void 0 === a ? this.defaultMix : a;
    };
    return a;
  }();
  a.AnimationStateData = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function a(a, c) {
      void 0 === c && (c = "");
      this.assets = {};
      this.errors = {};
      this.loaded = this.toLoad = 0;
      this.textureLoader = a;
      this.pathPrefix = c;
    }
    a.prototype.loadText = function(a, c, f) {
      var b = this;
      void 0 === c && (c = null);
      void 0 === f && (f = null);
      a = this.pathPrefix + a;
      this.toLoad++;
      var e = new XMLHttpRequest;
      e.onreadystatechange = function() {
        e.readyState == XMLHttpRequest.DONE && (200 <= e.status && 300 > e.status ? (b.assets[a] = e.responseText, c && c(a, e.responseText)) : (b.errors[a] = "Couldn't load text " + a + ": status " + e.status + ", " + e.responseText, f && f(a, "Couldn't load text " + a + ": status " + e.status + ", " + e.responseText)), b.toLoad--, b.loaded++);
      };
      e.open("GET", a, !0);
      e.send();
    };
    a.prototype.loadTexture = function(a, c, f) {
      var b = this;
      void 0 === c && (c = null);
      void 0 === f && (f = null);
      a = this.pathPrefix + a;
      this.toLoad++;
      var e = new Image;
      e.crossOrigin = "anonymous";
      e.onload = function(f) {
        f = b.textureLoader(e);
        b.assets[a] = f;
        b.toLoad--;
        b.loaded++;
        c && c(a, e);
      };
      e.onerror = function(c) {
        b.errors[a] = "Couldn't load image " + a;
        b.toLoad--;
        b.loaded++;
        f && f(a, "Couldn't load image " + a);
      };
      e.src = a;
    };
    a.prototype.loadTextureData = function(a, c, f, k) {
      var b = this;
      void 0 === f && (f = null);
      void 0 === k && (k = null);
      a = this.pathPrefix + a;
      this.toLoad++;
      var e = new Image;
      e.onload = function(c) {
        c = b.textureLoader(e);
        b.assets[a] = c;
        b.toLoad--;
        b.loaded++;
        f && f(a, e);
      };
      e.onerror = function(c) {
        b.errors[a] = "Couldn't load image " + a;
        b.toLoad--;
        b.loaded++;
        k && k(a, "Couldn't load image " + a);
      };
      e.src = c;
    };
    a.prototype.get = function(a) {
      a = this.pathPrefix + a;
      return this.assets[a];
    };
    a.prototype.remove = function(a) {
      a = this.pathPrefix + a;
      var b = this.assets[a];
      b.dispose && b.dispose();
      this.assets[a] = null;
    };
    a.prototype.removeAll = function() {
      for (var a in this.assets) {
        var c = this.assets[a];
        c.dispose && c.dispose();
      }
      this.assets = {};
    };
    a.prototype.isLoadingComplete = function() {
      return 0 == this.toLoad;
    };
    a.prototype.getToLoad = function() {
      return this.toLoad;
    };
    a.prototype.getLoaded = function() {
      return this.loaded;
    };
    a.prototype.dispose = function() {
      this.removeAll();
    };
    a.prototype.hasErrors = function() {
      return 0 < Object.keys(this.errors).length;
    };
    a.prototype.getErrors = function() {
      return this.errors;
    };
    return a;
  }();
  a.AssetManager = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function c(a) {
      this.atlas = a;
    }
    c.prototype.newRegionAttachment = function(b, c, f) {
      b = this.atlas.findRegion(f);
      if (null == b) {
        throw Error("Region not found in atlas: " + f + " (region attachment: " + c + ")");
      }
      b.renderObject = b;
      c = new a.RegionAttachment(c);
      c.setRegion(b);
      return c;
    };
    c.prototype.newMeshAttachment = function(b, c, f) {
      b = this.atlas.findRegion(f);
      if (null == b) {
        throw Error("Region not found in atlas: " + f + " (mesh attachment: " + c + ")");
      }
      b.renderObject = b;
      c = new a.MeshAttachment(c);
      c.region = b;
      return c;
    };
    c.prototype.newBoundingBoxAttachment = function(b, c) {
      return new a.BoundingBoxAttachment(c);
    };
    c.prototype.newPathAttachment = function(b, c) {
      return new a.PathAttachment(c);
    };
    c.prototype.newPointAttachment = function(b, c) {
      return new a.PointAttachment(c);
    };
    c.prototype.newClippingAttachment = function(b, c) {
      return new a.ClippingAttachment(c);
    };
    return c;
  }();
  a.AtlasAttachmentLoader = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    return function(a) {
      if (null == a) {
        throw Error("name cannot be null.");
      }
      this.name = a;
    };
  }();
  a.Attachment = c;
  c = function(a) {
    function b(c) {
      a.call(this, c);
      this.id = (b.nextID++ & 65535) << 11;
      this.worldVerticesLength = 0;
    }
    __extends(b, a);
    b.prototype.computeWorldVertices = function(a, b, c, g, p, m) {
      c = p + (c >> 1) * m;
      var e = a.bone.skeleton, d = a.attachmentVertices, f = this.vertices, k = this.bones;
      if (null == k) {
        0 < d.length && (f = d);
        a = a.bone;
        d = a.worldX;
        k = a.worldY;
        var n = a.a;
        e = a.b;
        var y = a.c;
        a = a.d;
        for (var x = b; p < c; x += 2, p += m) {
          b = f[x];
          var q = f[x + 1];
          g[p] = b * n + q * e + d;
          g[p + 1] = b * y + q * a + k;
        }
      } else {
        for (q = a = n = 0; q < b; q += 2) {
          y = k[n], n += y + 1, a += y;
        }
        x = e.bones;
        if (0 == d.length) {
          for (e = 3 * a; p < c; p += m) {
            var v = 0, z = 0;
            y = k[n++];
            for (y += n; n < y; n++, e += 3) {
              a = x[k[n]];
              b = f[e];
              q = f[e + 1];
              var C = f[e + 2];
              v += (b * a.a + q * a.b + a.worldX) * C;
              z += (b * a.c + q * a.d + a.worldY) * C;
            }
            g[p] = v;
            g[p + 1] = z;
          }
        } else {
          e = 3 * a;
          for (var A = a << 1; p < c; p += m) {
            z = v = 0;
            y = k[n++];
            for (y += n; n < y; n++, e += 3, A += 2) {
              a = x[k[n]], b = f[e] + d[A], q = f[e + 1] + d[A + 1], C = f[e + 2], v += (b * a.a + q * a.b + a.worldX) * C, z += (b * a.c + q * a.d + a.worldY) * C;
            }
            g[p] = v;
            g[p + 1] = z;
          }
        }
      }
    };
    b.prototype.applyDeform = function(a) {
      return this == a;
    };
    b.nextID = 0;
    return b;
  }(c);
  a.VertexAttachment = c;
})(spine || (spine = {}));
(function(a) {
  a = a.AttachmentType || (a.AttachmentType = {});
  a[a.Region = 0] = "Region";
  a[a.BoundingBox = 1] = "BoundingBox";
  a[a.Mesh = 2] = "Mesh";
  a[a.LinkedMesh = 3] = "LinkedMesh";
  a[a.Path = 4] = "Path";
  a[a.Point = 5] = "Point";
})(spine || (spine = {}));
(function(a) {
  var c = function(c) {
    function b(b) {
      c.call(this, b);
      this.color = new a.Color(1, 1, 1, 1);
    }
    __extends(b, c);
    return b;
  }(a.VertexAttachment);
  a.BoundingBoxAttachment = c;
})(spine || (spine = {}));
(function(a) {
  var c = function(c) {
    function b(b) {
      c.call(this, b);
      this.color = new a.Color(.2275, .2275, .8078, 1);
    }
    __extends(b, c);
    return b;
  }(a.VertexAttachment);
  a.ClippingAttachment = c;
})(spine || (spine = {}));
(function(a) {
  var c = function(c) {
    function b(b) {
      c.call(this, b);
      this.color = new a.Color(1, 1, 1, 1);
      this.inheritDeform = !1;
      this.tempColor = new a.Color(0, 0, 0, 0);
    }
    __extends(b, c);
    b.prototype.updateUVs = function() {
      var b, c;
      if (null == this.region) {
        var k = b = 0;
        var g = c = 1;
      } else {
        k = this.region.u, b = this.region.v, g = this.region.u2 - k, c = this.region.v2 - b;
      }
      var p = this.regionUVs;
      if (null == this.uvs || this.uvs.length != p.length) {
        this.uvs = a.Utils.newFloatArray(p.length);
      }
      var m = this.uvs;
      if (this.region.rotate) {
        for (var t = 0, d = m.length; t < d; t += 2) {
          m[t] = k + p[t + 1] * g, m[t + 1] = b + c - p[t] * c;
        }
      } else {
        for (t = 0, d = m.length; t < d; t += 2) {
          m[t] = k + p[t] * g, m[t + 1] = b + p[t + 1] * c;
        }
      }
    };
    b.prototype.applyDeform = function(a) {
      return this == a || this.inheritDeform && this.parentMesh == a;
    };
    b.prototype.getParentMesh = function() {
      return this.parentMesh;
    };
    b.prototype.setParentMesh = function(a) {
      this.parentMesh = a;
      null != a && (this.bones = a.bones, this.vertices = a.vertices, this.worldVerticesLength = a.worldVerticesLength, this.regionUVs = a.regionUVs, this.triangles = a.triangles, this.hullLength = a.hullLength, this.worldVerticesLength = a.worldVerticesLength);
    };
    return b;
  }(a.VertexAttachment);
  a.MeshAttachment = c;
})(spine || (spine = {}));
(function(a) {
  var c = function(c) {
    function b(b) {
      c.call(this, b);
      this.constantSpeed = this.closed = !1;
      this.color = new a.Color(1, 1, 1, 1);
    }
    __extends(b, c);
    return b;
  }(a.VertexAttachment);
  a.PathAttachment = c;
})(spine || (spine = {}));
(function(a) {
  var c = function(c) {
    function b(b) {
      c.call(this, b);
      this.color = new a.Color(.38, .94, 0, 1);
    }
    __extends(b, c);
    b.prototype.computeWorldPosition = function(a, b) {
      b.x = this.x * a.a + this.y * a.b + a.worldX;
      b.y = this.x * a.c + this.y * a.d + a.worldY;
      return b;
    };
    b.prototype.computeWorldRotation = function(b) {
      var c = a.MathUtils.cosDeg(this.rotation), e = a.MathUtils.sinDeg(this.rotation);
      return Math.atan2(c * b.c + e * b.d, c * b.a + e * b.b) * a.MathUtils.radDeg;
    };
    return b;
  }(a.VertexAttachment);
  a.PointAttachment = c;
})(spine || (spine = {}));
(function(a) {
  var c = function(c) {
    function b(b) {
      c.call(this, b);
      this.y = this.x = 0;
      this.scaleY = this.scaleX = 1;
      this.height = this.width = this.rotation = 0;
      this.color = new a.Color(1, 1, 1, 1);
      this.offset = a.Utils.newFloatArray(8);
      this.uvs = a.Utils.newFloatArray(8);
      this.tempColor = new a.Color(1, 1, 1, 1);
    }
    __extends(b, c);
    b.prototype.updateOffset = function() {
      var a = this.width / this.region.originalWidth * this.scaleX, c = this.height / this.region.originalHeight * this.scaleY, k = -this.width / 2 * this.scaleX + this.region.offsetX * a, g = -this.height / 2 * this.scaleY + this.region.offsetY * c, p = k + this.region.width * a;
      a = g + this.region.height * c;
      c = this.rotation * Math.PI / 180;
      var m = Math.cos(c), t = Math.sin(c);
      c = k * m + this.x;
      k *= t;
      var d = g * m + this.y;
      g *= t;
      var l = p * m + this.x;
      p *= t;
      m = a * m + this.y;
      a *= t;
      t = this.offset;
      t[b.OX1] = c - g;
      t[b.OY1] = d + k;
      t[b.OX2] = c - a;
      t[b.OY2] = m + k;
      t[b.OX3] = l - a;
      t[b.OY3] = m + p;
      t[b.OX4] = l - g;
      t[b.OY4] = d + p;
    };
    b.prototype.setRegion = function(a) {
      this.region = a;
      var b = this.uvs;
      a.rotate ? (b[2] = a.u, b[3] = a.v2, b[4] = a.u, b[5] = a.v, b[6] = a.u2, b[7] = a.v, b[0] = a.u2, b[1] = a.v2) : (b[0] = a.u, b[1] = a.v2, b[2] = a.u, b[3] = a.v, b[4] = a.u2, b[5] = a.v, b[6] = a.u2, b[7] = a.v2);
    };
    b.prototype.computeWorldVertices = function(a, c, k, g) {
      var e = this.offset, f = a.worldX, n = a.worldY, d = a.a, l = a.b, u = a.c;
      a = a.d;
      var w = e[b.OX1];
      var y = e[b.OY1];
      c[k] = w * d + y * l + f;
      c[k + 1] = w * u + y * a + n;
      k += g;
      w = e[b.OX2];
      y = e[b.OY2];
      c[k] = w * d + y * l + f;
      c[k + 1] = w * u + y * a + n;
      k += g;
      w = e[b.OX3];
      y = e[b.OY3];
      c[k] = w * d + y * l + f;
      c[k + 1] = w * u + y * a + n;
      k += g;
      w = e[b.OX4];
      y = e[b.OY4];
      c[k] = w * d + y * l + f;
      c[k + 1] = w * u + y * a + n;
    };
    b.OX1 = 0;
    b.OY1 = 1;
    b.OX2 = 2;
    b.OY2 = 3;
    b.OX3 = 4;
    b.OY3 = 5;
    b.OX4 = 6;
    b.OY4 = 7;
    b.X1 = 0;
    b.Y1 = 1;
    b.C1R = 2;
    b.C1G = 3;
    b.C1B = 4;
    b.C1A = 5;
    b.U1 = 6;
    b.V1 = 7;
    b.X2 = 8;
    b.Y2 = 9;
    b.C2R = 10;
    b.C2G = 11;
    b.C2B = 12;
    b.C2A = 13;
    b.U2 = 14;
    b.V2 = 15;
    b.X3 = 16;
    b.Y3 = 17;
    b.C3R = 18;
    b.C3G = 19;
    b.C3B = 20;
    b.C3A = 21;
    b.U3 = 22;
    b.V3 = 23;
    b.X4 = 24;
    b.Y4 = 25;
    b.C4R = 26;
    b.C4G = 27;
    b.C4B = 28;
    b.C4A = 29;
    b.U4 = 30;
    b.V4 = 31;
    return b;
  }(a.Attachment);
  a.RegionAttachment = c;
})(spine || (spine = {}));
(function(a) {
  a = a.BlendMode || (a.BlendMode = {});
  a[a.Normal = 0] = "Normal";
  a[a.Additive = 1] = "Additive";
  a[a.Multiply = 2] = "Multiply";
  a[a.Screen = 3] = "Screen";
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function c(a, c, f) {
      this.children = [];
      this.ashearY = this.ashearX = this.ascaleY = this.ascaleX = this.arotation = this.ay = this.ax = this.shearY = this.shearX = this.scaleY = this.scaleX = this.rotation = this.y = this.x = 0;
      this.appliedValid = !1;
      this.worldY = this.d = this.c = this.worldX = this.b = this.a = 0;
      this.sorted = !1;
      if (null == a) {
        throw Error("data cannot be null.");
      }
      if (null == c) {
        throw Error("skeleton cannot be null.");
      }
      this.data = a;
      this.skeleton = c;
      this.parent = f;
      this.setToSetupPose();
    }
    c.prototype.update = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    c.prototype.updateWorldTransform = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    c.prototype.updateWorldTransformWith = function(b, c, f, k, g, p, m) {
      this.ax = b;
      this.ay = c;
      this.arotation = f;
      this.ascaleX = k;
      this.ascaleY = g;
      this.ashearX = p;
      this.ashearY = m;
      this.appliedValid = !0;
      var e = this.parent;
      if (null == e) {
        m = f + 90 + m;
        e = a.MathUtils.cosDeg(f + p) * k;
        var d = a.MathUtils.cosDeg(m) * g;
        k *= a.MathUtils.sinDeg(f + p);
        g *= a.MathUtils.sinDeg(m);
        var l = this.skeleton;
        l.flipX && (b = -b, e = -e, d = -d);
        l.flipY && (c = -c, k = -k, g = -g);
        this.a = e;
        this.b = d;
        this.c = k;
        this.d = g;
        this.worldX = b + l.x;
        this.worldY = c + l.y;
      } else {
        l = e.a;
        var n = e.b, w = e.c, y = e.d;
        this.worldX = l * b + n * c + e.worldX;
        this.worldY = w * b + y * c + e.worldY;
        switch(this.data.transformMode) {
          case a.TransformMode.Normal:
            m = f + 90 + m;
            e = a.MathUtils.cosDeg(f + p) * k;
            d = a.MathUtils.cosDeg(m) * g;
            k *= a.MathUtils.sinDeg(f + p);
            g *= a.MathUtils.sinDeg(m);
            this.a = l * e + n * k;
            this.b = l * d + n * g;
            this.c = w * e + y * k;
            this.d = w * d + y * g;
            return;
          case a.TransformMode.OnlyTranslation:
            m = f + 90 + m;
            this.a = a.MathUtils.cosDeg(f + p) * k;
            this.b = a.MathUtils.cosDeg(m) * g;
            this.c = a.MathUtils.sinDeg(f + p) * k;
            this.d = a.MathUtils.sinDeg(m) * g;
            break;
          case a.TransformMode.NoRotationOrReflection:
            e = l * l + w * w;
            1E-4 < e ? (e = Math.abs(l * y - n * w) / e, n = w * e, y = l * e, e = Math.atan2(w, l) * a.MathUtils.radDeg) : (w = l = 0, e = 90 - Math.atan2(y, n) * a.MathUtils.radDeg);
            p = f + p - e;
            m = f + m - e + 90;
            e = a.MathUtils.cosDeg(p) * k;
            d = a.MathUtils.cosDeg(m) * g;
            k *= a.MathUtils.sinDeg(p);
            g *= a.MathUtils.sinDeg(m);
            this.a = l * e - n * k;
            this.b = l * d - n * g;
            this.c = w * e + y * k;
            this.d = w * d + y * g;
            break;
          case a.TransformMode.NoScale:
          case a.TransformMode.NoScaleOrReflection:
            e = a.MathUtils.cosDeg(f);
            d = a.MathUtils.sinDeg(f);
            f = l * e + n * d;
            b = w * e + y * d;
            e = Math.sqrt(f * f + b * b);
            1E-5 < e && (e = 1 / e);
            f *= e;
            b *= e;
            e = Math.sqrt(f * f + b * b);
            d = Math.PI / 2 + Math.atan2(b, f);
            c = Math.cos(d) * e;
            var x = Math.sin(d) * e;
            e = a.MathUtils.cosDeg(p) * k;
            d = a.MathUtils.cosDeg(90 + m) * g;
            k *= a.MathUtils.sinDeg(p);
            g *= a.MathUtils.sinDeg(90 + m);
            if (this.data.transformMode != a.TransformMode.NoScaleOrReflection ? 0 > l * y - n * w : this.skeleton.flipX != this.skeleton.flipY) {
              c = -c, x = -x;
            }
            this.a = f * e + c * k;
            this.b = f * d + c * g;
            this.c = b * e + x * k;
            this.d = b * d + x * g;
            return;
        }
        this.skeleton.flipX && (this.a = -this.a, this.b = -this.b);
        this.skeleton.flipY && (this.c = -this.c, this.d = -this.d);
      }
    };
    c.prototype.setToSetupPose = function() {
      var a = this.data;
      this.x = a.x;
      this.y = a.y;
      this.rotation = a.rotation;
      this.scaleX = a.scaleX;
      this.scaleY = a.scaleY;
      this.shearX = a.shearX;
      this.shearY = a.shearY;
    };
    c.prototype.getWorldRotationX = function() {
      return Math.atan2(this.c, this.a) * a.MathUtils.radDeg;
    };
    c.prototype.getWorldRotationY = function() {
      return Math.atan2(this.d, this.b) * a.MathUtils.radDeg;
    };
    c.prototype.getWorldScaleX = function() {
      return Math.sqrt(this.a * this.a + this.c * this.c);
    };
    c.prototype.getWorldScaleY = function() {
      return Math.sqrt(this.b * this.b + this.d * this.d);
    };
    c.prototype.updateAppliedTransform = function() {
      this.appliedValid = !0;
      var b = this.parent;
      if (null == b) {
        this.ax = this.worldX, this.ay = this.worldY, this.arotation = Math.atan2(this.c, this.a) * a.MathUtils.radDeg, this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c), this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d), this.ashearX = 0, this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * a.MathUtils.radDeg;
      } else {
        var c = b.a, f = b.b, k = b.c, g = b.d, p = 1 / (c * g - f * k), m = this.worldX - b.worldX;
        b = this.worldY - b.worldY;
        this.ax = m * g * p - b * f * p;
        this.ay = b * c * p - m * k * p;
        g *= p;
        c *= p;
        f *= p;
        p *= k;
        k = g * this.a - f * this.c;
        f = g * this.b - f * this.d;
        g = c * this.c - p * this.a;
        p = c * this.d - p * this.b;
        this.ashearX = 0;
        this.ascaleX = Math.sqrt(k * k + g * g);
        1E-4 < this.ascaleX ? (c = k * p - f * g, this.ascaleY = c / this.ascaleX, this.ashearY = Math.atan2(k * f + g * p, c) * a.MathUtils.radDeg, this.arotation = Math.atan2(g, k) * a.MathUtils.radDeg) : (this.ascaleX = 0, this.ascaleY = Math.sqrt(f * f + p * p), this.ashearY = 0, this.arotation = 90 - Math.atan2(p, f) * a.MathUtils.radDeg);
      }
    };
    c.prototype.worldToLocal = function(a) {
      var b = this.a, c = this.b, k = this.c, g = this.d, p = 1 / (b * g - c * k), m = a.x - this.worldX, t = a.y - this.worldY;
      a.x = m * g * p - t * c * p;
      a.y = t * b * p - m * k * p;
      return a;
    };
    c.prototype.localToWorld = function(a) {
      var b = a.x, c = a.y;
      a.x = b * this.a + c * this.b + this.worldX;
      a.y = b * this.c + c * this.d + this.worldY;
      return a;
    };
    c.prototype.worldToLocalRotation = function(b) {
      var c = a.MathUtils.sinDeg(b);
      b = a.MathUtils.cosDeg(b);
      return Math.atan2(this.a * c - this.c * b, this.d * b - this.b * c) * a.MathUtils.radDeg;
    };
    c.prototype.localToWorldRotation = function(b) {
      var c = a.MathUtils.sinDeg(b);
      b = a.MathUtils.cosDeg(b);
      return Math.atan2(b * this.c + c * this.d, b * this.a + c * this.b) * a.MathUtils.radDeg;
    };
    c.prototype.rotateWorld = function(b) {
      var c = this.a, f = this.b, k = this.c, g = this.d, p = a.MathUtils.cosDeg(b);
      b = a.MathUtils.sinDeg(b);
      this.a = p * c - b * k;
      this.b = p * f - b * g;
      this.c = b * c + p * k;
      this.d = b * f + p * g;
      this.appliedValid = !1;
    };
    return c;
  }();
  a.Bone = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    return function(a, c, f) {
      this.rotation = this.y = this.x = 0;
      this.scaleY = this.scaleX = 1;
      this.shearY = this.shearX = 0;
      this.transformMode = g.Normal;
      if (0 > a) {
        throw Error("index must be >= 0.");
      }
      if (null == c) {
        throw Error("name cannot be null.");
      }
      this.index = a;
      this.name = c;
      this.parent = f;
    };
  }();
  a.BoneData = c;
  (function(a) {
    a[a.Normal = 0] = "Normal";
    a[a.OnlyTranslation = 1] = "OnlyTranslation";
    a[a.NoRotationOrReflection = 2] = "NoRotationOrReflection";
    a[a.NoScale = 3] = "NoScale";
    a[a.NoScaleOrReflection = 4] = "NoScaleOrReflection";
  })(a.TransformMode || (a.TransformMode = {}));
  var g = a.TransformMode;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    return function(a, b) {
      if (null == b) {
        throw Error("data cannot be null.");
      }
      this.time = a;
      this.data = b;
    };
  }();
  a.Event = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    return function(a) {
      this.name = a;
    };
  }();
  a.EventData = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function c(a, c) {
      this.mix = 1;
      this.bendDirection = 0;
      if (null == a) {
        throw Error("data cannot be null.");
      }
      if (null == c) {
        throw Error("skeleton cannot be null.");
      }
      this.data = a;
      this.mix = a.mix;
      this.bendDirection = a.bendDirection;
      this.bones = [];
      for (var b = 0; b < a.bones.length; b++) {
        this.bones.push(c.findBone(a.bones[b].name));
      }
      this.target = c.findBone(a.target.name);
    }
    c.prototype.getOrder = function() {
      return this.data.order;
    };
    c.prototype.apply = function() {
      this.update();
    };
    c.prototype.update = function() {
      var a = this.target, c = this.bones;
      switch(c.length) {
        case 1:
          this.apply1(c[0], a.worldX, a.worldY, this.mix);
          break;
        case 2:
          this.apply2(c[0], c[1], a.worldX, a.worldY, this.bendDirection, this.mix);
      }
    };
    c.prototype.apply1 = function(b, c, f, k) {
      b.appliedValid || b.updateAppliedTransform();
      var e = b.parent, g = 1 / (e.a * e.d - e.b * e.c);
      c -= e.worldX;
      f -= e.worldY;
      e = Math.atan2((f * e.a - c * e.c) * g - b.ay, (c * e.d - f * e.b) * g - b.ax) * a.MathUtils.radDeg - b.ashearX - b.arotation;
      0 > b.ascaleX && (e += 180);
      180 < e ? e -= 360 : -180 > e && (e += 360);
      b.updateWorldTransformWith(b.ax, b.ay, b.arotation + e * k, b.ascaleX, b.ascaleY, b.ashearX, b.ashearY);
    };
    c.prototype.apply2 = function(b, c, f, k, g, p) {
      if (0 == p) {
        c.updateWorldTransform();
      } else {
        b.appliedValid || b.updateAppliedTransform();
        c.appliedValid || c.updateAppliedTransform();
        var e = b.ax, n = b.ay, d = b.ascaleX, l = b.ascaleY, u = c.ascaleX;
        if (0 > d) {
          d = -d;
          var w = 180;
          var y = -1;
        } else {
          w = 0, y = 1;
        }
        0 > l && (l = -l, y = -y);
        if (0 > u) {
          u = -u;
          var x = 180;
        } else {
          x = 0;
        }
        var q = c.ax, v = b.a, z = b.b, C = b.c, A = b.d, D = 1E-4 >= Math.abs(d - l);
        if (D) {
          var E = c.ay;
          var B = v * q + z * E + b.worldX;
          var G = C * q + A * E + b.worldY;
        } else {
          E = 0, B = v * q + b.worldX, G = C * q + b.worldY;
        }
        var H = b.parent;
        v = H.a;
        z = H.b;
        C = H.c;
        A = H.d;
        var K = 1 / (v * A - z * C);
        f -= H.worldX;
        k -= H.worldY;
        var I = (f * A - k * z) * K - e, L = (k * v - f * C) * K - n;
        f = B - H.worldX;
        k = G - H.worldY;
        z = (f * A - k * z) * K - e;
        v = (k * v - f * C) * K - n;
        f = Math.sqrt(z * z + v * v);
        z = c.data.length * u;
        a: {
          if (D) {
            z *= d, v = (I * I + L * L - f * f - z * z) / (2 * f * z), -1 > v ? v = -1 : 1 < v && (v = 1), g *= Math.acos(v), v = f + z * v, z *= Math.sin(g), v = Math.atan2(L * v - I * z, I * v + L * z);
          } else {
            v = d * z;
            z *= l;
            k = v * v;
            u = z * z;
            D = I * I + L * L;
            I = Math.atan2(L, I);
            C = u * f * f + k * D - k * u;
            L = -2 * u * f;
            K = u - k;
            A = L * L - 4 * K * C;
            if (0 <= A && (A = Math.sqrt(A), 0 > L && (A = -A), A = -(L + A) / 2, L = A / K, C /= A, C = Math.abs(L) < Math.abs(C) ? L : C, C * C <= D)) {
              k = Math.sqrt(D - C * C) * g;
              v = I - Math.atan2(k, C);
              g = Math.atan2(k / l, (C - f) / d);
              break a;
            }
            d = a.MathUtils.PI;
            L = f - v;
            K = L * L;
            l = B = 0;
            G = f + v;
            H = G * G;
            var R = 0;
            C = -v * f / (k - u);
            -1 <= C && 1 >= C && (C = Math.acos(C), f = v * Math.cos(C) + f, k = z * Math.sin(C), A = f * f + k * k, A < K && (d = C, K = A, L = f, B = k), A > H && (l = C, H = A, G = f, R = k));
            D <= (K + H) / 2 ? (v = I - Math.atan2(B * g, L), g *= d) : (v = I - Math.atan2(R * g, G), g *= l);
          }
        }
        z = Math.atan2(E, q) * y;
        C = b.arotation;
        v = (v - z) * a.MathUtils.radDeg + w - C;
        180 < v ? v -= 360 : -180 > v && (v += 360);
        b.updateWorldTransformWith(e, n, C + v * p, b.ascaleX, b.ascaleY, 0, 0);
        C = c.arotation;
        g = ((g + z) * a.MathUtils.radDeg - c.ashearX) * y + x - C;
        180 < g ? g -= 360 : -180 > g && (g += 360);
        c.updateWorldTransformWith(q, E, C + g * p, c.ascaleX, c.ascaleY, c.ashearX, c.ashearY);
      }
    };
    return c;
  }();
  a.IkConstraint = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    return function(a) {
      this.order = 0;
      this.bones = [];
      this.mix = this.bendDirection = 1;
      this.name = a;
    };
  }();
  a.IkConstraintData = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function c(a, c) {
      this.translateMix = this.rotateMix = this.spacing = this.position = 0;
      this.spaces = [];
      this.positions = [];
      this.world = [];
      this.curves = [];
      this.lengths = [];
      this.segments = [];
      if (null == a) {
        throw Error("data cannot be null.");
      }
      if (null == c) {
        throw Error("skeleton cannot be null.");
      }
      this.data = a;
      this.bones = [];
      for (var b = 0, e = a.bones.length; b < e; b++) {
        this.bones.push(c.findBone(a.bones[b].name));
      }
      this.target = c.findSlot(a.target.name);
      this.position = a.position;
      this.spacing = a.spacing;
      this.rotateMix = a.rotateMix;
      this.translateMix = a.translateMix;
    }
    c.prototype.apply = function() {
      this.update();
    };
    c.prototype.update = function() {
      var b = this.target.getAttachment();
      if (b instanceof a.PathAttachment) {
        var c = this.rotateMix, f = this.translateMix, k = 0 < c;
        if (0 < f || k) {
          var g = this.data, p = g.spacingMode, m = p == a.SpacingMode.Length, t = g.rotateMode, d = t == a.RotateMode.Tangent, l = t == a.RotateMode.ChainScale, u = this.bones.length, w = d ? u : u + 1, y = this.bones, x = a.Utils.setArraySize(this.spaces, w), q = null, v = this.spacing;
          if (l || m) {
            l && (q = a.Utils.setArraySize(this.lengths, u));
            for (var z = 0, C = w - 1; z < C;) {
              var A = y[z], D = A.data.length;
              0 == D && (D = 1E-7);
              var E = D * A.a, B = D * A.c;
              A = Math.sqrt(E * E + B * B);
              l && (q[z] = A);
              x[++z] = (m ? D + v : v) * A / D;
            }
          } else {
            for (z = 1; z < w; z++) {
              x[z] = v;
            }
          }
          b = this.computeWorldPositions(b, w, d, g.positionMode == a.PositionMode.Percent, p == a.SpacingMode.Percent);
          p = b[0];
          m = b[1];
          g = g.offsetRotation;
          0 == g ? t = t == a.RotateMode.Chain : (t = !1, w = this.target.bone, g *= 0 < w.a * w.d - w.b * w.c ? a.MathUtils.degRad : -a.MathUtils.degRad);
          z = 0;
          for (w = 3; z < u; z++, w += 3) {
            A = y[z];
            A.worldX += (p - A.worldX) * f;
            A.worldY += (m - A.worldY) * f;
            E = b[w];
            B = b[w + 1];
            v = E - p;
            C = B - m;
            l && (p = q[z], 0 != p && (p = (Math.sqrt(v * v + C * C) / p - 1) * c + 1, A.a *= p, A.c *= p));
            p = E;
            m = B;
            if (k) {
              E = A.a;
              B = A.b;
              D = A.c;
              var G = A.d;
              var H = d ? b[w - 1] : 0 == x[z + 1] ? b[w + 2] : Math.atan2(C, v);
              H -= Math.atan2(D, E);
              if (t) {
                var K = Math.cos(H);
                var I = Math.sin(H);
                var L = A.data.length;
                p += (L * (K * E - I * D) - v) * c;
                m += (L * (I * E + K * D) - C) * c;
              } else {
                H += g;
              }
              H > a.MathUtils.PI ? H -= a.MathUtils.PI2 : H < -a.MathUtils.PI && (H += a.MathUtils.PI2);
              H *= c;
              K = Math.cos(H);
              I = Math.sin(H);
              A.a = K * E - I * D;
              A.b = K * B - I * G;
              A.c = I * E + K * D;
              A.d = I * B + K * G;
            }
            A.appliedValid = !1;
          }
        }
      }
    };
    c.prototype.computeWorldPositions = function(b, e, f, k, g) {
      var n = this.target, m = this.position, t = this.spaces, d = a.Utils.setArraySize(this.positions, 3 * e + 2), l = b.closed, u = b.worldVerticesLength, w = u / 6, y = c.NONE;
      if (!b.constantSpeed) {
        var x = b.lengths;
        w -= l ? 1 : 2;
        var q = x[w];
        k && (m *= q);
        if (g) {
          for (var v = 0; v < e; v++) {
            t[v] *= q;
          }
        }
        var z = a.Utils.setArraySize(this.world, 8);
        for (g = k = v = 0; v < e; v++, k += 3) {
          var C = t[v], A = m += C;
          if (l) {
            A %= q, 0 > A && (A += q), g = 0;
          } else {
            if (0 > A) {
              y != c.BEFORE && (y = c.BEFORE, b.computeWorldVertices(n, 2, 4, z, 0, 2));
              this.addBeforePosition(A, z, 0, d, k);
              continue;
            } else {
              if (A > q) {
                y != c.AFTER && (y = c.AFTER, b.computeWorldVertices(n, u - 6, 4, z, 0, 2));
                this.addAfterPosition(A - q, z, 0, d, k);
                continue;
              }
            }
          }
          for (;; g++) {
            var D = x[g];
            if (!(A > D)) {
              if (0 == g) {
                A /= D;
              } else {
                var E = x[g - 1];
                A = (A - E) / (D - E);
              }
              break;
            }
          }
          g != y && (y = g, l && g == w ? (b.computeWorldVertices(n, u - 4, 4, z, 0, 2), b.computeWorldVertices(n, 0, 4, z, 4, 2)) : b.computeWorldVertices(n, 6 * g + 2, 8, z, 0, 2));
          this.addCurvePosition(A, z[0], z[1], z[2], z[3], z[4], z[5], z[6], z[7], d, k, f || 0 < v && 0 == C);
        }
        return d;
      }
      l ? (u += 2, z = a.Utils.setArraySize(this.world, u), b.computeWorldVertices(n, 2, u - 4, z, 0, 2), b.computeWorldVertices(n, 0, 2, z, u - 4, 2), z[u - 2] = z[0], z[u - 1] = z[1]) : (w--, u -= 4, z = a.Utils.setArraySize(this.world, u), b.computeWorldVertices(n, 2, u, z, 0, 2));
      b = a.Utils.setArraySize(this.curves, w);
      n = 0;
      x = z[0];
      q = z[1];
      var B = D = 0, G = 0, H = 0, K = 0, I = 0;
      v = 0;
      for (C = 2; v < w; v++, C += 6) {
        D = z[C];
        B = z[C + 1];
        G = z[C + 2];
        H = z[C + 3];
        K = z[C + 4];
        I = z[C + 5];
        var L = .1875 * (x - 2 * D + G);
        var R = .1875 * (q - 2 * B + H);
        E = .09375 * (3 * (D - G) - x + K);
        var J = .09375 * (3 * (B - H) - q + I);
        var Q = 2 * L + E;
        var aa = 2 * R + J;
        L = .75 * (D - x) + L + .16666667 * E;
        R = .75 * (B - q) + R + .16666667 * J;
        n += Math.sqrt(L * L + R * R);
        L += Q;
        R += aa;
        Q += E;
        aa += J;
        n += Math.sqrt(L * L + R * R);
        L += Q;
        R += aa;
        n += Math.sqrt(L * L + R * R);
        L += Q + E;
        R += aa + J;
        n += Math.sqrt(L * L + R * R);
        b[v] = n;
        x = K;
        q = I;
      }
      k && (m *= n);
      if (g) {
        for (v = 0; v < e; v++) {
          t[v] *= n;
        }
      }
      w = this.segments;
      var U = 0;
      for (J = g = k = v = 0; v < e; v++, k += 3) {
        C = t[v];
        A = m += C;
        if (l) {
          A %= n, 0 > A && (A += n), g = 0;
        } else {
          if (0 > A) {
            this.addBeforePosition(A, z, 0, d, k);
            continue;
          } else {
            if (A > n) {
              this.addAfterPosition(A - n, z, u - 4, d, k);
              continue;
            }
          }
        }
        for (;; g++) {
          if (Q = b[g], !(A > Q)) {
            0 == g ? A /= Q : (E = b[g - 1], A = (A - E) / (Q - E));
            break;
          }
        }
        if (g != y) {
          y = g;
          var N = 6 * g;
          x = z[N];
          q = z[N + 1];
          D = z[N + 2];
          B = z[N + 3];
          G = z[N + 4];
          H = z[N + 5];
          K = z[N + 6];
          I = z[N + 7];
          L = .03 * (x - 2 * D + G);
          R = .03 * (q - 2 * B + H);
          E = .006 * (3 * (D - G) - x + K);
          J = .006 * (3 * (B - H) - q + I);
          Q = 2 * L + E;
          aa = 2 * R + J;
          L = .3 * (D - x) + L + .16666667 * E;
          R = .3 * (B - q) + R + .16666667 * J;
          U = Math.sqrt(L * L + R * R);
          w[0] = U;
          for (N = 1; 8 > N; N++) {
            L += Q, R += aa, Q += E, aa += J, U += Math.sqrt(L * L + R * R), w[N] = U;
          }
          L += Q;
          R += aa;
          U += Math.sqrt(L * L + R * R);
          w[8] = U;
          L += Q + E;
          R += aa + J;
          U += Math.sqrt(L * L + R * R);
          w[9] = U;
          J = 0;
        }
        for (A *= U;; J++) {
          if (Q = w[J], !(A > Q)) {
            0 == J ? A /= Q : (E = w[J - 1], A = J + (A - E) / (Q - E));
            break;
          }
        }
        this.addCurvePosition(.1 * A, x, q, D, B, G, H, K, I, d, k, f || 0 < v && 0 == C);
      }
      return d;
    };
    c.prototype.addBeforePosition = function(a, c, f, k, g) {
      var b = c[f], e = c[f + 1];
      c = Math.atan2(c[f + 3] - e, c[f + 2] - b);
      k[g] = b + a * Math.cos(c);
      k[g + 1] = e + a * Math.sin(c);
      k[g + 2] = c;
    };
    c.prototype.addAfterPosition = function(a, c, f, k, g) {
      var b = c[f + 2], e = c[f + 3];
      c = Math.atan2(e - c[f + 1], b - c[f]);
      k[g] = b + a * Math.cos(c);
      k[g + 1] = e + a * Math.sin(c);
      k[g + 2] = c;
    };
    c.prototype.addCurvePosition = function(a, c, f, k, g, p, m, t, d, l, u, w) {
      if (0 == a || isNaN(a)) {
        a = 1E-4;
      }
      var b = a * a, e = b * a, n = 1 - a, v = n * n, z = v * n, C = n * a, A = 3 * C;
      n *= A;
      a *= A;
      t = c * z + k * n + p * a + t * e;
      d = f * z + g * n + m * a + d * e;
      l[u] = t;
      l[u + 1] = d;
      w && (l[u + 2] = Math.atan2(d - (f * v + g * C * 2 + m * b), t - (c * v + k * C * 2 + p * b)));
    };
    c.prototype.getOrder = function() {
      return this.data.order;
    };
    c.NONE = -1;
    c.BEFORE = -2;
    c.AFTER = -3;
    return c;
  }();
  a.PathConstraint = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    return function(a) {
      this.order = 0;
      this.bones = [];
      this.name = a;
    };
  }();
  a.PathConstraintData = c;
  (function(a) {
    a[a.Fixed = 0] = "Fixed";
    a[a.Percent = 1] = "Percent";
  })(a.PositionMode || (a.PositionMode = {}));
  (function(a) {
    a[a.Length = 0] = "Length";
    a[a.Fixed = 1] = "Fixed";
    a[a.Percent = 2] = "Percent";
  })(a.SpacingMode || (a.SpacingMode = {}));
  (function(a) {
    a[a.Tangent = 0] = "Tangent";
    a[a.Chain = 1] = "Chain";
    a[a.ChainScale = 2] = "ChainScale";
  })(a.RotateMode || (a.RotateMode = {}));
})(spine || (spine = {}));
(function() {
  Math.fround || (Math.fround = function(a) {
    return function(c) {
      return a[0] = c, a[0];
    };
  }(new Float32Array(1)));
})();
(function(a) {
  var c = function() {
    function a(a) {
      this.toLoad = [];
      this.assets = {};
      this.clientId = a;
    }
    a.prototype.loaded = function() {
      var a = 0, b;
      for (b in this.assets) {
        a++;
      }
      return a;
    };
    return a;
  }(), g = function() {
    function a(a) {
      void 0 === a && (a = "");
      this.clientAssets = {};
      this.queuedAssets = {};
      this.rawAssets = {};
      this.errors = {};
      this.pathPrefix = a;
    }
    a.prototype.queueAsset = function(a, b, k) {
      var e = this.clientAssets[a];
      if (null === e || void 0 === e) {
        e = new c(a), this.clientAssets[a] = e;
      }
      null !== b && (e.textureLoader = b);
      e.toLoad.push(k);
      if (this.queuedAssets[k] === k) {
        return !1;
      }
      this.queuedAssets[k] = k;
      return !0;
    };
    a.prototype.loadText = function(a, b) {
      var c = this;
      b = this.pathPrefix + b;
      if (this.queueAsset(a, null, b)) {
        var e = new XMLHttpRequest;
        e.onreadystatechange = function() {
          e.readyState == XMLHttpRequest.DONE && (200 <= e.status && 300 > e.status ? c.rawAssets[b] = e.responseText : c.errors[b] = "Couldn't load text " + b + ": status " + e.status + ", " + e.responseText);
        };
        e.open("GET", b, !0);
        e.send();
      }
    };
    a.prototype.loadJson = function(a, b) {
      var c = this;
      b = this.pathPrefix + b;
      if (this.queueAsset(a, null, b)) {
        var e = new XMLHttpRequest;
        e.onreadystatechange = function() {
          e.readyState == XMLHttpRequest.DONE && (200 <= e.status && 300 > e.status ? c.rawAssets[b] = JSON.parse(e.responseText) : c.errors[b] = "Couldn't load text " + b + ": status " + e.status + ", " + e.responseText);
        };
        e.open("GET", b, !0);
        e.send();
      }
    };
    a.prototype.loadTexture = function(a, b, c) {
      var e = this;
      c = this.pathPrefix + c;
      if (this.queueAsset(a, b, c)) {
        var f = new Image;
        f.src = c;
        f.crossOrigin = "anonymous";
        f.onload = function(a) {
          e.rawAssets[c] = f;
        };
        f.onerror = function(a) {
          e.errors[c] = "Couldn't load image " + c;
        };
      }
    };
    a.prototype.get = function(a, b) {
      b = this.pathPrefix + b;
      a = this.clientAssets[a];
      return null === a || void 0 === a ? !0 : a.assets[b];
    };
    a.prototype.updateClientAssets = function(a) {
      for (var b = 0; b < a.toLoad.length; b++) {
        var c = a.toLoad[b], e = a.assets[c];
        if (null === e || void 0 === e) {
          e = this.rawAssets[c], null !== e && void 0 !== e && (a.assets[c] = e instanceof HTMLImageElement ? a.textureLoader(e) : e);
        }
      }
    };
    a.prototype.isLoadingComplete = function(a) {
      a = this.clientAssets[a];
      if (null === a || void 0 === a) {
        return !0;
      }
      this.updateClientAssets(a);
      return a.toLoad.length == a.loaded();
    };
    a.prototype.dispose = function() {
    };
    a.prototype.hasErrors = function() {
      return 0 < Object.keys(this.errors).length;
    };
    a.prototype.getErrors = function() {
      return this.errors;
    };
    return a;
  }();
  a.SharedAssetManager = g;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function c(b) {
      this._updateCache = [];
      this.updateCacheReset = [];
      this.time = 0;
      this.flipY = this.flipX = !1;
      this.y = this.x = 0;
      if (null == b) {
        throw Error("data cannot be null.");
      }
      this.data = b;
      this.bones = [];
      for (var c = 0; c < b.bones.length; c++) {
        var f = b.bones[c];
        if (null == f.parent) {
          f = new a.Bone(f, this, null);
        } else {
          var k = this.bones[f.parent.index];
          f = new a.Bone(f, this, k);
          k.children.push(f);
        }
        this.bones.push(f);
      }
      this.slots = [];
      this.drawOrder = [];
      for (c = 0; c < b.slots.length; c++) {
        k = b.slots[c], f = this.bones[k.boneData.index], f = new a.Slot(k, f), this.slots.push(f), this.drawOrder.push(f);
      }
      this.ikConstraints = [];
      for (c = 0; c < b.ikConstraints.length; c++) {
        this.ikConstraints.push(new a.IkConstraint(b.ikConstraints[c], this));
      }
      this.transformConstraints = [];
      for (c = 0; c < b.transformConstraints.length; c++) {
        this.transformConstraints.push(new a.TransformConstraint(b.transformConstraints[c], this));
      }
      this.pathConstraints = [];
      for (c = 0; c < b.pathConstraints.length; c++) {
        this.pathConstraints.push(new a.PathConstraint(b.pathConstraints[c], this));
      }
      this.color = new a.Color(1, 1, 1, 1);
      this.updateCache();
    }
    c.prototype.updateCache = function() {
      this._updateCache.length = 0;
      this.updateCacheReset.length = 0;
      for (var a = this.bones, c = 0, f = a.length; c < f; c++) {
        a[c].sorted = !1;
      }
      f = this.ikConstraints;
      var k = this.transformConstraints, g = this.pathConstraints, p = f.length, m = k.length, t = g.length, d = p + m + t;
      c = 0;
      a: for (; c < d; c++) {
        for (var l = 0; l < p; l++) {
          var u = f[l];
          if (u.data.order == c) {
            this.sortIkConstraint(u);
            continue a;
          }
        }
        for (l = 0; l < m; l++) {
          if (u = k[l], u.data.order == c) {
            this.sortTransformConstraint(u);
            continue a;
          }
        }
        for (l = 0; l < t; l++) {
          if (u = g[l], u.data.order == c) {
            this.sortPathConstraint(u);
            continue a;
          }
        }
      }
      c = 0;
      for (f = a.length; c < f; c++) {
        this.sortBone(a[c]);
      }
    };
    c.prototype.sortIkConstraint = function(a) {
      this.sortBone(a.target);
      var b = a.bones, c = b[0];
      this.sortBone(c);
      if (1 < b.length) {
        var k = b[b.length - 1];
        -1 < this._updateCache.indexOf(k) || this.updateCacheReset.push(k);
      }
      this._updateCache.push(a);
      this.sortReset(c.children);
      b[b.length - 1].sorted = !0;
    };
    c.prototype.sortPathConstraint = function(b) {
      var c = b.target, f = c.data.index, k = c.bone;
      null != this.skin && this.sortPathConstraintAttachment(this.skin, f, k);
      null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, f, k);
      for (var g = 0, p = this.data.skins.length; g < p; g++) {
        this.sortPathConstraintAttachment(this.data.skins[g], f, k);
      }
      g = c.getAttachment();
      g instanceof a.PathAttachment && this.sortPathConstraintAttachmentWith(g, k);
      k = b.bones;
      c = k.length;
      for (g = 0; g < c; g++) {
        this.sortBone(k[g]);
      }
      this._updateCache.push(b);
      for (g = 0; g < c; g++) {
        this.sortReset(k[g].children);
      }
      for (g = 0; g < c; g++) {
        k[g].sorted = !0;
      }
    };
    c.prototype.sortTransformConstraint = function(a) {
      this.sortBone(a.target);
      var b = a.bones, c = b.length;
      if (a.data.local) {
        for (var k = 0; k < c; k++) {
          var g = b[k];
          this.sortBone(g.parent);
          -1 < this._updateCache.indexOf(g) || this.updateCacheReset.push(g);
        }
      } else {
        for (k = 0; k < c; k++) {
          this.sortBone(b[k]);
        }
      }
      this._updateCache.push(a);
      for (a = 0; a < c; a++) {
        this.sortReset(b[a].children);
      }
      for (a = 0; a < c; a++) {
        b[a].sorted = !0;
      }
    };
    c.prototype.sortPathConstraintAttachment = function(a, c, f) {
      if (a = a.attachments[c]) {
        for (var b in a) {
          this.sortPathConstraintAttachmentWith(a[b], f);
        }
      }
    };
    c.prototype.sortPathConstraintAttachmentWith = function(b, c) {
      if (b instanceof a.PathAttachment) {
        if (b = b.bones, null == b) {
          this.sortBone(c);
        } else {
          c = this.bones;
          for (var e = 0; e < b.length;) {
            var k = b[e++];
            for (k = e + k; e < k; e++) {
              this.sortBone(c[b[e]]);
            }
          }
        }
      }
    };
    c.prototype.sortBone = function(a) {
      if (!a.sorted) {
        var b = a.parent;
        null != b && this.sortBone(b);
        a.sorted = !0;
        this._updateCache.push(a);
      }
    };
    c.prototype.sortReset = function(a) {
      for (var b = 0, c = a.length; b < c; b++) {
        var k = a[b];
        k.sorted && this.sortReset(k.children);
        k.sorted = !1;
      }
    };
    c.prototype.updateWorldTransform = function() {
      for (var a = this.updateCacheReset, c = 0, f = a.length; c < f; c++) {
        var k = a[c];
        k.ax = k.x;
        k.ay = k.y;
        k.arotation = k.rotation;
        k.ascaleX = k.scaleX;
        k.ascaleY = k.scaleY;
        k.ashearX = k.shearX;
        k.ashearY = k.shearY;
        k.appliedValid = !0;
      }
      a = this._updateCache;
      c = 0;
      for (f = a.length; c < f; c++) {
        a[c].update();
      }
    };
    c.prototype.setToSetupPose = function() {
      this.setBonesToSetupPose();
      this.setSlotsToSetupPose();
    };
    c.prototype.setBonesToSetupPose = function() {
      for (var a = this.bones, c = 0, f = a.length; c < f; c++) {
        a[c].setToSetupPose();
      }
      var k = this.ikConstraints;
      c = 0;
      for (f = k.length; c < f; c++) {
        a = k[c], a.bendDirection = a.data.bendDirection, a.mix = a.data.mix;
      }
      var g = this.transformConstraints;
      c = 0;
      for (f = g.length; c < f; c++) {
        a = g[c], k = a.data, a.rotateMix = k.rotateMix, a.translateMix = k.translateMix, a.scaleMix = k.scaleMix, a.shearMix = k.shearMix;
      }
      g = this.pathConstraints;
      c = 0;
      for (f = g.length; c < f; c++) {
        a = g[c], k = a.data, a.position = k.position, a.spacing = k.spacing, a.rotateMix = k.rotateMix, a.translateMix = k.translateMix;
      }
    };
    c.prototype.setSlotsToSetupPose = function() {
      var b = this.slots;
      a.Utils.arrayCopy(b, 0, this.drawOrder, 0, b.length);
      for (var c = 0, f = b.length; c < f; c++) {
        b[c].setToSetupPose();
      }
    };
    c.prototype.getRootBone = function() {
      return 0 == this.bones.length ? null : this.bones[0];
    };
    c.prototype.findBone = function(a) {
      if (null == a) {
        throw Error("boneName cannot be null.");
      }
      for (var b = this.bones, c = 0, k = b.length; c < k; c++) {
        var g = b[c];
        if (g.data.name == a) {
          return g;
        }
      }
      return null;
    };
    c.prototype.findBoneIndex = function(a) {
      if (null == a) {
        throw Error("boneName cannot be null.");
      }
      for (var b = this.bones, c = 0, k = b.length; c < k; c++) {
        if (b[c].data.name == a) {
          return c;
        }
      }
      return -1;
    };
    c.prototype.findSlot = function(a) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var b = this.slots, c = 0, k = b.length; c < k; c++) {
        var g = b[c];
        if (g.data.name == a) {
          return g;
        }
      }
      return null;
    };
    c.prototype.findSlotIndex = function(a) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var b = this.slots, c = 0, k = b.length; c < k; c++) {
        if (b[c].data.name == a) {
          return c;
        }
      }
      return -1;
    };
    c.prototype.setSkinByName = function(a) {
      var b = this.data.findSkin(a);
      if (null == b) {
        throw Error("Skin not found: " + a);
      }
      this.setSkin(b);
    };
    c.prototype.setSkin = function(a) {
      if (null != a) {
        if (null != this.skin) {
          a.attachAll(this, this.skin);
        } else {
          for (var b = this.slots, c = 0, k = b.length; c < k; c++) {
            var g = b[c], p = g.data.attachmentName;
            null != p && (p = a.getAttachment(c, p), null != p && g.setAttachment(p));
          }
        }
      }
      this.skin = a;
    };
    c.prototype.getAttachmentByName = function(a, c) {
      return this.getAttachment(this.data.findSlotIndex(a), c);
    };
    c.prototype.getAttachment = function(a, c) {
      if (null == c) {
        throw Error("attachmentName cannot be null.");
      }
      if (null != this.skin) {
        var b = this.skin.getAttachment(a, c);
        if (null != b) {
          return b;
        }
      }
      return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(a, c) : null;
    };
    c.prototype.setAttachment = function(a, c) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var b = this.slots, e = 0, g = b.length; e < g; e++) {
        var p = b[e];
        if (p.data.name == a) {
          b = null;
          if (null != c && (b = this.getAttachment(e, c), null == b)) {
            throw Error("Attachment not found: " + c + ", for slot: " + a);
          }
          p.setAttachment(b);
          return;
        }
      }
      throw Error("Slot not found: " + a);
    };
    c.prototype.findIkConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var b = this.ikConstraints, c = 0, k = b.length; c < k; c++) {
        var g = b[c];
        if (g.data.name == a) {
          return g;
        }
      }
      return null;
    };
    c.prototype.findTransformConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var b = this.transformConstraints, c = 0, k = b.length; c < k; c++) {
        var g = b[c];
        if (g.data.name == a) {
          return g;
        }
      }
      return null;
    };
    c.prototype.findPathConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var b = this.pathConstraints, c = 0, k = b.length; c < k; c++) {
        var g = b[c];
        if (g.data.name == a) {
          return g;
        }
      }
      return null;
    };
    c.prototype.getBounds = function(b, c, f) {
      if (null == b) {
        throw Error("offset cannot be null.");
      }
      if (null == c) {
        throw Error("size cannot be null.");
      }
      for (var e = this.drawOrder, g = Number.POSITIVE_INFINITY, p = Number.POSITIVE_INFINITY, m = Number.NEGATIVE_INFINITY, t = Number.NEGATIVE_INFINITY, d = 0, l = e.length; d < l; d++) {
        var u = e[d], w = null, y = u.getAttachment();
        if (y instanceof a.RegionAttachment) {
          var x = 8;
          w = a.Utils.setArraySize(f, x, 0);
          y.computeWorldVertices(u.bone, w, 0, 2);
        } else {
          y instanceof a.MeshAttachment && (x = y.worldVerticesLength, w = a.Utils.setArraySize(f, x, 0), y.computeWorldVertices(u, 0, x, w, 0, 2));
        }
        if (null != w) {
          for (u = 0, x = w.length; u < x; u += 2) {
            y = w[u];
            var q = w[u + 1];
            g = Math.min(g, y);
            p = Math.min(p, q);
            m = Math.max(m, y);
            t = Math.max(t, q);
          }
        }
      }
      b.set(g, p);
      c.set(m - g, t - p);
    };
    c.prototype.update = function(a) {
      this.time += a;
    };
    return c;
  }();
  a.Skeleton = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function c() {
      this.maxY = this.maxX = this.minY = this.minX = 0;
      this.boundingBoxes = [];
      this.polygons = [];
      this.polygonPool = new a.Pool(function() {
        return a.Utils.newFloatArray(16);
      });
    }
    c.prototype.update = function(b, c) {
      if (null == b) {
        throw Error("skeleton cannot be null.");
      }
      var e = this.boundingBoxes, k = this.polygons, g = this.polygonPool;
      b = b.slots;
      var p = b.length;
      e.length = 0;
      g.freeAll(k);
      for (var m = k.length = 0; m < p; m++) {
        var t = b[m], d = t.getAttachment();
        if (d instanceof a.BoundingBoxAttachment) {
          e.push(d);
          var l = g.obtain();
          l.length != d.worldVerticesLength && (l = a.Utils.newFloatArray(d.worldVerticesLength));
          k.push(l);
          d.computeWorldVertices(t, 0, d.worldVerticesLength, l, 0, 2);
        }
      }
      c ? this.aabbCompute() : (this.minY = this.minX = Number.POSITIVE_INFINITY, this.maxY = this.maxX = Number.NEGATIVE_INFINITY);
    };
    c.prototype.aabbCompute = function() {
      for (var a = Number.POSITIVE_INFINITY, c = Number.POSITIVE_INFINITY, f = Number.NEGATIVE_INFINITY, k = Number.NEGATIVE_INFINITY, g = this.polygons, p = 0, m = g.length; p < m; p++) {
        var t = g[p], d = t, l = 0;
        for (t = t.length; l < t; l += 2) {
          var u = d[l], w = d[l + 1];
          a = Math.min(a, u);
          c = Math.min(c, w);
          f = Math.max(f, u);
          k = Math.max(k, w);
        }
      }
      this.minX = a;
      this.minY = c;
      this.maxX = f;
      this.maxY = k;
    };
    c.prototype.aabbContainsPoint = function(a, c) {
      return a >= this.minX && a <= this.maxX && c >= this.minY && c <= this.maxY;
    };
    c.prototype.aabbIntersectsSegment = function(a, c, f, k) {
      var b = this.minX, e = this.minY, g = this.maxX, t = this.maxY;
      if (a <= b && f <= b || c <= e && k <= e || a >= g && f >= g || c >= t && k >= t) {
        return !1;
      }
      f = (k - c) / (f - a);
      k = f * (b - a) + c;
      if (k > e && k < t) {
        return !0;
      }
      k = f * (g - a) + c;
      if (k > e && k < t) {
        return !0;
      }
      e = (e - c) / f + a;
      if (e > b && e < g) {
        return !0;
      }
      e = (t - c) / f + a;
      return e > b && e < g ? !0 : !1;
    };
    c.prototype.aabbIntersectsSkeleton = function(a) {
      return this.minX < a.maxX && this.maxX > a.minX && this.minY < a.maxY && this.maxY > a.minY;
    };
    c.prototype.containsPoint = function(a, c) {
      for (var b = this.polygons, e = 0, g = b.length; e < g; e++) {
        if (this.containsPointPolygon(b[e], a, c)) {
          return this.boundingBoxes[e];
        }
      }
      return null;
    };
    c.prototype.containsPointPolygon = function(a, c, f) {
      for (var b = a.length, e = b - 2, g = !1, m = 0; m < b; m += 2) {
        var t = a[m + 1], d = a[e + 1];
        if (t < f && d >= f || d < f && t >= f) {
          var l = a[m];
          l + (f - t) / (d - t) * (a[e] - l) < c && (g = !g);
        }
        e = m;
      }
      return g;
    };
    c.prototype.intersectsSegment = function(a, c, f, k) {
      for (var b = this.polygons, e = 0, g = b.length; e < g; e++) {
        if (this.intersectsSegmentPolygon(b[e], a, c, f, k)) {
          return this.boundingBoxes[e];
        }
      }
      return null;
    };
    c.prototype.intersectsSegmentPolygon = function(a, c, f, k, g) {
      for (var b = a.length, e = c - k, n = f - g, d = c * g - f * k, l = a[b - 2], u = a[b - 1], w = 0; w < b; w += 2) {
        var y = a[w], x = a[w + 1], q = l * x - u * y, v = l - y, z = u - x, C = e * z - n * v;
        v = (d * v - e * q) / C;
        if ((v >= l && v <= y || v >= y && v <= l) && (v >= c && v <= k || v >= k && v <= c) && (l = (d * z - n * q) / C, (l >= u && l <= x || l >= x && l <= u) && (l >= f && l <= g || l >= g && l <= f))) {
          return !0;
        }
        l = y;
        u = x;
      }
      return !1;
    };
    c.prototype.getPolygon = function(a) {
      if (null == a) {
        throw Error("boundingBox cannot be null.");
      }
      a = this.boundingBoxes.indexOf(a);
      return -1 == a ? null : this.polygons[a];
    };
    c.prototype.getWidth = function() {
      return this.maxX - this.minX;
    };
    c.prototype.getHeight = function() {
      return this.maxY - this.minY;
    };
    return c;
  }();
  a.SkeletonBounds = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function c() {
      this.triangulator = new a.Triangulator;
      this.clippingPolygon = [];
      this.clipOutput = [];
      this.clippedVertices = [];
      this.clippedTriangles = [];
      this.scratch = [];
    }
    c.prototype.clipStart = function(b, e) {
      if (null != this.clipAttachment) {
        return 0;
      }
      this.clipAttachment = e;
      var f = e.worldVerticesLength, k = a.Utils.setArraySize(this.clippingPolygon, f);
      e.computeWorldVertices(b, 0, f, k, 0, 2);
      b = this.clippingPolygon;
      c.makeClockwise(b);
      b = this.clippingPolygons = this.triangulator.decompose(b, this.triangulator.triangulate(b));
      e = 0;
      for (f = b.length; e < f; e++) {
        k = b[e], c.makeClockwise(k), k.push(k[0]), k.push(k[1]);
      }
      return b.length;
    };
    c.prototype.clipEndWithSlot = function(a) {
      null != this.clipAttachment && this.clipAttachment.endSlot == a.data && this.clipEnd();
    };
    c.prototype.clipEnd = function() {
      null != this.clipAttachment && (this.clippingPolygons = this.clipAttachment = null, this.clippedVertices.length = 0, this.clippedTriangles.length = 0, this.clippingPolygon.length = 0);
    };
    c.prototype.isClipping = function() {
      return null != this.clipAttachment;
    };
    c.prototype.clipTriangles = function(b, c, f, k, g, p, m, t) {
      c = this.clipOutput;
      var d = this.clippedVertices, e = this.clippedTriangles, n = this.clippingPolygons, w = this.clippingPolygons.length, y = t ? 12 : 8, x = 0;
      d.length = 0;
      var q = e.length = 0;
      a: for (; q < k; q += 3) {
        var v = f[q] << 1, z = b[v], C = b[v + 1], A = g[v], D = g[v + 1];
        v = f[q + 1] << 1;
        var E = b[v], B = b[v + 1], G = g[v], H = g[v + 1];
        v = f[q + 2] << 1;
        var K = b[v], I = b[v + 1], L = g[v];
        v = g[v + 1];
        for (var R = 0; R < w; R++) {
          var J = d.length;
          if (this.clip(z, C, E, B, K, I, n[R], c)) {
            var Q = c.length;
            if (0 != Q) {
              for (var aa = B - I, U = K - E, N = z - K, S = I - C, V = 1 / (aa * N + U * (C - I)), M = Q >> 1, O = this.clipOutput, P = a.Utils.setArraySize(d, J + M * y), ka = 0; ka < Q; ka += 2) {
                var ha = O[ka], ja = O[ka + 1];
                P[J] = ha;
                P[J + 1] = ja;
                P[J + 2] = p.r;
                P[J + 3] = p.g;
                P[J + 4] = p.b;
                P[J + 5] = p.a;
                ha -= K;
                var X = ja - I;
                ja = (aa * ha + U * X) * V;
                ha = (S * ha + N * X) * V;
                X = 1 - ja - ha;
                P[J + 6] = A * ja + G * ha + L * X;
                P[J + 7] = D * ja + H * ha + v * X;
                t && (P[J + 8] = m.r, P[J + 9] = m.g, P[J + 10] = m.b, P[J + 11] = m.a);
                J += y;
              }
              J = e.length;
              Q = a.Utils.setArraySize(e, J + 3 * (M - 2));
              M--;
              for (ka = 1; ka < M; ka++) {
                Q[J] = x, Q[J + 1] = x + ka, Q[J + 2] = x + ka + 1, J += 3;
              }
              x += M + 1;
            }
          } else {
            P = a.Utils.setArraySize(d, J + 3 * y);
            P[J] = z;
            P[J + 1] = C;
            P[J + 2] = p.r;
            P[J + 3] = p.g;
            P[J + 4] = p.b;
            P[J + 5] = p.a;
            t ? (P[J + 6] = A, P[J + 7] = D, P[J + 8] = m.r, P[J + 9] = m.g, P[J + 10] = m.b, P[J + 11] = m.a, P[J + 12] = E, P[J + 13] = B, P[J + 14] = p.r, P[J + 15] = p.g, P[J + 16] = p.b, P[J + 17] = p.a, P[J + 18] = G, P[J + 19] = H, P[J + 20] = m.r, P[J + 21] = m.g, P[J + 22] = m.b, P[J + 23] = m.a, P[J + 24] = K, P[J + 25] = I, P[J + 26] = p.r, P[J + 27] = p.g, P[J + 28] = p.b, P[J + 29] = p.a, P[J + 30] = L, P[J + 31] = v, P[J + 32] = m.r, P[J + 33] = m.g, P[J + 34] = m.b, P[J + 35] = m.a) : 
            (P[J + 6] = A, P[J + 7] = D, P[J + 8] = E, P[J + 9] = B, P[J + 10] = p.r, P[J + 11] = p.g, P[J + 12] = p.b, P[J + 13] = p.a, P[J + 14] = G, P[J + 15] = H, P[J + 16] = K, P[J + 17] = I, P[J + 18] = p.r, P[J + 19] = p.g, P[J + 20] = p.b, P[J + 21] = p.a, P[J + 22] = L, P[J + 23] = v);
            J = e.length;
            Q = a.Utils.setArraySize(e, J + 3);
            Q[J] = x;
            Q[J + 1] = x + 1;
            Q[J + 2] = x + 2;
            x += 3;
            continue a;
          }
        }
      }
    };
    c.prototype.clip = function(a, c, f, k, g, p, m, t) {
      var b = t, e = !1;
      if (2 <= m.length % 4) {
        var n = t;
        t = this.scratch;
      } else {
        n = this.scratch;
      }
      n.length = 0;
      n.push(a);
      n.push(c);
      n.push(f);
      n.push(k);
      n.push(g);
      n.push(p);
      n.push(a);
      n.push(c);
      t.length = 0;
      c = m.length - 4;
      for (a = 0;; a += 2) {
        f = m[a];
        k = m[a + 1];
        g = m[a + 2];
        p = m[a + 3];
        for (var w = f - g, y = k - p, x = n, q = n.length - 2, v = t.length, z = 0; z < q; z += 2) {
          var C = x[z], A = x[z + 1], D = x[z + 2], E = x[z + 3], B = 0 < w * (E - p) - y * (D - g);
          if (0 < w * (A - p) - y * (C - g)) {
            if (B) {
              t.push(D);
              t.push(E);
              continue;
            }
            e = E - A;
            B = D - C;
            e = (B * (k - A) - e * (f - C)) / (e * (g - f) - B * (p - k));
            t.push(f + (g - f) * e);
            t.push(k + (p - k) * e);
          } else {
            B && (e = E - A, B = D - C, e = (B * (k - A) - e * (f - C)) / (e * (g - f) - B * (p - k)), t.push(f + (g - f) * e), t.push(k + (p - k) * e), t.push(D), t.push(E));
          }
          e = !0;
        }
        if (v == t.length) {
          return b.length = 0, !0;
        }
        t.push(t[0]);
        t.push(t[1]);
        if (a == c) {
          break;
        }
        f = t;
        t = n;
        t.length = 0;
        n = f;
      }
      if (b != t) {
        for (a = b.length = 0, m = t.length - 2; a < m; a++) {
          b[a] = t[a];
        }
      } else {
        b.length -= 2;
      }
      return e;
    };
    c.makeClockwise = function(a) {
      for (var b = a.length, c = a[b - 2] * a[1] - a[0] * a[b - 1], k, g, p, m, t = 0, d = b - 3; t < d; t += 2) {
        k = a[t], g = a[t + 1], p = a[t + 2], m = a[t + 3], c += k * m - p * g;
      }
      if (!(0 > c)) {
        for (t = 0, c = b - 2, d = b >> 1; t < d; t += 2) {
          b = a[t], k = a[t + 1], g = c - t, a[t] = a[g], a[t + 1] = a[g + 1], a[g] = b, a[g + 1] = k;
        }
      }
    };
    return c;
  }();
  a.SkeletonClipping = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function a() {
      this.bones = [];
      this.slots = [];
      this.skins = [];
      this.events = [];
      this.animations = [];
      this.ikConstraints = [];
      this.transformConstraints = [];
      this.pathConstraints = [];
      this.fps = 0;
    }
    a.prototype.findBone = function(a) {
      if (null == a) {
        throw Error("boneName cannot be null.");
      }
      for (var b = this.bones, c = 0, k = b.length; c < k; c++) {
        var g = b[c];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findBoneIndex = function(a) {
      if (null == a) {
        throw Error("boneName cannot be null.");
      }
      for (var b = this.bones, c = 0, k = b.length; c < k; c++) {
        if (b[c].name == a) {
          return c;
        }
      }
      return -1;
    };
    a.prototype.findSlot = function(a) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var b = this.slots, c = 0, k = b.length; c < k; c++) {
        var g = b[c];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findSlotIndex = function(a) {
      if (null == a) {
        throw Error("slotName cannot be null.");
      }
      for (var b = this.slots, c = 0, k = b.length; c < k; c++) {
        if (b[c].name == a) {
          return c;
        }
      }
      return -1;
    };
    a.prototype.findSkin = function(a) {
      if (null == a) {
        throw Error("skinName cannot be null.");
      }
      for (var b = this.skins, c = 0, k = b.length; c < k; c++) {
        var g = b[c];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findEvent = function(a) {
      if (null == a) {
        throw Error("eventDataName cannot be null.");
      }
      for (var b = this.events, c = 0, k = b.length; c < k; c++) {
        var g = b[c];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findAnimation = function(a) {
      if (null == a) {
        throw Error("animationName cannot be null.");
      }
      for (var b = this.animations, c = 0, k = b.length; c < k; c++) {
        var g = b[c];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findIkConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var b = this.ikConstraints, c = 0, k = b.length; c < k; c++) {
        var g = b[c];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findTransformConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var b = this.transformConstraints, c = 0, k = b.length; c < k; c++) {
        var g = b[c];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findPathConstraint = function(a) {
      if (null == a) {
        throw Error("constraintName cannot be null.");
      }
      for (var b = this.pathConstraints, c = 0, k = b.length; c < k; c++) {
        var g = b[c];
        if (g.name == a) {
          return g;
        }
      }
      return null;
    };
    a.prototype.findPathConstraintIndex = function(a) {
      if (null == a) {
        throw Error("pathConstraintName cannot be null.");
      }
      for (var b = this.pathConstraints, c = 0, k = b.length; c < k; c++) {
        if (b[c].name == a) {
          return c;
        }
      }
      return -1;
    };
    return a;
  }();
  a.SkeletonData = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function b(a) {
      this.scale = 1;
      this.linkedMeshes = [];
      this.attachmentLoader = a;
    }
    b.prototype.readSkeletonData = function(c) {
      var e = this.scale, k = new a.SkeletonData;
      c = "string" === typeof c ? JSON.parse(c) : c;
      var g = c.skeleton;
      null != g && (k.hash = g.hash, k.version = g.spine, k.width = g.width, k.height = g.height, k.fps = g.fps, k.imagesPath = g.images);
      if (c.bones) {
        for (g = 0; g < c.bones.length; g++) {
          var p = c.bones[g], m = null, t = this.getValue(p, "parent", null);
          if (null != t && (m = k.findBone(t), null == m)) {
            throw Error("Parent bone not found: " + t);
          }
          m = new a.BoneData(k.bones.length, p.name, m);
          m.length = this.getValue(p, "length", 0) * e;
          m.x = this.getValue(p, "x", 0) * e;
          m.y = this.getValue(p, "y", 0) * e;
          m.rotation = this.getValue(p, "rotation", 0);
          m.scaleX = this.getValue(p, "scaleX", 1);
          m.scaleY = this.getValue(p, "scaleY", 1);
          m.shearX = this.getValue(p, "shearX", 0);
          m.shearY = this.getValue(p, "shearY", 0);
          m.transformMode = b.transformModeFromString(this.getValue(p, "transform", "normal"));
          k.bones.push(m);
        }
      }
      if (c.slots) {
        for (g = 0; g < c.slots.length; g++) {
          p = c.slots[g];
          var d = p.name;
          t = p.bone;
          m = k.findBone(t);
          if (null == m) {
            throw Error("Slot bone not found: " + t);
          }
          m = new a.SlotData(k.slots.length, d, m);
          t = this.getValue(p, "color", null);
          null != t && m.color.setFromString(t);
          t = this.getValue(p, "dark", null);
          null != t && (m.darkColor = new a.Color(1, 1, 1, 1), m.darkColor.setFromString(t));
          m.attachmentName = this.getValue(p, "attachment", null);
          m.blendMode = b.blendModeFromString(this.getValue(p, "blend", "normal"));
          k.slots.push(m);
        }
      }
      if (c.ik) {
        for (g = 0; g < c.ik.length; g++) {
          p = c.ik[g];
          m = new a.IkConstraintData(p.name);
          m.order = this.getValue(p, "order", 0);
          for (var l = 0; l < p.bones.length; l++) {
            t = p.bones[l];
            var u = k.findBone(t);
            if (null == u) {
              throw Error("IK bone not found: " + t);
            }
            m.bones.push(u);
          }
          t = p.target;
          m.target = k.findBone(t);
          if (null == m.target) {
            throw Error("IK target bone not found: " + t);
          }
          m.bendDirection = this.getValue(p, "bendPositive", !0) ? 1 : -1;
          m.mix = this.getValue(p, "mix", 1);
          k.ikConstraints.push(m);
        }
      }
      if (c.transform) {
        for (g = 0; g < c.transform.length; g++) {
          p = c.transform[g];
          m = new a.TransformConstraintData(p.name);
          m.order = this.getValue(p, "order", 0);
          for (l = 0; l < p.bones.length; l++) {
            t = p.bones[l];
            u = k.findBone(t);
            if (null == u) {
              throw Error("Transform constraint bone not found: " + t);
            }
            m.bones.push(u);
          }
          t = p.target;
          m.target = k.findBone(t);
          if (null == m.target) {
            throw Error("Transform constraint target bone not found: " + t);
          }
          m.local = this.getValue(p, "local", !1);
          m.relative = this.getValue(p, "relative", !1);
          m.offsetRotation = this.getValue(p, "rotation", 0);
          m.offsetX = this.getValue(p, "x", 0) * e;
          m.offsetY = this.getValue(p, "y", 0) * e;
          m.offsetScaleX = this.getValue(p, "scaleX", 0);
          m.offsetScaleY = this.getValue(p, "scaleY", 0);
          m.offsetShearY = this.getValue(p, "shearY", 0);
          m.rotateMix = this.getValue(p, "rotateMix", 1);
          m.translateMix = this.getValue(p, "translateMix", 1);
          m.scaleMix = this.getValue(p, "scaleMix", 1);
          m.shearMix = this.getValue(p, "shearMix", 1);
          k.transformConstraints.push(m);
        }
      }
      if (c.path) {
        for (g = 0; g < c.path.length; g++) {
          p = c.path[g];
          m = new a.PathConstraintData(p.name);
          m.order = this.getValue(p, "order", 0);
          for (l = 0; l < p.bones.length; l++) {
            t = p.bones[l];
            u = k.findBone(t);
            if (null == u) {
              throw Error("Transform constraint bone not found: " + t);
            }
            m.bones.push(u);
          }
          t = p.target;
          m.target = k.findSlot(t);
          if (null == m.target) {
            throw Error("Path target slot not found: " + t);
          }
          m.positionMode = b.positionModeFromString(this.getValue(p, "positionMode", "percent"));
          m.spacingMode = b.spacingModeFromString(this.getValue(p, "spacingMode", "length"));
          m.rotateMode = b.rotateModeFromString(this.getValue(p, "rotateMode", "tangent"));
          m.offsetRotation = this.getValue(p, "rotation", 0);
          m.position = this.getValue(p, "position", 0);
          m.positionMode == a.PositionMode.Fixed && (m.position *= e);
          m.spacing = this.getValue(p, "spacing", 0);
          if (m.spacingMode == a.SpacingMode.Length || m.spacingMode == a.SpacingMode.Fixed) {
            m.spacing *= e;
          }
          m.rotateMix = this.getValue(p, "rotateMix", 1);
          m.translateMix = this.getValue(p, "translateMix", 1);
          k.pathConstraints.push(m);
        }
      }
      if (c.skins) {
        for (var w in c.skins) {
          g = c.skins[w];
          e = new a.Skin(w);
          for (d in g) {
            m = k.findSlotIndex(d);
            if (-1 == m) {
              throw Error("Slot not found: " + d);
            }
            p = g[d];
            for (var y in p) {
              t = this.readAttachment(p[y], e, m, y, k), null != t && e.addAttachment(m, y, t);
            }
          }
          k.skins.push(e);
          "default" == e.name && (k.defaultSkin = e);
        }
      }
      g = 0;
      for (d = this.linkedMeshes.length; g < d; g++) {
        w = this.linkedMeshes[g];
        e = null == w.skin ? k.defaultSkin : k.findSkin(w.skin);
        if (null == e) {
          throw Error("Skin not found: " + w.skin);
        }
        y = e.getAttachment(w.slotIndex, w.parent);
        if (null == y) {
          throw Error("Parent mesh not found: " + w.parent);
        }
        w.mesh.setParentMesh(y);
        w.mesh.updateUVs();
      }
      this.linkedMeshes.length = 0;
      if (c.events) {
        for (var x in c.events) {
          d = c.events[x], m = new a.EventData(x), m.intValue = this.getValue(d, "int", 0), m.floatValue = this.getValue(d, "float", 0), m.stringValue = this.getValue(d, "string", ""), k.events.push(m);
        }
      }
      if (c.animations) {
        for (var q in c.animations) {
          this.readAnimation(c.animations[q], q, k);
        }
      }
      return k;
    };
    b.prototype.readAttachment = function(b, c, k, n, p) {
      var e = this.scale;
      n = this.getValue(b, "name", n);
      switch(this.getValue(b, "type", "region")) {
        case "region":
          p = this.getValue(b, "path", n);
          k = this.attachmentLoader.newRegionAttachment(c, n, p);
          if (null == k) {
            break;
          }
          k.path = p;
          k.x = this.getValue(b, "x", 0) * e;
          k.y = this.getValue(b, "y", 0) * e;
          k.scaleX = this.getValue(b, "scaleX", 1);
          k.scaleY = this.getValue(b, "scaleY", 1);
          k.rotation = this.getValue(b, "rotation", 0);
          k.width = b.width * e;
          k.height = b.height * e;
          e = this.getValue(b, "color", null);
          null != e && k.color.setFromString(e);
          k.updateOffset();
          return k;
        case "boundingbox":
          p = this.attachmentLoader.newBoundingBoxAttachment(c, n);
          if (null == p) {
            break;
          }
          this.readVertices(b, p, b.vertexCount << 1);
          e = this.getValue(b, "color", null);
          null != e && p.color.setFromString(e);
          return p;
        case "mesh":
        case "linkedmesh":
          p = this.getValue(b, "path", n);
          c = this.attachmentLoader.newMeshAttachment(c, n, p);
          if (null == c) {
            break;
          }
          c.path = p;
          e = this.getValue(b, "color", null);
          null != e && c.color.setFromString(e);
          e = this.getValue(b, "parent", null);
          if (null != e) {
            return c.inheritDeform = this.getValue(b, "deform", !0), this.linkedMeshes.push(new g(c, this.getValue(b, "skin", null), k, e)), c;
          }
          e = b.uvs;
          this.readVertices(b, c, e.length);
          c.triangles = b.triangles;
          c.regionUVs = e;
          c.updateUVs();
          c.hullLength = 2 * this.getValue(b, "hull", 0);
          return c;
        case "path":
          p = this.attachmentLoader.newPathAttachment(c, n);
          if (null == p) {
            break;
          }
          p.closed = this.getValue(b, "closed", !1);
          p.constantSpeed = this.getValue(b, "constantSpeed", !0);
          c = b.vertexCount;
          this.readVertices(b, p, c << 1);
          k = a.Utils.newArray(c / 3, 0);
          for (c = 0; c < b.lengths.length; c++) {
            k[c] = b.lengths[c] * e;
          }
          p.lengths = k;
          e = this.getValue(b, "color", null);
          null != e && p.color.setFromString(e);
          return p;
        case "point":
          p = this.attachmentLoader.newPointAttachment(c, n);
          if (null == p) {
            break;
          }
          p.x = this.getValue(b, "x", 0) * e;
          p.y = this.getValue(b, "y", 0) * e;
          p.rotation = this.getValue(b, "rotation", 0);
          e = this.getValue(b, "color", null);
          null != e && p.color.setFromString(e);
          return p;
        case "clipping":
          if (k = this.attachmentLoader.newClippingAttachment(c, n), null != k) {
            e = this.getValue(b, "end", null);
            if (null != e) {
              p = p.findSlot(e);
              if (null == p) {
                throw Error("Clipping end slot not found: " + e);
              }
              k.endSlot = p;
            }
            c = b.vertexCount;
            this.readVertices(b, k, c << 1);
            e = this.getValue(b, "color", null);
            null != e && k.color.setFromString(e);
            return k;
          }
      }
      return null;
    };
    b.prototype.readVertices = function(b, c, k) {
      var e = this.scale;
      c.worldVerticesLength = k;
      b = b.vertices;
      if (k == b.length) {
        var f = a.Utils.toFloatArray(b);
        if (1 != e) {
          k = 0;
          for (var g = b.length; k < g; k++) {
            f[k] *= e;
          }
        }
        c.vertices = f;
      } else {
        f = [];
        var t = [];
        k = 0;
        for (g = b.length; k < g;) {
          var d = b[k++];
          t.push(d);
          for (d = k + 4 * d; k < d; k += 4) {
            t.push(b[k]), f.push(b[k + 1] * e), f.push(b[k + 2] * e), f.push(b[k + 3]);
          }
        }
        c.bones = t;
        c.vertices = a.Utils.toFloatArray(f);
      }
    };
    b.prototype.readAnimation = function(b, c, k) {
      var e = this.scale, f = [], g = 0;
      if (b.slots) {
        for (var t in b.slots) {
          var d = b.slots[t], l = k.findSlotIndex(t);
          if (-1 == l) {
            throw Error("Slot not found: " + t);
          }
          for (var u in d) {
            var w = d[u];
            if ("attachment" == u) {
              var y = new a.AttachmentTimeline(w.length);
              y.slotIndex = l;
              for (var x = 0, q = 0; q < w.length; q++) {
                var v = w[q];
                y.setFrame(x++, v.time, v.name);
              }
              f.push(y);
              g = Math.max(g, y.frames[y.getFrameCount() - 1]);
            } else {
              if ("color" == u) {
                y = new a.ColorTimeline(w.length);
                y.slotIndex = l;
                for (q = x = 0; q < w.length; q++) {
                  v = w[q];
                  var z = new a.Color;
                  z.setFromString(v.color);
                  y.setFrame(x, v.time, z.r, z.g, z.b, z.a);
                  this.readCurve(v, y, x);
                  x++;
                }
                f.push(y);
                g = Math.max(g, y.frames[(y.getFrameCount() - 1) * a.ColorTimeline.ENTRIES]);
              } else {
                if ("twoColor" == u) {
                  y = new a.TwoColorTimeline(w.length);
                  y.slotIndex = l;
                  for (q = x = 0; q < w.length; q++) {
                    v = w[q];
                    z = new a.Color;
                    var C = new a.Color;
                    z.setFromString(v.light);
                    C.setFromString(v.dark);
                    y.setFrame(x, v.time, z.r, z.g, z.b, z.a, C.r, C.g, C.b);
                    this.readCurve(v, y, x);
                    x++;
                  }
                  f.push(y);
                  g = Math.max(g, y.frames[(y.getFrameCount() - 1) * a.TwoColorTimeline.ENTRIES]);
                } else {
                  throw Error("Invalid timeline type for a slot: " + u + " (" + t + ")");
                }
              }
            }
          }
        }
      }
      if (b.bones) {
        for (var A in b.bones) {
          d = b.bones[A];
          z = k.findBoneIndex(A);
          if (-1 == z) {
            throw Error("Bone not found: " + A);
          }
          for (u in d) {
            if (w = d[u], "rotate" === u) {
              y = new a.RotateTimeline(w.length);
              y.boneIndex = z;
              for (q = x = 0; q < w.length; q++) {
                v = w[q], y.setFrame(x, v.time, v.angle), this.readCurve(v, y, x), x++;
              }
              f.push(y);
              g = Math.max(g, y.frames[(y.getFrameCount() - 1) * a.RotateTimeline.ENTRIES]);
            } else {
              if ("translate" === u || "scale" === u || "shear" === u) {
                l = 1;
                "scale" === u ? y = new a.ScaleTimeline(w.length) : "shear" === u ? y = new a.ShearTimeline(w.length) : (y = new a.TranslateTimeline(w.length), l = e);
                y.boneIndex = z;
                for (q = x = 0; q < w.length; q++) {
                  v = w[q];
                  C = this.getValue(v, "x", 0);
                  var D = this.getValue(v, "y", 0);
                  y.setFrame(x, v.time, C * l, D * l);
                  this.readCurve(v, y, x);
                  x++;
                }
                f.push(y);
                g = Math.max(g, y.frames[(y.getFrameCount() - 1) * a.TranslateTimeline.ENTRIES]);
              } else {
                throw Error("Invalid timeline type for a bone: " + u + " (" + A + ")");
              }
            }
          }
        }
      }
      if (b.ik) {
        for (var E in b.ik) {
          d = b.ik[E];
          x = k.findIkConstraint(E);
          y = new a.IkConstraintTimeline(d.length);
          y.ikConstraintIndex = k.ikConstraints.indexOf(x);
          for (q = x = 0; q < d.length; q++) {
            v = d[q], y.setFrame(x, v.time, this.getValue(v, "mix", 1), this.getValue(v, "bendPositive", !0) ? 1 : -1), this.readCurve(v, y, x), x++;
          }
          f.push(y);
          g = Math.max(g, y.frames[(y.getFrameCount() - 1) * a.IkConstraintTimeline.ENTRIES]);
        }
      }
      if (b.transform) {
        for (E in b.transform) {
          d = b.transform[E];
          x = k.findTransformConstraint(E);
          y = new a.TransformConstraintTimeline(d.length);
          y.transformConstraintIndex = k.transformConstraints.indexOf(x);
          for (q = x = 0; q < d.length; q++) {
            v = d[q], y.setFrame(x, v.time, this.getValue(v, "rotateMix", 1), this.getValue(v, "translateMix", 1), this.getValue(v, "scaleMix", 1), this.getValue(v, "shearMix", 1)), this.readCurve(v, y, x), x++;
          }
          f.push(y);
          g = Math.max(g, y.frames[(y.getFrameCount() - 1) * a.TransformConstraintTimeline.ENTRIES]);
        }
      }
      if (b.paths) {
        for (E in b.paths) {
          d = b.paths[E];
          A = k.findPathConstraintIndex(E);
          if (-1 == A) {
            throw Error("Path constraint not found: " + E);
          }
          z = k.pathConstraints[A];
          for (u in d) {
            if (w = d[u], "position" === u || "spacing" === u) {
              l = 1;
              if ("spacing" === u) {
                if (y = new a.PathConstraintSpacingTimeline(w.length), z.spacingMode == a.SpacingMode.Length || z.spacingMode == a.SpacingMode.Fixed) {
                  l = e;
                }
              } else {
                y = new a.PathConstraintPositionTimeline(w.length), z.positionMode == a.PositionMode.Fixed && (l = e);
              }
              y.pathConstraintIndex = A;
              for (q = x = 0; q < w.length; q++) {
                v = w[q], y.setFrame(x, v.time, this.getValue(v, u, 0) * l), this.readCurve(v, y, x), x++;
              }
              f.push(y);
              g = Math.max(g, y.frames[(y.getFrameCount() - 1) * a.PathConstraintPositionTimeline.ENTRIES]);
            } else {
              if ("mix" === u) {
                y = new a.PathConstraintMixTimeline(w.length);
                y.pathConstraintIndex = A;
                for (q = x = 0; q < w.length; q++) {
                  v = w[q], y.setFrame(x, v.time, this.getValue(v, "rotateMix", 1), this.getValue(v, "translateMix", 1)), this.readCurve(v, y, x), x++;
                }
                f.push(y);
                g = Math.max(g, y.frames[(y.getFrameCount() - 1) * a.PathConstraintMixTimeline.ENTRIES]);
              }
            }
          }
        }
      }
      if (b.deform) {
        for (var B in b.deform) {
          A = b.deform[B];
          z = k.findSkin(B);
          if (null == z) {
            throw Error("Skin not found: " + B);
          }
          for (t in A) {
            d = A[t];
            l = k.findSlotIndex(t);
            if (-1 == l) {
              throw Error("Slot not found: " + d.name);
            }
            for (u in d) {
              w = d[u];
              x = z.getAttachment(l, u);
              if (null == x) {
                throw Error("Deform attachment not found: " + w.name);
              }
              C = null != x.bones;
              D = x.vertices;
              var G = C ? D.length / 3 * 2 : D.length;
              y = new a.DeformTimeline(w.length);
              y.slotIndex = l;
              y.attachment = x;
              for (E = x = 0; E < w.length; E++) {
                v = w[E];
                var H = this.getValue(v, "vertices", null);
                if (null == H) {
                  var K = C ? a.Utils.newFloatArray(G) : D;
                } else {
                  K = a.Utils.newFloatArray(G);
                  q = this.getValue(v, "offset", 0);
                  a.Utils.arrayCopy(H, 0, K, q, H.length);
                  if (1 != e) {
                    for (H = q + H.length; q < H; q++) {
                      K[q] *= e;
                    }
                  }
                  if (!C) {
                    for (q = 0; q < G; q++) {
                      K[q] += D[q];
                    }
                  }
                }
                y.setFrame(x, v.time, K);
                this.readCurve(v, y, x);
                x++;
              }
              f.push(y);
              g = Math.max(g, y.frames[y.getFrameCount() - 1]);
            }
          }
        }
      }
      e = b.drawOrder;
      null == e && (e = b.draworder);
      if (null != e) {
        y = new a.DrawOrderTimeline(e.length);
        t = k.slots.length;
        for (E = x = 0; E < e.length; E++) {
          u = e[E];
          B = null;
          w = this.getValue(u, "offsets", null);
          if (null != w) {
            B = a.Utils.newArray(t, -1);
            v = a.Utils.newArray(t - w.length, 0);
            for (q = A = d = 0; q < w.length; q++) {
              z = w[q];
              l = k.findSlotIndex(z.slot);
              if (-1 == l) {
                throw Error("Slot not found: " + z.slot);
              }
              for (; d != l;) {
                v[A++] = d++;
              }
              B[d + z.offset] = d++;
            }
            for (; d < t;) {
              v[A++] = d++;
            }
            for (q = t - 1; 0 <= q; q--) {
              -1 == B[q] && (B[q] = v[--A]);
            }
          }
          y.setFrame(x++, u.time, B);
        }
        f.push(y);
        g = Math.max(g, y.frames[y.getFrameCount() - 1]);
      }
      if (b.events) {
        y = new a.EventTimeline(b.events.length);
        for (q = x = 0; q < b.events.length; q++) {
          e = b.events[q];
          t = k.findEvent(e.name);
          if (null == t) {
            throw Error("Event not found: " + e.name);
          }
          l = new a.Event(a.Utils.toSinglePrecision(e.time), t);
          l.intValue = this.getValue(e, "int", t.intValue);
          l.floatValue = this.getValue(e, "float", t.floatValue);
          l.stringValue = this.getValue(e, "string", t.stringValue);
          y.setFrame(x++, l);
        }
        f.push(y);
        g = Math.max(g, y.frames[y.getFrameCount() - 1]);
      }
      if (isNaN(g)) {
        throw Error("Error while parsing animation, duration is NaN");
      }
      k.animations.push(new a.Animation(c, f, g));
    };
    b.prototype.readCurve = function(a, b, c) {
      a.curve && ("stepped" === a.curve ? b.setStepped(c) : "[object Array]" === Object.prototype.toString.call(a.curve) && (a = a.curve, b.setCurve(c, a[0], a[1], a[2], a[3])));
    };
    b.prototype.getValue = function(a, b, c) {
      return void 0 !== a[b] ? a[b] : c;
    };
    b.blendModeFromString = function(b) {
      b = b.toLowerCase();
      if ("normal" == b) {
        return a.BlendMode.Normal;
      }
      if ("additive" == b) {
        return a.BlendMode.Additive;
      }
      if ("multiply" == b) {
        return a.BlendMode.Multiply;
      }
      if ("screen" == b) {
        return a.BlendMode.Screen;
      }
      throw Error("Unknown blend mode: " + b);
    };
    b.positionModeFromString = function(b) {
      b = b.toLowerCase();
      if ("fixed" == b) {
        return a.PositionMode.Fixed;
      }
      if ("percent" == b) {
        return a.PositionMode.Percent;
      }
      throw Error("Unknown position mode: " + b);
    };
    b.spacingModeFromString = function(b) {
      b = b.toLowerCase();
      if ("length" == b) {
        return a.SpacingMode.Length;
      }
      if ("fixed" == b) {
        return a.SpacingMode.Fixed;
      }
      if ("percent" == b) {
        return a.SpacingMode.Percent;
      }
      throw Error("Unknown position mode: " + b);
    };
    b.rotateModeFromString = function(b) {
      b = b.toLowerCase();
      if ("tangent" == b) {
        return a.RotateMode.Tangent;
      }
      if ("chain" == b) {
        return a.RotateMode.Chain;
      }
      if ("chainscale" == b) {
        return a.RotateMode.ChainScale;
      }
      throw Error("Unknown rotate mode: " + b);
    };
    b.transformModeFromString = function(b) {
      b = b.toLowerCase();
      if ("normal" == b) {
        return a.TransformMode.Normal;
      }
      if ("onlytranslation" == b) {
        return a.TransformMode.OnlyTranslation;
      }
      if ("norotationorreflection" == b) {
        return a.TransformMode.NoRotationOrReflection;
      }
      if ("noscale" == b) {
        return a.TransformMode.NoScale;
      }
      if ("noscaleorreflection" == b) {
        return a.TransformMode.NoScaleOrReflection;
      }
      throw Error("Unknown transform mode: " + b);
    };
    return b;
  }();
  a.SkeletonJson = c;
  var g = function() {
    return function(a, c, f, g) {
      this.mesh = a;
      this.skin = c;
      this.slotIndex = f;
      this.parent = g;
    };
  }();
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function a(a) {
      this.attachments = [];
      if (null == a) {
        throw Error("name cannot be null.");
      }
      this.name = a;
    }
    a.prototype.addAttachment = function(a, c, f) {
      if (null == f) {
        throw Error("attachment cannot be null.");
      }
      var b = this.attachments;
      a >= b.length && (b.length = a + 1);
      b[a] || (b[a] = {});
      b[a][c] = f;
    };
    a.prototype.getAttachment = function(a, c) {
      return (a = this.attachments[a]) ? a[c] : null;
    };
    a.prototype.attachAll = function(a, c) {
      for (var b = 0, e = 0; e < a.slots.length; e++) {
        var g = a.slots[e], p = g.getAttachment();
        if (p && b < c.attachments.length) {
          var m = c.attachments[b], t;
          for (t in m) {
            if (p == m[t]) {
              p = this.getAttachment(b, t);
              null != p && g.setAttachment(p);
              break;
            }
          }
        }
        b++;
      }
    };
    return a;
  }();
  a.Skin = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function c(b, c) {
      this.attachmentVertices = [];
      if (null == b) {
        throw Error("data cannot be null.");
      }
      if (null == c) {
        throw Error("bone cannot be null.");
      }
      this.data = b;
      this.bone = c;
      this.color = new a.Color;
      this.darkColor = null == b.darkColor ? null : new a.Color;
      this.setToSetupPose();
    }
    c.prototype.getAttachment = function() {
      return this.attachment;
    };
    c.prototype.setAttachment = function(a) {
      this.attachment != a && (this.attachment = a, this.attachmentTime = this.bone.skeleton.time, this.attachmentVertices.length = 0);
    };
    c.prototype.setAttachmentTime = function(a) {
      this.attachmentTime = this.bone.skeleton.time - a;
    };
    c.prototype.getAttachmentTime = function() {
      return this.bone.skeleton.time - this.attachmentTime;
    };
    c.prototype.setToSetupPose = function() {
      this.color.setFromColor(this.data.color);
      null != this.darkColor && this.darkColor.setFromColor(this.data.darkColor);
      null == this.data.attachmentName ? this.attachment = null : (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)));
    };
    return c;
  }();
  a.Slot = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    return function(c, b, e) {
      this.color = new a.Color(1, 1, 1, 1);
      if (0 > c) {
        throw Error("index must be >= 0.");
      }
      if (null == b) {
        throw Error("name cannot be null.");
      }
      if (null == e) {
        throw Error("boneData cannot be null.");
      }
      this.index = c;
      this.name = b;
      this.boneData = e;
    };
  }();
  a.SlotData = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function a(a) {
      this._image = a;
    }
    a.prototype.getImage = function() {
      return this._image;
    };
    a.filterFromString = function(a) {
      switch(a.toLowerCase()) {
        case "nearest":
          return g.Nearest;
        case "linear":
          return g.Linear;
        case "mipmap":
          return g.MipMap;
        case "mipmapnearestnearest":
          return g.MipMapNearestNearest;
        case "mipmaplinearnearest":
          return g.MipMapLinearNearest;
        case "mipmapnearestlinear":
          return g.MipMapNearestLinear;
        case "mipmaplinearlinear":
          return g.MipMapLinearLinear;
        default:
          throw Error("Unknown texture filter " + a);
      }
    };
    a.wrapFromString = function(a) {
      switch(a.toLowerCase()) {
        case "mirroredtepeat":
          return b.MirroredRepeat;
        case "clamptoedge":
          return b.ClampToEdge;
        case "repeat":
          return b.Repeat;
        default:
          throw Error("Unknown texture wrap " + a);
      }
    };
    return a;
  }();
  a.Texture = c;
  (function(a) {
    a[a.Nearest = 9728] = "Nearest";
    a[a.Linear = 9729] = "Linear";
    a[a.MipMap = 9987] = "MipMap";
    a[a.MipMapNearestNearest = 9984] = "MipMapNearestNearest";
    a[a.MipMapLinearNearest = 9985] = "MipMapLinearNearest";
    a[a.MipMapNearestLinear = 9986] = "MipMapNearestLinear";
    a[a.MipMapLinearLinear = 9987] = "MipMapLinearLinear";
  })(a.TextureFilter || (a.TextureFilter = {}));
  var g = a.TextureFilter;
  (function(a) {
    a[a.MirroredRepeat = 33648] = "MirroredRepeat";
    a[a.ClampToEdge = 33071] = "ClampToEdge";
    a[a.Repeat = 10497] = "Repeat";
  })(a.TextureWrap || (a.TextureWrap = {}));
  var b = a.TextureWrap;
  c = function() {
    return function() {
      this.height = this.width = this.v2 = this.u2 = this.v = this.u = 0;
      this.rotate = !1;
      this.originalHeight = this.originalWidth = this.offsetY = this.offsetX = 0;
    };
  }();
  a.TextureRegion = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function c(a, b) {
      this.pages = [];
      this.regions = [];
      this.load(a, b);
    }
    c.prototype.load = function(c, f) {
      if (null == f) {
        throw Error("textureLoader cannot be null.");
      }
      c = new g(c);
      for (var k = Array(4), m = null;;) {
        var n = c.readLine();
        if (null == n) {
          break;
        }
        n = n.trim();
        if (0 == n.length) {
          m = null;
        } else {
          if (m) {
            var d = new e;
            d.name = n;
            d.page = m;
            d.rotate = "true" == c.readValue();
            c.readTuple(k);
            n = parseInt(k[0]);
            var l = parseInt(k[1]);
            c.readTuple(k);
            var u = parseInt(k[0]), w = parseInt(k[1]);
            d.u = n / m.width;
            d.v = l / m.height;
            d.rotate ? (d.u2 = (n + w) / m.width, d.v2 = (l + u) / m.height) : (d.u2 = (n + u) / m.width, d.v2 = (l + w) / m.height);
            d.x = n;
            d.y = l;
            d.width = Math.abs(u);
            d.height = Math.abs(w);
            4 == c.readTuple(k) && 4 == c.readTuple(k) && c.readTuple(k);
            d.originalWidth = parseInt(k[0]);
            d.originalHeight = parseInt(k[1]);
            c.readTuple(k);
            d.offsetX = parseInt(k[0]);
            d.offsetY = parseInt(k[1]);
            d.index = parseInt(c.readValue());
            d.texture = m.texture;
            this.regions.push(d);
          } else {
            m = new b, m.name = n, 2 == c.readTuple(k) && (m.width = parseInt(k[0]), m.height = parseInt(k[1]), c.readTuple(k)), c.readTuple(k), m.minFilter = a.Texture.filterFromString(k[0]), m.magFilter = a.Texture.filterFromString(k[1]), d = c.readValue(), m.uWrap = a.TextureWrap.ClampToEdge, m.vWrap = a.TextureWrap.ClampToEdge, "x" == d ? m.uWrap = a.TextureWrap.Repeat : "y" == d ? m.vWrap = a.TextureWrap.Repeat : "xy" == d && (m.uWrap = m.vWrap = a.TextureWrap.Repeat), m.texture = f(n), m.texture.setFilters(m.minFilter, 
            m.magFilter), m.texture.setWraps(m.uWrap, m.vWrap), m.width = m.texture.getImage().width, m.height = m.texture.getImage().height, this.pages.push(m);
          }
        }
      }
    };
    c.prototype.findRegion = function(a) {
      for (var b = 0; b < this.regions.length; b++) {
        if (this.regions[b].name == a) {
          return this.regions[b];
        }
      }
      return null;
    };
    c.prototype.dispose = function() {
      for (var a = 0; a < this.pages.length; a++) {
        this.pages[a].texture.dispose();
      }
    };
    return c;
  }();
  a.TextureAtlas = c;
  var g = function() {
    function a(a) {
      this.index = 0;
      this.lines = a.split(/\r\n|\r|\n/);
    }
    a.prototype.readLine = function() {
      return this.index >= this.lines.length ? null : this.lines[this.index++];
    };
    a.prototype.readValue = function() {
      var a = this.readLine(), b = a.indexOf(":");
      if (-1 == b) {
        throw Error("Invalid line: " + a);
      }
      return a.substring(b + 1).trim();
    };
    a.prototype.readTuple = function(a) {
      var b = this.readLine(), c = b.indexOf(":");
      if (-1 == c) {
        throw Error("Invalid line: " + b);
      }
      var e = 0;
      for (c += 1; 3 > e; e++) {
        var f = b.indexOf(",", c);
        if (-1 == f) {
          break;
        }
        a[e] = b.substr(c, f - c).trim();
        c = f + 1;
      }
      a[e] = b.substring(c).trim();
      return e + 1;
    };
    return a;
  }(), b = function() {
    return function() {
    };
  }();
  a.TextureAtlasPage = b;
  var e = function(a) {
    function b() {
      a.apply(this, arguments);
    }
    __extends(b, a);
    return b;
  }(a.TextureRegion);
  a.TextureAtlasRegion = e;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function c(b, c) {
      this.shearMix = this.scaleMix = this.translateMix = this.rotateMix = 0;
      this.temp = new a.Vector2;
      if (null == b) {
        throw Error("data cannot be null.");
      }
      if (null == c) {
        throw Error("skeleton cannot be null.");
      }
      this.data = b;
      this.rotateMix = b.rotateMix;
      this.translateMix = b.translateMix;
      this.scaleMix = b.scaleMix;
      this.shearMix = b.shearMix;
      this.bones = [];
      for (var e = 0; e < b.bones.length; e++) {
        this.bones.push(c.findBone(b.bones[e].name));
      }
      this.target = c.findBone(b.target.name);
    }
    c.prototype.apply = function() {
      this.update();
    };
    c.prototype.update = function() {
      this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld();
    };
    c.prototype.applyAbsoluteWorld = function() {
      var b = this.rotateMix, c = this.translateMix, f = this.scaleMix, g = this.shearMix, n = this.target, p = n.a, m = n.b, t = n.c, d = n.d, l = 0 < p * d - m * t ? a.MathUtils.degRad : -a.MathUtils.degRad, u = this.data.offsetRotation * l;
      l *= this.data.offsetShearY;
      for (var w = this.bones, y = 0, x = w.length; y < x; y++) {
        var q = w[y], v = !1;
        if (0 != b) {
          var z = q.a;
          v = q.b;
          var C = q.c, A = q.d, D = Math.atan2(t, p) - Math.atan2(C, z) + u;
          D > a.MathUtils.PI ? D -= a.MathUtils.PI2 : D < -a.MathUtils.PI && (D += a.MathUtils.PI2);
          D *= b;
          var E = Math.cos(D);
          D = Math.sin(D);
          q.a = E * z - D * C;
          q.b = E * v - D * A;
          q.c = D * z + E * C;
          q.d = D * v + E * A;
          v = !0;
        }
        0 != c && (v = this.temp, n.localToWorld(v.set(this.data.offsetX, this.data.offsetY)), q.worldX += (v.x - q.worldX) * c, q.worldY += (v.y - q.worldY) * c, v = !0);
        0 < f && (v = Math.sqrt(q.a * q.a + q.c * q.c), A = Math.sqrt(p * p + t * t), 1E-5 < v && (v = (v + (A - v + this.data.offsetScaleX) * f) / v), q.a *= v, q.c *= v, v = Math.sqrt(q.b * q.b + q.d * q.d), A = Math.sqrt(m * m + d * d), 1E-5 < v && (v = (v + (A - v + this.data.offsetScaleY) * f) / v), q.b *= v, q.d *= v, v = !0);
        0 < g && (v = q.b, A = q.d, z = Math.atan2(A, v), D = Math.atan2(d, m) - Math.atan2(t, p) - (z - Math.atan2(q.c, q.a)), D > a.MathUtils.PI ? D -= a.MathUtils.PI2 : D < -a.MathUtils.PI && (D += a.MathUtils.PI2), D = z + (D + l) * g, v = Math.sqrt(v * v + A * A), q.b = Math.cos(D) * v, q.d = Math.sin(D) * v, v = !0);
        v && (q.appliedValid = !1);
      }
    };
    c.prototype.applyRelativeWorld = function() {
      var b = this.rotateMix, c = this.translateMix, f = this.scaleMix, g = this.shearMix, n = this.target, p = n.a, m = n.b, t = n.c, d = n.d, l = 0 < p * d - m * t ? a.MathUtils.degRad : -a.MathUtils.degRad, u = this.data.offsetRotation * l;
      l *= this.data.offsetShearY;
      for (var w = this.bones, y = 0, x = w.length; y < x; y++) {
        var q = w[y], v = !1;
        if (0 != b) {
          v = q.a;
          var z = q.b, C = q.c, A = q.d, D = Math.atan2(t, p) + u;
          D > a.MathUtils.PI ? D -= a.MathUtils.PI2 : D < -a.MathUtils.PI && (D += a.MathUtils.PI2);
          D *= b;
          var E = Math.cos(D);
          D = Math.sin(D);
          q.a = E * v - D * C;
          q.b = E * z - D * A;
          q.c = D * v + E * C;
          q.d = D * z + E * A;
          v = !0;
        }
        0 != c && (v = this.temp, n.localToWorld(v.set(this.data.offsetX, this.data.offsetY)), q.worldX += v.x * c, q.worldY += v.y * c, v = !0);
        0 < f && (v = (Math.sqrt(p * p + t * t) - 1 + this.data.offsetScaleX) * f + 1, q.a *= v, q.c *= v, v = (Math.sqrt(m * m + d * d) - 1 + this.data.offsetScaleY) * f + 1, q.b *= v, q.d *= v, v = !0);
        0 < g && (D = Math.atan2(d, m) - Math.atan2(t, p), D > a.MathUtils.PI ? D -= a.MathUtils.PI2 : D < -a.MathUtils.PI && (D += a.MathUtils.PI2), z = q.b, A = q.d, D = Math.atan2(A, z) + (D - a.MathUtils.PI / 2 + l) * g, v = Math.sqrt(z * z + A * A), q.b = Math.cos(D) * v, q.d = Math.sin(D) * v, v = !0);
        v && (q.appliedValid = !1);
      }
    };
    c.prototype.applyAbsoluteLocal = function() {
      var a = this.rotateMix, c = this.translateMix, f = this.scaleMix, g = this.shearMix, n = this.target;
      n.appliedValid || n.updateAppliedTransform();
      for (var p = this.bones, m = 0, t = p.length; m < t; m++) {
        var d = p[m];
        d.appliedValid || d.updateAppliedTransform();
        var l = d.arotation;
        if (0 != a) {
          var u = n.arotation - l + this.data.offsetRotation;
          u -= 360 * (16384 - (16384.499999999996 - u / 360 | 0));
          l += u * a;
        }
        var w = d.ax, y = d.ay;
        0 != c && (w += (n.ax - w + this.data.offsetX) * c, y += (n.ay - y + this.data.offsetY) * c);
        var x = d.ascaleX, q = d.ascaleY;
        0 < f && (1E-5 < x && (x = (x + (n.ascaleX - x + this.data.offsetScaleX) * f) / x), 1E-5 < q && (q = (q + (n.ascaleY - q + this.data.offsetScaleY) * f) / q));
        var v = d.ashearY;
        0 < g && (u = n.ashearY - v + this.data.offsetShearY, u -= 360 * (16384 - (16384.499999999996 - u / 360 | 0)), d.shearY += u * g);
        d.updateWorldTransformWith(w, y, l, x, q, d.ashearX, v);
      }
    };
    c.prototype.applyRelativeLocal = function() {
      var a = this.rotateMix, c = this.translateMix, f = this.scaleMix, g = this.shearMix, n = this.target;
      n.appliedValid || n.updateAppliedTransform();
      for (var p = this.bones, m = 0, t = p.length; m < t; m++) {
        var d = p[m];
        d.appliedValid || d.updateAppliedTransform();
        var l = d.arotation;
        0 != a && (l += (n.arotation + this.data.offsetRotation) * a);
        var u = d.ax, w = d.ay;
        0 != c && (u += (n.ax + this.data.offsetX) * c, w += (n.ay + this.data.offsetY) * c);
        var y = d.ascaleX, x = d.ascaleY;
        0 < f && (1E-5 < y && (y *= (n.ascaleX - 1 + this.data.offsetScaleX) * f + 1), 1E-5 < x && (x *= (n.ascaleY - 1 + this.data.offsetScaleY) * f + 1));
        var q = d.ashearY;
        0 < g && (q += (n.ashearY + this.data.offsetShearY) * g);
        d.updateWorldTransformWith(u, w, l, y, x, d.ashearX, q);
      }
    };
    c.prototype.getOrder = function() {
      return this.data.order;
    };
    return c;
  }();
  a.TransformConstraint = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    return function(a) {
      this.order = 0;
      this.bones = [];
      this.offsetShearY = this.offsetScaleY = this.offsetScaleX = this.offsetY = this.offsetX = this.offsetRotation = this.shearMix = this.scaleMix = this.translateMix = this.rotateMix = 0;
      this.local = this.relative = !1;
      if (null == a) {
        throw Error("name cannot be null.");
      }
      this.name = a;
    };
  }();
  a.TransformConstraintData = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function c() {
      this.convexPolygons = [];
      this.convexPolygonsIndices = [];
      this.indicesArray = [];
      this.isConcaveArray = [];
      this.triangles = [];
      this.polygonPool = new a.Pool(function() {
        return [];
      });
      this.polygonIndicesPool = new a.Pool(function() {
        return [];
      });
    }
    c.prototype.triangulate = function(a) {
      for (var b = a.length >> 1, f = this.indicesArray, g = f.length = 0; g < b; g++) {
        f[g] = g;
      }
      var n = this.isConcaveArray;
      g = n.length = 0;
      for (var p = b; g < p; ++g) {
        n[g] = c.isConcave(g, b, a, f);
      }
      p = this.triangles;
      for (p.length = 0; 3 < b;) {
        var m = b - 1;
        g = 0;
        for (var t = 1;;) {
          a: {
            if (!n[g]) {
              var d = f[m] << 1, l = f[g] << 1, u = f[t] << 1, w = a[d];
              d = a[d + 1];
              var y = a[l];
              l = a[l + 1];
              var x = a[u];
              u = a[u + 1];
              for (var q = (t + 1) % b; q != m; q = (q + 1) % b) {
                if (n[q]) {
                  var v = f[q] << 1, z = a[v];
                  v = a[v + 1];
                  if (c.positiveArea(x, u, w, d, z, v) && c.positiveArea(w, d, y, l, z, v) && c.positiveArea(y, l, x, u, z, v)) {
                    break a;
                  }
                }
              }
              break;
            }
          }
          if (0 == t) {
            do {
              if (!n[g]) {
                break;
              }
              g--;
            } while (0 < g);
            break;
          }
          m = g;
          g = t;
          t = (t + 1) % b;
        }
        p.push(f[(b + g - 1) % b]);
        p.push(f[g]);
        p.push(f[(g + 1) % b]);
        f.splice(g, 1);
        n.splice(g, 1);
        b--;
        m = (b + g - 1) % b;
        g = g == b ? 0 : g;
        n[m] = c.isConcave(m, b, a, f);
        n[g] = c.isConcave(g, b, a, f);
      }
      3 == b && (p.push(f[2]), p.push(f[0]), p.push(f[1]));
      return p;
    };
    c.prototype.decompose = function(a, e) {
      var b = this.convexPolygons;
      this.polygonPool.freeAll(b);
      b.length = 0;
      var g = this.convexPolygonsIndices;
      this.polygonIndicesPool.freeAll(g);
      g.length = 0;
      var n = this.polygonIndicesPool.obtain();
      n.length = 0;
      var p = this.polygonPool.obtain();
      p.length = 0;
      for (var m = -1, t = 0, d = 0, l = e.length; d < l; d += 3) {
        var u = e[d] << 1, w = e[d + 1] << 1, y = e[d + 2] << 1, x = a[u], q = a[u + 1], v = a[w], z = a[w + 1], C = a[y], A = a[y + 1], D = !1;
        if (m == u) {
          var E = p.length - 4;
          E = c.winding(p[E], p[E + 1], p[E + 2], p[E + 3], C, A);
          var B = c.winding(C, A, p[0], p[1], p[2], p[3]);
          E == t && B == t && (p.push(C), p.push(A), n.push(y), D = !0);
        }
        D || (0 < p.length ? (b.push(p), g.push(n)) : (this.polygonPool.free(p), this.polygonIndicesPool.free(n)), p = this.polygonPool.obtain(), p.length = 0, p.push(x), p.push(q), p.push(v), p.push(z), p.push(C), p.push(A), n = this.polygonIndicesPool.obtain(), n.length = 0, n.push(u), n.push(w), n.push(y), t = c.winding(x, q, v, z, C, A), m = u);
      }
      0 < p.length && (b.push(p), g.push(n));
      d = 0;
      for (l = b.length; d < l; d++) {
        if (n = g[d], 0 != n.length) {
          for (a = n[0], e = n[n.length - 1], p = b[d], E = p.length - 4, m = p[E], t = p[E + 1], u = p[E + 2], w = p[E + 3], y = p[0], x = p[1], q = p[2], v = p[3], z = c.winding(m, t, u, w, y, x), D = 0; D < l; D++) {
            if (D != d) {
              var G = g[D];
              if (3 == G.length) {
                E = G[0];
                B = G[1];
                var H = G[2], K = b[D];
                C = K[K.length - 2];
                A = K[K.length - 1];
                E == a && B == e && (E = c.winding(m, t, u, w, C, A), B = c.winding(C, A, y, x, q, v), E == z && B == z && (K.length = 0, G.length = 0, p.push(C), p.push(A), n.push(H), m = u, t = w, u = C, w = A, D = 0));
              }
            }
          }
        }
      }
      for (d = b.length - 1; 0 <= d; d--) {
        p = b[d], 0 == p.length && (b.splice(d, 1), this.polygonPool.free(p), n = g[d], g.splice(d, 1), this.polygonIndicesPool.free(n));
      }
      return b;
    };
    c.isConcave = function(a, c, f, g) {
      var b = g[(c + a - 1) % c] << 1, e = g[a] << 1;
      a = g[(a + 1) % c] << 1;
      return !this.positiveArea(f[b], f[b + 1], f[e], f[e + 1], f[a], f[a + 1]);
    };
    c.positiveArea = function(a, c, f, g, n, p) {
      return 0 <= a * (p - g) + f * (c - p) + n * (g - c);
    };
    c.winding = function(a, c, f, g, n, p) {
      f -= a;
      g -= c;
      return 0 <= n * g - p * f + f * c - a * g ? 1 : -1;
    };
    return c;
  }();
  a.Triangulator = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function a() {
      this.array = [];
    }
    a.prototype.add = function(a) {
      var b = this.contains(a);
      this.array[a | 0] = a | 0;
      return !b;
    };
    a.prototype.contains = function(a) {
      return void 0 != this.array[a | 0];
    };
    a.prototype.remove = function(a) {
      this.array[a | 0] = void 0;
    };
    a.prototype.clear = function() {
      this.array.length = 0;
    };
    return a;
  }();
  a.IntSet = c;
  c = function() {
    function a(a, c, f, g) {
      void 0 === a && (a = 0);
      void 0 === c && (c = 0);
      void 0 === f && (f = 0);
      void 0 === g && (g = 0);
      this.r = a;
      this.g = c;
      this.b = f;
      this.a = g;
    }
    a.prototype.set = function(a, c, f, g) {
      this.r = a;
      this.g = c;
      this.b = f;
      this.a = g;
      this.clamp();
      return this;
    };
    a.prototype.setFromColor = function(a) {
      this.r = a.r;
      this.g = a.g;
      this.b = a.b;
      this.a = a.a;
      return this;
    };
    a.prototype.setFromString = function(a) {
      a = "#" == a.charAt(0) ? a.substr(1) : a;
      this.r = parseInt(a.substr(0, 2), 16) / 255;
      this.g = parseInt(a.substr(2, 2), 16) / 255;
      this.b = parseInt(a.substr(4, 2), 16) / 255;
      this.a = (8 != a.length ? 255 : parseInt(a.substr(6, 2), 16)) / 255;
      return this;
    };
    a.prototype.add = function(a, c, f, g) {
      this.r += a;
      this.g += c;
      this.b += f;
      this.a += g;
      this.clamp();
      return this;
    };
    a.prototype.clamp = function() {
      0 > this.r ? this.r = 0 : 1 < this.r && (this.r = 1);
      0 > this.g ? this.g = 0 : 1 < this.g && (this.g = 1);
      0 > this.b ? this.b = 0 : 1 < this.b && (this.b = 1);
      0 > this.a ? this.a = 0 : 1 < this.a && (this.a = 1);
      return this;
    };
    a.WHITE = new a(1, 1, 1, 1);
    a.RED = new a(1, 0, 0, 1);
    a.GREEN = new a(0, 1, 0, 1);
    a.BLUE = new a(0, 0, 1, 1);
    a.MAGENTA = new a(1, 0, 1, 1);
    return a;
  }();
  a.Color = c;
  c = function() {
    function a() {
    }
    a.clamp = function(a, c, f) {
      return a < c ? c : a > f ? f : a;
    };
    a.cosDeg = function(b) {
      return Math.cos(b * a.degRad);
    };
    a.sinDeg = function(b) {
      return Math.sin(b * a.degRad);
    };
    a.signum = function(a) {
      return 0 < a ? 1 : 0 > a ? -1 : 0;
    };
    a.toInt = function(a) {
      return 0 < a ? Math.floor(a) : Math.ceil(a);
    };
    a.cbrt = function(a) {
      var b = Math.pow(Math.abs(a), 1 / 3);
      return 0 > a ? -b : b;
    };
    a.randomTriangular = function(b, c) {
      return a.randomTriangularWith(b, c, .5 * (b + c));
    };
    a.randomTriangularWith = function(a, c, f) {
      var b = Math.random(), e = c - a;
      return b <= (f - a) / e ? a + Math.sqrt(b * e * (f - a)) : c - Math.sqrt((1 - b) * e * (c - f));
    };
    a.PI = 3.1415927;
    a.PI2 = 2 * a.PI;
    a.radiansToDegrees = 180 / a.PI;
    a.radDeg = a.radiansToDegrees;
    a.degreesToRadians = a.PI / 180;
    a.degRad = a.degreesToRadians;
    return a;
  }();
  a.MathUtils = c;
  c = function() {
    function a() {
    }
    a.prototype.apply = function(a, c, f) {
      return a + (c - a) * this.applyInternal(f);
    };
    return a;
  }();
  a.Interpolation = c;
  c = function(a) {
    function b(b) {
      a.call(this);
      this.power = 2;
      this.power = b;
    }
    __extends(b, a);
    b.prototype.applyInternal = function(a) {
      return .5 >= a ? Math.pow(2 * a, this.power) / 2 : Math.pow(2 * (a - 1), this.power) / (0 == this.power % 2 ? -2 : 2) + 1;
    };
    return b;
  }(c);
  a.Pow = c;
  c = function(a) {
    function b(b) {
      a.call(this, b);
    }
    __extends(b, a);
    b.prototype.applyInternal = function(a) {
      return Math.pow(a - 1, this.power) * (0 == this.power % 2 ? -1 : 1) + 1;
    };
    return b;
  }(c);
  a.PowOut = c;
  c = function() {
    function a() {
    }
    a.arrayCopy = function(a, c, f, g, n) {
      for (var b = c; b < c + n; b++, g++) {
        f[g] = a[b];
      }
    };
    a.setArraySize = function(a, c, f) {
      void 0 === f && (f = 0);
      var b = a.length;
      if (b == c) {
        return a;
      }
      a.length = c;
      if (b < c) {
        for (; b < c; b++) {
          a[b] = f;
        }
      }
      return a;
    };
    a.ensureArrayCapacity = function(b, c, f) {
      void 0 === f && (f = 0);
      return b.length >= c ? b : a.setArraySize(b, c, f);
    };
    a.newArray = function(a, c) {
      for (var b = Array(a), e = 0; e < a; e++) {
        b[e] = c;
      }
      return b;
    };
    a.newFloatArray = function(b) {
      if (a.SUPPORTS_TYPED_ARRAYS) {
        return new Float32Array(b);
      }
      b = Array(b);
      for (var c = 0; c < b.length; c++) {
        b[c] = 0;
      }
      return b;
    };
    a.newShortArray = function(b) {
      if (a.SUPPORTS_TYPED_ARRAYS) {
        return new Int16Array(b);
      }
      b = Array(b);
      for (var c = 0; c < b.length; c++) {
        b[c] = 0;
      }
      return b;
    };
    a.toFloatArray = function(b) {
      return a.SUPPORTS_TYPED_ARRAYS ? new Float32Array(b) : b;
    };
    a.toSinglePrecision = function(b) {
      return a.SUPPORTS_TYPED_ARRAYS ? Math.fround(b) : b;
    };
    a.SUPPORTS_TYPED_ARRAYS = "undefined" !== typeof Float32Array;
    return a;
  }();
  a.Utils = c;
  c = function() {
    function a() {
    }
    a.logBones = function(a) {
      for (var b = 0; b < a.bones.length; b++) {
        var c = a.bones[b];
        console.log(c.data.name + ", " + c.a + ", " + c.b + ", " + c.c + ", " + c.d + ", " + c.worldX + ", " + c.worldY);
      }
    };
    return a;
  }();
  a.DebugUtils = c;
  c = function() {
    function a(a) {
      this.items = [];
      this.instantiator = a;
    }
    a.prototype.obtain = function() {
      return 0 < this.items.length ? this.items.pop() : this.instantiator();
    };
    a.prototype.free = function(a) {
      a.reset && a.reset();
      this.items.push(a);
    };
    a.prototype.freeAll = function(a) {
      for (var b = 0; b < a.length; b++) {
        a[b].reset && a[b].reset(), this.items[b] = a[b];
      }
    };
    a.prototype.clear = function() {
      this.items.length = 0;
    };
    return a;
  }();
  a.Pool = c;
  c = function() {
    function a(a, c) {
      void 0 === a && (a = 0);
      void 0 === c && (c = 0);
      this.x = a;
      this.y = c;
    }
    a.prototype.set = function(a, c) {
      this.x = a;
      this.y = c;
      return this;
    };
    a.prototype.length = function() {
      var a = this.x, c = this.y;
      return Math.sqrt(a * a + c * c);
    };
    a.prototype.normalize = function() {
      var a = this.length();
      0 != a && (this.x /= a, this.y /= a);
      return this;
    };
    return a;
  }();
  a.Vector2 = c;
  c = function() {
    function a() {
      this.maxDelta = .064;
      this.totalTime = this.delta = this.framesPerSecond = 0;
      this.lastTime = Date.now() / 1E3;
      this.frameTime = this.frameCount = 0;
    }
    a.prototype.update = function() {
      var a = Date.now() / 1E3;
      this.delta = a - this.lastTime;
      this.frameTime += this.delta;
      this.totalTime += this.delta;
      this.delta > this.maxDelta && (this.delta = this.maxDelta);
      this.lastTime = a;
      this.frameCount++;
      1 < this.frameTime && (this.framesPerSecond = this.frameCount / this.frameTime, this.frameCount = this.frameTime = 0);
    };
    return a;
  }();
  a.TimeKeeper = c;
  c = function() {
    function a(a) {
      void 0 === a && (a = 32);
      this.mean = this.lastValue = this.addedValues = 0;
      this.dirty = !0;
      this.values = Array(a);
    }
    a.prototype.hasEnoughData = function() {
      return this.addedValues >= this.values.length;
    };
    a.prototype.addValue = function(a) {
      this.addedValues < this.values.length && this.addedValues++;
      this.values[this.lastValue++] = a;
      this.lastValue > this.values.length - 1 && (this.lastValue = 0);
      this.dirty = !0;
    };
    a.prototype.getMean = function() {
      if (this.hasEnoughData()) {
        if (this.dirty) {
          for (var a = 0, c = 0; c < this.values.length; c++) {
            a += this.values[c];
          }
          this.mean = a / this.values.length;
          this.dirty = !1;
        }
        return this.mean;
      }
      return 0;
    };
    return a;
  }();
  a.WindowedMean = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function c(a, c) {
      this.jitterY = this.jitterX = 0;
      this.jitterX = a;
      this.jitterY = c;
    }
    c.prototype.begin = function(a) {
    };
    c.prototype.transform = function(b, c, f, g) {
      b.x += a.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
      b.y += a.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
    };
    c.prototype.end = function() {
    };
    return c;
  }();
  a.JitterEffect = c;
})(spine || (spine = {}));
(function(a) {
  var c = function() {
    function c(a) {
      this.worldY = this.worldX = this.angle = this.radius = this.centerY = this.centerX = 0;
      this.radius = a;
    }
    c.prototype.begin = function(a) {
      this.worldX = a.x + this.centerX;
      this.worldY = a.y + this.centerY;
    };
    c.prototype.transform = function(b, e, f, g) {
      g = this.angle * a.MathUtils.degreesToRadians;
      e = b.x - this.worldX;
      f = b.y - this.worldY;
      var k = Math.sqrt(e * e + f * f);
      k < this.radius && (k = c.interpolation.apply(0, g, (this.radius - k) / this.radius), g = Math.cos(k), k = Math.sin(k), b.x = g * e - k * f + this.worldX, b.y = k * e + g * f + this.worldY);
    };
    c.prototype.end = function() {
    };
    c.interpolation = new a.PowOut(2);
    return c;
  }();
  a.SwirlEffect = c;
})(spine || (spine = {}));
(function(a) {
  (function(c) {
    var g = function(a) {
      function b(b) {
        void 0 === b && (b = "");
        a.call(this, function(a) {
          return new c.ThreeJsTexture(a);
        }, b);
      }
      __extends(b, a);
      return b;
    }(a.AssetManager);
    c.AssetManager = g;
  })(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
  (function(a) {
    var c = function() {
      function a(b, c) {
        void 0 === c && (c = 10920);
        this.indicesLength = this.verticesLength = 0;
        if (10920 < c) {
          throw Error("Can't have more than 10920 triangles per batch: " + c);
        }
        var e = this.vertices = new Float32Array(c * a.VERTEX_SIZE);
        c = this.indices = new Uint16Array(3 * c);
        this.mesh = b;
        var f = new THREE.BufferGeometry;
        e = this.vertexBuffer = new THREE.InterleavedBuffer(e, a.VERTEX_SIZE);
        e.dynamic = !0;
        f.addAttribute("position", new THREE.InterleavedBufferAttribute(e, 3, 0, !1));
        f.addAttribute("color", new THREE.InterleavedBufferAttribute(e, 4, 3, !1));
        f.addAttribute("uv", new THREE.InterleavedBufferAttribute(e, 2, 7, !1));
        f.setIndex(new THREE.BufferAttribute(c, 1));
        f.getIndex().dynamic = !0;
        f.drawRange.start = 0;
        f.drawRange.count = 0;
        b.geometry = f;
      }
      a.prototype.begin = function() {
        this.indicesLength = this.verticesLength = 0;
      };
      a.prototype.batch = function(b, c, g, n, p) {
        void 0 === p && (p = 0);
        for (var e = this.verticesLength / a.VERTEX_SIZE, f = this.vertices, d = this.verticesLength, k = 0; k < c;) {
          f[d++] = b[k++], f[d++] = b[k++], f[d++] = p, f[d++] = b[k++], f[d++] = b[k++], f[d++] = b[k++], f[d++] = b[k++], f[d++] = b[k++], f[d++] = b[k++];
        }
        this.verticesLength = d;
        b = this.indices;
        d = this.indicesLength;
        for (k = 0; k < n; d++, k++) {
          b[d] = g[k] + e;
        }
        this.indicesLength += n;
      };
      a.prototype.end = function() {
        this.vertexBuffer.needsUpdate = !0;
        this.vertexBuffer.updateRange.offset = 0;
        this.vertexBuffer.updateRange.count = this.verticesLength;
        var a = this.mesh.geometry;
        a.getIndex().needsUpdate = !0;
        a.getIndex().updateRange.offset = 0;
        a.getIndex().updateRange.count = this.indicesLength;
        a.drawRange.start = 0;
        a.drawRange.count = this.indicesLength;
      };
      a.VERTEX_SIZE = 9;
      return a;
    }();
    a.MeshBatcher = c;
  })(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
  (function(c) {
    var g = function(b) {
      function e(e) {
        b.call(this);
        this.tempPos = new a.Vector2;
        this.tempUv = new a.Vector2;
        this.tempLight = new a.Color;
        this.tempDark = new a.Color;
        this.zOffset = .1;
        this.clipper = new a.SkeletonClipping;
        this.vertices = a.Utils.newFloatArray(1024);
        this.tempColor = new a.Color;
        this.skeleton = new a.Skeleton(e);
        e = new a.AnimationStateData(e);
        this.state = new a.AnimationState(e);
        e = this.material = new THREE.MeshBasicMaterial;
        e.side = THREE.DoubleSide;
        e.transparent = !0;
        e.alphaTest = .5;
        this.batcher = new c.MeshBatcher(this);
      }
      __extends(e, b);
      e.prototype.update = function(a) {
        var b = this.state, c = this.skeleton;
        b.update(a);
        b.apply(c);
        c.updateWorldTransform();
        this.updateGeometry();
      };
      e.prototype.updateGeometry = function() {
        var b = this.tempPos, c = this.tempUv, g = this.tempLight, p = this.tempDark, m = this.clipper, t = this.skeleton.drawOrder, d = this.batcher;
        d.begin();
        for (var l = 0, u = this.zOffset, w = 0, y = t.length; w < y; w++) {
          var x = m.isClipping() ? 2 : e.VERTEX_SIZE, q = t[w];
          var v = q.getAttachment();
          if (v instanceof a.RegionAttachment) {
            var z = v;
            var C = z.color;
            v = this.vertices;
            var A = 4 * x;
            z.computeWorldVertices(q.bone, v, 0, x);
            var D = e.QUAD_TRIANGLES;
            var E = z.uvs;
            z = z.region.renderObject.texture;
          } else {
            if (v instanceof a.MeshAttachment) {
              z = v, C = z.color, v = this.vertices, A = (z.worldVerticesLength >> 1) * x, A > v.length && (v = this.vertices = a.Utils.newFloatArray(A)), z.computeWorldVertices(q, 0, z.worldVerticesLength, v, 0, x), D = z.triangles, E = z.uvs, z = z.region.renderObject.texture;
            } else {
              v instanceof a.ClippingAttachment && m.clipStart(q, v);
              continue;
            }
          }
          if (null != z) {
            if (!this.material.map) {
              var B = this.material;
              B.map = z.texture;
              B.needsUpdate = !0;
            }
            z = q.bone.skeleton.color;
            B = q.color;
            q = this.tempColor;
            q.set(z.r * B.r * C.r, z.g * B.g * C.g, z.b * B.b * C.b, z.a * B.a * C.a);
            if (m.isClipping()) {
              m.clipTriangles(v, A, D, D.length, E, q, null, !1);
              v = m.clippedVertices;
              D = m.clippedTriangles;
              if (null != this.vertexEffect) {
                for (B = this.vertexEffect, C = v, z = 0, E = v.length; z < E; z += x) {
                  b.x = C[z], b.y = C[z + 1], g.setFromColor(q), p.set(0, 0, 0, 0), c.x = C[z + 6], c.y = C[z + 7], B.transform(b, c, g, p), C[z] = b.x, C[z + 1] = b.y, C[z + 2] = g.r, C[z + 3] = g.g, C[z + 4] = g.b, C[z + 5] = g.a, C[z + 6] = c.x, C[z + 7] = c.y;
                }
              }
              d.batch(v, v.length, D, D.length, l);
            } else {
              C = v;
              if (null != this.vertexEffect) {
                B = this.vertexEffect;
                for (var G = z = 0, H = A; z < H; z += x, G += 2) {
                  b.x = C[z], b.y = C[z + 1], g.setFromColor(q), p.set(0, 0, 0, 0), c.x = E[G], c.y = E[G + 1], B.transform(b, c, g, p), C[z] = b.x, C[z + 1] = b.y, C[z + 2] = g.r, C[z + 3] = g.g, C[z + 4] = g.b, C[z + 5] = g.a, C[z + 6] = c.x, C[z + 7] = c.y;
                }
              } else {
                for (z = 2, G = 0, B = A; z < B; z += x, G += 2) {
                  C[z] = q.r, C[z + 1] = q.g, C[z + 2] = q.b, C[z + 3] = q.a, C[z + 4] = E[G], C[z + 5] = E[G + 1];
                }
              }
              d.batch(v, A, D, D.length, l);
            }
            l += u;
          }
        }
        d.end();
      };
      e.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
      e.VERTEX_SIZE = 8;
      return e;
    }(THREE.Mesh);
    c.SkeletonMesh = g;
  })(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
  (function(c) {
    var g = function(b) {
      function c(a) {
        b.call(this, a);
        this.texture = new THREE.Texture(a);
        this.texture.flipY = !1;
        this.texture.needsUpdate = !0;
      }
      __extends(c, b);
      c.prototype.setFilters = function(a, b) {
        this.texture.minFilter = c.toThreeJsTextureFilter(a);
        this.texture.magFilter = c.toThreeJsTextureFilter(b);
      };
      c.prototype.setWraps = function(a, b) {
        this.texture.wrapS = c.toThreeJsTextureWrap(a);
        this.texture.wrapT = c.toThreeJsTextureWrap(b);
      };
      c.prototype.dispose = function() {
        this.texture.dispose();
      };
      c.toThreeJsTextureFilter = function(b) {
        if (b === a.TextureFilter.Linear) {
          return THREE.LinearFilter;
        }
        if (b === a.TextureFilter.MipMap) {
          return THREE.LinearMipMapLinearFilter;
        }
        if (b === a.TextureFilter.MipMapLinearNearest) {
          return THREE.LinearMipMapNearestFilter;
        }
        if (b === a.TextureFilter.MipMapNearestLinear) {
          return THREE.NearestMipMapLinearFilter;
        }
        if (b === a.TextureFilter.MipMapNearestNearest) {
          return THREE.NearestMipMapNearestFilter;
        }
        if (b === a.TextureFilter.Nearest) {
          return THREE.NearestFilter;
        }
        throw Error("Unknown texture filter: " + b);
      };
      c.toThreeJsTextureWrap = function(b) {
        if (b === a.TextureWrap.ClampToEdge) {
          return THREE.ClampToEdgeWrapping;
        }
        if (b === a.TextureWrap.MirroredRepeat) {
          return THREE.MirroredRepeatWrapping;
        }
        if (b === a.TextureWrap.Repeat) {
          return THREE.RepeatWrapping;
        }
        throw Error("Unknown texture wrap: " + b);
      };
      return c;
    }(a.Texture);
    c.ThreeJsTexture = g;
  })(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
  "object" === typeof exports && "undefined" !== typeof module ? module.exports = a() : "function" === typeof define && define.amd ? define([], a) : ("undefined" !== typeof window ? window : "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : this).opentype = a();
})(function() {
  return function e(c, g, b) {
    function f(n, m) {
      if (!g[n]) {
        if (!c[n]) {
          var p = "function" == typeof require && require;
          if (!m && p) {
            return p(n, !0);
          }
          if (k) {
            return k(n, !0);
          }
          m = Error("Cannot find module '" + n + "'");
          throw m.code = "MODULE_NOT_FOUND", m;
        }
        m = g[n] = {exports:{}};
        c[n][0].call(m.exports, function(b) {
          var d = c[n][1][b];
          return f(d ? d : b);
        }, m, m.exports, e, c, g, b);
      }
      return g[n].exports;
    }
    for (var k = "function" == typeof require && require, n = 0; n < b.length; n++) {
      f(b[n]);
    }
    return f;
  }({1:[function(c, g, b) {
    function e() {
      this.table = new Uint16Array(16);
      this.trans = new Uint16Array(288);
    }
    function f(b, c) {
      this.source = b;
      this.bitcount = this.tag = this.sourceIndex = 0;
      this.dest = c;
      this.destLen = 0;
      this.ltree = new e;
      this.dtree = new e;
    }
    function k(b, c, d, e) {
      var f;
      for (f = 0; d > f; ++f) {
        b[f] = 0;
      }
      for (f = 0; 30 - d > f; ++f) {
        b[f + d] = f / d | 0;
      }
      d = e;
      for (f = 0; 30 > f; ++f) {
        c[f] = d, d += 1 << b[f];
      }
    }
    function n(b, c, d, e) {
      var f, g;
      for (f = 0; 16 > f; ++f) {
        b.table[f] = 0;
      }
      for (f = 0; e > f; ++f) {
        b.table[c[d + f]]++;
      }
      for (f = g = b.table[0] = 0; 16 > f; ++f) {
        A[f] = g, g += b.table[f];
      }
      for (f = 0; e > f; ++f) {
        c[d + f] && (b.trans[A[c[d + f]]++] = f);
      }
    }
    function p(b, c, d) {
      if (!c) {
        return d;
      }
      for (; 24 > b.bitcount;) {
        b.tag |= b.source[b.sourceIndex++] << b.bitcount, b.bitcount += 8;
      }
      var e = b.tag & 65535 >>> 16 - c;
      return b.tag >>>= c, b.bitcount -= c, e + d;
    }
    function m(b, c) {
      for (; 24 > b.bitcount;) {
        b.tag |= b.source[b.sourceIndex++] << b.bitcount, b.bitcount += 8;
      }
      var d = 0, e = 0, f = 0, g = b.tag;
      do {
        e = 2 * e + (1 & g), g >>>= 1, ++f, d += c.table[f], e -= c.table[f];
      } while (0 <= e);
      return b.tag = g, b.bitcount -= f, c.trans[d + e];
    }
    function t(b, c, e) {
      for (;;) {
        var f = m(b, c);
        if (256 === f) {
          return d;
        }
        if (256 > f) {
          b.dest[b.destLen++] = f;
        } else {
          var g;
          f -= 257;
          f = p(b, w[f], y[f]);
          var k = m(b, e);
          for (g = k = b.destLen - p(b, x[k], q[k]); k + f > g; ++g) {
            b.dest[b.destLen++] = b.dest[g];
          }
        }
      }
    }
    var d = 0, l = new e, u = new e, w = new Uint8Array(30), y = new Uint16Array(30), x = new Uint8Array(30), q = new Uint16Array(30), v = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), z = new e, C = new Uint8Array(320), A = new Uint16Array(16);
    (function(b, c) {
      var d;
      for (d = 0; 7 > d; ++d) {
        b.table[d] = 0;
      }
      b.table[7] = 24;
      b.table[8] = 152;
      b.table[9] = 112;
      for (d = 0; 24 > d; ++d) {
        b.trans[d] = 256 + d;
      }
      for (d = 0; 144 > d; ++d) {
        b.trans[24 + d] = d;
      }
      for (d = 0; 8 > d; ++d) {
        b.trans[168 + d] = 280 + d;
      }
      for (d = 0; 112 > d; ++d) {
        b.trans[176 + d] = 144 + d;
      }
      for (d = 0; 5 > d; ++d) {
        c.table[d] = 0;
      }
      c.table[5] = 32;
      for (d = 0; 32 > d; ++d) {
        c.trans[d] = d;
      }
    })(l, u);
    k(w, y, 4, 3);
    k(x, q, 2, 1);
    w[28] = 0;
    y[28] = 258;
    g.exports = function(b, c) {
      b = new f(b, c);
      do {
        c = b;
        c.bitcount-- || (c.tag = c.source[c.sourceIndex++], c.bitcount = 7);
        var e = 1 & c.tag;
        switch(c = (c.tag >>>= 1, e), p(b, 2, 0)) {
          case 0:
            var g, k = g = void 0;
            for (e = b; 8 < e.bitcount;) {
              e.sourceIndex--, e.bitcount -= 8;
            }
            if (k = e.source[e.sourceIndex + 1], k = 256 * k + e.source[e.sourceIndex], g = e.source[e.sourceIndex + 3], g = 256 * g + e.source[e.sourceIndex + 2], k !== (65535 & ~g)) {
              e = -3;
            } else {
              e.sourceIndex += 4;
              for (g = k; g; --g) {
                e.dest[e.destLen++] = e.source[e.sourceIndex++];
              }
              e = (e.bitcount = 0, d);
            }
            break;
          case 1:
            e = t(b, l, u);
            break;
          case 2:
            var q;
            k = b;
            var w = b.ltree, y = b.dtree;
            g = p(k, 5, 257);
            e = p(k, 5, 1);
            var x = p(k, 4, 4);
            for (q = 0; 19 > q; ++q) {
              C[q] = 0;
            }
            for (q = 0; x > q; ++q) {
              var A = p(k, 3, 0);
              C[v[q]] = A;
            }
            n(z, C, 0, 19);
            for (q = 0; g + e > q;) {
              switch(x = m(k, z), x) {
                case 16:
                  A = C[q - 1];
                  for (x = p(k, 2, 3); x; --x) {
                    C[q++] = A;
                  }
                  break;
                case 17:
                  for (x = p(k, 3, 3); x; --x) {
                    C[q++] = 0;
                  }
                  break;
                case 18:
                  for (x = p(k, 7, 11); x; --x) {
                    C[q++] = 0;
                  }
                  break;
                default:
                  C[q++] = x;
              }
            }
            n(w, C, 0, g);
            n(y, C, g, e);
            e = t(b, b.ltree, b.dtree);
            break;
          default:
            e = -3;
        }
        if (e !== d) {
          throw Error("Data error");
        }
      } while (!c);
      return b.destLen < b.dest.length ? "function" == typeof b.dest.slice ? b.dest.slice(0, b.destLen) : b.dest.subarray(0, b.destLen) : b.dest;
    };
  }, {}], 2:[function(c, g, b) {
    b.fail = function(b) {
      throw Error(b);
    };
    b.argument = function(c, f) {
      c || b.fail(f);
    };
    b.assert = b.argument;
  }, {}], 3:[function(c, g, b) {
    b.line = function(b, c, g, n, p) {
      b.beginPath();
      b.moveTo(c, g);
      b.lineTo(n, p);
      b.stroke();
    };
  }, {}], 4:[function(c, g, b) {
    function e(b) {
      this.font = b;
    }
    function f(b) {
      this.cmap = b;
    }
    function k(b, c) {
      this.encoding = b;
      this.charset = c;
    }
    function n(c) {
      var e;
      switch(c.version) {
        case 1:
          this.names = b.standardNames.slice();
          break;
        case 2:
          this.names = Array(c.numberOfGlyphs);
          for (e = 0; e < c.numberOfGlyphs; e++) {
            this.names[e] = c.glyphNameIndex[e] < b.standardNames.length ? b.standardNames[c.glyphNameIndex[e]] : c.names[c.glyphNameIndex[e] - b.standardNames.length];
          }
          break;
        case 2.5:
          this.names = Array(c.numberOfGlyphs);
          for (e = 0; e < c.numberOfGlyphs; e++) {
            this.names[e] = b.standardNames[e + c.glyphNameIndex[e]];
          }
          break;
        case 3:
          this.names = [];
      }
    }
    e.prototype.charToGlyphIndex = function(b) {
      b = b.charCodeAt(0);
      var c = this.font.glyphs;
      if (!c) {
        return null;
      }
      for (var e = 0; e < c.length; e += 1) {
        for (var d = c.get(e), f = 0; f < d.unicodes.length; f += 1) {
          if (d.unicodes[f] === b) {
            return e;
          }
        }
      }
    };
    f.prototype.charToGlyphIndex = function(b) {
      return this.cmap.glyphIndexMap[b.charCodeAt(0)] || 0;
    };
    k.prototype.charToGlyphIndex = function(b) {
      b = b.charCodeAt(0);
      return this.charset.indexOf(this.encoding[b]);
    };
    n.prototype.nameToGlyphIndex = function(b) {
      return this.names.indexOf(b);
    };
    n.prototype.glyphIndexToName = function(b) {
      return this.names[b];
    };
    b.cffStandardStrings = ".notdef;space;exclam;quotedbl;numbersign;dollar;percent;ampersand;quoteright;parenleft;parenright;asterisk;plus;comma;hyphen;period;slash;zero;one;two;three;four;five;six;seven;eight;nine;colon;semicolon;less;equal;greater;question;at;A;B;C;D;E;F;G;H;I;J;K;L;M;N;O;P;Q;R;S;T;U;V;W;X;Y;Z;bracketleft;backslash;bracketright;asciicircum;underscore;quoteleft;a;b;c;d;e;f;g;h;i;j;k;l;m;n;o;p;q;r;s;t;u;v;w;x;y;z;braceleft;bar;braceright;asciitilde;exclamdown;cent;sterling;fraction;yen;florin;section;currency;quotesingle;quotedblleft;guillemotleft;guilsinglleft;guilsinglright;fi;fl;endash;dagger;daggerdbl;periodcentered;paragraph;bullet;quotesinglbase;quotedblbase;quotedblright;guillemotright;ellipsis;perthousand;questiondown;grave;acute;circumflex;tilde;macron;breve;dotaccent;dieresis;ring;cedilla;hungarumlaut;ogonek;caron;emdash;AE;ordfeminine;Lslash;Oslash;OE;ordmasculine;ae;dotlessi;lslash;oslash;oe;germandbls;onesuperior;logicalnot;mu;trademark;Eth;onehalf;plusminus;Thorn;onequarter;divide;brokenbar;degree;thorn;threequarters;twosuperior;registered;minus;eth;multiply;threesuperior;copyright;Aacute;Acircumflex;Adieresis;Agrave;Aring;Atilde;Ccedilla;Eacute;Ecircumflex;Edieresis;Egrave;Iacute;Icircumflex;Idieresis;Igrave;Ntilde;Oacute;Ocircumflex;Odieresis;Ograve;Otilde;Scaron;Uacute;Ucircumflex;Udieresis;Ugrave;Yacute;Ydieresis;Zcaron;aacute;acircumflex;adieresis;agrave;aring;atilde;ccedilla;eacute;ecircumflex;edieresis;egrave;iacute;icircumflex;idieresis;igrave;ntilde;oacute;ocircumflex;odieresis;ograve;otilde;scaron;uacute;ucircumflex;udieresis;ugrave;yacute;ydieresis;zcaron;exclamsmall;Hungarumlautsmall;dollaroldstyle;dollarsuperior;ampersandsmall;Acutesmall;parenleftsuperior;parenrightsuperior;266 ff;onedotenleader;zerooldstyle;oneoldstyle;twooldstyle;threeoldstyle;fouroldstyle;fiveoldstyle;sixoldstyle;sevenoldstyle;eightoldstyle;nineoldstyle;commasuperior;threequartersemdash;periodsuperior;questionsmall;asuperior;bsuperior;centsuperior;dsuperior;esuperior;isuperior;lsuperior;msuperior;nsuperior;osuperior;rsuperior;ssuperior;tsuperior;ff;ffi;ffl;parenleftinferior;parenrightinferior;Circumflexsmall;hyphensuperior;Gravesmall;Asmall;Bsmall;Csmall;Dsmall;Esmall;Fsmall;Gsmall;Hsmall;Ismall;Jsmall;Ksmall;Lsmall;Msmall;Nsmall;Osmall;Psmall;Qsmall;Rsmall;Ssmall;Tsmall;Usmall;Vsmall;Wsmall;Xsmall;Ysmall;Zsmall;colonmonetary;onefitted;rupiah;Tildesmall;exclamdownsmall;centoldstyle;Lslashsmall;Scaronsmall;Zcaronsmall;Dieresissmall;Brevesmall;Caronsmall;Dotaccentsmall;Macronsmall;figuredash;hypheninferior;Ogoneksmall;Ringsmall;Cedillasmall;questiondownsmall;oneeighth;threeeighths;fiveeighths;seveneighths;onethird;twothirds;zerosuperior;foursuperior;fivesuperior;sixsuperior;sevensuperior;eightsuperior;ninesuperior;zeroinferior;oneinferior;twoinferior;threeinferior;fourinferior;fiveinferior;sixinferior;seveninferior;eightinferior;nineinferior;centinferior;dollarinferior;periodinferior;commainferior;Agravesmall;Aacutesmall;Acircumflexsmall;Atildesmall;Adieresissmall;Aringsmall;AEsmall;Ccedillasmall;Egravesmall;Eacutesmall;Ecircumflexsmall;Edieresissmall;Igravesmall;Iacutesmall;Icircumflexsmall;Idieresissmall;Ethsmall;Ntildesmall;Ogravesmall;Oacutesmall;Ocircumflexsmall;Otildesmall;Odieresissmall;OEsmall;Oslashsmall;Ugravesmall;Uacutesmall;Ucircumflexsmall;Udieresissmall;Yacutesmall;Thornsmall;Ydieresissmall;001.000;001.001;001.002;001.003;Black;Bold;Book;Light;Medium;Regular;Roman;Semibold".split(";");
    b.cffStandardEncoding = "                                space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk plus comma hyphen period slash zero one two three four five six seven eight nine colon semicolon less equal greater question at A B C D E F G H I J K L M N O P Q R S T U V W X Y Z bracketleft backslash bracketright asciicircum underscore quoteleft a b c d e f g h i j k l m n o p q r s t u v w x y z braceleft bar braceright asciitilde                                   exclamdown cent sterling fraction yen florin section currency quotesingle quotedblleft guillemotleft guilsinglleft guilsinglright fi fl  endash dagger daggerdbl periodcentered  paragraph bullet quotesinglbase quotedblbase quotedblright guillemotright ellipsis perthousand  questiondown  grave acute circumflex tilde macron breve dotaccent dieresis  ring cedilla  hungarumlaut ogonek caron emdash                 AE  ordfeminine     Lslash Oslash OE ordmasculine      ae    dotlessi   lslash oslash oe germandbls".split(" ");
    b.cffExpertEncoding = "                                space exclamsmall Hungarumlautsmall  dollaroldstyle dollarsuperior ampersandsmall Acutesmall parenleftsuperior parenrightsuperior twodotenleader onedotenleader comma hyphen period fraction zerooldstyle oneoldstyle twooldstyle threeoldstyle fouroldstyle fiveoldstyle sixoldstyle sevenoldstyle eightoldstyle nineoldstyle colon semicolon commasuperior threequartersemdash periodsuperior questionsmall  asuperior bsuperior centsuperior dsuperior esuperior   isuperior   lsuperior msuperior nsuperior osuperior   rsuperior ssuperior tsuperior  ff fi fl ffi ffl parenleftinferior  parenrightinferior Circumflexsmall hyphensuperior Gravesmall Asmall Bsmall Csmall Dsmall Esmall Fsmall Gsmall Hsmall Ismall Jsmall Ksmall Lsmall Msmall Nsmall Osmall Psmall Qsmall Rsmall Ssmall Tsmall Usmall Vsmall Wsmall Xsmall Ysmall Zsmall colonmonetary onefitted rupiah Tildesmall                                   exclamdownsmall centoldstyle Lslashsmall   Scaronsmall Zcaronsmall Dieresissmall Brevesmall Caronsmall  Dotaccentsmall   Macronsmall   figuredash hypheninferior   Ogoneksmall Ringsmall Cedillasmall    onequarter onehalf threequarters questiondownsmall oneeighth threeeighths fiveeighths seveneighths onethird twothirds   zerosuperior onesuperior twosuperior threesuperior foursuperior fivesuperior sixsuperior sevensuperior eightsuperior ninesuperior zeroinferior oneinferior twoinferior threeinferior fourinferior fiveinferior sixinferior seveninferior eightinferior nineinferior centinferior dollarinferior periodinferior commainferior Agravesmall Aacutesmall Acircumflexsmall Atildesmall Adieresissmall Aringsmall AEsmall Ccedillasmall Egravesmall Eacutesmall Ecircumflexsmall Edieresissmall Igravesmall Iacutesmall Icircumflexsmall Idieresissmall Ethsmall Ntildesmall Ogravesmall Oacutesmall Ocircumflexsmall Otildesmall Odieresissmall OEsmall Oslashsmall Ugravesmall Uacutesmall Ucircumflexsmall Udieresissmall Yacutesmall Thornsmall Ydieresissmall".split(" ");
    b.standardNames = ".notdef .null nonmarkingreturn space exclam quotedbl numbersign dollar percent ampersand quotesingle parenleft parenright asterisk plus comma hyphen period slash zero one two three four five six seven eight nine colon semicolon less equal greater question at A B C D E F G H I J K L M N O P Q R S T U V W X Y Z bracketleft backslash bracketright asciicircum underscore grave a b c d e f g h i j k l m n o p q r s t u v w x y z braceleft bar braceright asciitilde Adieresis Aring Ccedilla Eacute Ntilde Odieresis Udieresis aacute agrave acircumflex adieresis atilde aring ccedilla eacute egrave ecircumflex edieresis iacute igrave icircumflex idieresis ntilde oacute ograve ocircumflex odieresis otilde uacute ugrave ucircumflex udieresis dagger degree cent sterling section bullet paragraph germandbls registered copyright trademark acute dieresis notequal AE Oslash infinity plusminus lessequal greaterequal yen mu partialdiff summation product pi integral ordfeminine ordmasculine Omega ae oslash questiondown exclamdown logicalnot radical florin approxequal Delta guillemotleft guillemotright ellipsis nonbreakingspace Agrave Atilde Otilde OE oe endash emdash quotedblleft quotedblright quoteleft quoteright divide lozenge ydieresis Ydieresis fraction currency guilsinglleft guilsinglright fi fl daggerdbl periodcentered quotesinglbase quotedblbase perthousand Acircumflex Ecircumflex Aacute Edieresis Egrave Iacute Icircumflex Idieresis Igrave Oacute Ocircumflex apple Ograve Uacute Ucircumflex Ugrave dotlessi circumflex tilde macron breve dotaccent ring cedilla hungarumlaut ogonek caron Lslash lslash Scaron scaron Zcaron zcaron brokenbar Eth eth Yacute yacute Thorn thorn minus multiply onesuperior twosuperior threesuperior onehalf onequarter threequarters franc Gbreve gbreve Idotaccent Scedilla scedilla Cacute cacute Ccaron ccaron dcroat".split(" ");
    b.DefaultEncoding = e;
    b.CmapEncoding = f;
    b.CffEncoding = k;
    b.GlyphNames = n;
    b.addGlyphNames = function(b) {
      for (var c, e = b.tables.cmap.glyphIndexMap, d = Object.keys(e), f = 0; f < d.length; f += 1) {
        var g = d[f];
        c = b.glyphs.get(e[g]);
        c.addUnicode(parseInt(g));
      }
      for (f = 0; f < b.glyphs.length; f += 1) {
        c = b.glyphs.get(f), b.cffEncoding ? c.name = b.cffEncoding.charset[f] : b.glyphNames.names && (c.name = b.glyphNames.glyphIndexToName(f));
      }
    };
  }, {}], 5:[function(c, g, b) {
    function e(b) {
      b = b || {};
      b.empty || (t.checkArgument(b.familyName, "When creating a new Font object, familyName is required."), t.checkArgument(b.styleName, "When creating a new Font object, styleName is required."), t.checkArgument(b.unitsPerEm, "When creating a new Font object, unitsPerEm is required."), t.checkArgument(b.ascender, "When creating a new Font object, ascender is required."), t.checkArgument(b.descender, "When creating a new Font object, descender is required."), t.checkArgument(0 > b.descender, "Descender should be negative (e.g. -512)."), 
      this.names = {fontFamily:{en:b.familyName || " "}, fontSubfamily:{en:b.styleName || " "}, fullName:{en:b.fullName || b.familyName + " " + b.styleName}, postScriptName:{en:b.postScriptName || b.familyName + b.styleName}, designer:{en:b.designer || " "}, designerURL:{en:b.designerURL || " "}, manufacturer:{en:b.manufacturer || " "}, manufacturerURL:{en:b.manufacturerURL || " "}, license:{en:b.license || " "}, licenseURL:{en:b.licenseURL || " "}, version:{en:b.version || "Version 0.1"}, description:{en:b.description || 
      " "}, copyright:{en:b.copyright || " "}, trademark:{en:b.trademark || " "}}, this.unitsPerEm = b.unitsPerEm || 1E3, this.ascender = b.ascender, this.descender = b.descender, this.createdTimestamp = b.createdTimestamp, this.tables = {os2:{usWeightClass:b.weightClass || this.usWeightClasses.MEDIUM, usWidthClass:b.widthClass || this.usWidthClasses.MEDIUM, fsSelection:b.fsSelection || this.fsSelectionValues.REGULAR}});
      this.supported = !0;
      this.glyphs = new p.GlyphSet(this, b.glyphs || []);
      this.encoding = new n.DefaultEncoding(this);
      this.substitution = new m(this);
      this.tables = this.tables || {};
    }
    var f = c("./path"), k = c("./tables/sfnt"), n = c("./encoding"), p = c("./glyphset"), m = c("./substitution"), t = c("./util");
    e.prototype.hasChar = function(b) {
      return null !== this.encoding.charToGlyphIndex(b);
    };
    e.prototype.charToGlyphIndex = function(b) {
      return this.encoding.charToGlyphIndex(b);
    };
    e.prototype.charToGlyph = function(b) {
      b = this.charToGlyphIndex(b);
      b = this.glyphs.get(b);
      return b || (b = this.glyphs.get(0)), b;
    };
    e.prototype.stringToGlyphs = function(b) {
      for (var c = [], d = 0; d < b.length; d += 1) {
        c.push(this.charToGlyph(b[d]));
      }
      return c;
    };
    e.prototype.nameToGlyphIndex = function(b) {
      return this.glyphNames.nameToGlyphIndex(b);
    };
    e.prototype.nameToGlyph = function(b) {
      b = this.nametoGlyphIndex(b);
      b = this.glyphs.get(b);
      return b || (b = this.glyphs.get(0)), b;
    };
    e.prototype.glyphIndexToName = function(b) {
      return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(b) : "";
    };
    e.prototype.getKerningValue = function(b, c) {
      b = b.index || b;
      c = c.index || c;
      var d = this.getGposKerningValue;
      return d ? d(b, c) : this.kerningPairs[b + "," + c] || 0;
    };
    e.prototype.forEachGlyph = function(b, c, e, f, g, k) {
      c = void 0 !== c ? c : 0;
      e = void 0 !== e ? e : 0;
      f = void 0 !== f ? f : 72;
      g = g || {};
      var d = void 0 === g.kerning ? !0 : g.kerning, l = 1 / this.unitsPerEm * f;
      b = this.stringToGlyphs(b);
      for (var m = 0; m < b.length; m += 1) {
        var n = b[m];
        if (k(n, c, e, f, g), n.advanceWidth && (c += n.advanceWidth * l), d && m < b.length - 1) {
          n = this.getKerningValue(n, b[m + 1]), c += n * l;
        }
      }
    };
    e.prototype.getPath = function(b, c, e, g, k) {
      var d = new f.Path;
      return this.forEachGlyph(b, c, e, g, k, function(b, c, e, f) {
        b = b.getPath(c, e, f);
        d.extend(b);
      }), d;
    };
    e.prototype.getPaths = function(b, c, e, f, g) {
      var d = [];
      return this.forEachGlyph(b, c, e, f, g, function(b, c, e, f) {
        b = b.getPath(c, e, f);
        d.push(b);
      }), d;
    };
    e.prototype.draw = function(b, c, e, f, g, k) {
      this.getPath(c, e, f, g, k).draw(b);
    };
    e.prototype.drawPoints = function(b, c, e, f, g, k) {
      this.forEachGlyph(c, e, f, g, k, function(c, d, e, f) {
        c.drawPoints(b, d, e, f);
      });
    };
    e.prototype.drawMetrics = function(b, c, e, f, g, k) {
      this.forEachGlyph(c, e, f, g, k, function(c, d, e, f) {
        c.drawMetrics(b, d, e, f);
      });
    };
    e.prototype.getEnglishName = function(b) {
      return (b = this.names[b]) ? b.en : void 0;
    };
    e.prototype.validate = function() {
      function b(b) {
        var d = e.getEnglishName(b);
        d && 0 < d.trim().length || c.push("No English " + b + " specified.");
      }
      var c = [], e = this;
      b("fontFamily");
      b("weightName");
      b("manufacturer");
      b("copyright");
      b("version");
      0 < this.unitsPerEm || c.push("No unitsPerEm specified.");
    };
    e.prototype.toTables = function() {
      return k.fontToTable(this);
    };
    e.prototype.toBuffer = function() {
      return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."), this.toArrayBuffer();
    };
    e.prototype.toArrayBuffer = function() {
      for (var b = this.toTables().encode(), c = new ArrayBuffer(b.length), e = new Uint8Array(c), f = 0; f < b.length; f++) {
        e[f] = b[f];
      }
      return c;
    };
    e.prototype.download = function() {
      var b = this.getEnglishName("fontFamily"), e = this.getEnglishName("fontSubfamily"), f = b.replace(/\s/g, "") + "-" + e + ".otf", g = this.toArrayBuffer();
      t.isBrowser() ? (window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem, window.requestFileSystem(window.TEMPORARY, g.byteLength, function(b) {
        b.root.getFile(f, {create:!0}, function(b) {
          b.createWriter(function(c) {
            var d = new DataView(g);
            d = new Blob([d], {type:"font/opentype"});
            c.write(d);
            c.addEventListener("writeend", function() {
              location.href = b.toURL();
            }, !1);
          });
        });
      }, function(b) {
        throw Error(b.name + ": " + b.message);
      })) : (b = c("fs"), e = t.arrayBufferToNodeBuffer(g), b.writeFileSync(f, e));
    };
    e.prototype.fsSelectionValues = {ITALIC:1, UNDERSCORE:2, NEGATIVE:4, OUTLINED:8, STRIKEOUT:16, BOLD:32, REGULAR:64, USER_TYPO_METRICS:128, WWS:256, OBLIQUE:512};
    e.prototype.usWidthClasses = {ULTRA_CONDENSED:1, EXTRA_CONDENSED:2, CONDENSED:3, SEMI_CONDENSED:4, MEDIUM:5, SEMI_EXPANDED:6, EXPANDED:7, EXTRA_EXPANDED:8, ULTRA_EXPANDED:9};
    e.prototype.usWeightClasses = {THIN:100, EXTRA_LIGHT:200, LIGHT:300, NORMAL:400, MEDIUM:500, SEMI_BOLD:600, BOLD:700, EXTRA_BOLD:800, BLACK:900};
    b.Font = e;
  }, {"./encoding":4, "./glyphset":7, "./path":11, "./substitution":12, "./tables/sfnt":31, "./util":33, fs:void 0}], 6:[function(c, g, b) {
    function e(b, c) {
      var d = c || {commands:[]};
      return {configurable:!0, get:function() {
        return "function" == typeof d && (d = d()), d;
      }, set:function(b) {
        d = b;
      }};
    }
    function f(b) {
      this.bindConstructorValues(b);
    }
    var k = c("./check"), n = c("./draw"), p = c("./path");
    f.prototype.bindConstructorValues = function(b) {
      this.index = b.index || 0;
      this.name = b.name || null;
      this.unicode = b.unicode || void 0;
      this.unicodes = b.unicodes || void 0 !== b.unicode ? [b.unicode] : [];
      b.xMin && (this.xMin = b.xMin);
      b.yMin && (this.yMin = b.yMin);
      b.xMax && (this.xMax = b.xMax);
      b.yMax && (this.yMax = b.yMax);
      b.advanceWidth && (this.advanceWidth = b.advanceWidth);
      Object.defineProperty(this, "path", e(this, b.path));
    };
    f.prototype.addUnicode = function(b) {
      0 === this.unicodes.length && (this.unicode = b);
      this.unicodes.push(b);
    };
    f.prototype.getPath = function(b, c, d, e) {
      b = void 0 !== b ? b : 0;
      c = void 0 !== c ? c : 0;
      e = void 0 !== e ? e : {xScale:1, yScale:1};
      var f = 1 / this.path.unitsPerEm * (void 0 !== d ? d : 72);
      d = e.xScale * f;
      e = e.yScale * f;
      f = new p.Path;
      for (var g = this.path.commands, k = 0; k < g.length; k += 1) {
        var l = g[k];
        "M" === l.type ? f.moveTo(b + l.x * d, c + -l.y * e) : "L" === l.type ? f.lineTo(b + l.x * d, c + -l.y * e) : "Q" === l.type ? f.quadraticCurveTo(b + l.x1 * d, c + -l.y1 * e, b + l.x * d, c + -l.y * e) : "C" === l.type ? f.curveTo(b + l.x1 * d, c + -l.y1 * e, b + l.x2 * d, c + -l.y2 * e, b + l.x * d, c + -l.y * e) : "Z" === l.type && f.closePath();
      }
      return f;
    };
    f.prototype.getContours = function() {
      if (void 0 === this.points) {
        return [];
      }
      for (var b = [], c = [], d = 0; d < this.points.length; d += 1) {
        var e = this.points[d];
        c.push(e);
        e.lastPointOfContour && (b.push(c), c = []);
      }
      return k.argument(0 === c.length, "There are still points left in the current contour."), b;
    };
    f.prototype.getMetrics = function() {
      for (var b = this.path.commands, c = [], d = [], e = 0; e < b.length; e += 1) {
        var f = b[e];
        "Z" !== f.type && (c.push(f.x), d.push(f.y));
        "Q" !== f.type && "C" !== f.type || (c.push(f.x1), d.push(f.y1));
        "C" === f.type && (c.push(f.x2), d.push(f.y2));
      }
      b = {xMin:Math.min.apply(null, c), yMin:Math.min.apply(null, d), xMax:Math.max.apply(null, c), yMax:Math.max.apply(null, d), leftSideBearing:this.leftSideBearing};
      return isFinite(b.xMin) || (b.xMin = 0), isFinite(b.xMax) || (b.xMax = this.advanceWidth), isFinite(b.yMin) || (b.yMin = 0), isFinite(b.yMax) || (b.yMax = 0), b.rightSideBearing = this.advanceWidth - b.leftSideBearing - (b.xMax - b.xMin), b;
    };
    f.prototype.draw = function(b, c, d, e, f) {
      this.getPath(c, d, e, f).draw(b);
    };
    f.prototype.drawPoints = function(b, c, d, e) {
      function f(c, d, e, f) {
        var g = 2 * Math.PI;
        b.beginPath();
        for (var k = 0; k < c.length; k += 1) {
          b.moveTo(d + c[k].x * f, e + c[k].y * f), b.arc(d + c[k].x * f, e + c[k].y * f, 2, 0, g, !1);
        }
        b.closePath();
        b.fill();
      }
      c = void 0 !== c ? c : 0;
      d = void 0 !== d ? d : 0;
      e = 1 / this.path.unitsPerEm * (void 0 !== e ? e : 24);
      for (var g = [], k = [], l = this.path, m = 0; m < l.commands.length; m += 1) {
        var n = l.commands[m];
        void 0 !== n.x && g.push({x:n.x, y:-n.y});
        void 0 !== n.x1 && k.push({x:n.x1, y:-n.y1});
        void 0 !== n.x2 && k.push({x:n.x2, y:-n.y2});
      }
      b.fillStyle = "blue";
      f(g, c, d, e);
      b.fillStyle = "red";
      f(k, c, d, e);
    };
    f.prototype.drawMetrics = function(b, c, d, e) {
      c = void 0 !== c ? c : 0;
      d = void 0 !== d ? d : 0;
      e = 1 / this.path.unitsPerEm * (void 0 !== e ? e : 24);
      b.lineWidth = 1;
      b.strokeStyle = "black";
      n.line(b, c, -1E4, c, 1E4);
      n.line(b, -1E4, d, 1E4, d);
      var f = this.xMin || 0, g = this.yMin || 0, k = this.xMax || 0, l = this.yMax || 0, m = this.advanceWidth || 0;
      b.strokeStyle = "blue";
      n.line(b, c + f * e, -1E4, c + f * e, 1E4);
      n.line(b, c + k * e, -1E4, c + k * e, 1E4);
      n.line(b, -1E4, d + -g * e, 1E4, d + -g * e);
      n.line(b, -1E4, d + -l * e, 1E4, d + -l * e);
      b.strokeStyle = "green";
      n.line(b, c + m * e, -1E4, c + m * e, 1E4);
    };
    b.Glyph = f;
  }, {"./check":2, "./draw":3, "./path":11}], 7:[function(c, g, b) {
    function e(b, c, e) {
      Object.defineProperty(b, c, {get:function() {
        return b.path, b[e];
      }, set:function(c) {
        b[e] = c;
      }, enumerable:!0, configurable:!0});
    }
    function f(b, c) {
      if (this.font = b, this.glyphs = {}, Array.isArray(c)) {
        for (b = 0; b < c.length; b++) {
          this.glyphs[b] = c[b];
        }
      }
      this.length = c && c.length || 0;
    }
    var k = c("./glyph");
    f.prototype.get = function(b) {
      return "function" == typeof this.glyphs[b] && (this.glyphs[b] = this.glyphs[b]()), this.glyphs[b];
    };
    f.prototype.push = function(b, c) {
      this.glyphs[b] = c;
      this.length++;
    };
    b.GlyphSet = f;
    b.glyphLoader = function(b, c) {
      return new k.Glyph({index:c, font:b});
    };
    b.ttfGlyphLoader = function(b, c, f, g, d, l) {
      return function() {
        var m = new k.Glyph({index:c, font:b});
        return m.path = function() {
          f(m, g, d);
          var c = l(b.glyphs, m);
          return c.unitsPerEm = b.unitsPerEm, c;
        }, e(m, "xMin", "_xMin"), e(m, "xMax", "_xMax"), e(m, "yMin", "_yMin"), e(m, "yMax", "_yMax"), m;
      };
    };
    b.cffGlyphLoader = function(b, c, e, f) {
      return function() {
        var d = new k.Glyph({index:c, font:b});
        return d.path = function() {
          var c = e(b, d, f);
          return c.unitsPerEm = b.unitsPerEm, c;
        }, d;
      };
    };
  }, {"./glyph":6}], 8:[function(c, g, b) {
    function e(b, c) {
      for (var e = 0, f = b.length - 1; f >= e;) {
        var g = e + f >>> 1, d = b[g].tag;
        if (d === c) {
          return g;
        }
        c > d ? e = g + 1 : f = g - 1;
      }
      return -e - 1;
    }
    var f = c("./check");
    g.exports = {searchTag:e, binSearch:function(b, c) {
      for (var e = 0, f = b.length - 1; f >= e;) {
        var g = e + f >>> 1, d = b[g];
        if (d === c) {
          return g;
        }
        c > d ? e = g + 1 : f = g - 1;
      }
      return -e - 1;
    }, getScriptNames:function() {
      var b = this.getGsubTable();
      return b ? b.scripts.map(function(b) {
        return b.tag;
      }) : [];
    }, getScriptTable:function(b, c) {
      var f = this.getGsubTable(c);
      if (f) {
        c = f.scripts;
        f = e(f.scripts, b);
        if (0 <= f) {
          return c[f].script;
        }
        b = {tag:b, script:{defaultLangSys:{reserved:0, reqFeatureIndex:65535, featureIndexes:[]}, langSysRecords:[]}};
        return c.splice(-1 - f, 0, b.script), b;
      }
    }, getLangSysTable:function(b, c, f) {
      if (b = this.getScriptTable(b, f)) {
        if ("DFLT" === c) {
          return b.defaultLangSys;
        }
        var g = e(b.langSysRecords, c);
        if (0 <= g) {
          return b.langSysRecords[g].langSys;
        }
        if (f) {
          return c = {tag:c, langSys:{reserved:0, reqFeatureIndex:65535, featureIndexes:[]}}, b.langSysRecords.splice(-1 - g, 0, c), c.langSys;
        }
      }
    }, getFeatureTable:function(b, c, e, g) {
      if (b = this.getLangSysTable(b, c, g)) {
        var k;
        b = b.featureIndexes;
        c = this.font.tables.gsub.features;
        for (var d = 0; d < b.length; d++) {
          if (k = c[b[d]], k.tag === e) {
            return k.feature;
          }
        }
        if (g) {
          return g = c.length, f.assert(0 === g || e >= c[g - 1].tag, "Features must be added in alphabetical order."), k = {tag:e, feature:{params:0, lookupListIndexes:[]}}, c.push(k), b.push(g), k.feature;
        }
      }
    }, getLookupTable:function(b, c, e, f, g) {
      if (b = this.getFeatureTable(b, c, e, g)) {
        var d;
        b = b.lookupListIndexes;
        c = this.font.tables.gsub.lookups;
        for (e = 0; e < b.length; e++) {
          if (d = c[b[e]], d.lookupType === f) {
            return d;
          }
        }
        if (g) {
          return d = {lookupType:f, lookupFlag:0, subtables:[], markFilteringSet:void 0}, f = c.length, c.push(d), b.push(f), d;
        }
      }
    }, expandCoverage:function(b) {
      if (1 === b.format) {
        return b.glyphs;
      }
      var c = [];
      b = b.ranges;
      for (var e = 0; b > e; e++) {
        var f = b[e], g = f.end;
        for (f = f.start; g >= f; f++) {
          c.push(f);
        }
      }
      return c;
    }};
  }, {"./check":2}], 9:[function(c, g, b) {
    function e(b, d) {
      c("fs").readFile(b, function(b, c) {
        return b ? d(b.message) : void d(null, w.nodeBufferToArrayBuffer(c));
      });
    }
    function f(b, c) {
      var d = new XMLHttpRequest;
      d.open("get", b, !0);
      d.responseType = "arraybuffer";
      d.onload = function() {
        return 200 !== d.status ? c("Font could not be loaded: " + d.statusText) : c(null, d.response);
      };
      d.send();
    }
    function k(b, c) {
      for (var d = [], e = 12, f = 0; c > f; f += 1) {
        var g = l.getTag(b, e), k = l.getULong(b, e + 4), m = l.getULong(b, e + 8), n = l.getULong(b, e + 12);
        d.push({tag:g, checksum:k, offset:m, length:n, compression:!1});
        e += 16;
      }
      return d;
    }
    function n(b, c) {
      if ("WOFF" === c.compression) {
        b = new Uint8Array(b.buffer, c.offset + 2, c.compressedLength - 2);
        var d = new Uint8Array(c.originalLength);
        if (m(b, d), d.byteLength !== c.originalLength) {
          throw Error("Decompression error: " + c.tag + " decompressed length doesn't match recorded length");
        }
        return {data:new DataView(d.buffer, 0), offset:0};
      }
      return {data:b, offset:c.offset};
    }
    function p(b) {
      var c = new d.Font({empty:!0});
      b = new DataView(b, 0);
      var e = l.getTag(b, 0);
      if (e === String.fromCharCode(0, 1, 0, 0)) {
        c.outlinesFormat = "truetype";
        e = l.getUShort(b, 4);
        var f = k(b, e);
      } else {
        if ("OTTO" === e) {
          c.outlinesFormat = "cff", e = l.getUShort(b, 4), f = k(b, e);
        } else {
          if ("wOFF" !== e) {
            throw Error("Unsupported OpenType signature " + e);
          }
          f = l.getTag(b, 4);
          if (f === String.fromCharCode(0, 1, 0, 0)) {
            c.outlinesFormat = "truetype";
          } else {
            if ("OTTO" !== f) {
              throw Error("Unsupported OpenType flavor " + e);
            }
            c.outlinesFormat = "cff";
          }
          f = e = l.getUShort(b, 12);
          for (var g = [], m = 44, p = 0; f > p; p += 1) {
            var u = l.getTag(b, m), w = l.getULong(b, m + 4), Q = l.getULong(b, m + 8), ha = l.getULong(b, m + 12);
            g.push({tag:u, offset:w, compression:ha > Q ? "WOFF" : !1, compressedLength:Q, originalLength:ha});
            m += 20;
          }
          f = g;
        }
      }
      for (g = 0; e > g; g += 1) {
        switch(m = f[g], m.tag) {
          case "cmap":
            m = n(b, m);
            c.tables.cmap = y.parse(m.data, m.offset);
            c.encoding = new t.CmapEncoding(c.tables.cmap);
            break;
          case "fvar":
            var ja = m;
            break;
          case "head":
            m = n(b, m);
            c.tables.head = A.parse(m.data, m.offset);
            c.unitsPerEm = c.tables.head.unitsPerEm;
            var X = c.tables.head.indexToLocFormat;
            break;
          case "hhea":
            m = n(b, m);
            c.tables.hhea = D.parse(m.data, m.offset);
            c.ascender = c.tables.hhea.ascender;
            c.descender = c.tables.hhea.descender;
            c.numberOfHMetrics = c.tables.hhea.numberOfHMetrics;
            break;
          case "hmtx":
            var fa = m;
            break;
          case "ltag":
            m = n(b, m);
            var ba = G.parse(m.data, m.offset);
            break;
          case "maxp":
            m = n(b, m);
            c.tables.maxp = K.parse(m.data, m.offset);
            c.numGlyphs = c.tables.maxp.numGlyphs;
            break;
          case "name":
            var la = m;
            break;
          case "OS/2":
            m = n(b, m);
            c.tables.os2 = L.parse(m.data, m.offset);
            break;
          case "post":
            m = n(b, m);
            c.tables.post = R.parse(m.data, m.offset);
            c.glyphNames = new t.GlyphNames(c.tables.post);
            break;
          case "glyf":
            var ma = m;
            break;
          case "loca":
            var ca = m;
            break;
          case "CFF ":
            var Ua = m;
            break;
          case "kern":
            var ob = m;
            break;
          case "GPOS":
            var pb = m;
            break;
          case "GSUB":
            var qb = m;
            break;
          case "meta":
            var rb = m;
        }
      }
      la = n(b, la);
      if (c.tables.name = I.parse(la.data, la.offset, ba), c.names = c.tables.name, ma && ca) {
        X = 0 === X, ca = n(b, ca), ca = H.parse(ca.data, ca.offset, c.numGlyphs, X), ma = n(b, ma), c.glyphs = v.parse(ma.data, ma.offset, ca, c);
      } else {
        if (!Ua) {
          throw Error("Font doesn't contain TrueType or CFF outlines.");
        }
        ma = n(b, Ua);
        x.parse(ma.data, ma.offset, c);
      }
      fa = n(b, fa);
      (E.parse(fa.data, fa.offset, c.numberOfHMetrics, c.numGlyphs, c.glyphs), t.addGlyphNames(c), ob) ? (ob = n(b, ob), c.kerningPairs = B.parse(ob.data, ob.offset)) : c.kerningPairs = {};
      pb && (pb = n(b, pb), z.parse(pb.data, pb.offset, c));
      qb && (qb = n(b, qb), c.tables.gsub = C.parse(qb.data, qb.offset));
      ja && (ja = n(b, ja), c.tables.fvar = q.parse(ja.data, ja.offset, c.names));
      rb && (rb = n(b, rb), c.tables.meta = J.parse(rb.data, rb.offset), c.metas = c.tables.meta);
      return c;
    }
    var m = c("tiny-inflate"), t = c("./encoding"), d = c("./font");
    g = c("./glyph");
    var l = c("./parse"), u = c("./path"), w = c("./util"), y = c("./tables/cmap"), x = c("./tables/cff"), q = c("./tables/fvar"), v = c("./tables/glyf"), z = c("./tables/gpos"), C = c("./tables/gsub"), A = c("./tables/head"), D = c("./tables/hhea"), E = c("./tables/hmtx"), B = c("./tables/kern"), G = c("./tables/ltag"), H = c("./tables/loca"), K = c("./tables/maxp"), I = c("./tables/name"), L = c("./tables/os2"), R = c("./tables/post"), J = c("./tables/meta");
    b._parse = l;
    b.Font = d.Font;
    b.Glyph = g.Glyph;
    b.Path = u.Path;
    b.parse = p;
    b.load = function(b, c) {
      ("undefined" == typeof window ? e : f)(b, function(b, d) {
        if (b) {
          return c(b);
        }
        try {
          var e = p(d);
        } catch (V) {
          return c(V, null);
        }
        return c(null, e);
      });
    };
    b.loadSync = function(b) {
      b = c("fs").readFileSync(b);
      return p(w.nodeBufferToArrayBuffer(b));
    };
  }, {"./encoding":4, "./font":5, "./glyph":6, "./parse":10, "./path":11, "./tables/cff":14, "./tables/cmap":15, "./tables/fvar":16, "./tables/glyf":17, "./tables/gpos":18, "./tables/gsub":19, "./tables/head":20, "./tables/hhea":21, "./tables/hmtx":22, "./tables/kern":23, "./tables/loca":24, "./tables/ltag":25, "./tables/maxp":26, "./tables/meta":27, "./tables/name":28, "./tables/os2":29, "./tables/post":30, "./util":33, fs:void 0, "tiny-inflate":1}], 10:[function(c, g, b) {
    function e(b, c) {
      return b.getUint16(c, !1);
    }
    function f(b, c) {
      this.data = b;
      this.offset = c;
      this.relativeOffset = 0;
    }
    var k = c("./check");
    b.getByte = function(b, c) {
      return b.getUint8(c);
    };
    b.getCard8 = b.getByte;
    b.getUShort = b.getCard16 = e;
    b.getShort = function(b, c) {
      return b.getInt16(c, !1);
    };
    b.getULong = function(b, c) {
      return b.getUint32(c, !1);
    };
    b.getFixed = function(b, c) {
      var d = b.getInt16(c, !1);
      b = b.getUint16(c + 2, !1);
      return d + b / 65535;
    };
    b.getTag = function(b, c) {
      for (var d = "", e = c; c + 4 > e; e += 1) {
        d += String.fromCharCode(b.getInt8(e));
      }
      return d;
    };
    b.getOffset = function(b, c, d) {
      for (var e = 0, f = 0; d > f; f += 1) {
        e <<= 8, e += b.getUint8(c + f);
      }
      return e;
    };
    b.getBytes = function(b, c, d) {
      for (var e = []; d > c; c += 1) {
        e.push(b.getUint8(c));
      }
      return e;
    };
    b.bytesToString = function(b) {
      for (var c = "", d = 0; d < b.length; d += 1) {
        c += String.fromCharCode(b[d]);
      }
      return c;
    };
    var n = {"byte":1, uShort:2, "short":2, uLong:4, fixed:4, longDateTime:8, tag:4};
    f.prototype.parseByte = function() {
      var b = this.data.getUint8(this.offset + this.relativeOffset);
      return this.relativeOffset += 1, b;
    };
    f.prototype.parseChar = function() {
      var b = this.data.getInt8(this.offset + this.relativeOffset);
      return this.relativeOffset += 1, b;
    };
    f.prototype.parseCard8 = f.prototype.parseByte;
    f.prototype.parseUShort = function() {
      var b = this.data.getUint16(this.offset + this.relativeOffset);
      return this.relativeOffset += 2, b;
    };
    f.prototype.parseCard16 = f.prototype.parseUShort;
    f.prototype.parseSID = f.prototype.parseUShort;
    f.prototype.parseOffset16 = f.prototype.parseUShort;
    f.prototype.parseShort = function() {
      var b = this.data.getInt16(this.offset + this.relativeOffset);
      return this.relativeOffset += 2, b;
    };
    f.prototype.parseF2Dot14 = function() {
      var b = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
      return this.relativeOffset += 2, b;
    };
    f.prototype.parseULong = function() {
      var c = b.getULong(this.data, this.offset + this.relativeOffset);
      return this.relativeOffset += 4, c;
    };
    f.prototype.parseFixed = function() {
      var c = b.getFixed(this.data, this.offset + this.relativeOffset);
      return this.relativeOffset += 4, c;
    };
    f.prototype.parseString = function(b) {
      var c = this.data, d = this.offset + this.relativeOffset, e = "";
      this.relativeOffset += b;
      for (var f = 0; b > f; f++) {
        e += String.fromCharCode(c.getUint8(d + f));
      }
      return e;
    };
    f.prototype.parseTag = function() {
      return this.parseString(4);
    };
    f.prototype.parseLongDateTime = function() {
      var c = b.getULong(this.data, this.offset + this.relativeOffset + 4);
      return c -= 2082844800, this.relativeOffset += 8, c;
    };
    f.prototype.parseVersion = function() {
      var b = e(this.data, this.offset + this.relativeOffset), c = e(this.data, this.offset + this.relativeOffset + 2);
      return this.relativeOffset += 4, b + c / 4096 / 10;
    };
    f.prototype.skip = function(b, c) {
      void 0 === c && (c = 1);
      this.relativeOffset += n[b] * c;
    };
    f.prototype.parseOffset16List = f.prototype.parseUShortList = function(b) {
      void 0 === b && (b = this.parseUShort());
      for (var c = Array(b), d = this.data, e = this.offset + this.relativeOffset, f = 0; b > f; f++) {
        c[f] = d.getUint16(e), e += 2;
      }
      return this.relativeOffset += 2 * b, c;
    };
    f.prototype.parseList = function(b, c) {
      c || (c = b, b = this.parseUShort());
      for (var d = Array(b), e = 0; b > e; e++) {
        d[e] = c.call(this);
      }
      return d;
    };
    f.prototype.parseRecordList = function(b, c) {
      c || (c = b, b = this.parseUShort());
      for (var d = Array(b), e = Object.keys(c), f = 0; b > f; f++) {
        for (var g = {}, k = 0; k < e.length; k++) {
          var m = e[k];
          g[m] = c[m].call(this);
        }
        d[f] = g;
      }
      return d;
    };
    f.prototype.parseStruct = function(b) {
      if ("function" == typeof b) {
        return b.call(this);
      }
      for (var c = Object.keys(b), d = {}, e = 0; e < c.length; e++) {
        var f = c[e];
        d[f] = b[f].call(this);
      }
      return d;
    };
    f.prototype.parsePointer = function(b) {
      var c = this.parseOffset16();
      return 0 < c ? (new f(this.data, this.offset + c)).parseStruct(b) : void 0;
    };
    f.prototype.parseListOfLists = function(b) {
      for (var c = this.parseOffset16List(), d = c.length, e = this.relativeOffset, f = Array(d), g = 0; d > g; g++) {
        var k = c[g];
        if (0 !== k) {
          if (this.relativeOffset = k, b) {
            for (var m = this.parseOffset16List(), n = Array(m.length), p = 0; p < m.length; p++) {
              this.relativeOffset = k + m[p], n[p] = b.call(this);
            }
            f[g] = n;
          } else {
            f[g] = this.parseUShortList();
          }
        } else {
          f[g] = void 0;
        }
      }
      return this.relativeOffset = e, f;
    };
    f.prototype.parseCoverage = function() {
      var b = this.offset + this.relativeOffset, c = this.parseUShort(), d = this.parseUShort();
      if (1 === c) {
        return {format:1, glyphs:this.parseUShortList(d)};
      }
      if (2 === c) {
        b = Array(d);
        for (c = 0; d > c; c++) {
          b[c] = {start:this.parseUShort(), end:this.parseUShort(), index:this.parseUShort()};
        }
        return {format:2, ranges:b};
      }
      k.assert(!1, "0x" + b.toString(16) + ": Coverage format must be 1 or 2.");
    };
    f.prototype.parseClassDef = function() {
      var b = this.offset + this.relativeOffset, c = this.parseUShort();
      return 1 === c ? {format:1, startGlyph:this.parseUShort(), classes:this.parseUShortList()} : 2 === c ? {format:2, ranges:this.parseRecordList({start:f.uShort, end:f.uShort, classId:f.uShort})} : void k.assert(!1, "0x" + b.toString(16) + ": ClassDef format must be 1 or 2.");
    };
    f.list = function(b, c) {
      return function() {
        return this.parseList(b, c);
      };
    };
    f.recordList = function(b, c) {
      return function() {
        return this.parseRecordList(b, c);
      };
    };
    f.pointer = function(b) {
      return function() {
        return this.parsePointer(b);
      };
    };
    f.tag = f.prototype.parseTag;
    f.byte = f.prototype.parseByte;
    f.uShort = f.offset16 = f.prototype.parseUShort;
    f.uShortList = f.prototype.parseUShortList;
    f.struct = f.prototype.parseStruct;
    f.coverage = f.prototype.parseCoverage;
    f.classDef = f.prototype.parseClassDef;
    var p = {reserved:f.uShort, reqFeatureIndex:f.uShort, featureIndexes:f.uShortList};
    f.prototype.parseScriptList = function() {
      return this.parsePointer(f.recordList({tag:f.tag, script:f.pointer({defaultLangSys:f.pointer(p), langSysRecords:f.recordList({tag:f.tag, langSys:f.pointer(p)})})}));
    };
    f.prototype.parseFeatureList = function() {
      return this.parsePointer(f.recordList({tag:f.tag, feature:f.pointer({featureParams:f.offset16, lookupListIndexes:f.uShortList})}));
    };
    f.prototype.parseLookupList = function(b) {
      return this.parsePointer(f.list(f.pointer(function() {
        var c = this.parseUShort();
        k.argument(1 <= c && 8 >= c, "GSUB lookup type " + c + " unknown.");
        var d = this.parseUShort(), e = 16 & d;
        return {lookupType:c, lookupFlag:d, subtables:this.parseList(f.pointer(b[c])), markFilteringSet:e ? this.parseUShort() : void 0};
      })));
    };
    b.Parser = f;
  }, {"./check":2}], 11:[function(c, g, b) {
    function e() {
      this.commands = [];
      this.fill = "black";
      this.stroke = null;
      this.strokeWidth = 1;
    }
    e.prototype.moveTo = function(b, c) {
      this.commands.push({type:"M", x:b, y:c});
    };
    e.prototype.lineTo = function(b, c) {
      this.commands.push({type:"L", x:b, y:c});
    };
    e.prototype.curveTo = e.prototype.bezierCurveTo = function(b, c, e, g, m, t) {
      this.commands.push({type:"C", x1:b, y1:c, x2:e, y2:g, x:m, y:t});
    };
    e.prototype.quadTo = e.prototype.quadraticCurveTo = function(b, c, e, g) {
      this.commands.push({type:"Q", x1:b, y1:c, x:e, y:g});
    };
    e.prototype.close = e.prototype.closePath = function() {
      this.commands.push({type:"Z"});
    };
    e.prototype.extend = function(b) {
      b.commands && (b = b.commands);
      Array.prototype.push.apply(this.commands, b);
    };
    e.prototype.draw = function(b) {
      b.beginPath();
      for (var c = 0; c < this.commands.length; c += 1) {
        var e = this.commands[c];
        "M" === e.type ? b.moveTo(e.x, e.y) : "L" === e.type ? b.lineTo(e.x, e.y) : "C" === e.type ? b.bezierCurveTo(e.x1, e.y1, e.x2, e.y2, e.x, e.y) : "Q" === e.type ? b.quadraticCurveTo(e.x1, e.y1, e.x, e.y) : "Z" === e.type && b.closePath();
      }
      this.fill && (b.fillStyle = this.fill, b.fill());
      this.stroke && (b.strokeStyle = this.stroke, b.lineWidth = this.strokeWidth, b.stroke());
    };
    e.prototype.toPathData = function(b) {
      function c() {
        for (var c = "", d = 0; d < arguments.length; d += 1) {
          var e = arguments[d];
          0 <= e && 0 < d && (c += " ");
          c += Math.round(e) === e ? "" + Math.round(e) : e.toFixed(b);
        }
        return c;
      }
      b = void 0 !== b ? b : 2;
      for (var e = "", f = 0; f < this.commands.length; f += 1) {
        var g = this.commands[f];
        "M" === g.type ? e += "M" + c(g.x, g.y) : "L" === g.type ? e += "L" + c(g.x, g.y) : "C" === g.type ? e += "C" + c(g.x1, g.y1, g.x2, g.y2, g.x, g.y) : "Q" === g.type ? e += "Q" + c(g.x1, g.y1, g.x, g.y) : "Z" === g.type && (e += "Z");
      }
      return e;
    };
    e.prototype.toSVG = function(b) {
      var c = '<path d="';
      return c += this.toPathData(b), c += '"', this.fill && "black" !== this.fill && (c += null === this.fill ? ' fill="none"' : ' fill="' + this.fill + '"'), this.stroke && (c += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"'), c + "/>";
    };
    b.Path = e;
  }, {}], 12:[function(c, g, b) {
    function e(b, c, e) {
      b = b.subtables;
      for (var f = 0; f < b.length; f++) {
        var g = b[f];
        if (g.substFormat === c) {
          return g;
        }
      }
      return e ? (b.push(e), e) : void 0;
    }
    var f = c("./check");
    c = c("./layout");
    b = function(b) {
      this.font = b;
    };
    b.prototype = c;
    b.prototype.getGsubTable = function(b) {
      var c = this.font.tables.gsub;
      return !c && b && (this.font.tables.gsub = c = {version:1, scripts:[{tag:"DFLT", script:{defaultLangSys:{reserved:0, reqFeatureIndex:65535, featureIndexes:[]}, langSysRecords:[]}}], features:[], lookups:[]}), c;
    };
    b.prototype.getSingle = function(b, c, e) {
      var f = [];
      b = this.getLookupTable(c, e, b, 1);
      if (!b) {
        return f;
      }
      b = b.subtables;
      for (c = 0; c < b.length; c++) {
        var g = b[c];
        e = this.expandCoverage(g.coverage);
        if (1 === g.substFormat) {
          var d = g.deltaGlyphId;
          for (g = 0; g < e.length; g++) {
            var k = e[g];
            f.push({sub:k, by:k + d});
          }
        } else {
          for (d = g.substitute, g = 0; g < e.length; g++) {
            f.push({sub:e[g], by:d[g]});
          }
        }
      }
      return f;
    };
    b.prototype.getAlternates = function(b, c, e) {
      var f = [];
      b = this.getLookupTable(c, e, b, 3);
      if (!b) {
        return f;
      }
      b = b.subtables;
      for (c = 0; c < b.length; c++) {
        var g = b[c];
        e = this.expandCoverage(g.coverage);
        g = g.alternateSets;
        for (var d = 0; d < e.length; d++) {
          f.push({sub:e[d], by:g[d]});
        }
      }
      return f;
    };
    b.prototype.getLigatures = function(b, c, e) {
      var f = [];
      b = this.getLookupTable(c, e, b, 4);
      if (!b) {
        return [];
      }
      b = b.subtables;
      for (c = 0; c < b.length; c++) {
        var g = b[c];
        e = this.expandCoverage(g.coverage);
        g = g.ligatureSets;
        for (var d = 0; d < e.length; d++) {
          for (var k = e[d], n = g[d], p = 0; p < n.length; p++) {
            var y = n[p];
            f.push({sub:[k].concat(y.components), by:y.ligGlyph});
          }
        }
      }
      return f;
    };
    b.prototype.addSingle = function(b, c, g, m) {
      b = this.getLookupTable(g, m, b, 1, !0);
      b = e(b, 2, {substFormat:2, coverage:{format:1, glyphs:[]}, substitute:[]});
      f.assert(1 === b.coverage.format, "Ligature: unable to modify coverage table format " + b.coverage.format);
      g = c.sub;
      m = this.binSearch(b.coverage.glyphs, g);
      0 > m && (m = -1 - m, b.coverage.glyphs.splice(m, 0, g), b.substitute.splice(m, 0, 0));
      b.substitute[m] = c.by;
    };
    b.prototype.addAlternate = function(b, c, g, m) {
      b = this.getLookupTable(g, m, b, 3, !0);
      b = e(b, 1, {substFormat:1, coverage:{format:1, glyphs:[]}, alternateSets:[]});
      f.assert(1 === b.coverage.format, "Ligature: unable to modify coverage table format " + b.coverage.format);
      g = c.sub;
      m = this.binSearch(b.coverage.glyphs, g);
      0 > m && (m = -1 - m, b.coverage.glyphs.splice(m, 0, g), b.alternateSets.splice(m, 0, 0));
      b.alternateSets[m] = c.by;
    };
    b.prototype.addLigature = function(b, c, e, g) {
      b = this.getLookupTable(e || "DFLT", g || "DFLT", b, 4, !0);
      (e = b.subtables[0]) || (e = {substFormat:1, coverage:{format:1, glyphs:[]}, ligatureSets:[]}, b.subtables[0] = e);
      f.assert(1 === e.coverage.format, "Ligature: unable to modify coverage table format " + e.coverage.format);
      g = c.sub[0];
      b = c.sub.slice(1);
      c = {ligGlyph:c.by, components:b};
      var k = this.binSearch(e.coverage.glyphs, g);
      if (0 <= k) {
        e = e.ligatureSets[k];
        for (g = 0; g < e.length; g++) {
          a: {
            k = e[g].components;
            var d = k.length;
            if (d !== b.length) {
              k = !1;
            } else {
              for (var l = 0; d > l; l++) {
                if (k[l] !== b[l]) {
                  k = !1;
                  break a;
                }
              }
              k = !0;
            }
          }
          if (k) {
            return;
          }
        }
        e.push(c);
      } else {
        k = -1 - k, e.coverage.glyphs.splice(k, 0, g), e.ligatureSets.splice(k, 0, [c]);
      }
    };
    b.prototype.getFeature = function(b, c, e) {
      if (c = c || "DFLT", e = e || "DFLT", /ss\d\d/.test(b)) {
        return this.getSingle(b, c, e);
      }
      switch(b) {
        case "aalt":
        case "salt":
          return this.getSingle(b, c, e).concat(this.getAlternates(b, c, e));
        case "dlig":
        case "liga":
        case "rlig":
          return this.getLigatures(b, c, e);
      }
    };
    b.prototype.add = function(b, c, e, f) {
      if (e = e || "DFLT", f = f || "DFLT", /ss\d\d/.test(b)) {
        return this.addSingle(b, c, e, f);
      }
      switch(b) {
        case "aalt":
        case "salt":
          return "number" == typeof c.by ? this.addSingle(b, c, e, f) : this.addAlternate(b, c, e, f);
        case "dlig":
        case "liga":
        case "rlig":
          return this.addLigature(b, c, e, f);
      }
    };
    g.exports = b;
  }, {"./check":2, "./layout":8}], 13:[function(c, g, b) {
    function e(b, c, d) {
      var e;
      for (e = 0; e < c.length; e += 1) {
        var f = c[e];
        this[f.name] = f.value;
      }
      if (this.tableName = b, this.fields = c, d) {
        for (b = Object.keys(d), e = 0; e < b.length; e += 1) {
          c = b[e], f = d[c], void 0 !== this[c] && (this[c] = f);
        }
      }
    }
    function f(b, c, d) {
      void 0 === d && (d = c.length);
      var e = Array(c.length + 1);
      e[0] = {name:b + "Count", type:"USHORT", value:d};
      for (d = 0; d < c.length; d++) {
        e[d + 1] = {name:b + d, type:"USHORT", value:c[d]};
      }
      return e;
    }
    function k(b, c, d) {
      var e = c.length, f = Array(e + 1);
      f[0] = {name:b + "Count", type:"USHORT", value:e};
      for (var g = 0; e > g; g++) {
        f[g + 1] = {name:b + g, type:"TABLE", value:d(c[g], g)};
      }
      return f;
    }
    function n(b, c, d) {
      var e = c.length, f = [];
      f[0] = {name:b + "Count", type:"USHORT", value:e};
      for (b = 0; e > b; b++) {
        f = f.concat(d(c[b], b));
      }
      return f;
    }
    function p(b) {
      1 === b.format ? e.call(this, "coverageTable", [{name:"coverageFormat", type:"USHORT", value:1}].concat(f("glyph", b.glyphs))) : l.assert(!1, "Can't create coverage table format 2 yet.");
    }
    function m(b) {
      e.call(this, "scriptListTable", n("scriptRecord", b, function(b, c) {
        var d = b.script, g = d.defaultLangSys;
        return l.assert(!!g, "Unable to write GSUB: script " + b.tag + " has no default language system."), [{name:"scriptTag" + c, type:"TAG", value:b.tag}, {name:"script" + c, type:"TABLE", value:new e("scriptTable", [{name:"defaultLangSys", type:"TABLE", value:new e("defaultLangSys", [{name:"lookupOrder", type:"USHORT", value:0}, {name:"reqFeatureIndex", type:"USHORT", value:g.reqFeatureIndex}].concat(f("featureIndex", g.featureIndexes)))}].concat(n("langSys", d.langSysRecords, function(b, c) {
          var d = b.langSys;
          return [{name:"langSysTag" + c, type:"TAG", value:b.tag}, {name:"langSys" + c, type:"TABLE", value:new e("langSys", [{name:"lookupOrder", type:"USHORT", value:0}, {name:"reqFeatureIndex", type:"USHORT", value:d.reqFeatureIndex}].concat(f("featureIndex", d.featureIndexes)))}];
        })))}];
      }));
    }
    function t(b) {
      e.call(this, "featureListTable", n("featureRecord", b, function(b, c) {
        var d = b.feature;
        return [{name:"featureTag" + c, type:"TAG", value:b.tag}, {name:"feature" + c, type:"TABLE", value:new e("featureTable", [{name:"featureParams", type:"USHORT", value:d.featureParams}].concat(f("lookupListIndex", d.lookupListIndexes)))}];
      }));
    }
    function d(b, c) {
      e.call(this, "lookupListTable", k("lookup", b, function(b) {
        var d = c[b.lookupType];
        return l.assert(!!d, "Unable to write GSUB lookup type " + b.lookupType + " tables."), new e("lookupTable", [{name:"lookupType", type:"USHORT", value:b.lookupType}, {name:"lookupFlag", type:"USHORT", value:b.lookupFlag}].concat(k("subtable", b.subtables, d)));
      }));
    }
    var l = c("./check"), u = c("./types").encode, w = c("./types").sizeOf;
    e.prototype.encode = function() {
      return u.TABLE(this);
    };
    e.prototype.sizeOf = function() {
      return w.TABLE(this);
    };
    p.prototype = Object.create(e.prototype);
    p.prototype.constructor = p;
    m.prototype = Object.create(e.prototype);
    m.prototype.constructor = m;
    t.prototype = Object.create(e.prototype);
    t.prototype.constructor = t;
    d.prototype = Object.create(e.prototype);
    d.prototype.constructor = d;
    b.Record = b.Table = e;
    b.Coverage = p;
    b.ScriptList = m;
    b.FeatureList = t;
    b.LookupList = d;
    b.ushortList = f;
    b.tableList = k;
    b.recordList = n;
  }, {"./check":2, "./types":32}], 14:[function(c, g, b) {
    function e(b, c) {
      if (b === c) {
        return !0;
      }
      if (Array.isArray(b) && Array.isArray(c)) {
        if (b.length !== c.length) {
          return !1;
        }
        for (var d = 0; d < b.length; d += 1) {
          if (!e(b[d], c[d])) {
            return !1;
          }
        }
        return !0;
      }
      return !1;
    }
    function f(b, c, d) {
      var e, f = [], g = [];
      var k = v.getCard16(b, c);
      if (0 !== k) {
        var l = v.getByte(b, c + 2);
        var m = c + (k + 1) * l + 2;
        var n = c + 3;
        for (e = 0; k + 1 > e; e += 1) {
          f.push(v.getOffset(b, n, l)), n += l;
        }
        k = m + f[k];
      } else {
        k = c + 2;
      }
      for (e = 0; e < f.length - 1; e += 1) {
        l = v.getBytes(b, m + f[e], m + f[e + 1]), d && (l = d(l)), g.push(l);
      }
      return {objects:g, startOffset:c, endOffset:k};
    }
    function k(b, c) {
      var d, e, f, g;
      if (28 === c) {
        return d = b.parseByte(), e = b.parseByte(), d << 8 | e;
      }
      if (29 === c) {
        return d = b.parseByte(), e = b.parseByte(), f = b.parseByte(), g = b.parseByte(), d << 24 | e << 16 | f << 8 | g;
      }
      if (30 === c) {
        c = "";
        for (d = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];;) {
          f = b.parseByte();
          e = f >> 4;
          f &= 15;
          if (15 === e) {
            break;
          }
          if (c += d[e], 15 === f) {
            break;
          }
          c += d[f];
        }
        return parseFloat(c);
      }
      if (32 <= c && 246 >= c) {
        return c - 139;
      }
      if (247 <= c && 250 >= c) {
        return d = b.parseByte(), 256 * (c - 247) + d + 108;
      }
      if (251 <= c && 254 >= c) {
        return d = b.parseByte(), 256 * -(c - 251) - d - 108;
      }
      throw Error("Invalid b0 " + c);
    }
    function n(b, c, d) {
      var e = new v.Parser(b, void 0 !== c ? c : 0);
      c = [];
      var f = [];
      for (d = void 0 !== d ? d : b.length; e.relativeOffset < d;) {
        b = e.parseByte(), 21 >= b ? (12 === b && (b = 1200 + e.parseByte()), c.push([b, f]), f = []) : f.push(k(e, b));
      }
      d = {};
      for (b = 0; b < c.length; b += 1) {
        e = c[b][0];
        f = c[b][1];
        if (f = 1 === f.length ? f[0] : f, d.hasOwnProperty(e)) {
          throw Error("Object " + d + " already has key " + e);
        }
        d[e] = f;
      }
      return d;
    }
    function p(b, c) {
      return 390 >= c ? x.cffStandardStrings[c] : b[c - 391];
    }
    function m(b, c, d) {
      for (var e = {}, f = 0; f < c.length; f += 1) {
        var g = c[f], k = b[g.op];
        void 0 === k && (k = void 0 !== g.value ? g.value : null);
        "SID" === g.type && (k = p(d, k));
        e[g.name] = k;
      }
      return e;
    }
    function t(b, c, d) {
      function e(b, c) {
        v && q.closePath();
        q.moveTo(b, c);
        v = !0;
      }
      function f() {
        0 !== p.length % 2 && !t && (w = p.shift() + b.nominalWidthX);
        u += p.length >> 1;
        p.length = 0;
        t = !0;
      }
      function g(d) {
        for (var z, A, B, C, D, E, G, H, I, J, K = 0; K < d.length;) {
          switch(D = d[K], K += 1, D) {
            case 1:
              f();
              break;
            case 3:
              f();
              break;
            case 4:
              1 < p.length && !t && (w = p.shift() + b.nominalWidthX, t = !0);
              x += p.pop();
              e(y, x);
              break;
            case 5:
              for (; 0 < p.length;) {
                y += p.shift(), x += p.shift(), q.lineTo(y, x);
              }
              break;
            case 6:
              for (; 0 < p.length && (y += p.shift(), q.lineTo(y, x), 0 !== p.length);) {
                x += p.shift(), q.lineTo(y, x);
              }
              break;
            case 7:
              for (; 0 < p.length && (x += p.shift(), q.lineTo(y, x), 0 !== p.length);) {
                y += p.shift(), q.lineTo(y, x);
              }
              break;
            case 8:
              for (; 0 < p.length;) {
                k = y + p.shift(), l = x + p.shift(), m = k + p.shift(), n = l + p.shift(), y = m + p.shift(), x = n + p.shift(), q.curveTo(k, l, m, n, y, x);
              }
              break;
            case 10:
              D = p.pop() + b.subrsBias;
              (D = b.subrs[D]) && g(D);
              break;
            case 11:
              return;
            case 12:
              switch(D = d[K], K += 1, D) {
                case 35:
                  k = y + p.shift();
                  l = x + p.shift();
                  m = k + p.shift();
                  n = l + p.shift();
                  D = m + p.shift();
                  E = n + p.shift();
                  G = D + p.shift();
                  H = E + p.shift();
                  I = G + p.shift();
                  J = H + p.shift();
                  y = I + p.shift();
                  x = J + p.shift();
                  p.shift();
                  q.curveTo(k, l, m, n, D, E);
                  q.curveTo(G, H, I, J, y, x);
                  break;
                case 34:
                  k = y + p.shift();
                  l = x;
                  m = k + p.shift();
                  n = l + p.shift();
                  D = m + p.shift();
                  E = n;
                  G = D + p.shift();
                  H = n;
                  I = G + p.shift();
                  J = x;
                  y = I + p.shift();
                  q.curveTo(k, l, m, n, D, E);
                  q.curveTo(G, H, I, J, y, x);
                  break;
                case 36:
                  k = y + p.shift();
                  l = x + p.shift();
                  m = k + p.shift();
                  n = l + p.shift();
                  D = m + p.shift();
                  E = n;
                  G = D + p.shift();
                  H = n;
                  I = G + p.shift();
                  J = H + p.shift();
                  y = I + p.shift();
                  q.curveTo(k, l, m, n, D, E);
                  q.curveTo(G, H, I, J, y, x);
                  break;
                case 37:
                  k = y + p.shift();
                  l = x + p.shift();
                  m = k + p.shift();
                  n = l + p.shift();
                  D = m + p.shift();
                  E = n + p.shift();
                  G = D + p.shift();
                  H = E + p.shift();
                  I = G + p.shift();
                  J = H + p.shift();
                  Math.abs(I - y) > Math.abs(J - x) ? y = I + p.shift() : x = J + p.shift();
                  q.curveTo(k, l, m, n, D, E);
                  q.curveTo(G, H, I, J, y, x);
                  break;
                default:
                  console.log("Glyph " + c.index + ": unknown operator 1200" + D), p.length = 0;
              }break;
            case 14:
              0 < p.length && !t && (w = p.shift() + b.nominalWidthX, t = !0);
              v && (q.closePath(), v = !1);
              break;
            case 18:
              f();
              break;
            case 19:
            case 20:
              f();
              K += u + 7 >> 3;
              break;
            case 21:
              2 < p.length && !t && (w = p.shift() + b.nominalWidthX, t = !0);
              x += p.pop();
              y += p.pop();
              e(y, x);
              break;
            case 22:
              1 < p.length && !t && (w = p.shift() + b.nominalWidthX, t = !0);
              y += p.pop();
              e(y, x);
              break;
            case 23:
              f();
              break;
            case 24:
              for (; 2 < p.length;) {
                k = y + p.shift(), l = x + p.shift(), m = k + p.shift(), n = l + p.shift(), y = m + p.shift(), x = n + p.shift(), q.curveTo(k, l, m, n, y, x);
              }
              y += p.shift();
              x += p.shift();
              q.lineTo(y, x);
              break;
            case 25:
              for (; 6 < p.length;) {
                y += p.shift(), x += p.shift(), q.lineTo(y, x);
              }
              k = y + p.shift();
              l = x + p.shift();
              m = k + p.shift();
              n = l + p.shift();
              y = m + p.shift();
              x = n + p.shift();
              q.curveTo(k, l, m, n, y, x);
              break;
            case 26:
              for (p.length % 2 && (y += p.shift()); 0 < p.length;) {
                k = y, l = x + p.shift(), m = k + p.shift(), n = l + p.shift(), y = m, x = n + p.shift(), q.curveTo(k, l, m, n, y, x);
              }
              break;
            case 27:
              for (p.length % 2 && (x += p.shift()); 0 < p.length;) {
                k = y + p.shift(), l = x, m = k + p.shift(), n = l + p.shift(), y = m + p.shift(), x = n, q.curveTo(k, l, m, n, y, x);
              }
              break;
            case 28:
              z = d[K];
              A = d[K + 1];
              p.push((z << 24 | A << 16) >> 16);
              K += 2;
              break;
            case 29:
              D = p.pop() + b.gsubrsBias;
              (D = b.gsubrs[D]) && g(D);
              break;
            case 30:
              for (; 0 < p.length && (k = y, l = x + p.shift(), m = k + p.shift(), n = l + p.shift(), y = m + p.shift(), x = n + (1 === p.length ? p.shift() : 0), q.curveTo(k, l, m, n, y, x), 0 !== p.length);) {
                k = y + p.shift(), l = x, m = k + p.shift(), n = l + p.shift(), x = n + p.shift(), y = m + (1 === p.length ? p.shift() : 0), q.curveTo(k, l, m, n, y, x);
              }
              break;
            case 31:
              for (; 0 < p.length && (k = y + p.shift(), l = x, m = k + p.shift(), n = l + p.shift(), x = n + p.shift(), y = m + (1 === p.length ? p.shift() : 0), q.curveTo(k, l, m, n, y, x), 0 !== p.length);) {
                k = y, l = x + p.shift(), m = k + p.shift(), n = l + p.shift(), y = m + p.shift(), x = n + (1 === p.length ? p.shift() : 0), q.curveTo(k, l, m, n, y, x);
              }
              break;
            default:
              32 > D ? console.log("Glyph " + c.index + ": unknown operator " + D) : 247 > D ? p.push(D - 139) : 251 > D ? (z = d[K], K += 1, p.push(256 * (D - 247) + z + 108)) : 255 > D ? (z = d[K], K += 1, p.push(256 * -(D - 251) - z - 108)) : (z = d[K], A = d[K + 1], B = d[K + 2], C = d[K + 3], K += 4, p.push((z << 24 | A << 16 | B << 8 | C) / 65536));
          }
        }
      }
      var k, l, m, n, q = new z.Path, p = [], u = 0, t = !1, w = b.defaultWidthX, v = !1, y = 0, x = 0;
      return g(d), c.advanceWidth = w, q;
    }
    function d(b) {
      return 1240 > b.length ? 107 : 33900 > b.length ? 1131 : 32768;
    }
    function l(b, c) {
      var d, e = x.cffStandardStrings.indexOf(b);
      return e = c.indexOf(b), 0 <= e ? d = e + x.cffStandardStrings.length : (d = x.cffStandardStrings.length + c.length, c.push(b)), d;
    }
    function u(b, c, d) {
      for (var f = {}, g = 0; g < b.length; g += 1) {
        var k = b[g], m = c[k.name];
        void 0 === m || e(m, k.value) || ("SID" === k.type && (m = l(m, d)), f[k.op] = {name:k.name, type:k.type, value:m});
      }
      return f;
    }
    function w(b, c) {
      var d = new C.Record("Top DICT", [{name:"dict", type:"DICT", value:{}}]);
      return d.dict = u(A, b, c), d;
    }
    function y(b) {
      var c = new C.Record("Top DICT INDEX", [{name:"topDicts", type:"INDEX", value:[]}]);
      return c.topDicts = [{name:"topDict_0", type:"TABLE", value:b}], c;
    }
    var x = c("../encoding"), q = c("../glyphset"), v = c("../parse"), z = c("../path"), C = c("../table"), A = [{name:"version", op:0, type:"SID"}, {name:"notice", op:1, type:"SID"}, {name:"copyright", op:1200, type:"SID"}, {name:"fullName", op:2, type:"SID"}, {name:"familyName", op:3, type:"SID"}, {name:"weight", op:4, type:"SID"}, {name:"isFixedPitch", op:1201, type:"number", value:0}, {name:"italicAngle", op:1202, type:"number", value:0}, {name:"underlinePosition", op:1203, type:"number", value:-100}, 
    {name:"underlineThickness", op:1204, type:"number", value:50}, {name:"paintType", op:1205, type:"number", value:0}, {name:"charstringType", op:1206, type:"number", value:2}, {name:"fontMatrix", op:1207, type:"real real real real real real".split(" "), value:[.001, 0, 0, .001, 0, 0]}, {name:"uniqueId", op:13, type:"number"}, {name:"fontBBox", op:5, type:["number", "number", "number", "number"], value:[0, 0, 0, 0]}, {name:"strokeWidth", op:1208, type:"number", value:0}, {name:"xuid", op:14, type:[], 
    value:null}, {name:"charset", op:15, type:"offset", value:0}, {name:"encoding", op:16, type:"offset", value:0}, {name:"charStrings", op:17, type:"offset", value:0}, {name:"private", op:18, type:["number", "offset"], value:[0, 0]}], D = [{name:"subrs", op:19, type:"offset", value:0}, {name:"defaultWidthX", op:20, type:"number", value:0}, {name:"nominalWidthX", op:21, type:"number", value:0}];
    b.parse = function(b, c, e) {
      e.tables.cff = {};
      var g = {};
      g = (g.formatMajor = v.getCard8(b, c), g.formatMinor = v.getCard8(b, c + 1), g.size = v.getCard8(b, c + 2), g.offsetSize = v.getCard8(b, c + 3), g.startOffset = c, g.endOffset = c + 4, g);
      g = f(b, g.endOffset, v.bytesToString);
      g = f(b, g.endOffset);
      var k = f(b, g.endOffset, v.bytesToString), l = f(b, k.endOffset);
      e.gsubrs = l.objects;
      e.gsubrsBias = d(e.gsubrs);
      l = new DataView((new Uint8Array(g.objects[0])).buffer);
      g = k.objects;
      l = n(l, 0, l.byteLength);
      l = m(l, A, g);
      e.tables.cff.topDict = l;
      g = c + l["private"][1];
      var u = k.objects;
      var w = n(b, g, l["private"][0]);
      u = m(w, D, u);
      (e.defaultWidthX = u.defaultWidthX, e.nominalWidthX = u.nominalWidthX, 0 !== u.subrs) ? (g = f(b, g + u.subrs), e.subrs = g.objects, e.subrsBias = d(e.subrs)) : (e.subrs = [], e.subrsBias = 0);
      g = f(b, c + l.charStrings);
      e.nGlyphs = g.objects.length;
      u = e.nGlyphs;
      w = k.objects;
      var y = new v.Parser(b, c + l.charset);
      --u;
      k = [".notdef"];
      var z = y.parseCard8();
      if (0 === z) {
        for (z = 0; u > z; z += 1) {
          var B = y.parseSID();
          k.push(p(w, B));
        }
      } else {
        if (1 === z) {
          for (; k.length <= u;) {
            B = y.parseSID();
            var C = y.parseCard8();
            for (z = 0; C >= z; z += 1) {
              k.push(p(w, B)), B += 1;
            }
          }
        } else {
          if (2 !== z) {
            throw Error("Unknown charset format " + z);
          }
          for (; k.length <= u;) {
            for (B = y.parseSID(), C = y.parseCard16(), z = 0; C >= z; z += 1) {
              k.push(p(w, B)), B += 1;
            }
          }
        }
      }
      if (0 === l.encoding) {
        b = new x.CffEncoding(x.cffStandardEncoding, k);
      } else {
        if (1 === l.encoding) {
          b = new x.CffEncoding(x.cffExpertEncoding, k);
        } else {
          u = {};
          b = new v.Parser(b, c + l.encoding);
          c = b.parseCard8();
          if (0 === c) {
            for (w = b.parseCard8(), c = 0; w > c; c += 1) {
              l = b.parseCard8(), u[l] = c;
            }
          } else {
            if (1 !== c) {
              throw Error("Unknown encoding format " + c);
            }
            w = b.parseCard8();
            l = 1;
            for (c = 0; w > c; c += 1) {
              for (y = b.parseCard8(), z = b.parseCard8(), B = y; y + z >= B; B += 1) {
                u[B] = l, l += 1;
              }
            }
          }
          b = new x.CffEncoding(u, k);
        }
      }
      e.cffEncoding = b;
      e.encoding = e.encoding || e.cffEncoding;
      e.glyphs = new q.GlyphSet(e);
      for (b = 0; b < e.nGlyphs; b += 1) {
        e.glyphs.push(b, q.cffGlyphLoader(e, b, t, g.objects[b]));
      }
    };
    b.make = function(b, c) {
      var d = new C.Table("CFF ", [{name:"header", type:"RECORD"}, {name:"nameIndex", type:"RECORD"}, {name:"topDictIndex", type:"RECORD"}, {name:"stringIndex", type:"RECORD"}, {name:"globalSubrIndex", type:"RECORD"}, {name:"charsets", type:"RECORD"}, {name:"charStringsIndex", type:"RECORD"}, {name:"privateDict", type:"RECORD"}]), e = 1 / c.unitsPerEm;
      e = {version:c.version, fullName:c.fullName, familyName:c.familyName, weight:c.weightName, fontBBox:c.fontBBox || [0, 0, 0, 0], fontMatrix:[e, 0, 0, e, 0, 0], charset:999, encoding:0, charStrings:999, "private":[0, 999]};
      for (var f = [], g = 1; g < b.length; g += 1) {
        var k = b.get(g);
        f.push(k.name);
      }
      k = [];
      d.header = new C.Record("Header", [{name:"major", type:"Card8", value:1}, {name:"minor", type:"Card8", value:0}, {name:"hdrSize", type:"Card8", value:4}, {name:"major", type:"Card8", value:1}]);
      c = [c.postScriptName];
      g = new C.Record("Name INDEX", [{name:"names", type:"INDEX", value:[]}]);
      g.names = [];
      for (var m = 0; m < c.length; m += 1) {
        g.names.push({name:"name_" + m, type:"NAME", value:c[m]});
      }
      d.nameIndex = g;
      c = w(e, k);
      d.topDictIndex = y(c);
      d.globalSubrIndex = new C.Record("Global Subr INDEX", [{name:"subrs", type:"INDEX", value:[]}]);
      g = new C.Record("Charsets", [{name:"format", type:"Card8", value:0}]);
      for (m = 0; m < f.length; m += 1) {
        var n = l(f[m], k);
        g.fields.push({name:"glyph_" + m, type:"SID", value:n});
      }
      d.charsets = g;
      f = new C.Record("CharStrings INDEX", [{name:"charStrings", type:"INDEX", value:[]}]);
      for (g = 0; g < b.length; g += 1) {
        m = b.get(g);
        n = [];
        var p = m.path;
        n.push({name:"width", type:"NUMBER", value:m.advanceWidth});
        for (var q = 0, t = 0, v = 0; v < p.commands.length; v += 1) {
          var x = p.commands[v];
          if ("Q" === x.type) {
            var z = 1 / 3, A = 2 / 3;
            x = {type:"C", x:x.x, y:x.y, x1:z * q + A * x.x1, y1:z * t + A * x.y1, x2:z * x.x + A * x.x1, y2:z * x.y + A * x.y1};
          }
          if ("M" === x.type) {
            q = Math.round(x.x - q), t = Math.round(x.y - t), n.push({name:"dx", type:"NUMBER", value:q}), n.push({name:"dy", type:"NUMBER", value:t}), n.push({name:"rmoveto", type:"OP", value:21}), q = Math.round(x.x), t = Math.round(x.y);
          } else {
            if ("L" === x.type) {
              q = Math.round(x.x - q), t = Math.round(x.y - t), n.push({name:"dx", type:"NUMBER", value:q}), n.push({name:"dy", type:"NUMBER", value:t}), n.push({name:"rlineto", type:"OP", value:5}), q = Math.round(x.x), t = Math.round(x.y);
            } else {
              if ("C" === x.type) {
                z = Math.round(x.x1 - q);
                A = Math.round(x.y1 - t);
                var B = Math.round(x.x2 - x.x1), E = Math.round(x.y2 - x.y1);
                q = Math.round(x.x - x.x2);
                t = Math.round(x.y - x.y2);
                n.push({name:"dx1", type:"NUMBER", value:z});
                n.push({name:"dy1", type:"NUMBER", value:A});
                n.push({name:"dx2", type:"NUMBER", value:B});
                n.push({name:"dy2", type:"NUMBER", value:E});
                n.push({name:"dx", type:"NUMBER", value:q});
                n.push({name:"dy", type:"NUMBER", value:t});
                n.push({name:"rrcurveto", type:"OP", value:8});
                q = Math.round(x.x);
                t = Math.round(x.y);
              }
            }
          }
        }
        n = (n.push({name:"endchar", type:"OP", value:14}), n);
        f.charStrings.push({name:m.name, type:"CHARSTRING", value:n});
      }
      d.charStringsIndex = f;
      b = new C.Record("Private DICT", [{name:"dict", type:"DICT", value:{}}]);
      b = (b.dict = u(D, {}, k), b);
      d.privateDict = b;
      b = new C.Record("String INDEX", [{name:"strings", type:"INDEX", value:[]}]);
      b.strings = [];
      for (f = 0; f < k.length; f += 1) {
        b.strings.push({name:"string_" + f, type:"STRING", value:k[f]});
      }
      d.stringIndex = b;
      b = d.header.sizeOf() + d.nameIndex.sizeOf() + d.topDictIndex.sizeOf() + d.stringIndex.sizeOf() + d.globalSubrIndex.sizeOf();
      return e.charset = b, e.encoding = 0, e.charStrings = e.charset + d.charsets.sizeOf(), e.private[1] = e.charStrings + d.charStringsIndex.sizeOf(), c = w(e, k), d.topDictIndex = y(c), d;
    };
  }, {"../encoding":4, "../glyphset":7, "../parse":10, "../path":11, "../table":13}], 15:[function(c, g, b) {
    function e(b, c, e) {
      b.segments.push({end:c, start:c, delta:-(c - e), offset:0});
    }
    var f = c("../check"), k = c("../parse"), n = c("../table");
    b.parse = function(b, c) {
      var e, d = {};
      d.version = k.getUShort(b, c);
      f.argument(0 === d.version, "cmap table version should be 0.");
      d.numTables = k.getUShort(b, c + 2);
      var g = -1;
      for (e = d.numTables - 1; 0 <= e; --e) {
        var m = k.getUShort(b, c + 4 + 8 * e), n = k.getUShort(b, c + 4 + 8 * e + 2);
        if (3 === m && (0 === n || 1 === n || 10 === n)) {
          g = k.getULong(b, c + 4 + 8 * e + 4);
          break;
        }
      }
      if (-1 === g) {
        return null;
      }
      e = new k.Parser(b, c + g);
      if (d.format = e.parseUShort(), 12 === d.format) {
        e.parseUShort();
        d.length = e.parseULong();
        d.language = e.parseULong();
        var p;
        d.groupCount = p = e.parseULong();
        d.glyphIndexMap = {};
        for (b = 0; p > b; b += 1) {
          for (n = e.parseULong(), g = e.parseULong(), m = e.parseULong(); g >= n; n += 1) {
            d.glyphIndexMap[n] = m, m++;
          }
        }
      } else {
        if (4 !== d.format) {
          throw Error("Only format 4 and 12 cmap tables are supported.");
        }
        var x = g;
        d.length = e.parseUShort();
        d.language = e.parseUShort();
        d.segCount = g = e.parseUShort() >> 1;
        e.skip("uShort", 3);
        d.glyphIndexMap = {};
        e = new k.Parser(b, c + x + 14);
        m = new k.Parser(b, c + x + 16 + 2 * g);
        n = new k.Parser(b, c + x + 16 + 4 * g);
        var q = new k.Parser(b, c + x + 16 + 6 * g);
        x = c + x + 16 + 8 * g;
        for (c = 0; g - 1 > c; c += 1) {
          for (var v = e.parseUShort(), z = m.parseUShort(), C = n.parseShort(), A = q.parseUShort(), D = z; v >= D; D += 1) {
            0 !== A ? (x = q.offset + q.relativeOffset - 2, x += A, x += 2 * (D - z), p = k.getUShort(b, x), 0 !== p && (p = p + C & 65535)) : p = D + C & 65535, d.glyphIndexMap[D] = p;
          }
        }
      }
      return d;
    };
    b.make = function(b) {
      var c, f = new n.Table("cmap", [{name:"version", type:"USHORT", value:0}, {name:"numTables", type:"USHORT", value:1}, {name:"platformID", type:"USHORT", value:3}, {name:"encodingID", type:"USHORT", value:1}, {name:"offset", type:"ULONG", value:12}, {name:"format", type:"USHORT", value:4}, {name:"length", type:"USHORT", value:0}, {name:"language", type:"USHORT", value:0}, {name:"segCountX2", type:"USHORT", value:0}, {name:"searchRange", type:"USHORT", value:0}, {name:"entrySelector", type:"USHORT", 
      value:0}, {name:"rangeShift", type:"USHORT", value:0}]);
      f.segments = [];
      for (c = 0; c < b.length; c += 1) {
        for (var d = b.get(c), g = 0; g < d.unicodes.length; g += 1) {
          e(f, d.unicodes[g], c);
        }
        f.segments = f.segments.sort(function(b, c) {
          return b.start - c.start;
        });
      }
      f.segments.push({end:65535, start:65535, delta:1, offset:0});
      b = f.segments.length;
      f.segCountX2 = 2 * b;
      f.searchRange = 2 * Math.pow(2, Math.floor(Math.log(b) / Math.log(2)));
      f.entrySelector = Math.log(f.searchRange / 2) / Math.log(2);
      f.rangeShift = f.segCountX2 - f.searchRange;
      d = [];
      g = [];
      var k = [], p = [], y = [];
      for (c = 0; b > c; c += 1) {
        var x = f.segments[c];
        d = d.concat({name:"end_" + c, type:"USHORT", value:x.end});
        g = g.concat({name:"start_" + c, type:"USHORT", value:x.start});
        k = k.concat({name:"idDelta_" + c, type:"SHORT", value:x.delta});
        p = p.concat({name:"idRangeOffset_" + c, type:"USHORT", value:x.offset});
        void 0 !== x.glyphId && (y = y.concat({name:"glyph_" + c, type:"USHORT", value:x.glyphId}));
      }
      return f.fields = f.fields.concat(d), f.fields.push({name:"reservedPad", type:"USHORT", value:0}), f.fields = f.fields.concat(g), f.fields = f.fields.concat(k), f.fields = f.fields.concat(p), f.fields = f.fields.concat(y), f.length = 2 * d.length + 16 + 2 * g.length + 2 * k.length + 2 * p.length + 2 * y.length, f;
    };
  }, {"../check":2, "../parse":10, "../table":13}], 16:[function(c, g, b) {
    function e(b, c) {
      var d = JSON.stringify(b), e = 256, f;
      for (f in c) {
        var g = parseInt(f);
        if (g && !(256 > g)) {
          if (JSON.stringify(c[f]) === d) {
            return g;
          }
          g >= e && (e = g + 1);
        }
      }
      return c[e] = b, e;
    }
    function f(b, c, d) {
      d = e(c.name, d);
      return [{name:"tag_" + b, type:"TAG", value:c.tag}, {name:"minValue_" + b, type:"FIXED", value:c.minValue << 16}, {name:"defaultValue_" + b, type:"FIXED", value:c.defaultValue << 16}, {name:"maxValue_" + b, type:"FIXED", value:c.maxValue << 16}, {name:"flags_" + b, type:"USHORT", value:0}, {name:"nameID_" + b, type:"USHORT", value:d}];
    }
    function k(b, c, d) {
      var e = {};
      b = new t.Parser(b, c);
      return e.tag = b.parseTag(), e.minValue = b.parseFixed(), e.defaultValue = b.parseFixed(), e.maxValue = b.parseFixed(), b.skip("uShort", 1), e.name = d[b.parseUShort()] || {}, e;
    }
    function n(b, c, d, f) {
      f = e(c.name, f);
      f = [{name:"nameID_" + b, type:"USHORT", value:f}, {name:"flags_" + b, type:"USHORT", value:0}];
      for (var g = 0; g < d.length; ++g) {
        var k = d[g].tag;
        f.push({name:"axis_" + b + " " + k, type:"FIXED", value:c.coordinates[k] << 16});
      }
      return f;
    }
    function p(b, c, d, e) {
      var f = {};
      b = new t.Parser(b, c);
      f.name = e[b.parseUShort()] || {};
      b.skip("uShort", 1);
      f.coordinates = {};
      for (e = 0; e < d.length; ++e) {
        f.coordinates[d[e].tag] = b.parseFixed();
      }
      return f;
    }
    var m = c("../check"), t = c("../parse"), d = c("../table");
    b.make = function(b, c) {
      var e = new d.Table("fvar", [{name:"version", type:"ULONG", value:65536}, {name:"offsetToData", type:"USHORT", value:0}, {name:"countSizePairs", type:"USHORT", value:2}, {name:"axisCount", type:"USHORT", value:b.axes.length}, {name:"axisSize", type:"USHORT", value:20}, {name:"instanceCount", type:"USHORT", value:b.instances.length}, {name:"instanceSize", type:"USHORT", value:4 + 4 * b.axes.length}]);
      e.offsetToData = e.sizeOf();
      for (var g = 0; g < b.axes.length; g++) {
        e.fields = e.fields.concat(f(g, b.axes[g], c));
      }
      for (g = 0; g < b.instances.length; g++) {
        e.fields = e.fields.concat(n(g, b.instances[g], b.axes, c));
      }
      return e;
    };
    b.parse = function(b, c, d) {
      var e = new t.Parser(b, c), f = e.parseULong();
      m.argument(65536 === f, "Unsupported fvar table version.");
      var g = e.parseOffset16();
      e.skip("uShort", 1);
      var l = e.parseUShort(), n = e.parseUShort();
      f = e.parseUShort();
      e = e.parseUShort();
      for (var u = [], w = 0; l > w; w++) {
        u.push(k(b, c + g + w * n, d));
      }
      w = [];
      c = c + g + l * n;
      for (g = 0; f > g; g++) {
        w.push(p(b, c + g * e, u, d));
      }
      return {axes:u, instances:w};
    };
  }, {"../check":2, "../parse":10, "../table":13}], 17:[function(c, g, b) {
    function e(b, c, d, e, f) {
      var g;
      return 0 < (c & e) ? (g = b.parseByte(), 0 === (c & f) && (g = -g), g = d + g) : g = 0 < (c & f) ? d : d + b.parseShort(), g;
    }
    function f(b, c, d) {
      c = new t.Parser(c, d);
      b.numberOfContours = c.parseShort();
      b._xMin = c.parseShort();
      b._yMin = c.parseShort();
      b._xMax = c.parseShort();
      b._yMax = c.parseShort();
      var f;
      if (0 < b.numberOfContours) {
        var g, k = b.endPointIndices = [];
        for (g = 0; g < b.numberOfContours; g += 1) {
          k.push(c.parseUShort());
        }
        b.instructionLength = c.parseUShort();
        b.instructions = [];
        for (g = 0; g < b.instructionLength; g += 1) {
          b.instructions.push(c.parseByte());
        }
        var l = k[k.length - 1] + 1;
        d = [];
        for (g = 0; l > g; g += 1) {
          if (f = c.parseByte(), d.push(f), 0 < (8 & f)) {
            for (var m = c.parseByte(), n = 0; m > n; n += 1) {
              d.push(f), g += 1;
            }
          }
        }
        if (p.argument(d.length === l, "Bad flags."), 0 < k.length) {
          n = [];
          if (0 < l) {
            for (g = 0; l > g; g += 1) {
              f = d[g], m = {}, m.onCurve = !!(1 & f), m.lastPointOfContour = 0 <= k.indexOf(g), n.push(m);
            }
            for (g = k = 0; l > g; g += 1) {
              f = d[g], m = n[g], m.x = e(c, f, k, 2, 16), k = m.x;
            }
            for (g = k = 0; l > g; g += 1) {
              f = d[g], m = n[g], m.y = e(c, f, k, 4, 32), k = m.y;
            }
          }
          b.points = n;
        } else {
          b.points = [];
        }
      } else {
        if (0 === b.numberOfContours) {
          b.points = [];
        } else {
          for (b.isComposite = !0, b.points = [], b.components = [], f = !0; f;) {
            d = c.parseUShort(), f = {glyphIndex:c.parseUShort(), xScale:1, scale01:0, scale10:0, yScale:1, dx:0, dy:0}, 0 < (1 & d) ? 0 < (2 & d) ? (f.dx = c.parseShort(), f.dy = c.parseShort()) : f.matchedPoints = [c.parseUShort(), c.parseUShort()] : 0 < (2 & d) ? (f.dx = c.parseChar(), f.dy = c.parseChar()) : f.matchedPoints = [c.parseByte(), c.parseByte()], 0 < (8 & d) ? f.xScale = f.yScale = c.parseF2Dot14() : 0 < (64 & d) ? (f.xScale = c.parseF2Dot14(), f.yScale = c.parseF2Dot14()) : 0 < (128 & 
            d) && (f.xScale = c.parseF2Dot14(), f.scale01 = c.parseF2Dot14(), f.scale10 = c.parseF2Dot14(), f.yScale = c.parseF2Dot14()), b.components.push(f), f = !!(32 & d);
          }
        }
      }
    }
    function k(b, c) {
      for (var d = [], e = 0; e < b.length; e += 1) {
        var f = b[e];
        d.push({x:c.xScale * f.x + c.scale01 * f.y + c.dx, y:c.scale10 * f.x + c.yScale * f.y + c.dy, onCurve:f.onCurve, lastPointOfContour:f.lastPointOfContour});
      }
      return d;
    }
    function n(b, c) {
      if (c.isComposite) {
        for (var e = 0; e < c.components.length; e += 1) {
          var f = c.components[e], g = b.get(f.glyphIndex);
          if (g.getPath(), g.points) {
            if (void 0 === f.matchedPoints) {
              g = k(g.points, f);
            } else {
              if (f.matchedPoints[0] > c.points.length - 1 || f.matchedPoints[1] > g.points.length - 1) {
                throw Error("Matched points out of range in " + c.name);
              }
              var l = c.points[f.matchedPoints[0]], m = g.points[f.matchedPoints[1]];
              f = {xScale:f.xScale, scale01:f.scale01, scale10:f.scale10, yScale:f.yScale, dx:0, dy:0};
              m = k([m], f)[0];
              f.dx = l.x - m.x;
              f.dy = l.y - m.y;
              g = k(g.points, f);
            }
            c.points = c.points.concat(g);
          }
        }
      }
      var n;
      c = c.points;
      b = new d.Path;
      if (c) {
        e = [];
        g = [];
        for (l = 0; l < c.length; l += 1) {
          m = c[l], g.push(m), m.lastPointOfContour && (e.push(g), g = []);
        }
        c = (p.argument(0 === g.length, "There are still points left in the current contour."), e);
        for (e = 0; e < c.length; e += 1) {
          var u;
          g = c[e];
          l = g[0];
          m = g[g.length - 1];
          l.onCurve ? (n = null, u = !0) : (l = m.onCurve ? m : {x:(l.x + m.x) / 2, y:(l.y + m.y) / 2}, n = l, u = !1);
          b.moveTo(l.x, l.y);
          for (f = u ? 1 : 0; f < g.length; f += 1) {
            var t = g[f], D = 0 === f ? l : g[f - 1];
            if (D.onCurve && t.onCurve) {
              b.lineTo(t.x, t.y);
            } else {
              if (D.onCurve && !t.onCurve) {
                n = t;
              } else {
                if (D.onCurve || t.onCurve) {
                  if (D.onCurve || !t.onCurve) {
                    throw Error("Invalid state.");
                  }
                  b.quadraticCurveTo(n.x, n.y, t.x, t.y);
                  n = null;
                } else {
                  b.quadraticCurveTo(D.x, D.y, (D.x + t.x) / 2, (D.y + t.y) / 2), n = t;
                }
              }
            }
          }
          l !== m && (n ? b.quadraticCurveTo(n.x, n.y, l.x, l.y) : b.lineTo(l.x, l.y));
        }
        n = (b.closePath(), b);
      } else {
        n = b;
      }
      return n;
    }
    var p = c("../check"), m = c("../glyphset"), t = c("../parse"), d = c("../path");
    b.parse = function(b, c, d, e) {
      var g, k = new m.GlyphSet(e);
      for (g = 0; g < d.length - 1; g += 1) {
        var l = d[g];
        l !== d[g + 1] ? k.push(g, m.ttfGlyphLoader(e, g, f, b, c + l, n)) : k.push(g, m.glyphLoader(e, g));
      }
      return k;
    };
  }, {"../check":2, "../glyphset":7, "../parse":10, "../path":11}], 18:[function(c, g, b) {
    function e(b, c) {
      b = new t.Parser(b, c);
      c = b.parseUShort();
      for (var d = [], e = 0; c > e; e++) {
        d[b.parseTag()] = {offset:b.parseUShort()};
      }
      return d;
    }
    function f(b, c) {
      b = new t.Parser(b, c);
      var d = b.parseUShort();
      c = b.parseUShort();
      if (1 === d) {
        return b.parseUShortList(c);
      }
      if (2 === d) {
        for (d = []; c--;) {
          for (var e = b.parseUShort(), f = b.parseUShort(), g = b.parseUShort(); f >= e; e++) {
            d[g++] = e;
          }
        }
        return d;
      }
    }
    function k(b, c) {
      b = new t.Parser(b, c);
      c = b.parseUShort();
      if (1 === c) {
        var d = b.parseUShort();
        c = b.parseUShort();
        var e = b.parseUShortList(c);
        return function(b) {
          return e[b - d] || 0;
        };
      }
      if (2 === c) {
        c = b.parseUShort();
        for (var f = [], g = [], k = [], l = 0; c > l; l++) {
          f[l] = b.parseUShort(), g[l] = b.parseUShort(), k[l] = b.parseUShort();
        }
        return function(b) {
          for (var c = 0, d = f.length - 1; d > c;) {
            var e = c + d + 1 >> 1;
            b < f[e] ? d = e - 1 : c = e;
          }
          return f[c] <= b && b <= g[c] ? k[c] || 0 : 0;
        };
      }
    }
    function n(b, c) {
      var d, e = new t.Parser(b, c), g = e.parseUShort(), l = e.parseUShort();
      l = f(b, c + l);
      var m = e.parseUShort(), n = e.parseUShort();
      if (4 === m && 0 === n) {
        var p = {};
        if (1 === g) {
          b = e.parseUShort();
          var C = [];
          c = e.parseOffset16List(b);
          for (g = 0; b > g; g++) {
            var A = c[g], D = p[A];
            if (!D) {
              for (D = {}, e.relativeOffset = A, A = e.parseUShort(); A--;) {
                var E = e.parseUShort();
                m && (d = e.parseShort());
                n && e.parseShort();
                D[E] = d;
              }
            }
            C[l[g]] = D;
          }
          return function(b, c) {
            return (b = C[b]) ? b[c] : void 0;
          };
        }
        if (2 === g) {
          D = e.parseUShort();
          A = e.parseUShort();
          p = e.parseUShort();
          g = e.parseUShort();
          var B = k(b, c + D), G = k(b, c + A), H = [];
          for (b = 0; p > b; b++) {
            for (c = H[b] = [], D = 0; g > D; D++) {
              m && (d = e.parseShort()), n && e.parseShort(), c[D] = d;
            }
          }
          var K = {};
          for (b = 0; b < l.length; b++) {
            K[l[b]] = 1;
          }
          return function(b, c) {
            if (K[b]) {
              return b = B(b), c = G(c), (b = H[b]) ? b[c] : void 0;
            }
          };
        }
      }
    }
    function p(b, c) {
      var d = new t.Parser(b, c), e = d.parseUShort(), f = d.parseUShort(), g = 16 & f, k = d.parseUShort(), l = d.parseOffset16List(k);
      d = {lookupType:e, lookupFlag:f, markFilteringSet:g ? d.parseUShort() : -1};
      if (2 === e) {
        var m = [];
        for (e = 0; k > e; e++) {
          m.push(n(b, c + l[e]));
        }
        d.getKerningValue = function(b, c) {
          for (var d = m.length; d--;) {
            var e = m[d](b, c);
            if (void 0 !== e) {
              return e;
            }
          }
          return 0;
        };
      }
      return d;
    }
    var m = c("../check"), t = c("../parse");
    b.parse = function(b, c, f) {
      var d = new t.Parser(b, c), g = d.parseFixed();
      m.argument(1 === g, "Unsupported GPOS table version.");
      e(b, c + d.parseUShort());
      e(b, c + d.parseUShort());
      var k = d.parseUShort();
      d.relativeOffset = k;
      g = d.parseUShort();
      d = d.parseOffset16List(g);
      c += k;
      for (k = 0; g > k; k++) {
        var l = p(b, c + d[k]);
        2 !== l.lookupType || f.getGposKerningValue || (f.getGposKerningValue = l.getKerningValue);
      }
    };
  }, {"../check":2, "../parse":10}], 19:[function(c, g, b) {
    var e = c("../check"), f = c("../parse").Parser, k = Array(9), n = c("../table");
    k[1] = function() {
      var b = this.offset + this.relativeOffset, c = this.parseUShort();
      return 1 === c ? {substFormat:1, coverage:this.parsePointer(f.coverage), deltaGlyphId:this.parseUShort()} : 2 === c ? {substFormat:2, coverage:this.parsePointer(f.coverage), substitute:this.parseOffset16List()} : void e.assert(!1, "0x" + b.toString(16) + ": lookup type 1 format must be 1 or 2.");
    };
    k[2] = function() {
      var b = this.parseUShort();
      return e.argument(1 === b, "GSUB Multiple Substitution Subtable identifier-format must be 1"), {substFormat:b, coverage:this.parsePointer(f.coverage), sequences:this.parseListOfLists()};
    };
    k[3] = function() {
      var b = this.parseUShort();
      return e.argument(1 === b, "GSUB Alternate Substitution Subtable identifier-format must be 1"), {substFormat:b, coverage:this.parsePointer(f.coverage), alternateSets:this.parseListOfLists()};
    };
    k[4] = function() {
      var b = this.parseUShort();
      return e.argument(1 === b, "GSUB ligature table identifier-format must be 1"), {substFormat:b, coverage:this.parsePointer(f.coverage), ligatureSets:this.parseListOfLists(function() {
        return {ligGlyph:this.parseUShort(), components:this.parseUShortList(this.parseUShort() - 1)};
      })};
    };
    var p = {sequenceIndex:f.uShort, lookupListIndex:f.uShort};
    k[5] = function() {
      var b = this.offset + this.relativeOffset, c = this.parseUShort();
      if (1 === c) {
        return {substFormat:c, coverage:this.parsePointer(f.coverage), ruleSets:this.parseListOfLists(function() {
          var b = this.parseUShort(), c = this.parseUShort();
          return {input:this.parseUShortList(b - 1), lookupRecords:this.parseRecordList(c, p)};
        })};
      }
      if (2 === c) {
        return {substFormat:c, coverage:this.parsePointer(f.coverage), classDef:this.parsePointer(f.classDef), classSets:this.parseListOfLists(function() {
          var b = this.parseUShort(), c = this.parseUShort();
          return {classes:this.parseUShortList(b - 1), lookupRecords:this.parseRecordList(c, p)};
        })};
      }
      if (3 === c) {
        b = this.parseUShort();
        var g = this.parseUShort();
        return {substFormat:c, coverages:this.parseList(b, f.pointer(f.coverage)), lookupRecords:this.parseRecordList(g, p)};
      }
      e.assert(!1, "0x" + b.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
    };
    k[6] = function() {
      var b = this.offset + this.relativeOffset, c = this.parseUShort();
      return 1 === c ? {substFormat:1, coverage:this.parsePointer(f.coverage), chainRuleSets:this.parseListOfLists(function() {
        return {backtrack:this.parseUShortList(), input:this.parseUShortList(this.parseShort() - 1), lookahead:this.parseUShortList(), lookupRecords:this.parseRecordList(p)};
      })} : 2 === c ? {substFormat:2, coverage:this.parsePointer(f.coverage), backtrackClassDef:this.parsePointer(f.classDef), inputClassDef:this.parsePointer(f.classDef), lookaheadClassDef:this.parsePointer(f.classDef), chainClassSet:this.parseListOfLists(function() {
        return {backtrack:this.parseUShortList(), input:this.parseUShortList(this.parseShort() - 1), lookahead:this.parseUShortList(), lookupRecords:this.parseRecordList(p)};
      })} : 3 === c ? {substFormat:3, backtrackCoverage:this.parseList(f.pointer(f.coverage)), inputCoverage:this.parseList(f.pointer(f.coverage)), lookaheadCoverage:this.parseList(f.pointer(f.coverage)), lookupRecords:this.parseRecordList(p)} : void e.assert(!1, "0x" + b.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
    };
    k[7] = function() {
      var b = this.parseUShort();
      e.argument(1 === b, "GSUB Extension Substitution subtable identifier-format must be 1");
      b = this.parseUShort();
      var c = new f(this.data, this.offset + this.parseULong());
      return {substFormat:1, lookupType:b, extension:k[b].call(c)};
    };
    k[8] = function() {
      var b = this.parseUShort();
      return e.argument(1 === b, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), {substFormat:b, coverage:this.parsePointer(f.coverage), backtrackCoverage:this.parseList(f.pointer(f.coverage)), lookaheadCoverage:this.parseList(f.pointer(f.coverage)), substitutes:this.parseUShortList()};
    };
    var m = Array(9);
    m[1] = function(b) {
      return 1 === b.substFormat ? new n.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:1}, {name:"coverage", type:"TABLE", value:new n.Coverage(b.coverage)}, {name:"deltaGlyphID", type:"USHORT", value:b.deltaGlyphId}]) : new n.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:2}, {name:"coverage", type:"TABLE", value:new n.Coverage(b.coverage)}].concat(n.ushortList("substitute", b.substitute)));
    };
    m[3] = function(b) {
      return e.assert(1 === b.substFormat, "Lookup type 3 substFormat must be 1."), new n.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:1}, {name:"coverage", type:"TABLE", value:new n.Coverage(b.coverage)}].concat(n.tableList("altSet", b.alternateSets, function(b) {
        return new n.Table("alternateSetTable", n.ushortList("alternate", b));
      })));
    };
    m[4] = function(b) {
      return e.assert(1 === b.substFormat, "Lookup type 4 substFormat must be 1."), new n.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:1}, {name:"coverage", type:"TABLE", value:new n.Coverage(b.coverage)}].concat(n.tableList("ligSet", b.ligatureSets, function(b) {
        return new n.Table("ligatureSetTable", n.tableList("ligature", b, function(b) {
          return new n.Table("ligatureTable", [{name:"ligGlyph", type:"USHORT", value:b.ligGlyph}].concat(n.ushortList("component", b.components, b.components.length + 1)));
        }));
      })));
    };
    b.parse = function(b, c) {
      b = new f(b, c || 0);
      c = b.parseVersion();
      return e.argument(1 === c, "Unsupported GSUB table version."), {version:c, scripts:b.parseScriptList(), features:b.parseFeatureList(), lookups:b.parseLookupList(k)};
    };
    b.make = function(b) {
      return new n.Table("GSUB", [{name:"version", type:"ULONG", value:65536}, {name:"scripts", type:"TABLE", value:new n.ScriptList(b.scripts)}, {name:"features", type:"TABLE", value:new n.FeatureList(b.features)}, {name:"lookups", type:"TABLE", value:new n.LookupList(b.lookups, m)}]);
    };
  }, {"../check":2, "../parse":10, "../table":13}], 20:[function(c, g, b) {
    var e = c("../check"), f = c("../parse"), k = c("../table");
    b.parse = function(b, c) {
      var g = {};
      b = new f.Parser(b, c);
      return g.version = b.parseVersion(), g.fontRevision = Math.round(1E3 * b.parseFixed()) / 1E3, g.checkSumAdjustment = b.parseULong(), g.magicNumber = b.parseULong(), e.argument(1594834165 === g.magicNumber, "Font header has wrong magic number."), g.flags = b.parseUShort(), g.unitsPerEm = b.parseUShort(), g.created = b.parseLongDateTime(), g.modified = b.parseLongDateTime(), g.xMin = b.parseShort(), g.yMin = b.parseShort(), g.xMax = b.parseShort(), g.yMax = b.parseShort(), g.macStyle = b.parseUShort(), 
      g.lowestRecPPEM = b.parseUShort(), g.fontDirectionHint = b.parseShort(), g.indexToLocFormat = b.parseShort(), g.glyphDataFormat = b.parseShort(), g;
    };
    b.make = function(b) {
      var c = Math.round((new Date).getTime() / 1E3) + 2082844800, e = c;
      return b.createdTimestamp && (e = b.createdTimestamp + 2082844800), new k.Table("head", [{name:"version", type:"FIXED", value:65536}, {name:"fontRevision", type:"FIXED", value:65536}, {name:"checkSumAdjustment", type:"ULONG", value:0}, {name:"magicNumber", type:"ULONG", value:1594834165}, {name:"flags", type:"USHORT", value:0}, {name:"unitsPerEm", type:"USHORT", value:1E3}, {name:"created", type:"LONGDATETIME", value:e}, {name:"modified", type:"LONGDATETIME", value:c}, {name:"xMin", type:"SHORT", 
      value:0}, {name:"yMin", type:"SHORT", value:0}, {name:"xMax", type:"SHORT", value:0}, {name:"yMax", type:"SHORT", value:0}, {name:"macStyle", type:"USHORT", value:0}, {name:"lowestRecPPEM", type:"USHORT", value:0}, {name:"fontDirectionHint", type:"SHORT", value:2}, {name:"indexToLocFormat", type:"SHORT", value:0}, {name:"glyphDataFormat", type:"SHORT", value:0}], b);
    };
  }, {"../check":2, "../parse":10, "../table":13}], 21:[function(c, g, b) {
    var e = c("../parse"), f = c("../table");
    b.parse = function(b, c) {
      var f = {};
      b = new e.Parser(b, c);
      return f.version = b.parseVersion(), f.ascender = b.parseShort(), f.descender = b.parseShort(), f.lineGap = b.parseShort(), f.advanceWidthMax = b.parseUShort(), f.minLeftSideBearing = b.parseShort(), f.minRightSideBearing = b.parseShort(), f.xMaxExtent = b.parseShort(), f.caretSlopeRise = b.parseShort(), f.caretSlopeRun = b.parseShort(), f.caretOffset = b.parseShort(), b.relativeOffset += 8, f.metricDataFormat = b.parseShort(), f.numberOfHMetrics = b.parseUShort(), f;
    };
    b.make = function(b) {
      return new f.Table("hhea", [{name:"version", type:"FIXED", value:65536}, {name:"ascender", type:"FWORD", value:0}, {name:"descender", type:"FWORD", value:0}, {name:"lineGap", type:"FWORD", value:0}, {name:"advanceWidthMax", type:"UFWORD", value:0}, {name:"minLeftSideBearing", type:"FWORD", value:0}, {name:"minRightSideBearing", type:"FWORD", value:0}, {name:"xMaxExtent", type:"FWORD", value:0}, {name:"caretSlopeRise", type:"SHORT", value:1}, {name:"caretSlopeRun", type:"SHORT", value:0}, {name:"caretOffset", 
      type:"SHORT", value:0}, {name:"reserved1", type:"SHORT", value:0}, {name:"reserved2", type:"SHORT", value:0}, {name:"reserved3", type:"SHORT", value:0}, {name:"reserved4", type:"SHORT", value:0}, {name:"metricDataFormat", type:"SHORT", value:0}, {name:"numberOfHMetrics", type:"USHORT", value:0}], b);
    };
  }, {"../parse":10, "../table":13}], 22:[function(c, g, b) {
    var e = c("../parse"), f = c("../table");
    b.parse = function(b, c, f, g, t) {
      var d, k;
      b = new e.Parser(b, c);
      for (c = 0; g > c; c += 1) {
        f > c && (d = b.parseUShort(), k = b.parseShort());
        var m = t.get(c);
        m.advanceWidth = d;
        m.leftSideBearing = k;
      }
    };
    b.make = function(b) {
      for (var c = new f.Table("hmtx", []), e = 0; e < b.length; e += 1) {
        var g = b.get(e), k = g.leftSideBearing || 0;
        c.fields.push({name:"advanceWidth_" + e, type:"USHORT", value:g.advanceWidth || 0});
        c.fields.push({name:"leftSideBearing_" + e, type:"SHORT", value:k});
      }
      return c;
    };
  }, {"../parse":10, "../table":13}], 23:[function(c, g, b) {
    var e = c("../check"), f = c("../parse");
    b.parse = function(b, c) {
      var g = {};
      b = new f.Parser(b, c);
      c = b.parseUShort();
      e.argument(0 === c, "Unsupported kern table version.");
      b.skip("uShort", 1);
      c = b.parseUShort();
      e.argument(0 === c, "Unsupported kern sub-table version.");
      b.skip("uShort", 2);
      c = b.parseUShort();
      b.skip("uShort", 3);
      for (var k = 0; c > k; k += 1) {
        var n = b.parseUShort(), d = b.parseUShort(), l = b.parseShort();
        g[n + "," + d] = l;
      }
      return g;
    };
  }, {"../check":2, "../parse":10}], 24:[function(c, g, b) {
    var e = c("../parse");
    b.parse = function(b, c, g, p) {
      b = new e.Parser(b, c);
      c = p ? b.parseUShort : b.parseULong;
      for (var f = [], k = 0; g + 1 > k; k += 1) {
        var d = c.call(b);
        p && (d *= 2);
        f.push(d);
      }
      return f;
    };
  }, {"../parse":10}], 25:[function(c, g, b) {
    var e = c("../check"), f = c("../parse"), k = c("../table");
    b.make = function(b) {
      for (var c = new k.Table("ltag", [{name:"version", type:"ULONG", value:1}, {name:"flags", type:"ULONG", value:0}, {name:"numTags", type:"ULONG", value:b.length}]), e = "", f = 12 + 4 * b.length, d = 0; d < b.length; ++d) {
        var g = e.indexOf(b[d]);
        0 > g && (g = e.length, e += b[d]);
        c.fields.push({name:"offset " + d, type:"USHORT", value:f + g});
        c.fields.push({name:"length " + d, type:"USHORT", value:b[d].length});
      }
      return c.fields.push({name:"stringPool", type:"CHARARRAY", value:e}), c;
    };
    b.parse = function(b, c) {
      var g = new f.Parser(b, c), k = g.parseULong();
      e.argument(1 === k, "Unsupported ltag table version.");
      g.skip("uLong", 1);
      k = g.parseULong();
      for (var d = [], l = 0; k > l; l++) {
        for (var n = "", p = c + g.parseUShort(), y = g.parseUShort(), x = p; p + y > x; ++x) {
          n += String.fromCharCode(b.getInt8(x));
        }
        d.push(n);
      }
      return d;
    };
  }, {"../check":2, "../parse":10, "../table":13}], 26:[function(c, g, b) {
    var e = c("../parse"), f = c("../table");
    b.parse = function(b, c) {
      var f = {};
      b = new e.Parser(b, c);
      return f.version = b.parseVersion(), f.numGlyphs = b.parseUShort(), 1 === f.version && (f.maxPoints = b.parseUShort(), f.maxContours = b.parseUShort(), f.maxCompositePoints = b.parseUShort(), f.maxCompositeContours = b.parseUShort(), f.maxZones = b.parseUShort(), f.maxTwilightPoints = b.parseUShort(), f.maxStorage = b.parseUShort(), f.maxFunctionDefs = b.parseUShort(), f.maxInstructionDefs = b.parseUShort(), f.maxStackElements = b.parseUShort(), f.maxSizeOfInstructions = b.parseUShort(), f.maxComponentElements = 
      b.parseUShort(), f.maxComponentDepth = b.parseUShort()), f;
    };
    b.make = function(b) {
      return new f.Table("maxp", [{name:"version", type:"FIXED", value:20480}, {name:"numGlyphs", type:"USHORT", value:b}]);
    };
  }, {"../parse":10, "../table":13}], 27:[function(c, g, b) {
    var e = c("../types").decode, f = c("../check"), k = c("../parse"), n = c("../table");
    b.parse = function(b, c) {
      var g = new k.Parser(b, c), d = g.parseULong();
      f.argument(1 === d, "Unsupported META table version.");
      g.parseULong();
      g.parseULong();
      d = g.parseULong();
      for (var l = {}, m = 0; d > m; m++) {
        var n = g.parseTag(), p = g.parseULong(), x = g.parseULong();
        p = e.UTF8(b, c + p, x);
        l[n] = p;
      }
      return l;
    };
    b.make = function(b) {
      var c = Object.keys(b).length, e = "", d = 16 + 12 * c;
      c = new n.Table("meta", [{name:"version", type:"ULONG", value:1}, {name:"flags", type:"ULONG", value:0}, {name:"offset", type:"ULONG", value:d}, {name:"numTags", type:"ULONG", value:c}]);
      for (var f in b) {
        var g = e.length;
        e += b[f];
        c.fields.push({name:"tag " + f, type:"TAG", value:f});
        c.fields.push({name:"offset " + f, type:"ULONG", value:d + g});
        c.fields.push({name:"length " + f, type:"ULONG", value:b[f].length});
      }
      return c.fields.push({name:"stringPool", type:"CHARARRAY", value:e}), c;
    };
  }, {"../check":2, "../parse":10, "../table":13, "../types":32}], 28:[function(c, g, b) {
    function e(b, c, d) {
      switch(b) {
        case 0:
          return x;
        case 1:
          return v[d] || q[c];
        case 3:
          if (1 === c || 10 === c) {
            return x;
          }
      }
    }
    function f(b) {
      var c = {}, d;
      for (d in b) {
        c[b[d]] = parseInt(d);
      }
      return c;
    }
    function k(b, c, e, f, g, k) {
      return new d.Record("NameRecord", [{name:"platformID", type:"USHORT", value:b}, {name:"encodingID", type:"USHORT", value:c}, {name:"languageID", type:"USHORT", value:e}, {name:"nameID", type:"USHORT", value:f}, {name:"length", type:"USHORT", value:g}, {name:"offset", type:"USHORT", value:k}]);
    }
    function n(b, c) {
      a: {
        var d = b.length;
        var e = c.length - d + 1, f = 0;
        b: for (; e > f; f++) {
          for (; e > f;) {
            for (var g = 0; d > g; g++) {
              if (c[f + g] !== b[g]) {
                continue b;
              }
            }
            d = f;
            break a;
          }
        }
        d = -1;
      }
      if (0 > d) {
        for (d = c.length, e = 0, f = b.length; f > e; ++e) {
          c.push(b[e]);
        }
      }
      return d;
    }
    g = c("../types");
    var p = g.decode, m = g.encode, t = c("../parse"), d = c("../table"), l = "copyright fontFamily fontSubfamily uniqueID fullName version postScriptName trademark manufacturer designer description manufacturerURL designerURL license licenseURL reserved preferredFamily preferredSubfamily compatibleFullName sampleText postScriptFindFontName wwsFamily wwsSubfamily".split(" "), u = {0:"en", 1:"fr", 2:"de", 3:"it", 4:"nl", 5:"sv", 6:"es", 7:"da", 8:"pt", 9:"no", 10:"he", 11:"ja", 12:"ar", 13:"fi", 14:"el", 
    15:"is", 16:"mt", 17:"tr", 18:"hr", 19:"zh-Hant", 20:"ur", 21:"hi", 22:"th", 23:"ko", 24:"lt", 25:"pl", 26:"hu", 27:"es", 28:"lv", 29:"se", 30:"fo", 31:"fa", 32:"ru", 33:"zh", 34:"nl-BE", 35:"ga", 36:"sq", 37:"ro", 38:"cz", 39:"sk", 40:"si", 41:"yi", 42:"sr", 43:"mk", 44:"bg", 45:"uk", 46:"be", 47:"uz", 48:"kk", 49:"az-Cyrl", 50:"az-Arab", 51:"hy", 52:"ka", 53:"mo", 54:"ky", 55:"tg", 56:"tk", 57:"mn-CN", 58:"mn", 59:"ps", 60:"ks", 61:"ku", 62:"sd", 63:"bo", 64:"ne", 65:"sa", 66:"mr", 67:"bn", 
    68:"as", 69:"gu", 70:"pa", 71:"or", 72:"ml", 73:"kn", 74:"ta", 75:"te", 76:"si", 77:"my", 78:"km", 79:"lo", 80:"vi", 81:"id", 82:"tl", 83:"ms", 84:"ms-Arab", 85:"am", 86:"ti", 87:"om", 88:"so", 89:"sw", 90:"rw", 91:"rn", 92:"ny", 93:"mg", 94:"eo", 128:"cy", 129:"eu", 130:"ca", 131:"la", 132:"qu", 133:"gn", 134:"ay", 135:"tt", 136:"ug", 137:"dz", 138:"jv", 139:"su", 140:"gl", 141:"af", 142:"br", 143:"iu", 144:"gd", 145:"gv", 146:"ga", 147:"to", 148:"el-polyton", 149:"kl", 150:"az", 151:"nn"}, 
    w = {0:0, 1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0, 8:0, 9:0, 10:5, 11:1, 12:4, 13:0, 14:6, 15:0, 16:0, 17:0, 18:0, 19:2, 20:4, 21:9, 22:21, 23:3, 24:29, 25:29, 26:29, 27:29, 28:29, 29:0, 30:0, 31:4, 32:7, 33:25, 34:0, 35:0, 36:0, 37:0, 38:29, 39:29, 40:0, 41:5, 42:7, 43:7, 44:7, 45:7, 46:7, 47:7, 48:7, 49:7, 50:4, 51:24, 52:23, 53:7, 54:7, 55:7, 56:7, 57:27, 58:7, 59:4, 60:4, 61:4, 62:4, 63:26, 64:9, 65:9, 66:9, 67:13, 68:13, 69:11, 70:10, 71:12, 72:17, 73:16, 74:14, 75:15, 76:18, 77:19, 78:20, 79:22, 
    80:30, 81:0, 82:0, 83:0, 84:4, 85:28, 86:28, 87:28, 88:0, 89:0, 90:0, 91:0, 92:0, 93:0, 94:0, 128:0, 129:0, 130:0, 131:0, 132:0, 133:0, 134:0, 135:7, 136:4, 137:26, 138:0, 139:0, 140:0, 141:0, 142:0, 143:28, 144:0, 145:0, 146:0, 147:0, 148:6, 149:0, 150:0, 151:0}, y = {1078:"af", 1052:"sq", 1156:"gsw", 1118:"am", 5121:"ar-DZ", 15361:"ar-BH", 3073:"ar", 2049:"ar-IQ", 11265:"ar-JO", 13313:"ar-KW", 12289:"ar-LB", 4097:"ar-LY", 6145:"ary", 8193:"ar-OM", 16385:"ar-QA", 1025:"ar-SA", 10241:"ar-SY", 
    7169:"aeb", 14337:"ar-AE", 9217:"ar-YE", 1067:"hy", 1101:"as", 2092:"az-Cyrl", 1068:"az", 1133:"ba", 1069:"eu", 1059:"be", 2117:"bn", 1093:"bn-IN", 8218:"bs-Cyrl", 5146:"bs", 1150:"br", 1026:"bg", 1027:"ca", 3076:"zh-HK", 5124:"zh-MO", 2052:"zh", 4100:"zh-SG", 1028:"zh-TW", 1155:"co", 1050:"hr", 4122:"hr-BA", 1029:"cs", 1030:"da", 1164:"prs", 1125:"dv", 2067:"nl-BE", 1043:"nl", 3081:"en-AU", 10249:"en-BZ", 4105:"en-CA", 9225:"en-029", 16393:"en-IN", 6153:"en-IE", 8201:"en-JM", 17417:"en-MY", 
    5129:"en-NZ", 13321:"en-PH", 18441:"en-SG", 7177:"en-ZA", 11273:"en-TT", 2057:"en-GB", 1033:"en", 12297:"en-ZW", 1061:"et", 1080:"fo", 1124:"fil", 1035:"fi", 2060:"fr-BE", 3084:"fr-CA", 1036:"fr", 5132:"fr-LU", 6156:"fr-MC", 4108:"fr-CH", 1122:"fy", 1110:"gl", 1079:"ka", 3079:"de-AT", 1031:"de", 5127:"de-LI", 4103:"de-LU", 2055:"de-CH", 1032:"el", 1135:"kl", 1095:"gu", 1128:"ha", 1037:"he", 1081:"hi", 1038:"hu", 1039:"is", 1136:"ig", 1057:"id", 1117:"iu", 2141:"iu-Latn", 2108:"ga", 1076:"xh", 
    1077:"zu", 1040:"it", 2064:"it-CH", 1041:"ja", 1099:"kn", 1087:"kk", 1107:"km", 1158:"quc", 1159:"rw", 1089:"sw", 1111:"kok", 1042:"ko", 1088:"ky", 1108:"lo", 1062:"lv", 1063:"lt", 2094:"dsb", 1134:"lb", 1071:"mk", 2110:"ms-BN", 1086:"ms", 1100:"ml", 1082:"mt", 1153:"mi", 1146:"arn", 1102:"mr", 1148:"moh", 1104:"mn", 2128:"mn-CN", 1121:"ne", 1044:"nb", 2068:"nn", 1154:"oc", 1096:"or", 1123:"ps", 1045:"pl", 1046:"pt", 2070:"pt-PT", 1094:"pa", 1131:"qu-BO", 2155:"qu-EC", 3179:"qu", 1048:"ro", 1047:"rm", 
    1049:"ru", 9275:"smn", 4155:"smj-NO", 5179:"smj", 3131:"se-FI", 1083:"se", 2107:"se-SE", 8251:"sms", 6203:"sma-NO", 7227:"sms", 1103:"sa", 7194:"sr-Cyrl-BA", 3098:"sr", 6170:"sr-Latn-BA", 2074:"sr-Latn", 1132:"nso", 1074:"tn", 1115:"si", 1051:"sk", 1060:"sl", 11274:"es-AR", 16394:"es-BO", 13322:"es-CL", 9226:"es-CO", 5130:"es-CR", 7178:"es-DO", 12298:"es-EC", 17418:"es-SV", 4106:"es-GT", 18442:"es-HN", 2058:"es-MX", 19466:"es-NI", 6154:"es-PA", 15370:"es-PY", 10250:"es-PE", 20490:"es-PR", 3082:"es", 
    1034:"es", 21514:"es-US", 14346:"es-UY", 8202:"es-VE", 2077:"sv-FI", 1053:"sv", 1114:"syr", 1064:"tg", 2143:"tzm", 1097:"ta", 1092:"tt", 1098:"te", 1054:"th", 1105:"bo", 1055:"tr", 1090:"tk", 1152:"ug", 1058:"uk", 1070:"hsb", 1056:"ur", 2115:"uz-Cyrl", 1091:"uz", 1066:"vi", 1106:"cy", 1160:"wo", 1157:"sah", 1144:"ii", 1130:"yo"}, x = "utf-16", q = {0:"macintosh", 1:"x-mac-japanese", 2:"x-mac-chinesetrad", 3:"x-mac-korean", 6:"x-mac-greek", 7:"x-mac-cyrillic", 9:"x-mac-devanagai", 10:"x-mac-gurmukhi", 
    11:"x-mac-gujarati", 12:"x-mac-oriya", 13:"x-mac-bengali", 14:"x-mac-tamil", 15:"x-mac-telugu", 16:"x-mac-kannada", 17:"x-mac-malayalam", 18:"x-mac-sinhalese", 19:"x-mac-burmese", 20:"x-mac-khmer", 21:"x-mac-thai", 22:"x-mac-lao", 23:"x-mac-georgian", 24:"x-mac-armenian", 25:"x-mac-chinesesimp", 26:"x-mac-tibetan", 27:"x-mac-mongolian", 28:"x-mac-ethiopic", 29:"x-mac-ce", 30:"x-mac-vietnamese", 31:"x-mac-extarabic"}, v = {15:"x-mac-icelandic", 17:"x-mac-turkish", 18:"x-mac-croatian", 24:"x-mac-ce", 
    25:"x-mac-ce", 26:"x-mac-ce", 27:"x-mac-ce", 28:"x-mac-ce", 30:"x-mac-icelandic", 37:"x-mac-romanian", 38:"x-mac-ce", 39:"x-mac-ce", 40:"x-mac-ce", 143:"x-mac-inuit", 146:"x-mac-gaelic"};
    b.parse = function(b, c, d) {
      var f = {};
      c = new t.Parser(b, c);
      for (var g = c.parseUShort(), k = c.parseUShort(), m = c.offset + c.parseUShort(), n = 0; k > n; n++) {
        var q = c.parseUShort(), w = c.parseUShort(), v = c.parseUShort(), z = c.parseUShort();
        z = l[z] || z;
        var A = c.parseUShort(), C = c.parseUShort();
        a: {
          switch(q) {
            case 0:
              if (65535 === v) {
                var aa = "und";
                break a;
              }
              if (d) {
                aa = d[v];
                break a;
              }
              break;
            case 1:
              aa = u[v];
              break a;
            case 3:
              aa = y[v];
              break a;
          }
          aa = void 0;
        }
        q = e(q, w, v);
        void 0 !== q && void 0 !== aa && (q = q === x ? p.UTF16(b, m + C, A) : p.MACSTRING(b, m + C, A, q)) && (w = f[z], void 0 === w && (w = f[z] = {}), w[aa] = q);
      }
      return 1 === g && c.parseUShort(), f;
    };
    b.make = function(b, c) {
      var g, p = [], q = {}, t = f(l);
      for (x in b) {
        var v = t[x];
        if (void 0 === v && (v = x), g = parseInt(v), isNaN(g)) {
          throw Error('Name table entry "' + x + '" does not exist, see nameTableNames for complete list.');
        }
        q[g] = b[x];
        p.push(g);
      }
      var x = f(u);
      v = f(y);
      b = [];
      t = [];
      for (var z = 0; z < p.length; z++) {
        g = p[z];
        var C = q[g], L;
        for (L in C) {
          var R = C[L], J = 1, Q = x[L], aa = w[Q], U = e(J, aa, Q);
          U = m.MACSTRING(R, U);
          void 0 === U && (J = 0, Q = c.indexOf(L), 0 > Q && (Q = c.length, c.push(L)), aa = 4, U = m.UTF16(R));
          var N = n(U, t);
          b.push(k(J, aa, Q, g, U.length, N));
          J = v[L];
          void 0 !== J && (R = m.UTF16(R), Q = n(R, t), b.push(k(3, 1, J, g, R.length, Q)));
        }
      }
      b.sort(function(b, c) {
        return b.platformID - c.platformID || b.encodingID - c.encodingID || b.languageID - c.languageID || b.nameID - c.nameID;
      });
      c = new d.Table("name", [{name:"format", type:"USHORT", value:0}, {name:"count", type:"USHORT", value:b.length}, {name:"stringOffset", type:"USHORT", value:6 + 12 * b.length}]);
      for (g = 0; g < b.length; g++) {
        c.fields.push({name:"record_" + g, type:"RECORD", value:b[g]});
      }
      return c.fields.push({name:"strings", type:"LITERAL", value:t}), c;
    };
  }, {"../parse":10, "../table":13, "../types":32}], 29:[function(c, g, b) {
    var e = c("../parse"), f = c("../table"), k = [{begin:0, end:127}, {begin:128, end:255}, {begin:256, end:383}, {begin:384, end:591}, {begin:592, end:687}, {begin:688, end:767}, {begin:768, end:879}, {begin:880, end:1023}, {begin:11392, end:11519}, {begin:1024, end:1279}, {begin:1328, end:1423}, {begin:1424, end:1535}, {begin:42240, end:42559}, {begin:1536, end:1791}, {begin:1984, end:2047}, {begin:2304, end:2431}, {begin:2432, end:2559}, {begin:2560, end:2687}, {begin:2688, end:2815}, {begin:2816, 
    end:2943}, {begin:2944, end:3071}, {begin:3072, end:3199}, {begin:3200, end:3327}, {begin:3328, end:3455}, {begin:3584, end:3711}, {begin:3712, end:3839}, {begin:4256, end:4351}, {begin:6912, end:7039}, {begin:4352, end:4607}, {begin:7680, end:7935}, {begin:7936, end:8191}, {begin:8192, end:8303}, {begin:8304, end:8351}, {begin:8352, end:8399}, {begin:8400, end:8447}, {begin:8448, end:8527}, {begin:8528, end:8591}, {begin:8592, end:8703}, {begin:8704, end:8959}, {begin:8960, end:9215}, {begin:9216, 
    end:9279}, {begin:9280, end:9311}, {begin:9312, end:9471}, {begin:9472, end:9599}, {begin:9600, end:9631}, {begin:9632, end:9727}, {begin:9728, end:9983}, {begin:9984, end:10175}, {begin:12288, end:12351}, {begin:12352, end:12447}, {begin:12448, end:12543}, {begin:12544, end:12591}, {begin:12592, end:12687}, {begin:43072, end:43135}, {begin:12800, end:13055}, {begin:13056, end:13311}, {begin:44032, end:55215}, {begin:55296, end:57343}, {begin:67840, end:67871}, {begin:19968, end:40959}, {begin:57344, 
    end:63743}, {begin:12736, end:12783}, {begin:64256, end:64335}, {begin:64336, end:65023}, {begin:65056, end:65071}, {begin:65040, end:65055}, {begin:65104, end:65135}, {begin:65136, end:65279}, {begin:65280, end:65519}, {begin:65520, end:65535}, {begin:3840, end:4095}, {begin:1792, end:1871}, {begin:1920, end:1983}, {begin:3456, end:3583}, {begin:4096, end:4255}, {begin:4608, end:4991}, {begin:5024, end:5119}, {begin:5120, end:5759}, {begin:5760, end:5791}, {begin:5792, end:5887}, {begin:6016, 
    end:6143}, {begin:6144, end:6319}, {begin:10240, end:10495}, {begin:40960, end:42127}, {begin:5888, end:5919}, {begin:66304, end:66351}, {begin:66352, end:66383}, {begin:66560, end:66639}, {begin:118784, end:119039}, {begin:119808, end:120831}, {begin:1044480, end:1048573}, {begin:65024, end:65039}, {begin:917504, end:917631}, {begin:6400, end:6479}, {begin:6480, end:6527}, {begin:6528, end:6623}, {begin:6656, end:6687}, {begin:11264, end:11359}, {begin:11568, end:11647}, {begin:19904, end:19967}, 
    {begin:43008, end:43055}, {begin:65536, end:65663}, {begin:65856, end:65935}, {begin:66432, end:66463}, {begin:66464, end:66527}, {begin:66640, end:66687}, {begin:66688, end:66735}, {begin:67584, end:67647}, {begin:68096, end:68191}, {begin:119552, end:119647}, {begin:73728, end:74751}, {begin:119648, end:119679}, {begin:7040, end:7103}, {begin:7168, end:7247}, {begin:7248, end:7295}, {begin:43136, end:43231}, {begin:43264, end:43311}, {begin:43312, end:43359}, {begin:43520, end:43615}, {begin:65936, 
    end:65999}, {begin:66E3, end:66047}, {begin:66208, end:66271}, {begin:127024, end:127135}];
    b.unicodeRanges = k;
    b.getUnicodeRange = function(b) {
      for (var c = 0; c < k.length; c += 1) {
        var e = k[c];
        if (b >= e.begin && b < e.end) {
          return c;
        }
      }
      return -1;
    };
    b.parse = function(b, c) {
      var f = {};
      b = new e.Parser(b, c);
      f.version = b.parseUShort();
      f.xAvgCharWidth = b.parseShort();
      f.usWeightClass = b.parseUShort();
      f.usWidthClass = b.parseUShort();
      f.fsType = b.parseUShort();
      f.ySubscriptXSize = b.parseShort();
      f.ySubscriptYSize = b.parseShort();
      f.ySubscriptXOffset = b.parseShort();
      f.ySubscriptYOffset = b.parseShort();
      f.ySuperscriptXSize = b.parseShort();
      f.ySuperscriptYSize = b.parseShort();
      f.ySuperscriptXOffset = b.parseShort();
      f.ySuperscriptYOffset = b.parseShort();
      f.yStrikeoutSize = b.parseShort();
      f.yStrikeoutPosition = b.parseShort();
      f.sFamilyClass = b.parseShort();
      f.panose = [];
      for (c = 0; 10 > c; c++) {
        f.panose[c] = b.parseByte();
      }
      return f.ulUnicodeRange1 = b.parseULong(), f.ulUnicodeRange2 = b.parseULong(), f.ulUnicodeRange3 = b.parseULong(), f.ulUnicodeRange4 = b.parseULong(), f.achVendID = String.fromCharCode(b.parseByte(), b.parseByte(), b.parseByte(), b.parseByte()), f.fsSelection = b.parseUShort(), f.usFirstCharIndex = b.parseUShort(), f.usLastCharIndex = b.parseUShort(), f.sTypoAscender = b.parseShort(), f.sTypoDescender = b.parseShort(), f.sTypoLineGap = b.parseShort(), f.usWinAscent = b.parseUShort(), f.usWinDescent = 
      b.parseUShort(), 1 <= f.version && (f.ulCodePageRange1 = b.parseULong(), f.ulCodePageRange2 = b.parseULong()), 2 <= f.version && (f.sxHeight = b.parseShort(), f.sCapHeight = b.parseShort(), f.usDefaultChar = b.parseUShort(), f.usBreakChar = b.parseUShort(), f.usMaxContent = b.parseUShort()), f;
    };
    b.make = function(b) {
      return new f.Table("OS/2", [{name:"version", type:"USHORT", value:3}, {name:"xAvgCharWidth", type:"SHORT", value:0}, {name:"usWeightClass", type:"USHORT", value:0}, {name:"usWidthClass", type:"USHORT", value:0}, {name:"fsType", type:"USHORT", value:0}, {name:"ySubscriptXSize", type:"SHORT", value:650}, {name:"ySubscriptYSize", type:"SHORT", value:699}, {name:"ySubscriptXOffset", type:"SHORT", value:0}, {name:"ySubscriptYOffset", type:"SHORT", value:140}, {name:"ySuperscriptXSize", type:"SHORT", 
      value:650}, {name:"ySuperscriptYSize", type:"SHORT", value:699}, {name:"ySuperscriptXOffset", type:"SHORT", value:0}, {name:"ySuperscriptYOffset", type:"SHORT", value:479}, {name:"yStrikeoutSize", type:"SHORT", value:49}, {name:"yStrikeoutPosition", type:"SHORT", value:258}, {name:"sFamilyClass", type:"SHORT", value:0}, {name:"bFamilyType", type:"BYTE", value:0}, {name:"bSerifStyle", type:"BYTE", value:0}, {name:"bWeight", type:"BYTE", value:0}, {name:"bProportion", type:"BYTE", value:0}, {name:"bContrast", 
      type:"BYTE", value:0}, {name:"bStrokeVariation", type:"BYTE", value:0}, {name:"bArmStyle", type:"BYTE", value:0}, {name:"bLetterform", type:"BYTE", value:0}, {name:"bMidline", type:"BYTE", value:0}, {name:"bXHeight", type:"BYTE", value:0}, {name:"ulUnicodeRange1", type:"ULONG", value:0}, {name:"ulUnicodeRange2", type:"ULONG", value:0}, {name:"ulUnicodeRange3", type:"ULONG", value:0}, {name:"ulUnicodeRange4", type:"ULONG", value:0}, {name:"achVendID", type:"CHARARRAY", value:"XXXX"}, {name:"fsSelection", 
      type:"USHORT", value:0}, {name:"usFirstCharIndex", type:"USHORT", value:0}, {name:"usLastCharIndex", type:"USHORT", value:0}, {name:"sTypoAscender", type:"SHORT", value:0}, {name:"sTypoDescender", type:"SHORT", value:0}, {name:"sTypoLineGap", type:"SHORT", value:0}, {name:"usWinAscent", type:"USHORT", value:0}, {name:"usWinDescent", type:"USHORT", value:0}, {name:"ulCodePageRange1", type:"ULONG", value:0}, {name:"ulCodePageRange2", type:"ULONG", value:0}, {name:"sxHeight", type:"SHORT", value:0}, 
      {name:"sCapHeight", type:"SHORT", value:0}, {name:"usDefaultChar", type:"USHORT", value:0}, {name:"usBreakChar", type:"USHORT", value:0}, {name:"usMaxContext", type:"USHORT", value:0}], b);
    };
  }, {"../parse":10, "../table":13}], 30:[function(c, g, b) {
    var e = c("../encoding"), f = c("../parse"), k = c("../table");
    b.parse = function(b, c) {
      var g = {};
      c = new f.Parser(b, c);
      switch(g.version = c.parseVersion(), g.italicAngle = c.parseFixed(), g.underlinePosition = c.parseShort(), g.underlineThickness = c.parseShort(), g.isFixedPitch = c.parseULong(), g.minMemType42 = c.parseULong(), g.maxMemType42 = c.parseULong(), g.minMemType1 = c.parseULong(), g.maxMemType1 = c.parseULong(), g.version) {
        case 1:
          g.names = e.standardNames.slice();
          break;
        case 2:
          g.numberOfGlyphs = c.parseUShort();
          g.glyphNameIndex = Array(g.numberOfGlyphs);
          for (b = 0; b < g.numberOfGlyphs; b++) {
            g.glyphNameIndex[b] = c.parseUShort();
          }
          g.names = [];
          for (b = 0; b < g.numberOfGlyphs; b++) {
            if (g.glyphNameIndex[b] >= e.standardNames.length) {
              var k = c.parseChar();
              g.names.push(c.parseString(k));
            }
          }
          break;
        case 2.5:
          for (g.numberOfGlyphs = c.parseUShort(), g.offset = Array(g.numberOfGlyphs), b = 0; b < g.numberOfGlyphs; b++) {
            g.offset[b] = c.parseChar();
          }
      }
      return g;
    };
    b.make = function() {
      return new k.Table("post", [{name:"version", type:"FIXED", value:196608}, {name:"italicAngle", type:"FIXED", value:0}, {name:"underlinePosition", type:"FWORD", value:0}, {name:"underlineThickness", type:"FWORD", value:0}, {name:"isFixedPitch", type:"ULONG", value:0}, {name:"minMemType42", type:"ULONG", value:0}, {name:"maxMemType42", type:"ULONG", value:0}, {name:"minMemType1", type:"ULONG", value:0}, {name:"maxMemType1", type:"ULONG", value:0}]);
    };
  }, {"../encoding":4, "../parse":10, "../table":13}], 31:[function(c, g, b) {
    function e(b) {
      for (; 0 !== b.length % 4;) {
        b.push(0);
      }
      for (var c = 0, d = 0; d < b.length; d += 4) {
        c += (b[d] << 24) + (b[d + 1] << 16) + (b[d + 2] << 8) + b[d + 3];
      }
      return c % Math.pow(2, 32);
    }
    function f(b, c, d, e) {
      return new m.Record("Table Record", [{name:"tag", type:"TAG", value:void 0 !== b ? b : ""}, {name:"checkSum", type:"ULONG", value:void 0 !== c ? c : 0}, {name:"offset", type:"ULONG", value:void 0 !== d ? d : 0}, {name:"length", type:"ULONG", value:void 0 !== e ? e : 0}]);
    }
    function k(b) {
      var c = new m.Table("sfnt", [{name:"version", type:"TAG", value:"OTTO"}, {name:"numTables", type:"USHORT", value:0}, {name:"searchRange", type:"USHORT", value:0}, {name:"entrySelector", type:"USHORT", value:0}, {name:"rangeShift", type:"USHORT", value:0}]);
      c.tables = b;
      c.numTables = b.length;
      var d = Math.pow(2, Math.log(c.numTables) / Math.log(2) | 0);
      c.searchRange = 16 * d;
      c.entrySelector = Math.log(d) / Math.log(2) | 0;
      c.rangeShift = 16 * c.numTables - c.searchRange;
      d = [];
      for (var g = [], k = c.sizeOf() + f().sizeOf() * c.numTables; 0 !== k % 4;) {
        k += 1, g.push({name:"padding", type:"BYTE", value:0});
      }
      for (var l = 0; l < b.length; l += 1) {
        var n = b[l];
        p.argument(4 === n.tableName.length, "Table name" + n.tableName + " is invalid.");
        var q = n.sizeOf(), u = f(n.tableName, e(n.encode()), k, q);
        d.push({name:u.tag + " Table Record", type:"RECORD", value:u});
        g.push({name:n.tableName + " table", type:"RECORD", value:n});
        k += q;
        for (p.argument(!isNaN(k), "Something went wrong calculating the offset."); 0 !== k % 4;) {
          k += 1, g.push({name:"padding", type:"BYTE", value:0});
        }
      }
      return d.sort(function(b, c) {
        return b.value.tag > c.value.tag ? 1 : -1;
      }), c.fields = c.fields.concat(d), c.fields = c.fields.concat(g), c;
    }
    function n(b, c, d) {
      for (var e = 0; e < c.length; e += 1) {
        var f = b.charToGlyphIndex(c[e]);
        if (0 < f) {
          return b.glyphs.get(f).getMetrics();
        }
      }
      return d;
    }
    var p = c("../check"), m = c("../table"), t = c("./cmap"), d = c("./cff"), l = c("./head"), u = c("./hhea"), w = c("./hmtx"), y = c("./ltag"), x = c("./maxp"), q = c("./name"), v = c("./os2"), z = c("./post"), C = c("./gsub"), A = c("./meta");
    b.computeCheckSum = e;
    b.make = k;
    b.fontToTable = function(b) {
      for (var c, f = [], g = [], m = [], p = [], D = [], L = [], R = [], J = 0, Q = 0, aa = 0, U = 0, N = 0, S = 0; S < b.glyphs.length; S += 1) {
        var V = b.glyphs.get(S), M = 0 | V.unicode;
        if (isNaN(V.advanceWidth)) {
          throw Error("Glyph " + V.name + " (" + S + "): advanceWidth is not a number.");
        }
        (c > M || void 0 === c) && 0 < M && (c = M);
        M > J && (J = M);
        M = v.getUnicodeRange(M);
        if (32 > M) {
          Q |= 1 << M;
        } else {
          if (64 > M) {
            aa |= 1 << M - 32;
          } else {
            if (96 > M) {
              U |= 1 << M - 64;
            } else {
              if (!(123 > M)) {
                throw Error("Unicode ranges bits > 123 are reserved for internal usage");
              }
              N |= 1 << M - 96;
            }
          }
        }
        ".notdef" !== V.name && (M = V.getMetrics(), f.push(M.xMin), g.push(M.yMin), m.push(M.xMax), p.push(M.yMax), L.push(M.leftSideBearing), R.push(M.rightSideBearing), D.push(V.advanceWidth));
      }
      S = Math.min.apply(null, f);
      g = Math.min.apply(null, g);
      m = Math.max.apply(null, m);
      p = Math.max.apply(null, p);
      f = Math.max.apply(null, D);
      for (M = V = 0; M < D.length; M += 1) {
        V += D[M];
      }
      S = {xMin:S, yMin:g, xMax:m, yMax:p, advanceWidthMax:f, advanceWidthAvg:V / D.length, minLeftSideBearing:Math.min.apply(null, L), maxLeftSideBearing:Math.max.apply(null, L), minRightSideBearing:Math.min.apply(null, R)};
      S.ascender = b.ascender;
      S.descender = b.descender;
      D = l.make({flags:3, unitsPerEm:b.unitsPerEm, xMin:S.xMin, yMin:S.yMin, xMax:S.xMax, yMax:S.yMax, lowestRecPPEM:3, createdTimestamp:b.createdTimestamp});
      L = u.make({ascender:S.ascender, descender:S.descender, advanceWidthMax:S.advanceWidthMax, minLeftSideBearing:S.minLeftSideBearing, minRightSideBearing:S.minRightSideBearing, xMaxExtent:S.maxLeftSideBearing + (S.xMax - S.xMin), numberOfHMetrics:b.glyphs.length});
      R = x.make(b.glyphs.length);
      c = v.make({xAvgCharWidth:Math.round(S.advanceWidthAvg), usWeightClass:b.tables.os2.usWeightClass, usWidthClass:b.tables.os2.usWidthClass, usFirstCharIndex:c, usLastCharIndex:J, ulUnicodeRange1:Q, ulUnicodeRange2:aa, ulUnicodeRange3:U, ulUnicodeRange4:N, fsSelection:b.tables.os2.fsSelection, sTypoAscender:S.ascender, sTypoDescender:S.descender, sTypoLineGap:0, usWinAscent:S.yMax, usWinDescent:Math.abs(S.yMin), ulCodePageRange1:1, sxHeight:n(b, "xyvw", {yMax:Math.round(S.ascender / 2)}).yMax, 
      sCapHeight:n(b, "HIKLEFJMNTZBDPRAGOQSUVWXY", S).yMax, usDefaultChar:b.hasChar(" ") ? 32 : 0, usBreakChar:b.hasChar(" ") ? 32 : 0});
      J = w.make(b.glyphs);
      Q = t.make(b.glyphs);
      aa = b.getEnglishName("fontFamily");
      U = b.getEnglishName("fontSubfamily");
      N = aa + " " + U;
      (p = b.getEnglishName("postScriptName")) || (p = aa.replace(/\s/g, "") + "-" + U);
      m = {};
      for (var O in b.names) {
        m[O] = b.names[O];
      }
      m.uniqueID || (m.uniqueID = {en:b.getEnglishName("manufacturer") + ":" + N});
      m.postScriptName || (m.postScriptName = {en:p});
      m.preferredFamily || (m.preferredFamily = b.names.fontFamily);
      m.preferredSubfamily || (m.preferredSubfamily = b.names.fontSubfamily);
      g = [];
      O = q.make(m, g);
      m = 0 < g.length ? y.make(g) : void 0;
      g = z.make();
      U = d.make(b.glyphs, {version:b.getEnglishName("version"), fullName:N, familyName:aa, weightName:U, postScriptName:p, unitsPerEm:b.unitsPerEm, fontBBox:[0, S.yMin, S.ascender, S.advanceWidthMax]});
      aa = b.metas && 0 < Object.keys(b.metas).length ? A.make(b.metas) : void 0;
      O = [D, L, R, c, O, Q, g, U, J];
      m && O.push(m);
      b.tables.gsub && O.push(C.make(b.tables.gsub));
      aa && O.push(aa);
      b = k(O);
      O = b.encode();
      O = e(O);
      c = b.fields;
      J = !1;
      for (S = 0; S < c.length; S += 1) {
        if ("head table" === c[S].name) {
          c[S].value.checkSumAdjustment = 2981146554 - O;
          J = !0;
          break;
        }
      }
      if (!J) {
        throw Error("Could not find head table with checkSum to adjust.");
      }
      return b;
    };
  }, {"../check":2, "../table":13, "./cff":14, "./cmap":15, "./gsub":19, "./head":20, "./hhea":21, "./hmtx":22, "./ltag":25, "./maxp":26, "./meta":27, "./name":28, "./os2":29, "./post":30}], 32:[function(c, g, b) {
    function e(b) {
      return function() {
        return b;
      };
    }
    var f = c("./check");
    c = {};
    var k = {}, n = {};
    k.BYTE = function(b) {
      return f.argument(0 <= b && 255 >= b, "Byte value should be between 0 and 255."), [b];
    };
    n.BYTE = e(1);
    k.CHAR = function(b) {
      return [b.charCodeAt(0)];
    };
    n.CHAR = e(1);
    k.CHARARRAY = function(b) {
      for (var c = [], d = 0; d < b.length; d += 1) {
        c[d] = b.charCodeAt(d);
      }
      return c;
    };
    n.CHARARRAY = function(b) {
      return b.length;
    };
    k.USHORT = function(b) {
      return [b >> 8 & 255, 255 & b];
    };
    n.USHORT = e(2);
    k.SHORT = function(b) {
      return 32768 <= b && (b = -(65536 - b)), [b >> 8 & 255, 255 & b];
    };
    n.SHORT = e(2);
    k.UINT24 = function(b) {
      return [b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    n.UINT24 = e(3);
    k.ULONG = function(b) {
      return [b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    n.ULONG = e(4);
    k.LONG = function(b) {
      return 2147483648 <= b && (b = -(4294967296 - b)), [b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    n.LONG = e(4);
    k.FIXED = k.ULONG;
    n.FIXED = n.ULONG;
    k.FWORD = k.SHORT;
    n.FWORD = n.SHORT;
    k.UFWORD = k.USHORT;
    n.UFWORD = n.USHORT;
    k.LONGDATETIME = function(b) {
      return [0, 0, 0, 0, b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    n.LONGDATETIME = e(8);
    k.TAG = function(b) {
      return f.argument(4 === b.length, "Tag should be exactly 4 ASCII characters."), [b.charCodeAt(0), b.charCodeAt(1), b.charCodeAt(2), b.charCodeAt(3)];
    };
    n.TAG = e(4);
    k.Card8 = k.BYTE;
    n.Card8 = n.BYTE;
    k.Card16 = k.USHORT;
    n.Card16 = n.USHORT;
    k.OffSize = k.BYTE;
    n.OffSize = n.BYTE;
    k.SID = k.USHORT;
    n.SID = n.USHORT;
    k.NUMBER = function(b) {
      return -107 <= b && 107 >= b ? [b + 139] : 108 <= b && 1131 >= b ? (b -= 108, [(b >> 8) + 247, 255 & b]) : -1131 <= b && -108 >= b ? (b = -b - 108, [(b >> 8) + 251, 255 & b]) : -32768 <= b && 32767 >= b ? k.NUMBER16(b) : k.NUMBER32(b);
    };
    n.NUMBER = function(b) {
      return k.NUMBER(b).length;
    };
    k.NUMBER16 = function(b) {
      return [28, b >> 8 & 255, 255 & b];
    };
    n.NUMBER16 = e(3);
    k.NUMBER32 = function(b) {
      return [29, b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
    };
    n.NUMBER32 = e(5);
    k.REAL = function(b) {
      var c = b.toString(), d = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(c);
      d && (c = parseFloat("1e" + ((d[2] ? +d[2] : 0) + d[1].length)), c = (Math.round(b * c) / c).toString());
      var e = "";
      b = 0;
      for (d = c.length; d > b; b += 1) {
        var f = c[b];
        e += "e" === f ? "-" === c[++b] ? "c" : "b" : "." === f ? "a" : "-" === f ? "e" : f;
      }
      e += 1 & e.length ? "f" : "ff";
      c = [30];
      b = 0;
      for (d = e.length; d > b; b += 2) {
        c.push(parseInt(e.substr(b, 2), 16));
      }
      return c;
    };
    n.REAL = function(b) {
      return k.REAL(b).length;
    };
    k.NAME = k.CHARARRAY;
    n.NAME = n.CHARARRAY;
    k.STRING = k.CHARARRAY;
    n.STRING = n.CHARARRAY;
    c.UTF8 = function(b, c, d) {
      for (var e = [], f = 0; d > f; f++, c += 1) {
        e[f] = b.getUint8(c);
      }
      return String.fromCharCode.apply(null, e);
    };
    c.UTF16 = function(b, c, d) {
      var e = [];
      d /= 2;
      for (var f = 0; d > f; f++, c += 2) {
        e[f] = b.getUint16(c);
      }
      return String.fromCharCode.apply(null, e);
    };
    k.UTF16 = function(b) {
      for (var c = [], d = 0; d < b.length; d += 1) {
        var e = b.charCodeAt(d);
        c[c.length] = e >> 8 & 255;
        c[c.length] = 255 & e;
      }
      return c;
    };
    n.UTF16 = function(b) {
      return 2 * b.length;
    };
    var p = {"x-mac-croatian":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u0160\u2122\u00b4\u00a8\u2260\u017d\u00d8\u221e\u00b1\u2264\u2265\u2206\u00b5\u2202\u2211\u220f\u0161\u222b\u00aa\u00ba\u03a9\u017e\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u0106\u00ab\u010c\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u0110\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\uf8ff\u00a9\u2044\u20ac\u2039\u203a\u00c6\u00bb\u2013\u00b7\u201a\u201e\u2030\u00c2\u0107\u00c1\u010d\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\u0111\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u03c0\u00cb\u02da\u00b8\u00ca\u00e6\u02c7", 
    "x-mac-cyrillic":"\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\u2020\u00b0\u0490\u00a3\u00a7\u2022\u00b6\u0406\u00ae\u00a9\u2122\u0402\u0452\u2260\u0403\u0453\u221e\u00b1\u2264\u2265\u0456\u00b5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040a\u045a\u0458\u0405\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u040b\u045b\u040c\u045c\u0455\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u201e\u040e\u045e\u040f\u045f\u2116\u0401\u0451\u044f\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e", 
    "x-mac-gaelic":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u1e02\u00b1\u2264\u2265\u1e03\u010a\u010b\u1e0a\u1e0b\u1e1e\u1e1f\u0120\u0121\u1e40\u00e6\u00f8\u1e41\u1e56\u1e57\u027c\u0192\u017f\u1e60\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u1e61\u1e9b\u00ff\u0178\u1e6a\u20ac\u2039\u203a\u0176\u0177\u1e6b\u00b7\u1ef2\u1ef3\u204a\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\u2663\u00d2\u00da\u00db\u00d9\u0131\u00dd\u00fd\u0174\u0175\u1e84\u1e85\u1e80\u1e81\u1e82\u1e83", 
    "x-mac-greek":"\u00c4\u00b9\u00b2\u00c9\u00b3\u00d6\u00dc\u0385\u00e0\u00e2\u00e4\u0384\u00a8\u00e7\u00e9\u00e8\u00ea\u00eb\u00a3\u2122\u00ee\u00ef\u2022\u00bd\u2030\u00f4\u00f6\u00a6\u20ac\u00f9\u00fb\u00fc\u2020\u0393\u0394\u0398\u039b\u039e\u03a0\u00df\u00ae\u00a9\u03a3\u03aa\u00a7\u2260\u00b0\u00b7\u0391\u00b1\u2264\u2265\u00a5\u0392\u0395\u0396\u0397\u0399\u039a\u039c\u03a6\u03ab\u03a8\u03a9\u03ac\u039d\u00ac\u039f\u03a1\u2248\u03a4\u00ab\u00bb\u2026\u00a0\u03a5\u03a7\u0386\u0388\u0153\u2013\u2015\u201c\u201d\u2018\u2019\u00f7\u0389\u038a\u038c\u038e\u03ad\u03ae\u03af\u03cc\u038f\u03cd\u03b1\u03b2\u03c8\u03b4\u03b5\u03c6\u03b3\u03b7\u03b9\u03be\u03ba\u03bb\u03bc\u03bd\u03bf\u03c0\u03ce\u03c1\u03c3\u03c4\u03b8\u03c9\u03c2\u03c7\u03c5\u03b6\u03ca\u03cb\u0390\u03b0\u00ad", 
    "x-mac-icelandic":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u00dd\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u00e6\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u2044\u20ac\u00d0\u00f0\u00de\u00fe\u00fd\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7", 
    "x-mac-inuit":"\u1403\u1404\u1405\u1406\u140a\u140b\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144e\u144f\u1450\u1451\u1455\u1456\u1466\u146d\u146e\u146f\u1470\u1472\u1473\u1483\u148b\u148c\u148d\u148e\u1490\u1491\u00b0\u14a1\u14a5\u14a6\u2022\u00b6\u14a7\u00ae\u00a9\u2122\u14a8\u14aa\u14ab\u14bb\u14c2\u14c3\u14c4\u14c5\u14c7\u14c8\u14d0\u14ef\u14f0\u14f1\u14f2\u14f4\u14f5\u1505\u14d5\u14d6\u14d7\u14d8\u14da\u14db\u14ea\u1528\u1529\u152a\u152b\u152d\u2026\u00a0\u152e\u153e\u1555\u1556\u1557\u2013\u2014\u201c\u201d\u2018\u2019\u1558\u1559\u155a\u155d\u1546\u1547\u1548\u1549\u154b\u154c\u1550\u157f\u1580\u1581\u1582\u1583\u1584\u1585\u158f\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15a0\u15a1\u15a2\u15a3\u15a4\u15a5\u15a6\u157c\u0141\u0142", 
    "x-mac-ce":"\u00c4\u0100\u0101\u00c9\u0104\u00d6\u00dc\u00e1\u0105\u010c\u00e4\u010d\u0106\u0107\u00e9\u0179\u017a\u010e\u00ed\u010f\u0112\u0113\u0116\u00f3\u0117\u00f4\u00f6\u00f5\u00fa\u011a\u011b\u00fc\u2020\u00b0\u0118\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u0119\u00a8\u2260\u0123\u012e\u012f\u012a\u2264\u2265\u012b\u0136\u2202\u2211\u0142\u013b\u013c\u013d\u013e\u0139\u013a\u0145\u0146\u0143\u00ac\u221a\u0144\u0147\u2206\u00ab\u00bb\u2026\u00a0\u0148\u0150\u00d5\u0151\u014c\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u014d\u0154\u0155\u0158\u2039\u203a\u0159\u0156\u0157\u0160\u201a\u201e\u0161\u015a\u015b\u00c1\u0164\u0165\u00cd\u017d\u017e\u016a\u00d3\u00d4\u016b\u016e\u00da\u016f\u0170\u0171\u0172\u0173\u00dd\u00fd\u0137\u017b\u0141\u017c\u0122\u02c7", 
    macintosh:"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u00e6\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u2044\u20ac\u2039\u203a\ufb01\ufb02\u2021\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7", 
    "x-mac-romanian":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u0102\u0218\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u0103\u0219\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u2044\u20ac\u2039\u203a\u021a\u021b\u2021\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7", 
    "x-mac-turkish":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u00e6\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u011e\u011f\u0130\u0131\u015e\u015f\u2021\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\uf8a0\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7"};
    c.MACSTRING = function(b, c, d, e) {
      e = p[e];
      if (void 0 !== e) {
        for (var f = "", g = 0; d > g; g++) {
          var k = b.getUint8(c + g);
          f += 127 >= k ? String.fromCharCode(k) : e[127 & k];
        }
        return f;
      }
    };
    var m = "function" == typeof WeakMap && new WeakMap, t;
    k.MACSTRING = function(b, c) {
      a: {
        if (!t) {
          for (d in t = {}, p) {
            t[d] = new String(d);
          }
        }
        var d = t[c];
        if (void 0 !== d) {
          if (m) {
            var e = m.get(d);
            if (void 0 !== e) {
              d = e;
              break a;
            }
          }
          c = p[c];
          if (void 0 !== c) {
            e = {};
            for (var f = 0; f < c.length; f++) {
              e[c.charCodeAt(f)] = f + 128;
            }
            d = (m && m.set(d, e), e);
            break a;
          }
        }
        d = void 0;
      }
      if (void 0 !== d) {
        c = [];
        for (e = 0; e < b.length; e++) {
          f = b.charCodeAt(e);
          if (128 <= f && (f = d[f], void 0 === f)) {
            return;
          }
          c[e] = f;
        }
        return c;
      }
    };
    n.MACSTRING = function(b, c) {
      b = k.MACSTRING(b, c);
      return void 0 !== b ? b.length : 0;
    };
    k.INDEX = function(b) {
      var c, d = 1, e = [d], f = [];
      for (c = 0; c < b.length; c += 1) {
        var g = k.OBJECT(b[c]);
        Array.prototype.push.apply(f, g);
        d += g.length;
        e.push(d);
      }
      if (0 === f.length) {
        return [0, 0];
      }
      g = [];
      d = 1 + Math.floor(Math.log(d) / Math.log(2)) / 8 | 0;
      var l = [void 0, k.BYTE, k.USHORT, k.UINT24, k.ULONG][d];
      for (c = 0; c < e.length; c += 1) {
        var m = l(e[c]);
        Array.prototype.push.apply(g, m);
      }
      return Array.prototype.concat(k.Card16(b.length), k.OffSize(d), g, f);
    };
    n.INDEX = function(b) {
      return k.INDEX(b).length;
    };
    k.DICT = function(b) {
      for (var c = [], d = Object.keys(b), e = d.length, f = 0; e > f; f += 1) {
        var g = parseInt(d[f], 0), l = b[g];
        c = c.concat(k.OPERAND(l.value, l.type));
        c = c.concat(k.OPERATOR(g));
      }
      return c;
    };
    n.DICT = function(b) {
      return k.DICT(b).length;
    };
    k.OPERATOR = function(b) {
      return 1200 > b ? [b] : [12, b - 1200];
    };
    k.OPERAND = function(b, c) {
      var d = [];
      if (Array.isArray(c)) {
        for (var e = 0; e < c.length; e += 1) {
          f.argument(b.length === c.length, "Not enough arguments given for type" + c), d = d.concat(k.OPERAND(b[e], c[e]));
        }
      } else {
        if ("SID" === c) {
          d = d.concat(k.NUMBER(b));
        } else {
          if ("offset" === c) {
            d = d.concat(k.NUMBER32(b));
          } else {
            if ("number" === c) {
              d = d.concat(k.NUMBER(b));
            } else {
              if ("real" !== c) {
                throw Error("Unknown operand type " + c);
              }
              d = d.concat(k.REAL(b));
            }
          }
        }
      }
      return d;
    };
    k.OP = k.BYTE;
    n.OP = n.BYTE;
    var d = "function" == typeof WeakMap && new WeakMap;
    k.CHARSTRING = function(b) {
      if (d) {
        var c = d.get(b);
        if (void 0 !== c) {
          return c;
        }
      }
      c = [];
      for (var e = b.length, f = 0; e > f; f += 1) {
        var g = b[f];
        c = c.concat(k[g.type](g.value));
      }
      return d && d.set(b, c), c;
    };
    n.CHARSTRING = function(b) {
      return k.CHARSTRING(b).length;
    };
    k.OBJECT = function(b) {
      var c = k[b.type];
      return f.argument(void 0 !== c, "No encoding function for type " + b.type), c(b.value);
    };
    n.OBJECT = function(b) {
      var c = n[b.type];
      return f.argument(void 0 !== c, "No sizeOf function for type " + b.type), c(b.value);
    };
    k.TABLE = function(b) {
      var c, d = [], e = b.fields.length, g = [], l = [];
      for (c = 0; e > c; c += 1) {
        var m = b.fields[c], n = k[m.type];
        f.argument(void 0 !== n, "No encoding function for field type " + m.type + " (" + m.name + ")");
        var p = b[m.name];
        void 0 === p && (p = m.value);
        n = n(p);
        "TABLE" === m.type ? (l.push(d.length), d = d.concat([0, 0]), g.push(n)) : d = d.concat(n);
      }
      for (c = 0; c < g.length; c += 1) {
        e = l[c], m = d.length, f.argument(65536 > m, "Table " + b.tableName + " too big."), d[e] = m >> 8, d[e + 1] = 255 & m, d = d.concat(g[c]);
      }
      return d;
    };
    n.TABLE = function(b) {
      for (var c = 0, d = b.fields.length, e = 0; d > e; e += 1) {
        var g = b.fields[e], k = n[g.type];
        f.argument(void 0 !== k, "No sizeOf function for field type " + g.type + " (" + g.name + ")");
        var l = b[g.name];
        void 0 === l && (l = g.value);
        c += k(l);
        "TABLE" === g.type && (c += 2);
      }
      return c;
    };
    k.RECORD = k.TABLE;
    n.RECORD = n.TABLE;
    k.LITERAL = function(b) {
      return b;
    };
    n.LITERAL = function(b) {
      return b.length;
    };
    b.decode = c;
    b.encode = k;
    b.sizeOf = n;
  }, {"./check":2}], 33:[function(c, g, b) {
    b.isBrowser = function() {
      return "undefined" != typeof window;
    };
    b.isNode = function() {
      return "undefined" == typeof window;
    };
    b.nodeBufferToArrayBuffer = function(b) {
      for (var c = new ArrayBuffer(b.length), e = new Uint8Array(c), g = 0; g < b.length; ++g) {
        e[g] = b[g];
      }
      return c;
    };
    b.arrayBufferToNodeBuffer = function(b) {
      var c = new Buffer(b.byteLength);
      b = new Uint8Array(b);
      for (var e = 0; e < c.length; ++e) {
        c[e] = b[e];
      }
      return c;
    };
    b.checkArgument = function(b, c) {
      if (!b) {
        throw c;
      }
    };
  }, {}]}, {}, [9])(9);
});
"use strict";
function Nunu() {
}
Nunu.NAME = "nunuStudio";
Nunu.VERSION = "<PLACEHOLDER_VERSION>";
Nunu.TIMESTAMP = "<PLACEHOLDER_TIMESTAMP>";
Nunu.REPOSITORY_BRANCH = "<PLACEHOLDER_REPOSITORY_BRANCH>";
Nunu.REPOSITORY_COMMIT = "<PLACEHOLDER_REPOSITORY_COMMIT>";
Nunu.NWJS = 200;
Nunu.BROWSER = 201;
Nunu.CORDOVA = 202;
Nunu.developmentMode = function() {
  return "<PLACEHOLDER_TIMESTAMP>" === Nunu.TIMESTAMP;
};
Nunu.webvrAvailable = function() {
  return void 0 !== navigator.getVRDisplays;
};
Nunu.getVRDisplays = function(a) {
  void 0 === navigator.getVRDisplays ? console.warn("nunuStudio: WebVR is not supported.") : navigator.getVRDisplays().then(function(c) {
    0 < c.length ? a(c[0]) : console.warn("nunuStudio: WebVR supported but no display is available.");
  });
};
Nunu.getQueryParameters = function() {
  for (var a = location.search.substring(1).split("&"), c = {}, g = 0; g < a.length; g++) {
    var b = a[g].split("=");
    if (1 < b.length) {
      var e = unescape(b[0]).replace(/"/g, "");
      b = unescape(b[1]).replace(/"/g, "");
      c[e] = b;
    }
  }
  return c;
};
Nunu.createWorker = function(a, c) {
  a = new Blob([a], {type:"application/javascript"});
  a = new Worker(URL.createObjectURL(a));
  void 0 !== c && (a.onmessage = c);
  return a;
};
Nunu.webAudioAvailable = function() {
  return void 0 !== window.AudioContext || void 0 !== window.webkitAudioContext;
};
Nunu.webglAvailable = function() {
  try {
    var a = document.createElement("canvas");
    (a.getContext("webgl") || a.getContext("experimental-webgl")).getSupportedExtensions();
    return !0;
  } catch (c) {
  }
  return !1;
};
Nunu.getPlatform = function() {
  return void 0 !== window.nw ? Nunu.NWJS : void 0 !== window.cordova ? Nunu.CORDOVA : Nunu.BROWSER;
};
Nunu.runningOnDesktop = function() {
  return void 0 !== window.nw;
};
Nunu.openWebpage = function(a) {
  Nunu.runningOnDesktop() ? require("nw.gui").Shell.openExternal(a) : window.open(a);
};
Nunu.isFullscreen = function() {
  return !0 === document.webkitIsFullScreen || !0 === document.mozFullScreen || !0 === document.webkitIsFullScreen || !0 === document.webkitIsFullScreen || !0 === document.fullscreen || !1;
};
Nunu.setFullscreen = function(a, c) {
  var g = Nunu.isFullscreen();
  void 0 === a && (a = !g);
  !0 === a ? (void 0 === c && (c = document.body), !1 === g && (c.requestFullscreen = c.requestFullscreen || c.mozRequestFullScreen || c.webkitRequestFullscreen || c.msRequestFullscreen, void 0 !== c.requestFullscreen && c.requestFullscreen())) : !0 === g && (document.exitFullscreen = document.exitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen, void 0 !== document.exitFullscreen && document.exitFullscreen());
};
"use strict";
function importFrom(a) {
  for (var c in a) {
    c in window || (window[c] = a[c]);
  }
}
importFrom(THREE);
importFrom(CANNON);
importFrom(SPE);
"use strict";
function FileSystem() {
}
try {
  FileSystem.fs = require("fs");
} catch (a) {
}
FileSystem.isRemote = function(a) {
  return a.startsWith("http");
};
FileSystem.readFile = function(a, c, g, b, e) {
  void 0 === c && (c = !0);
  if (void 0 === FileSystem.fs || FileSystem.isRemote(a)) {
    var f = new XMLHttpRequest;
    f.overrideMimeType("text/plain");
    f.open("GET", a, !c);
    void 0 !== g && (f.onload = function() {
      g(f.response);
    });
    void 0 !== b && (f.onprogress = b);
    void 0 !== e && (f.onerror = e);
    f.send(null);
    return !0 === c ? f.response : null;
  }
  if (!0 === c) {
    return a = FileSystem.fs.readFileSync(a, "utf8"), void 0 !== g && g(a), a;
  }
  FileSystem.fs.readFile(a, "utf8", function(a, b) {
    null !== a ? void 0 !== e && e(a) : void 0 !== g && g(b);
  });
  return null;
};
FileSystem.readFileArrayBuffer = function(a, c, g, b, e) {
  void 0 === c && (c = !0);
  if (void 0 === FileSystem.fs || FileSystem.isRemote(a)) {
    var f = new XMLHttpRequest;
    f.open("GET", a, !c);
    f.overrideMimeType("text/plain; charset=x-user-defined");
    void 0 !== g && (f.onload = function() {
      g(ArraybufferUtils.fromBinaryString(f.response));
    });
    void 0 !== b && (f.onprogress = b);
    void 0 !== e && (f.onerror = e);
    f.send(null);
    return !0 === c ? ArraybufferUtils.fromBinaryString(f.response) : null;
  }
  if (!0 === c) {
    return a = FileSystem.fs.readFileSync(a), ArraybufferUtils.fromBuffer(a);
  }
  FileSystem.fs.readFile(a, function(a, b) {
    null !== a ? void 0 !== e && e(a) : void 0 !== g && g(ArraybufferUtils.fromBuffer(b));
  });
  return null;
};
FileSystem.readFileBase64 = function(a, c, g, b, e) {
  void 0 === c && (c = !0);
  if (void 0 === FileSystem.fs || FileSystem.isRemote(a)) {
    var f = new XMLHttpRequest;
    f.open("GET", a, !c);
    f.overrideMimeType("text/plain; charset=x-user-defined");
    void 0 !== g && (f.onload = function() {
      g(Base64Utils.fromBinaryString(f.response));
    });
    void 0 !== b && (f.onprogress = b);
    void 0 !== e && (f.onerror = e);
    f.send(null);
    return !0 === c ? Base64Utils.fromBinaryString(f.response) : null;
  }
  if (!0 === c) {
    return a = FileSystem.fs.readFileSync(a), (new Buffer(a)).toString("base64");
  }
  FileSystem.fs.readFile(a, function(a, b) {
    null !== a ? void 0 !== e && e(a) : void 0 !== g && g((new Buffer(b)).toString("base64"));
  });
  return null;
};
FileSystem.writeFile = function(a, c, g, b) {
  void 0 !== FileSystem.fs ? void 0 !== FileSystem.fs.writeFileSync ? !1 !== g ? (FileSystem.fs.writeFileSync(a, c, "utf8"), void 0 !== b && b()) : FileSystem.fs.writeFile(a, c, "utf8", b) : (a = FileSystem.fs.createWriteStream(a, "utf8"), a.write(c), a.end()) : (c = new Blob([c], {type:"octet/stream"}), g = document.createElement("a"), g.download = a, g.href = window.URL.createObjectURL(c), g.style.display = "none", g.onclick = function() {
    document.body.removeChild(this);
  }, document.body.appendChild(g), g.click(), void 0 !== b && b());
};
FileSystem.writeFileBase64 = function(a, c, g, b) {
  void 0 !== FileSystem.fs ? (c = Buffer.from(Base64Utils.removeHeader(c), "base64"), void 0 !== FileSystem.fs.writeFile ? !1 !== g ? (FileSystem.fs.writeFileSync(a, c), void 0 !== b && b()) : FileSystem.fs.writeFile(a, c, b) : (a = FileSystem.fs.createWriteStream(a), a.write(c), a.end())) : (g = ArraybufferUtils.fromBase64(Base64Utils.removeHeader(c)), g = new Blob([g]), c = document.createElement("a"), c.download = a, c.href = window.URL.createObjectURL(g), c.onclick = function() {
    document.body.removeChild(this);
  }, c.style.display = "none", document.body.appendChild(c), c.click(), void 0 !== b && b());
};
FileSystem.writeFileArrayBuffer = function(a, c, g, b) {
  void 0 !== FileSystem.fs ? (c = BufferUtils.fromArrayBuffer(c), void 0 !== FileSystem.fs.writeFileSync ? !1 !== g ? (FileSystem.fs.writeFileSync(a, c), void 0 !== b && b()) : FileSystem.fs.writeFile(a, c, b) : (a = FileSystem.fs.createWriteStream(a), a.write(c), a.end())) : (g = new Blob([c]), c = document.createElement("a"), c.download = a, c.href = window.URL.createObjectURL(g), c.onclick = function() {
    document.body.removeChild(this);
  }, c.style.display = "none", document.body.appendChild(c), c.click(), void 0 !== b && b());
};
FileSystem.chooseFile = function(a, c, g, b) {
  var e = document.createElement("input");
  e.type = "file";
  e.style.display = "none";
  document.body.appendChild(e);
  void 0 !== c && (e.accept = c);
  !0 === b && (e.multiple = !0);
  e.onchange = function(b) {
    void 0 !== a && a(e.files);
    document.body.removeChild(e);
  };
  void 0 !== g && (e.nwsaveas = !0 !== g ? g : "file");
  e.click();
};
FileSystem.chooseFileName = function(a, c, g) {
  g = prompt("Save As", void 0 !== g ? g : "file");
  null !== g && (void 0 === c || g.endsWith(c) || (g += c), void 0 !== a && a(g));
};
FileSystem.copyFile = function(a, c) {
  void 0 !== FileSystem.fs && (void 0 !== FileSystem.fs.copyFileSync ? FileSystem.fs.copyFileSync(a, c) : (a.replace(/\//g, "\\"), c.replace(/\//g, "\\"), FileSystem.fs.createReadStream(a).pipe(FileSystem.fs.createWriteStream(c))));
};
FileSystem.makeDirectory = function(a) {
  void 0 !== FileSystem.fs && (a.replace(/\//g, "\\"), FileSystem.fs.mkdirSync(a, {recursive:!0}));
};
FileSystem.getFilesDirectory = function(a) {
  if (void 0 !== FileSystem.fs) {
    try {
      return a.replace(/\//g, "\\"), FileSystem.fs.readdirSync(a);
    } catch (c) {
    }
  }
  return [];
};
FileSystem.deleteFolder = function(a) {
  void 0 !== FileSystem.fs && FileSystem.fs.existsSync(a) && (FileSystem.fs.readdirSync(a).forEach(function(c, g) {
    c = a + "/" + c;
    FileSystem.fs.lstatSync(c).isDirectory() ? FileSystem.deleteFolder(c) : FileSystem.fs.unlinkSync(c);
  }), FileSystem.fs.rmdirSync(a));
};
FileSystem.copyFolder = function(a, c) {
  if (void 0 !== FileSystem.fs) {
    a.replace(/\//g, "\\");
    c.replace(/\//g, "\\");
    FileSystem.makeDirectory(c);
    for (var g = FileSystem.fs.readdirSync(a), b = 0; b < g.length; b++) {
      var e = a + "\\" + g[b], f = c + "\\" + g[b], k = FileSystem.fs.statSync(e);
      k.isDirectory() ? FileSystem.copyFolder(e, f) : k.isSymbolicLink() ? FileSystem.fs.symlinkSync(FileSystem.fs.readlinkSync(e), f) : FileSystem.copyFile(e, f);
    }
  }
};
FileSystem.fileExists = function(a) {
  return void 0 !== FileSystem.fs ? (a.replace(/\//g, "\\"), FileSystem.fs.existsSync(a)) : !1;
};
FileSystem.getFileName = function(a) {
  if (void 0 !== a) {
    var c = a.lastIndexOf("\\"), g = a.lastIndexOf("/");
    return a.substring(c > g ? c + 1 : g + 1, a.lastIndexOf("."));
  }
  return "";
};
FileSystem.getFileNameWithExtension = function(a) {
  if (void 0 !== a) {
    var c = a.lastIndexOf("\\"), g = a.lastIndexOf("/");
    return a.substring(c > g ? c + 1 : g + 1, a.length);
  }
  return "";
};
FileSystem.getNameWithoutExtension = function(a) {
  return void 0 !== a ? a.substring(0, a.lastIndexOf(".")) : "";
};
FileSystem.getFilePath = function(a) {
  if (void 0 !== a) {
    var c = a.lastIndexOf("\\"), g = a.lastIndexOf("/");
    return a.substring(0, c > g ? c + 1 : g + 1);
  }
  return "";
};
FileSystem.getFileExtension = function(a) {
  return void 0 !== a ? a.substring(a.lastIndexOf(".") + 1, a.length).toLowerCase() : "";
};
"use strict";
THREE.KeyframeTrack.prototype.color = "#FF0000";
THREE.KeyframeTrack.prototype.setColor = function(a) {
  this.color = a;
};
THREE.KeyframeTrack.prototype.sort = function() {
  for (var a = 0; a < this.times.length; a++) {
    for (var c = a + 1; c < this.times.length; c++) {
      if (this.times[a] > this.times[c]) {
        var g = this.times[c];
        this.times[c] = this.times[a];
        this.times[a] = g;
        for (var b = this.getValueSize(), e = c * b, f = a * b, k = 0; k < b; k++) {
          g = this.values[e + k], this.values[e + k] = this.values[f + k], this.values[f + k] = g;
        }
      }
    }
  }
};
THREE.KeyframeTrack._toJSON = THREE.KeyframeTrack.toJSON;
THREE.KeyframeTrack.toJSON = function(a) {
  var c = THREE.KeyframeTrack._toJSON.call(this, a);
  c.color = a.color;
  return c;
};
THREE.KeyframeTrack._parse = THREE.KeyframeTrack.parse;
THREE.KeyframeTrack.parse = function(a) {
  var c = THREE.KeyframeTrack._parse.call(this, a);
  void 0 !== a.color && (c.color = a.color);
  return c;
};
"use strict";
THREE.AnimationClip.prototype.enabled = !0;
THREE.AnimationClip.prototype.loop = THREE.LoopRepeat;
THREE.AnimationClip.prototype.timeScale = 1;
THREE.AnimationClip.prototype.weight = 1;
THREE.AnimationClip._toJSON = THREE.AnimationClip.toJSON;
THREE.AnimationClip.toJSON = function(a) {
  var c = THREE.AnimationClip._toJSON.call(this, a);
  c.enabled = a.enabled;
  c.loop = a.loop;
  c.timeScale = a.timeScale;
  c.weight = a.weight;
  return c;
};
THREE.AnimationClip._parse = THREE.AnimationClip.parse;
THREE.AnimationClip.parse = function(a) {
  var c = THREE.AnimationClip._parse.call(this, a);
  void 0 !== a.enabled && (c.enabled = a.enabled, c.loop = a.loop, c.timeScale = a.timeScale, c.weight = a.weight);
  return c;
};
"use strict";
THREE.Object3D.prototype.folded = !1;
THREE.Object3D.prototype.locked = !1;
THREE.Object3D.prototype.contains = function(a) {
  for (var c = 0; c < this.children.length; c++) {
    if (this.children[c].uuid === a.uuid || this.children[c].contains(a)) {
      return !0;
    }
  }
  return !1;
};
THREE.Object3D.prototype.playAnimation = function() {
  void 0 !== this.mixer && this.mixer.play();
};
THREE.Object3D.prototype.stopAnimation = function() {
  void 0 !== this.mixer && this.mixer.stop();
};
THREE.Object3D.prototype.initialize = function() {
  void 0 !== this.animations && (this.mixer = new AnimationMixer(this), this.mixer.createActions(this.animations), this.mixer.play());
};
THREE.Object3D.prototype.update = function(a) {
  void 0 !== this.mixer && this.mixer.update(a);
};
THREE.Object3D.prototype.resize = function(a, c) {
};
THREE.Object3D.prototype.dispose = function() {
  void 0 !== this.mixer && this.mixer.dispose();
};
THREE.Object3D.prototype.addAbove = function(a, c) {
  if (a === this) {
    return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this;
  }
  a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({type:"added"}), c = this.children.indexOf(c), this.children.splice(c, 0, a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a);
  return this;
};
THREE.Object3D.prototype.addBellow = function(a, c) {
  if (a === this) {
    return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this;
  }
  a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({type:"added"}), c = this.children.indexOf(c) + 1, this.children.splice(c, 0, a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a);
  return this;
};
THREE.Object3D.prototype.getScene = function() {
  for (var a = this; null !== a.parent;) {
    if (a = a.parent, a instanceof Scene) {
      return a;
    }
  }
  return null;
};
THREE.Object3D.prototype.removeAll = function() {
  for (; 0 < this.children.length;) {
    this.remove(this.children[0]);
  }
};
THREE.Object3D.prototype.isEmpty = function() {
  return 0 === this.children.length;
};
THREE.Object3D.prototype.destroy = function() {
  for (; 0 < this.children.length;) {
    this.children[0].destroy();
  }
  null !== this.parent && (this.dispose && this.dispose(), this.parent.remove(this), this.parent = null);
};
THREE.Object3D.prototype.toJSON = function(a, c, g) {
  function b(b, c) {
    void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a));
    return c.uuid;
  }
  function e(a) {
    var b = [], c;
    for (c in a) {
      var d = a[c];
      delete d.metadata;
      b.push(d);
    }
    return b;
  }
  var f = void 0 === a, k = {};
  f && (a = new ResourceManager.ResourceContainer, k.metadata = {version:Nunu.VERSION, type:"NunuProgram"});
  var n = {};
  n.uuid = this.uuid;
  n.type = this.type;
  n.name = this.name;
  n.folded = this.folded;
  n.locked = this.locked;
  n.castShadow = this.castShadow;
  n.receiveShadow = this.receiveShadow;
  n.visible = this.visible;
  n.matrixAutoUpdate = this.matrixAutoUpdate;
  n.frustumCulled = this.frustumCulled;
  n.renderOrder = this.renderOrder;
  n.position = this.position.toArray();
  n.quaternion = this.quaternion.toArray();
  n.scale = this.scale.toArray();
  "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData);
  if (void 0 !== this.geometry) {
    n.geometry = b(a.geometries, this.geometry);
    var p = this.geometry.parameters;
    if (void 0 !== p && void 0 !== p.shapes) {
      var m = p.shapes;
      if (Array.isArray(m)) {
        p = 0;
        for (var t = m.length; p < t; p++) {
          b(a.shapes, m[p]);
        }
      } else {
        b(a.shapes, m);
      }
    }
  }
  if (void 0 !== this.material) {
    if (this.material instanceof THREE.Material) {
      n.material = b(a.materials, this.material);
    } else {
      if (this.material instanceof Array) {
        m = [];
        for (p = 0; p < this.material.length; p++) {
          m.push(b(a.materials, this.material[p]));
        }
        n.material = m;
      }
    }
  }
  if (void 0 !== this.animations && 0 < this.animations.length) {
    for (n.animations = [], p = 0; p < this.animations.length; p++) {
      n.animations.push(THREE.AnimationClip.toJSON(this.animations[p]));
    }
  }
  void 0 !== c && c(a, n);
  if (!1 !== g && 0 < this.children.length) {
    for (n.children = [], p = 0; p < this.children.length; p++) {
      this.children[p].locked || n.children.push(this.children[p].toJSON(a).object);
    }
  }
  f && (k.geometries = e(a.geometries), k.materials = e(a.materials), k.textures = e(a.textures), k.images = e(a.images), k.videos = e(a.videos), k.audio = e(a.audio), k.fonts = e(a.fonts), k.skeletons = e(a.skeletons), k.resources = e(a.resources), k.shapes = e(a.shapes));
  k.object = n;
  return k;
};
"use strict";
THREE.BufferGeometry.prototype.computeBoundingSphere = function() {
  var a = new THREE.Box3, c = new THREE.Vector3;
  return function() {
    null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
    var g = this.attributes.position;
    if (g) {
      var b = this.boundingSphere.center;
      a.setFromBufferAttribute(g);
      a.getCenter(b);
      var e = 0;
      g = g.array;
      for (var f = g.length, k = 0; k < f; k += 3) {
        c.set(g[k], g[k + 1], g[k + 2]);
        var n = b.distanceToSquared(c);
        n > e && (e = n);
      }
      this.boundingSphere.radius = Math.sqrt(e);
    }
  };
}();
THREE.BufferGeometry.prototype.toJSON = function() {
  var a = {metadata:{version:4.5, type:"BufferGeometry", generator:"BufferGeometry.toJSON"}};
  a.uuid = this.uuid;
  a.type = this.type;
  a.name = this.name;
  if (void 0 !== this.parameters) {
    var c = this.parameters;
    for (k in c) {
      void 0 !== c[k] && (a[k] = c[k]);
    }
    return a;
  }
  a.data = {attributes:{}, morphAttributes:{}};
  var g = this.index;
  null !== g && (c = Array.prototype.slice.call(g.array), a.data.index = {type:g.array.constructor.name, array:c});
  var b = this.attributes;
  for (k in b) {
    g = b[k], c = Array.prototype.slice.call(g.array), a.data.attributes[k] = {itemSize:g.itemSize, type:g.array.constructor.name, array:c, normalized:g.normalized};
  }
  c = this.morphAttributes;
  for (k in c) {
    b = this.morphAttributes[k];
    c = [];
    for (var e = 0, f = b.length; e < f; e++) {
      g = b[e], c.push({name:g.name, itemSize:g.itemSize, type:g.array.constructor.name, array:Array.prototype.slice.call(g.array), normalized:g.normalized});
    }
    a.data.morphAttributes[k] = c;
  }
  var k = this.groups;
  0 < k.length && (a.data.groups = JSON.parse(JSON.stringify(k)));
  k = this.boundingSphere;
  null !== k && (a.data.boundingSphere = {center:k.center.toArray(), radius:k.radius});
  return a;
};
"use strict";
THREE.Camera.prototype.render = function(a, c) {
  a.render(c, this);
};
"use strict";
THREE.Material.prototype.dispose = function() {
  function a(a) {
    void 0 !== a && null !== a && a.dispose();
  }
  this.dispatchEvent({type:"dispose"});
  a(this.map);
  a(this.bumpMap);
  a(this.normalMap);
  a(this.displacementMap);
  a(this.specularMap);
  a(this.emissiveMap);
  a(this.alphaMap);
  a(this.roughnessMap);
  a(this.metalnessMap);
  a(this.envMap);
};
THREE.Material.prototype.toJSON = function(a) {
  function c(a) {
    var b = [], c;
    for (c in a) {
      var e = a[c];
      delete e.metadata;
      b.push(e);
    }
    return b;
  }
  void 0 === a && (a = {textures:{}, images:{}, videos:{}});
  var g = {};
  g.uuid = this.uuid;
  g.type = this.type;
  g.name = this.name;
  g.depthFunc = this.depthFunc;
  g.depthTest = this.depthTest;
  g.depthWrite = this.depthWrite;
  this.color && this.color.isColor && (g.color = this.color.getHex());
  void 0 !== this.roughness && (g.roughness = this.roughness);
  void 0 !== this.metalness && (g.metalness = this.metalness);
  this.specular && this.specular.isColor && (g.specular = this.specular.getHex());
  void 0 !== this.shininess && (g.shininess = this.shininess);
  void 0 !== this.clearCoat && (g.clearCoat = this.clearCoat);
  void 0 !== this.clearCoatRoughness && (g.clearCoatRoughness = this.clearCoatRoughness);
  this.map && this.map.isTexture && (g.map = this.map.toJSON(a).uuid);
  this.alphaMap && this.alphaMap.isTexture && (g.alphaMap = this.alphaMap.toJSON(a).uuid);
  this.lightMap && this.lightMap.isTexture && (g.lightMap = this.lightMap.toJSON(a).uuid);
  this.bumpMap && this.bumpMap.isTexture && (g.bumpMap = this.bumpMap.toJSON(a).uuid, g.bumpScale = this.bumpScale);
  this.normalMap && this.normalMap.isTexture && (g.normalMap = this.normalMap.toJSON(a).uuid, g.normalMapType = this.normalMapType, g.normalScale = this.normalScale.toArray());
  this.displacementMap && this.displacementMap.isTexture && (g.displacementMap = this.displacementMap.toJSON(a).uuid, g.displacementScale = this.displacementScale, g.displacementBias = this.displacementBias);
  this.roughnessMap && this.roughnessMap.isTexture && (g.roughnessMap = this.roughnessMap.toJSON(a).uuid);
  this.metalnessMap && this.metalnessMap.isTexture && (g.metalnessMap = this.metalnessMap.toJSON(a).uuid);
  this.emissive && this.emissive.isColor && (g.emissive = this.emissive.getHex());
  1 !== this.emissiveIntensity && (g.emissiveIntensity = this.emissiveIntensity);
  this.matcap && this.matcap.isTexture && (g.matcap = this.matcap.toJSON(a).uuid);
  this.emissiveMap && this.emissiveMap.isTexture && (g.emissiveMap = this.emissiveMap.toJSON(a).uuid);
  this.aoMap && this.aoMap.isTexture && (g.aoMap = this.aoMap.toJSON(a).uuid);
  this.aoMapIntensity && (g.aoMapIntensity = this.aoMapIntensity);
  this.specularMap && this.specularMap.isTexture && (g.specularMap = this.specularMap.toJSON(a).uuid);
  this.envMap && this.envMap.isTexture && (g.envMap = this.envMap.toJSON(a).uuid, g.reflectivity = this.reflectivity, this.combine && (g.combine = this.combine), this.envMapIntensity && (g.envMapIntensity = this.envMapIntensity), this.refractionRatio && (g.refractionRatio = this.refractionRatio));
  this.gradientMap && this.gradientMap.isTexture && (g.gradientMap = this.gradientMap.toJSON(a).uuid);
  void 0 !== this.size && (g.size = this.size);
  void 0 !== this.sizeAttenuation && (g.sizeAttenuation = this.sizeAttenuation);
  void 0 !== this.rotation && (g.rotation = this.rotation);
  void 0 !== this.linewidth && (g.linewidth = this.linewidth);
  void 0 !== this.dashSize && (g.dashSize = this.dashSize);
  void 0 !== this.gapSize && (g.gapSize = this.gapSize);
  void 0 !== this.scale && (g.scale = this.scale);
  this.blending !== THREE.NormalBlending && (g.blending = this.blending);
  this.side !== THREE.FrontSide && (g.side = this.side);
  this.vertexColors !== THREE.NoColors && (g.vertexColors = this.vertexColors);
  g.flatShading = this.flatShading;
  1 > this.opacity && (g.opacity = this.opacity);
  !0 === this.transparent && (g.transparent = this.transparent);
  !0 === this.dithering && (g.dithering = !0);
  0 < this.alphaTest && (g.alphaTest = this.alphaTest);
  !0 === this.premultipliedAlpha && (g.premultipliedAlpha = this.premultipliedAlpha);
  !0 === this.wireframe && (g.wireframe = this.wireframe);
  1 < this.wireframeLinewidth && (g.wireframeLinewidth = this.wireframeLinewidth);
  "round" !== this.wireframeLinecap && (g.wireframeLinecap = this.wireframeLinecap);
  "round" !== this.wireframeLinejoin && (g.wireframeLinejoin = this.wireframeLinejoin);
  g.skinning = this.skinning;
  g.morphTargets = this.morphTargets;
  void 0 !== this.morphNormals && (g.morphNormals = this.morphNormals);
  if (void 0 === a) {
    var b = c(a.textures), e = c(a.images);
    a = c(a.videos);
    0 < b.length && (g.textures = b);
    0 < e.length && (g.images = e);
    0 < a.length && (g.videos = a);
  }
  return g;
};
"use strict";
THREE.BufferGeometryLoader.prototype.parse = function(a) {
  var c = {Int8Array:Int8Array, Uint8Array:Uint8Array, Uint8ClampedArray:Uint8ClampedArray, Int16Array:Int16Array, Uint16Array:Uint16Array, Int32Array:Int32Array, Uint32Array:Uint32Array, Float32Array:Float32Array, Float64Array:Float64Array}, g = new THREE.BufferGeometry, b = a.data.index;
  if (void 0 !== b) {
    var e = new c[b.type](b.array);
    g.setIndex(new THREE.BufferAttribute(e, 1));
  }
  b = a.data.attributes;
  for (var f in b) {
    var k = b[f];
    e = new c[k.type](k.array);
    g.addAttribute(f, new THREE.BufferAttribute(e, k.itemSize, k.normalized));
  }
  var n = a.data.morphAttributes;
  for (f in n) {
    var p = n[f], m = [];
    b = 0;
    for (var t = p.length; b < t; b++) {
      k = p[b], e = new c[k.type](k.array), e = new THREE.BufferAttribute(e, k.itemSize, k.normalized), void 0 !== k.name && (e.name = k.name), m.push(e);
    }
    g.morphAttributes[f] = m;
  }
  c = a.data.groups || a.data.drawcalls || a.data.offsets;
  if (void 0 !== c) {
    for (b = 0, f = c.length; b !== f; ++b) {
      k = c[b], g.addGroup(k.start, k.count, k.materialIndex);
    }
  }
  a = a.data.boundingSphere;
  void 0 !== a && (b = new THREE.Vector3, void 0 !== a.center && b.fromArray(a.center), g.boundingSphere = new THREE.Sphere(b, a.radius));
  return g;
};
"use strict";
THREE.Texture.prototype.toJSON = function(a) {
  if (void 0 !== a.textures[this.uuid]) {
    return a.textures[this.uuid];
  }
  var c = {metadata:{version:Nunu.VERSION, type:"Texture"}, uuid:this.uuid, name:this.name, category:this.category, format:this.format, mapping:this.mapping, repeat:[this.repeat.x, this.repeat.y], offset:[this.offset.x, this.offset.y], center:[this.center.x, this.center.y], rotation:this.rotation, wrap:[this.wrapS, this.wrapT], minFilter:this.minFilter, magFilter:this.magFilter, anisotropy:this.anisotropy, flipY:this.flipY};
  return a.textures[this.uuid] = c;
};
"use strict";
THREE.LightShadow.prototype.toJSON = function() {
  var a = {};
  a.bias = this.bias;
  a.radius = this.radius;
  a.mapSize = {};
  a.mapSize.x = this.mapSize.x;
  a.mapSize.y = this.mapSize.y;
  a.camera = {};
  a.camera.top = this.camera.top;
  a.camera.bottom = this.camera.bottom;
  a.camera.far = this.camera.far;
  a.camera.near = this.camera.near;
  a.camera.left = this.camera.left;
  a.camera.right = this.camera.right;
  return a;
};
THREE.LightShadow.prototype.fromJSON = function(a) {
  void 0 !== a.bias && (this.bias = a.bias);
  void 0 !== a.radius && (this.radius = a.radius);
  if (void 0 !== a.mapSize) {
    var c = a.mapSize;
    this.mapSize.set(c.x, c.y);
  }
  void 0 !== a.camera && (a = a.camera, this.camera.top = a.top, this.camera.bottom = a.bottom, this.camera.left = a.left, this.camera.right = a.right, this.camera.near = a.near, this.camera.far = a.far);
};
"use strict";
THREE.Fog.NONE = 0;
THREE.Fog.LINEAR = 1;
THREE.Fog.EXPONENTIAL = 2;
"use strict";
THREE.Points.prototype.raycast = function(a, c) {
  null === this.geometry.boundingBox && this.geometry.computeBoundingBox();
  var g = new THREE.Box3;
  g.copy(this.geometry.boundingBox);
  g.applyMatrix4(this.matrixWorld);
  null !== a.ray.intersectBox(g, new THREE.Vector3) && c.push({object:this});
};
"use strict";
function AnimationMixer(a) {
  THREE.AnimationMixer.call(this, a);
  this.playing = !1;
}
AnimationMixer.prototype = Object.create(THREE.AnimationMixer.prototype);
AnimationMixer.prototype.createActions = function(a) {
  for (var c = 0; c < a.length; c++) {
    var g = this.clipAction(a[c]);
    g.setLoop(a[c].loop);
    g.weight = a[c].weight;
    g.timeScale = a[c].timeScale;
    g.enabled = a[c].enabled;
    g.play();
  }
  return this._actions;
};
AnimationMixer.prototype.setTime = function(a) {
  this.time = a;
  for (var c = 0; c < this._actions.length; c++) {
    this._actions[c].time = a;
  }
  this.update(0, !0);
};
AnimationMixer.prototype.play = function() {
  this.playing = !0;
};
AnimationMixer.prototype.stop = function() {
  this.setTime(0);
  this.playing = !1;
};
AnimationMixer.prototype.pause = function() {
  this.playing = !1;
};
AnimationMixer.prototype.dispose = function() {
  this.stopAllAction();
  this.uncacheRoot(this._root);
};
AnimationMixer.prototype.update = function(a, c) {
  if (this.playing || c) {
    this.time += a;
    c = Math.sign(a);
    for (var g = 0; g < this._actions.length; g++) {
      this._actions[g]._update(this.time, a, c, this._accuIndex);
    }
    for (g = 0; g < this._bindings.length; g++) {
      this._bindings[g].apply(this._accuIndex);
    }
  }
  return this;
};
"use strict";
function Key() {
  this.justReleased = this.justPressed = this.pressed = !1;
}
Key.DOWN = -1;
Key.UP = 1;
Key.RESET = 0;
Key.prototype.constructor = Key;
Key.prototype.update = function(a) {
  this.justReleased = this.justPressed = !1;
  a === Key.DOWN ? (!1 === this.pressed && (this.justPressed = !0), this.pressed = !0) : a === Key.UP ? (this.pressed && (this.justReleased = !0), this.pressed = !1) : a === Key.RESET && (this.justPressed = this.justReleased = !1);
};
Key.prototype.set = function(a, c, g) {
  this.justPressed = a;
  this.pressed = c;
  this.justReleased = g;
};
Key.prototype.reset = function() {
  this.justReleased = this.pressed = this.justPressed = !1;
};
"use strict";
function Keyboard(a) {
  this.keys = [];
  this.actions = [];
  var c = this, g = this.actions;
  this.events = new EventManager;
  this.events.add(window, "keydown", function(a) {
    g.push(a.keyCode);
    g.push(Key.DOWN);
  });
  this.events.add(window, "keyup", function(a) {
    g.push(a.keyCode);
    g.push(Key.UP);
  });
  this.events.add(window, "focus", function(a) {
    c.reset();
  });
  !0 !== a && this.create();
}
Keyboard.prototype = Keyboard;
Keyboard.prototype.constructor = Keyboard;
Keyboard.update = function() {
  for (var a = 0; this.actions.length > a;) {
    var c = this.actions.shift(), g = this.actions.shift();
    void 0 === this.keys[c] && (this.keys[c] = new Key);
    this.keys[c].update(g);
    if (this.keys[c].justReleased || this.keys[c].justPressed) {
      this.actions.push(c), this.actions.push(Key.RESET), a += 2;
    }
  }
};
Keyboard.reset = function() {
  for (var a = 0; a < this.keys.length; a++) {
    void 0 !== this.keys[a] && this.keys[a].reset();
  }
};
Keyboard.keyPressed = function(a) {
  return void 0 !== this.keys[a] && this.keys[a].pressed;
};
Keyboard.keyJustPressed = function(a) {
  return void 0 !== this.keys[a] && this.keys[a].justPressed;
};
Keyboard.keyJustReleased = function(a) {
  return void 0 !== this.keys[a] && this.keys[a].justReleased;
};
Keyboard.create = function() {
  this.events.create();
};
Keyboard.dispose = function() {
  this.events.destroy();
};
Keyboard.TAB = 9;
Keyboard.ENTER = 13;
Keyboard.SHIFT = 16;
Keyboard.CTRL = 17;
Keyboard.ALT = 18;
Keyboard.CAPS_LOCK = 20;
Keyboard.ESC = 27;
Keyboard.SPACEBAR = 32;
Keyboard.PAGE_UP = 33;
Keyboard.PAGE_DOWN = 34;
Keyboard.END = 35;
Keyboard.HOME = 36;
Keyboard.INSERT = 45;
Keyboard.DEL = 46;
Keyboard.LEFT = 37;
Keyboard.RIGHT = 39;
Keyboard.UP = 38;
Keyboard.DOWN = 40;
Keyboard.NUM0 = 48;
Keyboard.NUM1 = 49;
Keyboard.NUM2 = 50;
Keyboard.NUM3 = 51;
Keyboard.NUM4 = 52;
Keyboard.NUM5 = 53;
Keyboard.NUM6 = 54;
Keyboard.NUM7 = 55;
Keyboard.NUM8 = 56;
Keyboard.NUM9 = 57;
Keyboard.A = 65;
Keyboard.B = 66;
Keyboard.C = 67;
Keyboard.D = 68;
Keyboard.E = 69;
Keyboard.F = 70;
Keyboard.G = 71;
Keyboard.H = 72;
Keyboard.I = 73;
Keyboard.J = 74;
Keyboard.K = 75;
Keyboard.L = 76;
Keyboard.M = 77;
Keyboard.N = 78;
Keyboard.O = 79;
Keyboard.P = 80;
Keyboard.Q = 81;
Keyboard.R = 82;
Keyboard.S = 83;
Keyboard.T = 84;
Keyboard.U = 85;
Keyboard.V = 86;
Keyboard.W = 87;
Keyboard.X = 88;
Keyboard.Y = 89;
Keyboard.Z = 90;
Keyboard.F1 = 112;
Keyboard.F2 = 113;
Keyboard.F3 = 114;
Keyboard.F4 = 115;
Keyboard.F5 = 116;
Keyboard.F6 = 117;
Keyboard.F7 = 118;
Keyboard.F8 = 119;
Keyboard.F9 = 120;
Keyboard.F10 = 121;
Keyboard.F11 = 122;
Keyboard.F12 = 123;
"use strict";
function TizenKeyboard() {
}
TizenKeyboard.ARROW_LEFT = 37;
TizenKeyboard.ARROW_UP = 38;
TizenKeyboard.ARROW_RIGHT = 39;
TizenKeyboard.ARROW_DOWN = 40;
TizenKeyboard.ENTER = 13;
TizenKeyboard.BACK = 10009;
TizenKeyboard.VOLUME_UP = 447;
TizenKeyboard.VOLUME_DOWN = 448;
TizenKeyboard.VOLUME_MUTE = 449;
TizenKeyboard.CHANNEL_UP = 427;
TizenKeyboard.CHANNEL_DOWN = 428;
TizenKeyboard.F0_RED = 403;
TizenKeyboard.F1_GREEN = 404;
TizenKeyboard.F2_YELLOW = 405;
TizenKeyboard.F3_BLUE = 406;
TizenKeyboard.NUM_0 = 48;
TizenKeyboard.NUM_1 = 49;
TizenKeyboard.NUM_2 = 50;
TizenKeyboard.NUM_3 = 51;
TizenKeyboard.NUM_4 = 52;
TizenKeyboard.NUM_5 = 53;
TizenKeyboard.NUM_6 = 54;
TizenKeyboard.NUM_7 = 55;
TizenKeyboard.NUM_8 = 56;
TizenKeyboard.NUM_9 = 57;
TizenKeyboard.MINUS = 189;
TizenKeyboard.E_MANUAL = 10146;
TizenKeyboard.PREVIOUS_CHANNEL = 10190;
TizenKeyboard.PICTURE_SIZE = 10140;
TizenKeyboard.SOCCER = 10228;
TizenKeyboard.TELETEXT = 10200;
TizenKeyboard.SEARCH = 10225;
TizenKeyboard.GUIDE = 458;
TizenKeyboard.SOURCE = 10072;
TizenKeyboard.EXTRA = 10253;
TizenKeyboard.MTS = 10195;
TizenKeyboard.MEDIA_PLAY_PAUSE = 10252;
TizenKeyboard.MENU = 18;
TizenKeyboard.MEDIA_REWIND = 412;
TizenKeyboard.TOOLS = 10135;
TizenKeyboard.MEDIA_FAST_FORWARD = 417;
TizenKeyboard.INFO = 457;
TizenKeyboard.MEDIA_PLAY = 415;
TizenKeyboard.EXIT = 10182;
TizenKeyboard.MEDIA_PAUSE = 19;
TizenKeyboard.MEDIA_STOP = 413;
TizenKeyboard.CAPTION = 10221;
TizenKeyboard.MEDIA_RECORD = 416;
TizenKeyboard.CHANNEL_LIST = 10073;
TizenKeyboard.MEDIA_TRACK_PREVIOUS = 10232;
TizenKeyboard.MEDIA_TRACK_NEXT = 10233;
TizenKeyboard.MEDIA_3D = 10199;
"use strict";
function Mouse(a, c) {
  this._keys = Array(5);
  this._position = new THREE.Vector2(0, 0);
  this._positionUpdated = !1;
  this._delta = new THREE.Vector2(0, 0);
  this._wheel = 0;
  this._wheelUpdated = !1;
  this._doubleClicked = Array(5);
  this.keys = Array(5);
  this.position = new THREE.Vector2(0, 0);
  this.delta = new THREE.Vector2(0, 0);
  this.wheel = 0;
  this.doubleClicked = Array(5);
  this.domElement = void 0 !== a ? a : window;
  this.canvas = null;
  this.events = new EventManager;
  for (a = 0; 5 > a; a++) {
    this._doubleClicked[a] = !1, this.doubleClicked[a] = !1, this._keys[a] = new Key, this.keys[a] = new Key;
  }
  var g = this;
  void 0 !== window.onmousewheel ? this.events.add(this.domElement, "mousewheel", function(a) {
    g._wheel = a.deltaY;
    g._wheelUpdated = !0;
  }) : void 0 !== window.addEventListener ? this.events.add(this.domElement, "DOMMouseScroll", function(a) {
    g._wheel = 30 * a.detail;
    g._wheelUpdated = !0;
  }) : this.events.add(this.domElement, "wheel", function(a) {
    g._wheel = a.deltaY;
    g._wheelUpdated = !0;
  });
  if (void 0 !== window.ontouchstart || 0 < navigator.msMaxTouchPoints) {
    var b = new Vector2(0, 0);
    this.events.add(this.domElement, "touchstart", function(a) {
      a = a.touches[0];
      g.updatePosition(a.clientX, a.clientY, 0, 0);
      g.updateKey(Mouse.LEFT, Key.DOWN);
      b.set(a.clientX, a.clientY);
    });
    this.events.add(this.domElement, "touchend", function(a) {
      g.updateKey(Mouse.LEFT, Key.UP);
    });
    this.events.add(this.domElement, "touchcancel", function(a) {
      g.updateKey(Mouse.LEFT, Key.UP);
    });
    this.events.add(document.body, "touchmove", function(a) {
      a = a.touches[0];
      g.updatePosition(a.clientX, a.clientY, a.clientX - b.x, a.clientY - b.y);
      b.set(a.clientX, a.clientY);
    });
  }
  this.events.add(this.domElement, "mousemove", function(a) {
    g.updatePosition(a.clientX, a.clientY, a.movementX, a.movementY);
  });
  this.events.add(this.domElement, "mousedown", function(a) {
    g.updateKey(a.which - 1, Key.DOWN);
  });
  this.events.add(this.domElement, "mouseup", function(a) {
    g.updateKey(a.which - 1, Key.UP);
  });
  this.events.add(this.domElement, "dragstart", function(a) {
    g.updateKey(a.which - 1, Key.UP);
  });
  this.events.add(this.domElement, "dblclick", function(a) {
    g._doubleClicked[a.which - 1] = !0;
  });
  !0 !== c && this.create();
}
Mouse.prototype = Mouse;
Mouse.prototype.constructor = Mouse;
Mouse.LEFT = 0;
Mouse.MIDDLE = 1;
Mouse.RIGHT = 2;
Mouse.BACK = 3;
Mouse.FORWARD = 4;
Mouse.setCanvas = function(a) {
  this.canvas = a;
  a.mouseInside = !1;
  a.addEventListener("mouseenter", function() {
    this.mouseInside = !0;
  });
  a.addEventListener("mouseleave", function() {
    this.mouseInside = !1;
  });
};
Mouse.insideCanvas = function() {
  return null !== this.canvas && this.canvas.mouseInside;
};
Mouse.setLock = function(a) {
  null !== this.canvas && (a ? this.canvas.requestPointerLock ? this.canvas.requestPointerLock() : this.canvas.mozRequestPointerLock ? this.canvas.mozRequestPointerLock() : this.canvas.webkitRequestPointerLock && this.canvas.webkitRequestPointerLock() : document.exitPointerLock ? document.exitPointerLock() : document.mozExitPointerLock ? document.mozExitPointerLock() : document.webkitExitPointerLock && document.webkitExitPointerLock());
};
Mouse.buttonPressed = function(a) {
  return this.keys[a].pressed;
};
Mouse.buttonDoubleClicked = function(a) {
  return this.doubleClicked[a];
};
Mouse.buttonJustPressed = function(a) {
  return this.keys[a].justPressed;
};
Mouse.buttonJustReleased = function(a) {
  return this.keys[a].justReleased;
};
Mouse.updatePosition = function(a, c, g, b) {
  if (null !== this.canvas) {
    var e = this.canvas.getBoundingClientRect();
    a -= e.left;
    c -= e.top;
  }
  this._position.set(a, c);
  this._delta.x += g;
  this._delta.y += b;
  this._positionUpdated = !0;
};
Mouse.updateKey = function(a, c) {
  -1 < a && this._keys[a].update(c);
};
Mouse.update = function() {
  for (var a = 0; 5 > a; a++) {
    this._keys[a].justPressed && this.keys[a].justPressed && (this._keys[a].justPressed = !1), this._keys[a].justReleased && this.keys[a].justReleased && (this._keys[a].justReleased = !1), this.keys[a].set(this._keys[a].justPressed, this._keys[a].pressed, this._keys[a].justReleased), !0 === this._doubleClicked[a] ? (this.doubleClicked[a] = !0, this._doubleClicked[a] = !1) : this.doubleClicked[a] = !1;
  }
  this._wheelUpdated ? (this.wheel = this._wheel, this._wheelUpdated = !1) : this.wheel = 0;
  this._positionUpdated ? (this.delta.copy(this._delta), this.position.copy(this._position), this._delta.set(0, 0), this._positionUpdated = !1) : (this.delta.x = 0, this.delta.y = 0);
};
Mouse.create = function() {
  this.events.create();
};
Mouse.dispose = function() {
  this.events.destroy();
};
"use strict";
function Gamepad() {
  this.product = this.vendor = -1;
  this.connected = !1;
  this.gamepad = null;
  this.buttons = [];
  for (var a = navigator.getGamepads(), c = 0; c < a.length; c++) {
    if (null !== a[c]) {
      this.setGamepad(a[c]);
      break;
    }
  }
  null === this.gamepad && console.warn("nunuStudio: No gamepad found");
}
Gamepad.prototype.setGamepad = function(a) {
  if (void 0 !== a && null !== a) {
    this.index = a.index;
    this.gamepad = a;
    this.buttons = [];
    for (var c = 0; c < a.buttons.length; c++) {
      this.buttons.push(new Key);
    }
    this.setProductVendor(a);
    this.connected = !0;
  } else {
    console.warn("nunuStudio: No gamepad found"), this.disconnect();
  }
};
Gamepad.prototype.disconnect = function() {
  this.product = this.vendor = -1;
  this.connected = !1;
  this.gamepad = null;
  this.buttons = [];
};
Gamepad.prototype.setProductVendor = function(a) {
  try {
    var c = a.id.split(":");
    this.vendor = c[1].split(" ")[1];
    this.product = c[2].replace(" ", "").replace(")", "");
    return;
  } catch (g) {
  }
  try {
    c = a.id.split("-"), this.vendor = c[0], this.product = c[1];
  } catch (g) {
  }
};
Gamepad.prototype.update = function(a) {
  this.gamepad = navigator.getGamepads()[this.index];
  if (void 0 !== this.gamepad) {
    for (a = 0; a < this.buttons.length; a++) {
      this.buttons[a].update(this.gamepad.buttons[a].pressed ? Key.DOWN : Key.UP);
    }
  }
};
Gamepad.prototype.getAnalogueButton = function(a) {
  return a > this.buttons.length || 0 > a ? 0 : this.gamepad.buttons[a].value;
};
Gamepad.prototype.getAxis = function(a) {
  return a > this.gamepad.axes.length || 0 > a ? 0 : this.gamepad.axes[a];
};
Gamepad.prototype.buttonExists = function(a) {
  return 0 <= a && a < this.buttons.length;
};
Gamepad.prototype.buttonPressed = function(a) {
  return this.buttons[a] ? this.buttons[a].pressed : !1;
};
Gamepad.prototype.buttonJustPressed = function(a) {
  return this.buttons[a] ? this.buttons[a].justPressed : !1;
};
Gamepad.prototype.buttonJustReleased = function(a) {
  return this.buttons[a] ? this.buttons[a].justReleased : !1;
};
Gamepad.LEFT = 14;
Gamepad.RIGHT = 15;
Gamepad.DOWN = 13;
Gamepad.UP = 12;
Gamepad.SELECT = 8;
Gamepad.START = 9;
Gamepad.HOME = 16;
Gamepad.LEFT_TRIGGER_A = 4;
Gamepad.LEFT_TRIGGER_B = 6;
Gamepad.RIGHT_TRIGGER_A = 5;
Gamepad.RIGHT_TRIGGER_B = 7;
Gamepad.L1 = 4;
Gamepad.L2 = 6;
Gamepad.L3 = 6;
Gamepad.R1 = 5;
Gamepad.R2 = 7;
Gamepad.R3 = 11;
Gamepad.A = 0;
Gamepad.B = 1;
Gamepad.C = 2;
Gamepad.D = 3;
Gamepad.X = 2;
Gamepad.Y = 3;
Gamepad.LEFT_ANALOGUE_BUT = 10;
Gamepad.LEFT_ANALOGUE_HOR = 0;
Gamepad.LEFT_ANALOGUE_VERT = 1;
Gamepad.RIGHT_ANALOGUE_BUT = 11;
Gamepad.RIGHT_ANALOGUE_HOR = 2;
Gamepad.RIGHT_ANALOGUE_VERT = 3;
"use strict";
function Gyroscope() {
  this.orientation = this.gamma = this.beta = this.alpha = 0;
  this.events = new EventManager;
  var a = this;
  this.events.add(window, "orientationchange", function(c) {
    a.orientation = THREE.Math.degToRad(window.orientation);
  });
  this.events.add(window, "deviceorientation", function(c) {
    a.alpha = THREE.Math.degToRad(c.alpha);
    a.beta = THREE.Math.degToRad(c.beta);
    a.gamma = THREE.Math.degToRad(c.gamma);
  });
  this.events.create();
}
Gyroscope.prototype.setObjectQuaternion = function() {
  var a = new THREE.Euler, c = new THREE.Quaternion, g = new THREE.Vector3(0, 0, 1), b = new THREE.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5));
  return function(e) {
    a.set(this.beta, this.alpha, -this.gamma, "YXZ");
    e.quaternion.setFromEuler(a);
    e.quaternion.multiply(b);
    e.quaternion.multiply(c.setFromAxisAngle(g, -this.orientation));
  };
}();
Gyroscope.prototype.dispose = function() {
  this.events.destroy();
};
"use strict";
function RendererState() {
  this.autoClearDepth = this.autoClearStencil = this.autoClearColor = this.autoClear = !1;
  this.clearColor = new THREE.Color;
  this.clearAlpha = 1;
}
RendererState.prototype.backup = function(a) {
  this.autoClear = a.autoClear;
  this.autoClearColor = a.autoClearColor;
  this.autoClearStencil = a.autoClearStencil;
  this.autoClearDepth = a.autoClearDepth;
  this.clearColor.copy(a.getClearColor());
  this.clearAlpha = a.getClearAlpha();
};
RendererState.prototype.restore = function(a) {
  a.autoClear = this.autoClear;
  a.autoClearColor = this.autoClearColor;
  a.autoClearStencil = this.autoClearStencil;
  a.autoClearDepth = this.autoClearDepth;
  a.setClearColor(this.clearColor);
  a.setClearAlpha(this.clearAlpha);
};
"use strict";
function Pass() {
  this.uuid = THREE.Math.generateUUID();
  this.type = "Pass";
  this.needsSwap = this.enabled = !0;
  this.copyToScreen = this.renderToScreen = this.clear = !1;
}
Pass.RGBALinear = {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBAFormat};
Pass.RGBLinear = {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBFormat};
Pass.RGBANearest = {minFilter:THREE.NearestFilter, magFilter:THREE.NearestFilter, format:THREE.RGBAFormat};
Pass.prototype.createQuadScene = function() {
  this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  this.scene = new THREE.Scene;
  this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
  this.quad.frustumCulled = !1;
  this.scene.add(this.quad);
};
Pass.prototype.setSize = function(a, c) {
};
Pass.prototype.render = function(a, c, g, b, e, f, k) {
};
Pass.prototype.dispose = function() {
};
Pass.prototype.toJSON = function(a) {
  a = {};
  a.uuid = this.uuid;
  a.type = this.type;
  a.enabled = this.enabled;
  a.needsSwap = this.needsSwap;
  a.renderToScreen = this.renderToScreen;
  a.clear = this.clear;
  a.copyToScreen = this.copyToScreen;
  return a;
};
"use strict";
function ShaderPass(a, c) {
  Pass.call(this);
  this.type = "Shader";
  this.textureID = void 0 !== c ? c : "tDiffuse";
  a instanceof THREE.ShaderMaterial ? (this.uniforms = a.uniforms, this.material = a) : a && (this.uniforms = THREE.UniformsUtils.clone(a.uniforms), this.material = new THREE.ShaderMaterial({defines:a.defines || {}, uniforms:this.uniforms, vertexShader:a.vertexShader, fragmentShader:a.fragmentShader}));
  this.createQuadScene();
}
ShaderPass.prototype = Object.create(Pass.prototype);
ShaderPass.prototype.render = function(a, c, g, b, e, f, k) {
  this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = g.texture);
  this.quad.material = this.material;
  !0 === this.clear && a.clear();
  a.setRenderTarget(this.renderToScreen ? null : c);
  a.render(this.scene, this.camera);
};
"use strict";
function EffectComposer() {
  void 0 === THREE.CopyShader && console.error("EffectComposer relies on THREE.CopyShader");
  this.uuid = THREE.Math.generateUUID();
  this.height = this.width = 1;
  this.passes = [];
  this.writeBuffer = new THREE.WebGLRenderTarget(this.width, this.height, EffectComposer.bufferParameters);
  this.readBuffer = new THREE.WebGLRenderTarget(this.width, this.height, EffectComposer.bufferParameters);
  this.copyPass = new ShaderPass(THREE.CopyShader);
  this.rendererState = new RendererState;
}
EffectComposer.bufferParameters = {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBAFormat, stencilBuffer:!1};
EffectComposer.prototype.swapBuffers = function() {
  var a = this.readBuffer;
  this.readBuffer = this.writeBuffer;
  this.writeBuffer = a;
};
EffectComposer.prototype.addPass = function(a) {
  this.passes.push(a);
};
EffectComposer.prototype.moveBack = function(a) {
  var c = this.passes.indexOf(a);
  if (0 < c) {
    for (var g = c; g !== c - 1; --g) {
      this.passes[g] = this.passes[g - 1];
    }
    this.passes[c - 1] = a;
    return !0;
  }
  return !1;
};
EffectComposer.prototype.moveForward = function(a) {
  var c = this.passes.indexOf(a);
  if (-1 !== c && c < this.passes.length - 1) {
    for (var g = c; g !== c + 1; g += 1) {
      this.passes[g] = this.passes[g + 1];
    }
    this.passes[c + 1] = a;
    return !0;
  }
  return !1;
};
EffectComposer.prototype.removePass = function(a) {
  a = this.passes.indexOf(a);
  -1 !== a && this.passes.splice(a, 1);
};
EffectComposer.prototype.insertPass = function(a, c) {
  this.passes.splice(c, 0, a);
};
EffectComposer.prototype.render = function(a, c, g, b) {
  var e = !1;
  this.rendererState.backup(a);
  for (var f = 0; f < this.passes.length; f++) {
    var k = this.passes[f];
    if (!0 === k.enabled) {
      k.render(a, this.writeBuffer, this.readBuffer, b, e, c, g);
      if (!0 === k.renderToScreen) {
        !0 === k.copyToScreen && (this.copyPass.renderToScreen = !0, this.copyPass.render(a, this.readBuffer, this.writeBuffer, b));
        break;
      }
      !0 === k.needsSwap && (!0 === e && (a.context.stencilFunc(a.context.NOTEQUAL, 1, 4294967295), this.copyPass.renderToScreen = !1, this.copyPass.render(a, this.writeBuffer, this.readBuffer, b), a.context.stencilFunc(a.context.EQUAL, 1, 4294967295)), this.swapBuffers());
      void 0 !== THREE.MaskPass && (k instanceof THREE.MaskPass ? e = !0 : k instanceof THREE.ClearMaskPass && (e = !1));
    }
  }
  this.rendererState.restore(a);
};
EffectComposer.prototype.setSize = function(a, c) {
  a = Math.floor(a);
  c = Math.floor(c);
  this.width = a;
  this.height = c;
  this.writeBuffer.setSize(a, c);
  this.readBuffer.setSize(a, c);
  for (var g = 0; g < this.passes.length; g++) {
    this.passes[g].setSize(a, c);
  }
};
EffectComposer.prototype.reset = function() {
  this.dispose();
  this.writeBuffer = new THREE.WebGLRenderTarget(this.width, this.height, EffectComposer.bufferParameters);
  this.readBuffer = new THREE.WebGLRenderTarget(this.width, this.height, EffectComposer.bufferParameters);
};
EffectComposer.prototype.dispose = function() {
  this.writeBuffer.dispose();
  this.readBuffer.dispose();
  this.readBuffer = this.writeBuffer = null;
};
EffectComposer.prototype.toJSON = function() {
  var a = {};
  a.uuid = this.uuid;
  a.passes = [];
  for (var c = 0; c < this.passes.length; c++) {
    a.passes.push(this.passes[c].toJSON());
  }
  return a;
};
EffectComposer.fromJSON = function(a) {
  var c = new EffectComposer;
  c.uuid = a.uuid;
  for (var g = 0; g < a.passes.length; g++) {
    var b = a.passes[g];
    if ("Render" === b.type) {
      var e = new RenderPass;
    } else {
      if ("UnrealBloom" === b.type) {
        for (e = new UnrealBloomPass, e.strength = b.strength, e.radius = b.radius, e.threshold = b.threshold, e.bloomFactors = b.bloomFactors, g = 0; g < e.bloomTintColors.length; g++) {
          e.bloomTintColors[g].fromArray(b.bloomTintColors[g]);
        }
      } else {
        "Bloom" === b.type ? e = new BloomPass(b.strength, b.kernelSize, b.sigma, b.resolution) : "SSAONOH" === b.type ? (e = new SSAONOHPass, e.kernelRadius = b.kernelRadius, e.minDistance = b.minDistance, e.maxDistance = b.maxDistance) : "SSAO" === b.type ? (e = new SSAOPass, e.onlyAO = b.onlyAO, e.radius = b.radius, e.aoClamp = b.aoClamp, e.lumInfluence = b.lumInfluence) : "Bokeh" === b.type ? e = new BokehPass(b.focus, b.aperture, b.maxblur) : "FXAA" === b.type ? e = new FXAAPass : "Copy" === 
        b.type ? e = new CopyPass : "Film" === b.type ? (e = new FilmPass, e.grayscale = b.grayscale, e.noiseIntensity = b.noiseIntensity, e.scanlinesIntensity = b.scanlinesIntensity, e.scanlinesCount = b.scanlinesCount) : "DotScreen" === b.type ? (e = new DotScreenPass, e.center.fromArray(b.center), e.angle = b.angle, e.scale = b.scale) : "Colorify" === b.type ? (e = new ColorifyPass, e.color.setHex(b.color)) : "Sobel" === b.type ? e = new SobelPass : "Technicolor" === b.type ? e = new TechnicolorPass : 
        "HueSaturation" === b.type ? (e = new HueSaturationPass, e.hue = b.hue, e.saturation = b.saturation) : e = new RenderPass;
      }
    }
    e.uuid = b.uuid;
    e.enabled = b.enabled;
    e.needsSwap = b.needsSwap;
    e.renderToScreen = b.renderToScreen;
    e.clear = b.clear;
    e.copyToScreen = !0 === b.copyToScreen;
    c.addPass(e);
  }
  return c;
};
"use strict";
function FXAAPass() {
  ShaderPass.call(this, THREE.FXAAShader);
  this.type = "FXAA";
}
FXAAPass.prototype = Object.create(ShaderPass.prototype);
FXAAPass.prototype.setSize = function(a, c) {
  this.uniforms.resolution.value.set(1 / a, 1 / c);
};
"use strict";
function RenderPass() {
  Pass.call(this);
  this.type = "Render";
}
RenderPass.prototype = Object.create(Pass.prototype);
RenderPass.prototype.render = function(a, c, g, b, e, f, k) {
  !0 === this.clear && a.clear();
  a.setRenderTarget(this.renderToScreen ? null : c);
  a.render(f, k);
};
"use strict";
function UnrealBloomPass(a, c, g) {
  void 0 === THREE.LuminosityHighPassShader && console.error("UnrealBloomPass relies on THREE.LuminosityHighPassShader");
  void 0 === THREE.CopyShader && console.error("UnrealBloomPass relies on THREE.CopyShader");
  Pass.call(this);
  this.type = "UnrealBloom";
  this.renderTargetsHorizontal = [];
  this.renderTargetsVertical = [];
  this.nMips = 5;
  for (var b = 0; b < this.nMips; b++) {
    var e = new THREE.WebGLRenderTarget(0, 0, Pass.RGBALinear);
    e.texture.generateMipmaps = !1;
    this.renderTargetsHorizontal.push(e);
    e = new THREE.WebGLRenderTarget(0, 0, Pass.RGBALinear);
    e.texture.generateMipmaps = !1;
    this.renderTargetsVertical.push(e);
  }
  this.renderTargetBright = new THREE.WebGLRenderTarget(0, 0, Pass.RGBALinear);
  this.renderTargetBright.texture.generateMipmaps = !1;
  b = THREE.LuminosityHighPassShader;
  this.highPassUniforms = THREE.UniformsUtils.clone(b.uniforms);
  this.materialHighPassFilter = new THREE.ShaderMaterial({uniforms:this.highPassUniforms, vertexShader:b.vertexShader, fragmentShader:b.fragmentShader, defines:{}});
  this.separableBlurMaterials = [];
  e = [3, 5, 7, 9, 11];
  for (b = 0; b < this.nMips; b++) {
    this.separableBlurMaterials.push(UnrealBloomPass.getSeperableBlurMaterial(e[b])), this.separableBlurMaterials[b].uniforms.texSize.value = new THREE.Vector2(0, 0);
  }
  this.compositeMaterial = UnrealBloomPass.getCompositeMaterial(this.nMips);
  this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture;
  this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture;
  this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture;
  this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture;
  this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture;
  this.highPassUniforms.luminosityThreshold.value = void 0 !== g ? g : .7;
  this.highPassUniforms.smoothWidth.value = .01;
  this.compositeMaterial.uniforms.bloomStrength.value = void 0 !== a ? a : .8;
  this.compositeMaterial.uniforms.bloomRadius.value = void 0 !== c ? c : .3;
  this.compositeMaterial.uniforms.bloomFactors.value = [1, .8, .6, .4, .2];
  this.compositeMaterial.uniforms.bloomTintColors.value = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)];
  this.compositeMaterial.needsUpdate = !0;
  this.copyUniforms = THREE.UniformsUtils.clone(THREE.CopyShader.uniforms);
  this.copyUniforms.opacity.value = 1;
  this.materialCopy = new THREE.ShaderMaterial({uniforms:this.copyUniforms, vertexShader:THREE.CopyShader.vertexShader, fragmentShader:THREE.CopyShader.fragmentShader, blending:THREE.AdditiveBlending, depthTest:!1, depthWrite:!1, transparent:!0});
  this.oldClearColor = new THREE.Color;
  this.oldClearAlpha = 1;
  this.oldAutoClear = !1;
  this.createQuadScene();
  this.basic = new THREE.MeshBasicMaterial;
  Object.defineProperties(this, {strength:{get:function() {
    return this.compositeMaterial.uniforms.bloomStrength.value;
  }, set:function(a) {
    this.compositeMaterial.uniforms.bloomStrength.value = a;
  }}, radius:{get:function() {
    return this.compositeMaterial.uniforms.bloomRadius.value;
  }, set:function(a) {
    this.compositeMaterial.uniforms.bloomRadius.value = a;
  }}, threshold:{get:function() {
    return this.highPassUniforms.luminosityThreshold.value;
  }, set:function(a) {
    this.highPassUniforms.luminosityThreshold.value;
  }}, smooth:{get:function() {
    return this.highPassUniforms.smoothWidth.value;
  }, set:function(a) {
    this.highPassUniforms.smoothWidth.value;
  }}, bloomFactors:{get:function() {
    return this.compositeMaterial.uniforms.bloomFactors.value;
  }, set:function(a) {
    this.compositeMaterial.uniforms.bloomFactors.value;
  }}, bloomTintColors:{get:function() {
    return this.compositeMaterial.uniforms.bloomTintColors.value;
  }, set:function(a) {
    this.compositeMaterial.uniforms.bloomTintColors.value = a;
  }}});
}
UnrealBloomPass.prototype = Object.create(Pass.prototype);
UnrealBloomPass.BlurDirectionX = new THREE.Vector2(1, 0);
UnrealBloomPass.BlurDirectionY = new THREE.Vector2(0, 1);
UnrealBloomPass.prototype.dispose = function() {
  for (var a = 0; a < this.renderTargetsHorizontal.length; a++) {
    this.renderTargetsHorizontal[a].dispose();
  }
  for (a = 0; a < this.renderTargetsVertical.length; a++) {
    this.renderTargetsVertical[a].dispose();
  }
  this.renderTargetBright.dispose();
};
UnrealBloomPass.prototype.setSize = function(a, c) {
  a = Math.round(a / 2);
  c = Math.round(c / 2);
  this.renderTargetBright.setSize(a, c);
  for (var g = 0; g < this.nMips; g++) {
    this.renderTargetsHorizontal[g].setSize(a, c), this.renderTargetsVertical[g].setSize(a, c), this.separableBlurMaterials[g].uniforms.texSize.value.set(a, c), a = Math.round(a / 2), c = Math.round(c / 2);
  }
};
UnrealBloomPass.prototype.render = function(a, c, g, b, e, f, k) {
  this.oldClearColor.copy(a.getClearColor());
  this.oldClearAlpha = a.getClearAlpha();
  this.oldAutoClear = a.autoClear;
  a.autoClear = !1;
  a.setClearColor(new THREE.Color(0, 0, 0), 0);
  e && a.context.disable(a.context.STENCIL_TEST);
  this.renderToScreen && (this.quad.material = this.basic, this.basic.map = g.texture, a.clear(), a.render(this.scene, this.camera));
  this.highPassUniforms.tDiffuse.value = g.texture;
  this.quad.material = this.materialHighPassFilter;
  a.clear();
  a.setRenderTarget(this.renderTargetBright);
  a.render(this.scene, this.camera);
  c = this.renderTargetBright;
  for (b = 0; b < this.nMips; b++) {
    this.quad.material = this.separableBlurMaterials[b], this.separableBlurMaterials[b].uniforms.colorTexture.value = c.texture, this.separableBlurMaterials[b].uniforms.direction.value = UnrealBloomPass.BlurDirectionX, a.clear(), a.setRenderTarget(this.renderTargetsHorizontal[b]), a.render(this.scene, this.camera), this.separableBlurMaterials[b].uniforms.colorTexture.value = this.renderTargetsHorizontal[b].texture, this.separableBlurMaterials[b].uniforms.direction.value = UnrealBloomPass.BlurDirectionY, 
    a.clear(), a.setRenderTarget(this.renderTargetsVertical[b]), a.render(this.scene, this.camera), c = this.renderTargetsVertical[b];
  }
  this.quad.material = this.compositeMaterial;
  a.clear();
  a.setRenderTarget(this.renderTargetsHorizontal[0]);
  a.render(this.scene, this.camera);
  this.quad.material = this.materialCopy;
  this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture;
  e && a.context.enable(a.context.STENCIL_TEST);
  !0 === this.clear && a.clear();
  a.setRenderTarget(this.renderToScreen ? null : g);
  a.render(this.scene, this.camera);
  a.setClearColor(this.oldClearColor, this.oldClearAlpha);
  a.autoClear = this.oldAutoClear;
};
UnrealBloomPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.strength = this.strength;
  a.radius = this.radius;
  a.threshold = this.threshold;
  a.bloomFactors = this.bloomFactors;
  a.bloomTintColors = [];
  for (var c = 0; c < this.bloomTintColors.length; c++) {
    a.bloomTintColors.push(this.bloomTintColors[c].toArray());
  }
  return a;
};
UnrealBloomPass.getSeperableBlurMaterial = function(a) {
  return new THREE.ShaderMaterial({defines:{KERNEL_RADIUS:a, SIGMA:a}, uniforms:{colorTexture:{value:null}, texSize:{value:new THREE.Vector2(.5, .5)}, direction:{value:new THREE.Vector2(.5, .5)}}, vertexShader:"\n\t\t\tvarying vec2 vUv;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tvUv = uv;\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t\t\t}", fragmentShader:"\n\t\t\t#include <common>\n\t\t\tvarying vec2 vUv;\n\t\t\tuniform sampler2D colorTexture;\n\t\t\tuniform vec2 texSize;\n\t\t\tuniform vec2 direction;\n\t\t\t\n\t\t\tfloat gaussianPdf(in float x, in float sigma)\n\t\t\t{\n\t\t\t\treturn 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n\t\t\t}\n\t\t\t\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\tvec3 diffuseSum = texture2D(colorTexture, vUv).rgb * weightSum;\n\t\t\t\tfor(int i = 1; i < KERNEL_RADIUS; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\tvec3 sample1 = texture2D(colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\tvec3 sample2 = texture2D(colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t}\n\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t}"});
};
UnrealBloomPass.getCompositeMaterial = function(a) {
  return new THREE.ShaderMaterial({defines:{NUM_MIPS:a}, uniforms:{blurTexture1:{value:null}, blurTexture2:{value:null}, blurTexture3:{value:null}, blurTexture4:{value:null}, blurTexture5:{value:null}, dirtTexture:{value:null}, bloomStrength:{value:1}, bloomFactors:{value:null}, bloomTintColors:{value:null}, bloomRadius:{value:0}}, vertexShader:"\n\t\t\tvarying vec2 vUv;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tvUv = uv;\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t\t\t}", 
  fragmentShader:"\n\t\t\tvarying vec2 vUv;\n\t\t\tuniform sampler2D blurTexture1;\n\t\t\tuniform sampler2D blurTexture2;\n\t\t\tuniform sampler2D blurTexture3;\n\t\t\tuniform sampler2D blurTexture4;\n\t\t\tuniform sampler2D blurTexture5;\n\t\t\tuniform sampler2D dirtTexture;\n\t\t\tuniform float bloomStrength;\n\t\t\tuniform float bloomRadius;\n\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\t\t\t\n\t\t\tfloat lerpBloomFactor(const in float factor)\n\t\t\t{\n\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t}\n\t\t\t\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tgl_FragColor = bloomStrength * (lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \n\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \n\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \n\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \n\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv));\n\t\t\t}"});
};
"use strict";
function BloomPass(a, c, g, b) {
  Pass.call(this);
  void 0 === THREE.ConvolutionShader && console.error("BloomPass relies on THREE.ConvolutionShader");
  void 0 === THREE.CopyShader && console.error("BloomPass relies on THREE.CopyShader");
  this.type = "Bloom";
  this.copyToScreen = !0;
  this.createQuadScene();
  a = void 0 !== a ? a : 1;
  c = void 0 !== c ? c : 25;
  g = void 0 !== g ? g : 4;
  b = void 0 !== b ? b : 256;
  this.renderTargetX = new THREE.WebGLRenderTarget(b, b, Pass.RGBALinear);
  this.renderTargetY = new THREE.WebGLRenderTarget(b, b, Pass.RGBALinear);
  this.copyUniforms = THREE.UniformsUtils.clone(THREE.CopyShader.uniforms);
  this.copyUniforms.opacity.value = a;
  this.materialCopy = new THREE.ShaderMaterial({uniforms:this.copyUniforms, vertexShader:THREE.CopyShader.vertexShader, fragmentShader:THREE.CopyShader.fragmentShader, blending:THREE.AdditiveBlending, transparent:!0});
  this.convolutionUniforms = THREE.UniformsUtils.clone(THREE.ConvolutionShader.uniforms);
  this.convolutionUniforms.uImageIncrement.value = BloomPass.blurX;
  this.convolutionUniforms.cKernel.value = THREE.ConvolutionShader.buildKernel(g);
  this.materialConvolution = new THREE.ShaderMaterial({uniforms:this.convolutionUniforms, vertexShader:THREE.ConvolutionShader.vertexShader, fragmentShader:THREE.ConvolutionShader.fragmentShader, defines:{KERNEL_SIZE_FLOAT:c.toFixed(1), KERNEL_SIZE_INT:c.toFixed(0)}});
}
BloomPass.blurX = new THREE.Vector2(.001953125, 0);
BloomPass.blurY = new THREE.Vector2(0, .001953125);
BloomPass.prototype = Object.create(Pass.prototype);
BloomPass.prototype.render = function(a, c, g, b, e, f, k) {
  e && a.context.disable(a.context.STENCIL_TEST);
  this.quad.material = this.materialConvolution;
  this.convolutionUniforms.tDiffuse.value = g.texture;
  this.convolutionUniforms.uImageIncrement.value = BloomPass.blurX;
  a.render(this.scene, this.camera, this.renderTargetX, !0);
  this.convolutionUniforms.tDiffuse.value = this.renderTargetX.texture;
  this.convolutionUniforms.uImageIncrement.value = BloomPass.blurY;
  a.render(this.scene, this.camera, this.renderTargetY, !0);
  this.quad.material = this.materialCopy;
  this.copyUniforms.tDiffuse.value = this.renderTargetY.texture;
  e && a.context.enable(a.context.STENCIL_TEST);
  a.setRenderTarget(c);
  a.render(this.scene, this.camera);
};
BloomPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.strength = this.strength;
  a.kernelSize = this.kernelSize;
  a.sigma = this.sigma;
  a.resolution = this.resolution;
  return a;
};
"use strict";
function SSAONOHPass() {
  void 0 === THREE.SSAOShader && console.warn("SSAONOHPass depends on THREE.SSAOShader");
  Pass.call(this);
  this.type = "SSAONOH";
  this.kernel = [];
  this.noiseTexture = null;
  this.createQuadScene();
  this.depthTexture = new THREE.DepthTexture;
  this.depthTexture.type = THREE.UnsignedShortType;
  this.depthTexture.minFilter = THREE.NearestFilter;
  this.depthTexture.maxFilter = THREE.NearestFilter;
  this.normalMaterial = new THREE.MeshNormalMaterial;
  this.normalMaterial.blending = THREE.NoBlending;
  this.normalRenderTarget = new THREE.WebGLRenderTarget(1, 1, {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBAFormat, depthTexture:this.depthTexture, depthBuffer:!0});
  this.ssaoRenderTarget = new THREE.WebGLRenderTarget(1, 1, Pass.RGBALinear);
  this.blurRenderTarget = new THREE.WebGLRenderTarget(1, 1, Pass.RGBALinear);
  this.blurMaterial = new THREE.ShaderMaterial({defines:Object.assign({}, THREE.SSAOBlurShader.defines), uniforms:THREE.UniformsUtils.clone(THREE.SSAOBlurShader.uniforms), vertexShader:THREE.SSAOBlurShader.vertexShader, fragmentShader:THREE.SSAOBlurShader.fragmentShader});
  this.blurMaterial.uniforms.tDiffuse.value = this.ssaoRenderTarget.texture;
  this.ssaoMaterial = new THREE.ShaderMaterial({defines:Object.assign({}, THREE.SSAOShader.defines), uniforms:THREE.UniformsUtils.clone(THREE.SSAOShader.uniforms), vertexShader:THREE.SSAOShader.vertexShader, fragmentShader:THREE.SSAOShader.fragmentShader, blending:THREE.NoBlending});
  this.ssaoMaterial.uniforms.tNormal.value = this.normalRenderTarget.texture;
  this.copyMaterial = new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(THREE.CopyShader.uniforms), vertexShader:THREE.CopyShader.vertexShader, fragmentShader:THREE.CopyShader.fragmentShader, transparent:!0, depthTest:!1, depthWrite:!1, blendSrc:THREE.DstColorFactor, blendDst:THREE.ZeroFactor, blendEquation:THREE.AddEquation, blendSrcAlpha:THREE.DstAlphaFactor, blendDstAlpha:THREE.ZeroFactor, blendEquationAlpha:THREE.AddEquation});
  this.originalClearColor = new THREE.Color;
  this._kernelSize = 0;
  var a = this;
  Object.defineProperties(this, {kernelRadius:{get:function() {
    return a.ssaoMaterial.uniforms.kernelRadius.value;
  }, set:function(c) {
    a.ssaoMaterial.uniforms.kernelRadius.value = c;
  }}, minDistance:{get:function() {
    return a.ssaoMaterial.uniforms.minDistance.value;
  }, set:function(c) {
    a.ssaoMaterial.uniforms.minDistance.value = c;
  }}, maxDistance:{get:function() {
    return a.ssaoMaterial.uniforms.maxDistance.value;
  }, set:function(c) {
    a.ssaoMaterial.uniforms.maxDistance.value = c;
  }}, kernelSize:{get:function() {
    return a._kernelSize;
  }, set:function(c) {
    a._kernelSize = c;
    a.generateSampleKernel();
    a.generateRandomKernelRotations();
    a.ssaoMaterial.uniforms.tNoise.value = a.noiseTexture;
    a.ssaoMaterial.uniforms.kernel.value = a.kernel;
  }}});
  this.kernelSize = 64;
  this.kernelRadius = 8;
  this.minDistance = .1;
  this.maxDistance = 1E3;
}
SSAONOHPass.prototype = Object.create(Pass.prototype);
SSAONOHPass.prototype.generateSampleKernel = function() {
  for (var a = 0; a < this._kernelSize; a++) {
    var c = new THREE.Vector3;
    c.x = 2 * Math.random() - 1;
    c.y = 2 * Math.random() - 1;
    c.z = Math.random();
    c.normalize();
    var g = a / this._kernelSize;
    g = THREE.Math.lerp(.1, 1, g * g);
    c.multiplyScalar(g);
    this.kernel.push(c);
  }
};
SSAONOHPass.prototype.generateRandomKernelRotations = function() {
  void 0 === SimplexNoise && console.error("SSAONOHPass: The pass relies on SimplexNoise.");
  for (var a = new SimplexNoise, c = new Float32Array(16), g = 0; 16 > g; g++) {
    c[g] = a.noise3d(2 * Math.random() - 1, 2 * Math.random() - 1, 0);
  }
  this.noiseTexture = new THREE.DataTexture(c, 4, 4, THREE.LuminanceFormat, THREE.FloatType);
  this.noiseTexture.wrapS = THREE.RepeatWrapping;
  this.noiseTexture.wrapT = THREE.RepeatWrapping;
  this.noiseTexture.needsUpdate = !0;
};
SSAONOHPass.prototype.render = function(a, c, g, b, e, f, k) {
  this.originalClearColor.copy(a.getClearColor());
  b = a.getClearAlpha();
  e = a.autoClear;
  f.overrideMaterial = this.normalMaterial;
  a.autoClear = !1;
  a.setClearColor(7829503);
  a.setClearAlpha(1);
  a.clear();
  a.setRenderTarget(this.normalRenderTarget);
  a.render(f, k);
  f.overrideMaterial = null;
  a.autoClear = e;
  a.setClearColor(this.originalClearColor);
  a.setClearAlpha(b);
  this.ssaoMaterial.uniforms.tDepth.value = this.depthTexture;
  this.ssaoMaterial.uniforms.tDiffuse.value = g.texture;
  this.ssaoMaterial.uniforms.cameraNear.value = k.near;
  this.ssaoMaterial.uniforms.cameraFar.value = k.far;
  this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(k.projectionMatrix);
  this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.getInverse(k.projectionMatrix);
  this.renderPass(a, this.ssaoMaterial, this.ssaoRenderTarget);
  this.renderPass(a, this.blurMaterial, this.blurRenderTarget);
  this.renderToScreen ? (this.copyMaterial.uniforms.tDiffuse.value = g.texture, this.copyMaterial.blending = THREE.NoBlending, this.renderPass(a, this.copyMaterial, void 0, this.clear), this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.copyMaterial.blending = THREE.CustomBlending, this.renderPass(a, this.copyMaterial, void 0, !1)) : (this.copyMaterial.uniforms.tDiffuse.value = g.texture, this.copyMaterial.blending = THREE.NoBlending, this.renderPass(a, this.copyMaterial, 
  c, this.clear), this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.copyMaterial.blending = THREE.CustomBlending, this.renderPass(a, this.copyMaterial, c, !1));
};
SSAONOHPass.prototype.renderPass = function(a, c, g, b) {
  this.quad.material = c;
  !0 === b && a.clear();
  a.setRenderTarget(g);
  a.render(this.scene, this.camera);
};
SSAONOHPass.prototype.dispose = function() {
  this.normalRenderTarget.dispose();
  this.ssaoRenderTarget.dispose();
  this.blurRenderTarget.dispose();
  this.quad.geometry.dispose();
  this.normalMaterial.dispose();
  this.blurMaterial.dispose();
  this.copyMaterial.dispose();
};
SSAONOHPass.prototype.setSize = function(a, c) {
  this.ssaoMaterial.uniforms.resolution.value.set(a, c);
  this.blurMaterial.uniforms.resolution.value.set(a, c);
  this.normalRenderTarget.setSize(a, c);
  this.ssaoRenderTarget.setSize(a, c);
  this.blurRenderTarget.setSize(a, c);
};
SSAONOHPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.kernelRadius = this.kernelRadius;
  a.minDistance = this.minDistance;
  a.maxDistance = this.maxDistance;
  return a;
};
"use strict";
function SSAOPass() {
  ShaderPass.call(this, SSAOShader);
  this.type = "SSAO";
  this.depthMaterial = new THREE.MeshDepthMaterial;
  this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
  this.depthMaterial.blending = THREE.NoBlending;
  this.depthRenderTarget = new THREE.WebGLRenderTarget(2, 2, {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter});
  this.uniforms.tDepth.value = this.depthRenderTarget.texture;
  this.uniforms.size.value.set(2, 2);
  Object.defineProperties(this, {radius:{get:function() {
    return this.uniforms.radius.value;
  }, set:function(a) {
    this.uniforms.radius.value = a;
  }}, onlyAO:{get:function() {
    return this.uniforms.onlyAO.value;
  }, set:function(a) {
    this.uniforms.onlyAO.value = a;
  }}, aoClamp:{get:function() {
    return this.uniforms.aoClamp.value;
  }, set:function(a) {
    this.uniforms.aoClamp.value = a;
  }}, lumInfluence:{get:function() {
    return this.uniforms.lumInfluence.value;
  }, set:function(a) {
    this.uniforms.lumInfluence.value = a;
  }}});
  this.radius = 4;
  this.onlyAO = !1;
  this.aoClamp = .25;
  this.lumInfluence = .7;
}
SSAOPass.prototype = Object.create(ShaderPass.prototype);
SSAOPass.prototype.render = function(a, c, g, b, e, f, k) {
  this.uniforms.cameraNear.value = k.near;
  this.uniforms.cameraFar.value = k.far;
  f.overrideMaterial = this.depthMaterial;
  a.clear();
  a.setRenderTarget(this.depthRenderTarget);
  a.render(f, k);
  f.overrideMaterial = null;
  ShaderPass.prototype.render.call(this, a, c, g, b, e);
};
SSAOPass.prototype.setSize = function(a, c) {
  this.uniforms.size.value.set(a, c);
  this.depthRenderTarget.setSize(a, c);
};
SSAOPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.onlyAO = this.onlyAO;
  a.radius = this.radius;
  a.aoClamp = this.aoClamp;
  a.lumInfluence = this.lumInfluence;
  return a;
};
"use strict";
function BokehPass(a, c, g) {
  void 0 === THREE.BokehShader && console.error("BokehPass relies on THREE.BokehShader");
  Pass.call(this);
  this.type = "Bokeh";
  this.renderTargetColor = new THREE.WebGLRenderTarget(0, 0, Pass.RGBLinear);
  this.renderTargetDepth = this.renderTargetColor.clone();
  this.materialDepth = new THREE.MeshDepthMaterial;
  this.materialDepth.depthPacking = THREE.RGBADepthPacking;
  this.materialDepth.blending = THREE.NoBlending;
  this.uniforms = THREE.UniformsUtils.clone(THREE.BokehShader.uniforms);
  this.uniforms.tDepth.value = this.renderTargetDepth.texture;
  this.materialBokeh = new THREE.ShaderMaterial({defines:THREE.BokehShader.defines, uniforms:this.uniforms, vertexShader:THREE.BokehShader.vertexShader, fragmentShader:THREE.BokehShader.fragmentShader});
  this.createQuadScene();
  this.quad.material = this.materialBokeh;
  this.oldClearColor = new THREE.Color;
  this.oldClearAlpha = 1;
  this.oldAutoClear = !1;
  var b = this;
  Object.defineProperties(this, {aperture:{get:function() {
    return b.uniforms.aperture.value;
  }, set:function(a) {
    b.uniforms.aperture.value = a;
  }}, focus:{get:function() {
    return b.uniforms.focus.value;
  }, set:function(a) {
    b.uniforms.focus.value = a;
  }}, maxblur:{get:function() {
    return b.uniforms.maxblur.value;
  }, set:function(a) {
    b.uniforms.maxblur.value = a;
  }}});
  this.focus = void 0 !== a ? a : 1;
  this.aperture = void 0 !== c ? c : 1;
  this.maxblur = void 0 !== g ? g : .2;
}
BokehPass.prototype = Object.create(Pass.prototype);
BokehPass.prototype.render = function(a, c, g, b, e, f, k) {
  this.oldClearColor.copy(a.getClearColor());
  this.oldClearAlpha = a.getClearAlpha();
  this.oldAutoClear = a.autoClear;
  f.overrideMaterial = this.materialDepth;
  a.autoClear = !1;
  a.setClearColor(16777215);
  a.setClearAlpha(1);
  a.render(f, k, this.renderTargetDepth, !0);
  this.uniforms.tColor.value = g.texture;
  this.uniforms.nearClip.value = k.near;
  this.uniforms.farClip.value = k.far;
  this.uniforms.aspect.value = k.aspect;
  !0 === this.clear && a.clear();
  a.setRenderTarget(this.renderToScreen ? void 0 : c);
  a.render(this.scene, this.camera);
  f.overrideMaterial = null;
  a.setClearColor(this.oldClearColor);
  a.setClearAlpha(this.oldClearAlpha);
  a.autoClear = this.oldAutoClear;
};
BokehPass.prototype.setSize = function(a, c) {
  this.renderTargetColor.setSize(a, c);
  this.renderTargetDepth.setSize(a, c);
};
BokehPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.aperture = this.aperture;
  a.focus = this.focus;
  a.maxblur = this.maxblur;
  return a;
};
"use strict";
function CopyPass() {
  ShaderPass.call(this, THREE.CopyShader);
  this.type = "Copy";
}
CopyPass.prototype = Object.create(ShaderPass.prototype);
"use strict";
function FilmPass(a, c, g, b) {
  void 0 === THREE.FilmShader && console.error("FilmPass relies on THREE.FilmShader");
  Pass.call(this);
  this.type = "Film";
  this.createQuadScene();
  this.uniforms = THREE.UniformsUtils.clone(THREE.FilmShader.uniforms);
  this.material = new THREE.ShaderMaterial({uniforms:this.uniforms, vertexShader:THREE.FilmShader.vertexShader, fragmentShader:THREE.FilmShader.fragmentShader});
  var e = this;
  Object.defineProperties(this, {grayscale:{get:function() {
    return e.uniforms.grayscale.value;
  }, set:function(a) {
    e.uniforms.grayscale.value = a;
  }}, noiseIntensity:{get:function() {
    return e.uniforms.nIntensity.value;
  }, set:function(a) {
    e.uniforms.nIntensity.value = a;
  }}, scanlinesIntensity:{get:function() {
    return e.uniforms.sIntensity.value;
  }, set:function(a) {
    e.uniforms.sIntensity.value = a;
  }}, scanlinesCount:{get:function() {
    return e.uniforms.sCount.value;
  }, set:function(a) {
    e.uniforms.sCount.value = a;
  }}});
  this.grayscale = void 0 !== b ? b : !1;
  this.noiseIntensity = void 0 !== a ? a : .35;
  this.scanlinesIntensity = void 0 !== c ? c : .5;
  this.scanlinesCount = void 0 !== g ? g : 512;
}
FilmPass.prototype = Object.create(Pass.prototype);
FilmPass.prototype.render = function(a, c, g, b, e, f, k) {
  this.uniforms.tDiffuse.value = g.texture;
  this.uniforms.time.value += b;
  this.quad.material = this.material;
  !0 === this.clear && a.clear();
  a.setRenderTarget(this.renderToScreen ? void 0 : c);
  a.render(this.scene, this.camera);
};
FilmPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.grayscale = this.grayscale;
  a.noiseIntensity = this.noiseIntensity;
  a.scanlinesIntensity = this.scanlinesIntensity;
  a.scanlinesCount = this.scanlinesCount;
  return a;
};
"use strict";
function DotScreenPass(a, c, g) {
  void 0 === THREE.DotScreenShader && console.error("DotScreenPass relies on THREE.DotScreenShader");
  Pass.call(this);
  this.type = "DotScreen";
  this.createQuadScene();
  this.uniforms = THREE.UniformsUtils.clone(THREE.DotScreenShader.uniforms);
  this.material = new THREE.ShaderMaterial({uniforms:this.uniforms, vertexShader:THREE.DotScreenShader.vertexShader, fragmentShader:THREE.DotScreenShader.fragmentShader});
  Object.defineProperties(this, {center:{get:function() {
    return this.uniforms.center.value;
  }, set:function(a) {
    this.uniforms.center.value = a;
  }}, angle:{get:function() {
    return this.uniforms.angle.value;
  }, set:function(a) {
    this.uniforms.angle.value = a;
  }}, scale:{get:function() {
    return this.uniforms.scale.value;
  }, set:function(a) {
    this.uniforms.scale.value = a;
  }}});
  void 0 !== a && this.center.copy(a);
  this.angle = void 0 !== c ? c : .5;
  this.scale = void 0 !== g ? g : .8;
}
DotScreenPass.prototype = Object.create(Pass.prototype);
DotScreenPass.prototype.render = function(a, c, g, b, e, f, k) {
  this.uniforms.tDiffuse.value = g.texture;
  this.uniforms.tSize.value.set(g.width, g.height);
  this.quad.material = this.material;
  !0 === this.clear && a.clear();
  a.setRenderTarget(this.renderToScreen ? void 0 : c);
  a.render(this.scene, this.camera);
};
DotScreenPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.center = this.center.toArray();
  a.angle = this.angle;
  a.scale = this.scale;
  return a;
};
"use strict";
function SobelPass(a, c, g) {
  void 0 === THREE.SobelOperatorShader && console.error("SobelPass relies on THREE.SobelOperatorShader");
  void 0 === THREE.LuminosityShader && console.error("SobelPass relies on THREE.LuminosityShader");
  ShaderPass.call(this, THREE.SobelOperatorShader);
  this.type = "Sobel";
}
SobelPass.prototype = Object.create(ShaderPass.prototype);
SobelPass.prototype.setSize = function(a, c) {
  this.uniforms.resolution.value.set(a, c);
};
"use strict";
function ColorifyPass() {
  ShaderPass.call(this, THREE.ColorifyShader);
  this.type = "Colorify";
  Object.defineProperties(this, {color:{get:function() {
    return this.uniforms.color.value;
  }, set:function(a) {
    this.uniforms.color.value = a;
  }}});
}
ColorifyPass.prototype = Object.create(ShaderPass.prototype);
ColorifyPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.color = this.color.getHex();
  return a;
};
"use strict";
function TechnicolorPass() {
  ShaderPass.call(this, THREE.TechnicolorShader);
  this.type = "Technicolor";
}
TechnicolorPass.prototype = Object.create(ShaderPass.prototype);
"use strict";
function HueSaturationPass(a, c) {
  ShaderPass.call(this, THREE.HueSaturationShader);
  this.type = "HueSaturation";
  Object.defineProperties(this, {hue:{get:function() {
    return this.uniforms.hue.value;
  }, set:function(a) {
    this.uniforms.hue.value = a;
  }}, saturation:{get:function() {
    return this.uniforms.saturation.value;
  }, set:function(a) {
    this.uniforms.saturation.value = a;
  }}});
  this.hue = void 0 !== a ? a : 0;
  this.saturation = void 0 !== c ? c : 0;
}
HueSaturationPass.prototype = Object.create(ShaderPass.prototype);
HueSaturationPass.prototype.toJSON = function(a) {
  a = Pass.prototype.toJSON.call(this, a);
  a.hue = this.hue;
  a.saturation = this.saturation;
  return a;
};
"use strict";
var SSAOShader = {uniforms:{tDiffuse:{value:null}, tDepth:{value:null}, size:{value:new THREE.Vector2(512, 512)}, cameraNear:{value:1}, cameraFar:{value:100}, radius:{value:32}, onlyAO:{value:0}, aoClamp:{value:.25}, lumInfluence:{value:.7}}, vertexShader:"\n\tvarying vec2 vUv;\n\tvoid main()\n\t{\n\t\tvUv = uv;\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t}", fragmentShader:"\n\tuniform float cameraNear;\n\tuniform float cameraFar;\n\n\t#ifdef USE_LOGDEPTHBUF\n\t\tuniform float logDepthBufFC;\n\t#endif\n\n\tuniform float radius; //ao radius \n\tuniform bool onlyAO; //use only ambient occlusion pass?\n\n\tuniform vec2 size; //texture width, height\n\tuniform float aoClamp; //depth clamp - reduces haloing at screen edges\n\n\tuniform float lumInfluence; //how much luminance affects occlusion\n\n\tuniform sampler2D tDiffuse;\n\tuniform sampler2D tDepth;\n\n\tvarying vec2 vUv;\n\n\t#define DL 2.399963229728653 //PI *(3.0 - sqrt(5.0))\n\t#define EULER 2.718281828459045\n\n\t//user variables\n\tconst int samples = 64; //ao sample count\n\tconst bool useNoise = true; //use noise instead of pattern for sample dithering\n\tconst float noiseAmount = 0.0004; //dithering amount\n\tconst float diffArea = 0.4; //self-shadowing reduction\n\tconst float gDisplace = 0.4; //gauss bell center\n\n\t//RGBA depth\n\t#include <packing>\n\n\t//generating noise / pattern texture for dithering\n\tvec2 rand(const vec2 coord)\n\t{\n\t\tvec2 noise;\n\n\t\tif(useNoise)\n\t\t{\n\t\t\tfloat nx = dot(coord, vec2(12.9898, 78.233));\n\t\t\tfloat ny = dot(coord, vec2(12.9898, 78.233) * 2.0);\n\t\t\tnoise = clamp(fract(43758.5453 * sin(vec2(nx, ny))), 0.0, 1.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat ff = fract(1.0 - coord.s *(size.x / 2.0));\n\t\t\tfloat gg = fract(coord.t *(size.y / 2.0));\n\t\t\tnoise = vec2(0.25, 0.75) * vec2(ff) + vec2(0.75, 0.25) * gg;\n\t\t}\n\n\t\treturn(noise * 2.0  - 1.0) * noiseAmount;\n\t}\n\n\tfloat readDepth(const in vec2 coord) {\n\n\t\tfloat cameraFarPlusNear = cameraFar + cameraNear;\n\t\tfloat cameraFarMinusNear = cameraFar - cameraNear;\n\t\tfloat cameraCoef = 2.0 * cameraNear;\n\n\t\t#ifdef USE_LOGDEPTHBUF\n\t\t\tfloat logz = unpackRGBAToDepth(texture2D(tDepth, coord));\n\t\t\tfloat w = pow(2.0, (logz / logDepthBufFC)) - 1.0;\n\t\t\tfloat z = (logz / w) + 1.0;\n\t\t#else\n\t\t\tfloat z = unpackRGBAToDepth(texture2D(tDepth, coord));\n\t\t#endif\n\n\t\treturn cameraCoef /(cameraFarPlusNear - z * cameraFarMinusNear);\n\t}\n\n\tfloat compareDepths(const in float depth1, const in float depth2, inout int far)\n\t{\n\t\tfloat garea = 8.0; //gauss bell width\n\t\tfloat diff =(depth1 - depth2) * 100.0; //depth difference (0-100)\n\n\t\t//reduce left bell width to avoid self-shadowing\n\t\tif(diff < gDisplace)\n\t\t{\n\t\t\tgarea = diffArea;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfar = 1;\n\t\t}\n\n\t\tfloat dd = diff - gDisplace;\n\t\tfloat gauss = pow(EULER, -2.0 *(dd * dd) /(garea * garea));\n\t\treturn gauss;\n\t}\n\n\tfloat calcAO(float depth, float dw, float dh)\n\t{\n\t\tvec2 vv = vec2(dw, dh);\n\t\tvec2 coord1 = vUv + radius * vv;\n\t\tvec2 coord2 = vUv - radius * vv;\n\n\t\tfloat temp1 = 0.0;\n\t\tfloat temp2 = 0.0;\n\n\t\tint far = 0;\n\t\ttemp1 = compareDepths(depth, readDepth(coord1), far);\n\n\t\t//DEPTH EXTRAPOLATION\n\t\tif(far > 0)\n\t\t{\n\t\t\ttemp2 = compareDepths(readDepth(coord2), depth, far);\n\t\t\ttemp1 +=(1.0 - temp1) * temp2;\n\t\t}\n\n\t\treturn temp1;\n\t}\n\n\tvoid main()\n\t{\n\t\tvec2 noise = rand(vUv);\n\t\tfloat depth = readDepth(vUv);\n\n\t\tfloat tt = clamp(depth, aoClamp, 1.0);\n\n\t\tfloat w =(1.0 / size.x) / tt +(noise.x *(1.0 - noise.x));\n\t\tfloat h =(1.0 / size.y) / tt +(noise.y *(1.0 - noise.y));\n\n\t\tfloat ao = 0.0;\n\n\t\tfloat dz = 1.0 / float(samples);\n\t\tfloat l = 0.0;\n\t\tfloat z = 1.0 - dz / 2.0;\n\n\t\tfor(int i = 0; i <= samples; i ++)\n\t\t{\n\t\t\tfloat r = sqrt(1.0 - z);\n\n\t\t\tfloat pw = cos(l) * r;\n\t\t\tfloat ph = sin(l) * r;\n\t\t\tao += calcAO(depth, pw * w, ph * h);\n\t\t\tz = z - dz;\n\t\t\tl = l + DL;\n\t\t}\n\n\t\tao /= float(samples);\n\t\tao = 1.0 - ao;\n\n\t\tvec3 color = texture2D(tDiffuse, vUv).rgb;\n\n\t\tvec3 lumcoeff = vec3(0.299, 0.587, 0.114);\n\t\tfloat lum = dot(color.rgb, lumcoeff);\n\t\tvec3 luminance = vec3(lum);\n\n\t\tvec3 final = vec3(color * mix(vec3(ao), vec3(1.0), luminance * lumInfluence)); //mix(color * ao, white, luminance)\n\n\t\tif(onlyAO)\n\t\t{\n\t\t\tfinal = vec3(mix(vec3(ao), vec3(1.0), luminance * lumInfluence)); //ambient occlusion only\n\t\t}\n\n\t\tgl_FragColor = vec4(final, 1.0);\n\t}"};
"use strict";
function VRControls() {
  this.display = null;
  this.scale = 1;
  this.standing = !1;
  this.userHeight = 1.6;
  this.frameData = null;
  void 0 !== VRFrameData && (this.frameData = new VRFrameData);
  this.position = new THREE.Vector3;
  this.quaternion = new THREE.Quaternion;
  if (void 0 !== navigator.getVRDisplays) {
    var a = this;
    navigator.getVRDisplays().then(function(c) {
      0 < c.length ? a.display = c[0] : console.warn("nunuStudio: No VR display is available.");
    });
  }
}
VRControls.prototype.update = function(a) {
  if (null !== this.display) {
    if (this.display.getFrameData) {
      this.display.getFrameData(this.frameData);
      var c = this.frameData.pose;
    } else {
      c = this.display.getPose();
    }
    null !== c.orientation && this.quaternion.fromArray(c.orientation);
    null !== c.position ? this.position.fromArray(c.position) : this.position.set(0, 0, 0);
    this.standing && (this.position.y += this.userHeight);
    this.position.multiplyScalar(this.scale);
    null !== a && (a.position.copy(this.position), a.quaternion.copy(this.quaternion));
  }
};
VRControls.prototype.dispose = function() {
  this.display = null;
};
VRControls.prototype.resetPose = function() {
  null !== this.display && this.display.resetPose();
};
"use strict";
function VREffect(a, c) {
  var g, b, e, f, k, n, p, m;
  function t(a) {
    0 < a.length ? u = a[0] : c && c("nunuStudio: HMD not available");
  }
  function d() {
    var b = C.isPresenting;
    C.isPresenting = void 0 !== u && u.isPresenting;
    if (C.isPresenting) {
      var c = u.getEyeParameters("left"), d = c.renderWidth;
      c = c.renderHeight;
      b || (E = a.getPixelRatio(), A = a.getSize(), a.setPixelRatio(1), a.setSize(2 * d, c, !1));
    } else {
      b && (a.setPixelRatio(E), a.setSize(A.width, A.height, D));
    }
  }
  function l(a, b, c, d) {
    var e = Math.PI / 180;
    var f = Math.tan(a.upDegrees * e);
    var g = Math.tan(a.downDegrees * e), k = Math.tan(a.leftDegrees * e);
    a = Math.tan(a.rightDegrees * e);
    c = void 0 === c ? .01 : c;
    d = void 0 === d ? 1E4 : d;
    e = void 0 === b || b ? -1 : 1;
    var l = new THREE.Matrix4, m = l.elements, n = 2 / (k + a), p = 2 / (f + g);
    b = [n, p];
    f = [(k - a) * n * .5, (f - g) * p * .5];
    m[0] = b[0];
    m[1] = 0;
    m[2] = f[0] * e;
    m[3] = 0;
    m[4] = 0;
    m[5] = b[1];
    m[6] = -f[1] * e;
    m[7] = 0;
    m[8] = 0;
    m[9] = 0;
    m[10] = d / (c - d) * -e;
    m[11] = d * c / (c - d);
    m[12] = 0;
    m[13] = 0;
    m[14] = e;
    m[15] = 0;
    l.transpose();
    return l;
  }
  var u, w = new THREE.Vector3, y = new THREE.Vector3, x = new THREE.Matrix4, q = new THREE.Matrix4, v = new THREE.Matrix4, z = null;
  void 0 !== window.VRFrameData && (z = new window.VRFrameData);
  navigator.getVRDisplays && navigator.getVRDisplays().then(t).catch(function() {
    console.warn("nunuStudio: Unable to get VR Displays");
  });
  this.isPresenting = !1;
  var C = this, A = a.getSize(), D = !1, E = a.getPixelRatio();
  this.getVRDisplay = function() {
    return u;
  };
  this.setVRDisplay = function(a) {
    u = a;
  };
  this.setSize = function(b, c, d) {
    A = {width:b, height:c};
    D = d;
    C.isPresenting ? (b = u.getEyeParameters("left"), a.setPixelRatio(1), a.setSize(2 * b.renderWidth, b.renderHeight, !1)) : (a.setPixelRatio(E), a.setSize(b, c, d));
  };
  var B = a.domElement, G = [0, 0, .5, 1], H = [.5, 0, .5, 1];
  window.addEventListener("vrdisplaypresentchange", d, !1);
  this.setFullScreen = function(a) {
    return new Promise(function(b, c) {
      void 0 === u ? c(Error("No VR hardware found.")) : C.isPresenting === a ? b() : a ? b(u.requestPresent([{source:B}])) : b(u.exitPresent());
    });
  };
  this.requestPresent = function() {
    return this.setFullScreen(!0);
  };
  this.exitPresent = function() {
    return this.setFullScreen(!1);
  };
  this.requestAnimationFrame = function(a) {
    return void 0 !== u ? u.requestAnimationFrame(a) : window.requestAnimationFrame(a);
  };
  this.cancelAnimationFrame = function(a) {
    void 0 !== u ? u.cancelAnimationFrame(a) : window.cancelAnimationFrame(a);
  };
  this.submitFrame = function() {
    void 0 !== u && C.isPresenting && u.submitFrame();
  };
  this.autoSubmitFrame = !0;
  var K = new THREE.PerspectiveCamera;
  K.layers.enable(1);
  var I = new THREE.PerspectiveCamera;
  I.layers.enable(2);
  this.render = function(c, d, t, A) {
    if (u && C.isPresenting) {
      var B = c.autoUpdate;
      B && (c.updateMatrixWorld(), c.autoUpdate = !1);
      var D = a.getSize(), E = u.getLayers();
      if (E.length) {
        var J = E[0];
        E = null !== J.leftBounds && 4 === J.leftBounds.length ? J.leftBounds : G;
        J = null !== J.rightBounds && 4 === J.rightBounds.length ? J.rightBounds : H;
      } else {
        E = G, J = H;
      }
      k = Math.round(D.width * E[0]);
      n = Math.round(D.height * E[1]);
      p = Math.round(D.width * E[2]);
      m = Math.round(D.height * E[3]);
      g = Math.round(D.width * J[0]);
      b = Math.round(D.height * J[1]);
      e = Math.round(D.width * J[2]);
      f = Math.round(D.height * J[3]);
      a.setClearColor(c.background);
      (a.autoClear || A) && a.clear(!0, !0, !0);
      t ? (a.setRenderTarget(t), t.scissorTest = !0) : (a.setRenderTarget(null), a.setScissorTest(!0));
      null === d.parent && d.updateMatrixWorld();
      d.matrixWorld.decompose(K.position, K.quaternion, K.scale);
      I.position.copy(K.position);
      I.quaternion.copy(K.quaternion);
      I.scale.copy(K.scale);
      u.getFrameData ? (u.depthNear = d.near, u.depthFar = d.far, u.getFrameData(z), K.projectionMatrix.elements = z.leftProjectionMatrix, I.projectionMatrix.elements = z.rightProjectionMatrix, d = z, d.pose.orientation ? (L.fromArray(d.pose.orientation), x.makeRotationFromQuaternion(L)) : x.identity(), d.pose.position && (R.fromArray(d.pose.position), x.setPosition(R)), q.fromArray(d.leftViewMatrix), q.multiply(x), v.fromArray(d.rightViewMatrix), v.multiply(x), q.getInverse(q), v.getInverse(v), 
      K.updateMatrix(), K.matrix.multiply(q), K.matrix.decompose(K.position, K.quaternion, K.scale), I.updateMatrix(), I.matrix.multiply(v), I.matrix.decompose(I.position, I.quaternion, I.scale)) : (E = u.getEyeParameters("left"), J = u.getEyeParameters("right"), K.projectionMatrix = l(E.fieldOfView, !0, d.near, d.far), I.projectionMatrix = l(J.fieldOfView, !0, d.near, d.far), w.fromArray(E.offset), y.fromArray(J.offset), K.translateOnAxis(w, K.scale.x), I.translateOnAxis(y, I.scale.x));
      t ? (t.viewport.set(k, n, p, m), t.scissor.set(k, n, p, m)) : (a.setViewport(k, n, p, m), a.setScissor(k, n, p, m));
      a.render(c, K, t, A);
      t ? (t.viewport.set(g, b, e, f), t.scissor.set(g, b, e, f)) : (a.setViewport(g, b, e, f), a.setScissor(g, b, e, f));
      a.render(c, I, t, A);
      t ? (t.viewport.set(0, 0, D.width, D.height), t.scissor.set(0, 0, D.width, D.height), t.scissorTest = !1, a.setRenderTarget(null)) : (a.setViewport(0, 0, D.width, D.height), a.setScissorTest(!1));
      B && (c.autoUpdate = !0);
      C.autoSubmitFrame && C.submitFrame();
    } else {
      a.render(c, d, t, A);
    }
  };
  this.dispose = function() {
    window.removeEventListener("vrdisplaypresentchange", d, !1);
  };
  var L = new THREE.Quaternion, R = new THREE.Vector3;
}
"use strict";
function Resource(a, c) {
  this.name = a;
  this.uuid = THREE.Math.generateUUID();
  this.type = c;
  this.encoding = this.format = "";
  this.data = null;
}
Resource.prototype.export = function(a) {
  "base64" === this.format ? FileSystem.writeFileBase64(a, this.data) : "arraybuffer" === this.format ? FileSystem.writeFileArrayBuffer(a, void 0 !== this.arraybuffer ? this.arraybuffer : this.data) : "string" === this.format ? FileSystem.writeFile(a, this.data) : "json" === this.format ? FileSystem.writeFile(a, JSON.stringify(this.data)) : "url" === this.format && FileSystem.writeFileArrayBuffer(a, FileSystem.readFileArrayBuffer(this.data));
};
Resource.prototype.toJSON = function(a) {
  a = {};
  a.name = this.name;
  a.uuid = this.uuid;
  a.type = this.type;
  return a;
};
"use strict";
function Font(a) {
  Resource.call(this, "font", "Font");
  this.reversed = !1;
  this.font = null;
  if (void 0 !== a) {
    if (a instanceof ArrayBuffer) {
      this.data = a, this.format = "arraybuffer", this.loadTTF();
    } else {
      if ("object" === typeof a) {
        this.font = this.data = a, this.encoding = this.format = "json";
      } else {
        if (this.encoding = FileSystem.getFileExtension(a), this.name = FileSystem.getFileName(a), "json" === this.encoding) {
          this.data = JSON.parse(FileSystem.readFile(a)), this.format = "json", this.font = this.data;
        } else {
          if ("ttf" === this.encoding || "otf" === this.encoding || "ttc" === this.encoding || "otc" === this.encoding) {
            this.data = FileSystem.readFileArrayBuffer(a), this.format = "arraybuffer", this.loadTTF();
          }
        }
      }
    }
  }
}
Font.prototype = Object.create(Resource.prototype);
Font.fileIsFont = function(a) {
  return void 0 !== a ? (a = a.name.toLocaleLowerCase(), a.endsWith("ttf") || a.endsWith("otf") || a.endsWith("ttc") || a.endsWith("otc") || a.endsWith("json")) : !1;
};
Font.prototype.isFont = !0;
Font.prototype.reverseGlyphs = function() {
  this.reversed = !this.reversed;
  this.loadTTF();
};
Font.prototype.loadTTF = function() {
  var a = new THREE.TTFLoader;
  a.reversed = this.reversed;
  this.font = a.parse(this.data);
};
Font.prototype.toJSON = function(a) {
  if (void 0 !== a.fonts[this.uuid]) {
    return a.fonts[this.uuid];
  }
  var c = Resource.prototype.toJSON.call(this, a);
  c.encoding = this.encoding;
  c.reversed = this.reversed;
  "arraybuffer" === this.format ? (c.data = this.data, c.format = this.format) : "base64" === this.format ? (c.data = ArraybufferUtils.fromBase64(this.data), c.format = "arraybuffer") : (c.data = this.data, c.format = this.format);
  return a.fonts[this.uuid] = c;
};
Font.prototype.generateShapes = function(a, c, g) {
  void 0 === c && (c = 100);
  void 0 === g && (g = 10);
  var b = this.font;
  a = String(a).split("");
  var e = c / b.resolution, f = (b.boundingBox.yMax - b.boundingBox.yMin) * e, k = 0, n = 0;
  c = [];
  for (var p = 0; p < a.length; p++) {
    var m = a[p];
    if ("\n" === m) {
      n -= f, k = 0;
    } else {
      var t;
      var d = e;
      var l = k, u = n;
      if (m = b.glyphs[m] || b.glyphs["?"]) {
        var w = new THREE.ShapePath, y = [], x = THREE.ShapeUtils.b2, q = THREE.ShapeUtils.b3;
        if (m.o) {
          for (var v = m._cachedOutline || (m._cachedOutline = m.o.split(" ")), z = 0, C = v.length; z < C;) {
            var A = v[z++];
            if ("m" === A) {
              var D = v[z++] * d + l;
              var E = v[z++] * d + u;
              w.moveTo(D, E);
            }
            if ("l" === A) {
              D = v[z++] * d + l, E = v[z++] * d + u, w.lineTo(D, E);
            } else {
              if ("q" === A) {
                var B = v[z++] * d + l;
                var G = v[z++] * d + u;
                var H = v[z++] * d + l;
                A = v[z++] * d + u;
                w.quadraticCurveTo(H, A, B, G);
                if (t = y[y.length - 1]) {
                  var K = t.x;
                  t = t.y;
                  for (var I = 1; I <= g; I++) {
                    var L = I / g;
                    x(L, K, H, B);
                    x(L, t, A, G);
                  }
                }
              } else {
                if ("b" === A && (B = v[z++] * d + l, G = v[z++] * d + u, H = v[z++] * d + l, A = v[z++] * d + u, D = v[z++] * d + l, E = v[z++] * d + u, w.bezierCurveTo(H, A, D, E, B, G), t = y[y.length - 1])) {
                  for (K = t.x, t = t.y, I = 1; I <= g; I++) {
                    L = I / g, q(L, K, H, D, B), q(L, t, A, E, G);
                  }
                }
              }
            }
          }
        }
        d = {width:m.ha * d, path:w};
      } else {
        d = void 0;
      }
      k += d.width;
      c.push(d.path);
    }
  }
  g = [];
  for (b = 0; b < c.length; b++) {
    Array.prototype.push.apply(g, c[b].toShapes());
  }
  return g;
};
"use strict";
function Video(a, c) {
  Resource.call(this, "video", "Video");
  void 0 !== a && (a instanceof ArrayBuffer ? this.loadArrayBufferData(a, c) : Base64Utils.isBase64(a) ? (this.encoding = Base64Utils.getFileFormat(a), this.format = "base64", this.data = a) : this.loadArrayBufferData(FileSystem.readFileArrayBuffer(a), FileSystem.getFileExtension(a)));
}
Video.prototype = Object.create(Resource.prototype);
Video.fileIsVideo = function(a) {
  return void 0 !== a && a.type.startsWith("video") ? !0 : !1;
};
Video.prototype.loadArrayBufferData = function(a, c) {
  var g = new Uint8Array(a);
  g = new Blob([g], {type:"video/" + c});
  this.data = URL.createObjectURL(g);
  this.arraybuffer = a;
  this.encoding = c;
  this.format = "arraybuffer";
};
Video.prototype.toJSON = function(a) {
  if (void 0 !== a.videos[this.uuid]) {
    return a.videos[this.uuid];
  }
  var c = Resource.prototype.toJSON.call(this, a);
  c.encoding = this.encoding;
  "arraybuffer" === this.format ? (c.format = this.format, c.data = this.arraybuffer) : "base64" === this.format ? (c.format = "arraybuffer", c.data = ArraybufferUtils.fromBase64(Base64Utils.removeHeader(this.data))) : (c.format = this.format, c.data = this.data);
  return a.videos[this.uuid] = c;
};
"use strict";
function Audio(a, c) {
  Resource.call(this, "audio", "Audio");
  void 0 !== a && (a instanceof ArrayBuffer ? (this.data = a, this.encoding = void 0 !== c ? c : "") : Base64Utils.isBase64(a) ? (this.encoding = void 0 !== c ? c : "", this.data = ArraybufferUtils.fromBase64(a)) : (this.data = FileSystem.readFileArrayBuffer(a), this.encoding = FileSystem.getFileExtension(a)), this.format = "arraybuffer");
}
Audio.prototype = Object.create(Resource.prototype);
Audio.fileIsAudio = function(a) {
  return void 0 !== a && a.type.startsWith("audio") ? !0 : !1;
};
Audio.prototype.getAudioBuffer = function(a, c) {
  a.decodeAudioData(this.data.slice(0), c, function(a) {
    console.error("nunuStudio: Cannot decode audio buffer (" + a + ")");
  });
};
Audio.prototype.toJSON = function(a) {
  if (void 0 !== a.audio[this.uuid]) {
    return a.audio[this.uuid];
  }
  var c = Resource.prototype.toJSON.call(this, a);
  c.encoding = this.encoding;
  c.data = this.data;
  c.format = this.format;
  return a.audio[this.uuid] = c;
};
"use strict";
function Image(a, c) {
  Resource.call(this, "image", "Image");
  this.height = this.width = -1;
  void 0 !== a ? a instanceof ArrayBuffer ? this.loadArrayBufferData(a, c) : (Base64Utils.isBase64(a) ? (this.encoding = Base64Utils.getFileFormat(a), this.format = "base64") : (this.encoding = FileSystem.getFileExtension(a), this.format = "url"), this.data = a) : this.createSolidColor();
}
Image.prototype = Object.create(Resource.prototype);
Image.fileIsImage = function(a) {
  if (void 0 !== a) {
    if (a.type.startsWith("image")) {
      return !0;
    }
    a = a.name.toLocaleLowerCase();
    return a.endsWith("tga") || a.endsWith("dds") || a.endsWith("pvr") || a.endsWith("ktx");
  }
  return !1;
};
Image.prototype.createSolidColor = function(a) {
  var c = document.createElement("canvas");
  c.width = 1;
  c.height = 1;
  var g = c.getContext("2d");
  g.fillStyle = void 0 !== a ? a : MathUtils.randomColor();
  g.fillRect(0, 0, 1, 1);
  this.data = c.toDataURL("image/png");
  this.format = "base64";
  this.encoding = "png";
};
Image.prototype.loadArrayBufferData = function(a, c) {
  var g = new Uint8Array(a);
  g = new Blob([g], {type:"image/" + c});
  this.data = URL.createObjectURL(g);
  this.arraybuffer = a;
  this.encoding = c;
  this.format = "arraybuffer";
};
Image.prototype.hasTransparency = function() {
  return "png" === this.encoding || "gif" === this.encoding;
};
Image.prototype.compressJPEG = function(a) {
  var c = document.createElement("img");
  c.src = this.data;
  var g = document.createElement("canvas");
  g.width = c.width;
  g.height = c.height;
  g.getContext("2d").drawImage(c, 0, 0, c.width, c.height);
  var b = this;
  g.toBlob(function(a) {
    var c = new FileReader;
    c.onload = function() {
      b.encoding = "jpeg";
      b.format = "arraybuffer";
      b.data = c.result;
    };
    c.readAsArrayBuffer(a);
  }, "image/jpeg", void 0 !== a ? a : .7);
};
Image.prototype.toJSON = function(a) {
  if (void 0 !== a.images[this.uuid]) {
    return a.images[this.uuid];
  }
  var c = Resource.prototype.toJSON.call(this, a);
  "url" === this.format && this.loadArrayBufferData(FileSystem.readFileArrayBuffer(this.data), this.encoding);
  c.width = this.width;
  c.height = this.height;
  c.encoding = this.encoding;
  "arraybuffer" === this.format ? (c.format = this.format, c.data = this.arraybuffer) : "base64" === this.format ? (c.format = "arraybuffer", c.data = ArraybufferUtils.fromBase64(Base64Utils.removeHeader(this.data))) : (c.format = this.format, c.data = this.data);
  return a.images[this.uuid] = c;
};
"use strict";
function Model() {
  Resource.call(this, "model", "Model");
}
Model.prototype = Object.create(Resource.prototype);
Model.extensions = "gcode drc assimp assimp.json blend amf babylon prwm svg obj 3ds dae gltf glb 3mf awd ply vtk vtp wrl vrml fbx pcd stl json x".split(" ");
Model.fileIsModel = function(a) {
  if (void 0 !== a) {
    a = a.name.toLocaleLowerCase();
    for (var c = 0; c < Model.extensions.length; c++) {
      if (a.endsWith(Model.extensions[c])) {
        return !0;
      }
    }
  }
  return !1;
};
"use strict";
function TextFile(a, c) {
  Resource.call(this, "text", "TextFile");
  this.format = "string";
  this.encoding = void 0 !== c ? c : "txt";
  this.data = void 0 !== a ? a : "";
}
TextFile.prototype = Object.create(Resource.prototype);
TextFile.extensions = ".js .txt .glsl .json .xml .yaml .csv .css .html".split(" ");
TextFile.fileIsText = function(a) {
  a = a.name.toLocaleLowerCase();
  for (var c = 0; c < TextFile.extensions.length; c++) {
    if (a.endsWith(TextFile.extensions[c])) {
      return !0;
    }
  }
  return !1;
};
TextFile.prototype.toJSON = function(a) {
  if (void 0 !== a.resources[this.uuid]) {
    return a.resources[this.uuid];
  }
  var c = Resource.prototype.toJSON.call(this, a);
  c.encoding = this.encoding;
  c.data = this.data;
  c.format = this.format;
  return a.resources[this.uuid] = c;
};
"use strict";
function ResourceManager() {
  THREE.Object3D.call(this);
  ResourceManager.ResourceContainer.call(this);
}
ResourceManager.ResourceContainer = function() {
  this.images = [];
  this.videos = [];
  this.audio = [];
  this.fonts = [];
  this.materials = [];
  this.textures = [];
  this.geometries = [];
  this.resources = [];
  this.shapes = [];
  this.skeletons = [];
};
ResourceManager.prototype = Object.create(THREE.Object3D.prototype);
ResourceManager.prototype.dispose = function() {
  for (var a in this.geometries) {
    this.geometries[a].dispose();
  }
  for (a in this.textures) {
    this.textures[a].dispose();
  }
  for (a in this.materials) {
    this.materials[a].dispose();
  }
};
ResourceManager.searchObject = function(a, c, g) {
  function b(a) {
    e(a);
    void 0 === c.materials[a.uuid] && (p.materials[a.uuid] = a);
  }
  function e(a) {
    f(a.map);
    f(a.bumpMap);
    f(a.normalMap);
    f(a.displacementMap);
    f(a.specularMap);
    f(a.emissiveMap);
    f(a.alphaMap);
    f(a.roughnessMap);
    f(a.metalnessMap);
    f(a.envMap);
  }
  function f(a) {
    null !== a && void 0 !== a && (n(a), void 0 === c.textures[a.uuid] && (p.textures[a.uuid] = a));
  }
  function k(a) {
    void 0 === c.images[a.uuid] && (p.images[a.uuid] = a);
  }
  function n(a) {
    a.img instanceof Image && k(a.img);
    a.video instanceof Video && void 0 === c.videos[a.video.uuid] && (p.videos[a.video.uuid] = a.video);
    if (void 0 !== a.images) {
      for (var b = 0; b < a.images.length; b++) {
        k(a.images[b]);
      }
    }
  }
  var p = void 0 !== g ? g : new ResourceManager.ResourceContainer;
  a.traverse(function(a) {
    if (!a.locked) {
      a.font instanceof Font && void 0 === c.fonts[a.font.uuid] && (p.fonts[a.font.uuid] = a.font);
      a.audio instanceof Audio && void 0 === c.audio[a.audio.uuid] && (p.audio[a.audio.uuid] = a.audio);
      if (void 0 !== a.material && !(a instanceof LensFlare || a instanceof ParticleEmitter || a instanceof Sky || a instanceof SpineAnimation)) {
        if (a.material instanceof THREE.Material) {
          b(a.material);
        } else {
          if (a.material instanceof Array) {
            for (var d = 0; d < a.material.length; d++) {
              b(a.material[d]);
            }
          } else {
            if (a.materials instanceof Array) {
              for (d = 0; d < a.materials.length; d++) {
                b(a.materials[d]);
              }
            } else {
              if (a.material instanceof THREE.MultiMaterial) {
                var e = a.material.materials;
                for (d = 0; d < e.length; d++) {
                  b(e[d]);
                }
              }
            }
          }
        }
      }
      !(a instanceof THREE.Mesh || a instanceof THREE.SkinnedMesh) || "BufferGeometry" !== a.geometry.type && "Geometry" !== a.geometry.type || void 0 !== c.geometries[a.geometry.uuid] || (p.geometries[a.geometry.uuid] = a.geometry);
      void 0 !== a.texture && f(a.texture);
      if (a instanceof LensFlare) {
        for (d = 0; d < a.elements.length; d++) {
          f(a.elements[d].texture);
        }
      }
    }
  });
  for (var m in c.materials) {
    e(c.materials[m]);
  }
  for (m in c.textures) {
    n(c.textures[m]);
  }
  return p;
};
ResourceManager.prototype.addRes = function(a, c) {
  this[c][a.uuid] = a;
};
ResourceManager.prototype.getResByName = function(a) {
  for (var c in this) {
    for (var g in c) {
      if (g[i].name === a) {
        return g[i];
      }
    }
  }
  return null;
};
ResourceManager.prototype.removeRes = function(a, c, g, b) {
  "materials" === c ? this.removeMaterial(a, g, b) : "textures" === c ? this.removeTexture(a, g) : "fonts" === c ? this.removeFont(a, g) : "audio" === c ? this.removeAudio(a, g) : void 0 !== this[c] && void 0 !== this[c][a.uuid] && delete this[c][a.uuid];
};
ResourceManager.prototype.getResourceByName = function(a) {
  for (var c in this.resources) {
    if (this.resources[c].name === a) {
      return this.resources[c];
    }
  }
  console.warn("nunuStudio: Resource " + a + " not found");
  return null;
};
ResourceManager.prototype.addResource = function(a) {
  a instanceof Resource && (this.resources[a.uuid] = a);
};
ResourceManager.prototype.removeResource = function(a) {
  delete this.resources[a.uuid];
};
ResourceManager.prototype.getImageByName = function(a) {
  for (var c in this.images) {
    if (this.images[c].name === a) {
      return this.images[c];
    }
  }
  console.warn("nunuStudio: Resource " + a + " not found");
  return null;
};
ResourceManager.prototype.removeImage = function(a) {
  a instanceof Image && delete this.images[a.uuid];
};
ResourceManager.prototype.getVideoByName = function(a) {
  for (var c in this.videos) {
    if (this.videos[c].name === a) {
      return this.videos[c];
    }
  }
  console.warn("nunuStudio: Resource " + a + " not found");
  return null;
};
ResourceManager.prototype.removeVideo = function(a) {
  a instanceof Video && delete this.videos[a.uuid];
};
ResourceManager.prototype.getMaterialByName = function(a) {
  for (var c in this.materials) {
    if (this.materials[c].name === a) {
      return this.materials[c];
    }
  }
  console.warn("nunuStudio: Resource " + a + " not found");
  return null;
};
ResourceManager.prototype.addMaterial = function(a) {
  a instanceof THREE.Material && (this.materials[a.uuid] = a);
};
ResourceManager.prototype.removeMaterial = function(a, c, g) {
  void 0 === c && (c = new THREE.MeshBasicMaterial);
  void 0 === g && (g = new THREE.SpriteMaterial);
  a instanceof THREE.Material && (delete this.materials[a.uuid], this.traverse(function(b) {
    void 0 !== b.material && b.material.uuid === a.uuid && (b.material = b instanceof THREE.Sprite ? g : c);
  }));
};
ResourceManager.prototype.getTextureByName = function(a) {
  for (var c in this.textures) {
    if (this.textures[c].name === a) {
      return this.textures[c];
    }
  }
  console.warn("nunuStudio: Resource " + a + " not found");
  return null;
};
ResourceManager.prototype.addTexture = function(a) {
  material instanceof THREE.Texture && (this.textures[a.uuid] = a);
};
ResourceManager.prototype.removeTexture = function(a, c) {
  void 0 === c && (c = new THREE.Texture);
  a instanceof THREE.Texture && (delete this.textures[a.uuid], this.traverse(function(g) {
    void 0 !== g.material ? (g = g.material, null != g.map && g.map.uuid === a.uuid && (g.map = c, g.needsUpdate = !0), null != g.bumpMap && g.bumpMap.uuid === a.uuid && (g.bumpMap = c, g.needsUpdate = !0), null != g.normalMap && g.normalMap.uuid === a.uuid && (g.normalMap = c, g.needsUpdate = !0), null != g.displacementMap && g.displacementMap.uuid === a.uuid && (g.displacementMap = c, g.needsUpdate = !0), null != g.specularMap && g.specularMap.uuid === a.uuid && (g.specularMap = c, g.needsUpdate = 
    !0), null != g.emissiveMap && g.emissiveMap.uuid === a.uuid && (g.emissiveMap = c, g.needsUpdate = !0), null != g.alphaMap && g.alphaMap.uuid === a.uuid && (g.alphaMap = c, g.needsUpdate = !0), null != g.roughnessMap && g.roughnessMap.uuid === a.uuid && (g.roughnessMap = c, g.needsUpdate = !0), null != g.metalnessMap && g.metalnessMap.uuid === a.uuid && (g.metalnessMap = c, g.needsUpdate = !0), null != g.envMap && g.envMap.uuid === a.uuid && (g.envMap = null, g.needsUpdate = !0)) : g instanceof 
    ParticleEmitter && g.group.texture.uuid === a.uuid && (g.group.texture = c);
  }));
};
ResourceManager.prototype.getFontByName = function(a) {
  for (var c in this.fonts) {
    if (this.fonts[c].name === a) {
      return this.fonts[c];
    }
  }
  console.warn("nunuStudio: Resource " + a + " not found");
  return null;
};
ResourceManager.prototype.addFont = function(a) {
  a instanceof Font && (this.fonts[a.uuid] = a);
};
ResourceManager.prototype.removeFont = function(a, c) {
  void 0 === c && (c = new Font);
  a instanceof Font && (delete this.fonts[a.uuid], this.traverse(function(g) {
    void 0 !== g.font && g.font.uuid === a.uuid && g.setFont(c);
  }));
};
ResourceManager.prototype.getAudioByName = function(a) {
  for (var c in this.audio) {
    if (this.audio[c].name === a) {
      return this.audio[c];
    }
  }
  console.warn("nunuStudio: Resource " + a + " not found");
  return null;
};
ResourceManager.prototype.addAudio = function(a) {
  a instanceof Audio && (this.audio[a.uuid] = a);
};
ResourceManager.prototype.removeAudio = function(a, c) {
  void 0 === c && (c = new Audio);
  a instanceof Audio && (delete this.audio[a.uuid], this.traverse(function(g) {
    void 0 !== g.audio && g.audio.uuid === a.uuid && g.setAudio(c);
  }));
};
"use strict";
function VideoStream(a) {
  Video.call(this);
  this.format = "url";
  this.encoding = FileSystem.getFileExtension(a);
  this.data = a;
}
VideoStream.prototype = Object.create(Video.prototype);
"use strict";
function Texture(a, c, g, b, e, f, k, n, p, m) {
  this.img = "string" === typeof a ? new Image(a) : void 0 === a ? new Image : a;
  THREE.Texture.call(this, document.createElement("img"), c, g, b, e, f, k, n, p, m);
  var t = this;
  this.name = "texture";
  this.category = "Image";
  this.disposed = !1;
  this.format = this.img.hasTransparency() ? THREE.RGBAFormat : THREE.RGBFormat;
  this.image.crossOrigin = "anonymous";
  this.image.src = this.img.data;
  this.image.onload = function() {
    t.needsUpdate = !0;
  };
  this.image.onerror = function() {
    console.log("nunuStudio: Failed to load image " + t.img.uuid + " data.");
    t.img.createSolidColor();
    t.image.src = t.img.data;
    t.needsUpdate = !0;
  };
  if ("gif" === this.img.encoding) {
    var d = function() {
      t.disposed || (t.needsUpdate = !0, requestAnimationFrame(d));
    };
    this.generateMipmaps = !1;
    this.minFilter = this.magFilter = THREE.LinearFilter;
    d();
  }
}
Texture.prototype = Object.create(THREE.Texture.prototype);
Texture.prototype.dispose = function() {
  THREE.Texture.prototype.dispose.call(this);
  this.disposed = !0;
};
Texture.prototype.toJSON = function(a) {
  var c = THREE.Texture.prototype.toJSON.call(this, a);
  a = this.img.toJSON(a);
  c.image = a.uuid;
  return c;
};
"use strict";
function CanvasTexture(a, c, g, b, e, f, k, n, p, m, t) {
  THREE.Texture.call(this, document.createElement("canvas"), g, b, e, f, k, n, p, m, t);
  this.name = "canvas";
  this.category = "Canvas";
  this.format = THREE.RGBAFormat;
  this.width = void 0 !== a ? a : 512;
  this.height = void 0 !== c ? c : 512;
  this.context = this.image.getContext("2d");
  this.updateSize();
}
CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
CanvasTexture.prototype.updateSize = function() {
  this.image.width = this.width;
  this.image.height = this.height;
  this.context.fillStyle = "#000000";
  this.context.fillRect(0, 0, this.width, this.height);
  this.context.font = "Normal " + Math.round(this.width / 12) + "px Arial";
  this.context.textAlign = "center";
  this.context.fillStyle = "#FF0000";
  this.context.fillText("Canvas Texture", this.width / 2, this.height / 2);
  this.needsUpdate = !0;
};
CanvasTexture.prototype.clear = function(a) {
  this.context.fillStyle = a;
  this.context.fillRect(0, 0, this.width, this.height);
};
CanvasTexture.prototype.toJSON = function(a) {
  a = THREE.Texture.prototype.toJSON.call(this, a);
  a.width = this.width;
  a.height = this.height;
  return a;
};
"use strict";
function VideoTexture(a, c, g, b, e, f) {
  function k() {
    n.disposed || (n.image.readyState >= n.image.HAVE_CURRENT_DATA && (n.needsUpdate = !0), requestAnimationFrame(k));
  }
  THREE.Texture.call(this, document.createElement("video"), c, g, b, THREE.LinearFilter, THREE.LinearFilter, THREE.RGBFormat, e, f);
  this.generateMipmaps = this.disposed = !1;
  this.name = "video";
  this.category = "Video";
  this.loop = this.autoplay = !0;
  this.volume = this.playbackRate = 1;
  this.image.crossOrigin = "anonymous";
  this.image.autoplay = this.autoplay;
  this.image.playbackRate = this.playbackRate;
  this.image.loop = this.loop;
  this.image.volume = this.volume;
  this.video = null;
  this.setVideo(a);
  var n = this;
  k();
}
VideoTexture.prototype = Object.create(THREE.Texture.prototype);
VideoTexture.prototype.setVideo = function(a) {
  null === a || void 0 === a ? (this.video = null, this.image.src = null) : ("string" === typeof a ? this.video = new Video(a) : a instanceof Video && (this.video = a), this.image.src = this.video.data);
};
VideoTexture.prototype.setTime = function(a) {
  this.image.currentTime = a;
};
VideoTexture.prototype.setLoop = function(a) {
  this.loop = a;
  this.image.loop = a;
};
VideoTexture.prototype.setVolume = function(a) {
  this.volume = 0 <= a && 1 >= a ? a : 0 <= a ? 1 : 0;
  this.image.volume = this.volume;
};
VideoTexture.prototype.setAutoPlay = function(a) {
  this.autoplay = a;
  this.image.autoplay = this.autoplay;
};
VideoTexture.prototype.setPlaybackRate = function(a) {
  this.playbackRate = a;
  this.image.playbackRate = a;
};
VideoTexture.prototype.pause = function() {
  this.image.paused || this.image.pause();
};
VideoTexture.prototype.play = function() {
  this.image.paused && this.image.play();
};
VideoTexture.prototype.dispose = function() {
  THREE.Texture.prototype.dispose.call(this);
  this.disposed = !0;
  this.image.pause();
  this.image.src = "";
  this.image.load();
};
VideoTexture.prototype.toJSON = function(a) {
  var c = THREE.Texture.prototype.toJSON.call(this, a);
  a = this.video.toJSON(a);
  c.video = a.uuid;
  c.loop = this.loop;
  c.autoplay = this.autoplay;
  c.playbackRate = this.playbackRate;
  c.volume = this.volume;
  return c;
};
"use strict";
function WebcamTexture(a, c, g, b, e) {
  function f() {
    k.readyState >= k.HAVE_CURRENT_DATA && (n.needsUpdate = !0);
    n.disposed || requestAnimationFrame(f);
  }
  var k = document.createElement("video");
  k.autoplay = !0;
  k.loop = !0;
  THREE.Texture.call(this, k, a, c, g, THREE.LinearFilter, THREE.LinearFilter, THREE.RGBFormat, b, e);
  var n = this;
  this.disposed = this.generateMipmaps = !1;
  this.name = "webcam";
  this.category = "Webcam";
  this.mode = WebcamTexture.USER;
  this.stream = null;
  this.connect();
  requestAnimationFrame(f);
}
WebcamTexture.USER = 21;
WebcamTexture.ENVIRONMENT = 22;
WebcamTexture.prototype = Object.create(THREE.Texture.prototype);
WebcamTexture.prototype.connect = function() {
  var a = this.mode === WebcamTexture.USER ? {facingMode:"user"} : {facingMode:{exact:"environment"}}, c = this;
  void 0 !== navigator.webkitGetUserMedia && (navigator.getUserMedia = navigator.webkitGetUserMedia);
  navigator.getUserMedia ? navigator.getUserMedia({video:!0}, function(a) {
    c.stream = a;
    c.image.src = URL.createObjectURL(a);
  }, function(a) {
    console.warn("nunuStudio: No webcam available");
  }) : navigator.mediaDevices.getUserMedia && navigator.mediaDevices.getUserMedia({video:a}).then(function(a) {
    c.stream = a;
    c.image.src = URL.createObjectURL(a);
  }).catch(function(a) {
    console.warn("nunuStudio: No webcam available");
  });
};
WebcamTexture.prototype.disconnect = function() {
  if (null !== this.stream) {
    for (var a = this.stream.getTracks(), c = 0; c < a.length; c++) {
      a[c].stop();
    }
  }
};
WebcamTexture.prototype.dispose = function() {
  THREE.Texture.prototype.dispose.call(this);
  this.disconnect();
  this.disposed = !0;
  this.image.paused || this.image.pause();
};
WebcamTexture.prototype.toJSON = function(a) {
  a = THREE.Texture.prototype.toJSON.call(this, a);
  a.mode = this.mode;
  return a;
};
"use strict";
function CubeTexture(a, c, g, b, e, f, k, n, p, m) {
  void 0 === c && (c = THREE.CubeReflectionMapping);
  for (var t = [], d = 0; 6 > d; d++) {
    t.push(document.createElement("canvas"));
  }
  THREE.Texture.call(this, t, c, g, b, e, f, k, n, p, m);
  this.images = void 0 !== a ? a : [];
  this.size = 512;
  this.flipY = !1;
  this.mode = 6 === this.images.length ? CubeTexture.CUBE : CubeTexture.CROSS;
  0 < this.images.length && this.updateImages();
  this.name = "cubetexture";
  this.category = "Cube";
}
CubeTexture.prototype = Object.create(THREE.Texture.prototype);
CubeTexture.prototype.isCubeTexture = !0;
CubeTexture.RIGHT = 0;
CubeTexture.LEFT = 1;
CubeTexture.TOP = 2;
CubeTexture.BOTTOM = 3;
CubeTexture.FRONT = 4;
CubeTexture.BACK = 5;
CubeTexture.CUBE = 20;
CubeTexture.CROSS = 21;
CubeTexture.EQUIRECTANGULAR = 22;
CubeTexture.prototype.setSize = function(a) {
  0 !== (a & a - 1) ? console.warn("nunuStudio: CubeTexture new size is not a power of two.") : this.size = a;
};
CubeTexture.prototype.setImages = function(a, c) {
  this.mode = void 0 !== c ? c : CubeTexture.CUBE;
  this.images = a;
};
CubeTexture.prototype.updateImages = function() {
  var a = this;
  if (this.mode === CubeTexture.CUBE) {
    for (var c = 0; c < this.images.length; c++) {
      "string" === typeof this.images[c] && (this.images[c] = new Image(this.images[c]));
      var g = document.createElement("img");
      g.crossOrigin = "anonymous";
      g.index = c;
      g.src = this.images[c].data;
      g.onload = function() {
        a.image[this.index].width = a.size;
        a.image[this.index].height = a.size;
        a.image[this.index].getContext("2d").drawImage(this, 0, 0, a.size, a.size);
        a.needsUpdate = !0;
      };
    }
  } else {
    if (this.mode === CubeTexture.CROSS) {
      for (c = 0; c < this.image.length; c++) {
        this.image[c].width = this.size, this.image[c].height = this.size;
      }
      g = document.createElement("img");
      g.src = this.images[0].data;
      g.onload = function() {
        var b = this.naturalWidth / 4, c = this.naturalHeight / 3;
        a.image[CubeTexture.LEFT].getContext("2d").drawImage(this, 0, c, b, c, 0, 0, a.size, a.size);
        a.image[CubeTexture.FRONT].getContext("2d").drawImage(this, b, c, b, c, 0, 0, a.size, a.size);
        a.image[CubeTexture.RIGHT].getContext("2d").drawImage(this, 2 * b, c, b, c, 0, 0, a.size, a.size);
        a.image[CubeTexture.BACK].getContext("2d").drawImage(this, 3 * b, c, b, c, 0, 0, a.size, a.size);
        a.image[CubeTexture.TOP].getContext("2d").drawImage(this, b, 0, b, c, 0, 0, a.size, a.size);
        a.image[CubeTexture.BOTTOM].getContext("2d").drawImage(this, b, 2 * c, b, c, 0, 0, a.size, a.size);
        a.needsUpdate = !0;
      };
    } else {
      if (this.mode === CubeTexture.EQUIRECTANGULAR) {
        for (c = 0; c < this.image.length; c++) {
          this.image[c].width = this.size, this.image[c].height = this.size;
        }
        g = document.createElement("img");
        g.src = this.images[0].data;
        g.onload = function() {
          var b = document.createElement("canvas");
          b.width = g.naturalWidth;
          b.height = g.naturalHeight;
          var c = b.getContext("2d");
          c.drawImage(g, 0, 0);
          b = c.getImageData(0, 0, b.width, b.height);
          for (c = 0; 6 > c; c++) {
            var f = CubeTexture.renderEquirectFace(b, c, Math.PI, a.size);
            a.image[c].getContext("2d").putImageData(f, 0, 0);
          }
          a.needsUpdate = !0;
        };
      }
    }
  }
};
CubeTexture.resampleBilinear = function(a, c, g, b, e) {
  var f = a.width, k = a.height;
  a = a.data;
  var n = THREE.Math.clamp(Math.floor(g), 0, f - 1), p = THREE.Math.clamp(Math.ceil(g), 0, f - 1);
  g -= n;
  var m = THREE.Math.clamp(Math.floor(b), 0, k - 1), t = THREE.Math.clamp(Math.ceil(b), 0, k - 1);
  b -= m;
  k = 4 * (m * f + n);
  m = 4 * (m * f + p);
  n = 4 * (t * f + n);
  f = 4 * (t * f + p);
  for (p = 0; 3 > p; p++) {
    c.data[e + p] = Math.ceil((a[k + p] * (1 - g) + a[m + p] * g) * (1 - b) + (a[n + p] * (1 - g) + a[f + p] * g) * b);
  }
};
CubeTexture.renderEquirectFace = function(a, c, g, b) {
  var e = new ImageData(b, b);
  c = CubeTexture.faces[c];
  for (var f = 0; f < b; f++) {
    for (var k = 0; k < b; k++) {
      var n = 4 * (k * b + f);
      e.data[n + 3] = 255;
      var p = c(2 * (f + .5) / b - 1, 2 * (k + .5) / b - 1), m = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z), t = THREE.Math.euclideanModulo(Math.atan2(p.y, p.x) + g, 2 * Math.PI);
      CubeTexture.resampleBilinear(a, e, a.width * t / Math.PI / 2 - .5, a.height * Math.acos(p.z / m) / Math.PI - .5, n);
    }
  }
  return e;
};
CubeTexture.faces = [function(a, c) {
  return new THREE.Vector3(a, -1, -c);
}, function(a, c) {
  return new THREE.Vector3(-a, 1, -c);
}, function(a, c) {
  return new THREE.Vector3(-c, -a, 1);
}, function(a, c) {
  return new THREE.Vector3(c, -a, -1);
}, function(a, c) {
  return new THREE.Vector3(-1, -a, -c);
}, function(a, c) {
  return new THREE.Vector3(1, a, -c);
}];
CubeTexture.prototype.toJSON = function(a) {
  var c = THREE.Texture.prototype.toJSON.call(this, a);
  c.size = this.size;
  c.mode = this.mode;
  c.images = [];
  if (this.mode === CubeTexture.EQUIRECTANGULAR || this.mode === CubeTexture.CROSS) {
    var g = this.images[0].toJSON(a);
    c.images.push(g.uuid);
  } else {
    for (var b = 0; b < this.images.length; b++) {
      g = this.images[b].toJSON(a), c.images.push(g.uuid);
    }
  }
  return c;
};
"use strict";
function CompressedTexture(a, c, g, b, e, f, k, n, p, m, t, d) {
  THREE.Texture.call(this, null, f, k, n, p, m, b, e, t, d);
  this.category = "Compressed";
  this.image = {width:c, height:g};
  this.mipmaps = a;
  this.generateMipmaps = this.flipY = this.isCubeTexture = !1;
}
CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.isCompressedTexture = !0;
CompressedTexture.prototype.toJSON = function(a) {
  a = THREE.Texture.prototype.toJSON.call(this, a);
  if (a.isCubeTexture = this.isCubeTexture) {
    a.image = [];
    for (var c = 0; c < this.image.length; c++) {
      for (var g = {mipmaps:[], format:this.image[c].format, width:this.image[c].width, height:this.image[c].height}, b = 0; b < this.image[c].mipmaps.length; b++) {
        g.mipmaps.push({width:this.image[c].mipmaps[b].width, height:this.image[c].mipmaps[b].height, data:this.image[c].mipmaps[b].data});
      }
      a.image.push(g);
    }
  } else {
    for (a.mipmaps = [], a.width = this.image.width, a.height = this.image.height, b = 0; b < this.mipmaps.length; b++) {
      a.mipmaps.push({width:this.mipmaps[b].width, height:this.mipmaps[b].height, data:this.mipmaps[b].data});
    }
  }
  return a;
};
"use strict";
function SpriteSheetTexture(a, c, g, b, e, f, k) {
  function n() {
    p.currentFrame++;
    p.currentFrame >= p._endFrame && (p.currentFrame = p._beginFrame);
    p.offset.x = p.currentFrame % p.framesHorizontal / p.framesHorizontal;
    p.offset.y = 1 - p.repeat.y - Math.floor(p.currentFrame / p.framesHorizontal) / p.framesVertical;
    p.disposed || setTimeout(n, 1E3 * p.animationSpeed);
  }
  "string" === typeof a ? this.img = new Image(a) : a instanceof Image && (this.img = a);
  THREE.Texture.call(this, document.createElement("img"), e, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.LinearFilter, THREE.LinearFilter, THREE.RGBFormat, f, k);
  this.name = "animation";
  this.category = "SpriteSheet";
  this.disposed = !1;
  this.format = this.img.hasTransparency() ? THREE.RGBAFormat : THREE.RGBFormat;
  this.repeat.set(1 / c, 1 / g);
  this.loop = !0;
  this.animationSpeed = .1;
  this._totalFrames = b;
  this._endFrame = this._beginFrame = 0;
  this._framesHorizontal = c;
  this._framesVertical = g;
  var p = this;
  Object.defineProperties(this, {framesHorizontal:{get:function() {
    return p._framesHorizontal;
  }, set:function(a) {
    p._framesHorizontal = a;
    p.repeat.x = 1 / a;
    p.totalFrames = p._framesHorizontal * p._framesVertical;
  }}, framesVertical:{get:function() {
    return p._framesVertical;
  }, set:function(a) {
    p._framesVertical = a;
    p.repeat.y = 1 / a;
    p.totalFrames = p._framesHorizontal * p._framesVertical;
  }}, endFrame:{get:function() {
    return p._endFrame;
  }, set:function(a) {
    a > p._totalFrames && (a = p._totalFrames);
    p._endFrame = a;
  }}, beginFrame:{get:function() {
    return p._beginFrame;
  }, set:function(a) {
    0 > a && (a = 0);
    p.currentFrame = a;
    p._beginFrame = a;
  }}, totalFrames:{get:function() {
    return p._totalFrames;
  }, set:function(a) {
    p._beginFrame = 0;
    p._endFrame = a;
    p._totalFrames = a;
  }}});
  this.image.crossOrigin = "anonymous";
  this.image.src = this.img.data;
  this.image.onload = function() {
    p.needsUpdate = !0;
  };
  this.currentFrame = 0;
  n();
}
SpriteSheetTexture.prototype = Object.create(THREE.Texture.prototype);
SpriteSheetTexture.prototype.setAnimationSpeed = function(a) {
  this.animationSpeed = a;
};
SpriteSheetTexture.prototype.setFrameGrid = function(a, c) {
  this._framesHorizontal = a;
  this._framesVertical = c;
  this._totalFrames = a * c;
  this.repeat.set(1 / a, 1 / c);
};
SpriteSheetTexture.prototype.setAnimationFrames = function(a, c) {
  this.beginFrame = a;
  this.endFrame = c;
};
SpriteSheetTexture.prototype.dispose = function() {
  THREE.Texture.prototype.dispose.call(this);
  this.disposed = !0;
};
SpriteSheetTexture.prototype.toJSON = function(a) {
  var c = THREE.Texture.prototype.toJSON.call(this, a);
  a = this.img.toJSON(a);
  c.image = a.uuid;
  c.loop = this.loop;
  c.animationSpeed = this.animationSpeed;
  c.framesHorizontal = this._framesHorizontal;
  c.framesVertical = this._framesVertical;
  c.totalFrames = this._totalFrames;
  c.beginFrame = this._beginFrame;
  c.endFrame = this._endFrame;
  return c;
};
"use strict";
function FontLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}
FontLoader.prototype.load = function(a, c, g, b) {
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    c(new Font(JSON.parse(a)));
  }, g, b);
};
FontLoader.prototype.parse = function(a) {
  if (void 0 !== a.data) {
    var c = new Font;
    c.name = a.name;
    c.uuid = a.uuid;
    c.encoding = a.encoding;
    void 0 !== a.reversed && (c.reversed = a.reversed);
    "arraybuffer" === a.format ? (c.format = a.format, c.data = void 0 !== a.data.toArrayBuffer ? a.data.toArrayBuffer() : a.data, c.loadTTF()) : "base64" === a.format ? (c.format = "arraybuffer", c.data = ArraybufferUtils.fromBase64(a.data), c.loadTTF()) : (c.format = a.format, c.data = a.data, c.font = a.data);
    return c;
  }
  return new Font(a);
};
"use strict";
function ImageLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.path = "";
  this.crossOrigin = "Anonymous";
}
ImageLoader.prototype.setCrossOrigin = function(a) {
  this.crossOrigin = a;
  return this;
};
ImageLoader.prototype.setPath = function(a) {
  this.path = a;
  return this;
};
ImageLoader.prototype.loadJSON = function(a, c, g, b) {
  var e = this;
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    c(e.parse(JSON.parse(a)));
  }, g, b);
};
ImageLoader.prototype.parse = function(a) {
  var c = new Image(void 0 !== a.data.toArrayBuffer ? a.data.toArrayBuffer() : a.data, a.encoding);
  c.name = a.name;
  c.uuid = a.uuid;
  void 0 !== a.width && (c.width = a.width, c.height = a.height);
  return c;
};
"use strict";
function VideoLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}
VideoLoader.prototype.load = function(a, c, g, b) {
  var e = this;
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    c(e.parse(JSON.parse(a)));
  }, g, b);
};
VideoLoader.prototype.parse = function(a) {
  var c = new Video(void 0 !== a.data.toArrayBuffer ? a.data.toArrayBuffer() : a.data, a.encoding);
  c.name = a.name;
  c.uuid = a.uuid;
  return c;
};
"use strict";
function AudioLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}
AudioLoader.prototype.load = function(a, c, g, b) {
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    c(self.parse(JSON.parse(a)));
  }, g, b);
};
AudioLoader.prototype.parse = function(a) {
  var c = new Audio;
  c.name = a.name;
  c.uuid = a.uuid;
  c.encoding = a.encoding;
  "base64" === a.format ? (c.format = "arraybuffer", c.data = ArraybufferUtils.fromBase64(a.data)) : "arraybuffer" === a.format ? (c.format = a.format, c.data = void 0 !== a.data.toArrayBuffer ? a.data.toArrayBuffer() : a.data) : (c.format = a.format, c.data = a.data);
  return c;
};
"use strict";
function MaterialLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.textures = {};
}
MaterialLoader.prototype.load = function(a, c, g, b) {
  var e = this;
  (new FileLoader(e.manager)).load(a, function(a) {
    c(e.parse(JSON.parse(a)));
  }, g, b);
};
MaterialLoader.prototype.setTextures = function(a) {
  this.textures = a;
};
MaterialLoader.prototype.parse = function(a) {
  function c(a) {
    void 0 === g[a] && console.warn("THREE.MaterialLoader: Undefined texture", a);
    return g[a];
  }
  var g = this.textures, b = new window[a.type];
  void 0 !== a.uuid && (b.uuid = a.uuid);
  void 0 !== a.name && (b.name = a.name);
  void 0 !== a.color && (void 0 === b.color && (b.color = new THREE.Color), b.color.setHex(a.color));
  void 0 !== a.roughness && (b.roughness = a.roughness);
  void 0 !== a.metalness && (b.metalness = a.metalness);
  void 0 !== a.specular && (void 0 === b.specular && (b.specular = new THREE.Color), b.specular.setHex(a.specular));
  void 0 !== a.shininess && (b.shininess = a.shininess);
  void 0 !== a.clearCoat && (b.clearCoat = a.clearCoat);
  void 0 !== a.clearCoatRoughness && (b.clearCoatRoughness = a.clearCoatRoughness);
  void 0 !== a.uniforms && (b.uniforms = a.uniforms);
  void 0 !== a.vertexShader && (b.vertexShader = a.vertexShader);
  void 0 !== a.fragmentShader && (b.fragmentShader = a.fragmentShader);
  void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors);
  void 0 !== a.fog && (b.fog = a.fog);
  void 0 !== a.blending && (b.blending = a.blending);
  void 0 !== a.side && (b.side = a.side);
  void 0 !== a.shading && (b.flatShading = 1 === a.shading);
  void 0 !== a.flatShading && (b.flatShading = a.flatShading);
  void 0 !== a.rotation && (b.rotation = a.rotation);
  void 0 !== a.linewidth && (b.linewidth = a.linewidth);
  void 0 !== a.dashSize && (b.dashSize = a.dashSize);
  void 0 !== a.gapSize && (b.gapSize = a.gapSize);
  void 0 !== a.scale && (b.scale = a.scale);
  void 0 !== a.opacity && (b.opacity = a.opacity);
  void 0 !== a.transparent && (b.transparent = a.transparent);
  void 0 !== a.alphaTest && (b.alphaTest = a.alphaTest);
  void 0 !== a.depthTest && (b.depthTest = a.depthTest);
  void 0 !== a.depthWrite && (b.depthWrite = a.depthWrite);
  void 0 !== a.colorWrite && (b.colorWrite = a.colorWrite);
  void 0 !== a.wireframe && (b.wireframe = a.wireframe);
  void 0 !== a.wireframeLinewidth && (b.wireframeLinewidth = a.wireframeLinewidth);
  void 0 !== a.wireframeLinecap && (b.wireframeLinecap = a.wireframeLinecap);
  void 0 !== a.wireframeLinejoin && (b.wireframeLinejoin = a.wireframeLinejoin);
  void 0 !== a.morphTargets && (b.morphTargets = a.morphTargets);
  void 0 !== a.morphNormals && (b.morphNormals = a.morphNormals);
  void 0 !== a.dithering && (b.dithering = a.dithering);
  void 0 !== a.visible && (b.visible = a.visible);
  void 0 !== a.userData && (b.userData = a.userData);
  void 0 !== a.skinning && (b.skinning = a.skinning);
  void 0 !== a.size && (b.size = a.size);
  void 0 !== a.sizeAttenuation && (b.sizeAttenuation = a.sizeAttenuation);
  void 0 !== a.map && (b.map = c(a.map));
  void 0 !== a.alphaMap && (b.alphaMap = c(a.alphaMap), b.transparent = !0);
  void 0 !== a.bumpMap && (b.bumpMap = c(a.bumpMap));
  void 0 !== a.bumpScale && (b.bumpScale = a.bumpScale);
  void 0 !== a.normalMap && (b.normalMap = c(a.normalMap));
  if (void 0 !== a.normalScale) {
    var e = a.normalScale;
    !1 === Array.isArray(e) && (e = [e, e]);
    b.normalScale = (new Vector2).fromArray(e);
  }
  void 0 !== a.displacementMap && (b.displacementMap = c(a.displacementMap));
  void 0 !== a.displacementScale && (b.displacementScale = a.displacementScale);
  void 0 !== a.displacementBias && (b.displacementBias = a.displacementBias);
  void 0 !== a.roughnessMap && (b.roughnessMap = c(a.roughnessMap));
  void 0 !== a.metalnessMap && (b.metalnessMap = c(a.metalnessMap));
  void 0 !== a.emissiveMap && (b.emissiveMap = c(a.emissiveMap));
  void 0 !== a.emissive && (void 0 === b.emissive && (b.emissive = new THREE.Color), b.emissive.setHex(a.emissive));
  void 0 !== a.emissiveIntensity && (b.emissiveIntensity = a.emissiveIntensity);
  void 0 !== a.matcap && (b.matcap = c(a.matcap));
  void 0 !== a.specularMap && (b.specularMap = c(a.specularMap));
  void 0 !== a.envMap && (b.envMap = c(a.envMap));
  void 0 !== a.reflectivity && (b.reflectivity = a.reflectivity);
  void 0 !== a.envMapIntensity && (b.envMapIntensity = a.envMapIntensity);
  void 0 !== a.combine && (b.combine = a.combine);
  void 0 !== a.refractionRatio && (b.refractionRatio = a.refractionRatio);
  void 0 !== a.lightMap && (b.lightMap = c(a.lightMap));
  void 0 !== a.lightMapIntensity && (b.lightMapIntensity = a.lightMapIntensity);
  void 0 !== a.aoMap && (b.aoMap = c(a.aoMap));
  void 0 !== a.aoMapIntensity && (b.aoMapIntensity = a.aoMapIntensity);
  void 0 !== a.gradientMap && (b.gradientMap = c(a.gradientMap));
  if (void 0 !== a.materials) {
    e = 0;
    for (var f = a.materials.length; e < f; e++) {
      b.materials.push(this.parse(a.materials[e]));
    }
  }
  return b;
};
"use strict";
function TextureLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.path = "";
  this.crossOrigin = "Anonymous";
  this.images = [];
  this.videos = [];
  this.fonts = [];
}
THREE._TextureLoader = THREE.TextureLoader;
THREE.TextureLoader = TextureLoader;
TextureLoader.prototype.setCrossOrigin = function(a) {
  this.crossOrigin = a;
  return this;
};
TextureLoader.prototype.setPath = function(a) {
  this.path = a;
  return this;
};
TextureLoader.prototype.setImages = function(a) {
  this.images = a;
  return this;
};
TextureLoader.prototype.setVideos = function(a) {
  this.videos = a;
  return this;
};
TextureLoader.prototype.setFonts = function(a) {
  this.fonts = a;
  return this;
};
TextureLoader.prototype.load = function(a, c, g, b) {
  try {
    var e = new Texture(this.path + a);
    void 0 !== c && c(e);
    return e;
  } catch (f) {
    return void 0 !== b && b(f), console.warn("nunuStudio: Texture not found", f), new Texture;
  }
};
TextureLoader.prototype.loadJSON = function(a, c, g, b) {
  var e = this;
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    e.parse(JSON.parse(a), c);
  }, g, b);
};
TextureLoader.prototype.parse = function(a, c) {
  var g = a.category;
  if ("Video" === g) {
    void 0 === a.video && console.warn("TextureLoader: No video specified for", a.uuid), void 0 === this.videos[a.video] && console.warn("TextureLoader: Undefined video", a.video), g = new VideoTexture(this.videos[a.video]), g.setLoop(a.loop), g.setAutoPlay(a.autoplay), g.setPlaybackRate(a.playbackRate), g.setVolume(a.volume);
  } else {
    if ("Webcam" === g) {
      g = new WebcamTexture, void 0 !== a.mode && (g.mode = a.mode);
    } else {
      if ("Compressed" === g) {
        if (a.isCubeTexture) {
          g = new CompressedTexture;
          g.image = [];
          g.isCubeTexture = !0;
          for (var b = 0; b < a.image.length; b++) {
            for (var e = 0; e < a.image[b].mipmaps.length; e++) {
              void 0 !== a.image[b].mipmaps[e].data.toArrayBuffer && (a.image[b].mipmaps[e].data = new Uint8Array(a.image[b].mipmaps[e].data.toArrayBuffer()));
            }
            g.image.push(a.image[b]);
          }
        } else {
          for (e = 0; e < a.mipmaps.length; e++) {
            void 0 !== a.mipmaps[e].data.toArrayBuffer && (a.mipmaps[e].data = new Uint8Array(a.mipmaps[e].data.toArrayBuffer()));
          }
          g = new CompressedTexture(a.mipmaps, a.width, a.height);
        }
      } else {
        if ("Cube" === g) {
          b = [];
          for (e = 0; e < a.images.length; e++) {
            void 0 === this.images[a.images[e]] && console.warn("nunuStudio: TextureLoader, undefined image", a.images[e]), b.push(this.images[a.images[e]]);
          }
          g = new CubeTexture;
          g.setImages(b, a.mode);
          g.setSize(a.size);
          g.updateImages();
        } else {
          "Canvas" === g ? g = new CanvasTexture(a.width, a.height) : (void 0 === a.image && console.warn("nunuStudio: TextureLoader, no image specified for", a.uuid), void 0 === this.images[a.image] && console.warn("nunuStudio: TextureLoader, undefined image", a.image), "SpriteSheet" === g ? (g = new SpriteSheetTexture(this.images[a.image], a.framesHorizontal, a.framesVertical, a.totalFrames), g.loop = a.loop, g.animationSpeed = a.animationSpeed, g.beginFrame = a.beginFrame, g.endFrame = a.endFrame) : 
          g = new Texture(this.images[a.image]));
        }
      }
    }
  }
  g.needsUpdate = !0;
  g.uuid = a.uuid;
  g.name = a.name;
  g.mapping = a.mapping;
  g.offset.set(a.offset[0], a.offset[1]);
  g.repeat.set(a.repeat[0], a.repeat[1]);
  void 0 !== a.center && g.center.set(a.center[0], a.center[1]);
  void 0 !== a.rotation && (g.rotation = a.rotation);
  void 0 !== a.format && (g.format = a.format);
  g.wrapS = a.wrap[0];
  g.wrapT = a.wrap[1];
  g.minFilter = a.minFilter;
  g.magFilter = a.magFilter;
  g.anisotropy = a.anisotropy;
  g.flipY = a.flipY;
  void 0 !== c && c(g);
  return g;
};
"use strict";
function GeometryLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.geometryLoader = new LegacyGeometryLoader;
  this.bufferGeometryLoader = new THREE.BufferGeometryLoader;
  this.shapes = {};
}
GeometryLoader.prototype.setShapes = function(a) {
  this.shapes = a;
  return this;
};
GeometryLoader.prototype.load = function(a, c, g, b) {
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    c(self.parse(JSON.parse(a)));
  }, g, b);
};
GeometryLoader.prototype.parse = function(a) {
  switch(a.type) {
    case "PlaneGeometry":
    case "PlaneBufferGeometry":
      var c = new THREE[a.type](a.width, a.height, a.widthSegments, a.heightSegments);
      break;
    case "BoxGeometry":
    case "BoxBufferGeometry":
    case "CubeGeometry":
      c = new THREE[a.type](a.width, a.height, a.depth, a.widthSegments, a.heightSegments, a.depthSegments);
      break;
    case "CircleGeometry":
    case "CircleBufferGeometry":
      c = new THREE[a.type](a.radius, a.segments, a.thetaStart, a.thetaLength);
      break;
    case "CylinderGeometry":
    case "CylinderBufferGeometry":
      c = new THREE[a.type](a.radiusTop, a.radiusBottom, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength);
      break;
    case "ConeGeometry":
    case "ConeBufferGeometry":
      c = new THREE[a.type](a.radius, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength);
      break;
    case "SphereGeometry":
    case "SphereBufferGeometry":
      c = new THREE[a.type](a.radius, a.widthSegments, a.heightSegments, a.phiStart, a.phiLength, a.thetaStart, a.thetaLength);
      break;
    case "DodecahedronGeometry":
    case "IcosahedronGeometry":
    case "OctahedronGeometry":
    case "TetrahedronGeometry":
    case "DodecahedronBufferGeometry":
    case "IcosahedronBufferGeometry":
    case "OctahedronBufferGeometry":
    case "TetrahedronBufferGeometry":
      c = new THREE[a.type](a.radius, a.detail);
      break;
    case "PolyhedronGeometry":
    case "PolyhedronBufferGeometry":
      c = new THREE[a.type](a.radius, a.indices, a.radius, a.detail);
      break;
    case "RingGeometry":
    case "RingBufferGeometry":
      c = new THREE[a.type](a.innerRadius, a.outerRadius, a.thetaSegments, a.phiSegments, a.thetaStart, a.thetaLength);
      break;
    case "TorusGeometry":
    case "TorusBufferGeometry":
      c = new THREE[a.type](a.radius, a.tube, a.radialSegments, a.tubularSegments, a.arc);
      break;
    case "TorusKnotGeometry":
    case "TorusKnotBufferGeometry":
      c = new THREE[a.type](a.radius, a.tube, a.tubularSegments, a.radialSegments, a.p, a.q);
      break;
    case "LatheGeometry":
    case "LatheBufferGeometry":
      c = new THREE[a.type](a.points, a.segments, a.phiStart, a.phiLength);
      break;
    case "ShapeGeometry":
    case "ShapeBufferGeometry":
      c = [];
      for (var g = 0, b = a.shapes.length; g < b; g++) {
        c.push(this.shapes[a.shapes[g]]);
      }
      c = new THREE[a.type](c, a.curveSegments);
      break;
    case "BufferGeometry":
      c = this.bufferGeometryLoader.parse(a);
      break;
    case "Geometry":
      c = this.geometryLoader.parse(a.data).geometry;
      break;
    default:
      console.warn("GeometryLoader: Unsupported geometry type " + a.type), c = new THREE.Geometry;
  }
  c.uuid = a.uuid;
  c.name = void 0 !== a.name ? a.name : "geometry";
  return c;
};
"use strict";
function LegacyGeometryLoader(a) {
  this.manager = void 0 !== a ? a : DefaultLoadingManager;
  this.withCredentials = !1;
}
LegacyGeometryLoader.prototype.load = function(a, c, g, b) {
  var e = this, f = void 0 === this.path ? LoaderUtils.extractUrlBase(a) : this.path, k = new FileLoader(this.manager);
  k.setPath(this.path);
  k.setWithCredentials(this.withCredentials);
  k.load(a, function(b) {
    b = JSON.parse(b);
    var g = b.metadata;
    if (void 0 !== g && (g = g.type, void 0 !== g && "object" === g.toLowerCase())) {
      console.error("nunuStudio: LegacyGeometryLoader: " + a + " should be loaded with ObjectLoader instead.");
      return;
    }
    b = e.parse(b, f);
    c(b.geometry, b.materials);
  }, g, b);
};
LegacyGeometryLoader.prototype.setPath = function(a) {
  this.path = a;
  return this;
};
LegacyGeometryLoader.prototype.setResourcePath = function(a) {
  this.resourcePath = a;
  return this;
};
LegacyGeometryLoader.prototype.setCrossOrigin = function(a) {
  this.crossOrigin = a;
  return this;
};
LegacyGeometryLoader.prototype.parse = function() {
  return function(a, c) {
    void 0 !== a.data && (a = a.data);
    a.scale = void 0 !== a.scale ? 1 / a.scale : 1;
    var g = new THREE.Geometry, b = a, e, f, k, n = b.faces;
    var p = b.vertices;
    var m = b.normals, t = b.colors;
    var d = b.scale;
    var l = 0;
    if (void 0 !== b.uvs) {
      for (e = 0; e < b.uvs.length; e++) {
        b.uvs[e].length && l++;
      }
      for (e = 0; e < l; e++) {
        g.faceVertexUvs[e] = [];
      }
    }
    var u = 0;
    for (k = p.length; u < k;) {
      e = new THREE.Vector3, e.x = p[u++] * d, e.y = p[u++] * d, e.z = p[u++] * d, g.vertices.push(e);
    }
    u = 0;
    for (k = n.length; u < k;) {
      p = n[u++];
      var w = p & 1;
      var y = p & 2;
      e = p & 8;
      var x = p & 16;
      var q = p & 32;
      d = p & 64;
      p &= 128;
      if (w) {
        w = new THREE.Face3;
        w.a = n[u];
        w.b = n[u + 1];
        w.c = n[u + 3];
        var v = new THREE.Face3;
        v.a = n[u + 1];
        v.b = n[u + 2];
        v.c = n[u + 3];
        u += 4;
        y && (y = n[u++], w.materialIndex = y, v.materialIndex = y);
        y = g.faces.length;
        if (e) {
          for (e = 0; e < l; e++) {
            var z = b.uvs[e];
            g.faceVertexUvs[e][y] = [];
            g.faceVertexUvs[e][y + 1] = [];
            for (f = 0; 4 > f; f++) {
              var C = n[u++];
              var A = z[2 * C];
              C = z[2 * C + 1];
              A = new THREE.Vector2(A, C);
              2 !== f && g.faceVertexUvs[e][y].push(A);
              0 !== f && g.faceVertexUvs[e][y + 1].push(A);
            }
          }
        }
        x && (x = 3 * n[u++], w.normal.set(m[x++], m[x++], m[x]), v.normal.copy(w.normal));
        if (q) {
          for (e = 0; 4 > e; e++) {
            x = 3 * n[u++], q = new THREE.Vector3(m[x++], m[x++], m[x]), 2 !== e && w.vertexNormals.push(q), 0 !== e && v.vertexNormals.push(q);
          }
        }
        d && (d = n[u++], d = t[d], w.color.setHex(d), v.color.setHex(d));
        if (p) {
          for (e = 0; 4 > e; e++) {
            d = n[u++], d = t[d], 2 !== e && w.vertexColors.push(new Color(d)), 0 !== e && v.vertexColors.push(new Color(d));
          }
        }
        g.faces.push(w);
        g.faces.push(v);
      } else {
        w = new THREE.Face3;
        w.a = n[u++];
        w.b = n[u++];
        w.c = n[u++];
        y && (y = n[u++], w.materialIndex = y);
        y = g.faces.length;
        if (e) {
          for (e = 0; e < l; e++) {
            for (z = b.uvs[e], g.faceVertexUvs[e][y] = [], f = 0; 3 > f; f++) {
              C = n[u++], A = z[2 * C], C = z[2 * C + 1], A = new THREE.Vector2(A, C), g.faceVertexUvs[e][y].push(A);
            }
          }
        }
        x && (x = 3 * n[u++], w.normal.set(m[x++], m[x++], m[x]));
        if (q) {
          for (e = 0; 3 > e; e++) {
            x = 3 * n[u++], q = new THREE.Vector3(m[x++], m[x++], m[x]), w.vertexNormals.push(q);
          }
        }
        d && (d = n[u++], w.color.setHex(t[d]));
        if (p) {
          for (e = 0; 3 > e; e++) {
            d = n[u++], w.vertexColors.push(new Color(t[d]));
          }
        }
        g.faces.push(w);
      }
    }
    b = a;
    u = void 0 !== b.influencesPerVertex ? b.influencesPerVertex : 2;
    if (b.skinWeights) {
      for (k = 0, n = b.skinWeights.length; k < n; k += u) {
        g.skinWeights.push(new Vector4(b.skinWeights[k], 1 < u ? b.skinWeights[k + 1] : 0, 2 < u ? b.skinWeights[k + 2] : 0, 3 < u ? b.skinWeights[k + 3] : 0));
      }
    }
    if (b.skinIndices) {
      for (k = 0, n = b.skinIndices.length; k < n; k += u) {
        g.skinIndices.push(new Vector4(b.skinIndices[k], 1 < u ? b.skinIndices[k + 1] : 0, 2 < u ? b.skinIndices[k + 2] : 0, 3 < u ? b.skinIndices[k + 3] : 0));
      }
    }
    g.bones = b.bones;
    g.bones && 0 < g.bones.length && (g.skinWeights.length !== g.skinIndices.length || g.skinIndices.length !== g.vertices.length) && console.warn("When skinning, number of vertices (" + g.vertices.length + "), skinIndices (" + g.skinIndices.length + "), and skinWeights (" + g.skinWeights.length + ") should match.");
    k = a;
    n = k.scale;
    if (void 0 !== k.morphTargets) {
      for (b = 0, u = k.morphTargets.length; b < u; b++) {
        for (g.morphTargets[b] = {}, g.morphTargets[b].name = k.morphTargets[b].name, g.morphTargets[b].vertices = [], m = g.morphTargets[b].vertices, t = k.morphTargets[b].vertices, l = 0, p = t.length; l < p; l += 3) {
          d = new THREE.Vector3, d.x = t[l] * n, d.y = t[l + 1] * n, d.z = t[l + 2] * n, m.push(d);
        }
      }
    }
    if (void 0 !== k.morphColors && 0 < k.morphColors.length) {
      for (n = g.faces, k = k.morphColors[0].colors, b = 0, u = n.length; b < u; b++) {
        n[b].color.fromArray(k, 3 * b);
      }
    }
    k = a;
    b = [];
    u = [];
    void 0 !== k.animation && u.push(k.animation);
    void 0 !== k.animations && (k.animations.length ? u = u.concat(k.animations) : u.push(k.animations));
    for (k = 0; k < u.length; k++) {
      (n = AnimationClip.parseAnimation(u[k], g.bones)) && b.push(n);
    }
    g.morphTargets && (u = AnimationClip.CreateClipsFromMorphTargetSequences(g.morphTargets, 10), b = b.concat(u));
    0 < b.length && (g.animations = b);
    g.computeFaceNormals();
    g.computeBoundingSphere();
    if (void 0 === a.materials || 0 === a.materials.length) {
      return {geometry:g};
    }
    a = Loader.prototype.initMaterials(a.materials, this.resourcePath || c, this.crossOrigin);
    return {geometry:g, materials:a};
  };
}();
"use strict";
function ObjectLoader(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
  this.texturePath = "";
}
ObjectLoader.prototype.load = function(a, c, g, b) {
  "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
  var e = this;
  (new THREE.FileLoader(this.manager)).load(a, function(a) {
    e.parse(JSON.parse(a), c);
  }, g, b);
};
ObjectLoader.prototype.parse = function(a, c) {
  var g = this.parseResources(a.resources), b = this.parseShape(a.shapes);
  b = this.parseGeometries(a.geometries, b);
  var e = this.parseImages(a.images), f = this.parseVideos(a.videos), k = this.parseAudio(a.audio), n = this.parseFonts(a.fonts);
  e = this.parseTextures(a.textures, e, f);
  f = this.parseMaterials(a.materials, e);
  g = this.parseObject(a.object, b, f, e, k, n, g);
  a.skeletons && (b = this.parseSkeletons(a.skeletons, g), this.bindSkeletons(g, b));
  a.animations && (g.animations = this.parseAnimations(a.animations));
  void 0 !== a.images && 0 !== a.images.length || void 0 === c || c(g);
  return g;
};
ObjectLoader.prototype.setTexturePath = function(a) {
  this.texturePath = a;
};
ObjectLoader.prototype.setCrossOrigin = function(a) {
  this.crossOrigin = a;
};
ObjectLoader.prototype.parseResources = function(a) {
  var c = [];
  if (void 0 !== a) {
    for (var g in a) {
      var b = new TextFile(a[g].data, a[g].encoding);
      b.format = a[g].format;
      b.name = a[g].name;
      b.uuid = a[g].uuid;
      c[b.uuid] = b;
    }
  }
  return c;
};
ObjectLoader.prototype.parseShape = function(a) {
  var c = {};
  if (void 0 !== a) {
    for (var g = 0, b = a.length; g < b; g++) {
      var e = (new Shape).fromJSON(a[g]);
      c[e.uuid] = e;
    }
  }
  return c;
};
ObjectLoader.prototype.parseGeometries = function(a, c) {
  var g = new GeometryLoader;
  g.setShapes(c);
  c = [];
  if (void 0 !== a) {
    for (var b = 0; b < a.length; b++) {
      c[a[b].uuid] = g.parse(a[b]);
    }
  }
  return c;
};
ObjectLoader.prototype.parseMaterials = function(a, c) {
  var g = [], b = new MaterialLoader;
  b.setTextures(c);
  if (void 0 !== a) {
    for (var e in a) {
      g[a[e].uuid] = b.parse(a[e]);
    }
  }
  return g;
};
ObjectLoader.prototype.parseAnimations = function(a) {
  for (var c = [], g = 0; g < a.length; g++) {
    var b = THREE.AnimationClip.parse(a[g]);
    void 0 !== a[g].uuid && (b.uuid = a[g].uuid);
    c.push();
  }
  return c;
};
ObjectLoader.prototype.parseImages = function(a) {
  var c = new ImageLoader, g = [];
  if (void 0 !== a) {
    for (var b in a) {
      g[a[b].uuid] = c.parse(a[b]);
    }
  }
  return g;
};
ObjectLoader.prototype.parseVideos = function(a) {
  var c = new VideoLoader, g = [];
  if (void 0 !== a) {
    for (var b in a) {
      g[a[b].uuid] = c.parse(a[b]);
    }
  }
  return g;
};
ObjectLoader.prototype.parseAudio = function(a) {
  var c = new AudioLoader, g = [];
  if (void 0 !== a) {
    for (var b in a) {
      g[a[b].uuid] = c.parse(a[b]);
    }
  }
  return g;
};
ObjectLoader.prototype.parseFonts = function(a) {
  var c = new FontLoader, g = [];
  if (void 0 !== a) {
    for (var b in a) {
      g[a[b].uuid] = c.parse(a[b]);
    }
  }
  return g;
};
ObjectLoader.prototype.parseTextures = function(a, c, g) {
  var b = [], e = new TextureLoader;
  e.setImages(c);
  e.setVideos(g);
  if (void 0 !== a) {
    for (var f in a) {
      b[a[f].uuid] = e.parse(a[f]);
    }
  }
  return b;
};
ObjectLoader.prototype.parseSkeletons = function(a, c) {
  var g = {};
  if (void 0 === a) {
    return g;
  }
  for (var b = 0; b < a.length; b++) {
    var e = a[b], f = e.uuid, k = e.bones;
    e = e.boneInverses;
    for (var n = [], p = [], m = 0, t = k.length; m < t; m++) {
      var d = c.getObjectByProperty("uuid", k[m]);
      void 0 === d && (console.warn("THREE.ObjectLoader: Not found Bone whose uuid is " + k[m]), d = new THREE.Bone);
      n.push(d);
      p.push((new THREE.Matrix4).fromArray(e[m]));
    }
    g[f] = new Skeleton(n, p);
  }
  return g;
};
ObjectLoader.prototype.bindSkeletons = function(a, c) {
  0 !== Object.keys(c).length && a.traverse(function(a) {
    if (!0 === a.isSkinnedMesh && void 0 !== a.skeletonUUID) {
      var b = c[a.skeletonUUID];
      void 0 === b ? console.warn("THREE.ObjectLoader: Not found Skeleton whose uuid is " + a.skeletonUUID) : a.bind(b, a.bindMatrix);
      delete a.skeletonUUID;
    }
  });
};
ObjectLoader.prototype.parseObject = function(a, c, g, b, e, f, k) {
  function n(a) {
    void 0 === b[a] && console.warn("ObjectLoader: Undefined texture", a);
    return b[a];
  }
  function p(a) {
    void 0 === c[a] && console.warn("ObjectLoader: Undefined geometry", a);
    return c[a];
  }
  function m(a) {
    if (a instanceof Array) {
      for (var b = [], c = 0; c < a.length; c++) {
        b.push(g[a[c]]);
      }
      return b;
    }
    void 0 === g[a] && console.warn("ObjectLoader: Undefined material", a);
    return g[a];
  }
  function t(a) {
    void 0 === f[a] && console.warn("ObjectLoader: Undefined font", a);
    return f[a];
  }
  function d(a) {
    void 0 === e[a] && console.warn("ObjectLoader: Undefined audio", a);
    return e[a];
  }
  switch(a.type) {
    case "SpineAnimation":
      for (var l = 0; l < a.textures.length; l++) {
        a.textures[l].texture = n(a.textures[l].texture);
      }
      var u = new SpineAnimation(a.json, a.atlas, "", a.textures);
      void 0 !== a.animation && (u.animation = a.animation, u.track = a.track, u.loop = a.loop);
      void 0 !== a.skin && (u.skin = a.skin);
      break;
    case "Audio":
      u = new AudioEmitter(d(a.audio));
      u.autoplay = a.autoplay;
      u.startTime = a.startTime;
      u.playbackRate = a.playbackRate;
      u.loop = void 0 !== a.source ? a.source.loop : a.loop;
      void 0 !== a.volume && (u.volume = a.volume);
      break;
    case "PositionalAudio":
      u = new PositionalAudio(d(a.audio));
      u.autoplay = a.autoplay;
      u.startTime = a.startTime;
      u.playbackRate = a.playbackRate;
      u.loop = void 0 !== a.source ? a.source.loop : a.loop;
      void 0 !== a.volume && (u.volume = a.volume);
      break;
    case "Physics":
      u = new PhysicsObject;
      u.body.type = a.body.type;
      u.body.mass = a.body.mass;
      u.body.linearDamping = a.body.linearDamping;
      u.body.angularDamping = a.body.angularDamping;
      u.body.allowSleep = a.body.allowSleep;
      u.body.sleepSpeedLimit = a.body.sleepSpeedLimit;
      u.body.sleepTimeLimit = a.body.sleepTimeLimit;
      u.body.collisionFilterGroup = a.body.collisionFilterGroup;
      u.body.collisionFilterMask = a.body.collisionFilterMask;
      u.body.fixedRotation = a.body.fixedRotation;
      var w = a.body.shapes;
      for (l = 0; l < w.length; l++) {
        var y = w[l];
        y.type === CANNON.Shape.types.SPHERE ? u.body.addShape(new CANNON.Sphere(y.radius)) : y.type === CANNON.Shape.types.BOX ? u.body.addShape(new CANNON.Box(new CANNON.Vec3(y.halfExtents.x, y.halfExtents.y, y.halfExtents.z))) : y.type === CANNON.Shape.types.PARTICLE ? u.body.addShape(new CANNON.Particle) : y.type === CANNON.Shape.types.PLANE ? u.body.addShape(new CANNON.Plane) : y.type === CANNON.Shape.types.CONVEXPOLYHEDRON && u.body.addShape(new CANNON.ConvexPolyhedron(y.vertices, y.faces));
      }
      break;
    case "ParticleEmiter":
      u = function(a) {
        return Array.isArray(a) ? (new THREE.Vector3).fromArray(a) : new THREE.Vector3(a.x, a.y, a.z);
      };
      void 0 !== a.group && (l = a.group, l.texture.value = n(l.texture.value), l.texture.frames = (new THREE.Vector2).fromArray(l.texture.frames || [1, 1]));
      if (void 0 !== a.emitter) {
        for (w = a.emitter, w.position.value = u(w.position.value), w.position.spread = u(w.position.spread), w.velocity.value = u(w.velocity.value), w.velocity.spread = u(w.velocity.spread), w.acceleration.value = u(w.acceleration.value), w.acceleration.spread = u(w.acceleration.spread), l = 0; l < w.color.value.length; l++) {
          w.color.value[l] = new THREE.Color(w.color.value[l]), w.color.spread[l] = u(w.color.spread[l]);
        }
      }
      u = new ParticleEmitter(a.group, a.emitter);
      break;
    case "LensFlare":
      u = new LensFlare;
      void 0 !== a.lensFlares && (a.elements = a.lensFlares);
      for (l = 0; l < a.elements.length; l++) {
        u.addFlare(n(a.elements[l].texture), a.elements[l].size, a.elements[l].distance, new THREE.Color(a.elements[l].color));
      }
      break;
    case "TextMesh":
    case "Text3D":
      u = new TextMesh(a.text, m(a.material), t(a.font), a.height, a.bevel, a.bevelThickness, a.bevelSize, a.size, a.curveSegments, a.extruded);
      break;
    case "Program":
      u = new Program(a.name);
      u.description = a.description;
      u.author = a.author;
      u.version = a.version;
      u.vr = a.vr;
      u.vrScale = a.vrScale;
      void 0 !== a.antialiasing && (u.antialiasing = a.antialiasing, u.shadows = a.shadows, u.shadowsType = a.shadowsType);
      void 0 !== a.toneMapping && (u.toneMapping = a.toneMapping, u.toneMappingWhitePoint = a.toneMappingWhitePoint, u.toneMappingExposure = a.toneMappingExposure);
      void 0 !== a.lockPointer && (u.lockPointer = a.lockPointer);
      void 0 !== a.defaultScene && (u.defaultScene = a.defaultScene);
      void 0 !== a.handlePixelRatio && (u.handlePixelRatio = a.handlePixelRatio);
      break;
    case "LeapDevice":
      u = new LeapMotion;
      u.mode = a.mode;
      u.useArm = a.useArm;
      void 0 !== a.debugModel && (u.debugModel = a.debugModel);
      void 0 !== a.gesturesEnabled && (u.gesturesEnabled = a.gesturesEnabled);
      void 0 !== a.posesEnabled && (u.posesEnabled = a.posesEnabled);
      break;
    case "Kinect":
      u = new KinectDevice;
      void 0 !== a.debugModel && (u.debugModel = a.debugModel);
      break;
    case "Sky":
      u = new Sky(a.autoUpdate, a.dayTime, a.sunDistance, a.time);
      void 0 !== a.sun && (u.sun.shadow.fromJSON(a.sun.shadow), void 0 !== a.sun.castShadow && (u.sun.castShadow = a.sun.castShadow));
      if (void 0 !== a.colorTop) {
        for (u.colorTop = [], l = 0; l < a.colorTop.length; l++) {
          u.colorTop.push(new THREE.Color(a.colorTop[l]));
        }
      }
      if (void 0 !== a.colorBottom) {
        for (u.colorBottom = [], l = 0; l < a.colorBottom.length; l++) {
          u.colorBottom.push(new THREE.Color(a.colorBottom[l]));
        }
      }
      void 0 !== a.sunColor && (u.sunColor = a.sunColor);
      void 0 !== a.moonColor && (u.moonColor = a.moonColor);
      void 0 !== a.intensity && (u.intensity = a.intensity);
      break;
    case "CubeCamera":
      u = new CubeCamera(a.near, a.far, a.resolution, a.autoUpdate);
      break;
    case "FirstPersonControls":
      u = new FirstPersonControls;
      u.sensitivity = a.sensitivity;
      u.needsButtonPressed = a.needsButtonPressed;
      u.movementEnabled = a.movementEnabled;
      u.moveSpeed = a.moveSpeed;
      u.moveOnPlane = a.moveOnPlane;
      u.moveKeys = a.moveKeys;
      break;
    case "OrbitControls":
      u = new OrbitControls;
      u.distance = a.distance;
      u.maxDistance = a.maxDistance;
      u.minDistance = a.minDistance;
      u.sensitivity = a.sensitivity;
      u.limitUp = a.limitUp;
      u.limitDown = a.limitDown;
      u.needsButtonPressed = a.needsButtonPressed;
      u.zoomEnabled = a.zoomEnabled;
      u.movementEnabled = a.movementEnabled;
      void 0 !== a.smooth && (u.smooth = a.smooth, u.friction = a.friction, u.speed = a.speed, u.invertNavigation = a.invertNavigation);
      void 0 !== a.center && (u.center.fromArray(a.center), u.vector.fromArray(a.vector));
      break;
    case "Scene":
      u = new Scene;
      void 0 !== a.background && (Number.isInteger(a.background) ? u.background = new THREE.Color(a.background) : u.background = n(a.background));
      void 0 !== a.fog && ("Fog" === a.fog.type ? u.fog = new THREE.Fog(a.fog.color, a.fog.near, a.fog.far) : "FogExp2" === a.fog.type && (u.fog = new THREE.FogExp2(a.fog.color, a.fog.density)));
      void 0 !== a.defaultCamera && (l = new ObjectLoader, u.defaultCamera = l.parse(a.defaultCamera));
      void 0 !== a.cameras && (u.cameras = a.cameras);
      void 0 !== a.usePhysics && (u.usePhysics = a.usePhysics);
      void 0 !== a.world && (u.world.gravity.set(a.world.gravity.x, a.world.gravity.y, a.world.gravity.z), u.world.quatNormalizeSkip = a.world.quatNormalizeSkip, u.world.quatNormalizeFast = a.world.quatNormalizeFast, u.world.solver.tolerance = a.world.solver.tolerance, u.world.solver.iterations = a.world.solver.iterations);
      break;
    case "PerspectiveCamera":
      u = new PerspectiveCamera(a.fov, a.aspect, a.near, a.far);
      void 0 !== a.focus && (u.focus = a.focus);
      void 0 !== a.zoom && (u.zoom = a.zoom);
      void 0 !== a.filmGauge && (u.filmGauge = a.filmGauge);
      void 0 !== a.filmOffset && (u.filmOffset = a.filmOffset);
      void 0 !== a.view && (u.view = Object.assign({}, a.view));
      void 0 !== a.viewport && u.viewport.fromArray(a.viewport);
      void 0 !== a.offset && u.offset.fromArray(a.offset);
      void 0 !== a.clearColor && (u.clearColor = a.clearColor);
      void 0 !== a.clearDepth && (u.clearDepth = a.clearDepth);
      void 0 !== a.clearStencil && (u.clearStencil = a.clearStencil);
      void 0 !== a.order && (u.order = a.order);
      void 0 !== a.composer && (u.composer = EffectComposer.fromJSON(a.composer));
      break;
    case "OrthographicCamera":
      u = new OrthographicCamera(a.size, a.aspect, a.mode, a.near, a.far);
      void 0 !== a.viewport && u.viewport.fromArray(a.viewport);
      void 0 !== a.offset && u.offset.fromArray(a.offset);
      void 0 !== a.clearColor && (u.clearColor = a.clearColor);
      void 0 !== a.clearDepth && (u.clearDepth = a.clearDepth);
      void 0 !== a.clearStencil && (u.clearStencil = a.clearStencil);
      void 0 !== a.order && (u.order = a.order);
      void 0 !== a.composer && (u.composer = EffectComposer.fromJSON(a.composer));
      void 0 !== a.zoom && (u.zoom = a.zoom);
      void 0 !== a.view && (u.view = Object.assign({}, a.view));
      break;
    case "Script":
      u = new Script(a.code, a.mode);
      break;
    case "RectAreaLight":
      u = new RectAreaLight(a.color, a.intensity, a.width, a.height);
      break;
    case "AmbientLight":
      u = new AmbientLight(a.color, a.intensity);
      break;
    case "DirectionalLight":
      u = new DirectionalLight(a.color, a.intensity);
      break;
    case "PointLight":
      u = new PointLight(a.color, a.intensity, a.distance, a.decay);
      break;
    case "SpotLight":
      u = new SpotLight(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay);
      break;
    case "HemisphereLight":
      u = new HemisphereLight(a.color, a.groundColor, a.intensity);
      break;
    case "SkinnedMesh":
      l = p(a.geometry);
      u = m(a.material);
      void 0 !== a.skeleton && void 0 !== l.bones && (w = l.bones, l.bones = void 0);
      u = new SkinnedMesh(l, u);
      void 0 !== a.skeleton && (u.skeletonUUID = a.skeleton);
      void 0 !== a.bindMode && (u.bindMode = a.bindMode);
      void 0 !== a.bindMatrix && u.bindMatrix.fromArray(a.bindMatrix);
      u.updateMatrixWorld(!0);
      void 0 !== w && (l.bones = w);
      break;
    case "Mesh":
      l = p(a.geometry);
      u = m(a.material);
      u = l.bones && 0 < l.bones.length ? new SkinnedMesh(l, u) : new Mesh(l, u);
      break;
    case "LOD":
      u = new THREE.LOD;
      break;
    case "Line":
      u = new THREE.Line(p(a.geometry), m(a.material), a.mode);
      break;
    case "LineLoop":
      u = new THREE.LineLoop(p(a.geometry), m(a.material));
      break;
    case "LineSegments":
      u = new THREE.LineSegments(p(a.geometry), m(a.material));
      break;
    case "PointCloud":
    case "Points":
      u = new THREE.Points(p(a.geometry), m(a.material));
      break;
    case "Sprite":
      u = new Sprite(m(a.material));
      break;
    case "Group":
      u = new Container;
      break;
    case "Bone":
      u = new THREE.Bone;
      break;
    default:
      u = new Container;
  }
  u.uuid = a.uuid;
  u.name = a.name;
  u.locked = !0 === a.locked || !0 === a.hidden;
  u.folded = !0 === a.folded;
  void 0 !== a.frustumCulled && (u.frustumCulled = a.frustumCulled);
  void 0 !== a.renderOrder && (u.renderOrder = a.renderOrder);
  if (void 0 !== a.animations) {
    for (u.animations = [], l = 0; l < a.animations.length; l++) {
      u.animations.push(THREE.AnimationClip.parse(a.animations[l]));
    }
  }
  void 0 !== a.matrix && (u.matrix.fromArray(a.matrix), u.matrix.decompose(u.position, u.quaternion, u.scale));
  void 0 !== a.position && u.position.fromArray(a.position);
  void 0 !== a.rotation && u.rotation.fromArray(a.rotation);
  void 0 !== a.quaternion && u.quaternion.fromArray(a.quaternion);
  void 0 !== a.scale && u.scale.fromArray(a.scale);
  u.castShadow = !0 === a.castShadow;
  u.receiveShadow = !0 === a.receiveShadow;
  void 0 !== a.shadow && u.shadow.fromJSON(a.shadow);
  u.visible = !0 === a.visible;
  void 0 !== a.userData && (u.userData = a.userData);
  if (void 0 !== a.children) {
    for (var x in a.children) {
      u.add(this.parseObject(a.children[x], c, g, b, e, f));
    }
  }
  void 0 !== a.matrixAutoUpdate && (u.matrixAutoUpdate = a.matrixAutoUpdate, u.matrixAutoUpdate || (u.updateMatrix(), u.updateMatrixWorld(!0)));
  if ("Program" === a.type) {
    u.materials = g, u.textures = b, u.resources = k, u.fonts = f, u.audio = e;
  } else {
    if ("Scene" === a.type) {
      for (l = 0; l < u.cameras.length; l++) {
        x = u.getCamera(u.cameras[l]), null !== x ? u.cameras[l] = x : u.cameras.splice(l, 1);
      }
    } else {
      if ("LOD" === a.type) {
        for (a = a.levels, k = 0; k < a.length; k++) {
          l = a[k], x = u.getObjectByProperty("uuid", l.object), void 0 !== x && u.addLevel(x, l.distance);
        }
      }
    }
  }
  return u;
};
"use strict";
function LeapMotion() {
  THREE.Group.call(this);
  this.type = "LeapDevice";
  this.name = "leap";
  this.posesEnabled = this.gesturesEnabled = this.debugModel = !0;
  this.mode = LeapMotion.DESK;
  this.useArm = !1;
  this.boneMeshes = [];
  this.armMeshes = [];
  this.material = new THREE.MeshPhongMaterial;
  this.geometry = new THREE.BoxBufferGeometry(1, 1, 1);
  this.gesture = [];
  for (var a = 0; 10 > a; a++) {
    this.gesture[a] = !1;
  }
  this.pose = [];
  for (a = 0; 3 > a; a++) {
    this.pose[a] = !1;
  }
  this.data = null;
}
LeapMotion.prototype = Object.create(THREE.Group.prototype);
LeapMotion.DESK = 0;
LeapMotion.HDM = 1;
LeapMotion.SWIPE = 0;
LeapMotion.SWIPE_LEFT = 1;
LeapMotion.SWIPE_RIGHT = 2;
LeapMotion.SWIPE_FRONT = 3;
LeapMotion.SWIPE_BACK = 4;
LeapMotion.SWIPE_UP = 5;
LeapMotion.SWIPE_DOWN = 6;
LeapMotion.CIRCLE = 7;
LeapMotion.SCREEN_TAP = 8;
LeapMotion.KEY_TAP = 9;
LeapMotion.CLOSED = 0;
LeapMotion.OPEN = 1;
LeapMotion.POINTING = 2;
LeapMotion.prototype.initialize = function() {
  var a = this;
  Leap.loop({background:!0}, function(c) {
    a.data = c;
  }).connect();
  THREE.Object3D.prototype.initialize.call(this);
};
LeapMotion.prototype.update = function(a) {
  null !== this.data && (this.gesturesEnabled && this.updateGestures(), this.posesEnabled && this.updatePoses(), this.debugModel && this.updateDebugModel());
  THREE.Object3D.prototype.update.call(this, a);
};
LeapMotion.prototype.checkGesture = function(a) {
  return void 0 !== this.gesture[a] ? this.gesture[a] : !1;
};
LeapMotion.prototype.checkPose = function(a) {
  return void 0 !== this.pose[a] ? this.pose[a] : !1;
};
LeapMotion.prototype.setMode = function(a) {
  this.mode = a;
};
LeapMotion.prototype.updatePoses = function() {
  for (var a = 0; a < this.pose.length; a++) {
    this.pose[a] = !0;
  }
  for (var c = 0; c < this.data.hands.length; c++) {
    var g = this.data.hands[c], b = g.sphereCenter;
    b = new THREE.Vector3(b[0], b[1], b[2]);
    var e = [], f = 0;
    for (a = 0; a < this.pose.length; a++) {
      this.pose[a] = !0;
    }
    var k = [];
    for (a = 0; a < g.fingers.length; a++) {
      var n = g.fingers[a];
      k.push(n.direction);
      n = n.distal.nextJoint;
      n = new THREE.Vector3(n[0], n[1], n[2]);
      e.push(b.distanceTo(n) / g._scaleFactor);
      0 !== a && (.3 > k[a][2] && (this.pose[LeapMotion.CLOSED] = !1), -.5 < k[a][2] && (this.pose[LeapMotion.OPEN] = !1), 1 === a ? f = e[1] : f < 2 * e[a] - 15 && (this.pose[LeapMotion.POINTING] = !1));
    }
    f < 2 * e[0] - 15 && (this.pose[LeapMotion.POINTING] = !1);
  }
};
LeapMotion.prototype.updateGestures = function() {
  for (var a = 0; a < this.gesture.length; a++) {
    this.gesture[a] = !1;
  }
  var c = this;
  this.data.valid && 0 < this.data.gestures.length && this.data.gestures.forEach(function(a) {
    "swipe" === a.type ? (c.gesture[LeapMotion.SWIPE] = !0, 0 < a.direction[0] ? c.gesture[LeapMotion.SWIPE_RIGHT] = !0 : c.gesture[LeapMotion.SWIPE_LEFT] = !0, 0 < a.direction[1] ? c.gesture[LeapMotion.SWIPE_UP] = !0 : c.gesture[LeapMotion.SWIPE_DOWN] = !0, 0 < a.direction[2] ? c.gesture[LeapMotion.SWIPE_FRONT] = !0 : c.gesture[LeapMotion.SWIPE_BACK] = !0) : "circle" === a.type ? c.gesture[LeapMotion.CIRCLE] = !0 : "keyTap" === a.type ? c.gesture[LeapMotion.KEY_TAP] = !0 : "screenTap" === a.type && 
    (c.gesture[LeapMotion.SCREEN_TAP] = !0);
  });
};
LeapMotion.prototype.updateDebugModel = function() {
  var a = this;
  this.armMeshes.forEach(function(b) {
    a.remove(b);
  });
  this.boneMeshes.forEach(function(b) {
    a.remove(b);
  });
  for (var c = 0, g = 0, b = 0; b < this.data.hands.length; b++) {
    for (var e = this.data.hands[b], f = 0; f < e.fingers.length; f++) {
      for (var k = e.fingers[f], n = 0; n < k.bones.length; n++) {
        var p = k.bones[n];
        if (0 !== c) {
          var m = this.boneMeshes[c] || this.addMesh(this.boneMeshes);
          this.updateMesh(p, m);
        }
        c++;
      }
    }
    this.showArm && (e = e.arm, f = this.armMeshes[g++] || this.addMesh(this.armMeshes), this.updateMesh(e, f), f.scale.set(e.width / 1200, e.width / 300, e.length / 150));
  }
};
LeapMotion.prototype.addMesh = function(a) {
  var c = new Mesh(this.geometry, this.material);
  c.castShadow = this.castShadow;
  c.receiveShadow = this.receiveShadow;
  a.push(c);
  return c;
};
LeapMotion.prototype.updateMesh = function(a, c) {
  c.position.fromArray(a.center());
  c.position.divideScalar(150);
  c.setRotationFromMatrix((new THREE.Matrix4).fromArray(a.matrix()));
  c.scale.set(a.width / 150, a.width / 150, a.length / 150);
  this.add(c);
};
LeapMotion.prototype.getMovement = function() {
  var a = this.data.gestures[0].position, c = this.data.gestures[0].startPosition;
  a = new THREE.Vector3(a[0] - c[0], a[1] - c[1], a[2] - c[2]);
  a.divideScalar(this.data.currentFrameRate);
  return a;
};
LeapMotion.prototype.toJSON = function(a) {
  a = THREE.Group.prototype.toJSON.call(this, a);
  a.object.type = this.type;
  a.object.debugModel = this.debugModel;
  a.object.gesturesEnabled = this.gesturesEnabled;
  a.object.posesEnabled = this.posesEnabled;
  a.object.mode = this.mode;
  a.object.useArm = this.useArm;
  return a;
};
"use strict";
function KinectDevice() {
  THREE.Group.call(this);
  this.type = "Kinect";
  this.name = "kinect";
  this.socket = new WebSocket("ws://127.0.0.1:8181");
  this.connected = !1;
  this.debugModel = !0;
  this.dataTimeout = 0;
  this.data = this.camera = null;
  this.dataReceived = !1;
  var a = this;
  this.socket.onopen = function() {
    a.connected = !0;
  };
  this.socket.onclose = function() {
    a.connected = !1;
  };
  this.socket.onmessage = function(c) {
    "string" === typeof c.data ? (a.data = JSON.parse(c.data), a.dataReceived = !0, a.dataTimeout = KinectDevice.DATA_TIMEOUT) : c.data instanceof Blob && (a.camera = c.data);
  };
}
KinectDevice.DATA_TIMEOUT = 20;
KinectDevice.DEPTH = 0;
KinectDevice.COLOR = 1;
KinectDevice.JOINTS_NAME = [["head", "shouldercenter"], ["shouldercenter", "shoulderright"], ["shouldercenter", "shoulderleft"], ["shoulderright", "elbowright"], ["shoulderleft", "elbowleft"], ["elbowright", "wristright"], ["elbowleft", "wristleft"], ["wristright", "handright"], ["wristleft", "handleft"], ["shouldercenter", "spine"], ["spine", "hipcenter"], ["hipcenter", "hipright"], ["hipcenter", "hipleft"], ["hipright", "kneeright"], ["hipleft", "kneeleft"], ["kneeright", "ankleright"], ["kneeleft", 
"ankleleft"], ["ankleright", "footright"], ["ankleleft", "footleft"]];
KinectDevice.prototype = Object.create(THREE.Group.prototype);
KinectDevice.prototype.update = function(a) {
  if (null !== this.data) {
    if (this.dataReceived) {
      for (this.dataReceived = !1; 0 < this.children.length;) {
        this.children.pop();
      }
      if (this.debugModel) {
        for (var c = new THREE.SphereGeometry(.04, 6, 6), g = new THREE.MeshPhongMaterial(16711680), b = 0; b < this.data.skeletons.length; b++) {
          for (var e = this.data.skeletons[b].joints, f = 0; f < e.length; f++) {
            var k = new Mesh(c, g);
            k.position.set(e[f].x, e[f].y, e[f].z);
            k.castShadow = !0;
            this.add(k);
          }
        }
      }
    } else {
      if (0 < this.dataTimeout && (this.dataTimeout--, 0 === this.dataTimeout)) {
        for (; 0 < this.children.length;) {
          this.children.pop();
        }
      }
    }
  }
  THREE.Object3D.prototype.update.call(this, a);
};
KinectDevice.prototype.isConnected = function() {
  return this.connected;
};
KinectDevice.prototype.setCameraMode = function(a) {
  a === KinectDevice.COLOR ? socket.send("Color") : a === KinectDevice.DEPTH && socket.send("Depth");
};
KinectDevice.prototype.toJSON = function(a) {
  a = THREE.Group.prototype.toJSON.call(this, a);
  a.object.debugModel = this.debugModel;
  return a;
};
"use strict";
function Mesh(a, c) {
  THREE._Mesh.call(this, a, c);
  this.name = "model";
  this.castShadow = this.receiveShadow = !0;
}
THREE._Mesh = THREE.Mesh;
THREE.Mesh = Mesh;
Mesh.prototype = Object.create(THREE._Mesh.prototype);
Mesh.prototype.dispose = function() {
  null !== this.material && void 0 !== this.material.dispose && this.material.dispose();
  null !== this.geometry && this.geometry.dispose();
  THREE.Object3D.prototype.dispose.call(this);
};
"use strict";
function SkinnedMesh(a, c, g) {
  THREE._SkinnedMesh.call(this, a, c, g);
  this.name = "skinned";
  this.castShadow = this.receiveShadow = !0;
}
THREE._SkinnedMesh = THREE.SkinnedMesh;
THREE.SkinnedMesh = SkinnedMesh;
SkinnedMesh.prototype = Object.create(THREE._SkinnedMesh.prototype);
SkinnedMesh.prototype.dispose = function() {
  null !== this.material && void 0 !== this.material.dispose && this.material.dispose();
  null !== this.geometry && this.geometry.dispose();
  THREE.Object3D.prototype.dispose.call(this);
};
SkinnedMesh.prototype.toJSON = function(a) {
  var c = this;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, b) {
    void 0 !== c.skeleton && (void 0 === a.skeletons[c.skeleton.uuid] && (a.skeletons[c.skeleton.uuid] = c.skeleton.toJSON(a)), b.skeleton = c.skeleton.uuid);
  });
  void 0 !== this.bindMode && (a.object.bindMode = this.bindMode);
  void 0 !== this.bindMatrix && (a.object.bindMatrix = this.bindMatrix.toArray());
  return a;
};
"use strict";
function TextMesh(a, c, g, b, e, f, k, n, p, m) {
  Mesh.call(this, TextMesh.EMPTY_GEOMETRY, c);
  this.name = "text";
  this.type = "TextMesh";
  this.font = void 0 !== g ? g : null;
  this.extruded = void 0 !== m ? m : !0;
  this.size = void 0 !== n ? n : 1;
  this.height = void 0 !== b ? b : .5;
  this.curveSegments = void 0 !== p ? p : 15;
  this.bevel = void 0 !== e ? e : !1;
  this.bevelThickness = void 0 !== f ? f : .1;
  this.bevelSize = void 0 !== k ? k : .05;
  this.text = "";
  this.setText(void 0 !== a ? a : "text");
}
TextMesh.prototype = Object.create(Mesh.prototype);
TextMesh.EMPTY_GEOMETRY = new THREE.Geometry;
TextMesh.prototype.setFont = function(a) {
  this.font !== a && (this.font = a, this.updateGeometry());
};
TextMesh.prototype.setText = function(a) {
  this.text !== a && (this.text = a, this.updateGeometry());
};
TextMesh.prototype.updateGeometry = function() {
  if (null !== this.font) {
    if (void 0 !== this.geometry && this.geometry.dispose(), !0 !== this.font.isFont) {
      console.warn("nunuStudio: Font parameter is not an instance of THREE.Font."), this.geometry = TextMesh.EMPTY_GEOMETRY;
    } else {
      var a = this.font.generateShapes(this.text, this.size);
      this.extruded ? (this.geometry = new THREE.ExtrudeBufferGeometry(a, {curveSegments:this.curveSegments, depth:this.height, bevelEnabled:this.bevel, bevelSize:this.bevelSize, bevelThickness:this.bevelThickness}), this.geometry.computeVertexNormals()) : this.geometry = new THREE.ShapeBufferGeometry(a, this.curveSegments);
    }
  }
};
TextMesh.prototype.clone = function() {
  return new TextMesh(this.text, this.material, this.font, this.height, this.bevel, this.bevelThickness, this.bevelSize, this.size, this.curveSegments);
};
TextMesh.prototype.toJSON = function(a) {
  var c = this.geometry;
  this.geometry = void 0;
  var g = this.font;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, c) {
    g = g.toJSON(a);
  });
  a.object.text = this.text;
  a.object.font = g.uuid;
  a.object.size = this.size;
  a.object.curveSegments = this.curveSegments;
  a.object.height = this.height;
  a.object.bevel = this.bevel;
  a.object.bevelThickness = this.bevelThickness;
  a.object.bevelSize = this.bevelSize;
  a.object.extruded = this.extruded;
  this.geometry = c;
  return a;
};
"use strict";
function TextBitmap(a, c, g, b) {
  if (void 0 === a.font) {
    throw Error("TextBitmap configuration font is required.");
  }
  void 0 === a.width && (a.width = 500);
  void 0 === a.align && (a.align = TextBitmap.CENTER);
  void 0 === a.lineHeight && (a.lineHeight = a.font.common.lineHeight);
  void 0 === a.letterSpacing && (a.letterSpacing = 5);
  void 0 === a.text && (a.text = "");
  this.config = a;
  this.mode = void 0 !== g ? g : TextBitmap.BITMAP;
  a = this.mode === TextBitmap.SDF ? TextBitmap.SDF_SHADER : this.mode === TextBitmap.MSDF ? TextBitmap.MSDF_SHADER : TextBitmap.BITMAP_SHADER;
  b = {map:{type:"t", value:c}, color:{type:"v3", value:new THREE.Color(void 0 !== b ? b : 16777215)}, smoothing:{type:"f", value:0}, threshold:{type:"f", value:.4}};
  b = new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(b), fragmentShader:a, vertexShader:TextBitmap.VERTEX_SHADER, side:THREE.DoubleSide, transparent:!0, depthTest:!1});
  b.uniforms.map.value = c;
  c = createGeometry(this.config);
  THREE.Mesh.call(this, c, b);
  this.name = "text";
  this.type = "TextBitmap";
  this.updateGeometry();
  Object.defineProperties(this, {font:{get:function() {
    return this.config.font;
  }, set:function(a) {
    this.config.font = a;
    this.updateGeometry();
  }}, text:{get:function() {
    return this.config.text;
  }, set:function(a) {
    this.config.text = a;
    this.updateGeometry();
  }}, lineHeight:{get:function() {
    return this.config.lineHeight;
  }, set:function(a) {
    this.config.lineHeight = a;
    this.updateGeometry();
  }}, letterSpacing:{get:function() {
    return this.config.letterSpacing;
  }, set:function(a) {
    this.config.letterSpacing = a;
    this.updateGeometry();
  }}, align:{get:function() {
    return this.config.align;
  }, set:function(a) {
    this.config.align = a;
    this.updateGeometry();
  }}, width:{get:function() {
    return this.config.width;
  }, set:function(a) {
    this.config.width = a;
    this.updateGeometry();
  }}, color:{get:function() {
    return this.material.uniforms.color.value;
  }, set:function(a) {
    this.material.uniforms.color.value = a;
  }}, threshold:{get:function() {
    return this.material.uniforms.threshold.value;
  }, set:function(a) {
    this.material.uniforms.threshold.value = a;
  }}, smoothing:{get:function() {
    return this.material.uniforms.smoothing.value;
  }, set:function(a) {
    this.material.uniforms.smoothing.value = a;
  }}});
}
TextBitmap.prototype = Object.create(THREE.Mesh.prototype);
TextBitmap.prototype.constructor = TextBitmap;
TextBitmap.BITMAP = 100;
TextBitmap.SDF = 101;
TextBitmap.MSDF = 102;
TextBitmap.LEFT = "left";
TextBitmap.CENTER = "center";
TextBitmap.RIGHT = "right";
TextBitmap.VERTEX_SHADER = "\n#define BILLBOARD 0 \n\nvarying vec2 vUv;\n\nvoid main()\n{\n\tvUv = uv;\n\t\n\t#if BILLBOARD\n\t\tmat4 model = modelViewMatrix; \n\t\tmodel[0][0] = 1.0;\n\t\tmodel[0][1] = 0.0;\n\t\tmodel[0][2] = 0.0;\n\t\t\n\t\tmodel[1][0] = 0.0;\n\t\tmodel[1][1] = 1.0;\n\t\tmodel[1][2] = 0.0;\n\t\t\n\t\tmodel[2][0] = 0.0;\n\t\tmodel[2][1] = 0.0;\n\t\tmodel[2][2] = 1.0;\n\t\t\n\t\tgl_Position = projectionMatrix * model * vec4(position, 1.0);\n\t#else\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t#endif\n\t\n}";
TextBitmap.BITMAP_SHADER = "\nvarying vec2 vUv;\nuniform sampler2D map;\n\nvoid main()\n{\n\tgl_FragColor = texture2D(map, vUv);\n}";
TextBitmap.SDF_SHADER = "\nvarying vec2 vUv;\nuniform sampler2D map;\nuniform vec3 color;\nuniform float smoothing;\nuniform float threshold;\n\nvoid main()\n{\n\tfloat distance = texture2D(map, vUv).a;\n\tfloat alpha = smoothstep(threshold - smoothing, threshold + smoothing, distance);\n\tgl_FragColor = vec4(color, alpha);\n}";
TextBitmap.MSDF_SHADER = "\n#extension GL_OES_standard_derivatives : enable\n\nvarying vec2 vUv;\nuniform sampler2D map;\nuniform vec3 color;\nuniform float smoothing;\nuniform float threshold;\n\nfloat median(float r, float g, float b)\n{\n\treturn max(min(r, g), min(max(r, g), b));\n}\n\nvoid main()\n{\n\tvec3 sample = texture2D(map, vUv).rgb;\n\tfloat sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n\tfloat alpha = clamp(sigDist / fwidth(sigDist) + 0.5, 0.0, 1.0);\n\tgl_FragColor = vec4(color, 1.0 - alpha);\n}";
TextBitmap.prototype.setText = function(a) {
  this.text = a;
};
TextBitmap.prototype.updateGeometry = function() {
  this.geometry.update(this.config);
};
"use strict";
function Sprite(a) {
  THREE._Sprite.call(this, a);
  this.name = "sprite";
}
THREE._Sprite = THREE.Sprite;
THREE.Sprite = Sprite;
Sprite.prototype = Object.create(THREE._Sprite.prototype);
Sprite.prototype.dispose = function() {
  null !== this.material && void 0 !== this.material.dispose && this.material.dispose();
  THREE.Object3D.prototype.dispose.call(this);
};
"use strict";
function PointLight(a, c, g, b) {
  THREE._PointLight.call(this, a, c, g, b);
  this.name = "point";
  this.castShadow = !0;
  this.shadow.camera.near = .1;
  this.shadow.camera.far = 1E3;
  this.shadow.bias = 0;
}
THREE._PointLight = THREE.PointLight;
THREE.PointLight = PointLight;
PointLight.prototype = Object.create(THREE._PointLight.prototype);
PointLight.prototype.updateShadowMap = function() {
  this.shadow.map.dispose();
  this.shadow.map = null;
  this.shadow.camera.updateProjectionMatrix();
};
"use strict";
function SpotLight(a, c, g, b, e, f) {
  THREE._SpotLight.call(this, a, c, g, b, e, f);
  this.name = "spotlight";
  this.castShadow = !0;
  this.shadow.camera.near = .05;
  this.shadow.camera.far = 5E3;
  this.shadow.mapSize.width = 512;
  this.shadow.mapSize.height = 512;
}
THREE._SpotLight = THREE.SpotLight;
THREE.SpotLight = SpotLight;
SpotLight.prototype = Object.create(THREE._SpotLight.prototype);
SpotLight.prototype.setTarget = function(a) {
  this.target = a;
};
SpotLight.prototype.updateShadowMap = function() {
  this.shadow.map.dispose();
  this.shadow.map = null;
  this.shadow.camera.updateProjectionMatrix();
};
SpotLight.prototype.toJSON = function(a) {
  a = THREE.Light.prototype.toJSON.call(this, a);
  a.object.target = this.target.uuid;
  return a;
};
"use strict";
function AmbientLight(a) {
  THREE._AmbientLight.call(this, a);
  this.name = "ambient";
  this.matrixAutoUpdate = !1;
}
THREE._AmbientLight = THREE.AmbientLight;
THREE.AmbientLight = AmbientLight;
AmbientLight.prototype = Object.create(THREE._AmbientLight.prototype);
"use strict";
function DirectionalLight(a, c) {
  THREE._DirectionalLight.call(this, a, c);
  this.name = "directional";
  this.castShadow = !0;
  this.shadow.camera.near = .5;
  this.shadow.camera.far = 1E4;
}
THREE._DirectionalLight = THREE.DirectionalLight;
THREE.DirectionalLight = DirectionalLight;
DirectionalLight.prototype = Object.create(THREE._DirectionalLight.prototype);
DirectionalLight.prototype.updateShadowMap = function() {
  this.shadow.map.dispose();
  this.shadow.map = null;
  this.shadow.camera.updateProjectionMatrix();
};
"use strict";
function HemisphereLight(a, c, g) {
  THREE._HemisphereLight.call(this, a, c, g);
  this.name = "hemisphere";
}
THREE._HemisphereLight = THREE.HemisphereLight;
THREE.HemisphereLight = HemisphereLight;
HemisphereLight.prototype = Object.create(THREE._HemisphereLight.prototype);
"use strict";
function RectAreaLight(a, c, g, b) {
  THREE._RectAreaLight.call(this, a, c, g, b);
  this.name = "rectarea";
}
THREE._RectAreaLight = THREE.RectAreaLight;
THREE.RectAreaLight = RectAreaLight;
RectAreaLight.prototype = Object.create(THREE._RectAreaLight.prototype);
RectAreaLight.prototype.toJSON = function(a) {
  a = THREE.Light.prototype.toJSON.call(this, a);
  a.object.width = this.width;
  a.object.height = this.height;
  return a;
};
"use strict";
function Viewport(a) {
  this.offset = new THREE.Vector2(0, 0);
  this.viewport = new THREE.Vector2(1,  1.);
  this.mode = void 0 !== a ? a : Viewport.RELATIVE;
  this.anchor = Viewport.TOP_LEFT;
}
Viewport.RELATIVE = 200;
Viewport.ABSOLUTE = 201;
Viewport.TOP_LEFT = 301;
Viewport.TOP_RIGHT = 302;
Viewport.BOTTOM_LEFT = 303;
Viewport.BOTTOM_RIGHT = 304;
Viewport.prototype.getAspectRatio = function(a) {
  return this.mode === Viewport.RELATIVE ? this.viewport.x * a.width / (this.viewport.y * a.height) : this.viewport.x / this.viewport.y;
};
Viewport.prototype.isInside = function(a, c) {
  if (this.mode === Viewport.RELATIVE) {
    var g = new THREE.Vector2(this.offset.x * a.width, this.offset.y * a.height), b = new THREE.Vector2(this.viewport.x * a.width, this.viewport.y * a.height);
  } else {
    g = this.offset, b = this.viewport;
  }
  return this.anchor === Viewport.TOP_LEFT ? c.position.x > g.x && c.position.x < g.x + b.x && c.position.y > g.y && c.position.y < g.y + b.y : this.anchor === Viewport.TOP_RIGHT ? c.position.x > a.width - b.x - g.x && c.position.x < a.width - g.x && c.position.y > g.y && c.position.y < g.y + b.y : this.anchor === Viewport.BOTTOM_LEFT ? c.position.x > g.x && c.position.x < g.x + b.x && c.position.y > a.height - g.y - b.y && c.position.y < a.height - g.y : c.position.x > a.width - b.x - g.x && c.position.x < 
  a.width - g.x && c.position.y > a.height - g.y - b.y && c.position.y < a.height - g.y;
};
Viewport.prototype.getNormalized = function(a, c) {
  var g = new THREE.Vector2;
  return function(a, c) {
    if (this.mode === Viewport.RELATIVE) {
      var b = new THREE.Vector2(this.offset.x * a.width, this.offset.y * a.height), e = new THREE.Vector2(this.viewport.x * a.width, this.viewport.y * a.height);
    } else {
      b = this.offset, e = this.viewport;
    }
    if (this.anchor === Viewport.TOP_LEFT) {
      var n = c.position.x - e.x - b.x;
      a = c.position.y - b.y;
      g.set(n / e.x * 2 + 1, -a / e.y * 2 + 1);
    } else {
      this.anchor === Viewport.TOP_RIGHT ? (n = a.width - c.position.x - e.x - b.x, a = c.position.y - b.y, g.set(-n / e.x * 2 - 1, -a / e.y * 2 + 1)) : this.anchor === Viewport.BOTTOM_LEFT ? (n = c.position.x - e.x - b.x, a = a.height - c.position.y - b.y, g.set(n / e.x * 2 + 1, a / e.y * 2 - 1)) : (n = a.width - c.position.x - e.x - b.x, a = a.height - c.position.y - b.y, g.set(-n / e.x * 2 - 1, a / e.y * 2 - 1));
    }
    return g;
  };
}();
Viewport.prototype.enable = function(a) {
  if (this.mode === Viewport.RELATIVE) {
    var c = new THREE.Vector2(this.offset.x * a.domElement.width, this.offset.y * a.domElement.height), g = new THREE.Vector2(this.viewport.x * a.domElement.width, this.viewport.y * a.domElement.height);
  } else {
    c = this.offset, g = this.viewport;
  }
  if (this.anchor === Viewport.BOTTOM_LEFT) {
    a.setViewport(c.x, c.y, g.x, g.y), a.setScissor(c.x, c.y, g.x, g.y);
  } else {
    if (this.anchor === Viewport.BOTTOM_RIGHT) {
      var b = a.domElement.width - g.x - c.x;
      a.setViewport(b, c.y, g.x, g.y);
      a.setScissor(b, c.y, g.x, g.y);
    } else {
      if (this.anchor === Viewport.TOP_LEFT) {
        var e = a.domElement.height - g.y - c.y;
        a.setViewport(c.x, e, g.x, g.y);
        a.setScissor(c.x, e, g.x, g.y);
      } else {
        this.anchor === Viewport.TOP_RIGHT && (b = a.domElement.width - g.x - c.x, e = a.domElement.height - g.y - c.y, a.setViewport(b, e, g.x, g.y), a.setScissor(b, e, g.x, g.y));
      }
    }
  }
};
Viewport.prototype.toJSON = function() {
  return {offset:this.offset.toArray(), viewport:this.viewport.toArray(), mode:this.mode, anchor:this.anchor};
};
Viewport.prototype.fromJSON = function(a) {
  this.offset.fromArray(a.offset);
  this.viewport.fromArray(a.viewport);
  this.mode = a.mode;
  this.anchor = a.anchor;
};
"use strict";
function PerspectiveCamera(a, c, g, b) {
  this.offset = new THREE.Vector2(0, 0);
  this.viewport = new THREE.Vector2(1, 1);
  THREE.PerspectiveCamera.call(this, a, c, g, b);
  this.name = "camera";
  this.clearStencil = this.clearDepth = this.clearColor = !0;
  this.order = 0;
  a = new RenderPass;
  a.renderToScreen = !0;
  this.composer = new EffectComposer;
  this.composer.addPass(a);
}
PerspectiveCamera.prototype = Object.create(THREE.PerspectiveCamera.prototype);
PerspectiveCamera.prototype.render = function(a, c) {
  this.composer.render(a, c, this, .016);
};
PerspectiveCamera.prototype.resize = function(a, c) {
  this.composer.setSize(a * this.viewport.x, c * this.viewport.y);
};
PerspectiveCamera.prototype.destroy = function() {
  var a = this.getScene();
  null !== a && a.removeCamera(this);
  THREE.Object3D.prototype.destroy.call(this);
};
PerspectiveCamera.prototype.updateProjectionMatrix = function() {
  var a = this.near * Math.tan(.5 * THREE.Math.DEG2RAD * this.fov) / this.zoom, c = 2 * a, g = this.aspect * c * this.viewport.x / this.viewport.y, b = -.5 * g;
  0 !== this.filmOffset && (b += this.near * this.filmOffset / this.getFilmWidth());
  this.projectionMatrix.makePerspective(b, b + g, a, a - c, this.near, this.far);
};
PerspectiveCamera.prototype.toJSON = function(a) {
  a = THREE.PerspectiveCamera.prototype.toJSON.call(this, a);
  a.object.clearColor = this.clearColor;
  a.object.clearDepth = this.clearDepth;
  a.object.clearStencil = this.clearStencil;
  a.object.viewport = this.viewport.toArray();
  a.object.offset = this.offset.toArray();
  a.object.order = this.order;
  a.object.composer = this.composer.toJSON();
  return a;
};
"use strict";
function OrthographicCamera(a, c, g, b, e) {
  THREE.OrthographicCamera.call(this, -1, 1, 1, -1, b, e);
  this.name = "camera";
  this.size = void 0 != a ? a : 10;
  this.aspect = void 0 != c ? c : 1;
  this.mode = void 0 !== g ? g : OrthographicCamera.RESIZE_HORIZONTAL;
  this.offset = new THREE.Vector2(0, 0);
  this.viewport = new THREE.Vector2(1, 1);
  this.clearStencil = this.clearDepth = this.clearColor = !0;
  this.order = 0;
  this.updateProjectionMatrix();
  a = new RenderPass;
  a.renderToScreen = !0;
  this.composer = new EffectComposer;
  this.composer.addPass(a);
}
OrthographicCamera.prototype = Object.create(THREE.OrthographicCamera.prototype);
OrthographicCamera.RESIZE_HORIZONTAL = 0;
OrthographicCamera.RESIZE_VERTICAL = 1;
OrthographicCamera.prototype.render = function(a, c) {
  this.composer.render(a, c, this, .016);
};
OrthographicCamera.prototype.resize = function(a, c) {
  this.composer.setSize(a * this.viewport.x, c * this.viewport.y);
};
OrthographicCamera.prototype.destroy = function() {
  var a = this.getScene();
  null !== a && a.removeCamera(this);
  THREE.Object3D.prototype.destroy.call(this);
};
OrthographicCamera.prototype.updateProjectionMatrix = function() {
  this.mode === OrthographicCamera.RESIZE_HORIZONTAL ? (this.top = this.size / 2, this.bottom = -this.top, this.right = this.viewport.x / this.viewport.y * this.aspect * this.top, this.left = -this.right) : this.mode === OrthographicCamera.RESIZE_VERTICAL && (this.right = this.size / 2, this.left = -this.right, this.top = this.right / this.aspect * (this.viewport.x / this.viewport.y), this.bottom = -this.top);
  THREE.OrthographicCamera.prototype.updateProjectionMatrix.call(this);
};
OrthographicCamera.prototype.toJSON = function(a) {
  a = THREE.OrthographicCamera.prototype.toJSON.call(this, a);
  a.object.size = this.size;
  a.object.aspect = this.aspect;
  a.object.mode = this.mode;
  a.object.clearColor = this.clearColor;
  a.object.clearDepth = this.clearDepth;
  a.object.clearStencil = this.clearStencil;
  a.object.viewport = this.viewport.toArray();
  a.object.offset = this.offset.toArray();
  a.object.order = this.order;
  a.object.composer = this.composer.toJSON();
  return a;
};
"use strict";
function AudioEmitter(a) {
  THREE.Object3D.call(this);
  this.name = "audio";
  this.type = "Audio";
  this.listener = new THREE.AudioListener;
  this.context = this.listener.context;
  this.matrixAutoUpdate = !1;
  this.gain = this.context.createGain();
  this.gain.connect(this.listener.getInput());
  this.buffer = null;
  this.filters = [];
  this.sourceType = "empty";
  this.audio = void 0 !== a ? a : null;
  this.autoplay = !0;
  this.playbackRate = this.volume = 1;
  this.startTime = 0;
  this.loop = !0;
  this.detune = 0;
  this.isPlaying = !1;
  this.hasPlaybackControl = !0;
}
THREE._Audio = THREE.Audio;
THREE.Audio = AudioEmitter;
AudioEmitter.prototype = Object.create(THREE._Audio.prototype);
AudioEmitter.prototype.initialize = function() {
  if (null !== this.audio) {
    var a = this;
    this.audio.getAudioBuffer(this.context, function(c) {
      a.setBuffer(c);
    });
  } else {
    console.warn("nunuStudio: AudioEmitter audio is null.");
  }
  this.setVolume(this.volume);
  this.setPlaybackRate(this.playbackRate);
  THREE.Object3D.prototype.initialize.call(this);
};
AudioEmitter.prototype.setBuffer = function(a) {
  this.buffer = a;
  this.sourceType = "buffer";
  !0 === this.autoplay && this.play();
  return this;
};
AudioEmitter.prototype.play = function() {
  if (null === this.buffer) {
    console.warn("nunuStudio: Audio buffer not ready, audio will not play.");
  } else {
    this.isPlaying && console.warn("nunuStudio: Audio is already playing, its only possible to control the last playing instance.");
    var a = this.context.createBufferSource();
    a.buffer = this.buffer;
    a.detune.value = this.detune;
    a.loop = this.loop;
    a.onended = this.onEnded.bind(this);
    a.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
    a.start(0, this.startTime);
    this.isPlaying = !0;
    this.source = a;
    return this.connect();
  }
};
AudioEmitter.prototype.pause = function() {
  this.source.stop();
  this.startTime = this.context.currentTime;
  this.isPlaying = !1;
  return this;
};
AudioEmitter.prototype.stop = function() {
  this.source.stop();
  this.startTime = 0;
  this.isPlaying = !1;
  return this;
};
AudioEmitter.prototype.setAudio = function(a) {
  this.audio = a;
  null !== this.buffer && (this.isPlaying && this.stop(), this.disconnect());
  var c = this;
  this.audio.getAudioBuffer(this.context, function(a) {
    c.setBuffer(a);
  });
};
AudioEmitter.prototype.getVolume = function() {
  return this.gain.gain.value;
};
AudioEmitter.prototype.setVolume = function(a) {
  this.volume = a;
  this.gain.gain.value = a;
  return this;
};
AudioEmitter.prototype.setLoop = function(a) {
  this.loop = a;
  this.isPlaying && (this.source.loop = this.loop);
  return this;
};
AudioEmitter.prototype.setDetune = function(a) {
  this.detune = a;
  !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01);
  return this;
};
AudioEmitter.prototype.getLoop = function() {
  return this.loop;
};
AudioEmitter.prototype.setPlaybackRate = function(a) {
  this.playbackRate = a;
  this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime);
  return this;
};
AudioEmitter.prototype.getPlaybackRate = function() {
  return this.playbackRate;
};
AudioEmitter.prototype.getFilters = function() {
  return this.filters;
};
AudioEmitter.prototype.setFilters = function(a) {
  a || (a = []);
  this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a;
  return this;
};
AudioEmitter.prototype.getFilter = function(a) {
  return this.getFilters()[void 0 !== a ? a : 0];
};
AudioEmitter.prototype.setFilter = function(a) {
  return this.setFilters(a ? [a] : []);
};
AudioEmitter.prototype.setNodeSource = function(a) {
  this.hasPlaybackControl = !1;
  this.sourceType = "audioNode";
  this.source = a;
  this.connect();
  return this;
};
AudioEmitter.prototype.getOutput = function() {
  return this.gain;
};
AudioEmitter.prototype.dispose = function() {
  this.isPlaying && (this.stop(), this.disconnect());
  THREE.Object3D.prototype.dispose.call(this);
};
AudioEmitter.prototype.toJSON = function(a) {
  var c = this.audio;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, b) {
    c = c.toJSON(a);
  });
  a.object.audio = c.uuid;
  a.object.volume = this.volume;
  a.object.autoplay = this.autoplay;
  a.object.startTime = this.startTime;
  a.object.playbackRate = this.playbackRate;
  a.object.loop = this.loop;
  return a;
};
"use strict";
function PositionalAudio(a) {
  AudioEmitter.call(this, a);
  this.type = "PositionalAudio";
  this.matrixAutoUpdate = !0;
  this.distanceModel = "inverse";
  this.panningModel = "HRTF";
  this.panner = this.context.createPanner();
  this.panner.connect(this.gain);
  this.panner.panningModel = this.panningModel;
  this.panner.distanceModel = this.distanceModel;
  this.panner.refDistance = 1;
  this.panner.maxDistance = 1E4;
  this.panner.rolloffFactor = 1;
  this.panner.coneInnerAngle = 360;
  this.panner.coneOuterAngle = 0;
  this.panner.coneOuterGain = 0;
  this.scene = null;
  this.tempPosition = new THREE.Vector3;
  this.tempPositionCamera = new THREE.Vector3;
  this.tempQuaternionCamera = new THREE.Quaternion;
}
THREE._PositionalAudio = THREE.PositionalAudio;
THREE.PositionalAudio = PositionalAudio;
PositionalAudio.prototype = Object.create(AudioEmitter.prototype);
PositionalAudio.prototype.initialize = function() {
  AudioEmitter.prototype.initialize.call(this);
  for (var a = this.parent; null !== a;) {
    if (a instanceof Scene) {
      this.scene = a;
      break;
    }
    a = a.parent;
  }
};
PositionalAudio.prototype.update = function(a) {
  if (0 < this.scene.cameras.length) {
    var c = this.scene.cameras[0];
    this.getWorldPosition(this.tempPosition);
    c.getWorldPosition(this.tempPositionCamera);
    c.getWorldQuaternion(this.tempQuaternionCamera);
    this.tempPosition.sub(this.tempPositionCamera);
    this.tempPosition.z = -this.tempPosition.z;
    this.tempPosition.applyQuaternion(this.tempQuaternionCamera);
    this.panner.setPosition(this.tempPosition.x, this.tempPosition.z, this.tempPosition.y);
  } else {
    this.panner.setPosition(0, 0, 0), this.panner.setOrientation(0, 0, 0);
  }
  THREE.Object3D.prototype.update.call(this, a);
};
PositionalAudio.prototype.getOutput = function() {
  return this.panner;
};
PositionalAudio.prototype.getRefDistance = function() {
  return this.panner.refDistance;
};
PositionalAudio.prototype.setRefDistance = function(a) {
  this.panner.refDistance = a;
};
PositionalAudio.prototype.getRolloffFactor = function() {
  return this.panner.rolloffFactor;
};
PositionalAudio.prototype.setRolloffFactor = function(a) {
  this.panner.rolloffFactor = a;
};
PositionalAudio.prototype.getDistanceModel = function() {
  return this.panner.distanceModel;
};
PositionalAudio.prototype.setDistanceModel = function(a) {
  this.panner.distanceModel = a;
};
PositionalAudio.prototype.getMaxDistance = function() {
  return this.panner.maxDistance;
};
PositionalAudio.prototype.setMaxDistance = function(a) {
  this.panner.maxDistance = a;
};
PositionalAudio.prototype.toJSON = function(a) {
  return AudioEmitter.prototype.toJSON.call(this, a);
};
function Script(a, c) {
  THREE.Group.call(this);
  this.type = "Script";
  this.name = "script";
  this.code = void 0 !== a ? a : Script.DEFAULT;
  this.mode = void 0 !== c ? c : Script.APPEND;
  this.script = {};
  this.scene = this.program = null;
}
Script.prototype = Object.create(THREE.Group.prototype);
Script.DEFAULT = "function initialize()\n{\n\t//TODO <INITIALIZATION CODE>\n}\n\nfunction update(delta)\n{\n\t//TODO <UPDATE CODE>\n}\n";
Script.METHODS = "initialize update dispose onMouseOver onResize onAppData".split(" ");
Script.APPEND = 100;
Script.EVALUATE = 101;
Script.INCLUDE = 102;
Script.getIncludes = function(a) {
  var c = [], g = a.search(/include\(".+?"\);/gi);
  -1 !== g && (a = a.substring(g), g = a.indexOf('");'), a = a.substring(9, g), c.push(a));
  return c;
};
Script.removeIncludes = function(a) {
  return a.replace(/include\(".+?"\);/gi, "");
};
Script.prototype.initialize = function() {
  for (var a = this; null !== a.parent;) {
    a = a.parent, a instanceof Scene ? this.scene = a : a instanceof Program && (this.program = a);
  }
  THREE.Object3D.prototype.initialize.call(this);
  var c = this;
  this.compileCode(this.code, function() {
    void 0 !== c.script.initialize && c.script.initialize.call(c);
  });
};
Script.prototype.update = function(a) {
  if (void 0 !== this.script.onMouseOver) {
    var c = this.scene.raycaster.intersectObjects(this.children, !0);
    0 < c.length && this.script.onMouseOver.call(this, c);
  }
  void 0 !== this.script.update && this.script.update.call(this, a);
  THREE.Object3D.prototype.update.call(this, a);
};
Script.prototype.dispose = function() {
  void 0 !== this.script.dispose && this.script.dispose.call(this);
  THREE.Object3D.prototype.dispose.call(this);
};
Script.prototype.resize = function(a, c) {
  void 0 !== this.script.onResize && this.script.onResize.call(this, a, c);
};
Script.prototype.appData = function(a) {
  void 0 !== this.script.onAppData && this.script.onAppData.call(this, a);
};
Script.prototype.compileCode = function(a, c) {
  void 0 !== a && (this.code = a);
  try {
    a = this.code;
    for (var g = 0; g < Script.METHODS.length; g++) {
      var b = Script.METHODS[g];
      a += "\nif(this." + b + " == undefined && typeof " + b + " !== 'undefined'){this." + b + " = " + b + ";}";
    }
    if (this.mode === Script.APPEND) {
      var e = Script.getIncludes(a);
      a = Script.removeIncludes(a);
      for (g = 0; g < e.length; g++) {
        a = this.program.getResourceByName(e[g]).data + "\n" + a;
      }
      a += '\nfunction include(name)\t\t\t{\t\t\t\tconsole.warn("nunuStudio: Script running in append mode " + name);\t\t\t}';
    } else {
      if (this.mode === Script.EVALUATE) {
        a += '\nfunction include(name)\t\t\t{\t\t\t\tvar text = program.getResourceByName(name);\t\t\t\tif(text !== null)\t\t\t\t{\t\t\t\t\tnew Function(text.data).call(this);\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tconsole.warn("nunuStudio: Javascript file " + name + " not found in resources");\t\t\t\t}\t\t\t}';
      } else {
        if (this.mode === Script.INCLUDE) {
          e = Script.getIncludes(a);
          a = Script.removeIncludes(a);
          var f = 0;
          for (g = 0; g < e.length; g++) {
            var k = new Blob([this.program.getResourceByName(e[g]).data], {type:"text/plain"}), n = URL.createObjectURL(k), p = document.createElement("script");
            p.type = "text/javascript";
            p.async = !1;
            p.src = n;
            p.onload = function() {
              f++;
              f === e.length && c();
            };
            p.onerror = p.onload;
            document.body.appendChild(p);
          }
        }
      }
    }
    var m = new Function("Keyboard, Mouse, self, program, scene", a);
    try {
      this.script = new m(this.program.keyboard, this.program.mouse, this, this.program, this.scene);
    } catch (t) {
      throw console.warn("nunuStudio: Error initializing script code", t), "Error initializing script code";
    }
    this.mode !== Script.INCLUDE && c();
  } catch (t) {
    throw console.warn("nunuStudio: Error compiling script code", t), "Error compiling script code";
  }
};
Script.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.code = this.code;
  a.object.mode = this.mode;
  return a;
};
"use strict";
function PhysicsObject() {
  THREE.Group.call(this);
  this.name = "physics";
  this.type = "Physics";
  this.body = new CANNON.Body;
  this.body.type = CANNON.Body.DYNAMIC;
  this.body.mass = 1;
  this.world = null;
}
PhysicsObject.prototype = Object.create(THREE.Group.prototype);
PhysicsObject.prototype.initialize = function() {
  this.body.position.copy(this.position);
  this.body.quaternion.copy(this.quaternion);
  for (var a = this; null !== a.parent;) {
    a = a.parent, a instanceof Scene && (this.world = a.world, this.world.addBody(this.body));
  }
  THREE.Object3D.prototype.initialize.call(this);
};
PhysicsObject.prototype.update = function(a) {
  this.position.copy(this.body.position);
  this.body.fixedRotation || this.quaternion.copy(this.body.quaternion);
  THREE.Object3D.prototype.update.call(this, a);
};
PhysicsObject.prototype.addShape = function(a) {
  a instanceof CANNON.Shape && this.body.addShape(a);
};
PhysicsObject.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.body = {};
  a.object.body.type = this.body.type;
  a.object.body.mass = this.body.mass;
  a.object.body.linearDamping = this.body.linearDamping;
  a.object.body.angularDamping = this.body.angularDamping;
  a.object.body.allowSleep = this.body.allowSleep;
  a.object.body.sleepSpeedLimit = this.body.sleepSpeedLimit;
  a.object.body.sleepTimeLimit = this.body.sleepTimeLimit;
  a.object.body.collisionFilterGroup = this.body.collisionFilterGroup;
  a.object.body.collisionFilterMask = this.body.collisionFilterMask;
  a.object.body.fixedRotation = this.body.fixedRotation;
  a.object.body.shapes = [];
  for (var c = this.body.shapes, g = 0; g < c.length; g++) {
    var b = c[g], e = {};
    e.type = b.type;
    b.type === CANNON.Shape.types.SPHERE ? e.radius = b.radius : b.type === CANNON.Shape.types.BOX ? (e.halfExtents = {}, e.halfExtents.x = b.halfExtents.x, e.halfExtents.y = b.halfExtents.y, e.halfExtents.z = b.halfExtents.z) : b.type === CANNON.Shape.types.CONVEXPOLYHEDRON ? (e.vertices = b.vertices, e.faces = b.faces) : b.type === CANNON.Shape.types.TRIMESH && (e.vertices = b.vertices, e.normals = b.normals, e.edges = b.edges, e.indices = b.indices);
    a.object.body.shapes[g] = e;
  }
  return a;
};
"use strict";
function SpineAnimation(a, c, g, b) {
  void 0 === b && (b = []);
  var e = new spine.TextureAtlas(c, function(a) {
    for (var e = 0; e < b.length; e++) {
      if (b[e].name === a) {
        var f = new SpineTexture(b[e].texture);
        break;
      }
    }
    e === b.length && (f = new SpineTexture(new Texture(new Image(g + "/" + a))), b.push({name:a, texture:f.texture}));
    a = f.texture.image;
    e = f.texture.img;
    if (0 < e.width && 0 < e.height) {
      a.width = e.width, a.height = e.height;
    } else {
      if (0 !== a.naturalWidth && 0 !== a.naturalHeight) {
        a.width = a.naturalWidth, a.height = a.naturalHeight, e.width = a.width, e.height = a.height;
      } else {
        e = c.search("size: ");
        var p = c.search("\nformat");
        e = c.substring(e + 6, p);
        e = e.split(",");
        a.width = parseInt(e[0]);
        a.height = parseInt(e[1]);
      }
    }
    return f;
  });
  e = new spine.AtlasAttachmentLoader(e);
  e = (new spine.SkeletonJson(e)).readSkeletonData(a);
  spine.threejs.SkeletonMesh.call(this, e);
  this.name = "spine";
  this.type = "SpineAnimation";
  this.frustumCulled = !1;
  this.castShadow = this.receiveShadow = !0;
  this.scale.set(.01, .01, .01);
  this.json = a;
  this.atlas = c;
  this.textures = b;
  this.skin = 0 < this.getSkins().length ? this.getSkins()[0].name : null;
  this.animation = 0 < this.getAnimations().length ? this.getAnimations()[0].name : null;
  this.track = 0;
  this.loop = !0;
  this.clock = new THREE.Clock;
  this.play();
}
SpineAnimation.prototype = Object.create(spine.threejs.SkeletonMesh.prototype);
SpineAnimation.prototype.update = THREE.Object3D.prototype.update;
SpineAnimation.prototype.onBeforeRender = function() {
  this.state.update(this.clock.getDelta());
  this.state.apply(this.skeleton);
  this.skeleton.updateWorldTransform();
  this.updateGeometry();
};
SpineAnimation.prototype.play = function() {
  null !== this.animation && this.setAnimation(this.track, this.animation, this.loop);
  null !== this.skin && this.setSkin(this.skin);
};
SpineAnimation.prototype.getAnimations = function() {
  return this.state.data.skeletonData.animations;
};
SpineAnimation.prototype.setAnimation = function(a, c, g) {
  try {
    void 0 !== a && (this.track = a), void 0 !== c && (this.animation = c), void 0 !== g && (this.loop = g), this.state.setAnimation(this.track, this.animation, this.loop);
  } catch (b) {
    this.animation = null, console.warn("nunuStudio: Error setting spine animation " + name + " on track " + a);
  }
};
SpineAnimation.prototype.getSkins = function() {
  return this.state.data.skeletonData.skins;
};
SpineAnimation.prototype.setSkin = function(a) {
  try {
    this.skeleton.setSkinByName(a), this.skin = a;
  } catch (c) {
    this.skin = null, console.warn("nunuStudio: Error setting spine skin " + a);
  }
};
SpineAnimation.prototype.toJSON = function(a) {
  var c = this.geometry, g = this.material;
  this.material = this.geometry = void 0;
  var b = [], e = this;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, c) {
    for (c = 0; c < e.textures.length; c++) {
      var f = e.textures[c].texture.toJSON(a);
      b.push({name:e.textures[c].name, texture:f.uuid});
    }
  });
  a.object.json = this.json;
  a.object.atlas = this.atlas;
  a.object.textures = b;
  null !== this.animation && (a.object.animation = this.animation, a.object.track = this.track, a.object.loop = this.loop);
  null !== this.skin && (a.object.skin = this.skin);
  this.geometry = c;
  this.material = g;
  return a;
};
"use strict";
function SpineTexture(a) {
  spine.Texture.call(this, a.image);
  this.texture = a;
  this.texture.flipY = !1;
}
SpineTexture.prototype = Object.create(spine.Texture.prototype);
SpineTexture.prototype.setFilters = function(a, c) {
  this.texture.minFilter = SpineTexture.getTextureFilter(a);
  this.texture.magFilter = SpineTexture.getTextureFilter(c);
};
SpineTexture.prototype.setWraps = function(a, c) {
  this.texture.wrapS = SpineTexture.getTextureWrap(a);
  this.texture.wrapT = SpineTexture.getTextureWrap(c);
};
SpineTexture.prototype.dispose = function() {
  this.texture.dispose();
};
SpineTexture.getTextureFilter = function(a) {
  return a === spine.TextureFilter.Linear ? THREE.LinearFilter : a === spine.TextureFilter.MipMap || a === spine.TextureFilter.MipMapLinearLinear ? THREE.LinearMipMapLinearFilter : a === spine.TextureFilter.MipMapLinearNearest ? THREE.LinearMipMapNearestFilter : a === spine.TextureFilter.MipMapNearestLinear ? THREE.NearestMipMapLinearFilter : a === spine.TextureFilter.MipMapNearestNearest ? THREE.NearestMipMapNearestFilter : a === spine.TextureFilter.Nearest ? THREE.NearestFilter : null;
};
SpineTexture.getTextureWrap = function(a) {
  if (a === spine.TextureWrap.ClampToEdge) {
    return THREE.ClampToEdgeWrapping;
  }
  if (a === spine.TextureWrap.MirroredRepeat) {
    return THREE.MirroredRepeatWrapping;
  }
  if (a === spine.TextureWrap.Repeat) {
    return THREE.RepeatWrapping;
  }
};
"use strict";
function ParticleEmitter(a, c) {
  this.group = new SPE.Group(void 0 !== a ? a : ParticleEmitter.defaultGroup);
  this.emitter = new SPE.Emitter(void 0 !== c ? c : ParticleEmitter.defaultEmitter);
  this.group.addEmitter(this.emitter);
  THREE.Points.call(this, this.group.geometry, this.group.material);
  this.type = "ParticleEmiter";
  this.name = "particle";
  this.dynamicEmitter = this.frustumCulled = !1;
  this.clock = new THREE.Clock;
  this.temp = new THREE.Vector4;
  var g = this;
  Object.defineProperties(this, {texture:{get:function() {
    return g.group.texture;
  }, set:function(a) {
    g.group.texture = a;
  }}});
}
ParticleEmitter.prototype = Object.create(THREE.Points.prototype);
ParticleEmitter.defaultEmitter = {particleCount:200, velocity:{value:new THREE.Vector3(0, 0, 0), spread:new THREE.Vector3(3, 3, 3)}, acceleration:{value:new THREE.Vector3(0, 0, 0), spread:new THREE.Vector3(0, 0, 0)}};
ParticleEmitter.defaultGroup = {texture:{value:null}, maxParticleCount:200, blending:THREE.AdditiveBlending, fog:!1, depthWrite:!1, depthTest:!0, transparent:!0, hasPerspective:!0};
ParticleEmitter.prototype.reload = function() {
  this.dispose();
  var a = this.children;
  this.children = [];
  var c = (new ObjectLoader).parse(this.toJSON());
  this.children = a;
  this.group = c.group;
  this.emitter = c.emitter;
  this.geometry = this.group.geometry;
  this.material = this.group.material;
};
ParticleEmitter.prototype.updateMatrix = function() {
  this.dynamicEmitter ? (this.matrix.makeRotationFromQuaternion(this.quaternion), this.matrix.scale(this.scale)) : this.matrix.compose(this.position, this.quaternion, this.scale);
  this.matrixWorldNeedsUpdate = !0;
};
ParticleEmitter.prototype.onBeforeRender = function(a, c, g, b) {
  this.group.uniforms.scale.value = a.getCurrentViewport(this.temp).w;
  this.group.tick(this.clock.getDelta());
  !0 === this.dynamicEmitter && (this.emitter.position.value = this.position);
};
ParticleEmitter.prototype.dispose = function() {
  this.group.dispose();
  THREE.Object3D.prototype.dispose.call(this);
};
ParticleEmitter.prototype.toJSON = function(a) {
  var c = this.material, g = this.geometry;
  this.geometry = this.material = void 0;
  var b = this.group.texture, e = THREE.Object3D.prototype.toJSON.call(this, a, function(a, c) {
    b = b.toJSON(a);
  });
  this.material = c;
  this.geometry = g;
  e.object.group = this.group.toJSON(a);
  e.object.emitter = this.emitter.toJSON(a);
  return e;
};
SPE.Group.prototype.toJSON = function(a) {
  a = {texture:{}};
  a.texture.value = this.texture.uuid;
  a.texture.frames = this.textureFrames.toArray();
  a.texture.frameCount = this.textureFrameCount;
  a.texture.loop = this.textureLoop;
  a.fixedTimeStep = this.fixedTimeStep;
  a.hasPerspective = this.hasPerspective;
  a.colorize = this.colorize;
  a.maxParticleCount = this.maxParticleCount;
  a.transparent = this.transparent;
  a.blending = this.blending;
  a.alphaTest = this.alphaTest;
  a.depthWrite = this.depthWrite;
  a.depthTest = this.depthTest;
  a.fog = this.fog;
  a.scale = this.scale;
  return a;
};
SPE.Emitter.prototype.toJSON = function(a) {
  a = {};
  a.uuid = this.uuid;
  a.type = this.type;
  a.direction = this.direction;
  a.particleCount = this.particleCount;
  a.duration = this.duration;
  a.isStatic = this.isStatic;
  a.maxAge = {};
  a.maxAge.value = this.maxAge.value;
  a.maxAge.spread = this.maxAge.spread;
  a.position = {};
  a.position.value = this.position.value.toArray();
  a.position.spread = this.position.spread.toArray();
  a.position.radius = this.position.radius;
  a.position.radiusScale = this.position.radiusScale.toArray();
  a.velocity = {};
  a.velocity.value = this.velocity.value.toArray();
  a.velocity.spread = this.velocity.spread.toArray();
  a.acceleration = {};
  a.acceleration.value = this.acceleration.value.toArray();
  a.acceleration.spread = this.acceleration.spread.toArray();
  a.wiggle = {};
  a.wiggle.value = this.wiggle.value;
  a.wiggle.spread = this.wiggle.spread;
  a.opacity = {};
  a.opacity.value = this.opacity.value.slice(0);
  a.opacity.spread = this.opacity.spread;
  a.size = {};
  a.size.value = this.size.value.slice(0);
  a.size.spread = this.size.spread;
  a.angle = {};
  a.angle.value = this.angle.value.slice(0);
  a.angle.spread = this.angle.spread;
  a.color = {};
  a.color.value = [];
  for (var c = 0; c < this.color.value.length; c++) {
    a.color.value.push(this.color.value[c].getHex());
  }
  a.color.spread = [];
  for (c = 0; c < this.color.spread.length; c++) {
    a.color.spread.push(this.color.spread[c].toArray());
  }
  return a;
};
"use strict";
function Sky(a, c, g, b) {
  THREE.Group.call(this);
  this.name = "sky";
  this.type = "Sky";
  this.colorTop = [new THREE.Color(7844859), new THREE.Color(30463), new THREE.Color(220086), new THREE.Color(9273)];
  this.colorBottom = [new THREE.Color(15461606), new THREE.Color(16777215), new THREE.Color(16705495), new THREE.Color(26023)];
  this.sunColor = 16777130;
  this.intensity = .3;
  this.moonColor = 5592507;
  this.hemisphere = new THREE.HemisphereLight(3310847, 16764031, .5);
  this.hemisphere.locked = !0;
  this.hemisphere.matrixAutoUpdate = !1;
  this.add(this.hemisphere);
  this.sun = new DirectionalLight(this.sunColor, this.intensity);
  this.sun.castShadow = !0;
  this.sun.locked = !0;
  this.add(this.sun);
  var e = {topColor:{type:"c", value:new THREE.Color(0, .46, 1)}, bottomColor:{type:"c", value:new THREE.Color(1, 1, 1)}, offset:{type:"f", value:20}, exponent:{type:"f", value:.2}};
  e.topColor.value.copy(this.hemisphere.color);
  var f = new THREE.SphereBufferGeometry(1500, 16, 16);
  e = new THREE.ShaderMaterial({vertexShader:Sky.VERTEX, fragmentShader:Sky.FRAGMENT, uniforms:e, side:THREE.BackSide});
  this.sky = new THREE.Mesh(f, e);
  this.sky.locked = !0;
  this.sky.matrixAutoUpdate = !1;
  this.add(this.sky);
  this.sky.raycast = function() {
    return null;
  };
  this.autoUpdate = void 0 !== a ? a : !0;
  this.sunDistance = void 0 !== g ? g : 100;
  this.dayTime = void 0 !== c ? c : 120;
  this.time = void 0 !== b ? b : 75;
  this.updateSky();
}
Sky.prototype = Object.create(THREE.Group.prototype);
Sky.VERTEX = "varying vec3 vWorldPosition;\nvoid main()\n{\n\tvec4 worldPosition = modelMatrix * vec4(position, 1.0);\n\tvWorldPosition = worldPosition.xyz;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}";
Sky.FRAGMENT = "uniform vec3 topColor;\nuniform vec3 bottomColor;\nuniform float offset;\nuniform float exponent;\nvarying vec3 vWorldPosition;\nvoid main()\n{\n\tfloat h = normalize(vWorldPosition + offset).y;\n\tgl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h , 0.0), exponent), 0.0)), 1.0);\n}";
Sky.prototype.initialize = function() {
  this.updateSky();
  THREE.Object3D.prototype.initialize.call(this);
};
Sky.prototype.update = function(a) {
  this.autoUpdate && (this.time += a, this.time > this.dayTime && (this.time -= this.dayTime), this.updateSky());
  THREE.Object3D.prototype.update.call(this, a);
};
Sky.prototype.updateSky = function() {
  var a = this.time / this.dayTime;
  if (.25 > a) {
    this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[3].r, this.colorTop[3].g, this.colorTop[3].b), this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[3].r, this.colorBottom[3].g, this.colorBottom[3].b);
  } else {
    if (.292 > a) {
      var c = 23.81 * (a - .25), g = 1 - c;
      this.sky.material.uniforms.topColor.value.setRGB(g * this.colorTop[3].r + c * this.colorTop[0].r, g * this.colorTop[3].g + c * this.colorTop[0].g, g * this.colorTop[3].b + c * this.colorTop[0].b);
      this.sky.material.uniforms.bottomColor.value.setRGB(g * this.colorBottom[3].r + c * this.colorBottom[0].r, g * this.colorBottom[3].g + c * this.colorBottom[0].g, g * this.colorBottom[3].b + c * this.colorBottom[0].b);
    } else {
      .4167 > a ? (this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[0].r, this.colorTop[0].g, this.colorTop[0].b), this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[0].r, this.colorBottom[0].g, this.colorBottom[0].b)) : .5 > a ? (c = 12 * (a - .4167), g = 1 - c, this.sky.material.uniforms.topColor.value.setRGB(g * this.colorTop[0].r + c * this.colorTop[1].r, g * this.colorTop[0].g + c * this.colorTop[1].g, g * this.colorTop[0].b + c * this.colorTop[1].b), this.sky.material.uniforms.bottomColor.value.setRGB(g * 
      this.colorBottom[0].r + c * this.colorBottom[1].r, g * this.colorBottom[0].g + c * this.colorBottom[1].g, g * this.colorBottom[0].b + c * this.colorBottom[1].b)) : .708 > a ? (this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[1].r, this.colorTop[1].g, this.colorTop[1].b), this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[1].r, this.colorBottom[1].g, this.colorBottom[1].b)) : .75 > a ? (c = 23.81 * (a - .708), g = 1 - c, this.sky.material.uniforms.topColor.value.setRGB(g * 
      this.colorTop[1].r + c * this.colorTop[2].r, g * this.colorTop[1].g + c * this.colorTop[2].g, g * this.colorTop[1].b + c * this.colorTop[2].b), this.sky.material.uniforms.bottomColor.value.setRGB(g * this.colorBottom[1].r + c * this.colorBottom[2].r, g * this.colorBottom[1].g + c * this.colorBottom[2].g, g * this.colorBottom[1].b + c * this.colorBottom[2].b)) : .8333 > a ? (c = 12.048 * (a - .75), g = 1 - c, this.sky.material.uniforms.topColor.value.setRGB(g * this.colorTop[2].r + c * this.colorTop[3].r, 
      g * this.colorTop[2].g + c * this.colorTop[3].g, g * this.colorTop[2].b + c * this.colorTop[3].b), this.sky.material.uniforms.bottomColor.value.setRGB(g * this.colorBottom[2].r + c * this.colorBottom[3].r, g * this.colorBottom[2].g + c * this.colorBottom[3].g, g * this.colorBottom[2].b + c * this.colorBottom[3].b)) : (this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[3].r, this.colorTop[3].g, this.colorTop[3].b), this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[3].r, 
      this.colorBottom[3].g, this.colorBottom[3].b));
    }
  }
  .2 > a ? (this.sun.intensity = this.intensity, this.sun.color.setHex(this.moonColor)) : .3 > a ? (c = 10 * (a - .2), .5 > c ? (this.sun.intensity = (2 - 2 * c) * this.intensity, this.sun.color.setHex(this.moonColor)) : (this.sun.intensity = 2 * c * this.intensity, this.sun.color.setHex(this.sunColor))) : .7 > a ? (this.sun.intensity = this.intensity, this.sun.color.setHex(this.sunColor)) : .8 > a ? (c = 10 * (a - .7), .5 > c ? (this.sun.intensity = (2 - 2 * c) * this.intensity, this.sun.color.setHex(this.sunColor)) : 
  (this.sun.intensity = 2 * c * this.intensity, this.sun.color.setHex(this.moonColor))) : (this.sun.intensity = this.intensity, this.sun.color.setHex(this.moonColor));
  c = MathUtils.PI2 * a - MathUtils.PID2;
  .25 < a && .75 > a ? (this.sun.position.x = this.sunDistance * Math.cos(c), this.sun.position.y = this.sunDistance * Math.sin(c)) : (this.sun.position.x = this.sunDistance * Math.cos(c + Math.PI), this.sun.position.y = this.sunDistance * Math.sin(c + Math.PI));
};
Sky.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.colorTop = [];
  for (var c = 0; c < this.colorTop.length; c++) {
    a.object.colorTop.push(this.colorTop[c].toJSON());
  }
  a.object.colorBottom = [];
  for (c = 0; c < this.colorBottom.length; c++) {
    a.object.colorBottom.push(this.colorBottom[c].toJSON());
  }
  a.object.sunColor = this.sunColor;
  a.object.moonColor = this.moonColor;
  a.object.intensity = this.intensity;
  a.object.autoUpdate = this.autoUpdate;
  a.object.sunDistance = this.sunDistance;
  a.object.dayTime = this.dayTime;
  a.object.time = this.time;
  a.object.sun = {};
  a.object.sun.castShadow = this.sun.castShadow;
  a.object.sun.shadow = this.sun.shadow.toJSON();
  return a;
};
"use strict";
function Container() {
  THREE.Group.call(this);
  this.name = "container";
  this.type = "Group";
}
Container.prototype = Object.create(THREE.Group.prototype);
"use strict";
function CubeCamera(a, c, g, b) {
  THREE.Object3D.call(this);
  this.name = "cubecamera";
  this.type = "CubeCamera";
  this.near = void 0 !== a ? a : .01;
  this.far = void 0 !== c ? c : 1E4;
  this.resolution = void 0 !== g ? g : 256;
  this.autoUpdate = void 0 !== b ? b : !1;
  this.cameras = [];
  for (a = 0; 6 > a; a++) {
    c = new THREE.PerspectiveCamera(90, 1, this.near, this.far), c.parent = this, this.cameras.push(c);
  }
  this.cameras[0].up.set(0, -1, 0);
  this.cameras[0].lookAt(new THREE.Vector3(1, 0, 0));
  this.cameras[1].up.set(0, -1, 0);
  this.cameras[1].lookAt(new THREE.Vector3(-1, 0, 0));
  this.cameras[2].up.set(0, 0, 1);
  this.cameras[2].lookAt(new THREE.Vector3(0, 1, 0));
  this.cameras[3].up.set(0, 0, -1);
  this.cameras[3].lookAt(new THREE.Vector3(0, -1, 0));
  this.cameras[4].up.set(0, -1, 0);
  this.cameras[4].lookAt(new THREE.Vector3(0, 0, 1));
  this.cameras[5].up.set(0, -1, 0);
  this.cameras[5].lookAt(new THREE.Vector3(0, 0, -1));
  this.target = new THREE.WebGLRenderTargetCube(this.resolution, this.resolution, {format:THREE.RGBFormat, magFilter:THREE.LinearFilter, minFilter:THREE.LinearFilter});
  this.cube = this.target.texture;
  this.cube.generateMipmaps = !1;
  this.cube.name = "cube";
  this.renderer = this.scene = null;
}
THREE._CubeCamera = THREE.CubeCamera;
THREE.CubeCamera = CubeCamera;
CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
CubeCamera.prototype.initialize = function() {
  for (var a = this; null !== a.parent;) {
    a = a.parent, a instanceof Scene ? this.scene = a : a instanceof Program && (this.renderer = a.renderer);
  }
  THREE.Object3D.prototype.initialize.call(this);
};
CubeCamera.prototype.update = function(a) {
  this.autoUpdate && this.updateCubeMap(this.renderer, this.scene);
  THREE.Object3D.prototype.update.call(this, a);
};
CubeCamera.prototype.setResolution = function(a) {
  this.resolution = a;
  this.target.setSize(a, a);
};
CubeCamera.prototype.updateCubeMap = function(a, c) {
  var g = a.autoClear;
  a.autoClear = !0;
  for (var b = 0; 6 > b; b++) {
    this.cameras[b].updateMatrixWorld(), this.target.activeCubeFace = b, a.setRenderTarget(this.target), a.render(c, this.cameras[b]);
  }
  a.autoClear = g;
};
CubeCamera.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.near = this.near;
  a.object.far = this.far;
  a.object.resolution = this.resolution;
  a.object.autoUpdate = this.autoUpdate;
  return a;
};
"use strict";
function LensFlare() {
  THREE.Mesh.call(this, THREE.Lensflare.Geometry, new THREE.MeshBasicMaterial({opacity:0, transparent:!0}));
  this.name = "lensflare";
  this.type = "LensFlare";
  this.renderOrder = Infinity;
  this.castShadow = this.receiveShadow = this.frustumCulled = !1;
  this.elements = [];
  var a = new THREE.Vector3, c = new THREE.DataTexture(new Uint8Array(768), 16, 16, THREE.RGBFormat);
  c.minFilter = THREE.NearestFilter;
  c.magFilter = THREE.NearestFilter;
  c.wrapS = THREE.ClampToEdgeWrapping;
  c.wrapT = THREE.ClampToEdgeWrapping;
  c.needsUpdate = !0;
  var g = new THREE.DataTexture(new Uint8Array(768), 16, 16, THREE.RGBFormat);
  g.minFilter = THREE.NearestFilter;
  g.magFilter = THREE.NearestFilter;
  g.wrapS = THREE.ClampToEdgeWrapping;
  g.wrapT = THREE.ClampToEdgeWrapping;
  g.needsUpdate = !0;
  var b = THREE.Lensflare.Geometry, e = THREE.Lensflare.Shader, f = new THREE.RawShaderMaterial({uniforms:{scale:{value:null}, screenPosition:{value:null}}, vertexShader:"precision highp float;\n\t\t\tuniform vec3 screenPosition;\n\t\t\tuniform vec2 scale;\n\t\t\tattribute vec3 position;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tgl_Position = vec4(position.xy * scale + screenPosition.xy, screenPosition.z, 1.0);\n\t\t\t}", fragmentShader:"precision highp float;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tgl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n\t\t\t}", 
  depthTest:!0, depthWrite:!1, transparent:!1}), k = new THREE.RawShaderMaterial({uniforms:{map:{value:c}, scale:{value:null}, screenPosition:{value:null}}, vertexShader:"precision highp float;\n\t\t\tuniform vec3 screenPosition;\n\t\t\tuniform vec2 scale;\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\t\t\tvarying vec2 vUV;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tvUV = uv;\n\t\t\t\tgl_Position = vec4(position.xy * scale + screenPosition.xy, screenPosition.z, 1.0);\n\t\t\t}", fragmentShader:"precision highp float;\n\t\t\tuniform sampler2D map;\n\t\t\tvarying vec2 vUV;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tgl_FragColor = texture2D(map, vUV);\n\t\t\t}", 
  depthTest:!1, depthWrite:!1, transparent:!1}), n = new THREE.Mesh(b, f);
  e = THREE.LensflareElement.Shader;
  var p = new THREE.RawShaderMaterial({uniforms:{map:{value:null}, occlusionMap:{value:g}, color:{value:new THREE.Color(16777215)}, scale:{value:new THREE.Vector2}, screenPosition:{value:new THREE.Vector3}}, vertexShader:e.vertexShader, fragmentShader:e.fragmentShader, blending:THREE.AdditiveBlending, transparent:!0, depthWrite:!1}), m = new THREE.Mesh(b, p), t = new THREE.Vector2, d = new THREE.Vector2, l = new THREE.Box2, u = new THREE.Vector4;
  this.onBeforeRender = function(e, y, x) {
    e.getCurrentViewport(u);
    y = u.w / u.z;
    var q = u.z / 2, v = u.w / 2, w = 16 / u.w;
    t.set(w * y, w);
    l.min.set(u.x, u.y);
    l.max.set(u.x + (u.z - 16), u.y + (u.w - 16));
    a.setFromMatrixPosition(this.matrixWorld);
    a.applyMatrix4(x.matrixWorldInverse);
    a.applyMatrix4(x.projectionMatrix);
    d.x = u.x + a.x * q + q - 8;
    d.y = u.y + a.y * v + v - 8;
    if (l.containsPoint(d)) {
      e.copyFramebufferToTexture(d, c);
      q = f.uniforms;
      q.scale.value = t;
      q.screenPosition.value = a;
      e.renderBufferDirect(x, null, b, f, n, null);
      e.copyFramebufferToTexture(d, g);
      q = k.uniforms;
      q.scale.value = t;
      q.screenPosition.value = a;
      e.renderBufferDirect(x, null, b, k, n, null);
      v = 2 * -a.x;
      for (var C = 2 * -a.y, A = 0, D = this.elements.length; A < D; A++) {
        y = this.elements[A], q = p.uniforms, q.color.value.copy(y.color), q.map.value = y.texture, q.screenPosition.value.x = a.x + v * y.distance, q.screenPosition.value.y = a.y + C * y.distance, w = y.size / u.w, y = u.w / u.z, q.scale.value.set(w * y, w), p.uniformsNeedUpdate = !0, e.renderBufferDirect(x, null, b, p, m, null);
      }
    }
  };
  this.dispose = function() {
    f.dispose();
    k.dispose();
    p.dispose();
    c.dispose();
    g.dispose();
    for (var a = 0; a < this.elements.length; a++) {
      this.elements[a].texture.dispose();
    }
  };
}
LensFlare.prototype = Object.create(THREE.Mesh.prototype);
LensFlare.prototype.addFlare = function(a, c, g, b) {
  void 0 === c && (c = -1);
  void 0 === g && (g = 0);
  void 0 === b && (b = new Color(16777215));
  g = Math.min(g, Math.max(0, g));
  this.addElement(new THREE.LensflareElement(a, c, g, b));
};
LensFlare.prototype.addElement = function(a) {
  this.elements.push(a);
};
LensFlare.prototype.toJSON = function(a) {
  var c = this, g = [];
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, e) {
    for (e = 0; e < c.elements.length; e++) {
      var b = {};
      b.texture = c.elements[e].texture.toJSON(a).uuid;
      b.size = c.elements[e].size;
      b.distance = c.elements[e].distance;
      b.color = c.elements[e].color.getHex();
      g.push(b);
    }
  });
  a.object.elements = g;
  return a;
};
"use strict";
function Skeleton(a, c) {
  this.uuid = THREE.Math.generateUUID();
  void 0 === a && (a = []);
  this.bones = a.slice(0);
  this.boneMatrices = new Float32Array(16 * this.bones.length);
  if (void 0 === c) {
    this.calculateInverses();
  } else {
    if (this.bones.length === c.length) {
      this.boneInverses = c.slice(0);
    } else {
      for (console.warn("nunuStudio: Skeleton boneInverses is the wrong length."), this.boneInverses = [], a = 0; a < this.bones.length; a++) {
        this.boneInverses.push(new Matrix4);
      }
    }
  }
}
THREE._Skeleton = THREE.Skeleton;
THREE.Skeleton = Skeleton;
Skeleton.prototype = Object.create(THREE._Skeleton.prototype);
Skeleton.prototype.toJSON = function(a) {
  a = {};
  for (var c = [], g = [], b = 0, e = this.bones.length; b < e; b++) {
    c.push(this.bones[b].uuid);
  }
  b = 0;
  for (e = this.boneInverses.length; b < e; b++) {
    g.push(this.boneInverses[b].toArray());
  }
  a.uuid = this.uuid;
  a.bones = c;
  a.boneInverses = g;
  return a;
};
"use strict";
function OrbitControls() {
  THREE.Group.call(this);
  this.name = "orbit";
  this.type = "OrbitControls";
  this.distance = 4;
  this.maxDistance = 20;
  this.minDistance = 2;
  this.sensitivity = .002;
  this.zoomSensitivity = .001;
  this.limitUp = 1.57;
  this.limitDown = -1.57;
  this.movementEnabled = this.zoomEnabled = this.needsButtonPressed = !0;
  this.center = new THREE.Vector3(0, 0, 0);
  this.vector = new THREE.Vector2(Math.PI / 2, 0);
  this.smooth = !0;
  this.friction = .8;
  this.speed = .3;
  this.invertNavigation = !1;
  this.keyboard = this.mouse = null;
  this.speedDistance = 0;
  this.speedCenter = new THREE.Vector3(0, 0, 0);
  this.speedOrientation = new THREE.Vector2(0, 0);
  this.tempVector = new THREE.Vector3;
}
OrbitControls.UP = new THREE.Vector3(0, 1, 0);
OrbitControls.ZERO = new THREE.Vector3(0, 0, 0);
OrbitControls.prototype = Object.create(THREE.Group.prototype);
OrbitControls.prototype.initialize = function() {
  for (var a = this; null !== a.parent;) {
    a = a.parent, a instanceof Program && (this.mouse = a.mouse, this.keyboard = a.keyboard);
  }
  this.center.copy(this.position);
  this.updateControls();
  THREE.Group.prototype.initialize.call(this);
};
OrbitControls.prototype.update = function(a) {
  var c = !1;
  if (!this.needsButtonPressed || this.mouse.buttonPressed(Mouse.LEFT)) {
    !0 === this.smooth ? (this.speedOrientation.y += this.speed * this.sensitivity * (this.invertNavigation ? this.mouse.delta.y : -this.mouse.delta.y), this.speedOrientation.x -= this.speed * this.sensitivity * this.mouse.delta.x) : (this.vector.y -= this.sensitivity * (this.invertNavigation ? this.mouse.delta.y : -this.mouse.delta.y), this.vector.x -= this.sensitivity * this.mouse.delta.x), c = !0;
  }
  this.zoomEnabled && (this.mouse.buttonPressed(Mouse.MIDDLE) && (!0 === this.smooth ? this.speedCenter.y += this.speed * this.sensitivity * this.mouse.delta.y * this.distance : this.center.y += this.sensitivity * this.mouse.delta.y * this.distance, c = !0), 0 !== this.mouse.wheel && (!0 === this.smooth ? this.speedDistance += this.speed * this.mouse.wheel * this.position.distanceTo(this.center) * this.sensitivity : this.distance += this.mouse.wheel * this.position.distanceTo(this.center) * this.sensitivity, 
  c = !0));
  if (this.movementEnabled && this.mouse.buttonPressed(Mouse.RIGHT)) {
    c = this.getWorldDirection(this.tempVector);
    c.y = 0;
    c.normalize();
    if (!0 === this.smooth) {
      var g = this.speed * this.mouse.delta.y * this.sensitivity * this.distance;
      this.speedCenter.x += up ? -c.x * g : c.x * g;
      this.speedCenter.z += up ? -c.z * g : c.z * g;
      c.applyAxisAngle(OrbitControls.UP, Math.PI / 2);
      g = this.speed * this.mouse.delta.x * this.sensitivity * this.distance;
      this.speedCenter.x -= c.x * g;
      this.speedCenter.z -= c.z * g;
    } else {
      g = this.mouse.delta.y * this.sensitivity * this.distance, this.center.x += up ? -c.x * g : c.x * g, this.center.z += up ? -c.z * g : c.z * g, c.applyAxisAngle(OrbitControls.UP, Math.PI / 2), g = this.mouse.delta.x * this.sensitivity * this.distance, this.center.x -= c.x * g, this.center.z -= c.z * g;
    }
    c = !0;
  }
  !0 === this.smooth ? (this.distance += this.speedDistance, this.center.add(this.speedCenter), this.vector.add(this.speedOrientation), this.speedDistance *= this.friction, this.speedOrientation.multiplyScalar(this.friction), this.speedCenter.multiplyScalar(this.friction), this.updateControls()) : (!0 === c && this.updateControls(), THREE.Object3D.prototype.update.call(this, a));
};
OrbitControls.prototype.updateControls = function() {
  this.vector.y < this.limitDown ? this.vector.y = this.limitDown : this.vector.y > this.limitUp && (this.vector.y = this.limitUp);
  this.distance < this.minDistance ? this.distance = this.minDistance : this.distance > this.maxDistance && (this.distance = this.maxDistance);
  var a = this.distance * Math.cos(this.vector.y);
  this.position.set(Math.cos(this.vector.x) * a, this.distance * Math.sin(this.vector.y), Math.sin(this.vector.x) * a);
  this.position.add(this.center);
  a = new THREE.Matrix4;
  a.lookAt(this.position, this.center, OrbitControls.UP);
  this.quaternion.setFromRotationMatrix(a);
};
OrbitControls.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.distance = this.distance;
  a.object.maxDistance = this.maxDistance;
  a.object.minDistance = this.minDistance;
  a.object.sensitivity = this.sensitivity;
  a.object.limitUp = this.limitUp;
  a.object.limitDown = this.limitDown;
  a.object.needsButtonPressed = this.needsButtonPressed;
  a.object.zoomEnabled = this.zoomEnabled;
  a.object.movementEnabled = this.movementEnabled;
  a.object.smooth = this.smooth;
  a.object.friction = this.friction;
  a.object.speed = this.speed;
  a.object.invertNavigation = this.invertNavigation;
  a.object.center = this.center.toArray();
  a.object.vector = this.vector.toArray();
  return a;
};
"use strict";
function FirstPersonControls() {
  THREE.Group.call(this);
  this.name = "controls";
  this.type = "FirstPersonControls";
  this.sensitivity = .005;
  this.movementEnabled = this.needsButtonPressed = !0;
  this.moveSpeed = .05;
  this.moveOnPlane = !1;
  this.moveKeys = [Keyboard.W, Keyboard.S, Keyboard.A, Keyboard.D];
  this.vector = new THREE.Vector2(0, 0);
  this.keyboard = this.mouse = null;
  this.tempVector = new THREE.Vector3;
}
FirstPersonControls.UP = new THREE.Vector3(0, 1, 0);
FirstPersonControls.prototype = Object.create(THREE.Group.prototype);
FirstPersonControls.prototype.initialize = function() {
  for (var a = this; null !== a.parent;) {
    a = a.parent, a instanceof Program && (this.mouse = a.mouse, this.keyboard = a.keyboard);
  }
  this.updateControls();
  THREE.Group.prototype.initialize.call(this);
};
FirstPersonControls.prototype.update = function(a) {
  if (!this.needsButtonPressed || this.mouse.buttonPressed(Mouse.LEFT)) {
    this.vector.y -= this.sensitivity * this.mouse.delta.y, this.vector.x -= this.sensitivity * this.mouse.delta.x, -1.57 > this.vector.y ? this.vector.y = -1.57 : 1.57 < this.vector.y && (this.vector.y = 1.57), this.updateControls();
  }
  if (this.movementEnabled) {
    if (this.keyboard.keyPressed(this.moveKeys[0])) {
      var c = this.getWorldDirection(this.tempVector);
      this.moveOnPlane && (c.y = 0);
      c.normalize();
      c.multiplyScalar(this.moveSpeed);
      this.position.sub(c);
    }
    this.keyboard.keyPressed(this.moveKeys[1]) && (c = this.getWorldDirection(this.tempVector), this.moveOnPlane && (c.y = 0), c.normalize(), c.multiplyScalar(this.moveSpeed), this.position.add(c));
    this.keyboard.keyPressed(this.moveKeys[2]) && (c = new THREE.Vector3(Math.sin(this.vector.x - 1.57), 0, Math.cos(this.vector.x - 1.57)), c.normalize(), c.multiplyScalar(this.moveSpeed), this.position.sub(c));
    this.keyboard.keyPressed(this.moveKeys[3]) && (c = new THREE.Vector3(Math.sin(this.vector.x + 1.57), 0, Math.cos(this.vector.x + 1.57)), c.normalize(), c.multiplyScalar(this.moveSpeed), this.position.sub(c));
  }
  THREE.Object3D.prototype.update.call(this, a);
};
FirstPersonControls.prototype.updateControls = function() {
  var a = Math.cos(this.vector.y);
  a = new THREE.Vector3(Math.sin(this.vector.x) * a, Math.sin(this.vector.y), Math.cos(this.vector.x) * a);
  a.add(this.position);
  var c = new THREE.Matrix4;
  c.lookAt(this.position, a, FirstPersonControls.UP);
  this.quaternion.setFromRotationMatrix(c);
};
FirstPersonControls.prototype.getDirection = function() {
  var a = this.getWorldDirection(this.tempVector);
  a.normalize();
  return a;
};
FirstPersonControls.prototype.toJSON = function(a) {
  a = THREE.Object3D.prototype.toJSON.call(this, a);
  a.object.moveSpeed = this.moveSpeed;
  a.object.sensitivity = this.sensitivity;
  a.object.needsButtonPressed = this.needsButtonPressed;
  a.object.movementEnabled = this.movementEnabled;
  a.object.moveOnPlane = this.moveOnPlane;
  a.object.moveKeys = this.moveKeys;
  return a;
};
"use strict";
function Program(a) {
  ResourceManager.call(this);
  this.type = "Program";
  this.matrixAutoUpdate = !1;
  this.app = null;
  this.name = void 0 !== a ? a : "program";
  this.author = this.description = "";
  this.version = "0";
  this.vr = this.handlePixelRatio = this.lockPointer = !1;
  this.vrScale = 1;
  this.shadows = this.antialiasing = !0;
  this.shadowsType = THREE.PCFSoftShadowMap;
  this.toneMapping = THREE.NoToneMapping;
  this.toneMappingWhitePoint = this.toneMappingExposure = 1;
  this.division = this.canvas = this.scene = this.renderer = this.mouse = this.keyboard = this.defaultCamera = this.defaultScene = null;
  this.useVR = !1;
  this.controls = this.effect = this.display = null;
  this.manager = new EventManager;
  this.manager.add(window, "vrdisplaypresentchange", function() {
    null === self.display || self.display.isPresenting || (self.useVR = !1);
  });
}
Program.prototype = Object.create(ResourceManager.prototype);
Program.prototype.initialize = function() {
  this.manager.create();
  null === this.mouse && (this.mouse = new Mouse);
  null === this.keyboard && (this.keyboard = new keyboard);
  if (null !== this.defaultScene) {
    for (var a = 0; a < this.children.length; a++) {
      if (this.children[a].uuid === this.defaultScene) {
        this.setScene(this.children[a]);
        break;
      }
    }
  } else {
    0 < this.children.length && this.setScene(this.children[0]);
  }
  if (this.vr) {
    var c = this;
    Nunu.getVRDisplays(function(a) {
      c.display = a;
      c.controls = new VRControls;
      c.effect = new VREffect(c.renderer);
    });
  }
};
Program.prototype.setMouseKeyboard = function(a, c) {
  this.mouse = a;
  this.keyboard = c;
};
Program.prototype.setRenderer = function(a, c) {
  this.renderer = a;
  this.renderer.autoClear = !1;
  this.canvas = a.domElement;
  this.division = this.canvas.parentElement;
  c && this.updateRenderer();
};
Program.prototype.update = function(a) {
  this.scene.update(a);
};
Program.prototype.render = function(a) {
  if (this.useVR) {
    for (a = 0; a < this.scene.cameras.length; a++) {
      var c = this.scene.cameras[a];
      this.controls.update(c);
      this.effect.render(this.scene, c, void 0, !0);
    }
  } else {
    this.scene.render(a);
  }
};
Program.prototype.resize = function(a, c) {
  null !== this.effect && this.effect.setSize(a, c);
  null !== this.defaultCamera && this.defaultCamera.resize(a, c);
  this.scene.resize(a, c);
};
Program.prototype.updateRenderer = function() {
  null !== this.renderer && (this.renderer.shadowMap.enabled = this.shadows, this.renderer.shadowMap.type = this.shadowsType, this.renderer.toneMapping = this.toneMapping, this.renderer.toneMappingExposure = this.toneMappingExposure, this.renderer.toneMappingWhitePoint = this.toneMappingWhitePoint);
};
Program.prototype.displayVR = function() {
  if (this.vr) {
    try {
      this.display.isPresenting || (this.display.requestPresent([{source:this.canvas}]), this.useVR = !0);
    } catch (a) {
      console.warn("nunuStudio: Failed to enter in VR mode", a);
    }
  }
};
Program.prototype.exitVR = function() {
  this.display.isPresenting && (this.display.exitPresent(), this.useVR = !1);
};
Program.prototype.setScene = function(a) {
  null !== this.scene && this.scene.dispose();
  a instanceof Scene ? this.scene = a : "string" === typeof a && (this.scene = this.getObjectByName(a));
  null !== this.scene && (null === this.scene.defaultCamera && (this.scene.defaultCamera = this.defaultCamera), this.scene.initialize());
};
Program.prototype.remove = function(a) {
  if (a instanceof Scene) {
    var c = this.children.indexOf(a);
    -1 < c && (this.children.splice(c, 1), a.parent = null);
    a === this.scene && (this.scene.dispose(), this.scene = null);
    0 === this.children.length && (this.scene = null);
  } else {
    console.warn("nunuStudio: Trying to remove Object3D from program, only Scene objects allowed.");
  }
};
Program.prototype.add = function(a) {
  a instanceof Scene ? (a.parent = this, this.children.push(a), 1 === this.children.length && (this.scene = this.children[0])) : console.warn("nunuStudio: Trying to add Object3D to program, only Scene objects allowed.");
};
Program.prototype.clone = function() {
  return (new ObjectLoader).parse(this.toJSON());
};
Program.prototype.setInitialScene = function(a) {
  this.defaultScene = a.uuid;
};
Program.prototype.dispose = function() {
  this.manager.destroy();
  null !== this.effect && this.effect.dispose();
  null !== this.scene ? this.scene.dispose() : console.warn("nunuStudio: Program dispose() scene is null.", this);
  ResourceManager.prototype.dispose.call(this);
  THREE.Object3D.prototype.dispose.call(this);
};
Program.prototype.receiveDataApp = function(a) {
  var c = !1;
  this.traverse(function(g) {
    g instanceof Script && (g.appData(a), c = !0);
  });
  c || console.warn("nunuStudio: No script with onAppData found", a);
};
Program.prototype.sendDataApp = function(a) {
  if (null !== this.app) {
    if (void 0 !== this.app.onDataReceived) {
      this.app.onDataReceived(a);
    } else {
      console.warn("nunuStudio: Send app data communication", a);
    }
  } else {
    console.warn("nunuStudio: Data sent to app", a);
  }
};
Program.prototype.toJSON = function(a, c) {
  var g = this;
  a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, e) {
    if (!1 !== c) {
      e = g.textures;
      for (var b in e) {
        var k = e[b];
        void 0 === a.textures[k.uuid] && (a.textures[k.uuid] = k.toJSON(a));
      }
      e = g.materials;
      for (b in e) {
        k = e[b], void 0 === a.materials[k.uuid] && (a.materials[k.uuid] = k.toJSON(a));
      }
      e = g.fonts;
      for (b in e) {
        k = e[b], void 0 === a.fonts[k.uuid] && (a.fonts[k.uuid] = k.toJSON(a));
      }
      e = g.audio;
      for (b in e) {
        k = e[b], void 0 === a.audio[k.uuid] && (a.audio[k.uuid] = k.toJSON(a));
      }
      e = g.resources;
      for (b in e) {
        k = e[b], void 0 === a.resources[k.uuid] && (a.resources[k.uuid] = k.toJSON(a));
      }
    }
  });
  null !== this.defaultScene && (a.object.defaultScene = this.defaultScene);
  a.object.author = this.author;
  a.object.description = this.description;
  a.object.version = this.version;
  a.object.lockPointer = this.lockPointer;
  a.object.handlePixelRatio = this.handlePixelRatio;
  a.object.vr = this.vr;
  a.object.vrScale = this.vrScale;
  a.object.antialiasing = this.antialiasing;
  a.object.shadows = this.shadows;
  a.object.shadowsType = this.shadowsType;
  a.object.toneMapping = this.toneMapping;
  a.object.toneMappingExposure = this.toneMappingExposure;
  a.object.toneMappingWhitePoint = this.toneMappingWhitePoint;
  return a;
};
"use strict";
function Scene() {
  THREE._Scene.call(this);
  this.name = "scene";
  this.matrixAutoUpdate = !1;
  this.usePhysics = !0;
  this.world = new CANNON.World;
  this.world.defaultContactMaterial.contactEquationStiffness = 1E9;
  this.world.defaultContactMaterial.contactEquationRelaxation = 4;
  this.world.quatNormalizeSkip = 0;
  this.world.quatNormalizeFast = !1;
  this.world.gravity.set(0, -9.8, 0);
  this.world.broadphase = new CANNON.NaiveBroadphase;
  this.world.solver = new CANNON.SplitSolver(new CANNON.GSSolver);
  this.world.solver.tolerance = .05;
  this.world.solver.iterations = 7;
  this.background = new THREE.Color(0);
  this.cameras = [];
  this.defaultCamera = null;
  this.clock = new THREE.Clock;
  this.delta = 0;
  this.raycaster = new THREE.Raycaster;
  this.canvas = this.program = null;
  this.mouse = new THREE.Vector2(0, 0);
}
THREE._Scene = THREE.Scene;
Scene.prototype = Object.create(THREE._Scene.prototype);
Scene.prototype.initialize = function() {
  this.program = this.parent;
  this.canvas = this.parent.canvas;
  THREE.Object3D.prototype.initialize.call(this);
  this.clock.start();
  for (var a = 0; a < this.children.length; a++) {
    this.children[a].traverse(function(a) {
      a.initialize();
    });
  }
};
Scene.prototype.update = function(a) {
  this.mouse.set(this.program.mouse.position.x / this.canvas.width * 2 - 1, -2 * this.program.mouse.position.y / this.canvas.height + 1);
  0 < this.cameras.length && this.raycaster.setFromCamera(this.mouse, this.cameras[0]);
  this.delta = this.clock.getDelta();
  this.usePhysics && this.world.step(.05 > this.delta ? this.delta : .05);
  a = this.delta;
  for (var c = 0; c < this.children.length; c++) {
    this.children[c].traverse(function(c) {
      c.update(a);
    });
  }
};
Scene.prototype.resize = function(a, c) {
  null !== this.defaultCamera && (this.defaultCamera.aspect = a / c, this.defaultCamera.updateProjectionMatrix());
  for (var g = 0; g < this.cameras.length; g++) {
    this.cameras[g].aspect = a / c, this.cameras[g].updateProjectionMatrix();
  }
  for (g = 0; g < this.children.length; g++) {
    this.children[g].traverse(function(b) {
      b.resize(a, c);
    });
  }
};
Scene.prototype.dispose = function() {
  for (var a = 0; a < this.children.length; a++) {
    this.children[a].traverse(function(a) {
      a.dispose();
    });
  }
};
Scene.prototype.render = function(a) {
  a.setClearColor(this.background);
  if (0 < this.cameras.length) {
    var c = a.domElement.width, g = a.domElement.height;
    a.setScissorTest(!0);
    for (var b = 0; b < this.cameras.length; b++) {
      var e = this.cameras[b];
      a.setViewport(c * e.offset.x, g * e.offset.y, c * e.viewport.x, g * e.viewport.y);
      a.setScissor(c * e.offset.x, g * e.offset.y, c * e.viewport.x, g * e.viewport.y);
      a.autoClearColor = e.clearColor;
      a.autoClearDepth = e.clearDepth;
      a.autoClearStencil = e.clearStencil;
      e.render(a, this);
    }
    a.setScissorTest(!1);
  } else {
    null !== this.defaultCamera && this.defaultCamera.render(a, this);
  }
};
Scene.prototype.getCamera = function(a, c) {
  void 0 === c && (c = this);
  if (a === c.uuid) {
    return c;
  }
  c = c.children;
  for (var g = 0; g < c.length; g++) {
    var b = this.getCamera(a, c[g]);
    if (null !== b) {
      return b;
    }
  }
  return null;
};
Scene.prototype.addCamera = function(a) {
  -1 === this.cameras.indexOf(a) && (this.cameras.push(a), this.updateCameraOrder());
};
Scene.prototype.updateCameraOrder = function() {
  this.cameras.sort(function(a, c) {
    return a.order > c.order;
  });
};
Scene.prototype.removeCamera = function(a) {
  a = this.cameras.indexOf(a);
  -1 < a && this.cameras.splice(a, 1);
};
Scene.prototype.isCameraActive = function(a) {
  return -1 < this.cameras.indexOf(a);
};
Scene.prototype.setFogMode = function(a) {
  var c = null !== this.fog ? this.fog.color.getHex() : "#FFFFFF";
  a === THREE.Fog.LINEAR ? this.fog = new THREE.Fog(c, 5, 20) : a === THREE.Fog.EXPONENTIAL ? this.fog = new THREE.FogExp2(c, .01) : a === THREE.Fog.NONE && (this.fog = null);
};
Scene.prototype.toJSON = function(a) {
  if (null == this.parent || "Program" !== this.parent.type) {
    return console.warn("nunuStudio: Scene is not on top level serializing as Group."), this.type = "Group", THREE.Object3D.prototype.toJSON.call(this, a);
  }
  var c = this.background, g = THREE.Object3D.prototype.toJSON.call(this, a, function(a, b) {
    c instanceof THREE.Color ? c = c.toJSON(a) : c instanceof THREE.Texture && (c = c.toJSON(a).uuid);
  });
  null !== c && (g.object.background = c);
  if (null !== this.defaultCamera) {
    var b = new THREE.Vector3, e = new THREE.Quaternion, f = new THREE.Vector3;
    this.defaultCamera.matrixWorld.decompose(b, e, f);
    a = this.defaultCamera.toJSON(a);
    a.object.position = b.toArray();
    a.object.quaternion = e.toArray();
    a.object.scale = f.toArray();
    g.object.defaultCamera = a;
  }
  null !== this.fog && (g.object.fog = this.fog.toJSON());
  g.object.usePhysics = this.usePhysics;
  g.object.cameras = [];
  for (b = 0; b < this.cameras.length; b++) {
    g.object.cameras.push(this.cameras[b].uuid);
  }
  g.object.world = {};
  g.object.world.gravity = this.world.gravity;
  g.object.world.quatNormalizeSkip = this.world.quatNormalizeSkip;
  g.object.world.quatNormalizeFast = this.world.quatNormalizeFast;
  g.object.world.solver = {};
  g.object.world.solver.tolerance = this.world.solver.tolerance;
  g.object.world.solver.iterations = this.world.solver.iterations;
  return g;
};
"use strict";
function Base64Utils() {
}
Base64Utils.encoding = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
Base64Utils.isBase64 = function(a) {
  if ("string" !== typeof a) {
    return !1;
  }
  if (a.startsWith("data:")) {
    return !0;
  }
  for (var c = 0; c < a.length; c++) {
    if (!Base64Utils.encoding.includes(a.charAt(c))) {
      return !1;
    }
  }
  return !0;
};
Base64Utils.removeHeader = function(a) {
  return a.slice(a.search(";base64,") + 8);
};
Base64Utils.getFileFormat = function(a) {
  var c = a.indexOf("/") + 1, g = a.indexOf(";");
  return a.substr(c, g - c);
};
Base64Utils.fromArraybuffer = function(a) {
  var c = "";
  a = new Uint8Array(a);
  for (var g = a.byteLength % 3, b = a.byteLength - g, e, f, k, n, p = 0; p < b; p += 3) {
    n = a[p] << 16 | a[p + 1] << 8 | a[p + 2], e = (n & 16515072) >> 18, f = (n & 258048) >> 12, k = (n & 4032) >> 6, n &= 63, c += Base64Utils.encoding[e] + Base64Utils.encoding[f] + Base64Utils.encoding[k] + Base64Utils.encoding[n];
  }
  1 === g ? (n = a[b], c += Base64Utils.encoding[(n & 252) >> 2] + Base64Utils.encoding[(n & 3) << 4] + "==") : 2 === g && (n = a[b] << 8 | a[b + 1], c += Base64Utils.encoding[(n & 64512) >> 10] + Base64Utils.encoding[(n & 1008) >> 4] + Base64Utils.encoding[(n & 15) << 2] + "=");
  return c;
};
Base64Utils.fromBinaryString = function(a) {
  for (var c = "", g = a.length % 3, b = a.length - g, e, f, k, n = 0; n < b; n += 3) {
    e = a.charCodeAt(n) & 255, f = a.charCodeAt(n + 1), k = a.charCodeAt(n + 2), c += Base64Utils.encoding.charAt(e >> 2), c += Base64Utils.encoding.charAt((e & 3) << 4 | (f & 240) >> 4), c += Base64Utils.encoding.charAt((f & 15) << 2 | (k & 192) >> 6), c += Base64Utils.encoding.charAt(k & 63);
  }
  1 === g ? (e = a.charCodeAt(n) & 255, c += Base64Utils.encoding.charAt(e >> 2), c += Base64Utils.encoding.charAt((e & 3) << 4), c += "==") : 2 === g && (e = a.charCodeAt(n) & 255, f = a.charCodeAt(n + 1), c += Base64Utils.encoding.charAt(e >> 2), c += Base64Utils.encoding.charAt((e & 3) << 4 | (f & 240) >> 4), c += Base64Utils.encoding.charAt((f & 15) << 2), c += "=");
  return c;
};
"use strict";
function ArraybufferUtils() {
}
ArraybufferUtils.fromBinaryString = function(a) {
  for (var c = a.length, g = new ArrayBuffer(c), b = new Uint8Array(g), e = 0; e < c; e++) {
    b[e] = a.charCodeAt(e);
  }
  return g;
};
ArraybufferUtils.fromBase64 = function(a) {
  for (var c = a.length / 4 * 3, g = new ArrayBuffer(c), b = new Uint8Array(g), e, f, k, n, p = 0, m = 0; p < c; p += 3) {
    e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(m++)), f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(m++)), k = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(m++)), n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(m++)), b[p] = e << 2 | f >> 4, 64 !== k && (b[p + 1] = (f & 15) << 4 | k >> 2), 64 !== n && (b[p + 2] = (k & 3) << 6 | n);
  }
  return g;
};
ArraybufferUtils.fromBuffer = function(a) {
  for (var c = new ArrayBuffer(a.length), g = new Uint8Array(c), b = 0; b < a.length; b++) {
    g[b] = a[b];
  }
  return c;
};
"use strict";
function BufferUtils() {
}
BufferUtils.fromArrayBuffer = function(a) {
  var c = new Buffer(a.byteLength);
  a = new Uint8Array(a);
  for (var g = 0; g < c.length; g++) {
    c[g] = a[g];
  }
  return c;
};
"use strict";
function Timer(a, c) {
  this.callback = a;
  this.time = c;
  this.running = !1;
  this.id = -1;
}
Timer.prototype.start = function() {
  function a() {
    c.callback();
    c.running && (c.id = setTimeout(a, c.time));
  }
  if (!this.running) {
    this.running = !0;
    var c = this;
    a();
  }
};
Timer.prototype.stop = function() {
  this.running = !1;
  clearTimeout(self.id);
};
"use strict";
function AnimationTimer(a) {
  this.callback = a;
  this.running = !1;
  this.id = -1;
}
AnimationTimer.prototype.start = function() {
  function a() {
    c.callback();
    c.running && (c.id = requestAnimationFrame(a));
  }
  if (!this.running) {
    this.running = !0;
    var c = this;
    a();
  }
};
AnimationTimer.prototype.stop = function() {
  this.running = !1;
  cancelAnimationFrame(this.id);
};
"use strict";
function LocalStorage() {
}
LocalStorage.set = function(a, c) {
  "object" === typeof c ? window.localStorage.setItem(a, JSON.stringify(c)) : window.localStorage.setItem(a, c);
};
LocalStorage.get = function(a) {
  a = window.localStorage.getItem(a);
  try {
    return JSON.parse(a);
  } catch (c) {
    return a;
  }
};
LocalStorage.exists = function(a) {
  return null !== window.localStorage.getItem(a);
};
LocalStorage.delete = function(a) {
  return window.localStorage.removeItem(a);
};
"use strict";
function EventManager() {
  this.events = [];
}
EventManager.prototype.add = function(a, c, g) {
  this.events.push([a, c, g, !1]);
};
EventManager.prototype.clear = function() {
  this.destroy();
  this.events = [];
};
EventManager.prototype.create = function() {
  for (var a = 0; a < this.events.length; a++) {
    var c = this.events[a];
    c[0].addEventListener(c[1], c[2]);
    c[3] = !0;
  }
};
EventManager.prototype.destroy = function() {
  for (var a = 0; a < this.events.length; a++) {
    var c = this.events[a];
    c[0].removeEventListener(c[1], c[2]);
    c[3] = !1;
  }
};
EventManager.prototype.addScrollEvent = function(a, c) {
  void 0 !== window.onmousewheel ? this.add(a, "mousewheel", c) : void 0 !== window.addEventListener ? this.add(a, "DOMMouseScroll", function(a) {
    a.deltaY = 30 * a.detail;
    c(a);
  }) : this.add(a, "wheel", c);
};
"use strict";
function MathUtils() {
}
MathUtils.PI2 = 2 * Math.PI;
MathUtils.PID3 = Math.PI / 3;
MathUtils.PID2 = Math.PI / 2;
MathUtils.randomColor = function() {
  for (var a = "#", c = 0; 6 > c; c++) {
    a += "0123456789ABCDEF"[Math.floor(16 * Math.random())];
  }
  return a;
};
"use strict";
function ObjectUtils() {
}
ObjectUtils.getRoot = function(a) {
  for (; null !== a.parent;) {
    a = a.parent;
  }
  return a;
};
ObjectUtils.scaleAndCenterObject = function(a) {
  var c = ObjectUtils.calculateBoundingBox(a);
  if (null !== c) {
    var g = new THREE.Vector3;
    c.getSize(g);
    g = 1 / (g.x > g.y ? g.x > g.z ? g.x : g.z : g.y > g.z ? g.y : g.z);
    var b = new THREE.Vector3;
    c.getCenter(b);
    b.multiplyScalar(g);
    a.scale.set(g, g, g);
    a.position.set(-b.x, -g * c.min.y, -b.z);
  }
};
ObjectUtils.calculateBoundingBox = function(a) {
  var c = null;
  a.traverse(function(a) {
    void 0 !== a.geometry && (a.geometry.computeBoundingBox(), a = a.geometry.boundingBox, null === c ? c = a.clone() : (a.min.x < c.min.x && (c.min.x = a.min.x), a.max.x > c.max.x && (c.max.x = a.max.x), a.min.y < c.min.y && (c.min.y = a.min.y), a.max.y > c.max.y && (c.max.y = a.max.y), a.min.z < c.min.z && (c.min.z = a.min.z), a.max.z > c.max.z && (c.max.z = a.max.z)));
  });
  return c;
};
ObjectUtils.recalculateGeometryOrigin = function(a) {
  a.traverse(function(a) {
    if (void 0 !== a.geometry) {
      a.geometry.computeBoundingBox();
      var c = a.geometry.boundingBox.clone().getCenter(new THREE.Vector3);
      a.position.add(c);
      var b = new THREE.Matrix4;
      b.makeTranslation(-c.x, -c.y, -c.z);
      a.geometry.applyMatrix(b);
    }
  });
};
ObjectUtils.convertToBufferGeometry = function(a) {
  a.traverse(function(a) {
    void 0 !== a.geometry && !0 === a.geometry.isGeometry && (a.geometry = (new THREE.BufferGeometry).fromGeometry(a.geometry));
  });
};
"use strict";
function PhysicsGenerator() {
}
PhysicsGenerator.Type = {BOX:"Box", CYLINDER:"Cylinder", SPHERE:"Sphere", HULL:"ConvexPolyhedron"};
PhysicsGenerator.createShape = function(a, c) {
  if (void 0 !== c) {
    return c === PhysicsGenerator.Type.BOX ? PhysicsGenerator.createBoundingBoxShape(a) : c === PhysicsGenerator.Type.CYLINDER ? PhysicsGenerator.createBoundingCylinderShape(a) : c === PhysicsGenerator.Type.SPHERE ? PhysicsGenerator.createBoundingSphereShape(a) : c === PhysicsGenerator.Type.HULL ? PhysicsGenerator.createConvexPolyhedron(a) : null;
  }
  c = PhysicsGenerator.getGeometry(a);
  if (!c) {
    return null;
  }
  switch(c.type) {
    case "BoxGeometry":
    case "BoxBufferGeometry":
      return PhysicsGenerator.createBoxShape(c);
    case "CylinderGeometry":
    case "CylinderBufferGeometry":
      return PhysicsGenerator.createCylinderShape(c);
    case "PlaneGeometry":
    case "PlaneBufferGeometry":
      return PhysicsGenerator.createPlaneShape(c);
    case "SphereGeometry":
    case "SphereBufferGeometry":
      return PhysicsGenerator.createSphereShape(c);
    case "TubeGeometry":
      return PhysicsGenerator.createTubeShape(c);
    case "Geometry":
    case "BufferGeometry":
      return PhysicsGenerator.createConvexPolyhedron(a);
    default:
      return PhysicsGenerator.createBoxShape(c);
  }
};
PhysicsGenerator.createBoxShape = function(a) {
  if (!PhysicsGenerator.getVertices(a).length) {
    return null;
  }
  a.computeBoundingBox();
  a = a.boundingBox;
  return new CANNON.Box(new CANNON.Vec3((a.max.x - a.min.x) / 2, (a.max.y - a.min.y) / 2, (a.max.z - a.min.z) / 2));
};
PhysicsGenerator.createBoundingBoxShape = function(a) {
  var c = new Box3;
  c.setFromObject(a);
  if (!isFinite(c.min.lengthSq())) {
    return null;
  }
  c = new CANNON.Box(new CANNON.Vec3((c.max.x - c.min.x) / 2, (c.max.y - c.min.y) / 2, (c.max.z - c.min.z) / 2));
  a.updateMatrixWorld();
  (new THREE.Vector3).setFromMatrixPosition(a.matrixWorld);
  return c;
};
PhysicsGenerator.createConvexPolyhedron = function(a) {
  var c = new THREE.QuickHull;
  c.setFromObject(a);
  a = [];
  for (var g = [], b = [], e = 0; e < c.faces.length; e++) {
    var f = c.faces[e], k = f.edge;
    do {
      var n = k.head().point;
      a.push(new CANNON.Vec3(n.x, n.y, n.z));
      k = k.next;
    } while (k !== f.edge);
    g.push([a.length - 3, a.length - 2, a.length - 1]);
    b.push(new CANNON.Vec3(f.normal.x, f.normal.y, f.normal.z));
  }
  return new CANNON.ConvexPolyhedron(a, g, b);
};
PhysicsGenerator.createCylinderShape = function(a) {
  a = a.parameters;
  a = new CANNON.Cylinder(a.radiusTop, a.radiusBottom, a.height, a.radialSegments);
  a.orientation = new CANNON.Quaternion;
  a.orientation.setFromEuler(0, 0, 0, "XYZ").normalize();
  return a;
};
PhysicsGenerator.createBoundingCylinderShape = function(a) {
  var c = ["x", "y", "z"];
  c = c.splice(c.indexOf("y"), 1) && c;
  a = PhysicsGenerator.getGeometry(a);
  a.computeBoundingBox();
  a.computeBoundingSphere();
  c = .5 * Math.max(a.boundingBox.max[c[0]] - a.boundingBox.min[c[0]], a.boundingBox.max[c[1]] - a.boundingBox.min[c[1]]);
  a = new CANNON.Cylinder(c, c, a.boundingBox.max.y - a.boundingBox.min.y, 12);
  a.orientation = new CANNON.Quaternion;
  a.orientation.setFromEuler(Math.PI / 2, 0, 0, "XYZ").normalize();
  return a;
};
PhysicsGenerator.createPlaneShape = function(a) {
  a.computeBoundingBox();
  a = a.boundingBox;
  return new CANNON.Box(new CANNON.Vec3((a.max.x - a.min.x) / 2, (a.max.y - a.min.y) / 2, (a.max.z - a.min.z) / 2));
};
PhysicsGenerator.createSphereShape = function(a) {
  return new CANNON.Sphere(a.parameters.radius);
};
PhysicsGenerator.createBoundingSphereShape = function(a) {
  a = PhysicsGenerator.getGeometry(a);
  a.computeBoundingSphere();
  return new CANNON.Sphere(a.boundingSphere.radius);
};
PhysicsGenerator.createTubeShape = function(a) {
  var c = new THREE.BufferGeometry;
  c.fromGeometry(a);
  return createTrimeshShape(c);
};
PhysicsGenerator.createTrimeshShape = function(a) {
  var c = PhysicsGenerator.getVertices(a);
  if (!c.length) {
    return null;
  }
  a = Object.keys(c).map(Number);
  return new CANNON.Trimesh(c, a);
};
PhysicsGenerator.getGeometry = function(a) {
  var c = PhysicsGenerator.getMeshes(a);
  if (0 === c.length) {
    return null;
  }
  var g = new THREE.Geometry;
  if (1 === c.length) {
    a = new THREE.Vector3;
    var b = new THREE.Quaternion, e = new THREE.Vector3(1, 1, 1);
    g = c[0].geometry.clone();
    c[0].updateMatrixWorld();
    c[0].matrixWorld.decompose(a, b, e);
    return g.scale(e.x, e.y, e.z);
  }
  for (b = new THREE.Geometry; e = c.pop();) {
    e.updateMatrixWorld(), e.geometry instanceof THREE.BufferGeometry ? (g.fromBufferGeometry(e.geometry), b.merge(g, e.matrixWorld)) : b.merge(e.geometry, e.matrixWorld);
  }
  c = new THREE.Matrix4;
  c.scale(a.scale);
  b.applyMatrix(c);
  return b;
};
PhysicsGenerator.getVertices = function(a) {
  a.attributes || (a = (new THREE.BufferGeometry).fromGeometry(a));
  return a.attributes.position.array;
};
PhysicsGenerator.getMeshes = function(a) {
  var c = [];
  a.traverse(function(a) {
    a instanceof THREE.Mesh && c.push(a);
  });
  return c;
};

