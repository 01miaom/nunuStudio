function Nunu() {
}
Nunu.NAME = "nunuStudio";
Nunu.VERSION = "V0.8.9.12 Alpha";
Nunu.TIMESTAMP = "201611271907";
(function(a, f) {
	"object" === typeof exports && "undefined" !== typeof module ? f(exports) : "function" === typeof define && define.amd ? define(["exports"], f) : f(a.THREE = a.THREE || {});
})(this, function(a) {
	function f() {
	}
	function l(d, n) {
		this.x = d || 0;
		this.y = n || 0;
	}
	function b(d, n, a, c, g, e, m, h, k, q) {
		Object.defineProperty(this, "id", {value:Me++});
		this.uuid = da.generateUUID();
		this.name = "";
		this.image = void 0 !== d ? d : b.DEFAULT_IMAGE;
		this.mipmaps = [];
		this.mapping = void 0 !== n ? n : b.DEFAULT_MAPPING;
		this.wrapS = void 0 !== a ? a : 1001;
		this.wrapT = void 0 !== c ? c : 1001;
		this.magFilter = void 0 !== g ? g : 1006;
		this.minFilter = void 0 !== e ? e : 1008;
		this.anisotropy = void 0 !== k ? k : 1;
		this.format = void 0 !== m ? m : 1023;
		this.type = void 0 !== h ? h : 1009;
		this.offset = new l(0, 0);
		this.repeat = new l(1, 1);
		this.generateMipmaps = !0;
		this.premultiplyAlpha = !1;
		this.flipY = !0;
		this.unpackAlignment = 4;
		this.encoding = void 0 !== q ? q : 3E3;
		this.version = 0;
		this.onUpdate = null;
	}
	function k(d, n, a, b) {
		this.x = d || 0;
		this.y = n || 0;
		this.z = a || 0;
		this.w = void 0 !== b ? b : 1;
	}
	function h(d, n, a) {
		this.uuid = da.generateUUID();
		this.width = d;
		this.height = n;
		this.scissor = new k(0, 0, d, n);
		this.scissorTest = !1;
		this.viewport = new k(0, 0, d, n);
		a = a || {};
		void 0 === a.minFilter && (a.minFilter = 1006);
		this.texture = new b(void 0, void 0, a.wrapS, a.wrapT, a.magFilter, a.minFilter, a.format, a.type, a.anisotropy, a.encoding);
		this.depthBuffer = void 0 !== a.depthBuffer ? a.depthBuffer : !0;
		this.stencilBuffer = void 0 !== a.stencilBuffer ? a.stencilBuffer : !0;
		this.depthTexture = void 0 !== a.depthTexture ? a.depthTexture : null;
	}
	function c(d, n, a) {
		h.call(this, d, n, a);
		this.activeMipMapLevel = this.activeCubeFace = 0;
	}
	function e(d, n, a, b) {
		this._x = d || 0;
		this._y = n || 0;
		this._z = a || 0;
		this._w = void 0 !== b ? b : 1;
	}
	function g(d, n, a) {
		this.x = d || 0;
		this.y = n || 0;
		this.z = a || 0;
	}
	function q() {
		this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
		0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
	}
	function r(d, n, a, c, g, e, m, h, k, q) {
		d = void 0 !== d ? d : [];
		b.call(this, d, void 0 !== n ? n : 301, a, c, g, e, m, h, k, q);
		this.flipY = !1;
	}
	function w(d, n, a) {
		var z = d[0];
		if (0 >= z || 0 < z) {
			return d;
		}
		var b = n * a, c = ye[b];
		void 0 === c && (c = new Float32Array(b), ye[b] = c);
		if (0 !== n) {
			for (z.toArray(c, 0), z = 1, b = 0;z !== n;++z) {
				b += a, d[z].toArray(c, b);
			}
		}
		return c;
	}
	function p(d, n) {
		var a = ze[n];
		void 0 === a && (a = new Int32Array(n), ze[n] = a);
		for (var b = 0;b !== n;++b) {
			a[b] = d.allocTextureUnit();
		}
		return a;
	}
	function t(d, n) {
		d.uniform1f(this.addr, n);
	}
	function v(d, n) {
		d.uniform1i(this.addr, n);
	}
	function y(d, n) {
		void 0 === n.x ? d.uniform2fv(this.addr, n) : d.uniform2f(this.addr, n.x, n.y);
	}
	function x(d, n) {
		void 0 !== n.x ? d.uniform3f(this.addr, n.x, n.y, n.z) : void 0 !== n.r ? d.uniform3f(this.addr, n.r, n.g, n.b) : d.uniform3fv(this.addr, n);
	}
	function m(d, n) {
		void 0 === n.x ? d.uniform4fv(this.addr, n) : d.uniform4f(this.addr, n.x, n.y, n.z, n.w);
	}
	function u(d, n) {
		d.uniformMatrix2fv(this.addr, !1, n.elements || n);
	}
	function B(d, n) {
		d.uniformMatrix3fv(this.addr, !1, n.elements || n);
	}
	function A(d, n) {
		d.uniformMatrix4fv(this.addr, !1, n.elements || n);
	}
	function D(d, n, a) {
		var z = a.allocTextureUnit();
		d.uniform1i(this.addr, z);
		a.setTexture2D(n || Ae, z);
	}
	function G(d, n, a) {
		var z = a.allocTextureUnit();
		d.uniform1i(this.addr, z);
		a.setTextureCube(n || Be, z);
	}
	function F(d, n) {
		d.uniform2iv(this.addr, n);
	}
	function C(d, n) {
		d.uniform3iv(this.addr, n);
	}
	function J(d, n) {
		d.uniform4iv(this.addr, n);
	}
	function I(d) {
		switch(d) {
			case 5126:
				return t;
			case 35664:
				return y;
			case 35665:
				return x;
			case 35666:
				return m;
			case 35674:
				return u;
			case 35675:
				return B;
			case 35676:
				return A;
			case 35678:
				return D;
			case 35680:
				return G;
			case 5124:
			;
			case 35670:
				return v;
			case 35667:
			;
			case 35671:
				return F;
			case 35668:
			;
			case 35672:
				return C;
			case 35669:
			;
			case 35673:
				return J;
		}
	}
	function Q(d, n) {
		d.uniform1fv(this.addr, n);
	}
	function M(d, n) {
		d.uniform1iv(this.addr, n);
	}
	function N(d, n) {
		d.uniform2fv(this.addr, w(n, this.size, 2));
	}
	function R(d, n) {
		d.uniform3fv(this.addr, w(n, this.size, 3));
	}
	function H(d, n) {
		d.uniform4fv(this.addr, w(n, this.size, 4));
	}
	function ba(d, n) {
		d.uniformMatrix2fv(this.addr, !1, w(n, this.size, 4));
	}
	function ha(d, n) {
		d.uniformMatrix3fv(this.addr, !1, w(n, this.size, 9));
	}
	function Y(d, n) {
		d.uniformMatrix4fv(this.addr, !1, w(n, this.size, 16));
	}
	function ga(d, n, a) {
		var z = n.length, b = p(a, z);
		d.uniform1iv(this.addr, b);
		for (d = 0;d !== z;++d) {
			a.setTexture2D(n[d] || Ae, b[d]);
		}
	}
	function S(d, n, a) {
		var z = n.length, b = p(a, z);
		d.uniform1iv(this.addr, b);
		for (d = 0;d !== z;++d) {
			a.setTextureCube(n[d] || Be, b[d]);
		}
	}
	function V(d) {
		switch(d) {
			case 5126:
				return Q;
			case 35664:
				return N;
			case 35665:
				return R;
			case 35666:
				return H;
			case 35674:
				return ba;
			case 35675:
				return ha;
			case 35676:
				return Y;
			case 35678:
				return ga;
			case 35680:
				return S;
			case 5124:
			;
			case 35670:
				return M;
			case 35667:
			;
			case 35671:
				return F;
			case 35668:
			;
			case 35672:
				return C;
			case 35669:
			;
			case 35673:
				return J;
		}
	}
	function L(d, n, a) {
		this.id = d;
		this.addr = a;
		this.setValue = I(n.type);
	}
	function W(d, n, a) {
		this.id = d;
		this.addr = a;
		this.size = n.size;
		this.setValue = V(n.type);
	}
	function ia(d) {
		this.id = d;
		this.seq = [];
		this.map = {};
	}
	function va(d, n, a) {
		this.seq = [];
		this.map = {};
		this.renderer = a;
		a = d.getProgramParameter(n, d.ACTIVE_UNIFORMS);
		for (var z = 0;z !== a;++z) {
			var b = d.getActiveUniform(n, z), c = d.getUniformLocation(n, b.name), g = this, e = b.name, m = e.length;
			for (Ud.lastIndex = 0;;) {
				var h = Ud.exec(e), k = Ud.lastIndex, q = h[1], f = h[3];
				"]" === h[2] && (q |= 0);
				if (void 0 === f || "[" === f && k + 2 === m) {
					e = g;
					b = void 0 === f ? new L(q, b, c) : new W(q, b, c);
					e.seq.push(b);
					e.map[b.id] = b;
					break;
				} else {
					f = g.map[q], void 0 === f && (f = new ia(q), q = g, g = f, q.seq.push(g), q.map[g.id] = g), g = f;
				}
			}
		}
	}
	function T(d, n, a) {
		return void 0 === n && void 0 === a ? this.set(d) : this.setRGB(d, n, a);
	}
	function pa(d, n, a, c, g, e, m, h, k, q, f, r) {
		b.call(this, null, e, m, h, k, q, c, g, f, r);
		this.image = {data:d, width:n, height:a};
		this.magFilter = void 0 !== k ? k : 1003;
		this.minFilter = void 0 !== q ? q : 1003;
		this.flipY = this.generateMipmaps = !1;
		this.unpackAlignment = 1;
	}
	function ra(d, n) {
		this.min = void 0 !== d ? d : new l(Infinity, Infinity);
		this.max = void 0 !== n ? n : new l(-Infinity, -Infinity);
	}
	function qa(d, n) {
		var a, b, c, e, m, h, k, q, f, r, p = d.context, u = d.state, w, t, v, B, y;
		this.render = function(z, E, P) {
			if (0 !== n.length) {
				z = new g;
				var aa = P.w / P.z, fa = .5 * P.z, O = .5 * P.w, x = 16 / P.w, Fa = new l(x * aa, x), C = new g(1, 1, 0), A = new l(1, 1), G = new ra;
				G.min.set(P.x, P.y);
				G.max.set(P.x + (P.z - 16), P.y + (P.w - 16));
				if (void 0 === v) {
					var x = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]), Ya = new Uint16Array([0, 1, 2, 0, 2, 3]);
					w = p.createBuffer();
					t = p.createBuffer();
					p.bindBuffer(p.ARRAY_BUFFER, w);
					p.bufferData(p.ARRAY_BUFFER, x, p.STATIC_DRAW);
					p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, t);
					p.bufferData(p.ELEMENT_ARRAY_BUFFER, Ya, p.STATIC_DRAW);
					B = p.createTexture();
					y = p.createTexture();
					u.bindTexture(p.TEXTURE_2D, B);
					p.texImage2D(p.TEXTURE_2D, 0, p.RGB, 16, 16, 0, p.RGB, p.UNSIGNED_BYTE, null);
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE);
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE);
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.NEAREST);
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.NEAREST);
					u.bindTexture(p.TEXTURE_2D, y);
					p.texImage2D(p.TEXTURE_2D, 0, p.RGBA, 16, 16, 0, p.RGBA, p.UNSIGNED_BYTE, null);
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE);
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE);
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.NEAREST);
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.NEAREST);
					var x = {vertexShader:"uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}", 
					fragmentShader:"uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"}, Ya = p.createProgram(), F = 
					p.createShader(p.FRAGMENT_SHADER), L = p.createShader(p.VERTEX_SHADER), D = "precision " + d.getPrecision() + " float;\n";
					p.shaderSource(F, D + x.fragmentShader);
					p.shaderSource(L, D + x.vertexShader);
					p.compileShader(F);
					p.compileShader(L);
					p.attachShader(Ya, F);
					p.attachShader(Ya, L);
					p.linkProgram(Ya);
					v = Ya;
					f = p.getAttribLocation(v, "position");
					r = p.getAttribLocation(v, "uv");
					a = p.getUniformLocation(v, "renderType");
					b = p.getUniformLocation(v, "map");
					c = p.getUniformLocation(v, "occlusionMap");
					e = p.getUniformLocation(v, "opacity");
					m = p.getUniformLocation(v, "color");
					h = p.getUniformLocation(v, "scale");
					k = p.getUniformLocation(v, "rotation");
					q = p.getUniformLocation(v, "screenPosition");
				}
				p.useProgram(v);
				u.initAttributes();
				u.enableAttribute(f);
				u.enableAttribute(r);
				u.disableUnusedAttributes();
				p.uniform1i(c, 0);
				p.uniform1i(b, 1);
				p.bindBuffer(p.ARRAY_BUFFER, w);
				p.vertexAttribPointer(f, 2, p.FLOAT, !1, 16, 0);
				p.vertexAttribPointer(r, 2, p.FLOAT, !1, 16, 8);
				p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, t);
				u.disable(p.CULL_FACE);
				u.setDepthWrite(!1);
				Ya = 0;
				for (F = n.length;Ya < F;Ya++) {
					if (x = 16 / P.w, Fa.set(x * aa, x), L = n[Ya], z.set(L.matrixWorld.elements[12], L.matrixWorld.elements[13], L.matrixWorld.elements[14]), z.applyMatrix4(E.matrixWorldInverse), z.applyProjection(E.projectionMatrix), C.copy(z), A.x = P.x + C.x * fa + fa - 8, A.y = P.y + C.y * O + O - 8, !0 === G.containsPoint(A)) {
						u.activeTexture(p.TEXTURE0);
						u.bindTexture(p.TEXTURE_2D, null);
						u.activeTexture(p.TEXTURE1);
						u.bindTexture(p.TEXTURE_2D, B);
						p.copyTexImage2D(p.TEXTURE_2D, 0, p.RGB, A.x, A.y, 16, 16, 0);
						p.uniform1i(a, 0);
						p.uniform2f(h, Fa.x, Fa.y);
						p.uniform3f(q, C.x, C.y, C.z);
						u.disable(p.BLEND);
						u.enable(p.DEPTH_TEST);
						p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0);
						u.activeTexture(p.TEXTURE0);
						u.bindTexture(p.TEXTURE_2D, y);
						p.copyTexImage2D(p.TEXTURE_2D, 0, p.RGBA, A.x, A.y, 16, 16, 0);
						p.uniform1i(a, 1);
						u.disable(p.DEPTH_TEST);
						u.activeTexture(p.TEXTURE1);
						u.bindTexture(p.TEXTURE_2D, B);
						p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0);
						L.positionScreen.copy(C);
						L.customUpdateCallback ? L.customUpdateCallback(L) : L.updateLensFlares();
						p.uniform1i(a, 2);
						u.enable(p.BLEND);
						for (var D = 0, qd = L.lensFlares.length;D < qd;D++) {
							var Ga = L.lensFlares[D];
							.001 < Ga.opacity && .001 < Ga.scale && (C.x = Ga.x, C.y = Ga.y, C.z = Ga.z, x = Ga.size * Ga.scale / P.w, Fa.x = x * aa, Fa.y = x, p.uniform3f(q, C.x, C.y, C.z), p.uniform2f(h, Fa.x, Fa.y), p.uniform1f(k, Ga.rotation), p.uniform1f(e, Ga.opacity), p.uniform3f(m, Ga.color.r, Ga.color.g, Ga.color.b), u.setBlending(Ga.blending, Ga.blendEquation, Ga.blendSrc, Ga.blendDst), d.setTexture2D(Ga.texture, 1), p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0));
						}
					}
				}
				u.enable(p.CULL_FACE);
				u.enable(p.DEPTH_TEST);
				u.setDepthWrite(!0);
				d.resetGLState();
			}
		};
	}
	function ea(d, n) {
		function a(d, n) {
			return d.renderOrder !== n.renderOrder ? d.renderOrder - n.renderOrder : d.z !== n.z ? n.z - d.z : n.id - d.id;
		}
		var c, m, h, k, q, f, p, r, u, l, w, t, v, B, y, x, C, A = d.context, G = d.state, L, F, D, W, J = new g, I = new e, Y = new g;
		this.render = function(z, g) {
			if (0 !== n.length) {
				if (void 0 === D) {
					var E = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]), e = new Uint16Array([0, 1, 2, 0, 2, 3]);
					L = A.createBuffer();
					F = A.createBuffer();
					A.bindBuffer(A.ARRAY_BUFFER, L);
					A.bufferData(A.ARRAY_BUFFER, E, A.STATIC_DRAW);
					A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, F);
					A.bufferData(A.ELEMENT_ARRAY_BUFFER, e, A.STATIC_DRAW);
					var E = A.createProgram(), e = A.createShader(A.VERTEX_SHADER), P = A.createShader(A.FRAGMENT_SHADER);
					A.shaderSource(e, ["precision " + d.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n"));
					A.shaderSource(P, ["precision " + d.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n"));
					A.compileShader(e);
					A.compileShader(P);
					A.attachShader(E, e);
					A.attachShader(E, P);
					A.linkProgram(E);
					D = E;
					x = A.getAttribLocation(D, "position");
					C = A.getAttribLocation(D, "uv");
					c = A.getUniformLocation(D, "uvOffset");
					m = A.getUniformLocation(D, "uvScale");
					h = A.getUniformLocation(D, "rotation");
					k = A.getUniformLocation(D, "scale");
					q = A.getUniformLocation(D, "color");
					f = A.getUniformLocation(D, "map");
					p = A.getUniformLocation(D, "opacity");
					r = A.getUniformLocation(D, "modelViewMatrix");
					u = A.getUniformLocation(D, "projectionMatrix");
					l = A.getUniformLocation(D, "fogType");
					w = A.getUniformLocation(D, "fogDensity");
					t = A.getUniformLocation(D, "fogNear");
					v = A.getUniformLocation(D, "fogFar");
					B = A.getUniformLocation(D, "fogColor");
					y = A.getUniformLocation(D, "alphaTest");
					E = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
					E.width = 8;
					E.height = 8;
					e = E.getContext("2d");
					e.fillStyle = "white";
					e.fillRect(0, 0, 8, 8);
					W = new b(E);
					W.needsUpdate = !0;
				}
				A.useProgram(D);
				G.initAttributes();
				G.enableAttribute(x);
				G.enableAttribute(C);
				G.disableUnusedAttributes();
				G.disable(A.CULL_FACE);
				G.enable(A.BLEND);
				A.bindBuffer(A.ARRAY_BUFFER, L);
				A.vertexAttribPointer(x, 2, A.FLOAT, !1, 16, 0);
				A.vertexAttribPointer(C, 2, A.FLOAT, !1, 16, 8);
				A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, F);
				A.uniformMatrix4fv(u, !1, g.projectionMatrix.elements);
				G.activeTexture(A.TEXTURE0);
				A.uniform1i(f, 0);
				e = E = 0;
				(P = z.fog) ? (A.uniform3f(B, P.color.r, P.color.g, P.color.b), P.isFog ? (A.uniform1f(t, P.near), A.uniform1f(v, P.far), A.uniform1i(l, 1), e = E = 1) : P.isFogExp2 && (A.uniform1f(w, P.density), A.uniform1i(l, 2), e = E = 2)) : (A.uniform1i(l, 0), e = E = 0);
				for (var P = 0, aa = n.length;P < aa;P++) {
					var fa = n[P];
					fa.modelViewMatrix.multiplyMatrices(g.matrixWorldInverse, fa.matrixWorld);
					fa.z = -fa.modelViewMatrix.elements[14];
				}
				n.sort(a);
				g = [];
				P = 0;
				for (aa = n.length;P < aa;P++) {
					var fa = n[P], O = fa.material;
					!1 !== O.visible && (A.uniform1f(y, O.alphaTest), A.uniformMatrix4fv(r, !1, fa.modelViewMatrix.elements), fa.matrixWorld.decompose(J, I, Y), g[0] = Y.x, g[1] = Y.y, fa = 0, z.fog && O.fog && (fa = e), E !== fa && (A.uniform1i(l, fa), E = fa), null !== O.map ? (A.uniform2f(c, O.map.offset.x, O.map.offset.y), A.uniform2f(m, O.map.repeat.x, O.map.repeat.y)) : (A.uniform2f(c, 0, 0), A.uniform2f(m, 1, 1)), A.uniform1f(p, O.opacity), A.uniform3f(q, O.color.r, O.color.g, O.color.b), A.uniform1f(h, 
					O.rotation), A.uniform2fv(k, g), G.setBlending(O.blending, O.blendEquation, O.blendSrc, O.blendDst), G.setDepthTest(O.depthTest), G.setDepthWrite(O.depthWrite), O.map ? d.setTexture2D(O.map, 0) : d.setTexture2D(W, 0), A.drawElements(A.TRIANGLES, 6, A.UNSIGNED_SHORT, 0));
				}
				G.enable(A.CULL_FACE);
				d.resetGLState();
			}
		};
	}
	function Z() {
		Object.defineProperty(this, "id", {value:Oe++});
		this.uuid = da.generateUUID();
		this.name = "";
		this.type = "Material";
		this.lights = this.fog = !0;
		this.blending = 1;
		this.side = 0;
		this.shading = 2;
		this.vertexColors = 0;
		this.opacity = 1;
		this.transparent = !1;
		this.blendSrc = 204;
		this.blendDst = 205;
		this.blendEquation = 100;
		this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
		this.depthFunc = 3;
		this.depthWrite = this.depthTest = !0;
		this.clippingPlanes = null;
		this.clipShadows = this.clipIntersection = !1;
		this.colorWrite = !0;
		this.precision = null;
		this.polygonOffset = !1;
		this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
		this.premultipliedAlpha = !1;
		this.overdraw = 0;
		this._needsUpdate = this.visible = !0;
	}
	function ua(d) {
		Z.call(this);
		this.type = "ShaderMaterial";
		this.defines = {};
		this.uniforms = {};
		this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
		this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
		this.linewidth = 1;
		this.wireframe = !1;
		this.wireframeLinewidth = 1;
		this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1;
		this.extensions = {derivatives:!1, fragDepth:!1, drawBuffers:!1, shaderTextureLOD:!1};
		this.defaultAttributeValues = {color:[1, 1, 1], uv:[0, 0], uv2:[0, 0]};
		this.index0AttributeName = void 0;
		void 0 !== d && (void 0 !== d.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(d));
	}
	function sa(d) {
		Z.call(this);
		this.type = "MeshDepthMaterial";
		this.depthPacking = 3200;
		this.morphTargets = this.skinning = !1;
		this.displacementMap = this.alphaMap = this.map = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.wireframe = !1;
		this.wireframeLinewidth = 1;
		this.lights = this.fog = !1;
		this.setValues(d);
	}
	function Ba(d, n) {
		this.min = void 0 !== d ? d : new g(Infinity, Infinity, Infinity);
		this.max = void 0 !== n ? n : new g(-Infinity, -Infinity, -Infinity);
	}
	function Ca(d, n) {
		this.center = void 0 !== d ? d : new g;
		this.radius = void 0 !== n ? n : 0;
	}
	function ya() {
		this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
		0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
	}
	function wa(d, n) {
		this.normal = void 0 !== d ? d : new g(1, 0, 0);
		this.constant = void 0 !== n ? n : 0;
	}
	function Sa(d, n, a, b, c, g) {
		this.planes = [void 0 !== d ? d : new wa, void 0 !== n ? n : new wa, void 0 !== a ? a : new wa, void 0 !== b ? b : new wa, void 0 !== c ? c : new wa, void 0 !== g ? g : new wa];
	}
	function rd(d, n, a, b) {
		function z(n, a, z, b) {
			var c = n.geometry, g;
			g = B;
			var E = n.customDepthMaterial;
			z && (g = y, E = n.customDistanceMaterial);
			E ? g = E : (E = !1, a.morphTargets && (c && c.isBufferGeometry ? E = c.morphAttributes && c.morphAttributes.position && 0 < c.morphAttributes.position.length : c && c.isGeometry && (E = c.morphTargets && 0 < c.morphTargets.length)), n = n.isSkinnedMesh && a.skinning, c = 0, E && (c |= 1), n && (c |= 2), g = g[c]);
			d.localClippingEnabled && !0 === a.clipShadows && 0 !== a.clippingPlanes.length && (c = g.uuid, E = a.uuid, n = A[c], void 0 === n && (n = {}, A[c] = n), c = n[E], void 0 === c && (c = g.clone(), n[E] = c), g = c);
			g.visible = a.visible;
			g.wireframe = a.wireframe;
			E = a.side;
			I.renderSingleSided && 2 == E && (E = 0);
			I.renderReverseSided && (0 === E ? E = 1 : 1 === E && (E = 0));
			g.side = E;
			g.clipShadows = a.clipShadows;
			g.clippingPlanes = a.clippingPlanes;
			g.wireframeLinewidth = a.wireframeLinewidth;
			g.linewidth = a.linewidth;
			z && void 0 !== g.uniforms.lightPos && g.uniforms.lightPos.value.copy(b);
			return g;
		}
		function c(d, n, a) {
			if (!1 !== d.visible) {
				0 !== (d.layers.mask & n.layers.mask) && (d.isMesh || d.isLine || d.isPoints) && d.castShadow && (!1 === d.frustumCulled || !0 === m.intersectsObject(d)) && !0 === d.material.visible && (d.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, d.matrixWorld), v.push(d));
				d = d.children;
				for (var z = 0, b = d.length;z < b;z++) {
					c(d[z], n, a);
				}
			}
		}
		var E = d.context, e = d.state, m = new Sa, f = new q, p = n.shadows, r = new l, u = new l(b.maxTextureSize, b.maxTextureSize), w = new g, t = new g, v = [], B = Array(4), y = Array(4), A = {}, x = [new g(1, 0, 0), new g(-1, 0, 0), new g(0, 0, 1), new g(0, 0, -1), new g(0, 1, 0), new g(0, -1, 0)], C = [new g(0, 1, 0), new g(0, 1, 0), new g(0, 1, 0), new g(0, 1, 0), new g(0, 0, 1), new g(0, 0, -1)], G = [new k, new k, new k, new k, new k, new k];
		n = new sa;
		n.depthPacking = 3201;
		n.clipping = !0;
		b = Wb.distanceRGBA;
		for (var L = Object.assign({}, b.uniforms), F = 0;4 !== F;++F) {
			var D = 0 !== (F & 1), W = 0 !== (F & 2), J = n.clone();
			J.morphTargets = D;
			J.skinning = W;
			B[F] = J;
			D = new ua({defines:{USE_SHADOWMAP:""}, uniforms:L, vertexShader:b.vertexShader, fragmentShader:b.fragmentShader, morphTargets:D, skinning:W, clipping:!0});
			y[F] = D;
		}
		var I = this;
		this.enabled = !1;
		this.autoUpdate = !0;
		this.needsUpdate = !1;
		this.type = 1;
		this.renderSingleSided = this.renderReverseSided = !0;
		this.render = function(n, b) {
			if (!1 !== I.enabled && (!1 !== I.autoUpdate || !1 !== I.needsUpdate) && 0 !== p.length) {
				e.buffers.color.setClear(1, 1, 1, 1);
				e.disable(E.BLEND);
				e.setDepthTest(!0);
				e.setScissorTest(!1);
				for (var g, k, q = 0, P = p.length;q < P;q++) {
					var l = p[q], aa = l.shadow;
					if (void 0 === aa) {
						console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
					} else {
						var fa = aa.camera;
						r.copy(aa.mapSize);
						r.min(u);
						if (l && l.isPointLight) {
							g = 6;
							k = !0;
							var O = r.x, B = r.y;
							G[0].set(2 * O, B, O, B);
							G[1].set(0, B, O, B);
							G[2].set(3 * O, B, O, B);
							G[3].set(O, B, O, B);
							G[4].set(3 * O, 0, O, B);
							G[5].set(O, 0, O, B);
							r.x *= 4;
							r.y *= 2;
						} else {
							g = 1, k = !1;
						}
						null === aa.map && (aa.map = new h(r.x, r.y, {minFilter:1003, magFilter:1003, format:1023}), fa.updateProjectionMatrix());
						aa.isSpotLightShadow && aa.update(l);
						aa && aa.isRectAreaLightShadow && aa.update(l);
						O = aa.map;
						aa = aa.matrix;
						t.setFromMatrixPosition(l.matrixWorld);
						fa.position.copy(t);
						d.setRenderTarget(O);
						d.clear();
						for (O = 0;O < g;O++) {
							k ? (w.copy(fa.position), w.add(x[O]), fa.up.copy(C[O]), fa.lookAt(w), e.viewport(G[O])) : (w.setFromMatrixPosition(l.target.matrixWorld), fa.lookAt(w));
							fa.updateMatrixWorld();
							fa.matrixWorldInverse.getInverse(fa.matrixWorld);
							aa.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
							aa.multiply(fa.projectionMatrix);
							aa.multiply(fa.matrixWorldInverse);
							f.multiplyMatrices(fa.projectionMatrix, fa.matrixWorldInverse);
							m.setFromMatrix(f);
							v.length = 0;
							c(n, b, fa);
							for (var B = 0, y = v.length;B < y;B++) {
								var A = v[B], Fa = a.update(A), F = A.material;
								if (F && F.isMultiMaterial) {
									for (var Ya = Fa.groups, F = F.materials, L = 0, D = Ya.length;L < D;L++) {
										var qd = Ya[L], Ga = F[qd.materialIndex];
										!0 === Ga.visible && (Ga = z(A, Ga, k, t), d.renderBufferDirect(fa, null, Fa, Ga, A, qd));
									}
								} else {
									Ga = z(A, F, k, t), d.renderBufferDirect(fa, null, Fa, Ga, A, null);
								}
							}
						}
					}
				}
				g = d.getClearColor();
				k = d.getClearAlpha();
				d.setClearColor(g, k);
				I.needsUpdate = !1;
			}
		};
	}
	function jb(d, n) {
		this.origin = void 0 !== d ? d : new g;
		this.direction = void 0 !== n ? n : new g;
	}
	function kb(d, n, a, b) {
		this._x = d || 0;
		this._y = n || 0;
		this._z = a || 0;
		this._order = b || kb.DefaultOrder;
	}
	function Xb() {
		this.mask = 1;
	}
	function X() {
		Object.defineProperty(this, "id", {value:Pe++});
		this.uuid = da.generateUUID();
		this.name = "";
		this.type = "Object3D";
		this.parent = null;
		this.children = [];
		this.up = X.DefaultUp.clone();
		var d = new g, n = new kb, a = new e, b = new g(1, 1, 1);
		n.onChange(function() {
			a.setFromEuler(n, !1);
		});
		a.onChange(function() {
			n.setFromQuaternion(a, void 0, !1);
		});
		Object.defineProperties(this, {position:{enumerable:!0, value:d}, rotation:{enumerable:!0, value:n}, quaternion:{enumerable:!0, value:a}, scale:{enumerable:!0, value:b}, modelViewMatrix:{value:new q}, normalMatrix:{value:new ya}});
		this.matrix = new q;
		this.matrixWorld = new q;
		this.matrixAutoUpdate = X.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = !1;
		this.layers = new Xb;
		this.visible = !0;
		this.receiveShadow = this.castShadow = !1;
		this.frustumCulled = !0;
		this.renderOrder = 0;
		this.userData = {};
		this.onBeforeRender = function() {
		};
		this.onAfterRender = function() {
		};
	}
	function qb(d, n) {
		this.start = void 0 !== d ? d : new g;
		this.end = void 0 !== n ? n : new g;
	}
	function Ia(d, n, a) {
		this.a = void 0 !== d ? d : new g;
		this.b = void 0 !== n ? n : new g;
		this.c = void 0 !== a ? a : new g;
	}
	function Ja(d, n, a, b, c, e) {
		this.a = d;
		this.b = n;
		this.c = a;
		this.normal = b && b.isVector3 ? b : new g;
		this.vertexNormals = Array.isArray(b) ? b : [];
		this.color = c && c.isColor ? c : new T;
		this.vertexColors = Array.isArray(c) ? c : [];
		this.materialIndex = void 0 !== e ? e : 0;
	}
	function La(d) {
		Z.call(this);
		this.type = "MeshBasicMaterial";
		this.color = new T(16777215);
		this.lightMap = this.map = null;
		this.lightMapIntensity = 1;
		this.aoMap = null;
		this.aoMapIntensity = 1;
		this.envMap = this.alphaMap = this.specularMap = null;
		this.combine = 0;
		this.reflectivity = 1;
		this.refractionRatio = .98;
		this.wireframe = !1;
		this.wireframeLinewidth = 1;
		this.wireframeLinejoin = this.wireframeLinecap = "round";
		this.lights = this.morphTargets = this.skinning = !1;
		this.setValues(d);
	}
	function U(d, n, a) {
		if (Array.isArray(d)) {
			throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
		}
		this.uuid = da.generateUUID();
		this.array = d;
		this.itemSize = n;
		this.count = void 0 !== d ? d.length / n : 0;
		this.normalized = !0 === a;
		this.dynamic = !1;
		this.updateRange = {offset:0, count:-1};
		this.onUploadCallback = function() {
		};
		this.version = 0;
	}
	function rb(d, n) {
		U.call(this, new Int8Array(d), n);
	}
	function lb(d, n) {
		U.call(this, new Uint8Array(d), n);
	}
	function Za(d, n) {
		U.call(this, new Uint8ClampedArray(d), n);
	}
	function xb(d, n) {
		U.call(this, new Int16Array(d), n);
	}
	function Ta(d, n) {
		U.call(this, new Uint16Array(d), n);
	}
	function bb(d, n) {
		U.call(this, new Int32Array(d), n);
	}
	function cb(d, n) {
		U.call(this, new Uint32Array(d), n);
	}
	function la(d, n) {
		U.call(this, new Float32Array(d), n);
	}
	function sb(d, n) {
		U.call(this, new Float64Array(d), n);
	}
	function Hc() {
		this.indices = [];
		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];
		this.groups = [];
		this.morphTargets = {};
		this.skinWeights = [];
		this.skinIndices = [];
		this.boundingSphere = this.boundingBox = null;
		this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1;
	}
	function ja() {
		Object.defineProperty(this, "id", {value:Wd++});
		this.uuid = da.generateUUID();
		this.name = "";
		this.type = "Geometry";
		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];
		this.morphTargets = [];
		this.morphNormals = [];
		this.skinWeights = [];
		this.skinIndices = [];
		this.lineDistances = [];
		this.boundingSphere = this.boundingBox = null;
		this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1;
	}
	function ca() {
		Object.defineProperty(this, "id", {value:Wd++});
		this.uuid = da.generateUUID();
		this.name = "";
		this.type = "BufferGeometry";
		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingSphere = this.boundingBox = null;
		this.drawRange = {start:0, count:Infinity};
	}
	function Da(d, n) {
		X.call(this);
		this.type = "Mesh";
		this.geometry = void 0 !== d ? d : new ca;
		this.material = void 0 !== n ? n : new La({color:16777215 * Math.random()});
		this.drawMode = 0;
		this.updateMorphTargets();
	}
	function mb(d, n, a, b, c, e) {
		function z(d, n, a, z, b, c, e, m, h, aa, fa) {
			var t = c / h, v = e / aa, O = c / 2, B = e / 2, y = m / 2;
			e = h + 1;
			for (var A = aa + 1, x = c = 0, Fa = new g, C = 0;C < A;C++) {
				for (var G = C * v - B, F = 0;F < e;F++) {
					Fa[d] = (F * t - O) * z, Fa[n] = G * b, Fa[a] = y, q[r] = Fa.x, q[r + 1] = Fa.y, q[r + 2] = Fa.z, Fa[d] = 0, Fa[n] = 0, Fa[a] = 0 < m ? 1 : -1, f[r] = Fa.x, f[r + 1] = Fa.y, f[r + 2] = Fa.z, p[P] = F / h, p[P + 1] = 1 - C / aa, r += 3, P += 2, c += 1;
				}
			}
			for (C = 0;C < aa;C++) {
				for (F = 0;F < h;F++) {
					d = l + F + e * (C + 1), n = l + (F + 1) + e * (C + 1), a = l + (F + 1) + e * C, k[u] = l + F + e * C, k[u + 1] = d, k[u + 2] = a, k[u + 3] = d, k[u + 4] = n, k[u + 5] = a, u += 6, x += 6;
				}
			}
			E.addGroup(w, x, fa);
			w += x;
			l += c;
		}
		ca.call(this);
		this.type = "BoxBufferGeometry";
		this.parameters = {width:d, height:n, depth:a, widthSegments:b, heightSegments:c, depthSegments:e};
		var E = this;
		b = Math.floor(b) || 1;
		c = Math.floor(c) || 1;
		e = Math.floor(e) || 1;
		var m = 0 + (b + 1) * (c + 1) * 2 + (b + 1) * (e + 1) * 2 + (e + 1) * (c + 1) * 2, h = 6 * (0 + b * c * 2 + b * e * 2 + e * c * 2), k = new (65535 < h ? Uint32Array : Uint16Array)(h), q = new Float32Array(3 * m), f = new Float32Array(3 * m), p = new Float32Array(2 * m), r = 0, P = 0, u = 0, l = 0, w = 0;
		z("z", "y", "x", -1, -1, a, n, d, e, c, 0);
		z("z", "y", "x", 1, -1, a, n, -d, e, c, 1);
		z("x", "z", "y", 1, 1, d, a, n, b, e, 2);
		z("x", "z", "y", 1, -1, d, a, -n, b, e, 3);
		z("x", "y", "z", 1, -1, d, n, a, b, c, 4);
		z("x", "y", "z", -1, -1, d, n, -a, b, c, 5);
		this.setIndex(new U(k, 1));
		this.addAttribute("position", new U(q, 3));
		this.addAttribute("normal", new U(f, 3));
		this.addAttribute("uv", new U(p, 2));
	}
	function Ra(d, n, a, b) {
		ca.call(this);
		this.type = "PlaneBufferGeometry";
		this.parameters = {width:d, height:n, widthSegments:a, heightSegments:b};
		var z = d / 2, c = n / 2;
		a = Math.floor(a) || 1;
		b = Math.floor(b) || 1;
		var g = a + 1, e = b + 1, E = d / a, m = n / b;
		n = new Float32Array(g * e * 3);
		d = new Float32Array(g * e * 3);
		for (var h = new Float32Array(g * e * 2), k = 0, q = 0, f = 0;f < e;f++) {
			for (var p = f * m - c, r = 0;r < g;r++) {
				n[k] = r * E - z, n[k + 1] = -p, d[k + 2] = 1, h[q] = r / a, h[q + 1] = 1 - f / b, k += 3, q += 2;
			}
		}
		k = 0;
		z = new (65535 < n.length / 3 ? Uint32Array : Uint16Array)(a * b * 6);
		for (f = 0;f < b;f++) {
			for (r = 0;r < a;r++) {
				c = r + g * (f + 1), e = r + 1 + g * (f + 1), E = r + 1 + g * f, z[k] = r + g * f, z[k + 1] = c, z[k + 2] = E, z[k + 3] = c, z[k + 4] = e, z[k + 5] = E, k += 6;
			}
		}
		this.setIndex(new U(z, 1));
		this.addAttribute("position", new U(n, 3));
		this.addAttribute("normal", new U(d, 3));
		this.addAttribute("uv", new U(h, 2));
	}
	function xa() {
		X.call(this);
		this.type = "Camera";
		this.matrixWorldInverse = new q;
		this.projectionMatrix = new q;
	}
	function Oa(d, n, a, b) {
		xa.call(this);
		this.type = "PerspectiveCamera";
		this.fov = void 0 !== d ? d : 50;
		this.zoom = 1;
		this.near = void 0 !== a ? a : .1;
		this.far = void 0 !== b ? b : 2E3;
		this.focus = 10;
		this.aspect = void 0 !== n ? n : 1;
		this.view = null;
		this.filmGauge = 35;
		this.filmOffset = 0;
		this.updateProjectionMatrix();
	}
	function Yb(d, n, a, b, c, g) {
		xa.call(this);
		this.type = "OrthographicCamera";
		this.zoom = 1;
		this.view = null;
		this.left = d;
		this.right = n;
		this.top = a;
		this.bottom = b;
		this.near = void 0 !== c ? c : .1;
		this.far = void 0 !== g ? g : 2E3;
		this.updateProjectionMatrix();
	}
	function Qe(d, n, a) {
		var z, b, c;
		return {setMode:function(d) {
			z = d;
		}, setIndex:function(a) {
			a.array instanceof Uint32Array && n.get("OES_element_index_uint") ? (b = d.UNSIGNED_INT, c = 4) : (b = d.UNSIGNED_SHORT, c = 2);
		}, render:function(n, g) {
			d.drawElements(z, g, b, n * c);
			a.calls++;
			a.vertices += g;
			z === d.TRIANGLES && (a.faces += g / 3);
		}, renderInstances:function(g, e, E) {
			var m = n.get("ANGLE_instanced_arrays");
			null === m ? console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (m.drawElementsInstancedANGLE(z, E, b, e * c, g.maxInstancedCount), a.calls++, a.vertices += E * g.maxInstancedCount, z === d.TRIANGLES && (a.faces += g.maxInstancedCount * E / 3));
		}};
	}
	function Re(d, n, a) {
		var z;
		return {setMode:function(d) {
			z = d;
		}, render:function(n, b) {
			d.drawArrays(z, n, b);
			a.calls++;
			a.vertices += b;
			z === d.TRIANGLES && (a.faces += b / 3);
		}, renderInstances:function(b) {
			var c = n.get("ANGLE_instanced_arrays");
			if (null === c) {
				console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
			} else {
				var g = b.attributes.position, g = g.isInterleavedBufferAttribute ? g.data.count : g.count;
				c.drawArraysInstancedANGLE(z, 0, g, b.maxInstancedCount);
				a.calls++;
				a.vertices += g * b.maxInstancedCount;
				z === d.TRIANGLES && (a.faces += b.maxInstancedCount * g / 3);
			}
		}};
	}
	function Se() {
		var d = {};
		return {get:function(n) {
			if (void 0 !== d[n.id]) {
				return d[n.id];
			}
			var a;
			switch(n.type) {
				case "DirectionalLight":
					a = {direction:new g, color:new T, shadow:!1, shadowBias:0, shadowRadius:1, shadowMapSize:new l};
					break;
				case "SpotLight":
					a = {position:new g, direction:new g, color:new T, distance:0, coneCos:0, penumbraCos:0, decay:0, shadow:!1, shadowBias:0, shadowRadius:1, shadowMapSize:new l};
					break;
				case "PointLight":
					a = {position:new g, color:new T, distance:0, decay:0, shadow:!1, shadowBias:0, shadowRadius:1, shadowMapSize:new l};
					break;
				case "HemisphereLight":
					a = {direction:new g, skyColor:new T, groundColor:new T};
					break;
				case "RectAreaLight":
					a = {color:new T, position:new g, halfWidth:new g, halfHeight:new g};
			}
			return d[n.id] = a;
		}};
	}
	function Ab(d) {
		d = d.split("\n");
		for (var n = 0;n < d.length;n++) {
			d[n] = n + 1 + ": " + d[n];
		}
		return d.join("\n");
	}
	function nb(d, n, a) {
		var z = d.createShader(n);
		d.shaderSource(z, a);
		d.compileShader(z);
		!1 === d.getShaderParameter(z, d.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile.");
		"" !== d.getShaderInfoLog(z) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", n === d.VERTEX_SHADER ? "vertex" : "fragment", d.getShaderInfoLog(z), Ab(a));
		return z;
	}
	function Ua(d) {
		switch(d) {
			case 3E3:
				return ["Linear", "( value )"];
			case 3001:
				return ["sRGB", "( value )"];
			case 3002:
				return ["RGBE", "( value )"];
			case 3004:
				return ["RGBM", "( value, 7.0 )"];
			case 3005:
				return ["RGBM", "( value, 16.0 )"];
			case 3006:
				return ["RGBD", "( value, 256.0 )"];
			case 3007:
				return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
			default:
				throw Error("unsupported encoding: " + d);;
		}
	}
	function yb(d, n) {
		n = Ua(n);
		return "vec4 " + d + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }";
	}
	function Pa(d, n) {
		n = Ua(n);
		return "vec4 " + d + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }";
	}
	function Ic(d, n) {
		switch(n) {
			case 1:
				n = "Linear";
				break;
			case 2:
				n = "Reinhard";
				break;
			case 3:
				n = "Uncharted2";
				break;
			case 4:
				n = "OptimizedCineon";
				break;
			default:
				throw Error("unsupported toneMapping: " + n);;
		}
		return "vec3 " + d + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
	}
	function sd(d, n, a) {
		d = d || {};
		return [d.derivatives || n.envMapCubeUV || n.bumpMap || n.normalMap || n.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (d.fragDepth || n.logarithmicDepthBuffer) && a.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", d.drawBuffers && a.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (d.shaderTextureLOD || n.envMap) && a.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(db).join("\n");
	}
	function Jc(d) {
		var n = [], a;
		for (a in d) {
			var b = d[a];
			!1 !== b && n.push("#define " + a + " " + b);
		}
		return n.join("\n");
	}
	function db(d) {
		return "" !== d;
	}
	function Zb(d, n) {
		return d.replace(/NUM_DIR_LIGHTS/g, n.numDirLights).replace(/NUM_SPOT_LIGHTS/g, n.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, n.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, n.numPointLights).replace(/NUM_HEMI_LIGHTS/g, n.numHemiLights);
	}
	function Va(d) {
		return d.replace(/#include +<([\w\d.]+)>/g, function(d, a) {
			d = ka[a];
			if (void 0 === d) {
				throw Error("Can not resolve #include <" + a + ">");
			}
			return Va(d);
		});
	}
	function Qa(d) {
		return d.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(d, a, b, c) {
			d = "";
			for (a = parseInt(a);a < parseInt(b);a++) {
				d += c.replace(/\[ i \]/g, "[ " + a + " ]");
			}
			return d;
		});
	}
	function zb(d, n, a, b) {
		var z = d.context, c = a.extensions, g = a.defines, e = a.__webglShader.vertexShader, E = a.__webglShader.fragmentShader, m = "SHADOWMAP_TYPE_BASIC";
		1 === b.shadowMapType ? m = "SHADOWMAP_TYPE_PCF" : 2 === b.shadowMapType && (m = "SHADOWMAP_TYPE_PCF_SOFT");
		var h = "ENVMAP_TYPE_CUBE", k = "ENVMAP_MODE_REFLECTION", q = "ENVMAP_BLENDING_MULTIPLY";
		if (b.envMap) {
			switch(a.envMap.mapping) {
				case 301:
				;
				case 302:
					h = "ENVMAP_TYPE_CUBE";
					break;
				case 306:
				;
				case 307:
					h = "ENVMAP_TYPE_CUBE_UV";
					break;
				case 303:
				;
				case 304:
					h = "ENVMAP_TYPE_EQUIREC";
					break;
				case 305:
					h = "ENVMAP_TYPE_SPHERE";
			}
			switch(a.envMap.mapping) {
				case 302:
				;
				case 304:
					k = "ENVMAP_MODE_REFRACTION";
			}
			switch(a.combine) {
				case 0:
					q = "ENVMAP_BLENDING_MULTIPLY";
					break;
				case 1:
					q = "ENVMAP_BLENDING_MIX";
					break;
				case 2:
					q = "ENVMAP_BLENDING_ADD";
			}
		}
		var f = 0 < d.gammaFactor ? d.gammaFactor : 1, c = sd(c, b, d.extensions), p = Jc(g), r = z.createProgram();
		a.isRawShaderMaterial ? (g = [p, "\n"].filter(db).join("\n"), m = [c, p, "\n"].filter(db).join("\n")) : (g = ["precision " + b.precision + " float;", "precision " + b.precision + " int;", "#define SHADER_NAME " + a.__webglShader.name, p, b.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + f, "#define MAX_BONES " + b.maxBones, b.map ? "#define USE_MAP" : "", b.envMap ? "#define USE_ENVMAP" : "", b.envMap ? "#define " + k : "", b.lightMap ? "#define USE_LIGHTMAP" : 
		"", b.aoMap ? "#define USE_AOMAP" : "", b.emissiveMap ? "#define USE_EMISSIVEMAP" : "", b.bumpMap ? "#define USE_BUMPMAP" : "", b.normalMap ? "#define USE_NORMALMAP" : "", b.displacementMap && b.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", b.specularMap ? "#define USE_SPECULARMAP" : "", b.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", b.metalnessMap ? "#define USE_METALNESSMAP" : "", b.alphaMap ? "#define USE_ALPHAMAP" : "", b.vertexColors ? "#define USE_COLOR" : "", b.flatShading ? 
		"#define FLAT_SHADED" : "", b.skinning ? "#define USE_SKINNING" : "", b.useVertexTexture ? "#define BONE_TEXTURE" : "", b.morphTargets ? "#define USE_MORPHTARGETS" : "", b.morphNormals && !1 === b.flatShading ? "#define USE_MORPHNORMALS" : "", b.doubleSided ? "#define DOUBLE_SIDED" : "", b.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + b.numClippingPlanes, b.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", b.shadowMapEnabled ? "#define " + m : "", b.sizeAttenuation ? 
		"#define USE_SIZEATTENUATION" : "", b.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", b.logarithmicDepthBuffer && d.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", 
		"#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", 
		"\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(db).join("\n"), m = [c, "precision " + b.precision + " float;", "precision " + b.precision + " int;", "#define SHADER_NAME " + a.__webglShader.name, p, b.alphaTest ? "#define ALPHATEST " + b.alphaTest : "", "#define GAMMA_FACTOR " + f, b.useFog && b.fog ? "#define USE_FOG" : "", b.useFog && b.fogExp ? "#define FOG_EXP2" : "", b.map ? "#define USE_MAP" : "", b.envMap ? 
		"#define USE_ENVMAP" : "", b.envMap ? "#define " + h : "", b.envMap ? "#define " + k : "", b.envMap ? "#define " + q : "", b.lightMap ? "#define USE_LIGHTMAP" : "", b.aoMap ? "#define USE_AOMAP" : "", b.emissiveMap ? "#define USE_EMISSIVEMAP" : "", b.bumpMap ? "#define USE_BUMPMAP" : "", b.normalMap ? "#define USE_NORMALMAP" : "", b.specularMap ? "#define USE_SPECULARMAP" : "", b.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", b.metalnessMap ? "#define USE_METALNESSMAP" : "", b.alphaMap ? "#define USE_ALPHAMAP" : 
		"", b.vertexColors ? "#define USE_COLOR" : "", b.gradientMap ? "#define USE_GRADIENTMAP" : "", b.flatShading ? "#define FLAT_SHADED" : "", b.doubleSided ? "#define DOUBLE_SIDED" : "", b.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + b.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (b.numClippingPlanes - b.numClipIntersection), b.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", b.shadowMapEnabled ? "#define " + m : "", b.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : 
		"", b.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", b.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", b.logarithmicDepthBuffer && d.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", b.envMap && d.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== b.toneMapping ? "#define TONE_MAPPING" : "", 0 !== b.toneMapping ? ka.tonemapping_pars_fragment : "", 0 !== 
		b.toneMapping ? Ic("toneMapping", b.toneMapping) : "", b.outputEncoding || b.mapEncoding || b.envMapEncoding || b.emissiveMapEncoding ? ka.encodings_pars_fragment : "", b.mapEncoding ? yb("mapTexelToLinear", b.mapEncoding) : "", b.envMapEncoding ? yb("envMapTexelToLinear", b.envMapEncoding) : "", b.emissiveMapEncoding ? yb("emissiveMapTexelToLinear", b.emissiveMapEncoding) : "", b.outputEncoding ? Pa("linearToOutputTexel", b.outputEncoding) : "", b.depthPacking ? "#define DEPTH_PACKING " + a.depthPacking : 
		"", "\n"].filter(db).join("\n"));
		e = Va(e, b);
		e = Zb(e, b);
		E = Va(E, b);
		E = Zb(E, b);
		a.isShaderMaterial || (e = Qa(e), E = Qa(E));
		E = m + E;
		e = nb(z, z.VERTEX_SHADER, g + e);
		E = nb(z, z.FRAGMENT_SHADER, E);
		z.attachShader(r, e);
		z.attachShader(r, E);
		void 0 !== a.index0AttributeName ? z.bindAttribLocation(r, 0, a.index0AttributeName) : !0 === b.morphTargets && z.bindAttribLocation(r, 0, "position");
		z.linkProgram(r);
		b = z.getProgramInfoLog(r);
		h = z.getShaderInfoLog(e);
		k = z.getShaderInfoLog(E);
		f = q = !0;
		if (!1 === z.getProgramParameter(r, z.LINK_STATUS)) {
			q = !1, console.error("THREE.WebGLProgram: shader error: ", z.getError(), "gl.VALIDATE_STATUS", z.getProgramParameter(r, z.VALIDATE_STATUS), "gl.getProgramInfoLog", b, h, k);
		} else {
			if ("" !== b) {
				console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", b);
			} else {
				if ("" === h || "" === k) {
					f = !1;
				}
			}
		}
		f && (this.diagnostics = {runnable:q, material:a, programLog:b, vertexShader:{log:h, prefix:g}, fragmentShader:{log:k, prefix:m}});
		z.deleteShader(e);
		z.deleteShader(E);
		var u;
		this.getUniforms = function() {
			void 0 === u && (u = new va(z, r, d));
			return u;
		};
		var l;
		this.getAttributes = function() {
			if (void 0 === l) {
				for (var d = {}, n = z.getProgramParameter(r, z.ACTIVE_ATTRIBUTES), a = 0;a < n;a++) {
					var b = z.getActiveAttrib(r, a).name;
					d[b] = z.getAttribLocation(r, b);
				}
				l = d;
			}
			return l;
		};
		this.destroy = function() {
			z.deleteProgram(r);
			this.program = void 0;
		};
		Object.defineProperties(this, {uniforms:{get:function() {
			console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
			return this.getUniforms();
		}}, attributes:{get:function() {
			console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
			return this.getAttributes();
		}}});
		this.id = Te++;
		this.code = n;
		this.usedTimes = 1;
		this.program = r;
		this.vertexShader = e;
		this.fragmentShader = E;
		return this;
	}
	function Ue(d, n) {
		function a(d, n) {
			var a;
			d ? d.isTexture ? a = d.encoding : d.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), a = d.texture.encoding) : a = 3E3;
			3E3 === a && n && (a = 3007);
			return a;
		}
		var b = [], c = {MeshDepthMaterial:"depth", MeshNormalMaterial:"normal", MeshBasicMaterial:"basic", MeshLambertMaterial:"lambert", MeshPhongMaterial:"phong", MeshToonMaterial:"phong", MeshStandardMaterial:"physical", MeshPhysicalMaterial:"physical", LineBasicMaterial:"basic", LineDashedMaterial:"dashed", PointsMaterial:"points"}, g = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking".split(" ");
		this.getParameters = function(b, z, g, e, m, E) {
			var h = c[b.type], k;
			n.floatVertexTextures && E && E.skeleton && E.skeleton.useVertexTexture ? k = 1024 : (k = Math.floor((n.maxVertexUniforms - 20) / 4), void 0 !== E && E && E.isSkinnedMesh && (k = Math.min(E.skeleton.bones.length, k), k < E.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + E.skeleton.bones.length + ", this GPU supports just " + k + " (try OpenGL instead of ANGLE)")));
			var q = d.getPrecision();
			null !== b.precision && (q = n.getMaxPrecision(b.precision), q !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", q, "instead."));
			var f = d.getCurrentRenderTarget();
			return {shaderID:h, precision:q, supportsVertexTextures:n.vertexTextures, outputEncoding:a(f ? f.texture : null, d.gammaOutput), map:!!b.map, mapEncoding:a(b.map, d.gammaInput), envMap:!!b.envMap, envMapMode:b.envMap && b.envMap.mapping, envMapEncoding:a(b.envMap, d.gammaInput), envMapCubeUV:!!b.envMap && (306 === b.envMap.mapping || 307 === b.envMap.mapping), lightMap:!!b.lightMap, aoMap:!!b.aoMap, emissiveMap:!!b.emissiveMap, emissiveMapEncoding:a(b.emissiveMap, d.gammaInput), bumpMap:!!b.bumpMap, 
			normalMap:!!b.normalMap, displacementMap:!!b.displacementMap, roughnessMap:!!b.roughnessMap, metalnessMap:!!b.metalnessMap, specularMap:!!b.specularMap, alphaMap:!!b.alphaMap, gradientMap:!!b.gradientMap, combine:b.combine, vertexColors:b.vertexColors, fog:!!g, useFog:b.fog, fogExp:g && g.isFogExp2, flatShading:1 === b.shading, sizeAttenuation:b.sizeAttenuation, logarithmicDepthBuffer:n.logarithmicDepthBuffer, skinning:b.skinning, maxBones:k, useVertexTexture:n.floatVertexTextures && E && E.skeleton && 
			E.skeleton.useVertexTexture, morphTargets:b.morphTargets, morphNormals:b.morphNormals, maxMorphTargets:d.maxMorphTargets, maxMorphNormals:d.maxMorphNormals, numDirLights:z.directional.length, numPointLights:z.point.length, numSpotLights:z.spot.length, numRectAreaLights:z.rectArea.length, numHemiLights:z.hemi.length, numClippingPlanes:e, numClipIntersection:m, shadowMapEnabled:d.shadowMap.enabled && E.receiveShadow && 0 < z.shadows.length, shadowMapType:d.shadowMap.type, toneMapping:d.toneMapping, 
			physicallyCorrectLights:d.physicallyCorrectLights, premultipliedAlpha:b.premultipliedAlpha, alphaTest:b.alphaTest, doubleSided:2 === b.side, flipSided:1 === b.side, depthPacking:void 0 !== b.depthPacking ? b.depthPacking : !1};
		};
		this.getProgramCode = function(d, n) {
			var a = [];
			n.shaderID ? a.push(n.shaderID) : (a.push(d.fragmentShader), a.push(d.vertexShader));
			if (void 0 !== d.defines) {
				for (var b in d.defines) {
					a.push(b), a.push(d.defines[b]);
				}
			}
			for (b = 0;b < g.length;b++) {
				a.push(n[g[b]]);
			}
			return a.join();
		};
		this.acquireProgram = function(n, a, z) {
			for (var c, g = 0, e = b.length;g < e;g++) {
				var E = b[g];
				if (E.code === z) {
					c = E;
					++c.usedTimes;
					break;
				}
			}
			void 0 === c && (c = new zb(d, z, n, a), b.push(c));
			return c;
		};
		this.releaseProgram = function(d) {
			if (0 === --d.usedTimes) {
				var n = b.indexOf(d);
				b[n] = b[b.length - 1];
				b.pop();
				d.destroy();
			}
		};
		this.programs = b;
	}
	function Bb(d, n, a) {
		function b(d) {
			var g = d.target;
			d = c[g.id];
			null !== d.index && z(d.index);
			var e = d.attributes, E;
			for (E in e) {
				z(e[E]);
			}
			g.removeEventListener("dispose", b);
			delete c[g.id];
			E = n.get(g);
			E.wireframe && z(E.wireframe);
			n["delete"](g);
			g = n.get(d);
			g.wireframe && z(g.wireframe);
			n["delete"](d);
			a.memory.geometries--;
		}
		function z(a) {
			var b;
			b = a.isInterleavedBufferAttribute ? n.get(a.data).__webglBuffer : n.get(a).__webglBuffer;
			void 0 !== b && (d.deleteBuffer(b), a.isInterleavedBufferAttribute ? n["delete"](a.data) : n["delete"](a));
		}
		var c = {};
		return {get:function(d) {
			var n = d.geometry;
			if (void 0 !== c[n.id]) {
				return c[n.id];
			}
			n.addEventListener("dispose", b);
			var z;
			n.isBufferGeometry ? z = n : n.isGeometry && (void 0 === n._bufferGeometry && (n._bufferGeometry = (new ca).setFromObject(d)), z = n._bufferGeometry);
			c[n.id] = z;
			a.memory.geometries++;
			return z;
		}};
	}
	function Ve(d, n, a) {
		function b(a, b) {
			a = a.isInterleavedBufferAttribute ? a.data : a;
			var z = n.get(a);
			if (void 0 === z.__webglBuffer) {
				z.__webglBuffer = d.createBuffer();
				d.bindBuffer(b, z.__webglBuffer);
				d.bufferData(b, a.array, a.dynamic ? d.DYNAMIC_DRAW : d.STATIC_DRAW);
				b = d.FLOAT;
				var c = a.array;
				c instanceof Float32Array ? b = d.FLOAT : c instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : c instanceof Uint16Array ? b = d.UNSIGNED_SHORT : c instanceof Int16Array ? b = d.SHORT : c instanceof Uint32Array ? b = d.UNSIGNED_INT : c instanceof Int32Array ? b = d.INT : c instanceof Int8Array ? b = d.BYTE : c instanceof Uint8Array && (b = d.UNSIGNED_BYTE);
				z.bytesPerElement = c.BYTES_PER_ELEMENT;
				z.type = b;
				z.version = a.version;
				a.onUploadCallback();
			} else {
				z.version !== a.version && (d.bindBuffer(b, z.__webglBuffer), !1 === a.dynamic ? d.bufferData(b, a.array, d.STATIC_DRAW) : -1 === a.updateRange.count ? d.bufferSubData(b, 0, a.array) : 0 === a.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (d.bufferSubData(b, a.updateRange.offset * a.array.BYTES_PER_ELEMENT, a.array.subarray(a.updateRange.offset, 
				a.updateRange.offset + a.updateRange.count)), a.updateRange.count = 0), z.version = a.version);
			}
		}
		var z = new Bb(d, n, a);
		return {getAttributeBuffer:function(d) {
			return d.isInterleavedBufferAttribute ? n.get(d.data).__webglBuffer : n.get(d).__webglBuffer;
		}, getAttributeProperties:function(d) {
			return d.isInterleavedBufferAttribute ? n.get(d.data) : n.get(d);
		}, getWireframeAttribute:function(a) {
			var z = n.get(a);
			if (void 0 !== z.wireframe) {
				return z.wireframe;
			}
			var c = [], g = a.index, e = a.attributes;
			a = e.position;
			if (null !== g) {
				for (var g = g.array, e = 0, E = g.length;e < E;e += 3) {
					var m = g[e + 0], h = g[e + 1], k = g[e + 2];
					c.push(m, h, h, k, k, m);
				}
			} else {
				for (g = e.position.array, e = 0, E = g.length / 3 - 1;e < E;e += 3) {
					m = e + 0, h = e + 1, k = e + 2, c.push(m, h, h, k, k, m);
				}
			}
			c = new U(new (65535 < a.count ? Uint32Array : Uint16Array)(c), 1);
			b(c, d.ELEMENT_ARRAY_BUFFER);
			return z.wireframe = c;
		}, update:function(n) {
			var a = z.get(n);
			n.geometry.isGeometry && a.updateFromObject(n);
			n = a.index;
			var c = a.attributes;
			null !== n && b(n, d.ELEMENT_ARRAY_BUFFER);
			for (var g in c) {
				b(c[g], d.ARRAY_BUFFER);
			}
			n = a.morphAttributes;
			for (g in n) {
				for (var c = n[g], e = 0, E = c.length;e < E;e++) {
					b(c[e], d.ARRAY_BUFFER);
				}
			}
			return a;
		}};
	}
	function We(d, n, a, b, c, g, e) {
		function z(d, n) {
			if (d.width > n || d.height > n) {
				n /= Math.max(d.width, d.height);
				var a = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
				a.width = Math.floor(d.width * n);
				a.height = Math.floor(d.height * n);
				a.getContext("2d").drawImage(d, 0, 0, d.width, d.height, 0, 0, a.width, a.height);
				console.warn("THREE.WebGLRenderer: image is too big (" + d.width + "x" + d.height + "). Resized to " + a.width + "x" + a.height, d);
				return a;
			}
			return d;
		}
		function m(d) {
			return da.isPowerOfTwo(d.width) && da.isPowerOfTwo(d.height);
		}
		function E(n) {
			return 1003 === n || 1004 === n || 1005 === n ? d.NEAREST : d.LINEAR;
		}
		function h(n) {
			n = n.target;
			n.removeEventListener("dispose", h);
			a: {
				var a = b.get(n);
				if (n.image && a.__image__webglTextureCube) {
					d.deleteTexture(a.__image__webglTextureCube);
				} else {
					if (void 0 === a.__webglInit) {
						break a;
					}
					d.deleteTexture(a.__webglTexture);
				}
				b["delete"](n);
			}
			u.textures--;
		}
		function k(n) {
			n = n.target;
			n.removeEventListener("dispose", k);
			var a = b.get(n), z = b.get(n.texture);
			if (n) {
				void 0 !== z.__webglTexture && d.deleteTexture(z.__webglTexture);
				n.depthTexture && n.depthTexture.dispose();
				if (n.isWebGLRenderTargetCube) {
					for (z = 0;6 > z;z++) {
						d.deleteFramebuffer(a.__webglFramebuffer[z]), a.__webglDepthbuffer && d.deleteRenderbuffer(a.__webglDepthbuffer[z]);
					}
				} else {
					d.deleteFramebuffer(a.__webglFramebuffer), a.__webglDepthbuffer && d.deleteRenderbuffer(a.__webglDepthbuffer);
				}
				b["delete"](n.texture);
				b["delete"](n);
			}
			u.textures--;
		}
		function q(n, e) {
			var E = b.get(n);
			if (0 < n.version && E.__version !== n.version) {
				var k = n.image;
				if (void 0 === k) {
					console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", n);
				} else {
					if (!1 === k.complete) {
						console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", n);
					} else {
						void 0 === E.__webglInit && (E.__webglInit = !0, n.addEventListener("dispose", h), E.__webglTexture = d.createTexture(), u.textures++);
						a.activeTexture(d.TEXTURE0 + e);
						a.bindTexture(d.TEXTURE_2D, E.__webglTexture);
						d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, n.flipY);
						d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha);
						d.pixelStorei(d.UNPACK_ALIGNMENT, n.unpackAlignment);
						e = z(n.image, c.maxTextureSize);
						if ((1001 !== n.wrapS || 1001 !== n.wrapT || 1003 !== n.minFilter && 1006 !== n.minFilter) && !1 === m(e)) {
							if (k = e, k instanceof HTMLImageElement || k instanceof HTMLCanvasElement) {
								var q = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
								q.width = da.nearestPowerOfTwo(k.width);
								q.height = da.nearestPowerOfTwo(k.height);
								q.getContext("2d").drawImage(k, 0, 0, q.width, q.height);
								console.warn("THREE.WebGLRenderer: image is not power of two (" + k.width + "x" + k.height + "). Resized to " + q.width + "x" + q.height, k);
								e = q;
							} else {
								e = k;
							}
						}
						var k = m(e), q = g(n.format), p = g(n.type);
						f(d.TEXTURE_2D, n, k);
						var r = n.mipmaps;
						if (n.isDepthTexture) {
							r = d.DEPTH_COMPONENT;
							if (1015 === n.type) {
								if (!P) {
									throw Error("Float Depth Texture only supported in WebGL2.0");
								}
								r = d.DEPTH_COMPONENT32F;
							} else {
								P && (r = d.DEPTH_COMPONENT16);
							}
							1026 === n.format && r === d.DEPTH_COMPONENT && 1012 !== n.type && 1014 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = 1012, p = g(n.type));
							1027 === n.format && (r = d.DEPTH_STENCIL, 1020 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = 1020, p = g(n.type)));
							a.texImage2D(d.TEXTURE_2D, 0, r, e.width, e.height, 0, q, p, null);
						} else {
							if (n.isDataTexture) {
								if (0 < r.length && k) {
									for (var l = 0, w = r.length;l < w;l++) {
										e = r[l], a.texImage2D(d.TEXTURE_2D, l, q, e.width, e.height, 0, q, p, e.data);
									}
									n.generateMipmaps = !1;
								} else {
									a.texImage2D(d.TEXTURE_2D, 0, q, e.width, e.height, 0, q, p, e.data);
								}
							} else {
								if (n.isCompressedTexture) {
									for (l = 0, w = r.length;l < w;l++) {
										e = r[l], 1023 !== n.format && 1022 !== n.format ? -1 < a.getCompressedTextureFormats().indexOf(q) ? a.compressedTexImage2D(d.TEXTURE_2D, l, q, e.width, e.height, 0, e.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : a.texImage2D(d.TEXTURE_2D, l, q, e.width, e.height, 0, q, p, e.data);
									}
								} else {
									if (0 < r.length && k) {
										l = 0;
										for (w = r.length;l < w;l++) {
											e = r[l], a.texImage2D(d.TEXTURE_2D, l, q, q, p, e);
										}
										n.generateMipmaps = !1;
									} else {
										a.texImage2D(d.TEXTURE_2D, 0, q, q, p, e);
									}
								}
							}
						}
						n.generateMipmaps && k && d.generateMipmap(d.TEXTURE_2D);
						E.__version = n.version;
						if (n.onUpdate) {
							n.onUpdate(n);
						}
						return;
					}
				}
			}
			a.activeTexture(d.TEXTURE0 + e);
			a.bindTexture(d.TEXTURE_2D, E.__webglTexture);
		}
		function f(a, z, e) {
			e ? (d.texParameteri(a, d.TEXTURE_WRAP_S, g(z.wrapS)), d.texParameteri(a, d.TEXTURE_WRAP_T, g(z.wrapT)), d.texParameteri(a, d.TEXTURE_MAG_FILTER, g(z.magFilter)), d.texParameteri(a, d.TEXTURE_MIN_FILTER, g(z.minFilter))) : (d.texParameteri(a, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(a, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), 1001 === z.wrapS && 1001 === z.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", 
			z), d.texParameteri(a, d.TEXTURE_MAG_FILTER, E(z.magFilter)), d.texParameteri(a, d.TEXTURE_MIN_FILTER, E(z.minFilter)), 1003 !== z.minFilter && 1006 !== z.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", z));
			!(e = n.get("EXT_texture_filter_anisotropic")) || 1015 === z.type && null === n.get("OES_texture_float_linear") || 1016 === z.type && null === n.get("OES_texture_half_float_linear") || !(1 < z.anisotropy || b.get(z).__currentAnisotropy) || (d.texParameterf(a, e.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(z.anisotropy, c.getMaxAnisotropy())), b.get(z).__currentAnisotropy = z.anisotropy);
		}
		function p(n, z, c, e) {
			var m = g(z.texture.format), E = g(z.texture.type);
			a.texImage2D(e, 0, m, z.width, z.height, 0, m, E, null);
			d.bindFramebuffer(d.FRAMEBUFFER, n);
			d.framebufferTexture2D(d.FRAMEBUFFER, c, e, b.get(z.texture).__webglTexture, 0);
			d.bindFramebuffer(d.FRAMEBUFFER, null);
		}
		function r(n, a) {
			d.bindRenderbuffer(d.RENDERBUFFER, n);
			a.depthBuffer && !a.stencilBuffer ? (d.renderbufferStorage(d.RENDERBUFFER, d.DEPTH_COMPONENT16, a.width, a.height), d.framebufferRenderbuffer(d.FRAMEBUFFER, d.DEPTH_ATTACHMENT, d.RENDERBUFFER, n)) : a.depthBuffer && a.stencilBuffer ? (d.renderbufferStorage(d.RENDERBUFFER, d.DEPTH_STENCIL, a.width, a.height), d.framebufferRenderbuffer(d.FRAMEBUFFER, d.DEPTH_STENCIL_ATTACHMENT, d.RENDERBUFFER, n)) : d.renderbufferStorage(d.RENDERBUFFER, d.RGBA4, a.width, a.height);
			d.bindRenderbuffer(d.RENDERBUFFER, null);
		}
		var u = e.memory, P = "undefined" !== typeof WebGL2RenderingContext && d instanceof WebGL2RenderingContext;
		this.setTexture2D = q;
		this.setTextureCube = function(n, e) {
			var E = b.get(n);
			if (6 === n.image.length) {
				if (0 < n.version && E.__version !== n.version) {
					E.__image__webglTextureCube || (n.addEventListener("dispose", h), E.__image__webglTextureCube = d.createTexture(), u.textures++);
					a.activeTexture(d.TEXTURE0 + e);
					a.bindTexture(d.TEXTURE_CUBE_MAP, E.__image__webglTextureCube);
					d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, n.flipY);
					e = n && n.isCompressedTexture;
					for (var k = n.image[0] && n.image[0].isDataTexture, q = [], p = 0;6 > p;p++) {
						q[p] = e || k ? k ? n.image[p].image : n.image[p] : z(n.image[p], c.maxCubemapSize);
					}
					var r = m(q[0]), l = g(n.format), P = g(n.type);
					f(d.TEXTURE_CUBE_MAP, n, r);
					for (p = 0;6 > p;p++) {
						if (e) {
							for (var w, aa = q[p].mipmaps, t = 0, v = aa.length;t < v;t++) {
								w = aa[t], 1023 !== n.format && 1022 !== n.format ? -1 < a.getCompressedTextureFormats().indexOf(l) ? a.compressedTexImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + p, t, l, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : a.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + p, t, l, w.width, w.height, 0, l, P, w.data);
							}
						} else {
							k ? a.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, l, q[p].width, q[p].height, 0, l, P, q[p].data) : a.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, l, l, P, q[p]);
						}
					}
					n.generateMipmaps && r && d.generateMipmap(d.TEXTURE_CUBE_MAP);
					E.__version = n.version;
					if (n.onUpdate) {
						n.onUpdate(n);
					}
				} else {
					a.activeTexture(d.TEXTURE0 + e), a.bindTexture(d.TEXTURE_CUBE_MAP, E.__image__webglTextureCube);
				}
			}
		};
		this.setTextureCubeDynamic = function(n, z) {
			a.activeTexture(d.TEXTURE0 + z);
			a.bindTexture(d.TEXTURE_CUBE_MAP, b.get(n).__webglTexture);
		};
		this.setupRenderTarget = function(n) {
			var z = b.get(n), c = b.get(n.texture);
			n.addEventListener("dispose", k);
			c.__webglTexture = d.createTexture();
			u.textures++;
			var g = !0 === n.isWebGLRenderTargetCube, e = m(n);
			if (g) {
				z.__webglFramebuffer = [];
				for (var E = 0;6 > E;E++) {
					z.__webglFramebuffer[E] = d.createFramebuffer();
				}
			} else {
				z.__webglFramebuffer = d.createFramebuffer();
			}
			if (g) {
				a.bindTexture(d.TEXTURE_CUBE_MAP, c.__webglTexture);
				f(d.TEXTURE_CUBE_MAP, n.texture, e);
				for (E = 0;6 > E;E++) {
					p(z.__webglFramebuffer[E], n, d.COLOR_ATTACHMENT0, d.TEXTURE_CUBE_MAP_POSITIVE_X + E);
				}
				n.texture.generateMipmaps && e && d.generateMipmap(d.TEXTURE_CUBE_MAP);
				a.bindTexture(d.TEXTURE_CUBE_MAP, null);
			} else {
				a.bindTexture(d.TEXTURE_2D, c.__webglTexture), f(d.TEXTURE_2D, n.texture, e), p(z.__webglFramebuffer, n, d.COLOR_ATTACHMENT0, d.TEXTURE_2D), n.texture.generateMipmaps && e && d.generateMipmap(d.TEXTURE_2D), a.bindTexture(d.TEXTURE_2D, null);
			}
			if (n.depthBuffer) {
				z = b.get(n);
				c = !0 === n.isWebGLRenderTargetCube;
				if (n.depthTexture) {
					if (c) {
						throw Error("target.depthTexture not supported in Cube render targets");
					}
					if (n && n.isWebGLRenderTargetCube) {
						throw Error("Depth Texture with cube render targets is not supported!");
					}
					d.bindFramebuffer(d.FRAMEBUFFER, z.__webglFramebuffer);
					if (!n.depthTexture || !n.depthTexture.isDepthTexture) {
						throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
					}
					b.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0);
					q(n.depthTexture, 0);
					z = b.get(n.depthTexture).__webglTexture;
					if (1026 === n.depthTexture.format) {
						d.framebufferTexture2D(d.FRAMEBUFFER, d.DEPTH_ATTACHMENT, d.TEXTURE_2D, z, 0);
					} else {
						if (1027 === n.depthTexture.format) {
							d.framebufferTexture2D(d.FRAMEBUFFER, d.DEPTH_STENCIL_ATTACHMENT, d.TEXTURE_2D, z, 0);
						} else {
							throw Error("Unknown depthTexture format");
						}
					}
				} else {
					if (c) {
						for (z.__webglDepthbuffer = [], c = 0;6 > c;c++) {
							d.bindFramebuffer(d.FRAMEBUFFER, z.__webglFramebuffer[c]), z.__webglDepthbuffer[c] = d.createRenderbuffer(), r(z.__webglDepthbuffer[c], n);
						}
					} else {
						d.bindFramebuffer(d.FRAMEBUFFER, z.__webglFramebuffer), z.__webglDepthbuffer = d.createRenderbuffer(), r(z.__webglDepthbuffer, n);
					}
				}
				d.bindFramebuffer(d.FRAMEBUFFER, null);
			}
		};
		this.updateRenderTargetMipmap = function(n) {
			var z = n.texture;
			z.generateMipmaps && m(n) && 1003 !== z.minFilter && 1006 !== z.minFilter && (n = n && n.isWebGLRenderTargetCube ? d.TEXTURE_CUBE_MAP : d.TEXTURE_2D, z = b.get(z).__webglTexture, a.bindTexture(n, z), d.generateMipmap(n), a.bindTexture(n, null));
		};
	}
	function Xe() {
		var d = {};
		return {get:function(n) {
			n = n.uuid;
			var a = d[n];
			void 0 === a && (a = {}, d[n] = a);
			return a;
		}, "delete":function(n) {
			delete d[n.uuid];
		}, clear:function() {
			d = {};
		}};
	}
	function Ye(d, n, a) {
		function b(n, a, b) {
			var z = new Uint8Array(4), c = d.createTexture();
			d.bindTexture(n, c);
			d.texParameteri(n, d.TEXTURE_MIN_FILTER, d.NEAREST);
			d.texParameteri(n, d.TEXTURE_MAG_FILTER, d.NEAREST);
			for (n = 0;n < b;n++) {
				d.texImage2D(a + n, 0, d.RGBA, 1, 1, 0, d.RGBA, d.UNSIGNED_BYTE, z);
			}
			return c;
		}
		function z(n) {
			!0 !== v[n] && (d.enable(n), v[n] = !0);
		}
		function c(n) {
			!1 !== v[n] && (d.disable(n), v[n] = !1);
		}
		function g(n, b, g, e, E, m, k, h) {
			0 !== n ? z(d.BLEND) : c(d.BLEND);
			if (n !== y || h !== D) {
				2 === n ? h ? (d.blendEquationSeparate(d.FUNC_ADD, d.FUNC_ADD), d.blendFuncSeparate(d.ONE, d.ONE, d.ONE, d.ONE)) : (d.blendEquation(d.FUNC_ADD), d.blendFunc(d.SRC_ALPHA, d.ONE)) : 3 === n ? h ? (d.blendEquationSeparate(d.FUNC_ADD, d.FUNC_ADD), d.blendFuncSeparate(d.ZERO, d.ZERO, d.ONE_MINUS_SRC_COLOR, d.ONE_MINUS_SRC_ALPHA)) : (d.blendEquation(d.FUNC_ADD), d.blendFunc(d.ZERO, d.ONE_MINUS_SRC_COLOR)) : 4 === n ? h ? (d.blendEquationSeparate(d.FUNC_ADD, d.FUNC_ADD), d.blendFuncSeparate(d.ZERO, 
				d.SRC_COLOR, d.ZERO, d.SRC_ALPHA)) : (d.blendEquation(d.FUNC_ADD), d.blendFunc(d.ZERO, d.SRC_COLOR)) : h ? (d.blendEquationSeparate(d.FUNC_ADD, d.FUNC_ADD), d.blendFuncSeparate(d.ONE, d.ONE_MINUS_SRC_ALPHA, d.ONE, d.ONE_MINUS_SRC_ALPHA)) : (d.blendEquationSeparate(d.FUNC_ADD, d.FUNC_ADD), d.blendFuncSeparate(d.SRC_ALPHA, d.ONE_MINUS_SRC_ALPHA, d.ONE, d.ONE_MINUS_SRC_ALPHA)), y = n, D = h;
			}
			if (5 === n) {
				E = E || b;
				m = m || g;
				k = k || e;
				if (b !== A || E !== G) {
					d.blendEquationSeparate(a(b), a(E)), A = b, G = E;
				}
				if (g !== x || e !== C || m !== F || k !== L) {
					d.blendFuncSeparate(a(g), a(e), a(m), a(k)), x = g, C = e, F = m, L = k;
				}
			} else {
				L = F = G = C = x = A = null;
			}
		}
		function e(d) {
			p.setFunc(d);
		}
		function m(n) {
			W !== n && (n ? d.frontFace(d.CW) : d.frontFace(d.CCW), W = n);
		}
		function h(n) {
			0 !== n ? (z(d.CULL_FACE), n !== J && (1 === n ? d.cullFace(d.BACK) : 2 === n ? d.cullFace(d.FRONT) : d.cullFace(d.FRONT_AND_BACK))) : c(d.CULL_FACE);
			J = n;
		}
		function q(n) {
			void 0 === n && (n = d.TEXTURE0 + ia - 1);
			N !== n && (d.activeTexture(n), N = n);
		}
		var f = new function() {
			var n = !1, a = new k, b = null, z = new k;
			return {setMask:function(a) {
				b === a || n || (d.colorMask(a, a, a, a), b = a);
			}, setLocked:function(d) {
				n = d;
			}, setClear:function(n, b, c, g, e) {
				!0 === e && (n *= g, b *= g, c *= g);
				a.set(n, b, c, g);
				!1 === z.equals(a) && (d.clearColor(n, b, c, g), z.copy(a));
			}, reset:function() {
				n = !1;
				b = null;
				z.set(0, 0, 0, 1);
			}};
		}, p = new function() {
			var n = !1, a = null, b = null, g = null;
			return {setTest:function(n) {
				n ? z(d.DEPTH_TEST) : c(d.DEPTH_TEST);
			}, setMask:function(b) {
				a === b || n || (d.depthMask(b), a = b);
			}, setFunc:function(n) {
				if (b !== n) {
					if (n) {
						switch(n) {
							case 0:
								d.depthFunc(d.NEVER);
								break;
							case 1:
								d.depthFunc(d.ALWAYS);
								break;
							case 2:
								d.depthFunc(d.LESS);
								break;
							case 3:
								d.depthFunc(d.LEQUAL);
								break;
							case 4:
								d.depthFunc(d.EQUAL);
								break;
							case 5:
								d.depthFunc(d.GEQUAL);
								break;
							case 6:
								d.depthFunc(d.GREATER);
								break;
							case 7:
								d.depthFunc(d.NOTEQUAL);
								break;
							default:
								d.depthFunc(d.LEQUAL);
						}
					} else {
						d.depthFunc(d.LEQUAL);
					}
					b = n;
				}
			}, setLocked:function(d) {
				n = d;
			}, setClear:function(n) {
				g !== n && (d.clearDepth(n), g = n);
			}, reset:function() {
				n = !1;
				g = b = a = null;
			}};
		}, r = new function() {
			var n = !1, a = null, b = null, g = null, e = null, E = null, m = null, k = null, h = null;
			return {setTest:function(n) {
				n ? z(d.STENCIL_TEST) : c(d.STENCIL_TEST);
			}, setMask:function(b) {
				a === b || n || (d.stencilMask(b), a = b);
			}, setFunc:function(n, a, z) {
				if (b !== n || g !== a || e !== z) {
					d.stencilFunc(n, a, z), b = n, g = a, e = z;
				}
			}, setOp:function(n, a, b) {
				if (E !== n || m !== a || k !== b) {
					d.stencilOp(n, a, b), E = n, m = a, k = b;
				}
			}, setLocked:function(d) {
				n = d;
			}, setClear:function(n) {
				h !== n && (d.clearStencil(n), h = n);
			}, reset:function() {
				n = !1;
				h = k = m = E = e = g = b = a = null;
			}};
		}, u = d.getParameter(d.MAX_VERTEX_ATTRIBS), l = new Uint8Array(u), w = new Uint8Array(u), t = new Uint8Array(u), v = {}, B = null, y = null, A = null, x = null, C = null, G = null, F = null, L = null, D = !1, W = null, J = null, I = null, Y = null, M = null, S = null, ia = d.getParameter(d.MAX_TEXTURE_IMAGE_UNITS), N = null, ga = {}, Q = new k, H = new k, ba = {};
		ba[d.TEXTURE_2D] = b(d.TEXTURE_2D, d.TEXTURE_2D, 1);
		ba[d.TEXTURE_CUBE_MAP] = b(d.TEXTURE_CUBE_MAP, d.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
		return {buffers:{color:f, depth:p, stencil:r}, init:function() {
			f.setClear(0, 0, 0, 1);
			p.setClear(1);
			r.setClear(0);
			z(d.DEPTH_TEST);
			e(3);
			m(!1);
			h(1);
			z(d.CULL_FACE);
			z(d.BLEND);
			g(1);
		}, initAttributes:function() {
			for (var d = 0, n = l.length;d < n;d++) {
				l[d] = 0;
			}
		}, enableAttribute:function(a) {
			l[a] = 1;
			0 === w[a] && (d.enableVertexAttribArray(a), w[a] = 1);
			0 !== t[a] && (n.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(a, 0), t[a] = 0);
		}, enableAttributeAndDivisor:function(n, a, b) {
			l[n] = 1;
			0 === w[n] && (d.enableVertexAttribArray(n), w[n] = 1);
			t[n] !== a && (b.vertexAttribDivisorANGLE(n, a), t[n] = a);
		}, disableUnusedAttributes:function() {
			for (var n = 0, a = w.length;n !== a;++n) {
				w[n] !== l[n] && (d.disableVertexAttribArray(n), w[n] = 0);
			}
		}, enable:z, disable:c, getCompressedTextureFormats:function() {
			if (null === B && (B = [], n.get("WEBGL_compressed_texture_pvrtc") || n.get("WEBGL_compressed_texture_s3tc") || n.get("WEBGL_compressed_texture_etc1"))) {
				for (var a = d.getParameter(d.COMPRESSED_TEXTURE_FORMATS), b = 0;b < a.length;b++) {
					B.push(a[b]);
				}
			}
			return B;
		}, setBlending:g, setColorWrite:function(d) {
			f.setMask(d);
		}, setDepthTest:function(d) {
			p.setTest(d);
		}, setDepthWrite:function(d) {
			p.setMask(d);
		}, setDepthFunc:e, setStencilTest:function(d) {
			r.setTest(d);
		}, setStencilWrite:function(d) {
			r.setMask(d);
		}, setStencilFunc:function(d, n, a) {
			r.setFunc(d, n, a);
		}, setStencilOp:function(d, n, a) {
			r.setOp(d, n, a);
		}, setFlipSided:m, setCullFace:h, setLineWidth:function(n) {
			n !== I && (d.lineWidth(n), I = n);
		}, setPolygonOffset:function(n, a, b) {
			if (n) {
				if (z(d.POLYGON_OFFSET_FILL), Y !== a || M !== b) {
					d.polygonOffset(a, b), Y = a, M = b;
				}
			} else {
				c(d.POLYGON_OFFSET_FILL);
			}
		}, getScissorTest:function() {
			return S;
		}, setScissorTest:function(n) {
			(S = n) ? z(d.SCISSOR_TEST) : c(d.SCISSOR_TEST);
		}, activeTexture:q, bindTexture:function(n, a) {
			null === N && q();
			var b = ga[N];
			void 0 === b && (b = {type:void 0, texture:void 0}, ga[N] = b);
			if (b.type !== n || b.texture !== a) {
				d.bindTexture(n, a || ba[n]), b.type = n, b.texture = a;
			}
		}, compressedTexImage2D:function() {
			try {
				d.compressedTexImage2D.apply(d, arguments);
			} catch (Vd) {
				console.error(Vd);
			}
		}, texImage2D:function() {
			try {
				d.texImage2D.apply(d, arguments);
			} catch (Vd) {
				console.error(Vd);
			}
		}, scissor:function(n) {
			!1 === Q.equals(n) && (d.scissor(n.x, n.y, n.z, n.w), Q.copy(n));
		}, viewport:function(n) {
			!1 === H.equals(n) && (d.viewport(n.x, n.y, n.z, n.w), H.copy(n));
		}, reset:function() {
			for (var n = 0;n < w.length;n++) {
				1 === w[n] && (d.disableVertexAttribArray(n), w[n] = 0);
			}
			v = {};
			N = B = null;
			ga = {};
			J = W = y = null;
			f.reset();
			p.reset();
			r.reset();
		}};
	}
	function Ze(d, n, a) {
		function b(n) {
			if ("highp" === n) {
				if (0 < d.getShaderPrecisionFormat(d.VERTEX_SHADER, d.HIGH_FLOAT).precision && 0 < d.getShaderPrecisionFormat(d.FRAGMENT_SHADER, d.HIGH_FLOAT).precision) {
					return "highp";
				}
				n = "mediump";
			}
			return "mediump" === n && 0 < d.getShaderPrecisionFormat(d.VERTEX_SHADER, d.MEDIUM_FLOAT).precision && 0 < d.getShaderPrecisionFormat(d.FRAGMENT_SHADER, d.MEDIUM_FLOAT).precision ? "mediump" : "lowp";
		}
		var z, c = void 0 !== a.precision ? a.precision : "highp", g = b(c);
		g !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", g, "instead."), c = g);
		a = !0 === a.logarithmicDepthBuffer && !!n.get("EXT_frag_depth");
		var g = d.getParameter(d.MAX_TEXTURE_IMAGE_UNITS), e = d.getParameter(d.MAX_VERTEX_TEXTURE_IMAGE_UNITS), m = d.getParameter(d.MAX_TEXTURE_SIZE), k = d.getParameter(d.MAX_CUBE_MAP_TEXTURE_SIZE), h = d.getParameter(d.MAX_VERTEX_ATTRIBS), q = d.getParameter(d.MAX_VERTEX_UNIFORM_VECTORS), f = d.getParameter(d.MAX_VARYING_VECTORS), p = d.getParameter(d.MAX_FRAGMENT_UNIFORM_VECTORS), r = 0 < e, u = !!n.get("OES_texture_float");
		return {getMaxAnisotropy:function() {
			if (void 0 !== z) {
				return z;
			}
			var a = n.get("EXT_texture_filter_anisotropic");
			return z = null !== a ? d.getParameter(a.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
		}, getMaxPrecision:b, precision:c, logarithmicDepthBuffer:a, maxTextures:g, maxVertexTextures:e, maxTextureSize:m, maxCubemapSize:k, maxAttributes:h, maxVertexUniforms:q, maxVaryings:f, maxFragmentUniforms:p, vertexTextures:r, floatFragmentTextures:u, floatVertexTextures:r && u};
	}
	function $e(d) {
		var n = {};
		return {get:function(a) {
			if (void 0 !== n[a]) {
				return n[a];
			}
			var b;
			switch(a) {
				case "WEBGL_depth_texture":
					b = d.getExtension("WEBGL_depth_texture") || d.getExtension("MOZ_WEBGL_depth_texture") || d.getExtension("WEBKIT_WEBGL_depth_texture");
					break;
				case "EXT_texture_filter_anisotropic":
					b = d.getExtension("EXT_texture_filter_anisotropic") || d.getExtension("MOZ_EXT_texture_filter_anisotropic") || d.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
					break;
				case "WEBGL_compressed_texture_s3tc":
					b = d.getExtension("WEBGL_compressed_texture_s3tc") || d.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || d.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
					break;
				case "WEBGL_compressed_texture_pvrtc":
					b = d.getExtension("WEBGL_compressed_texture_pvrtc") || d.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
					break;
				case "WEBGL_compressed_texture_etc1":
					b = d.getExtension("WEBGL_compressed_texture_etc1");
					break;
				default:
					b = d.getExtension(a);
			}
			null === b && console.warn("THREE.WebGLRenderer: " + a + " extension not supported.");
			return n[a] = b;
		}};
	}
	function af() {
		function d() {
			h.value !== b && (h.value = b, h.needsUpdate = 0 < c);
			a.numPlanes = c;
			a.numIntersection = 0;
		}
		function n(d, n, b, z) {
			var c = null !== d ? d.length : 0, g = null;
			if (0 !== c) {
				g = h.value;
				if (!0 !== z || null === g) {
					z = b + 4 * c;
					n = n.matrixWorldInverse;
					k.getNormalMatrix(n);
					if (null === g || g.length < z) {
						g = new Float32Array(z);
					}
					for (z = 0;z !== c;++z, b += 4) {
						m.copy(d[z]).applyMatrix4(n, k), m.normal.toArray(g, b), g[b + 3] = m.constant;
					}
				}
				h.value = g;
				h.needsUpdate = !0;
			}
			a.numPlanes = c;
			return g;
		}
		var a = this, b = null, c = 0, g = !1, e = !1, m = new wa, k = new ya, h = {value:null, needsUpdate:!1};
		this.uniform = h;
		this.numIntersection = this.numPlanes = 0;
		this.init = function(d, a, z) {
			var e = 0 !== d.length || a || 0 !== c || g;
			g = a;
			b = n(d, z, 0);
			c = d.length;
			return e;
		};
		this.beginShadows = function() {
			e = !0;
			n(null);
		};
		this.endShadows = function() {
			e = !1;
			d();
		};
		this.setState = function(a, z, m, E, k, q) {
			if (!g || null === a || 0 === a.length || e && !m) {
				e ? n(null) : d();
			} else {
				m = e ? 0 : c;
				var f = 4 * m, p = k.clippingState || null;
				h.value = p;
				p = n(a, E, f, q);
				for (a = 0;a !== f;++a) {
					p[a] = b[a];
				}
				k.clippingState = p;
				this.numIntersection = z ? this.numPlanes : 0;
				this.numPlanes += m;
			}
		};
	}
	function Xd(d) {
		function n() {
			ma.init();
			ma.scissor(ra.copy(Jc).multiplyScalar(Ua));
			ma.viewport(Ab.copy(X).multiplyScalar(Ua));
			ma.buffers.color.setClear(Pa.r, Pa.g, Pa.b, nb, D);
		}
		function a() {
			pa = H = null;
			V = "";
			ha = -1;
			ma.reset();
		}
		function b(d) {
			d.preventDefault();
			a();
			n();
			Qa.clear();
		}
		function c(d) {
			d = d.target;
			d.removeEventListener("dispose", c);
			e(d);
			Qa["delete"](d);
		}
		function e(d) {
			var n = Qa.get(d).program;
			d.program = void 0;
			void 0 !== n && xa.releaseProgram(n);
		}
		function m(d, n) {
			return Math.abs(n[0]) - Math.abs(d[0]);
		}
		function h(d, n) {
			return d.object.renderOrder !== n.object.renderOrder ? d.object.renderOrder - n.object.renderOrder : d.material.program && n.material.program && d.material.program !== n.material.program ? d.material.program.id - n.material.program.id : d.material.id !== n.material.id ? d.material.id - n.material.id : d.z !== n.z ? d.z - n.z : d.id - n.id;
		}
		function f(d, n) {
			return d.object.renderOrder !== n.object.renderOrder ? d.object.renderOrder - n.object.renderOrder : d.z !== n.z ? n.z - d.z : d.id - n.id;
		}
		function p(d, n, a, b, z) {
			var c;
			a.transparent ? (b = M, c = ++S) : (b = I, c = ++Y);
			c = b[c];
			void 0 !== c ? (c.id = d.id, c.object = d, c.geometry = n, c.material = a, c.z = da.z, c.group = z) : (c = {id:d.id, object:d, geometry:n, material:a, z:da.z, group:z}, b.push(c));
		}
		function r(d) {
			if (!Ba.intersectsSphere(d)) {
				return !1;
			}
			var n = sa.numPlanes;
			if (0 === n) {
				return !0;
			}
			var a = Q.clippingPlanes, b = d.center;
			d = -d.radius;
			var z = 0;
			do {
				if (a[z].distanceToPoint(b) < d) {
					return !1;
				}
			} while (++z !== n);
			return !0;
		}
		function u(d, n) {
			if (!1 !== d.visible) {
				if (0 !== (d.layers.mask & n.layers.mask)) {
					if (d.isLight) {
						J.push(d);
					} else {
						if (d.isSprite) {
							var a;
							(a = !1 === d.frustumCulled) || (db.center.set(0, 0, 0), db.radius = .7071067811865476, db.applyMatrix4(d.matrixWorld), a = !0 === r(db));
							a && N.push(d);
						} else {
							if (d.isLensFlare) {
								ga.push(d);
							} else {
								if (d.isImmediateRenderObject) {
									!0 === Q.sortObjects && (da.setFromMatrixPosition(d.matrixWorld), da.applyProjection(la)), p(d, null, d.material, da.z, null);
								} else {
									if (d.isMesh || d.isLine || d.isPoints) {
										if (d.isSkinnedMesh && d.skeleton.update(), (a = !1 === d.frustumCulled) || (a = d.geometry, null === a.boundingSphere && a.computeBoundingSphere(), db.copy(a.boundingSphere).applyMatrix4(d.matrixWorld), a = !0 === r(db)), a) {
											var b = d.material;
											if (!0 === b.visible) {
												if (!0 === Q.sortObjects && (da.setFromMatrixPosition(d.matrixWorld), da.applyProjection(la)), a = ta.update(d), b.isMultiMaterial) {
													for (var z = a.groups, c = b.materials, b = 0, g = z.length;b < g;b++) {
														var e = z[b], m = c[e.materialIndex];
														!0 === m.visible && p(d, a, m, da.z, e);
													}
												} else {
													p(d, a, b, da.z, null);
												}
											}
										}
									}
								}
							}
						}
					}
				}
				a = d.children;
				b = 0;
				for (g = a.length;b < g;b++) {
					u(a[b], n);
				}
			}
		}
		function l(d, n, a, b) {
			for (var z = 0, c = d.length;z < c;z++) {
				var g = d[z], e = g.object, m = g.geometry, E = void 0 === b ? g.material : b, g = g.group;
				e.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, e.matrixWorld);
				e.normalMatrix.getNormalMatrix(e.modelViewMatrix);
				e.onBeforeRender(Q, n, a, m, E, g);
				if (e.isImmediateRenderObject) {
					w(E);
					var h = t(a, n.fog, E, e);
					V = "";
					e.render(function(d) {
						Q.renderBufferImmediate(d, h, E);
					});
				} else {
					Q.renderBufferDirect(a, n.fog, m, E, e, g);
				}
				e.onAfterRender(Q, n, a, m, E, g);
			}
		}
		function w(d) {
			2 === d.side ? ma.disable(K.CULL_FACE) : ma.enable(K.CULL_FACE);
			ma.setFlipSided(1 === d.side);
			!0 === d.transparent ? ma.setBlending(d.blending, d.blendEquation, d.blendSrc, d.blendDst, d.blendEquationAlpha, d.blendSrcAlpha, d.blendDstAlpha, d.premultipliedAlpha) : ma.setBlending(0);
			ma.setDepthFunc(d.depthFunc);
			ma.setDepthTest(d.depthTest);
			ma.setDepthWrite(d.depthWrite);
			ma.setColorWrite(d.colorWrite);
			ma.setPolygonOffset(d.polygonOffset, d.polygonOffsetFactor, d.polygonOffsetUnits);
		}
		function t(d, n, a, b) {
			Z = 0;
			var z = Qa.get(a);
			ya && (ja || d !== pa) && sa.setState(a.clippingPlanes, a.clipIntersection, a.clipShadows, d, z, d === pa && a.id === ha);
			!1 === a.needsUpdate && (void 0 === z.program ? a.needsUpdate = !0 : a.fog && z.fog !== n ? a.needsUpdate = !0 : a.lights && z.lightsHash !== oa.hash ? a.needsUpdate = !0 : void 0 === z.numClippingPlanes || z.numClippingPlanes === sa.numPlanes && z.numIntersection === sa.numIntersection || (a.needsUpdate = !0));
			if (a.needsUpdate) {
				a: {
					var g = Qa.get(a), m = xa.getParameters(a, oa, n, sa.numPlanes, sa.numIntersection, b), E = xa.getProgramCode(a, m), h = g.program, k = !0;
					if (void 0 === h) {
						a.addEventListener("dispose", c);
					} else {
						if (h.code !== E) {
							e(a);
						} else {
							if (void 0 !== m.shaderID) {
								break a;
							} else {
								k = !1;
							}
						}
					}
					k && (m.shaderID ? (h = Wb[m.shaderID], g.__webglShader = {name:a.type, uniforms:Object.assign({}, h.uniforms), vertexShader:h.vertexShader, fragmentShader:h.fragmentShader}) : g.__webglShader = {name:a.type, uniforms:a.uniforms, vertexShader:a.vertexShader, fragmentShader:a.fragmentShader}, a.__webglShader = g.__webglShader, h = xa.acquireProgram(a, m, E), g.program = h, a.program = h);
					m = h.getAttributes();
					if (a.morphTargets) {
						for (E = a.numSupportedMorphTargets = 0;E < Q.maxMorphTargets;E++) {
							0 <= m["morphTarget" + E] && a.numSupportedMorphTargets++;
						}
					}
					if (a.morphNormals) {
						for (E = a.numSupportedMorphNormals = 0;E < Q.maxMorphNormals;E++) {
							0 <= m["morphNormal" + E] && a.numSupportedMorphNormals++;
						}
					}
					m = g.__webglShader.uniforms;
					if (!a.isShaderMaterial && !a.isRawShaderMaterial || !0 === a.clipping) {
						g.numClippingPlanes = sa.numPlanes, g.numIntersection = sa.numIntersection, m.clippingPlanes = sa.uniform;
					}
					g.fog = n;
					g.lightsHash = oa.hash;
					a.lights && (m.ambientLightColor.value = oa.ambient, m.directionalLights.value = oa.directional, m.spotLights.value = oa.spot, m.rectAreaLights.value = oa.rectArea, m.pointLights.value = oa.point, m.hemisphereLights.value = oa.hemi, m.directionalShadowMap.value = oa.directionalShadowMap, m.directionalShadowMatrix.value = oa.directionalShadowMatrix, m.spotShadowMap.value = oa.spotShadowMap, m.spotShadowMatrix.value = oa.spotShadowMatrix, m.pointShadowMap.value = oa.pointShadowMap, m.pointShadowMatrix.value = 
					oa.pointShadowMatrix);
					E = g.program.getUniforms();
					m = va.seqWithValue(E.seq, m);
					g.uniformsList = m;
				}
				a.needsUpdate = !1;
			}
			var q = !1, k = h = !1, g = z.program, m = g.getUniforms(), E = z.__webglShader.uniforms;
			g.id !== H && (K.useProgram(g.program), H = g.id, k = h = q = !0);
			a.id !== ha && (ha = a.id, h = !0);
			if (q || d !== pa) {
				m.set(K, d, "projectionMatrix");
				Va.logarithmicDepthBuffer && m.setValue(K, "logDepthBufFC", 2 / (Math.log(d.far + 1) / Math.LN2));
				d !== pa && (pa = d, k = h = !0);
				if (a.isShaderMaterial || a.isMeshPhongMaterial || a.isMeshStandardMaterial || a.envMap) {
					q = m.map.cameraPosition, void 0 !== q && q.setValue(K, da.setFromMatrixPosition(d.matrixWorld));
				}
				(a.isMeshPhongMaterial || a.isMeshLambertMaterial || a.isMeshBasicMaterial || a.isMeshStandardMaterial || a.isShaderMaterial || a.skinning) && m.setValue(K, "viewMatrix", d.matrixWorldInverse);
				m.set(K, Q, "toneMappingExposure");
				m.set(K, Q, "toneMappingWhitePoint");
			}
			a.skinning && (m.setOptional(K, b, "bindMatrix"), m.setOptional(K, b, "bindMatrixInverse"), d = b.skeleton) && (Va.floatVertexTextures && d.useVertexTexture ? (m.set(K, d, "boneTexture"), m.set(K, d, "boneTextureWidth"), m.set(K, d, "boneTextureHeight")) : m.setOptional(K, d, "boneMatrices"));
			if (h) {
				a.lights && (d = k, E.ambientLightColor.needsUpdate = d, E.directionalLights.needsUpdate = d, E.pointLights.needsUpdate = d, E.spotLights.needsUpdate = d, E.rectAreaLights.needsUpdate = d, E.hemisphereLights.needsUpdate = d);
				n && a.fog && (E.fogColor.value = n.color, n.isFog ? (E.fogNear.value = n.near, E.fogFar.value = n.far) : n.isFogExp2 && (E.fogDensity.value = n.density));
				if (a.isMeshBasicMaterial || a.isMeshLambertMaterial || a.isMeshPhongMaterial || a.isMeshStandardMaterial || a.isMeshDepthMaterial) {
					E.opacity.value = a.opacity;
					E.diffuse.value = a.color;
					a.emissive && E.emissive.value.copy(a.emissive).multiplyScalar(a.emissiveIntensity);
					E.map.value = a.map;
					E.specularMap.value = a.specularMap;
					E.alphaMap.value = a.alphaMap;
					a.lightMap && (E.lightMap.value = a.lightMap, E.lightMapIntensity.value = a.lightMapIntensity);
					a.aoMap && (E.aoMap.value = a.aoMap, E.aoMapIntensity.value = a.aoMapIntensity);
					var f;
					a.map ? f = a.map : a.specularMap ? f = a.specularMap : a.displacementMap ? f = a.displacementMap : a.normalMap ? f = a.normalMap : a.bumpMap ? f = a.bumpMap : a.roughnessMap ? f = a.roughnessMap : a.metalnessMap ? f = a.metalnessMap : a.alphaMap ? f = a.alphaMap : a.emissiveMap && (f = a.emissiveMap);
					void 0 !== f && (f.isWebGLRenderTarget && (f = f.texture), n = f.offset, f = f.repeat, E.offsetRepeat.value.set(n.x, n.y, f.x, f.y));
					E.envMap.value = a.envMap;
					E.flipEnvMap.value = a.envMap && a.envMap.isCubeTexture ? -1 : 1;
					E.reflectivity.value = a.reflectivity;
					E.refractionRatio.value = a.refractionRatio;
				}
				a.isLineBasicMaterial ? (E.diffuse.value = a.color, E.opacity.value = a.opacity) : a.isLineDashedMaterial ? (E.diffuse.value = a.color, E.opacity.value = a.opacity, E.dashSize.value = a.dashSize, E.totalSize.value = a.dashSize + a.gapSize, E.scale.value = a.scale) : a.isPointsMaterial ? (E.diffuse.value = a.color, E.opacity.value = a.opacity, E.size.value = a.size * Ua, E.scale.value = .5 * U, E.map.value = a.map, null !== a.map && (f = a.map.offset, a = a.map.repeat, E.offsetRepeat.value.set(f.x, 
				f.y, a.x, a.y))) : a.isMeshLambertMaterial ? a.emissiveMap && (E.emissiveMap.value = a.emissiveMap) : a.isMeshToonMaterial ? (v(E, a), a.gradientMap && (E.gradientMap.value = a.gradientMap)) : a.isMeshPhongMaterial ? v(E, a) : a.isMeshPhysicalMaterial ? (E.clearCoat.value = a.clearCoat, E.clearCoatRoughness.value = a.clearCoatRoughness, B(E, a)) : a.isMeshStandardMaterial ? B(E, a) : a.isMeshDepthMaterial ? a.displacementMap && (E.displacementMap.value = a.displacementMap, E.displacementScale.value = 
				a.displacementScale, E.displacementBias.value = a.displacementBias) : a.isMeshNormalMaterial && (E.opacity.value = a.opacity);
				va.upload(K, z.uniformsList, E, Q);
			}
			m.set(K, b, "modelViewMatrix");
			m.set(K, b, "normalMatrix");
			m.setValue(K, "modelMatrix", b.matrixWorld);
			return g;
		}
		function v(d, n) {
			d.specular.value = n.specular;
			d.shininess.value = Math.max(n.shininess, 1E-4);
			n.emissiveMap && (d.emissiveMap.value = n.emissiveMap);
			n.bumpMap && (d.bumpMap.value = n.bumpMap, d.bumpScale.value = n.bumpScale);
			n.normalMap && (d.normalMap.value = n.normalMap, d.normalScale.value.copy(n.normalScale));
			n.displacementMap && (d.displacementMap.value = n.displacementMap, d.displacementScale.value = n.displacementScale, d.displacementBias.value = n.displacementBias);
		}
		function B(d, n) {
			d.roughness.value = n.roughness;
			d.metalness.value = n.metalness;
			n.roughnessMap && (d.roughnessMap.value = n.roughnessMap);
			n.metalnessMap && (d.metalnessMap.value = n.metalnessMap);
			n.emissiveMap && (d.emissiveMap.value = n.emissiveMap);
			n.bumpMap && (d.bumpMap.value = n.bumpMap, d.bumpScale.value = n.bumpScale);
			n.normalMap && (d.normalMap.value = n.normalMap, d.normalScale.value.copy(n.normalScale));
			n.displacementMap && (d.displacementMap.value = n.displacementMap, d.displacementScale.value = n.displacementScale, d.displacementBias.value = n.displacementBias);
			n.envMap && (d.envMapIntensity.value = n.envMapIntensity);
		}
		function y(d) {
			var n;
			if (1E3 === d) {
				return K.REPEAT;
			}
			if (1001 === d) {
				return K.CLAMP_TO_EDGE;
			}
			if (1002 === d) {
				return K.MIRRORED_REPEAT;
			}
			if (1003 === d) {
				return K.NEAREST;
			}
			if (1004 === d) {
				return K.NEAREST_MIPMAP_NEAREST;
			}
			if (1005 === d) {
				return K.NEAREST_MIPMAP_LINEAR;
			}
			if (1006 === d) {
				return K.LINEAR;
			}
			if (1007 === d) {
				return K.LINEAR_MIPMAP_NEAREST;
			}
			if (1008 === d) {
				return K.LINEAR_MIPMAP_LINEAR;
			}
			if (1009 === d) {
				return K.UNSIGNED_BYTE;
			}
			if (1017 === d) {
				return K.UNSIGNED_SHORT_4_4_4_4;
			}
			if (1018 === d) {
				return K.UNSIGNED_SHORT_5_5_5_1;
			}
			if (1019 === d) {
				return K.UNSIGNED_SHORT_5_6_5;
			}
			if (1010 === d) {
				return K.BYTE;
			}
			if (1011 === d) {
				return K.SHORT;
			}
			if (1012 === d) {
				return K.UNSIGNED_SHORT;
			}
			if (1013 === d) {
				return K.INT;
			}
			if (1014 === d) {
				return K.UNSIGNED_INT;
			}
			if (1015 === d) {
				return K.FLOAT;
			}
			if (1016 === d && (n = ka.get("OES_texture_half_float"), null !== n)) {
				return n.HALF_FLOAT_OES;
			}
			if (1021 === d) {
				return K.ALPHA;
			}
			if (1022 === d) {
				return K.RGB;
			}
			if (1023 === d) {
				return K.RGBA;
			}
			if (1024 === d) {
				return K.LUMINANCE;
			}
			if (1025 === d) {
				return K.LUMINANCE_ALPHA;
			}
			if (1026 === d) {
				return K.DEPTH_COMPONENT;
			}
			if (1027 === d) {
				return K.DEPTH_STENCIL;
			}
			if (100 === d) {
				return K.FUNC_ADD;
			}
			if (101 === d) {
				return K.FUNC_SUBTRACT;
			}
			if (102 === d) {
				return K.FUNC_REVERSE_SUBTRACT;
			}
			if (200 === d) {
				return K.ZERO;
			}
			if (201 === d) {
				return K.ONE;
			}
			if (202 === d) {
				return K.SRC_COLOR;
			}
			if (203 === d) {
				return K.ONE_MINUS_SRC_COLOR;
			}
			if (204 === d) {
				return K.SRC_ALPHA;
			}
			if (205 === d) {
				return K.ONE_MINUS_SRC_ALPHA;
			}
			if (206 === d) {
				return K.DST_ALPHA;
			}
			if (207 === d) {
				return K.ONE_MINUS_DST_ALPHA;
			}
			if (208 === d) {
				return K.DST_COLOR;
			}
			if (209 === d) {
				return K.ONE_MINUS_DST_COLOR;
			}
			if (210 === d) {
				return K.SRC_ALPHA_SATURATE;
			}
			if (2001 === d || 2002 === d || 2003 === d || 2004 === d) {
				if (n = ka.get("WEBGL_compressed_texture_s3tc"), null !== n) {
					if (2001 === d) {
						return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
					}
					if (2002 === d) {
						return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					}
					if (2003 === d) {
						return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					}
					if (2004 === d) {
						return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
					}
				}
			}
			if (2100 === d || 2101 === d || 2102 === d || 2103 === d) {
				if (n = ka.get("WEBGL_compressed_texture_pvrtc"), null !== n) {
					if (2100 === d) {
						return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					}
					if (2101 === d) {
						return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					}
					if (2102 === d) {
						return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					}
					if (2103 === d) {
						return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
					}
				}
			}
			if (2151 === d && (n = ka.get("WEBGL_compressed_texture_etc1"), null !== n)) {
				return n.COMPRESSED_RGB_ETC1_WEBGL;
			}
			if (103 === d || 104 === d) {
				if (n = ka.get("EXT_blend_minmax"), null !== n) {
					if (103 === d) {
						return n.MIN_EXT;
					}
					if (104 === d) {
						return n.MAX_EXT;
					}
				}
			}
			return 1020 === d && (n = ka.get("WEBGL_depth_texture"), null !== n) ? n.UNSIGNED_INT_24_8_WEBGL : 0;
		}
		console.log("THREE.WebGLRenderer", "83dev");
		d = d || {};
		var A = void 0 !== d.canvas ? d.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), x = void 0 !== d.context ? d.context : null, C = void 0 !== d.alpha ? d.alpha : !1, G = void 0 !== d.depth ? d.depth : !0, F = void 0 !== d.stencil ? d.stencil : !0, L = void 0 !== d.antialias ? d.antialias : !1, D = void 0 !== d.premultipliedAlpha ? d.premultipliedAlpha : !0, W = void 0 !== d.preserveDrawingBuffer ? d.preserveDrawingBuffer : !1, J = [], I = [], Y = -1, M = [], S = -1, 
		ia = new Float32Array(8), N = [], ga = [];
		this.domElement = A;
		this.context = null;
		this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
		this.clippingPlanes = [];
		this.localClippingEnabled = !1;
		this.gammaFactor = 2;
		this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1;
		this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1;
		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;
		var Q = this, H = null, ba = null, R = null, ha = -1, V = "", pa = null, ra = new k, Ic = null, Ab = new k, Z = 0, Pa = new T(0), nb = 0, yb = A.width, U = A.height, Ua = 1, Jc = new k(0, 0, yb, U), sd = !1, X = new k(0, 0, yb, U), Ba = new Sa, sa = new af, ya = !1, ja = !1, db = new Ca, la = new q, da = new g, Zb = new q, na = new q, oa = {hash:"", ambient:[0, 0, 0], directional:[], directionalShadowMap:[], directionalShadowMatrix:[], spot:[], spotShadowMap:[], spotShadowMatrix:[], rectArea:[], 
		point:[], pointShadowMap:[], pointShadowMatrix:[], hemi:[], shadows:[]}, wa = {calls:0, vertices:0, faces:0, points:0};
		this.info = {render:wa, memory:{geometries:0, textures:0}, programs:null};
		var K;
		try {
			C = {alpha:C, depth:G, stencil:F, antialias:L, premultipliedAlpha:D, preserveDrawingBuffer:W};
			K = x || A.getContext("webgl", C) || A.getContext("experimental-webgl", C);
			if (null === K) {
				if (null !== A.getContext("webgl")) {
					throw "Error creating WebGL context with your selected attributes.";
				}
				throw "Error creating WebGL context.";
			}
			void 0 === K.getShaderPrecisionFormat && (K.getShaderPrecisionFormat = function() {
				return {rangeMin:1, rangeMax:1, precision:1};
			});
			A.addEventListener("webglcontextlost", b, !1);
		} catch (bf) {
			console.error("THREE.WebGLRenderer: " + bf);
		}
		var ka = new $e(K);
		ka.get("WEBGL_depth_texture");
		ka.get("OES_texture_float");
		ka.get("OES_texture_float_linear");
		ka.get("OES_texture_half_float");
		ka.get("OES_texture_half_float_linear");
		ka.get("OES_standard_derivatives");
		ka.get("ANGLE_instanced_arrays");
		ka.get("OES_element_index_uint") && (ca.MaxIndex = 4294967296);
		var Va = new Ze(K, ka, d), ma = new Ye(K, ka, y), Qa = new Xe, zb = new We(K, ka, ma, Qa, Va, y, this.info), ta = new Ve(K, Qa, this.info), xa = new Ue(this, Va), Bb = new Se;
		this.info.programs = xa.programs;
		var Ha = new Re(K, ka, wa), Ia = new Qe(K, ka, wa), Ja = new Yb(-1, 1, 1, -1, 0, 1), za = new Oa, Aa = new Da(new Ra(2, 2), new La({depthTest:!1, depthWrite:!1, fog:!1}));
		d = Wb.cube;
		var Ea = new Da(new mb(5, 5, 5), new ua({uniforms:d.uniforms, vertexShader:d.vertexShader, fragmentShader:d.fragmentShader, side:1, depthTest:!1, depthWrite:!1, fog:!1}));
		n();
		this.context = K;
		this.capabilities = Va;
		this.extensions = ka;
		this.properties = Qa;
		this.state = ma;
		var Ka = new rd(this, oa, ta, Va);
		this.shadowMap = Ka;
		var Ma = new ea(this, N), Na = new qa(this, ga);
		this.getContext = function() {
			return K;
		};
		this.getContextAttributes = function() {
			return K.getContextAttributes();
		};
		this.forceContextLoss = function() {
			ka.get("WEBGL_lose_context").loseContext();
		};
		this.getMaxAnisotropy = function() {
			return Va.getMaxAnisotropy();
		};
		this.getPrecision = function() {
			return Va.precision;
		};
		this.getPixelRatio = function() {
			return Ua;
		};
		this.setPixelRatio = function(d) {
			void 0 !== d && (Ua = d, this.setSize(X.z, X.w, !1));
		};
		this.getSize = function() {
			return {width:yb, height:U};
		};
		this.setSize = function(d, n, a) {
			yb = d;
			U = n;
			A.width = d * Ua;
			A.height = n * Ua;
			!1 !== a && (A.style.width = d + "px", A.style.height = n + "px");
			this.setViewport(0, 0, d, n);
		};
		this.setViewport = function(d, n, a, b) {
			ma.viewport(X.set(d, n, a, b));
		};
		this.setScissor = function(d, n, a, b) {
			ma.scissor(Jc.set(d, n, a, b));
		};
		this.setScissorTest = function(d) {
			ma.setScissorTest(sd = d);
		};
		this.getClearColor = function() {
			return Pa;
		};
		this.setClearColor = function(d, n) {
			Pa.set(d);
			nb = void 0 !== n ? n : 1;
			ma.buffers.color.setClear(Pa.r, Pa.g, Pa.b, nb, D);
		};
		this.getClearAlpha = function() {
			return nb;
		};
		this.setClearAlpha = function(d) {
			nb = d;
			ma.buffers.color.setClear(Pa.r, Pa.g, Pa.b, nb, D);
		};
		this.clear = function(d, n, a) {
			var b = 0;
			if (void 0 === d || d) {
				b |= K.COLOR_BUFFER_BIT;
			}
			if (void 0 === n || n) {
				b |= K.DEPTH_BUFFER_BIT;
			}
			if (void 0 === a || a) {
				b |= K.STENCIL_BUFFER_BIT;
			}
			K.clear(b);
		};
		this.clearColor = function() {
			this.clear(!0, !1, !1);
		};
		this.clearDepth = function() {
			this.clear(!1, !0, !1);
		};
		this.clearStencil = function() {
			this.clear(!1, !1, !0);
		};
		this.clearTarget = function(d, n, a, b) {
			this.setRenderTarget(d);
			this.clear(n, a, b);
		};
		this.resetGLState = a;
		this.dispose = function() {
			M = [];
			S = -1;
			I = [];
			Y = -1;
			A.removeEventListener("webglcontextlost", b, !1);
		};
		this.renderBufferImmediate = function(d, n, a) {
			ma.initAttributes();
			var b = Qa.get(d);
			d.hasPositions && !b.position && (b.position = K.createBuffer());
			d.hasNormals && !b.normal && (b.normal = K.createBuffer());
			d.hasUvs && !b.uv && (b.uv = K.createBuffer());
			d.hasColors && !b.color && (b.color = K.createBuffer());
			n = n.getAttributes();
			d.hasPositions && (K.bindBuffer(K.ARRAY_BUFFER, b.position), K.bufferData(K.ARRAY_BUFFER, d.positionArray, K.DYNAMIC_DRAW), ma.enableAttribute(n.position), K.vertexAttribPointer(n.position, 3, K.FLOAT, !1, 0, 0));
			if (d.hasNormals) {
				K.bindBuffer(K.ARRAY_BUFFER, b.normal);
				if (!a.isMeshPhongMaterial && !a.isMeshStandardMaterial && 1 === a.shading) {
					for (var z = 0, c = 3 * d.count;z < c;z += 9) {
						var g = d.normalArray, e = (g[z + 0] + g[z + 3] + g[z + 6]) / 3, m = (g[z + 1] + g[z + 4] + g[z + 7]) / 3, E = (g[z + 2] + g[z + 5] + g[z + 8]) / 3;
						g[z + 0] = e;
						g[z + 1] = m;
						g[z + 2] = E;
						g[z + 3] = e;
						g[z + 4] = m;
						g[z + 5] = E;
						g[z + 6] = e;
						g[z + 7] = m;
						g[z + 8] = E;
					}
				}
				K.bufferData(K.ARRAY_BUFFER, d.normalArray, K.DYNAMIC_DRAW);
				ma.enableAttribute(n.normal);
				K.vertexAttribPointer(n.normal, 3, K.FLOAT, !1, 0, 0);
			}
			d.hasUvs && a.map && (K.bindBuffer(K.ARRAY_BUFFER, b.uv), K.bufferData(K.ARRAY_BUFFER, d.uvArray, K.DYNAMIC_DRAW), ma.enableAttribute(n.uv), K.vertexAttribPointer(n.uv, 2, K.FLOAT, !1, 0, 0));
			d.hasColors && 0 !== a.vertexColors && (K.bindBuffer(K.ARRAY_BUFFER, b.color), K.bufferData(K.ARRAY_BUFFER, d.colorArray, K.DYNAMIC_DRAW), ma.enableAttribute(n.color), K.vertexAttribPointer(n.color, 3, K.FLOAT, !1, 0, 0));
			ma.disableUnusedAttributes();
			K.drawArrays(K.TRIANGLES, 0, d.count);
			d.count = 0;
		};
		this.renderBufferDirect = function(d, n, a, b, z, g) {
			w(b);
			var c = t(d, n, b, z), e = !1;
			d = a.id + "_" + c.id + "_" + b.wireframe;
			d !== V && (V = d, e = !0);
			n = z.morphTargetInfluences;
			if (void 0 !== n) {
				var E = [];
				d = 0;
				for (var h = n.length;d < h;d++) {
					e = n[d], E.push([e, d]);
				}
				E.sort(m);
				8 < E.length && (E.length = 8);
				var k = a.morphAttributes;
				d = 0;
				for (h = E.length;d < h;d++) {
					e = E[d], ia[d] = e[0], 0 !== e[0] ? (n = e[1], !0 === b.morphTargets && k.position && a.addAttribute("morphTarget" + d, k.position[n]), !0 === b.morphNormals && k.normal && a.addAttribute("morphNormal" + d, k.normal[n])) : (!0 === b.morphTargets && a.removeAttribute("morphTarget" + d), !0 === b.morphNormals && a.removeAttribute("morphNormal" + d));
				}
				d = E.length;
				for (n = ia.length;d < n;d++) {
					ia[d] = 0;
				}
				c.getUniforms().setValue(K, "morphTargetInfluences", ia);
				e = !0;
			}
			n = a.index;
			h = a.attributes.position;
			E = 1;
			!0 === b.wireframe && (n = ta.getWireframeAttribute(a), E = 2);
			null !== n ? (d = Ia, d.setIndex(n)) : d = Ha;
			if (e) {
				var e = void 0, q;
				if (a && a.isInstancedBufferGeometry && (q = ka.get("ANGLE_instanced_arrays"), null === q)) {
					console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
				} else {
					void 0 === e && (e = 0);
					ma.initAttributes();
					var k = a.attributes, c = c.getAttributes(), f = b.defaultAttributeValues, p;
					for (p in c) {
						var r = c[p];
						if (0 <= r) {
							var u = k[p];
							if (void 0 !== u) {
								var l = u.normalized, P = u.itemSize, aa = ta.getAttributeProperties(u), v = aa.__webglBuffer, fa = aa.type, aa = aa.bytesPerElement;
								if (u.isInterleavedBufferAttribute) {
									var B = u.data, y = B.stride, u = u.offset;
									B && B.isInstancedInterleavedBuffer ? (ma.enableAttributeAndDivisor(r, B.meshPerAttribute, q), void 0 === a.maxInstancedCount && (a.maxInstancedCount = B.meshPerAttribute * B.count)) : ma.enableAttribute(r);
									K.bindBuffer(K.ARRAY_BUFFER, v);
									K.vertexAttribPointer(r, P, fa, l, y * aa, (e * y + u) * aa);
								} else {
									u.isInstancedBufferAttribute ? (ma.enableAttributeAndDivisor(r, u.meshPerAttribute, q), void 0 === a.maxInstancedCount && (a.maxInstancedCount = u.meshPerAttribute * u.count)) : ma.enableAttribute(r), K.bindBuffer(K.ARRAY_BUFFER, v), K.vertexAttribPointer(r, P, fa, l, 0, e * P * aa);
								}
							} else {
								if (void 0 !== f && (l = f[p], void 0 !== l)) {
									switch(l.length) {
										case 2:
											K.vertexAttrib2fv(r, l);
											break;
										case 3:
											K.vertexAttrib3fv(r, l);
											break;
										case 4:
											K.vertexAttrib4fv(r, l);
											break;
										default:
											K.vertexAttrib1fv(r, l);
									}
								}
							}
						}
					}
					ma.disableUnusedAttributes();
				}
				null !== n && K.bindBuffer(K.ELEMENT_ARRAY_BUFFER, ta.getAttributeBuffer(n));
			}
			q = 0;
			null !== n ? q = n.count : void 0 !== h && (q = h.count);
			n = a.drawRange.start * E;
			h = null !== g ? g.start * E : 0;
			p = Math.max(n, h);
			g = Math.max(0, Math.min(q, n + a.drawRange.count * E, h + (null !== g ? g.count * E : Infinity)) - 1 - p + 1);
			if (0 !== g) {
				if (z.isMesh) {
					if (!0 === b.wireframe) {
						ma.setLineWidth(b.wireframeLinewidth * (null === ba ? Ua : 1)), d.setMode(K.LINES);
					} else {
						switch(z.drawMode) {
							case 0:
								d.setMode(K.TRIANGLES);
								break;
							case 1:
								d.setMode(K.TRIANGLE_STRIP);
								break;
							case 2:
								d.setMode(K.TRIANGLE_FAN);
						}
					}
				} else {
					z.isLine ? (b = b.linewidth, void 0 === b && (b = 1), ma.setLineWidth(b * (null === ba ? Ua : 1)), z.isLineSegments ? d.setMode(K.LINES) : d.setMode(K.LINE_STRIP)) : z.isPoints && d.setMode(K.POINTS);
				}
				a && a.isInstancedBufferGeometry ? 0 < a.maxInstancedCount && d.renderInstances(a, p, g) : d.render(p, g);
			}
		};
		this.render = function(d, n, a, b) {
			if (void 0 !== n && !0 !== n.isCamera) {
				console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
			} else {
				V = "";
				ha = -1;
				pa = null;
				!0 === d.autoUpdate && d.updateMatrixWorld();
				null === n.parent && n.updateMatrixWorld();
				n.matrixWorldInverse.getInverse(n.matrixWorld);
				la.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse);
				Ba.setFromMatrix(la);
				J.length = 0;
				S = Y = -1;
				N.length = 0;
				ga.length = 0;
				ja = this.localClippingEnabled;
				ya = sa.init(this.clippingPlanes, ja, n);
				u(d, n);
				I.length = Y + 1;
				M.length = S + 1;
				!0 === Q.sortObjects && (I.sort(h), M.sort(f));
				ya && sa.beginShadows();
				for (var z = J, g = 0, c = 0, e = z.length;c < e;c++) {
					var E = z[c];
					E.castShadow && (oa.shadows[g++] = E);
				}
				oa.shadows.length = g;
				Ka.render(d, n);
				for (var z = J, m = E = 0, k = 0, p, r, P, w, aa = n.matrixWorldInverse, t = 0, v = 0, fa = 0, B = 0, y = 0, g = 0, c = z.length;g < c;g++) {
					if (e = z[g], p = e.color, r = e.intensity, P = e.distance, w = e.shadow && e.shadow.map ? e.shadow.map.texture : null, e.isAmbientLight) {
						E += p.r * r, m += p.g * r, k += p.b * r;
					} else {
						if (e.isDirectionalLight) {
							var O = Bb.get(e);
							O.color.copy(e.color).multiplyScalar(e.intensity);
							O.direction.setFromMatrixPosition(e.matrixWorld);
							da.setFromMatrixPosition(e.target.matrixWorld);
							O.direction.sub(da);
							O.direction.transformDirection(aa);
							if (O.shadow = e.castShadow) {
								O.shadowBias = e.shadow.bias, O.shadowRadius = e.shadow.radius, O.shadowMapSize = e.shadow.mapSize;
							}
							oa.directionalShadowMap[t] = w;
							oa.directionalShadowMatrix[t] = e.shadow.matrix;
							oa.directional[t++] = O;
						} else {
							if (e.isSpotLight) {
								O = Bb.get(e);
								O.position.setFromMatrixPosition(e.matrixWorld);
								O.position.applyMatrix4(aa);
								O.color.copy(p).multiplyScalar(r);
								O.distance = P;
								O.direction.setFromMatrixPosition(e.matrixWorld);
								da.setFromMatrixPosition(e.target.matrixWorld);
								O.direction.sub(da);
								O.direction.transformDirection(aa);
								O.coneCos = Math.cos(e.angle);
								O.penumbraCos = Math.cos(e.angle * (1 - e.penumbra));
								O.decay = 0 === e.distance ? 0 : e.decay;
								if (O.shadow = e.castShadow) {
									O.shadowBias = e.shadow.bias, O.shadowRadius = e.shadow.radius, O.shadowMapSize = e.shadow.mapSize;
								}
								oa.spotShadowMap[fa] = w;
								oa.spotShadowMatrix[fa] = e.shadow.matrix;
								oa.spot[fa++] = O;
							} else {
								if (e.isRectAreaLight) {
									O = Bb.get(e), O.color.copy(p).multiplyScalar(r / (e.width * e.height)), O.position.setFromMatrixPosition(e.matrixWorld), O.position.applyMatrix4(aa), na.identity(), Zb.copy(e.matrixWorld), Zb.premultiply(aa), na.extractRotation(Zb), O.halfWidth.set(.5 * e.width, 0, 0), O.halfHeight.set(0, .5 * e.height, 0), O.halfWidth.applyMatrix4(na), O.halfHeight.applyMatrix4(na), oa.rectArea[B++] = O;
								} else {
									if (e.isPointLight) {
										O = Bb.get(e);
										O.position.setFromMatrixPosition(e.matrixWorld);
										O.position.applyMatrix4(aa);
										O.color.copy(e.color).multiplyScalar(e.intensity);
										O.distance = e.distance;
										O.decay = 0 === e.distance ? 0 : e.decay;
										if (O.shadow = e.castShadow) {
											O.shadowBias = e.shadow.bias, O.shadowRadius = e.shadow.radius, O.shadowMapSize = e.shadow.mapSize;
										}
										oa.pointShadowMap[v] = w;
										void 0 === oa.pointShadowMatrix[v] && (oa.pointShadowMatrix[v] = new q);
										da.setFromMatrixPosition(e.matrixWorld).negate();
										oa.pointShadowMatrix[v].identity().setPosition(da);
										oa.point[v++] = O;
									} else {
										e.isHemisphereLight && (O = Bb.get(e), O.direction.setFromMatrixPosition(e.matrixWorld), O.direction.transformDirection(aa), O.direction.normalize(), O.skyColor.copy(e.color).multiplyScalar(r), O.groundColor.copy(e.groundColor).multiplyScalar(r), oa.hemi[y++] = O);
									}
								}
							}
						}
					}
				}
				oa.ambient[0] = E;
				oa.ambient[1] = m;
				oa.ambient[2] = k;
				oa.directional.length = t;
				oa.spot.length = fa;
				oa.rectArea.length = B;
				oa.point.length = v;
				oa.hemi.length = y;
				oa.hash = t + "," + v + "," + fa + "," + B + "," + y + "," + oa.shadows.length;
				ya && sa.endShadows();
				wa.calls = 0;
				wa.vertices = 0;
				wa.faces = 0;
				wa.points = 0;
				void 0 === a && (a = null);
				this.setRenderTarget(a);
				z = d.background;
				null === z ? ma.buffers.color.setClear(Pa.r, Pa.g, Pa.b, nb, D) : z && z.isColor && (ma.buffers.color.setClear(z.r, z.g, z.b, 1, D), b = !0);
				(this.autoClear || b) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
				z && z.isCubeTexture ? (za.projectionMatrix.copy(n.projectionMatrix), za.matrixWorld.extractRotation(n.matrixWorld), za.matrixWorldInverse.getInverse(za.matrixWorld), Ea.material.uniforms.tCube.value = z, Ea.modelViewMatrix.multiplyMatrices(za.matrixWorldInverse, Ea.matrixWorld), ta.update(Ea), Q.renderBufferDirect(za, null, Ea.geometry, Ea.material, Ea, null)) : z && z.isTexture && (Aa.material.map = z, ta.update(Aa), Q.renderBufferDirect(Ja, null, Aa.geometry, Aa.material, Aa, null));
				d.overrideMaterial ? (b = d.overrideMaterial, l(I, d, n, b), l(M, d, n, b)) : (ma.setBlending(0), l(I, d, n), l(M, d, n));
				Ma.render(d, n);
				Na.render(d, n, Ab);
				a && zb.updateRenderTargetMipmap(a);
				ma.setDepthTest(!0);
				ma.setDepthWrite(!0);
				ma.setColorWrite(!0);
			}
		};
		this.setFaceCulling = function(d, n) {
			ma.setCullFace(d);
			ma.setFlipSided(0 === n);
		};
		this.allocTextureUnit = function() {
			var d = Z;
			d >= Va.maxTextures && console.warn("WebGLRenderer: trying to use " + d + " texture units while this GPU supports only " + Va.maxTextures);
			Z += 1;
			return d;
		};
		this.setTexture2D = function() {
			var d = !1;
			return function(n, a) {
				n && n.isWebGLRenderTarget && (d || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), d = !0), n = n.texture);
				zb.setTexture2D(n, a);
			};
		}();
		this.setTexture = function() {
			var d = !1;
			return function(n, a) {
				d || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), d = !0);
				zb.setTexture2D(n, a);
			};
		}();
		this.setTextureCube = function() {
			var d = !1;
			return function(n, a) {
				n && n.isWebGLRenderTargetCube && (d || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), d = !0), n = n.texture);
				n && n.isCubeTexture || Array.isArray(n.image) && 6 === n.image.length ? zb.setTextureCube(n, a) : zb.setTextureCubeDynamic(n, a);
			};
		}();
		this.getCurrentRenderTarget = function() {
			return ba;
		};
		this.setRenderTarget = function(d) {
			(ba = d) && void 0 === Qa.get(d).__webglFramebuffer && zb.setupRenderTarget(d);
			var n = d && d.isWebGLRenderTargetCube, a;
			d ? (a = Qa.get(d), a = n ? a.__webglFramebuffer[d.activeCubeFace] : a.__webglFramebuffer, ra.copy(d.scissor), Ic = d.scissorTest, Ab.copy(d.viewport)) : (a = null, ra.copy(Jc).multiplyScalar(Ua), Ic = sd, Ab.copy(X).multiplyScalar(Ua));
			R !== a && (K.bindFramebuffer(K.FRAMEBUFFER, a), R = a);
			ma.scissor(ra);
			ma.setScissorTest(Ic);
			ma.viewport(Ab);
			n && (n = Qa.get(d.texture), K.framebufferTexture2D(K.FRAMEBUFFER, K.COLOR_ATTACHMENT0, K.TEXTURE_CUBE_MAP_POSITIVE_X + d.activeCubeFace, n.__webglTexture, d.activeMipMapLevel));
		};
		this.readRenderTargetPixels = function(d, n, a, b, z, g) {
			if (!1 === (d && d.isWebGLRenderTarget)) {
				console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
			} else {
				var c = Qa.get(d).__webglFramebuffer;
				if (c) {
					var e = !1;
					c !== R && (K.bindFramebuffer(K.FRAMEBUFFER, c), e = !0);
					try {
						var E = d.texture, m = E.format, h = E.type;
						1023 !== m && y(m) !== K.getParameter(K.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === h || y(h) === K.getParameter(K.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === h && (ka.get("OES_texture_float") || ka.get("WEBGL_color_buffer_float")) || 1016 === h && ka.get("EXT_color_buffer_half_float") ? K.checkFramebufferStatus(K.FRAMEBUFFER) === K.FRAMEBUFFER_COMPLETE ? 0 <= 
						n && n <= d.width - b && 0 <= a && a <= d.height - z && K.readPixels(n, a, b, z, y(m), y(h), g) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
					} finally {
						e && K.bindFramebuffer(K.FRAMEBUFFER, R);
					}
				}
			}
		};
	}
	function $b(d, n) {
		this.name = "";
		this.color = new T(d);
		this.density = void 0 !== n ? n : 2.5E-4;
	}
	function ac(d, n, a) {
		this.name = "";
		this.color = new T(d);
		this.near = void 0 !== n ? n : 1;
		this.far = void 0 !== a ? a : 1E3;
	}
	function Cb() {
		X.call(this);
		this.type = "Scene";
		this.overrideMaterial = this.fog = this.background = null;
		this.autoUpdate = !0;
	}
	function Yd(d, n, a, b, c) {
		X.call(this);
		this.lensFlares = [];
		this.positionScreen = new g;
		this.customUpdateCallback = void 0;
		void 0 !== d && this.add(d, n, a, b, c);
	}
	function Db(d) {
		Z.call(this);
		this.type = "SpriteMaterial";
		this.color = new T(16777215);
		this.map = null;
		this.rotation = 0;
		this.lights = this.fog = !1;
		this.setValues(d);
	}
	function Kc(d) {
		X.call(this);
		this.type = "Sprite";
		this.material = void 0 !== d ? d : new Db;
	}
	function Lc() {
		X.call(this);
		this.type = "LOD";
		Object.defineProperties(this, {levels:{enumerable:!0, value:[]}});
	}
	function td(d, n, a) {
		this.useVertexTexture = void 0 !== a ? a : !0;
		this.identityMatrix = new q;
		d = d || [];
		this.bones = d.slice(0);
		this.useVertexTexture ? (d = Math.sqrt(4 * this.bones.length), d = da.nextPowerOfTwo(Math.ceil(d)), this.boneTextureHeight = this.boneTextureWidth = Math.max(d, 4), this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new pa(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, 1023, 1015)) : this.boneMatrices = new Float32Array(16 * this.bones.length);
		if (void 0 === n) {
			this.calculateInverses();
		} else {
			if (this.bones.length === n.length) {
				this.boneInverses = n.slice(0);
			} else {
				for (console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [], n = 0, d = this.bones.length;n < d;n++) {
					this.boneInverses.push(new q);
				}
			}
		}
	}
	function ud() {
		X.call(this);
		this.type = "Bone";
	}
	function vd(d, n, a) {
		Da.call(this, d, n);
		this.type = "SkinnedMesh";
		this.bindMode = "attached";
		this.bindMatrix = new q;
		this.bindMatrixInverse = new q;
		d = [];
		if (this.geometry && void 0 !== this.geometry.bones) {
			for (var b, z = 0, g = this.geometry.bones.length;z < g;++z) {
				b = this.geometry.bones[z], n = new ud, d.push(n), n.name = b.name, n.position.fromArray(b.pos), n.quaternion.fromArray(b.rotq), void 0 !== b.scl && n.scale.fromArray(b.scl);
			}
			z = 0;
			for (g = this.geometry.bones.length;z < g;++z) {
				b = this.geometry.bones[z], -1 !== b.parent && null !== b.parent && void 0 !== d[b.parent] ? d[b.parent].add(d[z]) : this.add(d[z]);
			}
		}
		this.normalizeSkinWeights();
		this.updateMatrixWorld(!0);
		this.bind(new td(d, void 0, a), this.matrixWorld);
	}
	function za(d) {
		Z.call(this);
		this.type = "LineBasicMaterial";
		this.color = new T(16777215);
		this.linewidth = 1;
		this.linejoin = this.linecap = "round";
		this.lights = !1;
		this.setValues(d);
	}
	function tb(d, n, a) {
		if (1 === a) {
			return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new ta(d, n);
		}
		X.call(this);
		this.type = "Line";
		this.geometry = void 0 !== d ? d : new ca;
		this.material = void 0 !== n ? n : new za({color:16777215 * Math.random()});
	}
	function ta(d, n) {
		tb.call(this, d, n);
		this.type = "LineSegments";
	}
	function gb(d) {
		Z.call(this);
		this.type = "PointsMaterial";
		this.color = new T(16777215);
		this.map = null;
		this.size = 1;
		this.sizeAttenuation = !0;
		this.lights = !1;
		this.setValues(d);
	}
	function bc(d, n) {
		X.call(this);
		this.type = "Points";
		this.geometry = void 0 !== d ? d : new ca;
		this.material = void 0 !== n ? n : new gb({color:16777215 * Math.random()});
	}
	function Mc() {
		X.call(this);
		this.type = "Group";
	}
	function wd(d, n, a, g, c, e, m, h, k) {
		function z() {
			requestAnimationFrame(z);
			d.readyState >= d.HAVE_CURRENT_DATA && (E.needsUpdate = !0);
		}
		b.call(this, d, n, a, g, c, e, m, h, k);
		this.generateMipmaps = !1;
		var E = this;
		z();
	}
	function cc(d, n, a, g, c, e, m, h, k, q, f, p) {
		b.call(this, null, e, m, h, k, q, g, c, f, p);
		this.image = {width:n, height:a};
		this.mipmaps = d;
		this.generateMipmaps = this.flipY = !1;
	}
	function xd(d, n, a, g, c, e, m, h, k) {
		b.call(this, d, n, a, g, c, e, m, h, k);
		this.needsUpdate = !0;
	}
	function Nc(d, n, a, g, c, e, m, h, k, q) {
		q = void 0 !== q ? q : 1026;
		if (1026 !== q && 1027 !== q) {
			throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
		}
		void 0 === a && 1026 === q && (a = 1012);
		void 0 === a && 1027 === q && (a = 1020);
		b.call(this, null, g, c, e, m, h, q, a, k);
		this.image = {width:d, height:n};
		this.magFilter = void 0 !== m ? m : 1003;
		this.minFilter = void 0 !== h ? h : 1003;
		this.generateMipmaps = this.flipY = !1;
	}
	function dc(d) {
		function n(d, n) {
			return d - n;
		}
		ca.call(this);
		var a = [0, 0], b = {}, g = ["a", "b", "c"];
		if (d && d.isGeometry) {
			var c = d.vertices, e = d.faces, m = 0, h = new Uint32Array(6 * e.length);
			d = 0;
			for (var k = e.length;d < k;d++) {
				for (var q = e[d], f = 0;3 > f;f++) {
					a[0] = q[g[f]];
					a[1] = q[g[(f + 1) % 3]];
					a.sort(n);
					var p = a.toString();
					void 0 === b[p] && (h[2 * m] = a[0], h[2 * m + 1] = a[1], b[p] = !0, m++);
				}
			}
			a = new Float32Array(6 * m);
			d = 0;
			for (k = m;d < k;d++) {
				for (f = 0;2 > f;f++) {
					b = c[h[2 * d + f]], m = 6 * d + 3 * f, a[m + 0] = b.x, a[m + 1] = b.y, a[m + 2] = b.z;
				}
			}
			this.addAttribute("position", new U(a, 3));
		} else {
			if (d && d.isBufferGeometry) {
				if (null !== d.index) {
					k = d.index.array;
					c = d.attributes.position;
					g = d.groups;
					m = 0;
					0 === g.length && d.addGroup(0, k.length);
					h = new Uint32Array(2 * k.length);
					e = 0;
					for (q = g.length;e < q;++e) {
						d = g[e];
						f = d.start;
						p = d.count;
						d = f;
						for (var r = f + p;d < r;d += 3) {
							for (f = 0;3 > f;f++) {
								a[0] = k[d + f], a[1] = k[d + (f + 1) % 3], a.sort(n), p = a.toString(), void 0 === b[p] && (h[2 * m] = a[0], h[2 * m + 1] = a[1], b[p] = !0, m++);
							}
						}
					}
					a = new Float32Array(6 * m);
					d = 0;
					for (k = m;d < k;d++) {
						for (f = 0;2 > f;f++) {
							m = 6 * d + 3 * f, b = h[2 * d + f], a[m + 0] = c.getX(b), a[m + 1] = c.getY(b), a[m + 2] = c.getZ(b);
						}
					}
				} else {
					for (c = d.attributes.position.array, m = c.length / 3, h = m / 3, a = new Float32Array(6 * m), d = 0, k = h;d < k;d++) {
						for (f = 0;3 > f;f++) {
							m = 18 * d + 6 * f, h = 9 * d + 3 * f, a[m + 0] = c[h], a[m + 1] = c[h + 1], a[m + 2] = c[h + 2], b = 9 * d + (f + 1) % 3 * 3, a[m + 3] = c[b], a[m + 4] = c[b + 1], a[m + 5] = c[b + 2];
						}
					}
				}
				this.addAttribute("position", new U(a, 3));
			}
		}
	}
	function ec(d, n, a) {
		ca.call(this);
		this.type = "ParametricBufferGeometry";
		this.parameters = {func:d, slices:n, stacks:a};
		var b = [], z = [], c, g, e, m, h, k = n + 1;
		for (c = 0;c <= a;c++) {
			for (h = c / a, g = 0;g <= n;g++) {
				m = g / n, e = d(m, h), b.push(e.x, e.y, e.z), z.push(m, h);
			}
		}
		d = [];
		var q;
		for (c = 0;c < a;c++) {
			for (g = 0;g < n;g++) {
				e = c * k + g, m = c * k + g + 1, h = (c + 1) * k + g + 1, q = (c + 1) * k + g, d.push(e, m, q), d.push(m, h, q);
			}
		}
		this.setIndex(new (65535 < d.length ? cb : Ta)(d, 1));
		this.addAttribute("position", new la(b, 3));
		this.addAttribute("uv", new la(z, 2));
		this.computeVertexNormals();
	}
	function Oc(d, n, a) {
		ja.call(this);
		this.type = "ParametricGeometry";
		this.parameters = {func:d, slices:n, stacks:a};
		this.fromBufferGeometry(new ec(d, n, a));
		this.mergeVertices();
	}
	function Wa(d, n, a, b) {
		function z(d) {
			m.push(d.x, d.y, d.z);
		}
		function c(n, a) {
			n *= 3;
			a.x = d[n + 0];
			a.y = d[n + 1];
			a.z = d[n + 2];
		}
		function e(d, n, a, b) {
			0 > b && 1 === d.x && (E[n] = d.x - 1);
			0 === a.x && 0 === a.z && (E[n] = b / 2 / Math.PI + .5);
		}
		ca.call(this);
		this.type = "PolyhedronBufferGeometry";
		this.parameters = {vertices:d, indices:n, radius:a, detail:b};
		a = a || 1;
		var m = [], E = [];
		(function(d) {
			for (var a = new g, b = new g, e = new g, m = 0;m < n.length;m += 3) {
				c(n[m + 0], a);
				c(n[m + 1], b);
				c(n[m + 2], e);
				var E = a, h = b, k = e, q = Math.pow(2, d), f = [], p, r;
				for (p = 0;p <= q;p++) {
					f[p] = [];
					var u = E.clone().lerp(k, p / q), l = h.clone().lerp(k, p / q), P = q - p;
					for (r = 0;r <= P;r++) {
						f[p][r] = 0 === r && p === q ? u : u.clone().lerp(l, r / P);
					}
				}
				for (p = 0;p < q;p++) {
					for (r = 0;r < 2 * (q - p) - 1;r++) {
						E = Math.floor(r / 2), 0 === r % 2 ? (z(f[p][E + 1]), z(f[p + 1][E]), z(f[p][E])) : (z(f[p][E + 1]), z(f[p + 1][E + 1]), z(f[p + 1][E]));
					}
				}
			}
		})(b || 0);
		(function(d) {
			for (var n = new g, a = 0;a < m.length;a += 3) {
				n.x = m[a + 0], n.y = m[a + 1], n.z = m[a + 2], n.normalize().multiplyScalar(d), m[a + 0] = n.x, m[a + 1] = n.y, m[a + 2] = n.z;
			}
		})(a);
		(function() {
			for (var d = new g, n = 0;n < m.length;n += 3) {
				d.x = m[n + 0], d.y = m[n + 1], d.z = m[n + 2], E.push(Math.atan2(d.z, -d.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-d.y, Math.sqrt(d.x * d.x + d.z * d.z)) / Math.PI + .5));
			}
			for (var d = new g, n = new g, a = new g, b = new g, z = new l, c = new l, h = new l, k = 0, q = 0;k < m.length;k += 9, q += 6) {
				d.set(m[k + 0], m[k + 1], m[k + 2]);
				n.set(m[k + 3], m[k + 4], m[k + 5]);
				a.set(m[k + 6], m[k + 7], m[k + 8]);
				z.set(E[q + 0], E[q + 1]);
				c.set(E[q + 2], E[q + 3]);
				h.set(E[q + 4], E[q + 5]);
				b.copy(d).add(n).add(a).divideScalar(3);
				var f = Math.atan2(b.z, -b.x);
				e(z, q + 0, d, f);
				e(c, q + 2, n, f);
				e(h, q + 4, a, f);
			}
			for (d = 0;d < E.length;d += 6) {
				n = E[d + 0], a = E[d + 2], b = E[d + 4], z = Math.min(n, a, b), .9 < Math.max(n, a, b) && .1 > z && (.2 > n && (E[d + 0] += 1), .2 > a && (E[d + 2] += 1), .2 > b && (E[d + 4] += 1));
			}
		})();
		this.addAttribute("position", new la(m, 3));
		this.addAttribute("normal", new la(m.slice(), 3));
		this.addAttribute("uv", new la(E, 2));
		this.normalizeNormals();
		this.boundingSphere = new Ca(new g, a);
	}
	function fc(d, n) {
		Wa.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], d, n);
		this.type = "TetrahedronBufferGeometry";
		this.parameters = {radius:d, detail:n};
	}
	function Pc(d, n) {
		ja.call(this);
		this.type = "TetrahedronGeometry";
		this.parameters = {radius:d, detail:n};
		this.fromBufferGeometry(new fc(d, n));
		this.mergeVertices();
	}
	function Eb(d, n) {
		Wa.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], d, n);
		this.type = "OctahedronBufferGeometry";
		this.parameters = {radius:d, detail:n};
	}
	function Qc(d, n) {
		ja.call(this);
		this.type = "OctahedronGeometry";
		this.parameters = {radius:d, detail:n};
		this.fromBufferGeometry(new Eb(d, n));
		this.mergeVertices();
	}
	function gc(d, n) {
		var a = (1 + Math.sqrt(5)) / 2;
		Wa.call(this, [-1, a, 0, 1, a, 0, -1, -a, 0, 1, -a, 0, 0, -1, a, 0, 1, a, 0, -1, -a, 0, 1, -a, a, 0, -1, a, 0, 1, -a, 0, -1, -a, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], d, n);
		this.type = "IcosahedronBufferGeometry";
		this.parameters = {radius:d, detail:n};
	}
	function Rc(d, n) {
		ja.call(this);
		this.type = "IcosahedronGeometry";
		this.parameters = {radius:d, detail:n};
		this.fromBufferGeometry(new gc(d, n));
		this.mergeVertices();
	}
	function hc(d, n) {
		var a = (1 + Math.sqrt(5)) / 2, b = 1 / a;
		Wa.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -b, -a, 0, -b, a, 0, b, -a, 0, b, a, -b, -a, 0, -b, a, 0, b, -a, 0, b, a, 0, -a, 0, -b, a, 0, -b, -a, 0, b, a, 0, b], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 
		8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], d, n);
		this.type = "DodecahedronBufferGeometry";
		this.parameters = {radius:d, detail:n};
	}
	function Sc(d, n) {
		ja.call(this);
		this.type = "DodecahedronGeometry";
		this.parameters = {radius:d, detail:n};
		this.fromBufferGeometry(new hc(d, n));
		this.mergeVertices();
	}
	function Tc(d, n, a, b) {
		ja.call(this);
		this.type = "PolyhedronGeometry";
		this.parameters = {vertices:d, indices:n, radius:a, detail:b};
		this.fromBufferGeometry(new Wa(d, n, a, b));
		this.mergeVertices();
	}
	function ic(d, n, a, b, c) {
		function z(z) {
			var c = d.getPointAt(z / n), g = e.normals[z];
			z = e.binormals[z];
			for (q = 0;q <= b;q++) {
				var h = q / b * Math.PI * 2, k = Math.sin(h), h = -Math.cos(h);
				E.x = h * g.x + k * z.x;
				E.y = h * g.y + k * z.y;
				E.z = h * g.z + k * z.z;
				E.normalize();
				p.push(E.x, E.y, E.z);
				m.x = c.x + a * E.x;
				m.y = c.y + a * E.y;
				m.z = c.z + a * E.z;
				f.push(m.x, m.y, m.z);
			}
		}
		ca.call(this);
		this.type = "TubeBufferGeometry";
		this.parameters = {path:d, tubularSegments:n, radius:a, radialSegments:b, closed:c};
		n = n || 64;
		a = a || 1;
		b = b || 8;
		c = c || !1;
		var e = d.computeFrenetFrames(n, c);
		this.tangents = e.tangents;
		this.normals = e.normals;
		this.binormals = e.binormals;
		var m = new g, E = new g, h = new l, k, q, f = [], p = [], r = [], u = [];
		for (k = 0;k < n;k++) {
			z(k);
		}
		z(!1 === c ? n : 0);
		for (k = 0;k <= n;k++) {
			for (q = 0;q <= b;q++) {
				h.x = k / n, h.y = q / b, r.push(h.x, h.y);
			}
		}
		(function() {
			for (q = 1;q <= n;q++) {
				for (k = 1;k <= b;k++) {
					var d = (b + 1) * q + (k - 1), a = (b + 1) * q + k, z = (b + 1) * (q - 1) + k;
					u.push((b + 1) * (q - 1) + (k - 1), d, z);
					u.push(d, a, z);
				}
			}
		})();
		this.setIndex(new (65535 < u.length ? cb : Ta)(u, 1));
		this.addAttribute("position", new la(f, 3));
		this.addAttribute("normal", new la(p, 3));
		this.addAttribute("uv", new la(r, 2));
	}
	function Uc(d, n, a, b, c, g) {
		ja.call(this);
		this.type = "TubeGeometry";
		this.parameters = {path:d, tubularSegments:n, radius:a, radialSegments:b, closed:c};
		void 0 !== g && console.warn("THREE.TubeGeometry: taper has been removed.");
		d = new ic(d, n, a, b, c);
		this.tangents = d.tangents;
		this.normals = d.normals;
		this.binormals = d.binormals;
		this.fromBufferGeometry(d);
		this.mergeVertices();
	}
	function jc(d, n, a, b, c, e) {
		function z(d, n, a, b, z) {
			var c = Math.sin(d);
			n = a / n * d;
			a = Math.cos(n);
			z.x = b * (2 + a) * .5 * Math.cos(d);
			z.y = b * (2 + a) * c * .5;
			z.z = b * Math.sin(n) * .5;
		}
		ca.call(this);
		this.type = "TorusKnotBufferGeometry";
		this.parameters = {radius:d, tube:n, tubularSegments:a, radialSegments:b, p:c, q:e};
		d = d || 100;
		n = n || 40;
		a = Math.floor(a) || 64;
		b = Math.floor(b) || 8;
		c = c || 2;
		e = e || 3;
		var m = (b + 1) * (a + 1), h = b * a * 6, h = new U(new (65535 < h ? Uint32Array : Uint16Array)(h), 1), k = new U(new Float32Array(3 * m), 3), E = new U(new Float32Array(3 * m), 3), m = new U(new Float32Array(2 * m), 2), q, f, p = 0, r = 0, u = new g, P = new g, w = new l, aa = new g, t = new g, v = new g, B = new g, y = new g;
		for (q = 0;q <= a;++q) {
			for (f = q / a * c * Math.PI * 2, z(f, c, e, d, aa), z(f + .01, c, e, d, t), B.subVectors(t, aa), y.addVectors(t, aa), v.crossVectors(B, y), y.crossVectors(v, B), v.normalize(), y.normalize(), f = 0;f <= b;++f) {
				var A = f / b * Math.PI * 2, x = -n * Math.cos(A), A = n * Math.sin(A);
				u.x = aa.x + (x * y.x + A * v.x);
				u.y = aa.y + (x * y.y + A * v.y);
				u.z = aa.z + (x * y.z + A * v.z);
				k.setXYZ(p, u.x, u.y, u.z);
				P.subVectors(u, aa).normalize();
				E.setXYZ(p, P.x, P.y, P.z);
				w.x = q / a;
				w.y = f / b;
				m.setXY(p, w.x, w.y);
				p++;
			}
		}
		for (f = 1;f <= a;f++) {
			for (q = 1;q <= b;q++) {
				d = (b + 1) * f + (q - 1), n = (b + 1) * f + q, c = (b + 1) * (f - 1) + q, h.setX(r, (b + 1) * (f - 1) + (q - 1)), r++, h.setX(r, d), r++, h.setX(r, c), r++, h.setX(r, d), r++, h.setX(r, n), r++, h.setX(r, c), r++;
			}
		}
		this.setIndex(h);
		this.addAttribute("position", k);
		this.addAttribute("normal", E);
		this.addAttribute("uv", m);
	}
	function Vc(d, n, a, b, c, g, e) {
		ja.call(this);
		this.type = "TorusKnotGeometry";
		this.parameters = {radius:d, tube:n, tubularSegments:a, radialSegments:b, p:c, q:g};
		void 0 !== e && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
		this.fromBufferGeometry(new jc(d, n, a, b, c, g));
		this.mergeVertices();
	}
	function kc(d, n, a, b, c) {
		ca.call(this);
		this.type = "TorusBufferGeometry";
		this.parameters = {radius:d, tube:n, radialSegments:a, tubularSegments:b, arc:c};
		d = d || 100;
		n = n || 40;
		a = Math.floor(a) || 8;
		b = Math.floor(b) || 6;
		c = c || 2 * Math.PI;
		var z = (a + 1) * (b + 1), e = a * b * 6, e = new (65535 < e ? Uint32Array : Uint16Array)(e), m = new Float32Array(3 * z), h = new Float32Array(3 * z), z = new Float32Array(2 * z), k = 0, E = 0, q = 0, f = new g, p = new g, r = new g, u, l;
		for (u = 0;u <= a;u++) {
			for (l = 0;l <= b;l++) {
				var P = l / b * c, w = u / a * Math.PI * 2;
				p.x = (d + n * Math.cos(w)) * Math.cos(P);
				p.y = (d + n * Math.cos(w)) * Math.sin(P);
				p.z = n * Math.sin(w);
				m[k] = p.x;
				m[k + 1] = p.y;
				m[k + 2] = p.z;
				f.x = d * Math.cos(P);
				f.y = d * Math.sin(P);
				r.subVectors(p, f).normalize();
				h[k] = r.x;
				h[k + 1] = r.y;
				h[k + 2] = r.z;
				z[E] = l / b;
				z[E + 1] = u / a;
				k += 3;
				E += 2;
			}
		}
		for (u = 1;u <= a;u++) {
			for (l = 1;l <= b;l++) {
				d = (b + 1) * (u - 1) + l - 1, n = (b + 1) * (u - 1) + l, c = (b + 1) * u + l, e[q] = (b + 1) * u + l - 1, e[q + 1] = d, e[q + 2] = c, e[q + 3] = d, e[q + 4] = n, e[q + 5] = c, q += 6;
			}
		}
		this.setIndex(new U(e, 1));
		this.addAttribute("position", new U(m, 3));
		this.addAttribute("normal", new U(h, 3));
		this.addAttribute("uv", new U(z, 2));
	}
	function Wc(d, n, a, b, c) {
		ja.call(this);
		this.type = "TorusGeometry";
		this.parameters = {radius:d, tube:n, radialSegments:a, tubularSegments:b, arc:c};
		this.fromBufferGeometry(new kc(d, n, a, b, c));
	}
	function eb(d, n) {
		"undefined" !== typeof d && (ja.call(this), this.type = "ExtrudeGeometry", d = Array.isArray(d) ? d : [d], this.addShapeList(d, n), this.computeFaceNormals());
	}
	function Xc(d, n) {
		n = n || {};
		var a = n.font;
		if (!1 === (a && a.isFont)) {
			return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new ja;
		}
		a = a.generateShapes(d, n.size, n.curveSegments);
		n.amount = void 0 !== n.height ? n.height : 50;
		void 0 === n.bevelThickness && (n.bevelThickness = 10);
		void 0 === n.bevelSize && (n.bevelSize = 8);
		void 0 === n.bevelEnabled && (n.bevelEnabled = !1);
		eb.call(this, a, n);
		this.type = "TextGeometry";
	}
	function Fb(d, n, a, b, c, e, m) {
		ca.call(this);
		this.type = "SphereBufferGeometry";
		this.parameters = {radius:d, widthSegments:n, heightSegments:a, phiStart:b, phiLength:c, thetaStart:e, thetaLength:m};
		d = d || 50;
		n = Math.max(3, Math.floor(n) || 8);
		a = Math.max(2, Math.floor(a) || 6);
		b = void 0 !== b ? b : 0;
		c = void 0 !== c ? c : 2 * Math.PI;
		e = void 0 !== e ? e : 0;
		m = void 0 !== m ? m : Math.PI;
		for (var z = e + m, h = (n + 1) * (a + 1), k = new U(new Float32Array(3 * h), 3), q = new U(new Float32Array(3 * h), 3), h = new U(new Float32Array(2 * h), 2), E = 0, f = [], p = new g, r = 0;r <= a;r++) {
			for (var u = [], l = r / a, P = 0;P <= n;P++) {
				var w = P / n, aa = -d * Math.cos(b + w * c) * Math.sin(e + l * m), t = d * Math.cos(e + l * m), v = d * Math.sin(b + w * c) * Math.sin(e + l * m);
				p.set(aa, t, v).normalize();
				k.setXYZ(E, aa, t, v);
				q.setXYZ(E, p.x, p.y, p.z);
				h.setXY(E, w, 1 - l);
				u.push(E);
				E++;
			}
			f.push(u);
		}
		b = [];
		for (r = 0;r < a;r++) {
			for (P = 0;P < n;P++) {
				c = f[r][P + 1], m = f[r][P], E = f[r + 1][P], p = f[r + 1][P + 1], (0 !== r || 0 < e) && b.push(c, m, p), (r !== a - 1 || z < Math.PI) && b.push(m, E, p);
			}
		}
		this.setIndex(new (65535 < k.count ? cb : Ta)(b, 1));
		this.addAttribute("position", k);
		this.addAttribute("normal", q);
		this.addAttribute("uv", h);
		this.boundingSphere = new Ca(new g, d);
	}
	function Yc(d, n, a, b, c, g, e) {
		ja.call(this);
		this.type = "SphereGeometry";
		this.parameters = {radius:d, widthSegments:n, heightSegments:a, phiStart:b, phiLength:c, thetaStart:g, thetaLength:e};
		this.fromBufferGeometry(new Fb(d, n, a, b, c, g, e));
	}
	function lc(d, n, a, b, c, e) {
		ca.call(this);
		this.type = "RingBufferGeometry";
		this.parameters = {innerRadius:d, outerRadius:n, thetaSegments:a, phiSegments:b, thetaStart:c, thetaLength:e};
		d = d || 20;
		n = n || 50;
		c = void 0 !== c ? c : 0;
		e = void 0 !== e ? e : 2 * Math.PI;
		a = void 0 !== a ? Math.max(3, a) : 8;
		b = void 0 !== b ? Math.max(1, b) : 1;
		var z = (a + 1) * (b + 1), m = a * b * 6, m = new U(new (65535 < m ? Uint32Array : Uint16Array)(m), 1), h = new U(new Float32Array(3 * z), 3), k = new U(new Float32Array(3 * z), 3), z = new U(new Float32Array(2 * z), 2), q = 0, E = 0, f, p = d, r = (n - d) / b, u = new g, P = new l, w;
		for (d = 0;d <= b;d++) {
			for (w = 0;w <= a;w++) {
				f = c + w / a * e, u.x = p * Math.cos(f), u.y = p * Math.sin(f), h.setXYZ(q, u.x, u.y, u.z), k.setXYZ(q, 0, 0, 1), P.x = (u.x / n + 1) / 2, P.y = (u.y / n + 1) / 2, z.setXY(q, P.x, P.y), q++;
			}
			p += r;
		}
		for (d = 0;d < b;d++) {
			for (n = d * (a + 1), w = 0;w < a;w++) {
				c = f = w + n, e = f + a + 1, q = f + a + 2, f += 1, m.setX(E, c), E++, m.setX(E, e), E++, m.setX(E, q), E++, m.setX(E, c), E++, m.setX(E, q), E++, m.setX(E, f), E++;
			}
		}
		this.setIndex(m);
		this.addAttribute("position", h);
		this.addAttribute("normal", k);
		this.addAttribute("uv", z);
	}
	function Zc(d, n, a, b, c, g) {
		ja.call(this);
		this.type = "RingGeometry";
		this.parameters = {innerRadius:d, outerRadius:n, thetaSegments:a, phiSegments:b, thetaStart:c, thetaLength:g};
		this.fromBufferGeometry(new lc(d, n, a, b, c, g));
	}
	function $c(d, n, a, b) {
		ja.call(this);
		this.type = "PlaneGeometry";
		this.parameters = {width:d, height:n, widthSegments:a, heightSegments:b};
		this.fromBufferGeometry(new Ra(d, n, a, b));
	}
	function mc(d, n, a, b) {
		ca.call(this);
		this.type = "LatheBufferGeometry";
		this.parameters = {points:d, segments:n, phiStart:a, phiLength:b};
		n = Math.floor(n) || 12;
		a = a || 0;
		b = b || 2 * Math.PI;
		b = da.clamp(b, 0, 2 * Math.PI);
		for (var z = (n + 1) * d.length, c = n * d.length * 6, e = new U(new (65535 < c ? Uint32Array : Uint16Array)(c), 1), m = new U(new Float32Array(3 * z), 3), h = new U(new Float32Array(2 * z), 2), k = 0, q = 0, E = 1 / n, f = new g, p = new l, z = 0;z <= n;z++) {
			for (var c = a + z * E * b, r = Math.sin(c), u = Math.cos(c), c = 0;c <= d.length - 1;c++) {
				f.x = d[c].x * r, f.y = d[c].y, f.z = d[c].x * u, m.setXYZ(k, f.x, f.y, f.z), p.x = z / n, p.y = c / (d.length - 1), h.setXY(k, p.x, p.y), k++;
			}
		}
		for (z = 0;z < n;z++) {
			for (c = 0;c < d.length - 1;c++) {
				a = c + z * d.length, k = a + d.length, E = a + d.length + 1, f = a + 1, e.setX(q, a), q++, e.setX(q, k), q++, e.setX(q, f), q++, e.setX(q, k), q++, e.setX(q, E), q++, e.setX(q, f), q++;
			}
		}
		this.setIndex(e);
		this.addAttribute("position", m);
		this.addAttribute("uv", h);
		this.computeVertexNormals();
		if (b === 2 * Math.PI) {
			for (b = this.attributes.normal.array, e = new g, m = new g, h = new g, a = n * d.length * 3, c = z = 0;z < d.length;z++, c += 3) {
				e.x = b[c + 0], e.y = b[c + 1], e.z = b[c + 2], m.x = b[a + c + 0], m.y = b[a + c + 1], m.z = b[a + c + 2], h.addVectors(e, m).normalize(), b[c + 0] = b[a + c + 0] = h.x, b[c + 1] = b[a + c + 1] = h.y, b[c + 2] = b[a + c + 2] = h.z;
			}
		}
	}
	function ad(d, n, a, b) {
		ja.call(this);
		this.type = "LatheGeometry";
		this.parameters = {points:d, segments:n, phiStart:a, phiLength:b};
		this.fromBufferGeometry(new mc(d, n, a, b));
		this.mergeVertices();
	}
	function nc(d, n) {
		function a(d) {
			var a, z, m = b.length / 3;
			d = d.extractPoints(n);
			var k = d.shape, q = d.holes;
			if (!1 === Ea.isClockWise(k)) {
				for (k = k.reverse(), d = 0, a = q.length;d < a;d++) {
					z = q[d], !0 === Ea.isClockWise(z) && (q[d] = z.reverse());
				}
			}
			var E = Ea.triangulateShape(k, q);
			d = 0;
			for (a = q.length;d < a;d++) {
				z = q[d], k = k.concat(z);
			}
			d = 0;
			for (a = k.length;d < a;d++) {
				z = k[d], b.push(z.x, z.y, 0), c.push(0, 0, 1), e.push(z.x, z.y);
			}
			d = 0;
			for (a = E.length;d < a;d++) {
				k = E[d], g.push(k[0] + m, k[1] + m, k[2] + m), h += 3;
			}
		}
		ca.call(this);
		this.type = "ShapeBufferGeometry";
		this.parameters = {shapes:d, curveSegments:n};
		n = n || 12;
		var b = [], c = [], e = [], g = [], m = 0, h = 0;
		if (!1 === Array.isArray(d)) {
			a(d);
		} else {
			for (var k = 0;k < d.length;k++) {
				a(d[k]), this.addGroup(m, h, k), m += h, h = 0;
			}
		}
		this.setIndex(new (65535 < g.length ? cb : Ta)(g, 1));
		this.addAttribute("position", new la(b, 3));
		this.addAttribute("normal", new la(c, 3));
		this.addAttribute("uv", new la(e, 2));
	}
	function oc(d, n) {
		ja.call(this);
		this.type = "ShapeGeometry";
		"object" === typeof n && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), n = n.curveSegments);
		this.parameters = {shapes:d, curveSegments:n};
		this.fromBufferGeometry(new nc(d, n));
		this.mergeVertices();
	}
	function pc(d, n) {
		function a(d, n) {
			return d - n;
		}
		ca.call(this);
		n = Math.cos(da.DEG2RAD * (void 0 !== n ? n : 1));
		var b = [0, 0], c = {}, e = ["a", "b", "c"], g;
		d.isBufferGeometry ? (g = new ja, g.fromBufferGeometry(d)) : g = d.clone();
		g.mergeVertices();
		g.computeFaceNormals();
		d = g.vertices;
		g = g.faces;
		for (var m = 0, h = g.length;m < h;m++) {
			for (var k = g[m], q = 0;3 > q;q++) {
				b[0] = k[e[q]];
				b[1] = k[e[(q + 1) % 3]];
				b.sort(a);
				var f = b.toString();
				void 0 === c[f] ? c[f] = {vert1:b[0], vert2:b[1], face1:m, face2:void 0} : c[f].face2 = m;
			}
		}
		b = [];
		for (f in c) {
			if (e = c[f], void 0 === e.face2 || g[e.face1].normal.dot(g[e.face2].normal) <= n) {
				m = d[e.vert1], b.push(m.x), b.push(m.y), b.push(m.z), m = d[e.vert2], b.push(m.x), b.push(m.y), b.push(m.z);
			}
		}
		this.addAttribute("position", new U(new Float32Array(b), 3));
	}
	function ub(d, n, a, b, c, e, m, h) {
		function z(a) {
			var c, z, e, q = new l, E = new g, f = 0, v = !0 === a ? d : n, y = !0 === a ? 1 : -1;
			z = P;
			for (c = 1;c <= b;c++) {
				r.setXYZ(P, 0, aa * y, 0), u.setXYZ(P, 0, y, 0), q.x = .5, q.y = .5, w.setXY(P, q.x, q.y), P++;
			}
			e = P;
			for (c = 0;c <= b;c++) {
				var fa = c / b * h + m, O = Math.cos(fa), fa = Math.sin(fa);
				E.x = v * fa;
				E.y = aa * y;
				E.z = v * O;
				r.setXYZ(P, E.x, E.y, E.z);
				u.setXYZ(P, 0, y, 0);
				q.x = .5 * O + .5;
				q.y = .5 * fa * y + .5;
				w.setXY(P, q.x, q.y);
				P++;
			}
			for (c = 0;c < b;c++) {
				q = z + c, E = e + c, !0 === a ? (p.setX(t, E), t++, p.setX(t, E + 1)) : (p.setX(t, E + 1), t++, p.setX(t, E)), t++, p.setX(t, q), t++, f += 3;
			}
			k.addGroup(B, f, !0 === a ? 1 : 2);
			B += f;
		}
		ca.call(this);
		this.type = "CylinderBufferGeometry";
		this.parameters = {radiusTop:d, radiusBottom:n, height:a, radialSegments:b, heightSegments:c, openEnded:e, thetaStart:m, thetaLength:h};
		var k = this;
		d = void 0 !== d ? d : 20;
		n = void 0 !== n ? n : 20;
		a = void 0 !== a ? a : 100;
		b = Math.floor(b) || 8;
		c = Math.floor(c) || 1;
		e = void 0 !== e ? e : !1;
		m = void 0 !== m ? m : 0;
		h = void 0 !== h ? h : 2 * Math.PI;
		var q = 0;
		!1 === e && (0 < d && q++, 0 < n && q++);
		var E = function() {
			var d = (b + 1) * (c + 1);
			!1 === e && (d += (b + 1) * q + b * q);
			return d;
		}(), f = function() {
			var d = b * c * 6;
			!1 === e && (d += b * q * 3);
			return d;
		}(), p = new U(new (65535 < f ? Uint32Array : Uint16Array)(f), 1), r = new U(new Float32Array(3 * E), 3), u = new U(new Float32Array(3 * E), 3), w = new U(new Float32Array(2 * E), 2), P = 0, t = 0, v = [], aa = a / 2, B = 0;
		(function() {
			var z, e, q = new g, E = new g, f = 0, l = (n - d) / a;
			for (e = 0;e <= c;e++) {
				var y = [], fa = e / c, O = fa * (n - d) + d;
				for (z = 0;z <= b;z++) {
					var A = z / b, x = A * h + m, C = Math.sin(x), x = Math.cos(x);
					E.x = O * C;
					E.y = -fa * a + aa;
					E.z = O * x;
					r.setXYZ(P, E.x, E.y, E.z);
					q.set(C, l, x).normalize();
					u.setXYZ(P, q.x, q.y, q.z);
					w.setXY(P, A, 1 - fa);
					y.push(P);
					P++;
				}
				v.push(y);
			}
			for (z = 0;z < b;z++) {
				for (e = 0;e < c;e++) {
					q = v[e + 1][z], E = v[e + 1][z + 1], l = v[e][z + 1], p.setX(t, v[e][z]), t++, p.setX(t, q), t++, p.setX(t, l), t++, p.setX(t, q), t++, p.setX(t, E), t++, p.setX(t, l), t++, f += 6;
				}
			}
			k.addGroup(B, f, 0);
			B += f;
		})();
		!1 === e && (0 < d && z(!0), 0 < n && z(!1));
		this.setIndex(p);
		this.addAttribute("position", r);
		this.addAttribute("normal", u);
		this.addAttribute("uv", w);
	}
	function Gb(d, n, a, b, c, e, g, m) {
		ja.call(this);
		this.type = "CylinderGeometry";
		this.parameters = {radiusTop:d, radiusBottom:n, height:a, radialSegments:b, heightSegments:c, openEnded:e, thetaStart:g, thetaLength:m};
		this.fromBufferGeometry(new ub(d, n, a, b, c, e, g, m));
		this.mergeVertices();
	}
	function bd(d, n, a, b, c, e, g) {
		Gb.call(this, 0, d, n, a, b, c, e, g);
		this.type = "ConeGeometry";
		this.parameters = {radius:d, height:n, radialSegments:a, heightSegments:b, openEnded:c, thetaStart:e, thetaLength:g};
	}
	function cd(d, n, a, b, c, e, g) {
		ub.call(this, 0, d, n, a, b, c, e, g);
		this.type = "ConeBufferGeometry";
		this.parameters = {radius:d, height:n, radialSegments:a, heightSegments:b, openEnded:c, thetaStart:e, thetaLength:g};
	}
	function qc(d, n, a, b) {
		ca.call(this);
		this.type = "CircleBufferGeometry";
		this.parameters = {radius:d, segments:n, thetaStart:a, thetaLength:b};
		d = d || 50;
		n = void 0 !== n ? Math.max(3, n) : 8;
		a = void 0 !== a ? a : 0;
		b = void 0 !== b ? b : 2 * Math.PI;
		var c = n + 2, z = new Float32Array(3 * c), e = new Float32Array(3 * c), c = new Float32Array(2 * c);
		e[2] = 1;
		c[0] = .5;
		c[1] = .5;
		for (var m = 0, h = 3, k = 2;m <= n;m++, h += 3, k += 2) {
			var q = a + m / n * b;
			z[h] = d * Math.cos(q);
			z[h + 1] = d * Math.sin(q);
			e[h + 2] = 1;
			c[k] = (z[h] / d + 1) / 2;
			c[k + 1] = (z[h + 1] / d + 1) / 2;
		}
		a = [];
		for (h = 1;h <= n;h++) {
			a.push(h, h + 1, 0);
		}
		this.setIndex(new U(new Uint16Array(a), 1));
		this.addAttribute("position", new U(z, 3));
		this.addAttribute("normal", new U(e, 3));
		this.addAttribute("uv", new U(c, 2));
		this.boundingSphere = new Ca(new g, d);
	}
	function dd(d, n, a, b) {
		ja.call(this);
		this.type = "CircleGeometry";
		this.parameters = {radius:d, segments:n, thetaStart:a, thetaLength:b};
		this.fromBufferGeometry(new qc(d, n, a, b));
	}
	function rc(d, n, a, b, c, e) {
		ja.call(this);
		this.type = "BoxGeometry";
		this.parameters = {width:d, height:n, depth:a, widthSegments:b, heightSegments:c, depthSegments:e};
		this.fromBufferGeometry(new mb(d, n, a, b, c, e));
		this.mergeVertices();
	}
	function sc() {
		ua.call(this, {uniforms:Object.assign({}, na.lights, {opacity:{value:1}}), vertexShader:ka.shadow_vert, fragmentShader:ka.shadow_frag});
		this.transparent = this.lights = !0;
		Object.defineProperties(this, {opacity:{enumerable:!0, get:function() {
			return this.uniforms.opacity.value;
		}, set:function(d) {
			this.uniforms.opacity.value = d;
		}}});
	}
	function tc(d) {
		ua.call(this, d);
		this.type = "RawShaderMaterial";
	}
	function ed(d) {
		this.uuid = da.generateUUID();
		this.type = "MultiMaterial";
		this.materials = d instanceof Array ? d : [];
		this.visible = !0;
	}
	function ob(d) {
		Z.call(this);
		this.defines = {STANDARD:""};
		this.type = "MeshStandardMaterial";
		this.color = new T(16777215);
		this.metalness = this.roughness = .5;
		this.lightMap = this.map = null;
		this.lightMapIntensity = 1;
		this.aoMap = null;
		this.aoMapIntensity = 1;
		this.emissive = new T(0);
		this.emissiveIntensity = 1;
		this.bumpMap = this.emissiveMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalScale = new l(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
		this.envMapIntensity = 1;
		this.refractionRatio = .98;
		this.wireframe = !1;
		this.wireframeLinewidth = 1;
		this.wireframeLinejoin = this.wireframeLinecap = "round";
		this.morphNormals = this.morphTargets = this.skinning = !1;
		this.setValues(d);
	}
	function Hb(d) {
		ob.call(this);
		this.defines = {PHYSICAL:""};
		this.type = "MeshPhysicalMaterial";
		this.reflectivity = .5;
		this.clearCoatRoughness = this.clearCoat = 0;
		this.setValues(d);
	}
	function hb(d) {
		Z.call(this);
		this.type = "MeshPhongMaterial";
		this.color = new T(16777215);
		this.specular = new T(1118481);
		this.shininess = 30;
		this.lightMap = this.map = null;
		this.lightMapIntensity = 1;
		this.aoMap = null;
		this.aoMapIntensity = 1;
		this.emissive = new T(0);
		this.emissiveIntensity = 1;
		this.bumpMap = this.emissiveMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalScale = new l(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.envMap = this.alphaMap = this.specularMap = null;
		this.combine = 0;
		this.reflectivity = 1;
		this.refractionRatio = .98;
		this.wireframe = !1;
		this.wireframeLinewidth = 1;
		this.wireframeLinejoin = this.wireframeLinecap = "round";
		this.morphNormals = this.morphTargets = this.skinning = !1;
		this.setValues(d);
	}
	function Ib(d) {
		hb.call(this);
		this.defines = {TOON:""};
		this.type = "MeshToonMaterial";
		this.gradientMap = null;
		this.setValues(d);
	}
	function Jb(d) {
		Z.call(this, d);
		this.type = "MeshNormalMaterial";
		this.wireframe = !1;
		this.wireframeLinewidth = 1;
		this.morphTargets = this.lights = this.fog = !1;
		this.setValues(d);
	}
	function Kb(d) {
		Z.call(this);
		this.type = "MeshLambertMaterial";
		this.color = new T(16777215);
		this.lightMap = this.map = null;
		this.lightMapIntensity = 1;
		this.aoMap = null;
		this.aoMapIntensity = 1;
		this.emissive = new T(0);
		this.emissiveIntensity = 1;
		this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null;
		this.combine = 0;
		this.reflectivity = 1;
		this.refractionRatio = .98;
		this.wireframe = !1;
		this.wireframeLinewidth = 1;
		this.wireframeLinejoin = this.wireframeLinecap = "round";
		this.morphNormals = this.morphTargets = this.skinning = !1;
		this.setValues(d);
	}
	function Lb(d) {
		Z.call(this);
		this.type = "LineDashedMaterial";
		this.color = new T(16777215);
		this.scale = this.linewidth = 1;
		this.dashSize = 3;
		this.gapSize = 1;
		this.lights = !1;
		this.setValues(d);
	}
	function Zd(d, n, a) {
		var b = this, c = !1, z = 0, e = 0;
		this.onStart = void 0;
		this.onLoad = d;
		this.onProgress = n;
		this.onError = a;
		this.itemStart = function(d) {
			e++;
			if (!1 === c && void 0 !== b.onStart) {
				b.onStart(d, z, e);
			}
			c = !0;
		};
		this.itemEnd = function(d) {
			z++;
			if (void 0 !== b.onProgress) {
				b.onProgress(d, z, e);
			}
			if (z === e && (c = !1, void 0 !== b.onLoad)) {
				b.onLoad();
			}
		};
		this.itemError = function(d) {
			if (void 0 !== b.onError) {
				b.onError(d);
			}
		};
	}
	function fb(d) {
		this.manager = void 0 !== d ? d : $a;
	}
	function Ce(d) {
		this.manager = void 0 !== d ? d : $a;
		this._parser = null;
	}
	function $d(d) {
		this.manager = void 0 !== d ? d : $a;
		this._parser = null;
	}
	function fd(d) {
		this.manager = void 0 !== d ? d : $a;
	}
	function ae(d) {
		this.manager = void 0 !== d ? d : $a;
	}
	function yd(d) {
		this.manager = void 0 !== d ? d : $a;
	}
	function Aa(d, n) {
		X.call(this);
		this.type = "Light";
		this.color = new T(d);
		this.intensity = void 0 !== n ? n : 1;
		this.receiveShadow = void 0;
	}
	function zd(d, n, a) {
		Aa.call(this, d, a);
		this.type = "HemisphereLight";
		this.castShadow = void 0;
		this.position.copy(X.DefaultUp);
		this.updateMatrix();
		this.groundColor = new T(n);
	}
	function Mb(d) {
		this.camera = d;
		this.bias = 0;
		this.radius = 1;
		this.mapSize = new l(512, 512);
		this.map = null;
		this.matrix = new q;
	}
	function Ad() {
		Mb.call(this, new Oa(50, 1, .5, 500));
	}
	function Bd(d, n, a, b, c, e) {
		Aa.call(this, d, n);
		this.type = "SpotLight";
		this.position.copy(X.DefaultUp);
		this.updateMatrix();
		this.target = new X;
		Object.defineProperty(this, "power", {get:function() {
			return this.intensity * Math.PI;
		}, set:function(d) {
			this.intensity = d / Math.PI;
		}});
		this.distance = void 0 !== a ? a : 0;
		this.angle = void 0 !== b ? b : Math.PI / 3;
		this.penumbra = void 0 !== c ? c : 0;
		this.decay = void 0 !== e ? e : 1;
		this.shadow = new Ad;
	}
	function Cd(d, n, a, b) {
		Aa.call(this, d, n);
		this.type = "PointLight";
		Object.defineProperty(this, "power", {get:function() {
			return 4 * this.intensity * Math.PI;
		}, set:function(d) {
			this.intensity = d / (4 * Math.PI);
		}});
		this.distance = void 0 !== a ? a : 0;
		this.decay = void 0 !== b ? b : 1;
		this.shadow = new Mb(new Oa(90, 1, .5, 500));
	}
	function Dd(d) {
		Mb.call(this, new Yb(-5, 5, 5, -5, .5, 500));
	}
	function Ed(d, n) {
		Aa.call(this, d, n);
		this.type = "DirectionalLight";
		this.position.copy(X.DefaultUp);
		this.updateMatrix();
		this.target = new X;
		this.shadow = new Dd;
	}
	function Fd(d, n) {
		Aa.call(this, d, n);
		this.type = "AmbientLight";
		this.castShadow = void 0;
	}
	function Xa(d, n, a, b) {
		this.parameterPositions = d;
		this._cachedIndex = 0;
		this.resultBuffer = void 0 !== b ? b : new n.constructor(a);
		this.sampleValues = n;
		this.valueSize = a;
	}
	function Gd(d, n, a, b) {
		Xa.call(this, d, n, a, b);
		this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0;
	}
	function gd(d, n, a, b) {
		Xa.call(this, d, n, a, b);
	}
	function Hd(d, n, a, b) {
		Xa.call(this, d, n, a, b);
	}
	function Nb(d, n, a, b) {
		if (void 0 === d) {
			throw Error("track name is undefined");
		}
		if (void 0 === n || 0 === n.length) {
			throw Error("no keyframes in track named " + d);
		}
		this.name = d;
		this.times = Ma.convertArray(n, this.TimeBufferType);
		this.values = Ma.convertArray(a, this.ValueBufferType);
		this.setInterpolation(b || this.DefaultInterpolation);
		this.validate();
		this.optimize();
	}
	function uc(d, n, a, b) {
		Nb.call(this, d, n, a, b);
	}
	function Id(d, n, a, b) {
		Xa.call(this, d, n, a, b);
	}
	function hd(d, n, a, b) {
		Nb.call(this, d, n, a, b);
	}
	function vc(d, n, a, b) {
		Nb.call(this, d, n, a, b);
	}
	function Jd(d, n, a, b) {
		Nb.call(this, d, n, a, b);
	}
	function Kd(d, n, a) {
		Nb.call(this, d, n, a);
	}
	function Ld(d, n, a, b) {
		Nb.call(this, d, n, a, b);
	}
	function Ob(d, n, a, b) {
		Nb.apply(this, arguments);
	}
	function ab(d, n, a) {
		this.name = d;
		this.tracks = a;
		this.duration = void 0 !== n ? n : -1;
		this.uuid = da.generateUUID();
		0 > this.duration && this.resetDuration();
		this.optimize();
	}
	function Md(d) {
		this.manager = void 0 !== d ? d : $a;
		this.textures = {};
	}
	function be(d) {
		this.manager = void 0 !== d ? d : $a;
	}
	function Pb() {
		this.onLoadStart = function() {
		};
		this.onLoadProgress = function() {
		};
		this.onLoadComplete = function() {
		};
	}
	function ce(d) {
		"boolean" === typeof d && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), d = void 0);
		this.manager = void 0 !== d ? d : $a;
		this.withCredentials = !1;
	}
	function De(d) {
		this.manager = void 0 !== d ? d : $a;
		this.texturePath = "";
	}
	function Na() {
	}
	function pb(d, n) {
		this.v1 = d;
		this.v2 = n;
	}
	function id() {
		this.curves = [];
		this.autoClose = !1;
	}
	function vb(d, n, a, b, c, e, g, m) {
		this.aX = d;
		this.aY = n;
		this.xRadius = a;
		this.yRadius = b;
		this.aStartAngle = c;
		this.aEndAngle = e;
		this.aClockwise = g;
		this.aRotation = m || 0;
	}
	function Qb(d) {
		this.points = void 0 === d ? [] : d;
	}
	function Rb(d, n, a, b) {
		this.v0 = d;
		this.v1 = n;
		this.v2 = a;
		this.v3 = b;
	}
	function Sb(d, n, a) {
		this.v0 = d;
		this.v1 = n;
		this.v2 = a;
	}
	function Tb() {
		jd.apply(this, arguments);
		this.holes = [];
	}
	function jd(d) {
		id.call(this);
		this.currentPoint = new l;
		d && this.fromPoints(d);
	}
	function de() {
		this.subPaths = [];
		this.currentPath = null;
	}
	function ee(d) {
		this.data = d;
	}
	function Ee(d) {
		this.manager = void 0 !== d ? d : $a;
	}
	function fe(d) {
		this.manager = void 0 !== d ? d : $a;
	}
	function ge(d, n, a, b) {
		Aa.call(this, d, n);
		this.type = "RectAreaLight";
		this.position.set(0, 1, 0);
		this.updateMatrix();
		this.width = void 0 !== a ? a : 10;
		this.height = void 0 !== b ? b : 10;
	}
	function Fe() {
		this.type = "StereoCamera";
		this.aspect = 1;
		this.eyeSep = .064;
		this.cameraL = new Oa;
		this.cameraL.layers.enable(1);
		this.cameraL.matrixAutoUpdate = !1;
		this.cameraR = new Oa;
		this.cameraR.layers.enable(2);
		this.cameraR.matrixAutoUpdate = !1;
	}
	function Nd(d, n, a) {
		X.call(this);
		this.type = "CubeCamera";
		var b = new Oa(90, 1, d, n);
		b.up.set(0, -1, 0);
		b.lookAt(new g(1, 0, 0));
		this.add(b);
		var e = new Oa(90, 1, d, n);
		e.up.set(0, -1, 0);
		e.lookAt(new g(-1, 0, 0));
		this.add(e);
		var z = new Oa(90, 1, d, n);
		z.up.set(0, 0, 1);
		z.lookAt(new g(0, 1, 0));
		this.add(z);
		var m = new Oa(90, 1, d, n);
		m.up.set(0, 0, -1);
		m.lookAt(new g(0, -1, 0));
		this.add(m);
		var h = new Oa(90, 1, d, n);
		h.up.set(0, -1, 0);
		h.lookAt(new g(0, 0, 1));
		this.add(h);
		var k = new Oa(90, 1, d, n);
		k.up.set(0, -1, 0);
		k.lookAt(new g(0, 0, -1));
		this.add(k);
		this.renderTarget = new c(a, a, {format:1022, magFilter:1006, minFilter:1006});
		this.updateCubeMap = function(d, n) {
			null === this.parent && this.updateMatrixWorld();
			var a = this.renderTarget, c = a.texture.generateMipmaps;
			a.texture.generateMipmaps = !1;
			a.activeCubeFace = 0;
			d.render(n, b, a);
			a.activeCubeFace = 1;
			d.render(n, e, a);
			a.activeCubeFace = 2;
			d.render(n, z, a);
			a.activeCubeFace = 3;
			d.render(n, m, a);
			a.activeCubeFace = 4;
			d.render(n, h, a);
			a.texture.generateMipmaps = c;
			a.activeCubeFace = 5;
			d.render(n, k, a);
			d.setRenderTarget(null);
		};
	}
	function he() {
		X.call(this);
		this.type = "AudioListener";
		this.context = ie.getContext();
		this.gain = this.context.createGain();
		this.gain.connect(this.context.destination);
		this.filter = null;
	}
	function wc(d) {
		X.call(this);
		this.type = "Audio";
		this.context = d.context;
		this.gain = this.context.createGain();
		this.gain.connect(d.getInput());
		this.autoplay = !1;
		this.buffer = null;
		this.loop = !1;
		this.startTime = 0;
		this.playbackRate = 1;
		this.isPlaying = !1;
		this.hasPlaybackControl = !0;
		this.sourceType = "empty";
		this.filters = [];
	}
	function je(d) {
		wc.call(this, d);
		this.panner = this.context.createPanner();
		this.panner.connect(this.gain);
	}
	function ke(d, n) {
		this.analyser = d.context.createAnalyser();
		this.analyser.fftSize = void 0 !== n ? n : 2048;
		this.data = new Uint8Array(this.analyser.frequencyBinCount);
		d.getOutput().connect(this.analyser);
	}
	function Od(d, n, a) {
		this.binding = d;
		this.valueSize = a;
		d = Float64Array;
		switch(n) {
			case "quaternion":
				n = this._slerp;
				break;
			case "string":
			;
			case "bool":
				d = Array;
				n = this._select;
				break;
			default:
				n = this._lerp;
		}
		this.buffer = new d(4 * a);
		this._mixBufferRegion = n;
		this.referenceCount = this.useCount = this.cumulativeWeight = 0;
	}
	function Ha(d, n, a) {
		this.path = n;
		this.parsedPath = a || Ha.parseTrackName(n);
		this.node = Ha.findNode(d, this.parsedPath.nodeName) || d;
		this.rootNode = d;
	}
	function le(d) {
		this.uuid = da.generateUUID();
		this._objects = Array.prototype.slice.call(arguments);
		this.nCachedObjects_ = 0;
		var n = {};
		this._indicesByUUID = n;
		for (var a = 0, b = arguments.length;a !== b;++a) {
			n[arguments[a].uuid] = a;
		}
		this._paths = [];
		this._parsedPaths = [];
		this._bindings = [];
		this._bindingsIndicesByPath = {};
		var c = this;
		this.stats = {objects:{get total() {
			return c._objects.length;
		}, get inUse() {
			return this.total - c.nCachedObjects_;
		}}, get bindingsPerObject() {
			return c._bindings.length;
		}};
	}
	function me(d, n, a) {
		this._mixer = d;
		this._clip = n;
		this._localRoot = a || null;
		d = n.tracks;
		n = d.length;
		a = Array(n);
		for (var b = {endingStart:2400, endingEnd:2400}, c = 0;c !== n;++c) {
			var e = d[c].createInterpolant(null);
			a[c] = e;
			e.settings = b;
		}
		this._interpolantSettings = b;
		this._interpolants = a;
		this._propertyBindings = Array(n);
		this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null;
		this.loop = 2201;
		this._loopCount = -1;
		this._startTime = null;
		this.time = 0;
		this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1;
		this.repetitions = Infinity;
		this.paused = !1;
		this.enabled = !0;
		this.clampWhenFinished = !1;
		this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
	}
	function ne(d) {
		this._root = d;
		this._initMemoryManager();
		this.time = this._accuIndex = 0;
		this.timeScale = 1;
	}
	function Pd(d, n) {
		"string" === typeof d && (console.warn("THREE.Uniform: Type parameter is no longer needed."), d = n);
		this.value = d;
	}
	function Ub() {
		ca.call(this);
		this.type = "InstancedBufferGeometry";
		this.maxInstancedCount = void 0;
	}
	function oe(d, n, a, b) {
		this.uuid = da.generateUUID();
		this.data = d;
		this.itemSize = n;
		this.offset = a;
		this.normalized = !0 === b;
	}
	function xc(d, n) {
		this.uuid = da.generateUUID();
		this.array = d;
		this.stride = n;
		this.count = void 0 !== d ? d.length / n : 0;
		this.dynamic = !1;
		this.updateRange = {offset:0, count:-1};
		this.onUploadCallback = function() {
		};
		this.version = 0;
	}
	function yc(d, n, a) {
		xc.call(this, d, n);
		this.meshPerAttribute = a || 1;
	}
	function zc(d, n, a) {
		U.call(this, d, n);
		this.meshPerAttribute = a || 1;
	}
	function pe(d, n, a, b) {
		this.ray = new jb(d, n);
		this.near = a || 0;
		this.far = b || Infinity;
		this.params = {Mesh:{}, Line:{}, LOD:{}, Points:{threshold:1}, Sprite:{}};
		Object.defineProperties(this.params, {PointCloud:{get:function() {
			console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
			return this.Points;
		}}});
	}
	function Ge(d, n) {
		return d.distance - n.distance;
	}
	function qe(d, n, a, b) {
		if (!1 !== d.visible && (d.raycast(n, a), !0 === b)) {
			d = d.children;
			b = 0;
			for (var c = d.length;b < c;b++) {
				qe(d[b], n, a, !0);
			}
		}
	}
	function re(d) {
		this.autoStart = void 0 !== d ? d : !0;
		this.elapsedTime = this.oldTime = this.startTime = 0;
		this.running = !1;
	}
	function se(d, n, a) {
		this.radius = void 0 !== d ? d : 1;
		this.phi = void 0 !== n ? n : 0;
		this.theta = void 0 !== a ? a : 0;
		return this;
	}
	function Ka(d, n) {
		Da.call(this, d, n);
		this.animationsMap = {};
		this.animationsList = [];
		d = this.geometry.morphTargets.length;
		this.createAnimation("__default", 0, d - 1, d / 1);
		this.setAnimationWeight("__default", 1);
	}
	function kd(d) {
		X.call(this);
		this.material = d;
		this.render = function(d) {
		};
	}
	function ld(d, n, a, b) {
		this.object = d;
		this.size = void 0 !== n ? n : 1;
		d = void 0 !== a ? a : 16711680;
		b = void 0 !== b ? b : 1;
		n = 0;
		(a = this.object.geometry) && a.isGeometry ? n = 3 * a.faces.length : a && a.isBufferGeometry && (n = a.attributes.normal.count);
		a = new ca;
		n = new la(6 * n, 3);
		a.addAttribute("position", n);
		ta.call(this, a, new za({color:d, linewidth:b}));
		this.matrixAutoUpdate = !1;
		this.update();
	}
	function Ac(d) {
		X.call(this);
		this.light = d;
		this.light.updateMatrixWorld();
		this.matrix = d.matrixWorld;
		this.matrixAutoUpdate = !1;
		d = new ca;
		for (var n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], a = 0, b = 1;32 > a;a++, b++) {
			var c = a / 32 * Math.PI * 2, e = b / 32 * Math.PI * 2;
			n.push(Math.cos(c), Math.sin(c), 1, Math.cos(e), Math.sin(e), 1);
		}
		d.addAttribute("position", new la(n, 3));
		n = new za({fog:!1});
		this.cone = new ta(d, n);
		this.add(this.cone);
		this.update();
	}
	function Bc(d) {
		this.bones = this.getBoneList(d);
		for (var n = new ca, a = [], b = [], c = new T(0, 0, 1), e = new T(0, 1, 0), g = 0;g < this.bones.length;g++) {
			var m = this.bones[g];
			m.parent && m.parent.isBone && (a.push(0, 0, 0), a.push(0, 0, 0), b.push(c.r, c.g, c.b), b.push(e.r, e.g, e.b));
		}
		n.addAttribute("position", new la(a, 3));
		n.addAttribute("color", new la(b, 3));
		a = new za({vertexColors:2, depthTest:!1, depthWrite:!1, transparent:!0});
		ta.call(this, n, a);
		this.root = d;
		this.matrix = d.matrixWorld;
		this.matrixAutoUpdate = !1;
		this.update();
	}
	function Cc(d, n) {
		this.light = d;
		this.light.updateMatrixWorld();
		d = new Fb(n, 4, 2);
		n = new La({wireframe:!0, fog:!1});
		n.color.copy(this.light.color).multiplyScalar(this.light.intensity);
		Da.call(this, d, n);
		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = !1;
	}
	function Dc(d) {
		X.call(this);
		this.light = d;
		this.light.updateMatrixWorld();
		var n = new La({color:d.color, fog:!1});
		d = new La({color:d.color, fog:!1, wireframe:!0});
		var a = new ca;
		a.addAttribute("position", new U(new Float32Array(18), 3));
		this.add(new Da(a, n));
		this.add(new Da(a, d));
		this.update();
	}
	function Ec(d, n) {
		X.call(this);
		this.light = d;
		this.light.updateMatrixWorld();
		this.matrix = d.matrixWorld;
		this.matrixAutoUpdate = !1;
		d = new Eb(n);
		d.rotateY(.5 * Math.PI);
		n = new La({vertexColors:2, wireframe:!0});
		var a = d.getAttribute("position"), a = new Float32Array(3 * a.count);
		d.addAttribute("color", new U(a, 3));
		this.add(new Da(d, n));
		this.update();
	}
	function md(d, n, a, b) {
		d = d || 10;
		n = n || 10;
		a = new T(void 0 !== a ? a : 4473924);
		b = new T(void 0 !== b ? b : 8947848);
		for (var c = n / 2, e = 2 * d / n, g = [], z = [], m = 0, h = 0, k = -d;m <= n;m++, k += e) {
			g.push(-d, 0, k, d, 0, k);
			g.push(k, 0, -d, k, 0, d);
			var q = m === c ? a : b;
			q.toArray(z, h);
			h += 3;
			q.toArray(z, h);
			h += 3;
			q.toArray(z, h);
			h += 3;
			q.toArray(z, h);
			h += 3;
		}
		d = new ca;
		d.addAttribute("position", new la(g, 3));
		d.addAttribute("color", new la(z, 3));
		g = new za({vertexColors:2});
		ta.call(this, d, g);
	}
	function Qd(d, n, a, b, c, e) {
		d = d || 10;
		n = n || 16;
		a = a || 8;
		b = b || 64;
		c = new T(void 0 !== c ? c : 4473924);
		e = new T(void 0 !== e ? e : 8947848);
		var g = [], z = [], m, h, k, q, f;
		for (k = 0;k <= n;k++) {
			h = k / n * 2 * Math.PI, m = Math.sin(h) * d, h = Math.cos(h) * d, g.push(0, 0, 0), g.push(m, 0, h), f = k & 1 ? c : e, z.push(f.r, f.g, f.b), z.push(f.r, f.g, f.b);
		}
		for (k = 0;k <= a;k++) {
			for (f = k & 1 ? c : e, q = d - d / a * k, n = 0;n < b;n++) {
				h = n / b * 2 * Math.PI, m = Math.sin(h) * q, h = Math.cos(h) * q, g.push(m, 0, h), z.push(f.r, f.g, f.b), h = (n + 1) / b * 2 * Math.PI, m = Math.sin(h) * q, h = Math.cos(h) * q, g.push(m, 0, h), z.push(f.r, f.g, f.b);
			}
		}
		d = new ca;
		d.addAttribute("position", new la(g, 3));
		d.addAttribute("color", new la(z, 3));
		g = new za({vertexColors:2});
		ta.call(this, d, g);
	}
	function nd(d, n, a, b) {
		this.object = d;
		this.size = void 0 !== n ? n : 1;
		d = void 0 !== a ? a : 16776960;
		b = void 0 !== b ? b : 1;
		n = 0;
		(a = this.object.geometry) && a.isGeometry ? n = a.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
		a = new ca;
		n = new la(6 * n, 3);
		a.addAttribute("position", n);
		ta.call(this, a, new za({color:d, linewidth:b}));
		this.matrixAutoUpdate = !1;
		this.update();
	}
	function Fc(d, n) {
		X.call(this);
		this.light = d;
		this.light.updateMatrixWorld();
		this.matrix = d.matrixWorld;
		this.matrixAutoUpdate = !1;
		void 0 === n && (n = 1);
		d = new ca;
		d.addAttribute("position", new la([-n, n, 0, n, n, 0, n, -n, 0, -n, -n, 0, -n, n, 0], 3));
		n = new za({fog:!1});
		this.add(new tb(d, n));
		d = new ca;
		d.addAttribute("position", new la([0, 0, 0, 0, 0, 1], 3));
		this.add(new tb(d, n));
		this.update();
	}
	function od(d) {
		function n(d, n, b) {
			a(d, b);
			a(n, b);
		}
		function a(d, n) {
			e.push(0, 0, 0);
			g.push(n.r, n.g, n.b);
			void 0 === m[d] && (m[d] = []);
			m[d].push(e.length / 3 - 1);
		}
		var b = new ca, c = new za({color:16777215, vertexColors:1}), e = [], g = [], m = {}, h = new T(16755200), k = new T(16711680), q = new T(43775), f = new T(16777215), p = new T(3355443);
		n("n1", "n2", h);
		n("n2", "n4", h);
		n("n4", "n3", h);
		n("n3", "n1", h);
		n("f1", "f2", h);
		n("f2", "f4", h);
		n("f4", "f3", h);
		n("f3", "f1", h);
		n("n1", "f1", h);
		n("n2", "f2", h);
		n("n3", "f3", h);
		n("n4", "f4", h);
		n("p", "n1", k);
		n("p", "n2", k);
		n("p", "n3", k);
		n("p", "n4", k);
		n("u1", "u2", q);
		n("u2", "u3", q);
		n("u3", "u1", q);
		n("c", "t", f);
		n("p", "c", p);
		n("cn1", "cn2", p);
		n("cn3", "cn4", p);
		n("cf1", "cf2", p);
		n("cf3", "cf4", p);
		b.addAttribute("position", new la(e, 3));
		b.addAttribute("color", new la(g, 3));
		ta.call(this, b, c);
		this.camera = d;
		this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix();
		this.matrix = d.matrixWorld;
		this.matrixAutoUpdate = !1;
		this.pointMap = m;
		this.update();
	}
	function Gc(d, n) {
		void 0 === n && (n = 16776960);
		var a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), b = new Float32Array(24), c = new ca;
		c.setIndex(new U(a, 1));
		c.addAttribute("position", new U(b, 3));
		ta.call(this, c, new za({color:n}));
		void 0 !== d && this.update(d);
	}
	function Vb(d, n, a, b, c, e) {
		X.call(this);
		void 0 === b && (b = 16776960);
		void 0 === a && (a = 1);
		void 0 === c && (c = .2 * a);
		void 0 === e && (e = .2 * c);
		this.position.copy(n);
		this.line = new tb(He, new za({color:b}));
		this.line.matrixAutoUpdate = !1;
		this.add(this.line);
		this.cone = new Da(Ie, new La({color:b}));
		this.cone.matrixAutoUpdate = !1;
		this.add(this.cone);
		this.setDirection(d);
		this.setLength(a, c, e);
	}
	function Rd(d) {
		d = d || 1;
		var n = [0, 0, 0, d, 0, 0, 0, 0, 0, 0, d, 0, 0, 0, 0, 0, 0, d];
		d = new ca;
		d.addAttribute("position", new la(n, 3));
		d.addAttribute("color", new la([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
		n = new za({vertexColors:2});
		ta.call(this, d, n);
	}
	function Sd(d, n, a, b, c, e) {
		vb.call(this, d, n, a, a, b, c, e);
	}
	function Je(d) {
		console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
		te.call(this, d);
		this.type = "catmullrom";
		this.closed = !0;
	}
	void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52));
	void 0 === Math.sign && (Math.sign = function(d) {
		return 0 > d ? -1 : 0 < d ? 1 : +d;
	});
	void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {get:function() {
		return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
	}});
	void 0 === Object.assign && function() {
		Object.assign = function(d) {
			if (void 0 === d || null === d) {
				throw new TypeError("Cannot convert undefined or null to object");
			}
			for (var n = Object(d), a = 1;a < arguments.length;a++) {
				var b = arguments[a];
				if (void 0 !== b && null !== b) {
					for (var c in b) {
						Object.prototype.hasOwnProperty.call(b, c) && (n[c] = b[c]);
					}
				}
			}
			return n;
		};
	}();
	Object.assign(f.prototype, {addEventListener:function(d, n) {
		void 0 === this._listeners && (this._listeners = {});
		var a = this._listeners;
		void 0 === a[d] && (a[d] = []);
		-1 === a[d].indexOf(n) && a[d].push(n);
	}, hasEventListener:function(d, n) {
		if (void 0 === this._listeners) {
			return !1;
		}
		var a = this._listeners;
		return void 0 !== a[d] && -1 !== a[d].indexOf(n) ? !0 : !1;
	}, removeEventListener:function(d, n) {
		void 0 !== this._listeners && (d = this._listeners[d], void 0 !== d && (n = d.indexOf(n), -1 !== n && d.splice(n, 1)));
	}, dispatchEvent:function(d) {
		if (void 0 !== this._listeners) {
			var n = this._listeners[d.type];
			if (void 0 !== n) {
				d.target = this;
				var a = [], b, c = n.length;
				for (b = 0;b < c;b++) {
					a[b] = n[b];
				}
				for (b = 0;b < c;b++) {
					a[b].call(this, d);
				}
			}
		}
	}});
	var Ke = {NoBlending:0, NormalBlending:1, AdditiveBlending:2, SubtractiveBlending:3, MultiplyBlending:4, CustomBlending:5}, Le = {UVMapping:300, CubeReflectionMapping:301, CubeRefractionMapping:302, EquirectangularReflectionMapping:303, EquirectangularRefractionMapping:304, SphericalReflectionMapping:305, CubeUVReflectionMapping:306, CubeUVRefractionMapping:307}, ue = {RepeatWrapping:1E3, ClampToEdgeWrapping:1001, MirroredRepeatWrapping:1002}, ve = {NearestFilter:1003, NearestMipMapNearestFilter:1004, 
	NearestMipMapLinearFilter:1005, LinearFilter:1006, LinearMipMapNearestFilter:1007, LinearMipMapLinearFilter:1008}, da = {DEG2RAD:Math.PI / 180, RAD2DEG:180 / Math.PI, generateUUID:function() {
		var d = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), n = Array(36), a = 0, b;
		return function() {
			for (var c = 0;36 > c;c++) {
				8 === c || 13 === c || 18 === c || 23 === c ? n[c] = "-" : 14 === c ? n[c] = "4" : (2 >= a && (a = 33554432 + 16777216 * Math.random() | 0), b = a & 15, a >>= 4, n[c] = d[19 === c ? b & 3 | 8 : b]);
			}
			return n.join("");
		};
	}(), clamp:function(d, n, a) {
		return Math.max(n, Math.min(a, d));
	}, euclideanModulo:function(d, n) {
		return (d % n + n) % n;
	}, mapLinear:function(d, n, a, b, c) {
		return b + (d - n) * (c - b) / (a - n);
	}, lerp:function(d, n, a) {
		return (1 - a) * d + a * n;
	}, smoothstep:function(d, n, a) {
		if (d <= n) {
			return 0;
		}
		if (d >= a) {
			return 1;
		}
		d = (d - n) / (a - n);
		return d * d * (3 - 2 * d);
	}, smootherstep:function(d, n, a) {
		if (d <= n) {
			return 0;
		}
		if (d >= a) {
			return 1;
		}
		d = (d - n) / (a - n);
		return d * d * d * (d * (6 * d - 15) + 10);
	}, randInt:function(d, n) {
		return d + Math.floor(Math.random() * (n - d + 1));
	}, randFloat:function(d, n) {
		return d + Math.random() * (n - d);
	}, randFloatSpread:function(d) {
		return d * (.5 - Math.random());
	}, degToRad:function(d) {
		return d * da.DEG2RAD;
	}, radToDeg:function(d) {
		return d * da.RAD2DEG;
	}, isPowerOfTwo:function(d) {
		return 0 === (d & d - 1) && 0 !== d;
	}, nearestPowerOfTwo:function(d) {
		return Math.pow(2, Math.round(Math.log(d) / Math.LN2));
	}, nextPowerOfTwo:function(d) {
		d--;
		d |= d >> 1;
		d |= d >> 2;
		d |= d >> 4;
		d |= d >> 8;
		d |= d >> 16;
		d++;
		return d;
	}};
	l.prototype = {constructor:l, isVector2:!0, get width() {
		return this.x;
	}, set width(d) {
		this.x = d;
	}, get height() {
		return this.y;
	}, set height(d) {
		this.y = d;
	}, set:function(d, n) {
		this.x = d;
		this.y = n;
		return this;
	}, setScalar:function(d) {
		this.y = this.x = d;
		return this;
	}, setX:function(d) {
		this.x = d;
		return this;
	}, setY:function(d) {
		this.y = d;
		return this;
	}, setComponent:function(d, n) {
		switch(d) {
			case 0:
				this.x = n;
				break;
			case 1:
				this.y = n;
				break;
			default:
				throw Error("index is out of range: " + d);;
		}
		return this;
	}, getComponent:function(d) {
		switch(d) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			default:
				throw Error("index is out of range: " + d);;
		}
	}, clone:function() {
		return new this.constructor(this.x, this.y);
	}, copy:function(d) {
		this.x = d.x;
		this.y = d.y;
		return this;
	}, add:function(d, n) {
		if (void 0 !== n) {
			return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(d, n);
		}
		this.x += d.x;
		this.y += d.y;
		return this;
	}, addScalar:function(d) {
		this.x += d;
		this.y += d;
		return this;
	}, addVectors:function(d, n) {
		this.x = d.x + n.x;
		this.y = d.y + n.y;
		return this;
	}, addScaledVector:function(d, n) {
		this.x += d.x * n;
		this.y += d.y * n;
		return this;
	}, sub:function(d, n) {
		if (void 0 !== n) {
			return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(d, n);
		}
		this.x -= d.x;
		this.y -= d.y;
		return this;
	}, subScalar:function(d) {
		this.x -= d;
		this.y -= d;
		return this;
	}, subVectors:function(d, n) {
		this.x = d.x - n.x;
		this.y = d.y - n.y;
		return this;
	}, multiply:function(d) {
		this.x *= d.x;
		this.y *= d.y;
		return this;
	}, multiplyScalar:function(d) {
		isFinite(d) ? (this.x *= d, this.y *= d) : this.y = this.x = 0;
		return this;
	}, divide:function(d) {
		this.x /= d.x;
		this.y /= d.y;
		return this;
	}, divideScalar:function(d) {
		return this.multiplyScalar(1 / d);
	}, min:function(d) {
		this.x = Math.min(this.x, d.x);
		this.y = Math.min(this.y, d.y);
		return this;
	}, max:function(d) {
		this.x = Math.max(this.x, d.x);
		this.y = Math.max(this.y, d.y);
		return this;
	}, clamp:function(d, n) {
		this.x = Math.max(d.x, Math.min(n.x, this.x));
		this.y = Math.max(d.y, Math.min(n.y, this.y));
		return this;
	}, clampScalar:function() {
		var d, n;
		return function(a, b) {
			void 0 === d && (d = new l, n = new l);
			d.set(a, a);
			n.set(b, b);
			return this.clamp(d, n);
		};
	}(), clampLength:function(d, n) {
		var a = this.length();
		return this.multiplyScalar(Math.max(d, Math.min(n, a)) / a);
	}, floor:function() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	}, ceil:function() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	}, round:function() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	}, roundToZero:function() {
		this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
		this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
		return this;
	}, negate:function() {
		this.x = -this.x;
		this.y = -this.y;
		return this;
	}, dot:function(d) {
		return this.x * d.x + this.y * d.y;
	}, lengthSq:function() {
		return this.x * this.x + this.y * this.y;
	}, length:function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}, lengthManhattan:function() {
		return Math.abs(this.x) + Math.abs(this.y);
	}, normalize:function() {
		return this.divideScalar(this.length());
	}, angle:function() {
		var d = Math.atan2(this.y, this.x);
		0 > d && (d += 2 * Math.PI);
		return d;
	}, distanceTo:function(d) {
		return Math.sqrt(this.distanceToSquared(d));
	}, distanceToSquared:function(d) {
		var n = this.x - d.x;
		d = this.y - d.y;
		return n * n + d * d;
	}, distanceToManhattan:function(d) {
		return Math.abs(this.x - d.x) + Math.abs(this.y - d.y);
	}, setLength:function(d) {
		return this.multiplyScalar(d / this.length());
	}, lerp:function(d, n) {
		this.x += (d.x - this.x) * n;
		this.y += (d.y - this.y) * n;
		return this;
	}, lerpVectors:function(d, n, a) {
		return this.subVectors(n, d).multiplyScalar(a).add(d);
	}, equals:function(d) {
		return d.x === this.x && d.y === this.y;
	}, fromArray:function(d, n) {
		void 0 === n && (n = 0);
		this.x = d[n];
		this.y = d[n + 1];
		return this;
	}, toArray:function(d, n) {
		void 0 === d && (d = []);
		void 0 === n && (n = 0);
		d[n] = this.x;
		d[n + 1] = this.y;
		return d;
	}, fromAttribute:function(d, n, a) {
		void 0 === a && (a = 0);
		n = n * d.itemSize + a;
		this.x = d.array[n];
		this.y = d.array[n + 1];
		return this;
	}, rotateAround:function(d, a) {
		var n = Math.cos(a);
		a = Math.sin(a);
		var b = this.x - d.x, c = this.y - d.y;
		this.x = b * n - c * a + d.x;
		this.y = b * a + c * n + d.y;
		return this;
	}};
	var Me = 0;
	b.DEFAULT_IMAGE = void 0;
	b.DEFAULT_MAPPING = 300;
	b.prototype = {constructor:b, isTexture:!0, set needsUpdate(d) {
		!0 === d && this.version++;
	}, clone:function() {
		return (new this.constructor).copy(this);
	}, copy:function(d) {
		this.image = d.image;
		this.mipmaps = d.mipmaps.slice(0);
		this.mapping = d.mapping;
		this.wrapS = d.wrapS;
		this.wrapT = d.wrapT;
		this.magFilter = d.magFilter;
		this.minFilter = d.minFilter;
		this.anisotropy = d.anisotropy;
		this.format = d.format;
		this.type = d.type;
		this.offset.copy(d.offset);
		this.repeat.copy(d.repeat);
		this.generateMipmaps = d.generateMipmaps;
		this.premultiplyAlpha = d.premultiplyAlpha;
		this.flipY = d.flipY;
		this.unpackAlignment = d.unpackAlignment;
		this.encoding = d.encoding;
		return this;
	}, toJSON:function(d) {
		if (void 0 !== d.textures[this.uuid]) {
			return d.textures[this.uuid];
		}
		var a = {metadata:{version:4.4, type:"Texture", generator:"Texture.toJSON"}, uuid:this.uuid, name:this.name, mapping:this.mapping, repeat:[this.repeat.x, this.repeat.y], offset:[this.offset.x, this.offset.y], wrap:[this.wrapS, this.wrapT], minFilter:this.minFilter, magFilter:this.magFilter, anisotropy:this.anisotropy, flipY:this.flipY};
		if (void 0 !== this.image) {
			var b = this.image;
			void 0 === b.uuid && (b.uuid = da.generateUUID());
			if (void 0 === d.images[b.uuid]) {
				var c = d.images, e = b.uuid, g = b.uuid, m;
				void 0 !== b.toDataURL ? m = b : (m = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), m.width = b.width, m.height = b.height, m.getContext("2d").drawImage(b, 0, 0, b.width, b.height));
				m = 2048 < m.width || 2048 < m.height ? m.toDataURL("image/jpeg", .6) : m.toDataURL("image/png");
				c[e] = {uuid:g, url:m};
			}
			a.image = b.uuid;
		}
		return d.textures[this.uuid] = a;
	}, dispose:function() {
		this.dispatchEvent({type:"dispose"});
	}, transformUv:function(d) {
		if (300 === this.mapping) {
			d.multiply(this.repeat);
			d.add(this.offset);
			if (0 > d.x || 1 < d.x) {
				switch(this.wrapS) {
					case 1E3:
						d.x -= Math.floor(d.x);
						break;
					case 1001:
						d.x = 0 > d.x ? 0 : 1;
						break;
					case 1002:
						d.x = 1 === Math.abs(Math.floor(d.x) % 2) ? Math.ceil(d.x) - d.x : d.x - Math.floor(d.x);
				}
			}
			if (0 > d.y || 1 < d.y) {
				switch(this.wrapT) {
					case 1E3:
						d.y -= Math.floor(d.y);
						break;
					case 1001:
						d.y = 0 > d.y ? 0 : 1;
						break;
					case 1002:
						d.y = 1 === Math.abs(Math.floor(d.y) % 2) ? Math.ceil(d.y) - d.y : d.y - Math.floor(d.y);
				}
			}
			this.flipY && (d.y = 1 - d.y);
		}
	}};
	Object.assign(b.prototype, f.prototype);
	k.prototype = {constructor:k, isVector4:!0, set:function(d, a, b, c) {
		this.x = d;
		this.y = a;
		this.z = b;
		this.w = c;
		return this;
	}, setScalar:function(d) {
		this.w = this.z = this.y = this.x = d;
		return this;
	}, setX:function(d) {
		this.x = d;
		return this;
	}, setY:function(d) {
		this.y = d;
		return this;
	}, setZ:function(d) {
		this.z = d;
		return this;
	}, setW:function(d) {
		this.w = d;
		return this;
	}, setComponent:function(d, a) {
		switch(d) {
			case 0:
				this.x = a;
				break;
			case 1:
				this.y = a;
				break;
			case 2:
				this.z = a;
				break;
			case 3:
				this.w = a;
				break;
			default:
				throw Error("index is out of range: " + d);;
		}
		return this;
	}, getComponent:function(d) {
		switch(d) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			case 3:
				return this.w;
			default:
				throw Error("index is out of range: " + d);;
		}
	}, clone:function() {
		return new this.constructor(this.x, this.y, this.z, this.w);
	}, copy:function(d) {
		this.x = d.x;
		this.y = d.y;
		this.z = d.z;
		this.w = void 0 !== d.w ? d.w : 1;
		return this;
	}, add:function(d, a) {
		if (void 0 !== a) {
			return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(d, a);
		}
		this.x += d.x;
		this.y += d.y;
		this.z += d.z;
		this.w += d.w;
		return this;
	}, addScalar:function(d) {
		this.x += d;
		this.y += d;
		this.z += d;
		this.w += d;
		return this;
	}, addVectors:function(d, a) {
		this.x = d.x + a.x;
		this.y = d.y + a.y;
		this.z = d.z + a.z;
		this.w = d.w + a.w;
		return this;
	}, addScaledVector:function(d, a) {
		this.x += d.x * a;
		this.y += d.y * a;
		this.z += d.z * a;
		this.w += d.w * a;
		return this;
	}, sub:function(d, a) {
		if (void 0 !== a) {
			return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(d, a);
		}
		this.x -= d.x;
		this.y -= d.y;
		this.z -= d.z;
		this.w -= d.w;
		return this;
	}, subScalar:function(d) {
		this.x -= d;
		this.y -= d;
		this.z -= d;
		this.w -= d;
		return this;
	}, subVectors:function(d, a) {
		this.x = d.x - a.x;
		this.y = d.y - a.y;
		this.z = d.z - a.z;
		this.w = d.w - a.w;
		return this;
	}, multiplyScalar:function(d) {
		isFinite(d) ? (this.x *= d, this.y *= d, this.z *= d, this.w *= d) : this.w = this.z = this.y = this.x = 0;
		return this;
	}, applyMatrix4:function(d) {
		var a = this.x, b = this.y, c = this.z, e = this.w;
		d = d.elements;
		this.x = d[0] * a + d[4] * b + d[8] * c + d[12] * e;
		this.y = d[1] * a + d[5] * b + d[9] * c + d[13] * e;
		this.z = d[2] * a + d[6] * b + d[10] * c + d[14] * e;
		this.w = d[3] * a + d[7] * b + d[11] * c + d[15] * e;
		return this;
	}, divideScalar:function(d) {
		return this.multiplyScalar(1 / d);
	}, setAxisAngleFromQuaternion:function(d) {
		this.w = 2 * Math.acos(d.w);
		var a = Math.sqrt(1 - d.w * d.w);
		1E-4 > a ? (this.x = 1, this.z = this.y = 0) : (this.x = d.x / a, this.y = d.y / a, this.z = d.z / a);
		return this;
	}, setAxisAngleFromRotationMatrix:function(d) {
		var a, b, c;
		d = d.elements;
		var e = d[0];
		c = d[4];
		var g = d[8], m = d[1], h = d[5], k = d[9];
		b = d[2];
		a = d[6];
		var q = d[10];
		if (.01 > Math.abs(c - m) && .01 > Math.abs(g - b) && .01 > Math.abs(k - a)) {
			if (.1 > Math.abs(c + m) && .1 > Math.abs(g + b) && .1 > Math.abs(k + a) && .1 > Math.abs(e + h + q - 3)) {
				return this.set(1, 0, 0, 0), this;
			}
			d = Math.PI;
			e = (e + 1) / 2;
			h = (h + 1) / 2;
			q = (q + 1) / 2;
			c = (c + m) / 4;
			g = (g + b) / 4;
			k = (k + a) / 4;
			e > h && e > q ? .01 > e ? (a = 0, c = b = .707106781) : (a = Math.sqrt(e), b = c / a, c = g / a) : h > q ? .01 > h ? (a = .707106781, b = 0, c = .707106781) : (b = Math.sqrt(h), a = c / b, c = k / b) : .01 > q ? (b = a = .707106781, c = 0) : (c = Math.sqrt(q), a = g / c, b = k / c);
			this.set(a, b, c, d);
			return this;
		}
		d = Math.sqrt((a - k) * (a - k) + (g - b) * (g - b) + (m - c) * (m - c));
		.001 > Math.abs(d) && (d = 1);
		this.x = (a - k) / d;
		this.y = (g - b) / d;
		this.z = (m - c) / d;
		this.w = Math.acos((e + h + q - 1) / 2);
		return this;
	}, min:function(d) {
		this.x = Math.min(this.x, d.x);
		this.y = Math.min(this.y, d.y);
		this.z = Math.min(this.z, d.z);
		this.w = Math.min(this.w, d.w);
		return this;
	}, max:function(d) {
		this.x = Math.max(this.x, d.x);
		this.y = Math.max(this.y, d.y);
		this.z = Math.max(this.z, d.z);
		this.w = Math.max(this.w, d.w);
		return this;
	}, clamp:function(d, a) {
		this.x = Math.max(d.x, Math.min(a.x, this.x));
		this.y = Math.max(d.y, Math.min(a.y, this.y));
		this.z = Math.max(d.z, Math.min(a.z, this.z));
		this.w = Math.max(d.w, Math.min(a.w, this.w));
		return this;
	}, clampScalar:function() {
		var d, a;
		return function(n, b) {
			void 0 === d && (d = new k, a = new k);
			d.set(n, n, n, n);
			a.set(b, b, b, b);
			return this.clamp(d, a);
		};
	}(), floor:function() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		this.z = Math.floor(this.z);
		this.w = Math.floor(this.w);
		return this;
	}, ceil:function() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		this.z = Math.ceil(this.z);
		this.w = Math.ceil(this.w);
		return this;
	}, round:function() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		this.z = Math.round(this.z);
		this.w = Math.round(this.w);
		return this;
	}, roundToZero:function() {
		this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
		this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
		this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
		this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
		return this;
	}, negate:function() {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
		this.w = -this.w;
		return this;
	}, dot:function(d) {
		return this.x * d.x + this.y * d.y + this.z * d.z + this.w * d.w;
	}, lengthSq:function() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	}, length:function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}, lengthManhattan:function() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
	}, normalize:function() {
		return this.divideScalar(this.length());
	}, setLength:function(d) {
		return this.multiplyScalar(d / this.length());
	}, lerp:function(d, a) {
		this.x += (d.x - this.x) * a;
		this.y += (d.y - this.y) * a;
		this.z += (d.z - this.z) * a;
		this.w += (d.w - this.w) * a;
		return this;
	}, lerpVectors:function(d, a, b) {
		return this.subVectors(a, d).multiplyScalar(b).add(d);
	}, equals:function(d) {
		return d.x === this.x && d.y === this.y && d.z === this.z && d.w === this.w;
	}, fromArray:function(d, a) {
		void 0 === a && (a = 0);
		this.x = d[a];
		this.y = d[a + 1];
		this.z = d[a + 2];
		this.w = d[a + 3];
		return this;
	}, toArray:function(d, a) {
		void 0 === d && (d = []);
		void 0 === a && (a = 0);
		d[a] = this.x;
		d[a + 1] = this.y;
		d[a + 2] = this.z;
		d[a + 3] = this.w;
		return d;
	}, fromAttribute:function(d, a, b) {
		void 0 === b && (b = 0);
		a = a * d.itemSize + b;
		this.x = d.array[a];
		this.y = d.array[a + 1];
		this.z = d.array[a + 2];
		this.w = d.array[a + 3];
		return this;
	}};
	Object.assign(h.prototype, f.prototype, {isWebGLRenderTarget:!0, setSize:function(d, a) {
		if (this.width !== d || this.height !== a) {
			this.width = d, this.height = a, this.dispose();
		}
		this.viewport.set(0, 0, d, a);
		this.scissor.set(0, 0, d, a);
	}, clone:function() {
		return (new this.constructor).copy(this);
	}, copy:function(d) {
		this.width = d.width;
		this.height = d.height;
		this.viewport.copy(d.viewport);
		this.texture = d.texture.clone();
		this.depthBuffer = d.depthBuffer;
		this.stencilBuffer = d.stencilBuffer;
		this.depthTexture = d.depthTexture;
		return this;
	}, dispose:function() {
		this.dispatchEvent({type:"dispose"});
	}});
	c.prototype = Object.create(h.prototype);
	c.prototype.constructor = c;
	c.prototype.isWebGLRenderTargetCube = !0;
	e.prototype = {constructor:e, get x() {
		return this._x;
	}, set x(d) {
		this._x = d;
		this.onChangeCallback();
	}, get y() {
		return this._y;
	}, set y(d) {
		this._y = d;
		this.onChangeCallback();
	}, get z() {
		return this._z;
	}, set z(d) {
		this._z = d;
		this.onChangeCallback();
	}, get w() {
		return this._w;
	}, set w(d) {
		this._w = d;
		this.onChangeCallback();
	}, set:function(d, a, b, c) {
		this._x = d;
		this._y = a;
		this._z = b;
		this._w = c;
		this.onChangeCallback();
		return this;
	}, clone:function() {
		return new this.constructor(this._x, this._y, this._z, this._w);
	}, copy:function(d) {
		this._x = d.x;
		this._y = d.y;
		this._z = d.z;
		this._w = d.w;
		this.onChangeCallback();
		return this;
	}, setFromEuler:function(d, a) {
		if (!1 === (d && d.isEuler)) {
			throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
		}
		var n = Math.cos(d._x / 2), b = Math.cos(d._y / 2), c = Math.cos(d._z / 2), e = Math.sin(d._x / 2), g = Math.sin(d._y / 2), m = Math.sin(d._z / 2);
		d = d.order;
		"XYZ" === d ? (this._x = e * b * c + n * g * m, this._y = n * g * c - e * b * m, this._z = n * b * m + e * g * c, this._w = n * b * c - e * g * m) : "YXZ" === d ? (this._x = e * b * c + n * g * m, this._y = n * g * c - e * b * m, this._z = n * b * m - e * g * c, this._w = n * b * c + e * g * m) : "ZXY" === d ? (this._x = e * b * c - n * g * m, this._y = n * g * c + e * b * m, this._z = n * b * m + e * g * c, this._w = n * b * c - e * g * m) : "ZYX" === d ? (this._x = e * b * c - n * g * m, this._y = 
		n * g * c + e * b * m, this._z = n * b * m - e * g * c, this._w = n * b * c + e * g * m) : "YZX" === d ? (this._x = e * b * c + n * g * m, this._y = n * g * c + e * b * m, this._z = n * b * m - e * g * c, this._w = n * b * c - e * g * m) : "XZY" === d && (this._x = e * b * c - n * g * m, this._y = n * g * c - e * b * m, this._z = n * b * m + e * g * c, this._w = n * b * c + e * g * m);
		if (!1 !== a) {
			this.onChangeCallback();
		}
		return this;
	}, setFromAxisAngle:function(d, a) {
		a /= 2;
		var n = Math.sin(a);
		this._x = d.x * n;
		this._y = d.y * n;
		this._z = d.z * n;
		this._w = Math.cos(a);
		this.onChangeCallback();
		return this;
	}, setFromRotationMatrix:function(d) {
		var a = d.elements, b = a[0];
		d = a[4];
		var c = a[8], e = a[1], g = a[5], m = a[9], h = a[2], k = a[6], a = a[10], q = b + g + a;
		0 < q ? (b = .5 / Math.sqrt(q + 1), this._w = .25 / b, this._x = (k - m) * b, this._y = (c - h) * b, this._z = (e - d) * b) : b > g && b > a ? (b = 2 * Math.sqrt(1 + b - g - a), this._w = (k - m) / b, this._x = .25 * b, this._y = (d + e) / b, this._z = (c + h) / b) : g > a ? (b = 2 * Math.sqrt(1 + g - b - a), this._w = (c - h) / b, this._x = (d + e) / b, this._y = .25 * b, this._z = (m + k) / b) : (b = 2 * Math.sqrt(1 + a - b - g), this._w = (e - d) / b, this._x = (c + h) / b, this._y = (m + 
		k) / b, this._z = .25 * b);
		this.onChangeCallback();
		return this;
	}, setFromUnitVectors:function() {
		var d, a;
		return function(n, b) {
			void 0 === d && (d = new g);
			a = n.dot(b) + 1;
			1E-6 > a ? (a = 0, Math.abs(n.x) > Math.abs(n.z) ? d.set(-n.y, n.x, 0) : d.set(0, -n.z, n.y)) : d.crossVectors(n, b);
			this._x = d.x;
			this._y = d.y;
			this._z = d.z;
			this._w = a;
			return this.normalize();
		};
	}(), inverse:function() {
		return this.conjugate().normalize();
	}, conjugate:function() {
		this._x *= -1;
		this._y *= -1;
		this._z *= -1;
		this.onChangeCallback();
		return this;
	}, dot:function(d) {
		return this._x * d._x + this._y * d._y + this._z * d._z + this._w * d._w;
	}, lengthSq:function() {
		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	}, length:function() {
		return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
	}, normalize:function() {
		var d = this.length();
		0 === d ? (this._z = this._y = this._x = 0, this._w = 1) : (d = 1 / d, this._x *= d, this._y *= d, this._z *= d, this._w *= d);
		this.onChangeCallback();
		return this;
	}, multiply:function(d, a) {
		return void 0 !== a ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(d, a)) : this.multiplyQuaternions(this, d);
	}, premultiply:function(d) {
		return this.multiplyQuaternions(d, this);
	}, multiplyQuaternions:function(d, a) {
		var n = d._x, b = d._y, c = d._z;
		d = d._w;
		var e = a._x, g = a._y, m = a._z;
		a = a._w;
		this._x = n * a + d * e + b * m - c * g;
		this._y = b * a + d * g + c * e - n * m;
		this._z = c * a + d * m + n * g - b * e;
		this._w = d * a - n * e - b * g - c * m;
		this.onChangeCallback();
		return this;
	}, slerp:function(d, a) {
		if (0 === a) {
			return this;
		}
		if (1 === a) {
			return this.copy(d);
		}
		var n = this._x, b = this._y, c = this._z, e = this._w, g = e * d._w + n * d._x + b * d._y + c * d._z;
		0 > g ? (this._w = -d._w, this._x = -d._x, this._y = -d._y, this._z = -d._z, g = -g) : this.copy(d);
		if (1 <= g) {
			return this._w = e, this._x = n, this._y = b, this._z = c, this;
		}
		d = Math.sqrt(1 - g * g);
		if (.001 > Math.abs(d)) {
			return this._w = .5 * (e + this._w), this._x = .5 * (n + this._x), this._y = .5 * (b + this._y), this._z = .5 * (c + this._z), this;
		}
		var m = Math.atan2(d, g), g = Math.sin((1 - a) * m) / d;
		d = Math.sin(a * m) / d;
		this._w = e * g + this._w * d;
		this._x = n * g + this._x * d;
		this._y = b * g + this._y * d;
		this._z = c * g + this._z * d;
		this.onChangeCallback();
		return this;
	}, equals:function(d) {
		return d._x === this._x && d._y === this._y && d._z === this._z && d._w === this._w;
	}, fromArray:function(d, a) {
		void 0 === a && (a = 0);
		this._x = d[a];
		this._y = d[a + 1];
		this._z = d[a + 2];
		this._w = d[a + 3];
		this.onChangeCallback();
		return this;
	}, toArray:function(d, a) {
		void 0 === d && (d = []);
		void 0 === a && (a = 0);
		d[a] = this._x;
		d[a + 1] = this._y;
		d[a + 2] = this._z;
		d[a + 3] = this._w;
		return d;
	}, onChange:function(d) {
		this.onChangeCallback = d;
		return this;
	}, onChangeCallback:function() {
	}};
	Object.assign(e, {slerp:function(d, a, b, c) {
		return b.copy(d).slerp(a, c);
	}, slerpFlat:function(d, a, b, c, e, g, m) {
		var n = b[c + 0], z = b[c + 1], h = b[c + 2];
		b = b[c + 3];
		c = e[g + 0];
		var k = e[g + 1], q = e[g + 2];
		e = e[g + 3];
		if (b !== e || n !== c || z !== k || h !== q) {
			g = 1 - m;
			var f = n * c + z * k + h * q + b * e, p = 0 <= f ? 1 : -1, r = 1 - f * f;
			r > Number.EPSILON && (r = Math.sqrt(r), f = Math.atan2(r, f * p), g = Math.sin(g * f) / r, m = Math.sin(m * f) / r);
			p *= m;
			n = n * g + c * p;
			z = z * g + k * p;
			h = h * g + q * p;
			b = b * g + e * p;
			g === 1 - m && (m = 1 / Math.sqrt(n * n + z * z + h * h + b * b), n *= m, z *= m, h *= m, b *= m);
		}
		d[a] = n;
		d[a + 1] = z;
		d[a + 2] = h;
		d[a + 3] = b;
	}});
	g.prototype = {constructor:g, isVector3:!0, set:function(d, a, b) {
		this.x = d;
		this.y = a;
		this.z = b;
		return this;
	}, setScalar:function(d) {
		this.z = this.y = this.x = d;
		return this;
	}, setX:function(d) {
		this.x = d;
		return this;
	}, setY:function(d) {
		this.y = d;
		return this;
	}, setZ:function(d) {
		this.z = d;
		return this;
	}, setComponent:function(d, a) {
		switch(d) {
			case 0:
				this.x = a;
				break;
			case 1:
				this.y = a;
				break;
			case 2:
				this.z = a;
				break;
			default:
				throw Error("index is out of range: " + d);;
		}
		return this;
	}, getComponent:function(d) {
		switch(d) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			default:
				throw Error("index is out of range: " + d);;
		}
	}, clone:function() {
		return new this.constructor(this.x, this.y, this.z);
	}, copy:function(d) {
		this.x = d.x;
		this.y = d.y;
		this.z = d.z;
		return this;
	}, add:function(d, a) {
		if (void 0 !== a) {
			return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(d, a);
		}
		this.x += d.x;
		this.y += d.y;
		this.z += d.z;
		return this;
	}, addScalar:function(d) {
		this.x += d;
		this.y += d;
		this.z += d;
		return this;
	}, addVectors:function(d, a) {
		this.x = d.x + a.x;
		this.y = d.y + a.y;
		this.z = d.z + a.z;
		return this;
	}, addScaledVector:function(d, a) {
		this.x += d.x * a;
		this.y += d.y * a;
		this.z += d.z * a;
		return this;
	}, sub:function(d, a) {
		if (void 0 !== a) {
			return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(d, a);
		}
		this.x -= d.x;
		this.y -= d.y;
		this.z -= d.z;
		return this;
	}, subScalar:function(d) {
		this.x -= d;
		this.y -= d;
		this.z -= d;
		return this;
	}, subVectors:function(d, a) {
		this.x = d.x - a.x;
		this.y = d.y - a.y;
		this.z = d.z - a.z;
		return this;
	}, multiply:function(d, a) {
		if (void 0 !== a) {
			return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(d, a);
		}
		this.x *= d.x;
		this.y *= d.y;
		this.z *= d.z;
		return this;
	}, multiplyScalar:function(d) {
		isFinite(d) ? (this.x *= d, this.y *= d, this.z *= d) : this.z = this.y = this.x = 0;
		return this;
	}, multiplyVectors:function(d, a) {
		this.x = d.x * a.x;
		this.y = d.y * a.y;
		this.z = d.z * a.z;
		return this;
	}, applyEuler:function() {
		var d;
		return function(a) {
			!1 === (a && a.isEuler) && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
			void 0 === d && (d = new e);
			return this.applyQuaternion(d.setFromEuler(a));
		};
	}(), applyAxisAngle:function() {
		var d;
		return function(a, b) {
			void 0 === d && (d = new e);
			return this.applyQuaternion(d.setFromAxisAngle(a, b));
		};
	}(), applyMatrix3:function(d) {
		var a = this.x, b = this.y, c = this.z;
		d = d.elements;
		this.x = d[0] * a + d[3] * b + d[6] * c;
		this.y = d[1] * a + d[4] * b + d[7] * c;
		this.z = d[2] * a + d[5] * b + d[8] * c;
		return this;
	}, applyMatrix4:function(d) {
		var a = this.x, b = this.y, c = this.z;
		d = d.elements;
		this.x = d[0] * a + d[4] * b + d[8] * c + d[12];
		this.y = d[1] * a + d[5] * b + d[9] * c + d[13];
		this.z = d[2] * a + d[6] * b + d[10] * c + d[14];
		return this;
	}, applyProjection:function(d) {
		var a = this.x, b = this.y, c = this.z;
		d = d.elements;
		var e = 1 / (d[3] * a + d[7] * b + d[11] * c + d[15]);
		this.x = (d[0] * a + d[4] * b + d[8] * c + d[12]) * e;
		this.y = (d[1] * a + d[5] * b + d[9] * c + d[13]) * e;
		this.z = (d[2] * a + d[6] * b + d[10] * c + d[14]) * e;
		return this;
	}, applyQuaternion:function(d) {
		var a = this.x, b = this.y, c = this.z, e = d.x, g = d.y, m = d.z;
		d = d.w;
		var h = d * a + g * c - m * b, k = d * b + m * a - e * c, q = d * c + e * b - g * a, a = -e * a - g * b - m * c;
		this.x = h * d + a * -e + k * -m - q * -g;
		this.y = k * d + a * -g + q * -e - h * -m;
		this.z = q * d + a * -m + h * -g - k * -e;
		return this;
	}, project:function() {
		var d;
		return function(a) {
			void 0 === d && (d = new q);
			d.multiplyMatrices(a.projectionMatrix, d.getInverse(a.matrixWorld));
			return this.applyProjection(d);
		};
	}(), unproject:function() {
		var d;
		return function(a) {
			void 0 === d && (d = new q);
			d.multiplyMatrices(a.matrixWorld, d.getInverse(a.projectionMatrix));
			return this.applyProjection(d);
		};
	}(), transformDirection:function(d) {
		var a = this.x, b = this.y, c = this.z;
		d = d.elements;
		this.x = d[0] * a + d[4] * b + d[8] * c;
		this.y = d[1] * a + d[5] * b + d[9] * c;
		this.z = d[2] * a + d[6] * b + d[10] * c;
		return this.normalize();
	}, divide:function(d) {
		this.x /= d.x;
		this.y /= d.y;
		this.z /= d.z;
		return this;
	}, divideScalar:function(d) {
		return this.multiplyScalar(1 / d);
	}, min:function(d) {
		this.x = Math.min(this.x, d.x);
		this.y = Math.min(this.y, d.y);
		this.z = Math.min(this.z, d.z);
		return this;
	}, max:function(d) {
		this.x = Math.max(this.x, d.x);
		this.y = Math.max(this.y, d.y);
		this.z = Math.max(this.z, d.z);
		return this;
	}, clamp:function(d, a) {
		this.x = Math.max(d.x, Math.min(a.x, this.x));
		this.y = Math.max(d.y, Math.min(a.y, this.y));
		this.z = Math.max(d.z, Math.min(a.z, this.z));
		return this;
	}, clampScalar:function() {
		var d, a;
		return function(n, b) {
			void 0 === d && (d = new g, a = new g);
			d.set(n, n, n);
			a.set(b, b, b);
			return this.clamp(d, a);
		};
	}(), clampLength:function(d, a) {
		var n = this.length();
		return this.multiplyScalar(Math.max(d, Math.min(a, n)) / n);
	}, floor:function() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		this.z = Math.floor(this.z);
		return this;
	}, ceil:function() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		this.z = Math.ceil(this.z);
		return this;
	}, round:function() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		this.z = Math.round(this.z);
		return this;
	}, roundToZero:function() {
		this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
		this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
		this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
		return this;
	}, negate:function() {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
		return this;
	}, dot:function(d) {
		return this.x * d.x + this.y * d.y + this.z * d.z;
	}, lengthSq:function() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}, length:function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}, lengthManhattan:function() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
	}, normalize:function() {
		return this.divideScalar(this.length());
	}, setLength:function(d) {
		return this.multiplyScalar(d / this.length());
	}, lerp:function(d, a) {
		this.x += (d.x - this.x) * a;
		this.y += (d.y - this.y) * a;
		this.z += (d.z - this.z) * a;
		return this;
	}, lerpVectors:function(d, a, b) {
		return this.subVectors(a, d).multiplyScalar(b).add(d);
	}, cross:function(d, a) {
		if (void 0 !== a) {
			return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(d, a);
		}
		a = this.x;
		var n = this.y, b = this.z;
		this.x = n * d.z - b * d.y;
		this.y = b * d.x - a * d.z;
		this.z = a * d.y - n * d.x;
		return this;
	}, crossVectors:function(d, a) {
		var n = d.x, b = d.y;
		d = d.z;
		var c = a.x, e = a.y;
		a = a.z;
		this.x = b * a - d * e;
		this.y = d * c - n * a;
		this.z = n * e - b * c;
		return this;
	}, projectOnVector:function(d) {
		var a = d.dot(this) / d.lengthSq();
		return this.copy(d).multiplyScalar(a);
	}, projectOnPlane:function() {
		var d;
		return function(a) {
			void 0 === d && (d = new g);
			d.copy(this).projectOnVector(a);
			return this.sub(d);
		};
	}(), reflect:function() {
		var d;
		return function(a) {
			void 0 === d && (d = new g);
			return this.sub(d.copy(a).multiplyScalar(2 * this.dot(a)));
		};
	}(), angleTo:function(d) {
		d = this.dot(d) / Math.sqrt(this.lengthSq() * d.lengthSq());
		return Math.acos(da.clamp(d, -1, 1));
	}, distanceTo:function(d) {
		return Math.sqrt(this.distanceToSquared(d));
	}, distanceToSquared:function(d) {
		var a = this.x - d.x, b = this.y - d.y;
		d = this.z - d.z;
		return a * a + b * b + d * d;
	}, distanceToManhattan:function(d) {
		return Math.abs(this.x - d.x) + Math.abs(this.y - d.y) + Math.abs(this.z - d.z);
	}, setFromSpherical:function(d) {
		var a = Math.sin(d.phi) * d.radius;
		this.x = a * Math.sin(d.theta);
		this.y = Math.cos(d.phi) * d.radius;
		this.z = a * Math.cos(d.theta);
		return this;
	}, setFromMatrixPosition:function(d) {
		return this.setFromMatrixColumn(d, 3);
	}, setFromMatrixScale:function(d) {
		var a = this.setFromMatrixColumn(d, 0).length(), b = this.setFromMatrixColumn(d, 1).length();
		d = this.setFromMatrixColumn(d, 2).length();
		this.x = a;
		this.y = b;
		this.z = d;
		return this;
	}, setFromMatrixColumn:function(d, a) {
		if ("number" === typeof d) {
			console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).");
			var n = d;
			d = a;
			a = n;
		}
		return this.fromArray(d.elements, 4 * a);
	}, equals:function(d) {
		return d.x === this.x && d.y === this.y && d.z === this.z;
	}, fromArray:function(d, a) {
		void 0 === a && (a = 0);
		this.x = d[a];
		this.y = d[a + 1];
		this.z = d[a + 2];
		return this;
	}, toArray:function(d, a) {
		void 0 === d && (d = []);
		void 0 === a && (a = 0);
		d[a] = this.x;
		d[a + 1] = this.y;
		d[a + 2] = this.z;
		return d;
	}, fromAttribute:function(d, a, b) {
		void 0 === b && (b = 0);
		a = a * d.itemSize + b;
		this.x = d.array[a];
		this.y = d.array[a + 1];
		this.z = d.array[a + 2];
		return this;
	}};
	q.prototype = {constructor:q, isMatrix4:!0, set:function(d, a, b, c, e, g, m, h, k, q, f, p, r, u, l, w) {
		var n = this.elements;
		n[0] = d;
		n[4] = a;
		n[8] = b;
		n[12] = c;
		n[1] = e;
		n[5] = g;
		n[9] = m;
		n[13] = h;
		n[2] = k;
		n[6] = q;
		n[10] = f;
		n[14] = p;
		n[3] = r;
		n[7] = u;
		n[11] = l;
		n[15] = w;
		return this;
	}, identity:function() {
		this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
		return this;
	}, clone:function() {
		return (new q).fromArray(this.elements);
	}, copy:function(d) {
		this.elements.set(d.elements);
		return this;
	}, copyPosition:function(d) {
		var a = this.elements;
		d = d.elements;
		a[12] = d[12];
		a[13] = d[13];
		a[14] = d[14];
		return this;
	}, extractBasis:function(d, a, b) {
		d.setFromMatrixColumn(this, 0);
		a.setFromMatrixColumn(this, 1);
		b.setFromMatrixColumn(this, 2);
		return this;
	}, makeBasis:function(d, a, b) {
		this.set(d.x, a.x, b.x, 0, d.y, a.y, b.y, 0, d.z, a.z, b.z, 0, 0, 0, 0, 1);
		return this;
	}, extractRotation:function() {
		var d;
		return function(a) {
			void 0 === d && (d = new g);
			var n = this.elements, b = a.elements, c = 1 / d.setFromMatrixColumn(a, 0).length(), e = 1 / d.setFromMatrixColumn(a, 1).length();
			a = 1 / d.setFromMatrixColumn(a, 2).length();
			n[0] = b[0] * c;
			n[1] = b[1] * c;
			n[2] = b[2] * c;
			n[4] = b[4] * e;
			n[5] = b[5] * e;
			n[6] = b[6] * e;
			n[8] = b[8] * a;
			n[9] = b[9] * a;
			n[10] = b[10] * a;
			return this;
		};
	}(), makeRotationFromEuler:function(d) {
		!1 === (d && d.isEuler) && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
		var a = this.elements, b = d.x, c = d.y, e = d.z, g = Math.cos(b), b = Math.sin(b), m = Math.cos(c), c = Math.sin(c), h = Math.cos(e), e = Math.sin(e);
		if ("XYZ" === d.order) {
			d = g * h;
			var k = g * e, q = b * h, f = b * e;
			a[0] = m * h;
			a[4] = -m * e;
			a[8] = c;
			a[1] = k + q * c;
			a[5] = d - f * c;
			a[9] = -b * m;
			a[2] = f - d * c;
			a[6] = q + k * c;
			a[10] = g * m;
		} else {
			"YXZ" === d.order ? (d = m * h, k = m * e, q = c * h, f = c * e, a[0] = d + f * b, a[4] = q * b - k, a[8] = g * c, a[1] = g * e, a[5] = g * h, a[9] = -b, a[2] = k * b - q, a[6] = f + d * b, a[10] = g * m) : "ZXY" === d.order ? (d = m * h, k = m * e, q = c * h, f = c * e, a[0] = d - f * b, a[4] = -g * e, a[8] = q + k * b, a[1] = k + q * b, a[5] = g * h, a[9] = f - d * b, a[2] = -g * c, a[6] = b, a[10] = g * m) : "ZYX" === d.order ? (d = g * h, k = g * e, q = b * h, f = b * e, a[0] = m * h, a[4] = 
			q * c - k, a[8] = d * c + f, a[1] = m * e, a[5] = f * c + d, a[9] = k * c - q, a[2] = -c, a[6] = b * m, a[10] = g * m) : "YZX" === d.order ? (d = g * m, k = g * c, q = b * m, f = b * c, a[0] = m * h, a[4] = f - d * e, a[8] = q * e + k, a[1] = e, a[5] = g * h, a[9] = -b * h, a[2] = -c * h, a[6] = k * e + q, a[10] = d - f * e) : "XZY" === d.order && (d = g * m, k = g * c, q = b * m, f = b * c, a[0] = m * h, a[4] = -e, a[8] = c * h, a[1] = d * e + f, a[5] = g * h, a[9] = k * e - q, a[2] = q * 
			e - k, a[6] = b * h, a[10] = f * e + d);
		}
		a[3] = 0;
		a[7] = 0;
		a[11] = 0;
		a[12] = 0;
		a[13] = 0;
		a[14] = 0;
		a[15] = 1;
		return this;
	}, makeRotationFromQuaternion:function(d) {
		var a = this.elements, b = d.x, c = d.y, e = d.z, g = d.w, m = b + b, h = c + c, k = e + e;
		d = b * m;
		var q = b * h, b = b * k, f = c * h, c = c * k, e = e * k, m = g * m, h = g * h, g = g * k;
		a[0] = 1 - (f + e);
		a[4] = q - g;
		a[8] = b + h;
		a[1] = q + g;
		a[5] = 1 - (d + e);
		a[9] = c - m;
		a[2] = b - h;
		a[6] = c + m;
		a[10] = 1 - (d + f);
		a[3] = 0;
		a[7] = 0;
		a[11] = 0;
		a[12] = 0;
		a[13] = 0;
		a[14] = 0;
		a[15] = 1;
		return this;
	}, lookAt:function() {
		var d, a, b;
		return function(n, c, e) {
			void 0 === d && (d = new g, a = new g, b = new g);
			var m = this.elements;
			b.subVectors(n, c).normalize();
			0 === b.lengthSq() && (b.z = 1);
			d.crossVectors(e, b).normalize();
			0 === d.lengthSq() && (b.z += 1E-4, d.crossVectors(e, b).normalize());
			a.crossVectors(b, d);
			m[0] = d.x;
			m[4] = a.x;
			m[8] = b.x;
			m[1] = d.y;
			m[5] = a.y;
			m[9] = b.y;
			m[2] = d.z;
			m[6] = a.z;
			m[10] = b.z;
			return this;
		};
	}(), multiply:function(d, a) {
		return void 0 !== a ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(d, a)) : this.multiplyMatrices(this, d);
	}, premultiply:function(d) {
		return this.multiplyMatrices(d, this);
	}, multiplyMatrices:function(d, a) {
		d = d.elements;
		a = a.elements;
		var n = this.elements, b = d[0], c = d[4], e = d[8], g = d[12], m = d[1], h = d[5], k = d[9], q = d[13], f = d[2], p = d[6], r = d[10], u = d[14], l = d[3], w = d[7], t = d[11];
		d = d[15];
		var v = a[0], B = a[4], y = a[8], A = a[12], x = a[1], C = a[5], G = a[9], F = a[13], L = a[2], D = a[6], W = a[10], J = a[14], I = a[3], Y = a[7], M = a[11];
		a = a[15];
		n[0] = b * v + c * x + e * L + g * I;
		n[4] = b * B + c * C + e * D + g * Y;
		n[8] = b * y + c * G + e * W + g * M;
		n[12] = b * A + c * F + e * J + g * a;
		n[1] = m * v + h * x + k * L + q * I;
		n[5] = m * B + h * C + k * D + q * Y;
		n[9] = m * y + h * G + k * W + q * M;
		n[13] = m * A + h * F + k * J + q * a;
		n[2] = f * v + p * x + r * L + u * I;
		n[6] = f * B + p * C + r * D + u * Y;
		n[10] = f * y + p * G + r * W + u * M;
		n[14] = f * A + p * F + r * J + u * a;
		n[3] = l * v + w * x + t * L + d * I;
		n[7] = l * B + w * C + t * D + d * Y;
		n[11] = l * y + w * G + t * W + d * M;
		n[15] = l * A + w * F + t * J + d * a;
		return this;
	}, multiplyToArray:function(d, a, b) {
		var n = this.elements;
		this.multiplyMatrices(d, a);
		b[0] = n[0];
		b[1] = n[1];
		b[2] = n[2];
		b[3] = n[3];
		b[4] = n[4];
		b[5] = n[5];
		b[6] = n[6];
		b[7] = n[7];
		b[8] = n[8];
		b[9] = n[9];
		b[10] = n[10];
		b[11] = n[11];
		b[12] = n[12];
		b[13] = n[13];
		b[14] = n[14];
		b[15] = n[15];
		return this;
	}, multiplyScalar:function(d) {
		var a = this.elements;
		a[0] *= d;
		a[4] *= d;
		a[8] *= d;
		a[12] *= d;
		a[1] *= d;
		a[5] *= d;
		a[9] *= d;
		a[13] *= d;
		a[2] *= d;
		a[6] *= d;
		a[10] *= d;
		a[14] *= d;
		a[3] *= d;
		a[7] *= d;
		a[11] *= d;
		a[15] *= d;
		return this;
	}, applyToVector3Array:function() {
		var d;
		return function(a, b, c) {
			void 0 === d && (d = new g);
			void 0 === b && (b = 0);
			void 0 === c && (c = a.length);
			for (var n = 0;n < c;n += 3, b += 3) {
				d.fromArray(a, b), d.applyMatrix4(this), d.toArray(a, b);
			}
			return a;
		};
	}(), applyToBuffer:function() {
		var d;
		return function(a, b, c) {
			void 0 === d && (d = new g);
			void 0 === b && (b = 0);
			void 0 === c && (c = a.length / a.itemSize);
			for (var n = 0;n < c;n++, b++) {
				d.x = a.getX(b), d.y = a.getY(b), d.z = a.getZ(b), d.applyMatrix4(this), a.setXYZ(b, d.x, d.y, d.z);
			}
			return a;
		};
	}(), determinant:function() {
		var d = this.elements, a = d[0], b = d[4], c = d[8], e = d[12], g = d[1], m = d[5], h = d[9], k = d[13], q = d[2], f = d[6], p = d[10], r = d[14];
		return d[3] * (+e * h * f - c * k * f - e * m * p + b * k * p + c * m * r - b * h * r) + d[7] * (+a * h * r - a * k * p + e * g * p - c * g * r + c * k * q - e * h * q) + d[11] * (+a * k * f - a * m * r - e * g * f + b * g * r + e * m * q - b * k * q) + d[15] * (-c * m * q - a * h * f + a * m * p + c * g * f - b * g * p + b * h * q);
	}, transpose:function() {
		var d = this.elements, a;
		a = d[1];
		d[1] = d[4];
		d[4] = a;
		a = d[2];
		d[2] = d[8];
		d[8] = a;
		a = d[6];
		d[6] = d[9];
		d[9] = a;
		a = d[3];
		d[3] = d[12];
		d[12] = a;
		a = d[7];
		d[7] = d[13];
		d[13] = a;
		a = d[11];
		d[11] = d[14];
		d[14] = a;
		return this;
	}, setPosition:function(d) {
		var a = this.elements;
		a[12] = d.x;
		a[13] = d.y;
		a[14] = d.z;
		return this;
	}, getInverse:function(d, a) {
		var n = this.elements;
		d = d.elements;
		var b = d[0], c = d[1], e = d[2], g = d[3], m = d[4], h = d[5], k = d[6], q = d[7], f = d[8], p = d[9], r = d[10], u = d[11], l = d[12], w = d[13], t = d[14];
		d = d[15];
		var v = p * t * q - w * r * q + w * k * u - h * t * u - p * k * d + h * r * d, B = l * r * q - f * t * q - l * k * u + m * t * u + f * k * d - m * r * d, y = f * w * q - l * p * q + l * h * u - m * w * u - f * h * d + m * p * d, A = l * p * k - f * w * k - l * h * r + m * w * r + f * h * t - m * p * t, x = b * v + c * B + e * y + g * A;
		if (0 === x) {
			if (!0 === a) {
				throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
			}
			console.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
			return this.identity();
		}
		x = 1 / x;
		n[0] = v * x;
		n[1] = (w * r * g - p * t * g - w * e * u + c * t * u + p * e * d - c * r * d) * x;
		n[2] = (h * t * g - w * k * g + w * e * q - c * t * q - h * e * d + c * k * d) * x;
		n[3] = (p * k * g - h * r * g - p * e * q + c * r * q + h * e * u - c * k * u) * x;
		n[4] = B * x;
		n[5] = (f * t * g - l * r * g + l * e * u - b * t * u - f * e * d + b * r * d) * x;
		n[6] = (l * k * g - m * t * g - l * e * q + b * t * q + m * e * d - b * k * d) * x;
		n[7] = (m * r * g - f * k * g + f * e * q - b * r * q - m * e * u + b * k * u) * x;
		n[8] = y * x;
		n[9] = (l * p * g - f * w * g - l * c * u + b * w * u + f * c * d - b * p * d) * x;
		n[10] = (m * w * g - l * h * g + l * c * q - b * w * q - m * c * d + b * h * d) * x;
		n[11] = (f * h * g - m * p * g - f * c * q + b * p * q + m * c * u - b * h * u) * x;
		n[12] = A * x;
		n[13] = (f * w * e - l * p * e + l * c * r - b * w * r - f * c * t + b * p * t) * x;
		n[14] = (l * h * e - m * w * e - l * c * k + b * w * k + m * c * t - b * h * t) * x;
		n[15] = (m * p * e - f * h * e + f * c * k - b * p * k - m * c * r + b * h * r) * x;
		return this;
	}, scale:function(d) {
		var a = this.elements, b = d.x, c = d.y;
		d = d.z;
		a[0] *= b;
		a[4] *= c;
		a[8] *= d;
		a[1] *= b;
		a[5] *= c;
		a[9] *= d;
		a[2] *= b;
		a[6] *= c;
		a[10] *= d;
		a[3] *= b;
		a[7] *= c;
		a[11] *= d;
		return this;
	}, getMaxScaleOnAxis:function() {
		var d = this.elements;
		return Math.sqrt(Math.max(d[0] * d[0] + d[1] * d[1] + d[2] * d[2], d[4] * d[4] + d[5] * d[5] + d[6] * d[6], d[8] * d[8] + d[9] * d[9] + d[10] * d[10]));
	}, makeTranslation:function(d, a, b) {
		this.set(1, 0, 0, d, 0, 1, 0, a, 0, 0, 1, b, 0, 0, 0, 1);
		return this;
	}, makeRotationX:function(d) {
		var a = Math.cos(d);
		d = Math.sin(d);
		this.set(1, 0, 0, 0, 0, a, -d, 0, 0, d, a, 0, 0, 0, 0, 1);
		return this;
	}, makeRotationY:function(d) {
		var a = Math.cos(d);
		d = Math.sin(d);
		this.set(a, 0, d, 0, 0, 1, 0, 0, -d, 0, a, 0, 0, 0, 0, 1);
		return this;
	}, makeRotationZ:function(d) {
		var a = Math.cos(d);
		d = Math.sin(d);
		this.set(a, -d, 0, 0, d, a, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
		return this;
	}, makeRotationAxis:function(d, a) {
		var n = Math.cos(a);
		a = Math.sin(a);
		var b = 1 - n, c = d.x, e = d.y;
		d = d.z;
		var g = b * c, m = b * e;
		this.set(g * c + n, g * e - a * d, g * d + a * e, 0, g * e + a * d, m * e + n, m * d - a * c, 0, g * d - a * e, m * d + a * c, b * d * d + n, 0, 0, 0, 0, 1);
		return this;
	}, makeScale:function(d, a, b) {
		this.set(d, 0, 0, 0, 0, a, 0, 0, 0, 0, b, 0, 0, 0, 0, 1);
		return this;
	}, makeShear:function(d, a, b) {
		this.set(1, a, b, 0, d, 1, b, 0, d, a, 1, 0, 0, 0, 0, 1);
		return this;
	}, compose:function(d, a, b) {
		this.makeRotationFromQuaternion(a);
		this.scale(b);
		this.setPosition(d);
		return this;
	}, decompose:function() {
		var d, a;
		return function(n, b, c) {
			void 0 === d && (d = new g, a = new q);
			var e = this.elements, m = d.set(e[0], e[1], e[2]).length(), h = d.set(e[4], e[5], e[6]).length(), k = d.set(e[8], e[9], e[10]).length();
			0 > this.determinant() && (m = -m);
			n.x = e[12];
			n.y = e[13];
			n.z = e[14];
			a.elements.set(this.elements);
			n = 1 / m;
			var e = 1 / h, z = 1 / k;
			a.elements[0] *= n;
			a.elements[1] *= n;
			a.elements[2] *= n;
			a.elements[4] *= e;
			a.elements[5] *= e;
			a.elements[6] *= e;
			a.elements[8] *= z;
			a.elements[9] *= z;
			a.elements[10] *= z;
			b.setFromRotationMatrix(a);
			c.x = m;
			c.y = h;
			c.z = k;
			return this;
		};
	}(), makeFrustum:function(d, a, b, c, e, g) {
		var n = this.elements;
		n[0] = 2 * e / (a - d);
		n[4] = 0;
		n[8] = (a + d) / (a - d);
		n[12] = 0;
		n[1] = 0;
		n[5] = 2 * e / (c - b);
		n[9] = (c + b) / (c - b);
		n[13] = 0;
		n[2] = 0;
		n[6] = 0;
		n[10] = -(g + e) / (g - e);
		n[14] = -2 * g * e / (g - e);
		n[3] = 0;
		n[7] = 0;
		n[11] = -1;
		n[15] = 0;
		return this;
	}, makePerspective:function(d, a, b, c) {
		d = b * Math.tan(da.DEG2RAD * d * .5);
		var n = -d;
		return this.makeFrustum(n * a, d * a, n, d, b, c);
	}, makeOrthographic:function(d, a, b, c, e, g) {
		var n = this.elements, m = 1 / (a - d), h = 1 / (b - c), k = 1 / (g - e);
		n[0] = 2 * m;
		n[4] = 0;
		n[8] = 0;
		n[12] = -((a + d) * m);
		n[1] = 0;
		n[5] = 2 * h;
		n[9] = 0;
		n[13] = -((b + c) * h);
		n[2] = 0;
		n[6] = 0;
		n[10] = -2 * k;
		n[14] = -((g + e) * k);
		n[3] = 0;
		n[7] = 0;
		n[11] = 0;
		n[15] = 1;
		return this;
	}, equals:function(d) {
		var a = this.elements;
		d = d.elements;
		for (var b = 0;16 > b;b++) {
			if (a[b] !== d[b]) {
				return !1;
			}
		}
		return !0;
	}, fromArray:function(d, a) {
		void 0 === a && (a = 0);
		for (var n = 0;16 > n;n++) {
			this.elements[n] = d[n + a];
		}
		return this;
	}, toArray:function(d, a) {
		void 0 === d && (d = []);
		void 0 === a && (a = 0);
		var n = this.elements;
		d[a] = n[0];
		d[a + 1] = n[1];
		d[a + 2] = n[2];
		d[a + 3] = n[3];
		d[a + 4] = n[4];
		d[a + 5] = n[5];
		d[a + 6] = n[6];
		d[a + 7] = n[7];
		d[a + 8] = n[8];
		d[a + 9] = n[9];
		d[a + 10] = n[10];
		d[a + 11] = n[11];
		d[a + 12] = n[12];
		d[a + 13] = n[13];
		d[a + 14] = n[14];
		d[a + 15] = n[15];
		return d;
	}};
	r.prototype = Object.create(b.prototype);
	r.prototype.constructor = r;
	r.prototype.isCubeTexture = !0;
	Object.defineProperty(r.prototype, "images", {get:function() {
		return this.image;
	}, set:function(d) {
		this.image = d;
	}});
	var Ae = new b, Be = new r, ye = [], ze = [];
	ia.prototype.setValue = function(d, a) {
		for (var n = this.seq, b = 0, c = n.length;b !== c;++b) {
			var e = n[b];
			e.setValue(d, a[e.id]);
		}
	};
	var Ud = /([\w\d_]+)(\])?(\[|\.)?/g;
	va.prototype.setValue = function(d, a, b) {
		a = this.map[a];
		void 0 !== a && a.setValue(d, b, this.renderer);
	};
	va.prototype.set = function(d, a, b) {
		var n = this.map[b];
		void 0 !== n && n.setValue(d, a[b], this.renderer);
	};
	va.prototype.setOptional = function(d, a, b) {
		a = a[b];
		void 0 !== a && this.setValue(d, b, a);
	};
	va.upload = function(d, a, b, c) {
		for (var n = 0, e = a.length;n !== e;++n) {
			var g = a[n], m = b[g.id];
			!1 !== m.needsUpdate && g.setValue(d, m.value, c);
		}
	};
	va.seqWithValue = function(d, a) {
		for (var n = [], b = 0, c = d.length;b !== c;++b) {
			var e = d[b];
			e.id in a && n.push(e);
		}
		return n;
	};
	var ka = {alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n", alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n", alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n", aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n", 
	aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex:"\nvec3 transformed = vec3( position );\n", beginnormal_vertex:"\nvec3 objectNormal = vec3( normal );\n", bsdfs:"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\n\tint config = 0;\n\tif ( L[0].z > 0.0 ) config += 1;\n\tif ( L[1].z > 0.0 ) config += 2;\n\tif ( L[2].z > 0.0 ) config += 4;\n\tif ( L[3].z > 0.0 ) config += 8;\n\tn = 0;\n\tif ( config == 0 ) {\n\t} else if ( config == 1 ) {\n\t\tn = 3;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 2 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 3 ) {\n\t\tn = 4;\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 4 ) {\n\t\tn = 3;\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t} else if ( config == 5 ) {\n\t\tn = 0;\n\t} else if ( config == 6 ) {\n\t\tn = 4;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 7 ) {\n\t\tn = 5;\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 8 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] =  L[3];\n\t} else if ( config == 9 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\n\t} else if ( config == 10 ) {\n\t\tn = 0;\n\t} else if ( config == 11 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 12 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t} else if ( config == 13 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = L[2];\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t} else if ( config == 14 ) {\n\t\tn = 5;\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t} else if ( config == 15 ) {\n\t\tn = 4;\n\t}\n\tif ( n == 3 )\n\t\tL[3] = L[0];\n\tif ( n == 4 )\n\t\tL[4] = L[0];\n}\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\n\tfloat cosTheta = dot( v1, v2 );\n\tfloat theta = acos( cosTheta );\n\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\n\treturn res;\n}\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\n\trectPoints[0] = pos - halfWidth - halfHeight;\n\trectPoints[1] = pos + halfWidth - halfHeight;\n\trectPoints[2] = pos + halfWidth + halfHeight;\n\trectPoints[3] = pos - halfWidth + halfHeight;\n}\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot( V, N ));\n\tT2 = - cross( N, T1 );\n\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\n\tvec3 clippedRect[5];\n\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\n\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\n\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\n\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\n\tint n;\n\tclipQuadToHorizon(clippedRect, n);\n\tif ( n == 0 )\n\t\treturn vec3( 0, 0, 0 );\n\tclippedRect[0] = normalize( clippedRect[0] );\n\tclippedRect[1] = normalize( clippedRect[1] );\n\tclippedRect[2] = normalize( clippedRect[2] );\n\tclippedRect[3] = normalize( clippedRect[3] );\n\tclippedRect[4] = normalize( clippedRect[4] );\n\tfloat sum = 0.0;\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\n\tif (n >= 4)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\n\tif (n == 5)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\n\tsum = max( 0.0, sum );\n\tvec3 Lo_i = vec3( sum, sum, sum );\n\treturn Lo_i;\n}\nvec3 Rect_Area_Light_Specular_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\n\t\tconst in float roughness,\n\t\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tvec2 uv = ltcTextureCoords( geometry, roughness );\n\tvec4 brdfLtcApproxParams, t;\n\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\n\tt = texture2D( ltcMat, uv );\n\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\n\tmat3 brdfLtcApproxMat = mat3(\n\t\tvec3(   1,   0, t.y ),\n\t\tvec3(   0, t.z,   0 ),\n\t\tvec3( t.w,   0, t.x )\n\t);\n\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\n\tspecularReflectance *= brdfLtcScalar;\n\treturn specularReflectance;\n}\nvec3 Rect_Area_Light_Diffuse_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tmat3 diffuseBrdfMat = mat3(1);\n\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\n\treturn diffuseReflectance;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n", 
	bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n", 
	clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n", 
	clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n", clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n", clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n", 
	color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n", color_pars_vertex:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex:"#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common:"#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n", 
	cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n", 
	defaultnormal_vertex:"#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n", displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n", displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n", emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n", 
	emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n", encodings_fragment:"  gl_FragColor = linearToOutputTexel( gl_FragColor );\n", encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n", 
	envmap_fragment:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n", 
	envmap_pars_fragment:"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n", 
	envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n", envmap_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n", 
	fog_fragment:"#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n", fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", 
	gradientmap_pars_fragment:"#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n", lightmap_fragment:"#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n", 
	lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n", 
	lights_pars:"uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n", 
	lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n", lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n    void RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n        vec3 matDiffColor = material.diffuseColor;\n        vec3 matSpecColor = material.specularColor;\n        vec3 lightColor   = rectAreaLight.color;\n        float roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n        vec3 spec = Rect_Area_Light_Specular_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n                roughness,\n                ltcMat, ltcMag );\n        vec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n        reflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\n        reflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\n    }\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n", 
	lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n", 
	lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n    void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n        vec3 matDiffColor = material.diffuseColor;\n        vec3 matSpecColor = material.specularColor;\n        vec3 lightColor   = rectAreaLight.color;\n        float roughness = material.specularRoughness;\n        vec3 spec = Rect_Area_Light_Specular_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n                roughness,\n                ltcMat, ltcMag );\n        vec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n        reflectedLight.directSpecular += lightColor * matSpecColor * spec;\n        reflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\n    }\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n", 
	lights_template:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n", 
	logdepthbuf_fragment:"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment:"#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n", logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif", logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n", 
	map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n", map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n", map_particle_fragment:"#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n", map_particle_pars_fragment:"#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n", 
	metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n", metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n", 
	morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n", 
	normal_flip:"#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n", normal_fragment:"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n", 
	normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n", 
	packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n", 
	premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n", project_vertex:"#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n", roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n", 
	roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n    #if NUM_RECT_AREA_LIGHTS > 0\n    #endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n", 
	shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n    #if NUM_RECT_AREA_LIGHTS > 0\n    #endif\n#endif\n", 
	shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n    #if NUM_RECT_AREA_LIGHTS > 0\n    #endif\n#endif\n", 
	shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\t#endif\n\t#endif\n\treturn shadow;\n}\n", 
	skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n", 
	skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n", skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n", 
	specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment:"#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n", tonemapping_pars_fragment:"#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n", 
	uv_pars_fragment:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n", 
	uv_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif", uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif", 
	uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n", cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n", 
	cube_vert:"varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n", depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n", 
	depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", 
	distanceRGBA_frag:"uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n", distanceRGBA_vert:"varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n", 
	equirect_frag:"uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n", equirect_vert:"varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n", 
	linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
	linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
	meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n", 
	meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
	meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n", 
	meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
	meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n", 
	meshphysical_frag:"#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
	meshphysical_vert:"#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n", 
	normal_frag:"uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n", normal_vert:"varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", 
	points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
	points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n", 
	shadow_frag:"uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n", shadow_vert:"#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"};
	T.prototype = {constructor:T, isColor:!0, r:1, g:1, b:1, set:function(d) {
		d && d.isColor ? this.copy(d) : "number" === typeof d ? this.setHex(d) : "string" === typeof d && this.setStyle(d);
		return this;
	}, setScalar:function(d) {
		this.b = this.g = this.r = d;
		return this;
	}, setHex:function(d) {
		d = Math.floor(d);
		this.r = (d >> 16 & 255) / 255;
		this.g = (d >> 8 & 255) / 255;
		this.b = (d & 255) / 255;
		return this;
	}, setRGB:function(d, a, b) {
		this.r = d;
		this.g = a;
		this.b = b;
		return this;
	}, setHSL:function() {
		function d(d, a, b) {
			0 > b && (b += 1);
			1 < b && --b;
			return b < 1 / 6 ? d + 6 * (a - d) * b : .5 > b ? a : b < 2 / 3 ? d + 6 * (a - d) * (2 / 3 - b) : d;
		}
		return function(a, b, c) {
			a = da.euclideanModulo(a, 1);
			b = da.clamp(b, 0, 1);
			c = da.clamp(c, 0, 1);
			0 === b ? this.r = this.g = this.b = c : (b = .5 >= c ? c * (1 + b) : c + b - c * b, c = 2 * c - b, this.r = d(c, b, a + 1 / 3), this.g = d(c, b, a), this.b = d(c, b, a - 1 / 3));
			return this;
		};
	}(), setStyle:function(d) {
		function a(a) {
			void 0 !== a && 1 > parseFloat(a) && console.warn("THREE.Color: Alpha component of " + d + " will be ignored.");
		}
		var b;
		if (b = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(d)) {
			var c = b[2];
			switch(b[1]) {
				case "rgb":
				;
				case "rgba":
					if (b = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(c)) {
						return this.r = Math.min(255, parseInt(b[1], 10)) / 255, this.g = Math.min(255, parseInt(b[2], 10)) / 255, this.b = Math.min(255, parseInt(b[3], 10)) / 255, a(b[5]), this;
					}
					if (b = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(c)) {
						return this.r = Math.min(100, parseInt(b[1], 10)) / 100, this.g = Math.min(100, parseInt(b[2], 10)) / 100, this.b = Math.min(100, parseInt(b[3], 10)) / 100, a(b[5]), this;
					}
					break;
				case "hsl":
				;
				case "hsla":
					if (b = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(c)) {
						var c = parseFloat(b[1]) / 360, e = parseInt(b[2], 10) / 100, g = parseInt(b[3], 10) / 100;
						a(b[5]);
						return this.setHSL(c, e, g);
					}
				;
			}
		} else {
			if (b = /^\#([A-Fa-f0-9]+)$/.exec(d)) {
				b = b[1];
				c = b.length;
				if (3 === c) {
					return this.r = parseInt(b.charAt(0) + b.charAt(0), 16) / 255, this.g = parseInt(b.charAt(1) + b.charAt(1), 16) / 255, this.b = parseInt(b.charAt(2) + b.charAt(2), 16) / 255, this;
				}
				if (6 === c) {
					return this.r = parseInt(b.charAt(0) + b.charAt(1), 16) / 255, this.g = parseInt(b.charAt(2) + b.charAt(3), 16) / 255, this.b = parseInt(b.charAt(4) + b.charAt(5), 16) / 255, this;
				}
			}
		}
		d && 0 < d.length && (b = cf[d], void 0 !== b ? this.setHex(b) : console.warn("THREE.Color: Unknown color " + d));
		return this;
	}, clone:function() {
		return new this.constructor(this.r, this.g, this.b);
	}, copy:function(d) {
		this.r = d.r;
		this.g = d.g;
		this.b = d.b;
		return this;
	}, copyGammaToLinear:function(d, a) {
		void 0 === a && (a = 2);
		this.r = Math.pow(d.r, a);
		this.g = Math.pow(d.g, a);
		this.b = Math.pow(d.b, a);
		return this;
	}, copyLinearToGamma:function(d, a) {
		void 0 === a && (a = 2);
		a = 0 < a ? 1 / a : 1;
		this.r = Math.pow(d.r, a);
		this.g = Math.pow(d.g, a);
		this.b = Math.pow(d.b, a);
		return this;
	}, convertGammaToLinear:function() {
		var d = this.r, a = this.g, b = this.b;
		this.r = d * d;
		this.g = a * a;
		this.b = b * b;
		return this;
	}, convertLinearToGamma:function() {
		this.r = Math.sqrt(this.r);
		this.g = Math.sqrt(this.g);
		this.b = Math.sqrt(this.b);
		return this;
	}, getHex:function() {
		return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
	}, getHexString:function() {
		return ("000000" + this.getHex().toString(16)).slice(-6);
	}, getHSL:function(d) {
		d = d || {h:0, s:0, l:0};
		var a = this.r, b = this.g, c = this.b, e = Math.max(a, b, c), g = Math.min(a, b, c), m, h = (g + e) / 2;
		if (g === e) {
			g = m = 0;
		} else {
			var k = e - g, g = .5 >= h ? k / (e + g) : k / (2 - e - g);
			switch(e) {
				case a:
					m = (b - c) / k + (b < c ? 6 : 0);
					break;
				case b:
					m = (c - a) / k + 2;
					break;
				case c:
					m = (a - b) / k + 4;
			}
			m /= 6;
		}
		d.h = m;
		d.s = g;
		d.l = h;
		return d;
	}, getStyle:function() {
		return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
	}, offsetHSL:function(d, a, b) {
		var n = this.getHSL();
		n.h += d;
		n.s += a;
		n.l += b;
		this.setHSL(n.h, n.s, n.l);
		return this;
	}, add:function(d) {
		this.r += d.r;
		this.g += d.g;
		this.b += d.b;
		return this;
	}, addColors:function(d, a) {
		this.r = d.r + a.r;
		this.g = d.g + a.g;
		this.b = d.b + a.b;
		return this;
	}, addScalar:function(d) {
		this.r += d;
		this.g += d;
		this.b += d;
		return this;
	}, sub:function(d) {
		this.r = Math.max(0, this.r - d.r);
		this.g = Math.max(0, this.g - d.g);
		this.b = Math.max(0, this.b - d.b);
		return this;
	}, multiply:function(d) {
		this.r *= d.r;
		this.g *= d.g;
		this.b *= d.b;
		return this;
	}, multiplyScalar:function(d) {
		this.r *= d;
		this.g *= d;
		this.b *= d;
		return this;
	}, lerp:function(d, a) {
		this.r += (d.r - this.r) * a;
		this.g += (d.g - this.g) * a;
		this.b += (d.b - this.b) * a;
		return this;
	}, equals:function(d) {
		return d.r === this.r && d.g === this.g && d.b === this.b;
	}, fromArray:function(d, a) {
		void 0 === a && (a = 0);
		this.r = d[a];
		this.g = d[a + 1];
		this.b = d[a + 2];
		return this;
	}, toArray:function(d, a) {
		void 0 === d && (d = []);
		void 0 === a && (a = 0);
		d[a] = this.r;
		d[a + 1] = this.g;
		d[a + 2] = this.b;
		return d;
	}, toJSON:function() {
		return this.getHex();
	}};
	var cf = {aliceblue:15792383, antiquewhite:16444375, aqua:65535, aquamarine:8388564, azure:15794175, beige:16119260, bisque:16770244, black:0, blanchedalmond:16772045, blue:255, blueviolet:9055202, brown:10824234, burlywood:14596231, cadetblue:6266528, chartreuse:8388352, chocolate:13789470, coral:16744272, cornflowerblue:6591981, cornsilk:16775388, crimson:14423100, cyan:65535, darkblue:139, darkcyan:35723, darkgoldenrod:12092939, darkgray:11119017, darkgreen:25600, darkgrey:11119017, darkkhaki:12433259, 
	darkmagenta:9109643, darkolivegreen:5597999, darkorange:16747520, darkorchid:10040012, darkred:9109504, darksalmon:15308410, darkseagreen:9419919, darkslateblue:4734347, darkslategray:3100495, darkslategrey:3100495, darkturquoise:52945, darkviolet:9699539, deeppink:16716947, deepskyblue:49151, dimgray:6908265, dimgrey:6908265, dodgerblue:2003199, firebrick:11674146, floralwhite:16775920, forestgreen:2263842, fuchsia:16711935, gainsboro:14474460, ghostwhite:16316671, gold:16766720, goldenrod:14329120, 
	gray:8421504, green:32768, greenyellow:11403055, grey:8421504, honeydew:15794160, hotpink:16738740, indianred:13458524, indigo:4915330, ivory:16777200, khaki:15787660, lavender:15132410, lavenderblush:16773365, lawngreen:8190976, lemonchiffon:16775885, lightblue:11393254, lightcoral:15761536, lightcyan:14745599, lightgoldenrodyellow:16448210, lightgray:13882323, lightgreen:9498256, lightgrey:13882323, lightpink:16758465, lightsalmon:16752762, lightseagreen:2142890, lightskyblue:8900346, lightslategray:7833753, 
	lightslategrey:7833753, lightsteelblue:11584734, lightyellow:16777184, lime:65280, limegreen:3329330, linen:16445670, magenta:16711935, maroon:8388608, mediumaquamarine:6737322, mediumblue:205, mediumorchid:12211667, mediumpurple:9662683, mediumseagreen:3978097, mediumslateblue:8087790, mediumspringgreen:64154, mediumturquoise:4772300, mediumvioletred:13047173, midnightblue:1644912, mintcream:16121850, mistyrose:16770273, moccasin:16770229, navajowhite:16768685, navy:128, oldlace:16643558, olive:8421376, 
	olivedrab:7048739, orange:16753920, orangered:16729344, orchid:14315734, palegoldenrod:15657130, palegreen:10025880, paleturquoise:11529966, palevioletred:14381203, papayawhip:16773077, peachpuff:16767673, peru:13468991, pink:16761035, plum:14524637, powderblue:11591910, purple:8388736, red:16711680, rosybrown:12357519, royalblue:4286945, saddlebrown:9127187, salmon:16416882, sandybrown:16032864, seagreen:3050327, seashell:16774638, sienna:10506797, silver:12632256, skyblue:8900331, slateblue:6970061, 
	slategray:7372944, slategrey:7372944, snow:16775930, springgreen:65407, steelblue:4620980, tan:13808780, teal:32896, thistle:14204888, tomato:16737095, turquoise:4251856, violet:15631086, wheat:16113331, white:16777215, whitesmoke:16119285, yellow:16776960, yellowgreen:10145074};
	pa.prototype = Object.create(b.prototype);
	pa.prototype.constructor = pa;
	pa.prototype.isDataTexture = !0;
	var na = {common:{diffuse:{value:new T(15658734)}, opacity:{value:1}, map:{value:null}, offsetRepeat:{value:new k(0, 0, 1, 1)}, specularMap:{value:null}, alphaMap:{value:null}, envMap:{value:null}, flipEnvMap:{value:-1}, reflectivity:{value:1}, refractionRatio:{value:.98}}, aomap:{aoMap:{value:null}, aoMapIntensity:{value:1}}, lightmap:{lightMap:{value:null}, lightMapIntensity:{value:1}}, emissivemap:{emissiveMap:{value:null}}, bumpmap:{bumpMap:{value:null}, bumpScale:{value:1}}, normalmap:{normalMap:{value:null}, 
	normalScale:{value:new l(1, 1)}}, displacementmap:{displacementMap:{value:null}, displacementScale:{value:1}, displacementBias:{value:0}}, roughnessmap:{roughnessMap:{value:null}}, metalnessmap:{metalnessMap:{value:null}}, gradientmap:{gradientMap:{value:null}}, fog:{fogDensity:{value:2.5E-4}, fogNear:{value:1}, fogFar:{value:2E3}, fogColor:{value:new T(16777215)}}, lights:{ambientLightColor:{value:[]}, directionalLights:{value:[], properties:{direction:{}, color:{}, shadow:{}, shadowBias:{}, shadowRadius:{}, 
	shadowMapSize:{}}}, directionalShadowMap:{value:[]}, directionalShadowMatrix:{value:[]}, spotLights:{value:[], properties:{color:{}, position:{}, direction:{}, distance:{}, coneCos:{}, penumbraCos:{}, decay:{}, shadow:{}, shadowBias:{}, shadowRadius:{}, shadowMapSize:{}}}, spotShadowMap:{value:[]}, spotShadowMatrix:{value:[]}, pointLights:{value:[], properties:{color:{}, position:{}, decay:{}, distance:{}, shadow:{}, shadowBias:{}, shadowRadius:{}, shadowMapSize:{}}}, pointShadowMap:{value:[]}, 
	pointShadowMatrix:{value:[]}, hemisphereLights:{value:[], properties:{direction:{}, skyColor:{}, groundColor:{}}}, rectAreaLights:{value:[], properties:{color:{}, position:{}, width:{}, height:{}}}}, points:{diffuse:{value:new T(15658734)}, opacity:{value:1}, size:{value:1}, scale:{value:1}, map:{value:null}, offsetRepeat:{value:new k(0, 0, 1, 1)}}}, Wb = {basic:{uniforms:Object.assign({}, na.common, na.aomap, na.lightmap, na.fog), vertexShader:ka.meshbasic_vert, fragmentShader:ka.meshbasic_frag}, 
	lambert:{uniforms:Object.assign({}, na.common, na.aomap, na.lightmap, na.emissivemap, na.fog, na.lights, {emissive:{value:new T(0)}}), vertexShader:ka.meshlambert_vert, fragmentShader:ka.meshlambert_frag}, phong:{uniforms:Object.assign({}, na.common, na.aomap, na.lightmap, na.emissivemap, na.bumpmap, na.normalmap, na.displacementmap, na.gradientmap, na.fog, na.lights, {emissive:{value:new T(0)}, specular:{value:new T(1118481)}, shininess:{value:30}}), vertexShader:ka.meshphong_vert, fragmentShader:ka.meshphong_frag}, 
	standard:{uniforms:Object.assign({}, na.common, na.aomap, na.lightmap, na.emissivemap, na.bumpmap, na.normalmap, na.displacementmap, na.roughnessmap, na.metalnessmap, na.fog, na.lights, {emissive:{value:new T(0)}, roughness:{value:.5}, metalness:{value:0}, envMapIntensity:{value:1}}), vertexShader:ka.meshphysical_vert, fragmentShader:ka.meshphysical_frag}, points:{uniforms:Object.assign({}, na.points, na.fog), vertexShader:ka.points_vert, fragmentShader:ka.points_frag}, dashed:{uniforms:Object.assign({}, 
	na.common, na.fog, {scale:{value:1}, dashSize:{value:1}, totalSize:{value:2}}), vertexShader:ka.linedashed_vert, fragmentShader:ka.linedashed_frag}, depth:{uniforms:Object.assign({}, na.common, na.displacementmap), vertexShader:ka.depth_vert, fragmentShader:ka.depth_frag}, normal:{uniforms:{opacity:{value:1}}, vertexShader:ka.normal_vert, fragmentShader:ka.normal_frag}, cube:{uniforms:{tCube:{value:null}, tFlip:{value:-1}, opacity:{value:1}}, vertexShader:ka.cube_vert, fragmentShader:ka.cube_frag}, 
	equirect:{uniforms:{tEquirect:{value:null}, tFlip:{value:-1}}, vertexShader:ka.equirect_vert, fragmentShader:ka.equirect_frag}, distanceRGBA:{uniforms:{lightPos:{value:new g}}, vertexShader:ka.distanceRGBA_vert, fragmentShader:ka.distanceRGBA_frag}};
	Wb.physical = {uniforms:Object.assign({}, Wb.standard.uniforms, {clearCoat:{value:0}, clearCoatRoughness:{value:0}}), vertexShader:ka.meshphysical_vert, fragmentShader:ka.meshphysical_frag};
	ra.prototype = {constructor:ra, set:function(d, a) {
		this.min.copy(d);
		this.max.copy(a);
		return this;
	}, setFromPoints:function(d) {
		this.makeEmpty();
		for (var a = 0, b = d.length;a < b;a++) {
			this.expandByPoint(d[a]);
		}
		return this;
	}, setFromCenterAndSize:function() {
		var d = new l;
		return function(a, b) {
			b = d.copy(b).multiplyScalar(.5);
			this.min.copy(a).sub(b);
			this.max.copy(a).add(b);
			return this;
		};
	}(), clone:function() {
		return (new this.constructor).copy(this);
	}, copy:function(d) {
		this.min.copy(d.min);
		this.max.copy(d.max);
		return this;
	}, makeEmpty:function() {
		this.min.x = this.min.y = Infinity;
		this.max.x = this.max.y = -Infinity;
		return this;
	}, isEmpty:function() {
		return this.max.x < this.min.x || this.max.y < this.min.y;
	}, getCenter:function(d) {
		d = d || new l;
		return this.isEmpty() ? d.set(0, 0) : d.addVectors(this.min, this.max).multiplyScalar(.5);
	}, getSize:function(d) {
		d = d || new l;
		return this.isEmpty() ? d.set(0, 0) : d.subVectors(this.max, this.min);
	}, expandByPoint:function(d) {
		this.min.min(d);
		this.max.max(d);
		return this;
	}, expandByVector:function(d) {
		this.min.sub(d);
		this.max.add(d);
		return this;
	}, expandByScalar:function(d) {
		this.min.addScalar(-d);
		this.max.addScalar(d);
		return this;
	}, containsPoint:function(d) {
		return d.x < this.min.x || d.x > this.max.x || d.y < this.min.y || d.y > this.max.y ? !1 : !0;
	}, containsBox:function(d) {
		return this.min.x <= d.min.x && d.max.x <= this.max.x && this.min.y <= d.min.y && d.max.y <= this.max.y ? !0 : !1;
	}, getParameter:function(d, a) {
		return (a || new l).set((d.x - this.min.x) / (this.max.x - this.min.x), (d.y - this.min.y) / (this.max.y - this.min.y));
	}, intersectsBox:function(d) {
		return d.max.x < this.min.x || d.min.x > this.max.x || d.max.y < this.min.y || d.min.y > this.max.y ? !1 : !0;
	}, clampPoint:function(d, a) {
		return (a || new l).copy(d).clamp(this.min, this.max);
	}, distanceToPoint:function() {
		var d = new l;
		return function(a) {
			return d.copy(a).clamp(this.min, this.max).sub(a).length();
		};
	}(), intersect:function(d) {
		this.min.max(d.min);
		this.max.min(d.max);
		return this;
	}, union:function(d) {
		this.min.min(d.min);
		this.max.max(d.max);
		return this;
	}, translate:function(d) {
		this.min.add(d);
		this.max.add(d);
		return this;
	}, equals:function(d) {
		return d.min.equals(this.min) && d.max.equals(this.max);
	}};
	var Oe = 0;
	Z.prototype = {constructor:Z, isMaterial:!0, get needsUpdate() {
		return this._needsUpdate;
	}, set needsUpdate(d) {
		!0 === d && this.update();
		this._needsUpdate = d;
	}, setValues:function(d) {
		if (void 0 !== d) {
			for (var a in d) {
				var b = d[a];
				if (void 0 === b) {
					console.warn("THREE.Material: '" + a + "' parameter is undefined.");
				} else {
					var c = this[a];
					void 0 === c ? console.warn("THREE." + this.type + ": '" + a + "' is not a property of this material.") : c && c.isColor ? c.set(b) : c && c.isVector3 && b && b.isVector3 ? c.copy(b) : this[a] = "overdraw" === a ? Number(b) : b;
				}
			}
		}
	}, toJSON:function(d) {
		function a(d) {
			var a = [], n;
			for (n in d) {
				var b = d[n];
				delete b.metadata;
				a.push(b);
			}
			return a;
		}
		var b = void 0 === d;
		b && (d = {textures:{}, images:{}});
		var c = {metadata:{version:4.4, type:"Material", generator:"Material.toJSON"}};
		c.uuid = this.uuid;
		c.type = this.type;
		"" !== this.name && (c.name = this.name);
		this.color && this.color.isColor && (c.color = this.color.getHex());
		void 0 !== this.roughness && (c.roughness = this.roughness);
		void 0 !== this.metalness && (c.metalness = this.metalness);
		this.emissive && this.emissive.isColor && (c.emissive = this.emissive.getHex());
		this.specular && this.specular.isColor && (c.specular = this.specular.getHex());
		void 0 !== this.shininess && (c.shininess = this.shininess);
		void 0 !== this.clearCoat && (c.clearCoat = this.clearCoat);
		void 0 !== this.clearCoatRoughness && (c.clearCoatRoughness = this.clearCoatRoughness);
		this.map && this.map.isTexture && (c.map = this.map.toJSON(d).uuid);
		this.alphaMap && this.alphaMap.isTexture && (c.alphaMap = this.alphaMap.toJSON(d).uuid);
		this.lightMap && this.lightMap.isTexture && (c.lightMap = this.lightMap.toJSON(d).uuid);
		this.bumpMap && this.bumpMap.isTexture && (c.bumpMap = this.bumpMap.toJSON(d).uuid, c.bumpScale = this.bumpScale);
		this.normalMap && this.normalMap.isTexture && (c.normalMap = this.normalMap.toJSON(d).uuid, c.normalScale = this.normalScale.toArray());
		this.displacementMap && this.displacementMap.isTexture && (c.displacementMap = this.displacementMap.toJSON(d).uuid, c.displacementScale = this.displacementScale, c.displacementBias = this.displacementBias);
		this.roughnessMap && this.roughnessMap.isTexture && (c.roughnessMap = this.roughnessMap.toJSON(d).uuid);
		this.metalnessMap && this.metalnessMap.isTexture && (c.metalnessMap = this.metalnessMap.toJSON(d).uuid);
		this.emissiveMap && this.emissiveMap.isTexture && (c.emissiveMap = this.emissiveMap.toJSON(d).uuid);
		this.specularMap && this.specularMap.isTexture && (c.specularMap = this.specularMap.toJSON(d).uuid);
		this.envMap && this.envMap.isTexture && (c.envMap = this.envMap.toJSON(d).uuid, c.reflectivity = this.reflectivity);
		this.gradientMap && this.gradientMap.isTexture && (c.gradientMap = this.gradientMap.toJSON(d).uuid);
		void 0 !== this.size && (c.size = this.size);
		void 0 !== this.sizeAttenuation && (c.sizeAttenuation = this.sizeAttenuation);
		1 !== this.blending && (c.blending = this.blending);
		2 !== this.shading && (c.shading = this.shading);
		0 !== this.side && (c.side = this.side);
		0 !== this.vertexColors && (c.vertexColors = this.vertexColors);
		1 > this.opacity && (c.opacity = this.opacity);
		!0 === this.transparent && (c.transparent = this.transparent);
		c.depthFunc = this.depthFunc;
		c.depthTest = this.depthTest;
		c.depthWrite = this.depthWrite;
		0 < this.alphaTest && (c.alphaTest = this.alphaTest);
		!0 === this.premultipliedAlpha && (c.premultipliedAlpha = this.premultipliedAlpha);
		!0 === this.wireframe && (c.wireframe = this.wireframe);
		1 < this.wireframeLinewidth && (c.wireframeLinewidth = this.wireframeLinewidth);
		"round" !== this.wireframeLinecap && (c.wireframeLinecap = this.wireframeLinecap);
		"round" !== this.wireframeLinejoin && (c.wireframeLinejoin = this.wireframeLinejoin);
		c.skinning = this.skinning;
		c.morphTargets = this.morphTargets;
		b && (b = a(d.textures), d = a(d.images), 0 < b.length && (c.textures = b), 0 < d.length && (c.images = d));
		return c;
	}, clone:function() {
		return (new this.constructor).copy(this);
	}, copy:function(d) {
		this.name = d.name;
		this.fog = d.fog;
		this.lights = d.lights;
		this.blending = d.blending;
		this.side = d.side;
		this.shading = d.shading;
		this.vertexColors = d.vertexColors;
		this.opacity = d.opacity;
		this.transparent = d.transparent;
		this.blendSrc = d.blendSrc;
		this.blendDst = d.blendDst;
		this.blendEquation = d.blendEquation;
		this.blendSrcAlpha = d.blendSrcAlpha;
		this.blendDstAlpha = d.blendDstAlpha;
		this.blendEquationAlpha = d.blendEquationAlpha;
		this.depthFunc = d.depthFunc;
		this.depthTest = d.depthTest;
		this.depthWrite = d.depthWrite;
		this.colorWrite = d.colorWrite;
		this.precision = d.precision;
		this.polygonOffset = d.polygonOffset;
		this.polygonOffsetFactor = d.polygonOffsetFactor;
		this.polygonOffsetUnits = d.polygonOffsetUnits;
		this.alphaTest = d.alphaTest;
		this.premultipliedAlpha = d.premultipliedAlpha;
		this.overdraw = d.overdraw;
		this.visible = d.visible;
		this.clipShadows = d.clipShadows;
		this.clipIntersection = d.clipIntersection;
		d = d.clippingPlanes;
		var a = null;
		if (null !== d) {
			for (var b = d.length, a = Array(b), c = 0;c !== b;++c) {
				a[c] = d[c].clone();
			}
		}
		this.clippingPlanes = a;
		return this;
	}, update:function() {
		this.dispatchEvent({type:"update"});
	}, dispose:function() {
		this.dispatchEvent({type:"dispose"});
	}};
	Object.assign(Z.prototype, f.prototype);
	ua.prototype = Object.create(Z.prototype);
	ua.prototype.constructor = ua;
	ua.prototype.isShaderMaterial = !0;
	ua.prototype.copy = function(d) {
		Z.prototype.copy.call(this, d);
		this.fragmentShader = d.fragmentShader;
		this.vertexShader = d.vertexShader;
		this.uniforms = Object.assign({}, d.uniforms);
		this.defines = d.defines;
		this.wireframe = d.wireframe;
		this.wireframeLinewidth = d.wireframeLinewidth;
		this.lights = d.lights;
		this.clipping = d.clipping;
		this.skinning = d.skinning;
		this.morphTargets = d.morphTargets;
		this.morphNormals = d.morphNormals;
		this.extensions = d.extensions;
		return this;
	};
	ua.prototype.toJSON = function(d) {
		d = Z.prototype.toJSON.call(this, d);
		d.uniforms = this.uniforms;
		d.vertexShader = this.vertexShader;
		d.fragmentShader = this.fragmentShader;
		return d;
	};
	sa.prototype = Object.create(Z.prototype);
	sa.prototype.constructor = sa;
	sa.prototype.isMeshDepthMaterial = !0;
	sa.prototype.copy = function(d) {
		Z.prototype.copy.call(this, d);
		this.depthPacking = d.depthPacking;
		this.skinning = d.skinning;
		this.morphTargets = d.morphTargets;
		this.map = d.map;
		this.alphaMap = d.alphaMap;
		this.displacementMap = d.displacementMap;
		this.displacementScale = d.displacementScale;
		this.displacementBias = d.displacementBias;
		this.wireframe = d.wireframe;
		this.wireframeLinewidth = d.wireframeLinewidth;
		return this;
	};
	Ba.prototype = {constructor:Ba, isBox3:!0, set:function(d, a) {
		this.min.copy(d);
		this.max.copy(a);
		return this;
	}, setFromArray:function(d) {
		for (var a = Infinity, b = Infinity, c = Infinity, e = -Infinity, g = -Infinity, m = -Infinity, h = 0, k = d.length;h < k;h += 3) {
			var q = d[h], f = d[h + 1], p = d[h + 2];
			q < a && (a = q);
			f < b && (b = f);
			p < c && (c = p);
			q > e && (e = q);
			f > g && (g = f);
			p > m && (m = p);
		}
		this.min.set(a, b, c);
		this.max.set(e, g, m);
	}, setFromPoints:function(d) {
		this.makeEmpty();
		for (var a = 0, b = d.length;a < b;a++) {
			this.expandByPoint(d[a]);
		}
		return this;
	}, setFromCenterAndSize:function() {
		var d = new g;
		return function(a, b) {
			b = d.copy(b).multiplyScalar(.5);
			this.min.copy(a).sub(b);
			this.max.copy(a).add(b);
			return this;
		};
	}(), setFromObject:function() {
		var d = new g;
		return function(a) {
			var b = this;
			a.updateMatrixWorld(!0);
			this.makeEmpty();
			a.traverse(function(a) {
				var n = a.geometry;
				if (void 0 !== n) {
					if (n.isGeometry) {
						for (var n = n.vertices, c = 0, e = n.length;c < e;c++) {
							d.copy(n[c]), d.applyMatrix4(a.matrixWorld), b.expandByPoint(d);
						}
					} else {
						if (n.isBufferGeometry && (e = n.attributes.position, void 0 !== e)) {
							var g;
							e.isInterleavedBufferAttribute ? (n = e.data.array, c = e.offset, g = e.data.stride) : (n = e.array, c = 0, g = 3);
							for (e = n.length;c < e;c += g) {
								d.fromArray(n, c), d.applyMatrix4(a.matrixWorld), b.expandByPoint(d);
							}
						}
					}
				}
			});
			return this;
		};
	}(), clone:function() {
		return (new this.constructor).copy(this);
	}, copy:function(d) {
		this.min.copy(d.min);
		this.max.copy(d.max);
		return this;
	}, makeEmpty:function() {
		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = -Infinity;
		return this;
	}, isEmpty:function() {
		return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
	}, getCenter:function(d) {
		d = d || new g;
		return this.isEmpty() ? d.set(0, 0, 0) : d.addVectors(this.min, this.max).multiplyScalar(.5);
	}, getSize:function(d) {
		d = d || new g;
		return this.isEmpty() ? d.set(0, 0, 0) : d.subVectors(this.max, this.min);
	}, expandByPoint:function(d) {
		this.min.min(d);
		this.max.max(d);
		return this;
	}, expandByVector:function(d) {
		this.min.sub(d);
		this.max.add(d);
		return this;
	}, expandByScalar:function(d) {
		this.min.addScalar(-d);
		this.max.addScalar(d);
		return this;
	}, containsPoint:function(d) {
		return d.x < this.min.x || d.x > this.max.x || d.y < this.min.y || d.y > this.max.y || d.z < this.min.z || d.z > this.max.z ? !1 : !0;
	}, containsBox:function(d) {
		return this.min.x <= d.min.x && d.max.x <= this.max.x && this.min.y <= d.min.y && d.max.y <= this.max.y && this.min.z <= d.min.z && d.max.z <= this.max.z ? !0 : !1;
	}, getParameter:function(d, a) {
		return (a || new g).set((d.x - this.min.x) / (this.max.x - this.min.x), (d.y - this.min.y) / (this.max.y - this.min.y), (d.z - this.min.z) / (this.max.z - this.min.z));
	}, intersectsBox:function(d) {
		return d.max.x < this.min.x || d.min.x > this.max.x || d.max.y < this.min.y || d.min.y > this.max.y || d.max.z < this.min.z || d.min.z > this.max.z ? !1 : !0;
	}, intersectsSphere:function() {
		var d;
		return function(a) {
			void 0 === d && (d = new g);
			this.clampPoint(a.center, d);
			return d.distanceToSquared(a.center) <= a.radius * a.radius;
		};
	}(), intersectsPlane:function(d) {
		var a, b;
		0 < d.normal.x ? (a = d.normal.x * this.min.x, b = d.normal.x * this.max.x) : (a = d.normal.x * this.max.x, b = d.normal.x * this.min.x);
		0 < d.normal.y ? (a += d.normal.y * this.min.y, b += d.normal.y * this.max.y) : (a += d.normal.y * this.max.y, b += d.normal.y * this.min.y);
		0 < d.normal.z ? (a += d.normal.z * this.min.z, b += d.normal.z * this.max.z) : (a += d.normal.z * this.max.z, b += d.normal.z * this.min.z);
		return a <= d.constant && b >= d.constant;
	}, clampPoint:function(d, a) {
		return (a || new g).copy(d).clamp(this.min, this.max);
	}, distanceToPoint:function() {
		var d = new g;
		return function(a) {
			return d.copy(a).clamp(this.min, this.max).sub(a).length();
		};
	}(), getBoundingSphere:function() {
		var d = new g;
		return function(a) {
			a = a || new Ca;
			this.getCenter(a.center);
			a.radius = .5 * this.getSize(d).length();
			return a;
		};
	}(), intersect:function(d) {
		this.min.max(d.min);
		this.max.min(d.max);
		this.isEmpty() && this.makeEmpty();
		return this;
	}, union:function(d) {
		this.min.min(d.min);
		this.max.max(d.max);
		return this;
	}, applyMatrix4:function() {
		var d = [new g, new g, new g, new g, new g, new g, new g, new g];
		return function(a) {
			if (this.isEmpty()) {
				return this;
			}
			d[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(a);
			d[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(a);
			d[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(a);
			d[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(a);
			d[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(a);
			d[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(a);
			d[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(a);
			d[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(a);
			this.setFromPoints(d);
			return this;
		};
	}(), translate:function(d) {
		this.min.add(d);
		this.max.add(d);
		return this;
	}, equals:function(d) {
		return d.min.equals(this.min) && d.max.equals(this.max);
	}};
	Ca.prototype = {constructor:Ca, set:function(d, a) {
		this.center.copy(d);
		this.radius = a;
		return this;
	}, setFromPoints:function() {
		var d = new Ba;
		return function(a, b) {
			var n = this.center;
			void 0 !== b ? n.copy(b) : d.setFromPoints(a).getCenter(n);
			for (var c = b = 0, e = a.length;c < e;c++) {
				b = Math.max(b, n.distanceToSquared(a[c]));
			}
			this.radius = Math.sqrt(b);
			return this;
		};
	}(), clone:function() {
		return (new this.constructor).copy(this);
	}, copy:function(d) {
		this.center.copy(d.center);
		this.radius = d.radius;
		return this;
	}, empty:function() {
		return 0 >= this.radius;
	}, containsPoint:function(d) {
		return d.distanceToSquared(this.center) <= this.radius * this.radius;
	}, distanceToPoint:function(d) {
		return d.distanceTo(this.center) - this.radius;
	}, intersectsSphere:function(d) {
		var a = this.radius + d.radius;
		return d.center.distanceToSquared(this.center) <= a * a;
	}, intersectsBox:function(d) {
		return d.intersectsSphere(this);
	}, intersectsPlane:function(d) {
		return Math.abs(this.center.dot(d.normal) - d.constant) <= this.radius;
	}, clampPoint:function(d, a) {
		var b = this.center.distanceToSquared(d);
		a = a || new g;
		a.copy(d);
		b > this.radius * this.radius && (a.sub(this.center).normalize(), a.multiplyScalar(this.radius).add(this.center));
		return a;
	}, getBoundingBox:function(d) {
		d = d || new Ba;
		d.set(this.center, this.center);
		d.expandByScalar(this.radius);
		return d;
	}, applyMatrix4:function(d) {
		this.center.applyMatrix4(d);
		this.radius *= d.getMaxScaleOnAxis();
		return this;
	}, translate:function(d) {
		this.center.add(d);
		return this;
	}, equals:function(d) {
		return d.center.equals(this.center) && d.radius === this.radius;
	}};
	ya.prototype = {constructor:ya, isMatrix3:!0, set:function(d, a, b, c, e, g, m, h, k) {
		var n = this.elements;
		n[0] = d;
		n[1] = c;
		n[2] = m;
		n[3] = a;
		n[4] = e;
		n[5] = h;
		n[6] = b;
		n[7] = g;
		n[8] = k;
		return this;
	}, identity:function() {
		this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
		return this;
	}, clone:function() {
		return (new this.constructor).fromArray(this.elements);
	}, copy:function(d) {
		d = d.elements;
		this.set(d[0], d[3], d[6], d[1], d[4], d[7], d[2], d[5], d[8]);
		return this;
	}, setFromMatrix4:function(d) {
		d = d.elements;
		this.set(d[0], d[4], d[8], d[1], d[5], d[9], d[2], d[6], d[10]);
		return this;
	}, applyToVector3Array:function() {
		var d;
		return function(a, b, c) {
			void 0 === d && (d = new g);
			void 0 === b && (b = 0);
			void 0 === c && (c = a.length);
			for (var n = 0;n < c;n += 3, b += 3) {
				d.fromArray(a, b), d.applyMatrix3(this), d.toArray(a, b);
			}
			return a;
		};
	}(), applyToBuffer:function() {
		var d;
		return function(a, b, c) {
			void 0 === d && (d = new g);
			void 0 === b && (b = 0);
			void 0 === c && (c = a.length / a.itemSize);
			for (var n = 0;n < c;n++, b++) {
				d.x = a.getX(b), d.y = a.getY(b), d.z = a.getZ(b), d.applyMatrix3(this), a.setXYZ(b, d.x, d.y, d.z);
			}
			return a;
		};
	}(), multiplyScalar:function(d) {
		var a = this.elements;
		a[0] *= d;
		a[3] *= d;
		a[6] *= d;
		a[1] *= d;
		a[4] *= d;
		a[7] *= d;
		a[2] *= d;
		a[5] *= d;
		a[8] *= d;
		return this;
	}, determinant:function() {
		var d = this.elements, a = d[0], b = d[1], c = d[2], e = d[3], g = d[4], m = d[5], h = d[6], k = d[7], d = d[8];
		return a * g * d - a * m * k - b * e * d + b * m * h + c * e * k - c * g * h;
	}, getInverse:function(d, a) {
		d && d.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
		d = d.elements;
		var b = this.elements, n = d[0], c = d[1], e = d[2], g = d[3], m = d[4], h = d[5], k = d[6], q = d[7];
		d = d[8];
		var f = d * m - h * q, p = h * k - d * g, r = q * g - m * k, u = n * f + c * p + e * r;
		if (0 === u) {
			if (!0 === a) {
				throw Error("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
			}
			console.warn("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
			return this.identity();
		}
		u = 1 / u;
		b[0] = f * u;
		b[1] = (e * q - d * c) * u;
		b[2] = (h * c - e * m) * u;
		b[3] = p * u;
		b[4] = (d * n - e * k) * u;
		b[5] = (e * g - h * n) * u;
		b[6] = r * u;
		b[7] = (c * k - q * n) * u;
		b[8] = (m * n - c * g) * u;
		return this;
	}, transpose:function() {
		var d, a = this.elements;
		d = a[1];
		a[1] = a[3];
		a[3] = d;
		d = a[2];
		a[2] = a[6];
		a[6] = d;
		d = a[5];
		a[5] = a[7];
		a[7] = d;
		return this;
	}, getNormalMatrix:function(d) {
		return this.setFromMatrix4(d).getInverse(this).transpose();
	}, transposeIntoArray:function(d) {
		var a = this.elements;
		d[0] = a[0];
		d[1] = a[3];
		d[2] = a[6];
		d[3] = a[1];
		d[4] = a[4];
		d[5] = a[7];
		d[6] = a[2];
		d[7] = a[5];
		d[8] = a[8];
		return this;
	}, fromArray:function(d, a) {
		void 0 === a && (a = 0);
		for (var b = 0;9 > b;b++) {
			this.elements[b] = d[b + a];
		}
		return this;
	}, toArray:function(d, a) {
		void 0 === d && (d = []);
		void 0 === a && (a = 0);
		var b = this.elements;
		d[a] = b[0];
		d[a + 1] = b[1];
		d[a + 2] = b[2];
		d[a + 3] = b[3];
		d[a + 4] = b[4];
		d[a + 5] = b[5];
		d[a + 6] = b[6];
		d[a + 7] = b[7];
		d[a + 8] = b[8];
		return d;
	}};
	wa.prototype = {constructor:wa, set:function(d, a) {
		this.normal.copy(d);
		this.constant = a;
		return this;
	}, setComponents:function(d, a, b, c) {
		this.normal.set(d, a, b);
		this.constant = c;
		return this;
	}, setFromNormalAndCoplanarPoint:function(d, a) {
		this.normal.copy(d);
		this.constant = -a.dot(this.normal);
		return this;
	}, setFromCoplanarPoints:function() {
		var d = new g, a = new g;
		return function(b, n, c) {
			n = d.subVectors(c, n).cross(a.subVectors(b, n)).normalize();
			this.setFromNormalAndCoplanarPoint(n, b);
			return this;
		};
	}(), clone:function() {
		return (new this.constructor).copy(this);
	}, copy:function(d) {
		this.normal.copy(d.normal);
		this.constant = d.constant;
		return this;
	}, normalize:function() {
		var d = 1 / this.normal.length();
		this.normal.multiplyScalar(d);
		this.constant *= d;
		return this;
	}, negate:function() {
		this.constant *= -1;
		this.normal.negate();
		return this;
	}, distanceToPoint:function(d) {
		return this.normal.dot(d) + this.constant;
	}, distanceToSphere:function(d) {
		return this.distanceToPoint(d.center) - d.radius;
	}, projectPoint:function(d, a) {
		return this.orthoPoint(d, a).sub(d).negate();
	}, orthoPoint:function(d, a) {
		d = this.distanceToPoint(d);
		return (a || new g).copy(this.normal).multiplyScalar(d);
	}, intersectLine:function() {
		var d = new g;
		return function(a, b) {
			b = b || new g;
			var n = a.delta(d), c = this.normal.dot(n);
			if (0 === c) {
				if (0 === this.distanceToPoint(a.start)) {
					return b.copy(a.start);
				}
			} else {
				return c = -(a.start.dot(this.normal) + this.constant) / c, 0 > c || 1 < c ? void 0 : b.copy(n).multiplyScalar(c).add(a.start);
			}
		};
	}(), intersectsLine:function(d) {
		var a = this.distanceToPoint(d.start);
		d = this.distanceToPoint(d.end);
		return 0 > a && 0 < d || 0 > d && 0 < a;
	}, intersectsBox:function(d) {
		return d.intersectsPlane(this);
	}, intersectsSphere:function(d) {
		return d.intersectsPlane(this);
	}, coplanarPoint:function(d) {
		return (d || new g).copy(this.normal).multiplyScalar(-this.constant);
	}, applyMatrix4:function() {
		var d = new g, a = new ya;
		return function(b, n) {
			var c = this.coplanarPoint(d).applyMatrix4(b);
			b = n || a.getNormalMatrix(b);
			b = this.normal.applyMatrix3(b).normalize();
			this.constant = -c.dot(b);
			return this;
		};
	}(), translate:function(d) {
		this.constant -= d.dot(this.normal);
		return this;
	}, equals:function(d) {
		return d.normal.equals(this.normal) && d.constant === this.constant;
	}};
	Sa.prototype = {constructor:Sa, set:function(d, a, b, c, e, g) {
		var n = this.planes;
		n[0].copy(d);
		n[1].copy(a);
		n[2].copy(b);
		n[3].copy(c);
		n[4].copy(e);
		n[5].copy(g);
		return this;
	}, clone:function() {
		return (new this.constructor).copy(this);
	}, copy:function(d) {
		for (var a = this.planes, b = 0;6 > b;b++) {
			a[b].copy(d.planes[b]);
		}
		return this;
	}, setFromMatrix:function(d) {
		var a = this.planes, b = d.elements;
		d = b[0];
		var c = b[1], e = b[2], g = b[3], m = b[4], h = b[5], k = b[6], q = b[7], f = b[8], p = b[9], r = b[10], u = b[11], l = b[12], w = b[13], t = b[14], b = b[15];
		a[0].setComponents(g - d, q - m, u - f, b - l).normalize();
		a[1].setComponents(g + d, q + m, u + f, b + l).normalize();
		a[2].setComponents(g + c, q + h, u + p, b + w).normalize();
		a[3].setComponents(g - c, q - h, u - p, b - w).normalize();
		a[4].setComponents(g - e, q - k, u - r, b - t).normalize();
		a[5].setComponents(g + e, q + k, u + r, b + t).normalize();
		return this;
	}, intersectsObject:function() {
		var d = new Ca;
		return function(a) {
			var b = a.geometry;
			null === b.boundingSphere && b.computeBoundingSphere();
			d.copy(b.boundingSphere).applyMatrix4(a.matrixWorld);
			return this.intersectsSphere(d);
		};
	}(), intersectsSprite:function() {
		var d = new Ca;
		return function(a) {
			d.center.set(0, 0, 0);
			d.radius = .7071067811865476;
			d.applyMatrix4(a.matrixWorld);
			return this.intersectsSphere(d);
		};
	}(), intersectsSphere:function(d) {
		var a = this.planes, b = d.center;
		d = -d.radius;
		for (var c = 0;6 > c;c++) {
			if (a[c].distanceToPoint(b) < d) {
				return !1;
			}
		}
		return !0;
	}, intersectsBox:function() {
		var d = new g, a = new g;
		return function(b) {
			for (var n = this.planes, c = 0;6 > c;c++) {
				var e = n[c];
				d.x = 0 < e.normal.x ? b.min.x : b.max.x;
				a.x = 0 < e.normal.x ? b.max.x : b.min.x;
				d.y = 0 < e.normal.y ? b.min.y : b.max.y;
				a.y = 0 < e.normal.y ? b.max.y : b.min.y;
				d.z = 0 < e.normal.z ? b.min.z : b.max.z;
				a.z = 0 < e.normal.z ? b.max.z : b.min.z;
				var g = e.distanceToPoint(d), e = e.distanceToPoint(a);
				if (0 > g && 0 > e) {
					return !1;
				}
			}
			return !0;
		};
	}(), containsPoint:function(d) {
		for (var a = this.planes, b = 0;6 > b;b++) {
			if (0 > a[b].distanceToPoint(d)) {
				return !1;
			}
		}
		return !0;
	}};
	jb.prototype = {constructor:jb, set:function(d, a) {
		this.origin.copy(d);
		this.direction.copy(a);
		return this;
	}, clone:function() {
		return (new this.constructor).copy(this);
	}, copy:function(d) {
		this.origin.copy(d.origin);
		this.direction.copy(d.direction);
		return this;
	}, at:function(d, a) {
		return (a || new g).copy(this.direction).multiplyScalar(d).add(this.origin);
	}, lookAt:function(d) {
		this.direction.copy(d).sub(this.origin).normalize();
		return this;
	}, recast:function() {
		var d = new g;
		return function(a) {
			this.origin.copy(this.at(a, d));
			return this;
		};
	}(), closestPointToPoint:function(d, a) {
		a = a || new g;
		a.subVectors(d, this.origin);
		d = a.dot(this.direction);
		return 0 > d ? a.copy(this.origin) : a.copy(this.direction).multiplyScalar(d).add(this.origin);
	}, distanceToPoint:function(d) {
		return Math.sqrt(this.distanceSqToPoint(d));
	}, distanceSqToPoint:function() {
		var d = new g;
		return function(a) {
			var b = d.subVectors(a, this.origin).dot(this.direction);
			if (0 > b) {
				return this.origin.distanceToSquared(a);
			}
			d.copy(this.direction).multiplyScalar(b).add(this.origin);
			return d.distanceToSquared(a);
		};
	}(), distanceSqToSegment:function() {
		var d = new g, a = new g, b = new g;
		return function(n, c, e, g) {
			d.copy(n).add(c).multiplyScalar(.5);
			a.copy(c).sub(n).normalize();
			b.copy(this.origin).sub(d);
			var m = .5 * n.distanceTo(c), h = -this.direction.dot(a), k = b.dot(this.direction), q = -b.dot(a), f = b.lengthSq(), p = Math.abs(1 - h * h), r;
			0 < p ? (n = h * q - k, c = h * k - q, r = m * p, 0 <= n ? c >= -r ? c <= r ? (m = 1 / p, n *= m, c *= m, h = n * (n + h * c + 2 * k) + c * (h * n + c + 2 * q) + f) : (c = m, n = Math.max(0, -(h * c + k)), h = -n * n + c * (c + 2 * q) + f) : (c = -m, n = Math.max(0, -(h * c + k)), h = -n * n + c * (c + 2 * q) + f) : c <= -r ? (n = Math.max(0, -(-h * m + k)), c = 0 < n ? -m : Math.min(Math.max(-m, -q), m), h = -n * n + c * (c + 2 * q) + f) : c <= r ? (n = 0, c = Math.min(Math.max(-m, -q), m), 
			h = c * (c + 2 * q) + f) : (n = Math.max(0, -(h * m + k)), c = 0 < n ? m : Math.min(Math.max(-m, -q), m), h = -n * n + c * (c + 2 * q) + f)) : (c = 0 < h ? -m : m, n = Math.max(0, -(h * c + k)), h = -n * n + c * (c + 2 * q) + f);
			e && e.copy(this.direction).multiplyScalar(n).add(this.origin);
			g && g.copy(a).multiplyScalar(c).add(d);
			return h;
		};
	}(), intersectSphere:function() {
		var d = new g;
		return function(a, b) {
			d.subVectors(a.center, this.origin);
			var n = d.dot(this.direction), c = d.dot(d) - n * n;
			a = a.radius * a.radius;
			if (c > a) {
				return null;
			}
			a = Math.sqrt(a - c);
			c = n - a;
			n += a;
			return 0 > c && 0 > n ? null : 0 > c ? this.at(n, b) : this.at(c, b);
		};
	}(), intersectsSphere:function(d) {
		return this.distanceToPoint(d.center) <= d.radius;
	}, distanceToPlane:function(d) {
		var a = d.normal.dot(this.direction);
		if (0 === a) {
			return 0 === d.distanceToPoint(this.origin) ? 0 : null;
		}
		d = -(this.origin.dot(d.normal) + d.constant) / a;
		return 0 <= d ? d : null;
	}, intersectPlane:function(d, a) {
		d = this.distanceToPlane(d);
		return null === d ? null : this.at(d, a);
	}, intersectsPlane:function(d) {
		var a = d.distanceToPoint(this.origin);
		return 0 === a || 0 > d.normal.dot(this.direction) * a ? !0 : !1;
	}, intersectBox:function(d, a) {
		var b, n, c, e, g;
		n = 1 / this.direction.x;
		e = 1 / this.direction.y;
		g = 1 / this.direction.z;
		var m = this.origin;
		0 <= n ? (b = (d.min.x - m.x) * n, n *= d.max.x - m.x) : (b = (d.max.x - m.x) * n, n *= d.min.x - m.x);
		0 <= e ? (c = (d.min.y - m.y) * e, e *= d.max.y - m.y) : (c = (d.max.y - m.y) * e, e *= d.min.y - m.y);
		if (b > e || c > n) {
			return null;
		}
		if (c > b || b !== b) {
			b = c;
		}
		if (e < n || n !== n) {
			n = e;
		}
		0 <= g ? (c = (d.min.z - m.z) * g, g *= d.max.z - m.z) : (c = (d.max.z - m.z) * g, g *= d.min.z - m.z);
		if (b > g || c > n) {
			return null;
		}
		if (c > b || b !== b) {
			b = c;
		}
		if (g < n || n !== n) {
			n = g;
		}
		return 0 > n ? null : this.at(0 <= b ? b : n, a);
	}, intersectsBox:function() {
		var d = new g;
		return function(a) {
			return null !== this.intersectBox(a, d);
		};
	}(), intersectTriangle:function() {
		var d = new g, a = new g, b = new g, c = new g;
		return function(n, e, g, m, h) {
			a.subVectors(e, n);
			b.subVectors(g, n);
			c.crossVectors(a, b);
			e = this.direction.dot(c);
			if (0 < e) {
				if (m) {
					return null;
				}
				m = 1;
			} else {
				if (0 > e) {
					m = -1, e = -e;
				} else {
					return null;
				}
			}
			d.subVectors(this.origin, n);
			n = m * this.direction.dot(b.crossVectors(d, b));
			if (0 > n) {
				return null;
			}
			g = m * this.direction.dot(a.cross(d));
			if (0 > g || n + g > e) {
				return null;
			}
			n = -m * d.dot(c);
			return 0 > n ? null : this.at(n / e, h);
		};
	}(), applyMatrix4:function(d) {
		this.direction.add(this.origin).applyMatrix4(d);
		this.origin.applyMatrix4(d);
		this.direction.sub(this.origin);
		this.direction.normalize();
		return this;
	}, equals:function(d) {
		return d.origin.equals(this.origin) && d.direction.equals(this.direction);
	}};
	kb.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
	kb.DefaultOrder = "XYZ";
	kb.prototype = {constructor:kb, isEuler:!0, get x() {
		return this._x;
	}, set x(d) {
		this._x = d;
		this.onChangeCallback();
	}, get y() {
		return this._y;
	}, set y(d) {
		this._y = d;
		this.onChangeCallback();
	}, get z() {
		return this._z;
	}, set z(d) {
		this._z = d;
		this.onChangeCallback();
	}, get order() {
		return this._order;
	}, set order(d) {
		this._order = d;
		this.onChangeCallback();
	}, set:function(d, a, b, c) {
		this._x = d;
		this._y = a;
		this._z = b;
		this._order = c || this._order;
		this.onChangeCallback();
		return this;
	}, clone:function() {
		return new this.constructor(this._x, this._y, this._z, this._order);
	}, copy:function(d) {
		this._x = d._x;
		this._y = d._y;
		this._z = d._z;
		this._order = d._order;
		this.onChangeCallback();
		return this;
	}, setFromRotationMatrix:function(d, a, b) {
		var n = da.clamp, c = d.elements;
		d = c[0];
		var e = c[4], g = c[8], m = c[1], h = c[5], k = c[9], q = c[2], f = c[6], c = c[10];
		a = a || this._order;
		"XYZ" === a ? (this._y = Math.asin(n(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-k, c), this._z = Math.atan2(-e, d)) : (this._x = Math.atan2(f, h), this._z = 0)) : "YXZ" === a ? (this._x = Math.asin(-n(k, -1, 1)), .99999 > Math.abs(k) ? (this._y = Math.atan2(g, c), this._z = Math.atan2(m, h)) : (this._y = Math.atan2(-q, d), this._z = 0)) : "ZXY" === a ? (this._x = Math.asin(n(f, -1, 1)), .99999 > Math.abs(f) ? (this._y = Math.atan2(-q, c), this._z = Math.atan2(-e, h)) : (this._y = 
		0, this._z = Math.atan2(m, d))) : "ZYX" === a ? (this._y = Math.asin(-n(q, -1, 1)), .99999 > Math.abs(q) ? (this._x = Math.atan2(f, c), this._z = Math.atan2(m, d)) : (this._x = 0, this._z = Math.atan2(-e, h))) : "YZX" === a ? (this._z = Math.asin(n(m, -1, 1)), .99999 > Math.abs(m) ? (this._x = Math.atan2(-k, h), this._y = Math.atan2(-q, d)) : (this._x = 0, this._y = Math.atan2(g, c))) : "XZY" === a ? (this._z = Math.asin(-n(e, -1, 1)), .99999 > Math.abs(e) ? (this._x = Math.atan2(f, h), this._y = 
		Math.atan2(g, d)) : (this._x = Math.atan2(-k, c), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + a);
		this._order = a;
		if (!1 !== b) {
			this.onChangeCallback();
		}
		return this;
	}, setFromQuaternion:function() {
		var d;
		return function(a, b, c) {
			void 0 === d && (d = new q);
			d.makeRotationFromQuaternion(a);
			return this.setFromRotationMatrix(d, b, c);
		};
	}(), setFromVector3:function(d, a) {
		return this.set(d.x, d.y, d.z, a || this._order);
	}, reorder:function() {
		var d = new e;
		return function(a) {
			d.setFromEuler(this);
			return this.setFromQuaternion(d, a);
		};
	}(), equals:function(d) {
		return d._x === this._x && d._y === this._y && d._z === this._z && d._order === this._order;
	}, fromArray:function(d) {
		this._x = d[0];
		this._y = d[1];
		this._z = d[2];
		void 0 !== d[3] && (this._order = d[3]);
		this.onChangeCallback();
		return this;
	}, toArray:function(d, a) {
		void 0 === d && (d = []);
		void 0 === a && (a = 0);
		d[a] = this._x;
		d[a + 1] = this._y;
		d[a + 2] = this._z;
		d[a + 3] = this._order;
		return d;
	}, toVector3:function(d) {
		return d ? d.set(this._x, this._y, this._z) : new g(this._x, this._y, this._z);
	}, onChange:function(d) {
		this.onChangeCallback = d;
		return this;
	}, onChangeCallback:function() {
	}};
	Xb.prototype = {constructor:Xb, set:function(d) {
		this.mask = 1 << d;
	}, enable:function(d) {
		this.mask |= 1 << d;
	}, toggle:function(d) {
		this.mask ^= 1 << d;
	}, disable:function(d) {
		this.mask &= ~(1 << d);
	}, test:function(d) {
		return 0 !== (this.mask & d.mask);
	}};
	var Pe = 0;
	X.DefaultUp = new g(0, 1, 0);
	X.DefaultMatrixAutoUpdate = !0;
	Object.assign(X.prototype, f.prototype, {isObject3D:!0, applyMatrix:function(d) {
		this.matrix.multiplyMatrices(d, this.matrix);
		this.matrix.decompose(this.position, this.quaternion, this.scale);
	}, setRotationFromAxisAngle:function(d, a) {
		this.quaternion.setFromAxisAngle(d, a);
	}, setRotationFromEuler:function(d) {
		this.quaternion.setFromEuler(d, !0);
	}, setRotationFromMatrix:function(d) {
		this.quaternion.setFromRotationMatrix(d);
	}, setRotationFromQuaternion:function(d) {
		this.quaternion.copy(d);
	}, rotateOnAxis:function() {
		var d = new e;
		return function(a, b) {
			d.setFromAxisAngle(a, b);
			this.quaternion.multiply(d);
			return this;
		};
	}(), rotateX:function() {
		var d = new g(1, 0, 0);
		return function(a) {
			return this.rotateOnAxis(d, a);
		};
	}(), rotateY:function() {
		var d = new g(0, 1, 0);
		return function(a) {
			return this.rotateOnAxis(d, a);
		};
	}(), rotateZ:function() {
		var d = new g(0, 0, 1);
		return function(a) {
			return this.rotateOnAxis(d, a);
		};
	}(), translateOnAxis:function() {
		var d = new g;
		return function(a, b) {
			d.copy(a).applyQuaternion(this.quaternion);
			this.position.add(d.multiplyScalar(b));
			return this;
		};
	}(), translateX:function() {
		var d = new g(1, 0, 0);
		return function(a) {
			return this.translateOnAxis(d, a);
		};
	}(), translateY:function() {
		var d = new g(0, 1, 0);
		return function(a) {
			return this.translateOnAxis(d, a);
		};
	}(), translateZ:function() {
		var d = new g(0, 0, 1);
		return function(a) {
			return this.translateOnAxis(d, a);
		};
	}(), localToWorld:function(d) {
		return d.applyMatrix4(this.matrixWorld);
	}, worldToLocal:function() {
		var d = new q;
		return function(a) {
			return a.applyMatrix4(d.getInverse(this.matrixWorld));
		};
	}(), lookAt:function() {
		var d = new q;
		return function(a) {
			d.lookAt(a, this.position, this.up);
			this.quaternion.setFromRotationMatrix(d);
		};
	}(), add:function(d) {
		if (1 < arguments.length) {
			for (var a = 0;a < arguments.length;a++) {
				this.add(arguments[a]);
			}
			return this;
		}
		if (d === this) {
			return console.error("THREE.Object3D.add: object can't be added as a child of itself.", d), this;
		}
		d && d.isObject3D ? (null !== d.parent && d.parent.remove(d), d.parent = this, d.dispatchEvent({type:"added"}), this.children.push(d)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", d);
		return this;
	}, remove:function(d) {
		if (1 < arguments.length) {
			for (var a = 0;a < arguments.length;a++) {
				this.remove(arguments[a]);
			}
		}
		a = this.children.indexOf(d);
		-1 !== a && (d.parent = null, d.dispatchEvent({type:"removed"}), this.children.splice(a, 1));
	}, getObjectById:function(d) {
		return this.getObjectByProperty("id", d);
	}, getObjectByName:function(d) {
		return this.getObjectByProperty("name", d);
	}, getObjectByProperty:function(d, a) {
		if (this[d] === a) {
			return this;
		}
		for (var b = 0, n = this.children.length;b < n;b++) {
			var c = this.children[b].getObjectByProperty(d, a);
			if (void 0 !== c) {
				return c;
			}
		}
	}, getWorldPosition:function(d) {
		d = d || new g;
		this.updateMatrixWorld(!0);
		return d.setFromMatrixPosition(this.matrixWorld);
	}, getWorldQuaternion:function() {
		var d = new g, a = new g;
		return function(b) {
			b = b || new e;
			this.updateMatrixWorld(!0);
			this.matrixWorld.decompose(d, b, a);
			return b;
		};
	}(), getWorldRotation:function() {
		var d = new e;
		return function(a) {
			a = a || new kb;
			this.getWorldQuaternion(d);
			return a.setFromQuaternion(d, this.rotation.order, !1);
		};
	}(), getWorldScale:function() {
		var d = new g, a = new e;
		return function(b) {
			b = b || new g;
			this.updateMatrixWorld(!0);
			this.matrixWorld.decompose(d, a, b);
			return b;
		};
	}(), getWorldDirection:function() {
		var d = new e;
		return function(a) {
			a = a || new g;
			this.getWorldQuaternion(d);
			return a.set(0, 0, 1).applyQuaternion(d);
		};
	}(), raycast:function() {
	}, traverse:function(d) {
		d(this);
		for (var a = this.children, b = 0, c = a.length;b < c;b++) {
			a[b].traverse(d);
		}
	}, traverseVisible:function(d) {
		if (!1 !== this.visible) {
			d(this);
			for (var a = this.children, b = 0, c = a.length;b < c;b++) {
				a[b].traverseVisible(d);
			}
		}
	}, traverseAncestors:function(d) {
		var a = this.parent;
		null !== a && (d(a), a.traverseAncestors(d));
	}, updateMatrix:function() {
		this.matrix.compose(this.position, this.quaternion, this.scale);
		this.matrixWorldNeedsUpdate = !0;
	}, updateMatrixWorld:function(d) {
		!0 === this.matrixAutoUpdate && this.updateMatrix();
		if (!0 === this.matrixWorldNeedsUpdate || !0 === d) {
			null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, d = !0;
		}
		for (var a = this.children, b = 0, c = a.length;b < c;b++) {
			a[b].updateMatrixWorld(d);
		}
	}, toJSON:function(d) {
		function a(d) {
			var a = [], b;
			for (b in d) {
				var n = d[b];
				delete n.metadata;
				a.push(n);
			}
			return a;
		}
		var b = void 0 === d || "" === d, c = {};
		b && (d = {geometries:{}, materials:{}, textures:{}, images:{}}, c.metadata = {version:4.4, type:"Object", generator:"Object3D.toJSON"});
		var e = {};
		e.uuid = this.uuid;
		e.type = this.type;
		"" !== this.name && (e.name = this.name);
		"{}" !== JSON.stringify(this.userData) && (e.userData = this.userData);
		!0 === this.castShadow && (e.castShadow = !0);
		!0 === this.receiveShadow && (e.receiveShadow = !0);
		!1 === this.visible && (e.visible = !1);
		e.matrix = this.matrix.toArray();
		void 0 !== this.geometry && (void 0 === d.geometries[this.geometry.uuid] && (d.geometries[this.geometry.uuid] = this.geometry.toJSON(d)), e.geometry = this.geometry.uuid);
		void 0 !== this.material && (void 0 === d.materials[this.material.uuid] && (d.materials[this.material.uuid] = this.material.toJSON(d)), e.material = this.material.uuid);
		if (0 < this.children.length) {
			e.children = [];
			for (var g = 0;g < this.children.length;g++) {
				e.children.push(this.children[g].toJSON(d).object);
			}
		}
		if (b) {
			var b = a(d.geometries), g = a(d.materials), m = a(d.textures);
			d = a(d.images);
			0 < b.length && (c.geometries = b);
			0 < g.length && (c.materials = g);
			0 < m.length && (c.textures = m);
			0 < d.length && (c.images = d);
		}
		c.object = e;
		return c;
	}, clone:function(d) {
		return (new this.constructor).copy(this, d);
	}, copy:function(d, a) {
		void 0 === a && (a = !0);
		this.name = d.name;
		this.up.copy(d.up);
		this.position.copy(d.position);
		this.quaternion.copy(d.quaternion);
		this.scale.copy(d.scale);
		this.matrix.copy(d.matrix);
		this.matrixWorld.copy(d.matrixWorld);
		this.matrixAutoUpdate = d.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = d.matrixWorldNeedsUpdate;
		this.visible = d.visible;
		this.castShadow = d.castShadow;
		this.receiveShadow = d.receiveShadow;
		this.frustumCulled = d.frustumCulled;
		this.renderOrder = d.renderOrder;
		this.userData = JSON.parse(JSON.stringify(d.userData));
		if (!0 === a) {
			for (a = 0;a < d.children.length;a++) {
				this.add(d.children[a].clone());
			}
		}
		return this;
	}});
	qb.prototype = {constructor:qb, set:function(d, a) {
		this.start.copy(d);
		this.end.copy(a);
		return this;
	}, clone:function() {
		return (new this.constructor).copy(this);
	}, copy:function(d) {
		this.start.copy(d.start);
		this.end.copy(d.end);
		return this;
	}, getCenter:function(d) {
		return (d || new g).addVectors(this.start, this.end).multiplyScalar(.5);
	}, delta:function(d) {
		return (d || new g).subVectors(this.end, this.start);
	}, distanceSq:function() {
		return this.start.distanceToSquared(this.end);
	}, distance:function() {
		return this.start.distanceTo(this.end);
	}, at:function(d, a) {
		a = a || new g;
		return this.delta(a).multiplyScalar(d).add(this.start);
	}, closestPointToPointParameter:function() {
		var d = new g, a = new g;
		return function(b, n) {
			d.subVectors(b, this.start);
			a.subVectors(this.end, this.start);
			b = a.dot(a);
			b = a.dot(d) / b;
			n && (b = da.clamp(b, 0, 1));
			return b;
		};
	}(), closestPointToPoint:function(d, a, b) {
		d = this.closestPointToPointParameter(d, a);
		b = b || new g;
		return this.delta(b).multiplyScalar(d).add(this.start);
	}, applyMatrix4:function(d) {
		this.start.applyMatrix4(d);
		this.end.applyMatrix4(d);
		return this;
	}, equals:function(d) {
		return d.start.equals(this.start) && d.end.equals(this.end);
	}};
	Ia.normal = function() {
		var d = new g;
		return function(a, b, c, e) {
			e = e || new g;
			e.subVectors(c, b);
			d.subVectors(a, b);
			e.cross(d);
			a = e.lengthSq();
			return 0 < a ? e.multiplyScalar(1 / Math.sqrt(a)) : e.set(0, 0, 0);
		};
	}();
	Ia.barycoordFromPoint = function() {
		var d = new g, a = new g, b = new g;
		return function(n, c, e, m, h) {
			d.subVectors(m, c);
			a.subVectors(e, c);
			b.subVectors(n, c);
			n = d.dot(d);
			c = d.dot(a);
			e = d.dot(b);
			var k = a.dot(a);
			m = a.dot(b);
			var q = n * k - c * c;
			h = h || new g;
			if (0 === q) {
				return h.set(-2, -1, -1);
			}
			q = 1 / q;
			k = (k * e - c * m) * q;
			n = (n * m - c * e) * q;
			return h.set(1 - k - n, n, k);
		};
	}();
	Ia.containsPoint = function() {
		var d = new g;
		return function(a, b, c, e) {
			a = Ia.barycoordFromPoint(a, b, c, e, d);
			return 0 <= a.x && 0 <= a.y && 1 >= a.x + a.y;
		};
	}();
	Ia.prototype = {constructor:Ia, set:function(d, a, b) {
		this.a.copy(d);
		this.b.copy(a);
		this.c.copy(b);
		return this;
	}, setFromPointsAndIndices:function(d, a, b, c) {
		this.a.copy(d[a]);
		this.b.copy(d[b]);
		this.c.copy(d[c]);
		return this;
	}, clone:function() {
		return (new this.constructor).copy(this);
	}, copy:function(d) {
		this.a.copy(d.a);
		this.b.copy(d.b);
		this.c.copy(d.c);
		return this;
	}, area:function() {
		var d = new g, a = new g;
		return function() {
			d.subVectors(this.c, this.b);
			a.subVectors(this.a, this.b);
			return .5 * d.cross(a).length();
		};
	}(), midpoint:function(d) {
		return (d || new g).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
	}, normal:function(d) {
		return Ia.normal(this.a, this.b, this.c, d);
	}, plane:function(d) {
		return (d || new wa).setFromCoplanarPoints(this.a, this.b, this.c);
	}, barycoordFromPoint:function(d, a) {
		return Ia.barycoordFromPoint(d, this.a, this.b, this.c, a);
	}, containsPoint:function(d) {
		return Ia.containsPoint(d, this.a, this.b, this.c);
	}, closestPointToPoint:function() {
		var d, a, b, c;
		return function(n, e) {
			void 0 === d && (d = new wa, a = [new qb, new qb, new qb], b = new g, c = new g);
			e = e || new g;
			var m = Infinity;
			d.setFromCoplanarPoints(this.a, this.b, this.c);
			d.projectPoint(n, b);
			if (!0 === this.containsPoint(b)) {
				e.copy(b);
			} else {
				for (a[0].set(this.a, this.b), a[1].set(this.b, this.c), a[2].set(this.c, this.a), n = 0;n < a.length;n++) {
					a[n].closestPointToPoint(b, !0, c);
					var h = b.distanceToSquared(c);
					h < m && (m = h, e.copy(c));
				}
			}
			return e;
		};
	}(), equals:function(d) {
		return d.a.equals(this.a) && d.b.equals(this.b) && d.c.equals(this.c);
	}};
	Ja.prototype = {constructor:Ja, clone:function() {
		return (new this.constructor).copy(this);
	}, copy:function(d) {
		this.a = d.a;
		this.b = d.b;
		this.c = d.c;
		this.normal.copy(d.normal);
		this.color.copy(d.color);
		this.materialIndex = d.materialIndex;
		for (var a = 0, b = d.vertexNormals.length;a < b;a++) {
			this.vertexNormals[a] = d.vertexNormals[a].clone();
		}
		a = 0;
		for (b = d.vertexColors.length;a < b;a++) {
			this.vertexColors[a] = d.vertexColors[a].clone();
		}
		return this;
	}};
	La.prototype = Object.create(Z.prototype);
	La.prototype.constructor = La;
	La.prototype.isMeshBasicMaterial = !0;
	La.prototype.copy = function(d) {
		Z.prototype.copy.call(this, d);
		this.color.copy(d.color);
		this.map = d.map;
		this.lightMap = d.lightMap;
		this.lightMapIntensity = d.lightMapIntensity;
		this.aoMap = d.aoMap;
		this.aoMapIntensity = d.aoMapIntensity;
		this.specularMap = d.specularMap;
		this.alphaMap = d.alphaMap;
		this.envMap = d.envMap;
		this.combine = d.combine;
		this.reflectivity = d.reflectivity;
		this.refractionRatio = d.refractionRatio;
		this.wireframe = d.wireframe;
		this.wireframeLinewidth = d.wireframeLinewidth;
		this.wireframeLinecap = d.wireframeLinecap;
		this.wireframeLinejoin = d.wireframeLinejoin;
		this.skinning = d.skinning;
		this.morphTargets = d.morphTargets;
		return this;
	};
	U.prototype = {constructor:U, isBufferAttribute:!0, set needsUpdate(d) {
		!0 === d && this.version++;
	}, setArray:function(d) {
		if (Array.isArray(d)) {
			throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
		}
		this.count = void 0 !== d ? d.length / this.itemSize : 0;
		this.array = d;
	}, setDynamic:function(d) {
		this.dynamic = d;
		return this;
	}, copy:function(d) {
		this.array = new d.array.constructor(d.array);
		this.itemSize = d.itemSize;
		this.count = d.count;
		this.normalized = d.normalized;
		this.dynamic = d.dynamic;
		return this;
	}, copyAt:function(d, a, b) {
		d *= this.itemSize;
		b *= a.itemSize;
		for (var n = 0, c = this.itemSize;n < c;n++) {
			this.array[d + n] = a.array[b + n];
		}
		return this;
	}, copyArray:function(d) {
		this.array.set(d);
		return this;
	}, copyColorsArray:function(d) {
		for (var a = this.array, b = 0, c = 0, e = d.length;c < e;c++) {
			var g = d[c];
			void 0 === g && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", c), g = new T);
			a[b++] = g.r;
			a[b++] = g.g;
			a[b++] = g.b;
		}
		return this;
	}, copyIndicesArray:function(d) {
		for (var a = this.array, b = 0, c = 0, e = d.length;c < e;c++) {
			var g = d[c];
			a[b++] = g.a;
			a[b++] = g.b;
			a[b++] = g.c;
		}
		return this;
	}, copyVector2sArray:function(d) {
		for (var a = this.array, b = 0, c = 0, e = d.length;c < e;c++) {
			var g = d[c];
			void 0 === g && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", c), g = new l);
			a[b++] = g.x;
			a[b++] = g.y;
		}
		return this;
	}, copyVector3sArray:function(d) {
		for (var a = this.array, b = 0, c = 0, e = d.length;c < e;c++) {
			var m = d[c];
			void 0 === m && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", c), m = new g);
			a[b++] = m.x;
			a[b++] = m.y;
			a[b++] = m.z;
		}
		return this;
	}, copyVector4sArray:function(d) {
		for (var a = this.array, b = 0, c = 0, e = d.length;c < e;c++) {
			var g = d[c];
			void 0 === g && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", c), g = new k);
			a[b++] = g.x;
			a[b++] = g.y;
			a[b++] = g.z;
			a[b++] = g.w;
		}
		return this;
	}, set:function(d, a) {
		void 0 === a && (a = 0);
		this.array.set(d, a);
		return this;
	}, getX:function(d) {
		return this.array[d * this.itemSize];
	}, setX:function(d, a) {
		this.array[d * this.itemSize] = a;
		return this;
	}, getY:function(d) {
		return this.array[d * this.itemSize + 1];
	}, setY:function(d, a) {
		this.array[d * this.itemSize + 1] = a;
		return this;
	}, getZ:function(d) {
		return this.array[d * this.itemSize + 2];
	}, setZ:function(d, a) {
		this.array[d * this.itemSize + 2] = a;
		return this;
	}, getW:function(d) {
		return this.array[d * this.itemSize + 3];
	}, setW:function(d, a) {
		this.array[d * this.itemSize + 3] = a;
		return this;
	}, setXY:function(d, a, b) {
		d *= this.itemSize;
		this.array[d + 0] = a;
		this.array[d + 1] = b;
		return this;
	}, setXYZ:function(d, a, b, c) {
		d *= this.itemSize;
		this.array[d + 0] = a;
		this.array[d + 1] = b;
		this.array[d + 2] = c;
		return this;
	}, setXYZW:function(d, a, b, c, e) {
		d *= this.itemSize;
		this.array[d + 0] = a;
		this.array[d + 1] = b;
		this.array[d + 2] = c;
		this.array[d + 3] = e;
		return this;
	}, onUpload:function(d) {
		this.onUploadCallback = d;
		return this;
	}, clone:function() {
		return (new this.constructor).copy(this);
	}};
	rb.prototype = Object.create(U.prototype);
	rb.prototype.constructor = rb;
	lb.prototype = Object.create(U.prototype);
	lb.prototype.constructor = lb;
	Za.prototype = Object.create(U.prototype);
	Za.prototype.constructor = Za;
	xb.prototype = Object.create(U.prototype);
	xb.prototype.constructor = xb;
	Ta.prototype = Object.create(U.prototype);
	Ta.prototype.constructor = Ta;
	bb.prototype = Object.create(U.prototype);
	bb.prototype.constructor = bb;
	cb.prototype = Object.create(U.prototype);
	cb.prototype.constructor = cb;
	la.prototype = Object.create(U.prototype);
	la.prototype.constructor = la;
	sb.prototype = Object.create(U.prototype);
	sb.prototype.constructor = sb;
	Object.assign(Hc.prototype, {computeGroups:function(d) {
		var a, b = [], c;
		d = d.faces;
		for (var e = 0;e < d.length;e++) {
			var g = d[e];
			g.materialIndex !== c && (c = g.materialIndex, void 0 !== a && (a.count = 3 * e - a.start, b.push(a)), a = {start:3 * e, materialIndex:c});
		}
		void 0 !== a && (a.count = 3 * e - a.start, b.push(a));
		this.groups = b;
	}, fromGeometry:function(d) {
		var a = d.faces, b = d.vertices, c = d.faceVertexUvs, e = c[0] && 0 < c[0].length, g = c[1] && 0 < c[1].length, m = d.morphTargets, h = m.length, k;
		if (0 < h) {
			k = [];
			for (var q = 0;q < h;q++) {
				k[q] = [];
			}
			this.morphTargets.position = k;
		}
		var f = d.morphNormals, p = f.length, r;
		if (0 < p) {
			r = [];
			for (q = 0;q < p;q++) {
				r[q] = [];
			}
			this.morphTargets.normal = r;
		}
		for (var u = d.skinIndices, w = d.skinWeights, t = u.length === b.length, v = w.length === b.length, q = 0;q < a.length;q++) {
			var B = a[q];
			this.vertices.push(b[B.a], b[B.b], b[B.c]);
			var y = B.vertexNormals;
			3 === y.length ? this.normals.push(y[0], y[1], y[2]) : (y = B.normal, this.normals.push(y, y, y));
			y = B.vertexColors;
			3 === y.length ? this.colors.push(y[0], y[1], y[2]) : (y = B.color, this.colors.push(y, y, y));
			!0 === e && (y = c[0][q], void 0 !== y ? this.uvs.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", q), this.uvs.push(new l, new l, new l)));
			!0 === g && (y = c[1][q], void 0 !== y ? this.uvs2.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", q), this.uvs2.push(new l, new l, new l)));
			for (y = 0;y < h;y++) {
				var A = m[y].vertices;
				k[y].push(A[B.a], A[B.b], A[B.c]);
			}
			for (y = 0;y < p;y++) {
				A = f[y].vertexNormals[q], r[y].push(A.a, A.b, A.c);
			}
			t && this.skinIndices.push(u[B.a], u[B.b], u[B.c]);
			v && this.skinWeights.push(w[B.a], w[B.b], w[B.c]);
		}
		this.computeGroups(d);
		this.verticesNeedUpdate = d.verticesNeedUpdate;
		this.normalsNeedUpdate = d.normalsNeedUpdate;
		this.colorsNeedUpdate = d.colorsNeedUpdate;
		this.uvsNeedUpdate = d.uvsNeedUpdate;
		this.groupsNeedUpdate = d.groupsNeedUpdate;
		return this;
	}});
	Object.assign(ja.prototype, f.prototype, {isGeometry:!0, applyMatrix:function(d) {
		for (var a = (new ya).getNormalMatrix(d), b = 0, c = this.vertices.length;b < c;b++) {
			this.vertices[b].applyMatrix4(d);
		}
		b = 0;
		for (c = this.faces.length;b < c;b++) {
			d = this.faces[b];
			d.normal.applyMatrix3(a).normalize();
			for (var e = 0, g = d.vertexNormals.length;e < g;e++) {
				d.vertexNormals[e].applyMatrix3(a).normalize();
			}
		}
		null !== this.boundingBox && this.computeBoundingBox();
		null !== this.boundingSphere && this.computeBoundingSphere();
		this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
		return this;
	}, rotateX:function() {
		var d;
		return function(a) {
			void 0 === d && (d = new q);
			d.makeRotationX(a);
			this.applyMatrix(d);
			return this;
		};
	}(), rotateY:function() {
		var d;
		return function(a) {
			void 0 === d && (d = new q);
			d.makeRotationY(a);
			this.applyMatrix(d);
			return this;
		};
	}(), rotateZ:function() {
		var d;
		return function(a) {
			void 0 === d && (d = new q);
			d.makeRotationZ(a);
			this.applyMatrix(d);
			return this;
		};
	}(), translate:function() {
		var d;
		return function(a, b, c) {
			void 0 === d && (d = new q);
			d.makeTranslation(a, b, c);
			this.applyMatrix(d);
			return this;
		};
	}(), scale:function() {
		var d;
		return function(a, b, c) {
			void 0 === d && (d = new q);
			d.makeScale(a, b, c);
			this.applyMatrix(d);
			return this;
		};
	}(), lookAt:function() {
		var d;
		return function(a) {
			void 0 === d && (d = new X);
			d.lookAt(a);
			d.updateMatrix();
			this.applyMatrix(d.matrix);
		};
	}(), fromBufferGeometry:function(d) {
		function a(d, a, n, c) {
			var e = void 0 !== h ? [p[d].clone(), p[a].clone(), p[n].clone()] : [], g = void 0 !== k ? [b.colors[d].clone(), b.colors[a].clone(), b.colors[n].clone()] : [];
			c = new Ja(d, a, n, e, g, c);
			b.faces.push(c);
			void 0 !== q && b.faceVertexUvs[0].push([r[d].clone(), r[a].clone(), r[n].clone()]);
			void 0 !== f && b.faceVertexUvs[1].push([u[d].clone(), u[a].clone(), u[n].clone()]);
		}
		var b = this, c = null !== d.index ? d.index.array : void 0, e = d.attributes, m = e.position.array, h = void 0 !== e.normal ? e.normal.array : void 0, k = void 0 !== e.color ? e.color.array : void 0, q = void 0 !== e.uv ? e.uv.array : void 0, f = void 0 !== e.uv2 ? e.uv2.array : void 0;
		void 0 !== f && (this.faceVertexUvs[1] = []);
		for (var p = [], r = [], u = [], w = e = 0;e < m.length;e += 3, w += 2) {
			b.vertices.push(new g(m[e], m[e + 1], m[e + 2])), void 0 !== h && p.push(new g(h[e], h[e + 1], h[e + 2])), void 0 !== k && b.colors.push(new T(k[e], k[e + 1], k[e + 2])), void 0 !== q && r.push(new l(q[w], q[w + 1])), void 0 !== f && u.push(new l(f[w], f[w + 1]));
		}
		if (void 0 !== c) {
			if (m = d.groups, 0 < m.length) {
				for (e = 0;e < m.length;e++) {
					for (var t = m[e], v = t.start, B = t.count, w = v, v = v + B;w < v;w += 3) {
						a(c[w], c[w + 1], c[w + 2], t.materialIndex);
					}
				}
			} else {
				for (e = 0;e < c.length;e += 3) {
					a(c[e], c[e + 1], c[e + 2]);
				}
			}
		} else {
			for (e = 0;e < m.length / 3;e += 3) {
				a(e, e + 1, e + 2);
			}
		}
		this.computeFaceNormals();
		null !== d.boundingBox && (this.boundingBox = d.boundingBox.clone());
		null !== d.boundingSphere && (this.boundingSphere = d.boundingSphere.clone());
		return this;
	}, center:function() {
		this.computeBoundingBox();
		var d = this.boundingBox.getCenter().negate();
		this.translate(d.x, d.y, d.z);
		return d;
	}, normalize:function() {
		this.computeBoundingSphere();
		var d = this.boundingSphere.center, a = this.boundingSphere.radius, a = 0 === a ? 1 : 1 / a, b = new q;
		b.set(a, 0, 0, -a * d.x, 0, a, 0, -a * d.y, 0, 0, a, -a * d.z, 0, 0, 0, 1);
		this.applyMatrix(b);
		return this;
	}, computeFaceNormals:function() {
		for (var d = new g, a = new g, b = 0, c = this.faces.length;b < c;b++) {
			var e = this.faces[b], m = this.vertices[e.a], h = this.vertices[e.b];
			d.subVectors(this.vertices[e.c], h);
			a.subVectors(m, h);
			d.cross(a);
			d.normalize();
			e.normal.copy(d);
		}
	}, computeVertexNormals:function(d) {
		void 0 === d && (d = !0);
		var a, b, c;
		c = Array(this.vertices.length);
		a = 0;
		for (b = this.vertices.length;a < b;a++) {
			c[a] = new g;
		}
		if (d) {
			var e, m, h, k = new g, q = new g;
			d = 0;
			for (a = this.faces.length;d < a;d++) {
				b = this.faces[d], e = this.vertices[b.a], m = this.vertices[b.b], h = this.vertices[b.c], k.subVectors(h, m), q.subVectors(e, m), k.cross(q), c[b.a].add(k), c[b.b].add(k), c[b.c].add(k);
			}
		} else {
			for (this.computeFaceNormals(), d = 0, a = this.faces.length;d < a;d++) {
				b = this.faces[d], c[b.a].add(b.normal), c[b.b].add(b.normal), c[b.c].add(b.normal);
			}
		}
		a = 0;
		for (b = this.vertices.length;a < b;a++) {
			c[a].normalize();
		}
		d = 0;
		for (a = this.faces.length;d < a;d++) {
			b = this.faces[d], e = b.vertexNormals, 3 === e.length ? (e[0].copy(c[b.a]), e[1].copy(c[b.b]), e[2].copy(c[b.c])) : (e[0] = c[b.a].clone(), e[1] = c[b.b].clone(), e[2] = c[b.c].clone());
		}
		0 < this.faces.length && (this.normalsNeedUpdate = !0);
	}, computeFlatVertexNormals:function() {
		var d, a, b;
		this.computeFaceNormals();
		d = 0;
		for (a = this.faces.length;d < a;d++) {
			b = this.faces[d];
			var c = b.vertexNormals;
			3 === c.length ? (c[0].copy(b.normal), c[1].copy(b.normal), c[2].copy(b.normal)) : (c[0] = b.normal.clone(), c[1] = b.normal.clone(), c[2] = b.normal.clone());
		}
		0 < this.faces.length && (this.normalsNeedUpdate = !0);
	}, computeMorphNormals:function() {
		var d, a, b, c, e;
		b = 0;
		for (c = this.faces.length;b < c;b++) {
			for (e = this.faces[b], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), d = 0, a = e.vertexNormals.length;d < a;d++) {
				e.__originalVertexNormals[d] ? e.__originalVertexNormals[d].copy(e.vertexNormals[d]) : e.__originalVertexNormals[d] = e.vertexNormals[d].clone();
			}
		}
		var m = new ja;
		m.faces = this.faces;
		d = 0;
		for (a = this.morphTargets.length;d < a;d++) {
			if (!this.morphNormals[d]) {
				this.morphNormals[d] = {};
				this.morphNormals[d].faceNormals = [];
				this.morphNormals[d].vertexNormals = [];
				e = this.morphNormals[d].faceNormals;
				var h = this.morphNormals[d].vertexNormals, k, q;
				b = 0;
				for (c = this.faces.length;b < c;b++) {
					k = new g, q = {a:new g, b:new g, c:new g}, e.push(k), h.push(q);
				}
			}
			h = this.morphNormals[d];
			m.vertices = this.morphTargets[d].vertices;
			m.computeFaceNormals();
			m.computeVertexNormals();
			b = 0;
			for (c = this.faces.length;b < c;b++) {
				e = this.faces[b], k = h.faceNormals[b], q = h.vertexNormals[b], k.copy(e.normal), q.a.copy(e.vertexNormals[0]), q.b.copy(e.vertexNormals[1]), q.c.copy(e.vertexNormals[2]);
			}
		}
		b = 0;
		for (c = this.faces.length;b < c;b++) {
			e = this.faces[b], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals;
		}
	}, computeLineDistances:function() {
		for (var d = 0, a = this.vertices, b = 0, c = a.length;b < c;b++) {
			0 < b && (d += a[b].distanceTo(a[b - 1])), this.lineDistances[b] = d;
		}
	}, computeBoundingBox:function() {
		null === this.boundingBox && (this.boundingBox = new Ba);
		this.boundingBox.setFromPoints(this.vertices);
	}, computeBoundingSphere:function() {
		null === this.boundingSphere && (this.boundingSphere = new Ca);
		this.boundingSphere.setFromPoints(this.vertices);
	}, merge:function(d, a, b) {
		if (!1 === (d && d.isGeometry)) {
			console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", d);
		} else {
			var n, c = this.vertices.length, e = this.vertices, g = d.vertices, m = this.faces, h = d.faces, k = this.faceVertexUvs[0], q = d.faceVertexUvs[0], f = this.colors, p = d.colors;
			void 0 === b && (b = 0);
			void 0 !== a && (n = (new ya).getNormalMatrix(a));
			d = 0;
			for (var r = g.length;d < r;d++) {
				var u = g[d].clone();
				void 0 !== a && u.applyMatrix4(a);
				e.push(u);
			}
			d = 0;
			for (r = p.length;d < r;d++) {
				f.push(p[d].clone());
			}
			d = 0;
			for (r = h.length;d < r;d++) {
				var g = h[d], l = g.vertexNormals, p = g.vertexColors, f = new Ja(g.a + c, g.b + c, g.c + c);
				f.normal.copy(g.normal);
				void 0 !== n && f.normal.applyMatrix3(n).normalize();
				a = 0;
				for (e = l.length;a < e;a++) {
					u = l[a].clone(), void 0 !== n && u.applyMatrix3(n).normalize(), f.vertexNormals.push(u);
				}
				f.color.copy(g.color);
				a = 0;
				for (e = p.length;a < e;a++) {
					u = p[a], f.vertexColors.push(u.clone());
				}
				f.materialIndex = g.materialIndex + b;
				m.push(f);
			}
			d = 0;
			for (r = q.length;d < r;d++) {
				if (b = q[d], n = [], void 0 !== b) {
					a = 0;
					for (e = b.length;a < e;a++) {
						n.push(b[a].clone());
					}
					k.push(n);
				}
			}
		}
	}, mergeMesh:function(d) {
		!1 === (d && d.isMesh) ? console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", d) : (d.matrixAutoUpdate && d.updateMatrix(), this.merge(d.geometry, d.matrix));
	}, mergeVertices:function() {
		var d = {}, a = [], b = [], c, e = Math.pow(10, 4), g, m;
		g = 0;
		for (m = this.vertices.length;g < m;g++) {
			c = this.vertices[g], c = Math.round(c.x * e) + "_" + Math.round(c.y * e) + "_" + Math.round(c.z * e), void 0 === d[c] ? (d[c] = g, a.push(this.vertices[g]), b[g] = a.length - 1) : b[g] = b[d[c]];
		}
		d = [];
		g = 0;
		for (m = this.faces.length;g < m;g++) {
			for (e = this.faces[g], e.a = b[e.a], e.b = b[e.b], e.c = b[e.c], e = [e.a, e.b, e.c], c = 0;3 > c;c++) {
				if (e[c] === e[(c + 1) % 3]) {
					d.push(g);
					break;
				}
			}
		}
		for (g = d.length - 1;0 <= g;g--) {
			for (e = d[g], this.faces.splice(e, 1), b = 0, m = this.faceVertexUvs.length;b < m;b++) {
				this.faceVertexUvs[b].splice(e, 1);
			}
		}
		g = this.vertices.length - a.length;
		this.vertices = a;
		return g;
	}, sortFacesByMaterialIndex:function() {
		for (var d = this.faces, a = d.length, b = 0;b < a;b++) {
			d[b]._id = b;
		}
		d.sort(function(d, a) {
			return d.materialIndex - a.materialIndex;
		});
		var c = this.faceVertexUvs[0], e = this.faceVertexUvs[1], g, m;
		c && c.length === a && (g = []);
		e && e.length === a && (m = []);
		for (b = 0;b < a;b++) {
			var h = d[b]._id;
			g && g.push(c[h]);
			m && m.push(e[h]);
		}
		g && (this.faceVertexUvs[0] = g);
		m && (this.faceVertexUvs[1] = m);
	}, toJSON:function() {
		function d(d, a, b) {
			return b ? d | 1 << a : d & ~(1 << a);
		}
		function a(d) {
			var a = d.x.toString() + d.y.toString() + d.z.toString();
			if (void 0 !== q[a]) {
				return q[a];
			}
			q[a] = k.length / 3;
			k.push(d.x, d.y, d.z);
			return q[a];
		}
		function b(d) {
			var a = d.r.toString() + d.g.toString() + d.b.toString();
			if (void 0 !== p[a]) {
				return p[a];
			}
			p[a] = f.length;
			f.push(d.getHex());
			return p[a];
		}
		function c(d) {
			var a = d.x.toString() + d.y.toString();
			if (void 0 !== u[a]) {
				return u[a];
			}
			u[a] = r.length / 2;
			r.push(d.x, d.y);
			return u[a];
		}
		var e = {metadata:{version:4.4, type:"Geometry", generator:"Geometry.toJSON"}};
		e.uuid = this.uuid;
		e.type = this.type;
		"" !== this.name && (e.name = this.name);
		if (void 0 !== this.parameters) {
			var g = this.parameters, m;
			for (m in g) {
				void 0 !== g[m] && (e[m] = g[m]);
			}
			return e;
		}
		g = [];
		for (m = 0;m < this.vertices.length;m++) {
			var h = this.vertices[m];
			g.push(h.x, h.y, h.z);
		}
		var h = [], k = [], q = {}, f = [], p = {}, r = [], u = {};
		for (m = 0;m < this.faces.length;m++) {
			var l = this.faces[m], w = void 0 !== this.faceVertexUvs[0][m], t = 0 < l.normal.length(), v = 0 < l.vertexNormals.length, B = 1 !== l.color.r || 1 !== l.color.g || 1 !== l.color.b, y = 0 < l.vertexColors.length, A = 0, A = d(A, 0, 0), A = d(A, 1, !0), A = d(A, 2, !1), A = d(A, 3, w), A = d(A, 4, t), A = d(A, 5, v), A = d(A, 6, B), A = d(A, 7, y);
			h.push(A);
			h.push(l.a, l.b, l.c);
			h.push(l.materialIndex);
			w && (w = this.faceVertexUvs[0][m], h.push(c(w[0]), c(w[1]), c(w[2])));
			t && h.push(a(l.normal));
			v && (t = l.vertexNormals, h.push(a(t[0]), a(t[1]), a(t[2])));
			B && h.push(b(l.color));
			y && (l = l.vertexColors, h.push(b(l[0]), b(l[1]), b(l[2])));
		}
		e.data = {};
		e.data.vertices = g;
		e.data.normals = k;
		0 < f.length && (e.data.colors = f);
		0 < r.length && (e.data.uvs = [r]);
		e.data.faces = h;
		return e;
	}, clone:function() {
		return (new ja).copy(this);
	}, copy:function(d) {
		this.vertices = [];
		this.faces = [];
		this.faceVertexUvs = [[]];
		this.colors = [];
		for (var a = d.vertices, b = 0, c = a.length;b < c;b++) {
			this.vertices.push(a[b].clone());
		}
		a = d.colors;
		b = 0;
		for (c = a.length;b < c;b++) {
			this.colors.push(a[b].clone());
		}
		a = d.faces;
		b = 0;
		for (c = a.length;b < c;b++) {
			this.faces.push(a[b].clone());
		}
		b = 0;
		for (c = d.faceVertexUvs.length;b < c;b++) {
			a = d.faceVertexUvs[b];
			void 0 === this.faceVertexUvs[b] && (this.faceVertexUvs[b] = []);
			for (var e = 0, g = a.length;e < g;e++) {
				for (var m = a[e], h = [], k = 0, q = m.length;k < q;k++) {
					h.push(m[k].clone());
				}
				this.faceVertexUvs[b].push(h);
			}
		}
		return this;
	}, dispose:function() {
		this.dispatchEvent({type:"dispose"});
	}});
	var Wd = 0;
	Object.assign(ca.prototype, f.prototype, {isBufferGeometry:!0, getIndex:function() {
		return this.index;
	}, setIndex:function(d) {
		this.index = d;
	}, addAttribute:function(d, a, b) {
		if (!1 === (a && a.isBufferAttribute) && !1 === (a && a.isInterleavedBufferAttribute)) {
			console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(d, new U(a, b));
		} else {
			if ("index" === d) {
				console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(a);
			} else {
				return this.attributes[d] = a, this;
			}
		}
	}, getAttribute:function(d) {
		return this.attributes[d];
	}, removeAttribute:function(d) {
		delete this.attributes[d];
		return this;
	}, addGroup:function(d, a, b) {
		this.groups.push({start:d, count:a, materialIndex:void 0 !== b ? b : 0});
	}, clearGroups:function() {
		this.groups = [];
	}, setDrawRange:function(d, a) {
		this.drawRange.start = d;
		this.drawRange.count = a;
	}, applyMatrix:function(d) {
		var a = this.attributes.position;
		void 0 !== a && (d.applyToVector3Array(a.array), a.needsUpdate = !0);
		a = this.attributes.normal;
		void 0 !== a && ((new ya).getNormalMatrix(d).applyToVector3Array(a.array), a.needsUpdate = !0);
		null !== this.boundingBox && this.computeBoundingBox();
		null !== this.boundingSphere && this.computeBoundingSphere();
		return this;
	}, rotateX:function() {
		var d;
		return function(a) {
			void 0 === d && (d = new q);
			d.makeRotationX(a);
			this.applyMatrix(d);
			return this;
		};
	}(), rotateY:function() {
		var d;
		return function(a) {
			void 0 === d && (d = new q);
			d.makeRotationY(a);
			this.applyMatrix(d);
			return this;
		};
	}(), rotateZ:function() {
		var d;
		return function(a) {
			void 0 === d && (d = new q);
			d.makeRotationZ(a);
			this.applyMatrix(d);
			return this;
		};
	}(), translate:function() {
		var d;
		return function(a, b, c) {
			void 0 === d && (d = new q);
			d.makeTranslation(a, b, c);
			this.applyMatrix(d);
			return this;
		};
	}(), scale:function() {
		var d;
		return function(a, b, c) {
			void 0 === d && (d = new q);
			d.makeScale(a, b, c);
			this.applyMatrix(d);
			return this;
		};
	}(), lookAt:function() {
		var d;
		return function(a) {
			void 0 === d && (d = new X);
			d.lookAt(a);
			d.updateMatrix();
			this.applyMatrix(d.matrix);
		};
	}(), center:function() {
		this.computeBoundingBox();
		var d = this.boundingBox.getCenter().negate();
		this.translate(d.x, d.y, d.z);
		return d;
	}, setFromObject:function(d) {
		var a = d.geometry;
		if (d.isPoints || d.isLine) {
			d = new la(3 * a.vertices.length, 3);
			var b = new la(3 * a.colors.length, 3);
			this.addAttribute("position", d.copyVector3sArray(a.vertices));
			this.addAttribute("color", b.copyColorsArray(a.colors));
			a.lineDistances && a.lineDistances.length === a.vertices.length && (d = new la(a.lineDistances.length, 1), this.addAttribute("lineDistance", d.copyArray(a.lineDistances)));
			null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
			null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
		} else {
			d.isMesh && a && a.isGeometry && this.fromGeometry(a);
		}
		return this;
	}, updateFromObject:function(d) {
		var a = d.geometry;
		if (d.isMesh) {
			var b = a.__directGeometry;
			!0 === a.elementsNeedUpdate && (b = void 0, a.elementsNeedUpdate = !1);
			if (void 0 === b) {
				return this.fromGeometry(a);
			}
			b.verticesNeedUpdate = a.verticesNeedUpdate;
			b.normalsNeedUpdate = a.normalsNeedUpdate;
			b.colorsNeedUpdate = a.colorsNeedUpdate;
			b.uvsNeedUpdate = a.uvsNeedUpdate;
			b.groupsNeedUpdate = a.groupsNeedUpdate;
			a.verticesNeedUpdate = !1;
			a.normalsNeedUpdate = !1;
			a.colorsNeedUpdate = !1;
			a.uvsNeedUpdate = !1;
			a.groupsNeedUpdate = !1;
			a = b;
		}
		!0 === a.verticesNeedUpdate && (b = this.attributes.position, void 0 !== b && (b.copyVector3sArray(a.vertices), b.needsUpdate = !0), a.verticesNeedUpdate = !1);
		!0 === a.normalsNeedUpdate && (b = this.attributes.normal, void 0 !== b && (b.copyVector3sArray(a.normals), b.needsUpdate = !0), a.normalsNeedUpdate = !1);
		!0 === a.colorsNeedUpdate && (b = this.attributes.color, void 0 !== b && (b.copyColorsArray(a.colors), b.needsUpdate = !0), a.colorsNeedUpdate = !1);
		a.uvsNeedUpdate && (b = this.attributes.uv, void 0 !== b && (b.copyVector2sArray(a.uvs), b.needsUpdate = !0), a.uvsNeedUpdate = !1);
		a.lineDistancesNeedUpdate && (b = this.attributes.lineDistance, void 0 !== b && (b.copyArray(a.lineDistances), b.needsUpdate = !0), a.lineDistancesNeedUpdate = !1);
		a.groupsNeedUpdate && (a.computeGroups(d.geometry), this.groups = a.groups, a.groupsNeedUpdate = !1);
		return this;
	}, fromGeometry:function(d) {
		d.__directGeometry = (new Hc).fromGeometry(d);
		return this.fromDirectGeometry(d.__directGeometry);
	}, fromDirectGeometry:function(d) {
		var a = new Float32Array(3 * d.vertices.length);
		this.addAttribute("position", (new U(a, 3)).copyVector3sArray(d.vertices));
		0 < d.normals.length && (a = new Float32Array(3 * d.normals.length), this.addAttribute("normal", (new U(a, 3)).copyVector3sArray(d.normals)));
		0 < d.colors.length && (a = new Float32Array(3 * d.colors.length), this.addAttribute("color", (new U(a, 3)).copyColorsArray(d.colors)));
		0 < d.uvs.length && (a = new Float32Array(2 * d.uvs.length), this.addAttribute("uv", (new U(a, 2)).copyVector2sArray(d.uvs)));
		0 < d.uvs2.length && (a = new Float32Array(2 * d.uvs2.length), this.addAttribute("uv2", (new U(a, 2)).copyVector2sArray(d.uvs2)));
		0 < d.indices.length && (a = new (65535 < d.vertices.length ? Uint32Array : Uint16Array)(3 * d.indices.length), this.setIndex((new U(a, 1)).copyIndicesArray(d.indices)));
		this.groups = d.groups;
		for (var b in d.morphTargets) {
			for (var a = [], c = d.morphTargets[b], e = 0, g = c.length;e < g;e++) {
				var m = c[e], h = new la(3 * m.length, 3);
				a.push(h.copyVector3sArray(m));
			}
			this.morphAttributes[b] = a;
		}
		0 < d.skinIndices.length && (b = new la(4 * d.skinIndices.length, 4), this.addAttribute("skinIndex", b.copyVector4sArray(d.skinIndices)));
		0 < d.skinWeights.length && (b = new la(4 * d.skinWeights.length, 4), this.addAttribute("skinWeight", b.copyVector4sArray(d.skinWeights)));
		null !== d.boundingSphere && (this.boundingSphere = d.boundingSphere.clone());
		null !== d.boundingBox && (this.boundingBox = d.boundingBox.clone());
		return this;
	}, computeBoundingBox:function() {
		null === this.boundingBox && (this.boundingBox = new Ba);
		var d = this.attributes.position.array;
		void 0 !== d ? this.boundingBox.setFromArray(d) : this.boundingBox.makeEmpty();
		(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
	}, computeBoundingSphere:function() {
		var d = new Ba, a = new g;
		return function() {
			null === this.boundingSphere && (this.boundingSphere = new Ca);
			var b = this.attributes.position;
			if (b) {
				var b = b.array, c = this.boundingSphere.center;
				d.setFromArray(b);
				d.getCenter(c);
				for (var n = 0, e = 0, g = b.length;e < g;e += 3) {
					a.fromArray(b, e), n = Math.max(n, c.distanceToSquared(a));
				}
				this.boundingSphere.radius = Math.sqrt(n);
				isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
			}
		};
	}(), computeFaceNormals:function() {
	}, computeVertexNormals:function() {
		var d = this.index, a = this.attributes, b = this.groups;
		if (a.position) {
			var c = a.position.array;
			if (void 0 === a.normal) {
				this.addAttribute("normal", new U(new Float32Array(c.length), 3));
			} else {
				for (var e = a.normal.array, m = 0, h = e.length;m < h;m++) {
					e[m] = 0;
				}
			}
			var e = a.normal.array, k, q, f, p = new g, r = new g, u = new g, l = new g, w = new g;
			if (d) {
				d = d.array;
				0 === b.length && this.addGroup(0, d.length);
				for (var t = 0, v = b.length;t < v;++t) {
					for (m = b[t], h = m.start, k = m.count, m = h, h += k;m < h;m += 3) {
						k = 3 * d[m + 0], q = 3 * d[m + 1], f = 3 * d[m + 2], p.fromArray(c, k), r.fromArray(c, q), u.fromArray(c, f), l.subVectors(u, r), w.subVectors(p, r), l.cross(w), e[k] += l.x, e[k + 1] += l.y, e[k + 2] += l.z, e[q] += l.x, e[q + 1] += l.y, e[q + 2] += l.z, e[f] += l.x, e[f + 1] += l.y, e[f + 2] += l.z;
					}
				}
			} else {
				for (m = 0, h = c.length;m < h;m += 9) {
					p.fromArray(c, m), r.fromArray(c, m + 3), u.fromArray(c, m + 6), l.subVectors(u, r), w.subVectors(p, r), l.cross(w), e[m] = l.x, e[m + 1] = l.y, e[m + 2] = l.z, e[m + 3] = l.x, e[m + 4] = l.y, e[m + 5] = l.z, e[m + 6] = l.x, e[m + 7] = l.y, e[m + 8] = l.z;
				}
			}
			this.normalizeNormals();
			a.normal.needsUpdate = !0;
		}
	}, merge:function(d, a) {
		if (!1 === (d && d.isBufferGeometry)) {
			console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", d);
		} else {
			void 0 === a && (a = 0);
			var b = this.attributes, c;
			for (c in b) {
				if (void 0 !== d.attributes[c]) {
					for (var n = b[c].array, e = d.attributes[c], g = e.array, m = 0, e = e.itemSize * a;m < g.length;m++, e++) {
						n[e] = g[m];
					}
				}
			}
			return this;
		}
	}, normalizeNormals:function() {
		for (var d = this.attributes.normal.array, a, b, c, e = 0, g = d.length;e < g;e += 3) {
			a = d[e], b = d[e + 1], c = d[e + 2], a = 1 / Math.sqrt(a * a + b * b + c * c), d[e] *= a, d[e + 1] *= a, d[e + 2] *= a;
		}
	}, toNonIndexed:function() {
		if (null === this.index) {
			return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
		}
		var d = new ca, a = this.index.array, b = this.attributes, c;
		for (c in b) {
			for (var e = b[c], g = e.array, e = e.itemSize, m = new g.constructor(a.length * e), h, k = 0, q = 0, f = a.length;q < f;q++) {
				h = a[q] * e;
				for (var p = 0;p < e;p++) {
					m[k++] = g[h++];
				}
			}
			d.addAttribute(c, new U(m, e));
		}
		return d;
	}, toJSON:function() {
		var d = {metadata:{version:4.4, type:"BufferGeometry", generator:"BufferGeometry.toJSON"}};
		d.uuid = this.uuid;
		d.type = this.type;
		"" !== this.name && (d.name = this.name);
		if (void 0 !== this.parameters) {
			var a = this.parameters, b;
			for (b in a) {
				void 0 !== a[b] && (d[b] = a[b]);
			}
			return d;
		}
		d.data = {attributes:{}};
		var c = this.index;
		null !== c && (a = Array.prototype.slice.call(c.array), d.data.index = {type:c.array.constructor.name, array:a});
		c = this.attributes;
		for (b in c) {
			var e = c[b], a = Array.prototype.slice.call(e.array);
			d.data.attributes[b] = {itemSize:e.itemSize, type:e.array.constructor.name, array:a, normalized:e.normalized};
		}
		b = this.groups;
		0 < b.length && (d.data.groups = JSON.parse(JSON.stringify(b)));
		b = this.boundingSphere;
		null !== b && (d.data.boundingSphere = {center:b.center.toArray(), radius:b.radius});
		return d;
	}, clone:function() {
		return (new ca).copy(this);
	}, copy:function(d) {
		var a = d.index;
		null !== a && this.setIndex(a.clone());
		var a = d.attributes, b;
		for (b in a) {
			this.addAttribute(b, a[b].clone());
		}
		d = d.groups;
		b = 0;
		for (a = d.length;b < a;b++) {
			var c = d[b];
			this.addGroup(c.start, c.count, c.materialIndex);
		}
		return this;
	}, dispose:function() {
		this.dispatchEvent({type:"dispose"});
	}});
	ca.MaxIndex = 65535;
	Da.prototype = Object.assign(Object.create(X.prototype), {constructor:Da, isMesh:!0, setDrawMode:function(d) {
		this.drawMode = d;
	}, copy:function(d) {
		X.prototype.copy.call(this, d);
		this.drawMode = d.drawMode;
		return this;
	}, updateMorphTargets:function() {
		var d = this.geometry.morphTargets;
		if (void 0 !== d && 0 < d.length) {
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};
			for (var a = 0, b = d.length;a < b;a++) {
				this.morphTargetInfluences.push(0), this.morphTargetDictionary[d[a].name] = a;
			}
		}
	}, raycast:function() {
		function d(d, a, b, c, n, e, g) {
			Ia.barycoordFromPoint(d, a, b, c, B);
			n.multiplyScalar(B.x);
			e.multiplyScalar(B.y);
			g.multiplyScalar(B.z);
			n.add(e).add(g);
			return n.clone();
		}
		function a(d, a, b, c, n, e, g) {
			var m = d.material;
			if (null === (1 === m.side ? b.intersectTriangle(e, n, c, !0, g) : b.intersectTriangle(c, n, e, 2 !== m.side, g))) {
				return null;
			}
			A.copy(g);
			A.applyMatrix4(d.matrixWorld);
			b = a.ray.origin.distanceTo(A);
			return b < a.near || b > a.far ? null : {distance:b, point:A.clone(), object:d};
		}
		function b(b, c, n, e, g, m, q, p) {
			h.fromArray(e, 3 * m);
			k.fromArray(e, 3 * q);
			f.fromArray(e, 3 * p);
			if (b = a(b, c, n, h, k, f, y)) {
				g && (w.fromArray(g, 2 * m), t.fromArray(g, 2 * q), v.fromArray(g, 2 * p), b.uv = d(y, h, k, f, w, t, v)), b.face = new Ja(m, q, p, Ia.normal(h, k, f)), b.faceIndex = m;
			}
			return b;
		}
		var c = new q, e = new jb, m = new Ca, h = new g, k = new g, f = new g, p = new g, r = new g, u = new g, w = new l, t = new l, v = new l, B = new g, y = new g, A = new g;
		return function(n, g) {
			var q = this.geometry, l = this.material, z = this.matrixWorld;
			if (void 0 !== l && (null === q.boundingSphere && q.computeBoundingSphere(), m.copy(q.boundingSphere), m.applyMatrix4(z), !1 !== n.ray.intersectsSphere(m) && (c.getInverse(z), e.copy(n.ray).applyMatrix4(c), null === q.boundingBox || !1 !== e.intersectsBox(q.boundingBox)))) {
				var E, B;
				if (q.isBufferGeometry) {
					var A, x, l = q.index, z = q.attributes, q = z.position.array;
					void 0 !== z.uv && (E = z.uv.array);
					if (null !== l) {
						for (var z = l.array, C = 0, P = z.length;C < P;C += 3) {
							if (l = z[C], A = z[C + 1], x = z[C + 2], B = b(this, n, e, q, E, l, A, x)) {
								B.faceIndex = Math.floor(C / 3), g.push(B);
							}
						}
					} else {
						for (C = 0, P = q.length;C < P;C += 9) {
							if (l = C / 3, A = l + 1, x = l + 2, B = b(this, n, e, q, E, l, A, x)) {
								B.index = l, g.push(B);
							}
						}
					}
				} else {
					if (q.isGeometry) {
						var G, F, z = l && l.isMultiMaterial, C = !0 === z ? l.materials : null, P = q.vertices;
						A = q.faces;
						x = q.faceVertexUvs[0];
						0 < x.length && (E = x);
						for (var aa = 0, L = A.length;aa < L;aa++) {
							var D = A[aa];
							B = !0 === z ? C[D.materialIndex] : l;
							if (void 0 !== B) {
								x = P[D.a];
								G = P[D.b];
								F = P[D.c];
								if (!0 === B.morphTargets) {
									B = q.morphTargets;
									var fa = this.morphTargetInfluences;
									h.set(0, 0, 0);
									k.set(0, 0, 0);
									f.set(0, 0, 0);
									for (var W = 0, O = B.length;W < O;W++) {
										var J = fa[W];
										if (0 !== J) {
											var I = B[W].vertices;
											h.addScaledVector(p.subVectors(I[D.a], x), J);
											k.addScaledVector(r.subVectors(I[D.b], G), J);
											f.addScaledVector(u.subVectors(I[D.c], F), J);
										}
									}
									h.add(x);
									k.add(G);
									f.add(F);
									x = h;
									G = k;
									F = f;
								}
								if (B = a(this, n, e, x, G, F, y)) {
									E && (fa = E[aa], w.copy(fa[0]), t.copy(fa[1]), v.copy(fa[2]), B.uv = d(y, x, G, F, w, t, v)), B.face = D, B.faceIndex = aa, g.push(B);
								}
							}
						}
					}
				}
			}
		};
	}(), clone:function() {
		return (new this.constructor(this.geometry, this.material)).copy(this);
	}});
	mb.prototype = Object.create(ca.prototype);
	mb.prototype.constructor = mb;
	Ra.prototype = Object.create(ca.prototype);
	Ra.prototype.constructor = Ra;
	xa.prototype = Object.create(X.prototype);
	xa.prototype.constructor = xa;
	xa.prototype.isCamera = !0;
	xa.prototype.getWorldDirection = function() {
		var d = new e;
		return function(a) {
			a = a || new g;
			this.getWorldQuaternion(d);
			return a.set(0, 0, -1).applyQuaternion(d);
		};
	}();
	xa.prototype.lookAt = function() {
		var d = new q;
		return function(a) {
			d.lookAt(this.position, a, this.up);
			this.quaternion.setFromRotationMatrix(d);
		};
	}();
	xa.prototype.clone = function() {
		return (new this.constructor).copy(this);
	};
	xa.prototype.copy = function(d) {
		X.prototype.copy.call(this, d);
		this.matrixWorldInverse.copy(d.matrixWorldInverse);
		this.projectionMatrix.copy(d.projectionMatrix);
		return this;
	};
	Oa.prototype = Object.assign(Object.create(xa.prototype), {constructor:Oa, isPerspectiveCamera:!0, copy:function(d) {
		xa.prototype.copy.call(this, d);
		this.fov = d.fov;
		this.zoom = d.zoom;
		this.near = d.near;
		this.far = d.far;
		this.focus = d.focus;
		this.aspect = d.aspect;
		this.view = null === d.view ? null : Object.assign({}, d.view);
		this.filmGauge = d.filmGauge;
		this.filmOffset = d.filmOffset;
		return this;
	}, setFocalLength:function(d) {
		d = .5 * this.getFilmHeight() / d;
		this.fov = 2 * da.RAD2DEG * Math.atan(d);
		this.updateProjectionMatrix();
	}, getFocalLength:function() {
		var d = Math.tan(.5 * da.DEG2RAD * this.fov);
		return .5 * this.getFilmHeight() / d;
	}, getEffectiveFOV:function() {
		return 2 * da.RAD2DEG * Math.atan(Math.tan(.5 * da.DEG2RAD * this.fov) / this.zoom);
	}, getFilmWidth:function() {
		return this.filmGauge * Math.min(this.aspect, 1);
	}, getFilmHeight:function() {
		return this.filmGauge / Math.max(this.aspect, 1);
	}, setViewOffset:function(d, a, b, c, e, g) {
		this.aspect = d / a;
		this.view = {fullWidth:d, fullHeight:a, offsetX:b, offsetY:c, width:e, height:g};
		this.updateProjectionMatrix();
	}, clearViewOffset:function() {
		this.view = null;
		this.updateProjectionMatrix();
	}, updateProjectionMatrix:function() {
		var d = this.near, a = d * Math.tan(.5 * da.DEG2RAD * this.fov) / this.zoom, b = 2 * a, c = this.aspect * b, e = -.5 * c, g = this.view;
		if (null !== g) {
			var m = g.fullWidth, h = g.fullHeight, e = e + g.offsetX * c / m, a = a - g.offsetY * b / h, c = g.width / m * c, b = g.height / h * b
		}
		g = this.filmOffset;
		0 !== g && (e += d * g / this.getFilmWidth());
		this.projectionMatrix.makeFrustum(e, e + c, a - b, a, d, this.far);
	}, toJSON:function(d) {
		d = X.prototype.toJSON.call(this, d);
		d.object.fov = this.fov;
		d.object.zoom = this.zoom;
		d.object.near = this.near;
		d.object.far = this.far;
		d.object.focus = this.focus;
		d.object.aspect = this.aspect;
		null !== this.view && (d.object.view = Object.assign({}, this.view));
		d.object.filmGauge = this.filmGauge;
		d.object.filmOffset = this.filmOffset;
		return d;
	}});
	Yb.prototype = Object.assign(Object.create(xa.prototype), {constructor:Yb, isOrthographicCamera:!0, copy:function(d) {
		xa.prototype.copy.call(this, d);
		this.left = d.left;
		this.right = d.right;
		this.top = d.top;
		this.bottom = d.bottom;
		this.near = d.near;
		this.far = d.far;
		this.zoom = d.zoom;
		this.view = null === d.view ? null : Object.assign({}, d.view);
		return this;
	}, setViewOffset:function(d, a, b, c, e, g) {
		this.view = {fullWidth:d, fullHeight:a, offsetX:b, offsetY:c, width:e, height:g};
		this.updateProjectionMatrix();
	}, clearViewOffset:function() {
		this.view = null;
		this.updateProjectionMatrix();
	}, updateProjectionMatrix:function() {
		var d = (this.right - this.left) / (2 * this.zoom), a = (this.top - this.bottom) / (2 * this.zoom), b = (this.right + this.left) / 2, c = (this.top + this.bottom) / 2, e = b - d, b = b + d, d = c + a, a = c - a;
		if (null !== this.view) {
			var b = this.zoom / (this.view.width / this.view.fullWidth), a = this.zoom / (this.view.height / this.view.fullHeight), g = (this.right - this.left) / this.view.width, c = (this.top - this.bottom) / this.view.height, e = e + this.view.offsetX / b * g, b = e + this.view.width / b * g, d = d - this.view.offsetY / a * c, a = d - this.view.height / a * c
		}
		this.projectionMatrix.makeOrthographic(e, b, d, a, this.near, this.far);
	}, toJSON:function(d) {
		d = X.prototype.toJSON.call(this, d);
		d.object.zoom = this.zoom;
		d.object.left = this.left;
		d.object.right = this.right;
		d.object.top = this.top;
		d.object.bottom = this.bottom;
		d.object.near = this.near;
		d.object.far = this.far;
		null !== this.view && (d.object.view = Object.assign({}, this.view));
		return d;
	}});
	var Te = 0;
	$b.prototype.isFogExp2 = !0;
	$b.prototype.clone = function() {
		return new $b(this.color.getHex(), this.density);
	};
	$b.prototype.toJSON = function(d) {
		return {type:"FogExp2", color:this.color.getHex(), density:this.density};
	};
	ac.prototype.isFog = !0;
	ac.prototype.clone = function() {
		return new ac(this.color.getHex(), this.near, this.far);
	};
	ac.prototype.toJSON = function(d) {
		return {type:"Fog", color:this.color.getHex(), near:this.near, far:this.far};
	};
	Cb.prototype = Object.create(X.prototype);
	Cb.prototype.constructor = Cb;
	Cb.prototype.copy = function(d, a) {
		X.prototype.copy.call(this, d, a);
		null !== d.background && (this.background = d.background.clone());
		null !== d.fog && (this.fog = d.fog.clone());
		null !== d.overrideMaterial && (this.overrideMaterial = d.overrideMaterial.clone());
		this.autoUpdate = d.autoUpdate;
		this.matrixAutoUpdate = d.matrixAutoUpdate;
		return this;
	};
	Cb.prototype.toJSON = function(d) {
		var a = X.prototype.toJSON.call(this, d);
		null !== this.background && (a.object.background = this.background.toJSON(d));
		null !== this.fog && (a.object.fog = this.fog.toJSON());
		return a;
	};
	Yd.prototype = Object.assign(Object.create(X.prototype), {constructor:Yd, isLensFlare:!0, copy:function(d) {
		X.prototype.copy.call(this, d);
		this.positionScreen.copy(d.positionScreen);
		this.customUpdateCallback = d.customUpdateCallback;
		for (var a = 0, b = d.lensFlares.length;a < b;a++) {
			this.lensFlares.push(d.lensFlares[a]);
		}
		return this;
	}, add:function(d, a, b, c, e, g) {
		void 0 === a && (a = -1);
		void 0 === b && (b = 0);
		void 0 === g && (g = 1);
		void 0 === e && (e = new T(16777215));
		void 0 === c && (c = 1);
		b = Math.min(b, Math.max(0, b));
		this.lensFlares.push({texture:d, size:a, distance:b, x:0, y:0, z:0, scale:1, rotation:0, opacity:g, color:e, blending:c});
	}, updateLensFlares:function() {
		var d, a = this.lensFlares.length, b, c = 2 * -this.positionScreen.x, e = 2 * -this.positionScreen.y;
		for (d = 0;d < a;d++) {
			b = this.lensFlares[d], b.x = this.positionScreen.x + c * b.distance, b.y = this.positionScreen.y + e * b.distance, b.wantedRotation = b.x * Math.PI * .25, b.rotation += .25 * (b.wantedRotation - b.rotation);
		}
	}});
	Db.prototype = Object.create(Z.prototype);
	Db.prototype.constructor = Db;
	Db.prototype.copy = function(d) {
		Z.prototype.copy.call(this, d);
		this.color.copy(d.color);
		this.map = d.map;
		this.rotation = d.rotation;
		return this;
	};
	Kc.prototype = Object.assign(Object.create(X.prototype), {constructor:Kc, isSprite:!0, raycast:function() {
		var d = new g;
		return function(a, b) {
			d.setFromMatrixPosition(this.matrixWorld);
			a = a.ray.distanceSqToPoint(d);
			a > this.scale.x * this.scale.y / 4 || b.push({distance:Math.sqrt(a), point:this.position, face:null, object:this});
		};
	}(), clone:function() {
		return (new this.constructor(this.material)).copy(this);
	}});
	Lc.prototype = Object.assign(Object.create(X.prototype), {constructor:Lc, copy:function(d) {
		X.prototype.copy.call(this, d, !1);
		d = d.levels;
		for (var a = 0, b = d.length;a < b;a++) {
			var c = d[a];
			this.addLevel(c.object.clone(), c.distance);
		}
		return this;
	}, addLevel:function(d, a) {
		void 0 === a && (a = 0);
		a = Math.abs(a);
		for (var b = this.levels, c = 0;c < b.length && !(a < b[c].distance);c++) {
		}
		b.splice(c, 0, {distance:a, object:d});
		this.add(d);
	}, getObjectForDistance:function(d) {
		for (var a = this.levels, b = 1, c = a.length;b < c && !(d < a[b].distance);b++) {
		}
		return a[b - 1].object;
	}, raycast:function() {
		var d = new g;
		return function(a, b) {
			d.setFromMatrixPosition(this.matrixWorld);
			var c = a.ray.origin.distanceTo(d);
			this.getObjectForDistance(c).raycast(a, b);
		};
	}(), update:function() {
		var d = new g, a = new g;
		return function(b) {
			var c = this.levels;
			if (1 < c.length) {
				d.setFromMatrixPosition(b.matrixWorld);
				a.setFromMatrixPosition(this.matrixWorld);
				b = d.distanceTo(a);
				c[0].object.visible = !0;
				for (var n = 1, e = c.length;n < e;n++) {
					if (b >= c[n].distance) {
						c[n - 1].object.visible = !1, c[n].object.visible = !0;
					} else {
						break;
					}
				}
				for (;n < e;n++) {
					c[n].object.visible = !1;
				}
			}
		};
	}(), toJSON:function(d) {
		d = X.prototype.toJSON.call(this, d);
		d.object.levels = [];
		for (var a = this.levels, b = 0, c = a.length;b < c;b++) {
			var e = a[b];
			d.object.levels.push({object:e.object.uuid, distance:e.distance});
		}
		return d;
	}});
	Object.assign(td.prototype, {calculateInverses:function() {
		this.boneInverses = [];
		for (var d = 0, a = this.bones.length;d < a;d++) {
			var b = new q;
			this.bones[d] && b.getInverse(this.bones[d].matrixWorld);
			this.boneInverses.push(b);
		}
	}, pose:function() {
		for (var d, a = 0, b = this.bones.length;a < b;a++) {
			(d = this.bones[a]) && d.matrixWorld.getInverse(this.boneInverses[a]);
		}
		a = 0;
		for (b = this.bones.length;a < b;a++) {
			if (d = this.bones[a]) {
				d.parent && d.parent.isBone ? (d.matrix.getInverse(d.parent.matrixWorld), d.matrix.multiply(d.matrixWorld)) : d.matrix.copy(d.matrixWorld), d.matrix.decompose(d.position, d.quaternion, d.scale);
			}
		}
	}, update:function() {
		var d = new q;
		return function() {
			for (var a = 0, b = this.bones.length;a < b;a++) {
				d.multiplyMatrices(this.bones[a] ? this.bones[a].matrixWorld : this.identityMatrix, this.boneInverses[a]), d.toArray(this.boneMatrices, 16 * a);
			}
			this.useVertexTexture && (this.boneTexture.needsUpdate = !0);
		};
	}(), clone:function() {
		return new td(this.bones, this.boneInverses, this.useVertexTexture);
	}});
	ud.prototype = Object.assign(Object.create(X.prototype), {constructor:ud, isBone:!0});
	vd.prototype = Object.assign(Object.create(Da.prototype), {constructor:vd, isSkinnedMesh:!0, bind:function(d, a) {
		this.skeleton = d;
		void 0 === a && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), a = this.matrixWorld);
		this.bindMatrix.copy(a);
		this.bindMatrixInverse.getInverse(a);
	}, pose:function() {
		this.skeleton.pose();
	}, normalizeSkinWeights:function() {
		if (this.geometry && this.geometry.isGeometry) {
			for (var d = 0;d < this.geometry.skinWeights.length;d++) {
				var a = this.geometry.skinWeights[d], b = 1 / a.lengthManhattan();
				Infinity !== b ? a.multiplyScalar(b) : a.set(1, 0, 0, 0);
			}
		} else {
			if (this.geometry && this.geometry.isBufferGeometry) {
				for (var a = new k, c = this.geometry.attributes.skinWeight, d = 0;d < c.count;d++) {
					a.x = c.getX(d), a.y = c.getY(d), a.z = c.getZ(d), a.w = c.getW(d), b = 1 / a.lengthManhattan(), Infinity !== b ? a.multiplyScalar(b) : a.set(1, 0, 0, 0), c.setXYZW(d, a.x, a.y, a.z, a.w);
				}
			}
		}
	}, updateMatrixWorld:function(d) {
		Da.prototype.updateMatrixWorld.call(this, !0);
		"attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode);
	}, clone:function() {
		return (new this.constructor(this.geometry, this.material, this.skeleton.useVertexTexture)).copy(this);
	}});
	za.prototype = Object.create(Z.prototype);
	za.prototype.constructor = za;
	za.prototype.isLineBasicMaterial = !0;
	za.prototype.copy = function(d) {
		Z.prototype.copy.call(this, d);
		this.color.copy(d.color);
		this.linewidth = d.linewidth;
		this.linecap = d.linecap;
		this.linejoin = d.linejoin;
		return this;
	};
	tb.prototype = Object.assign(Object.create(X.prototype), {constructor:tb, isLine:!0, raycast:function() {
		var d = new q, a = new jb, b = new Ca;
		return function(c, e) {
			var n = c.linePrecision, n = n * n, m = this.geometry, h = this.matrixWorld;
			null === m.boundingSphere && m.computeBoundingSphere();
			b.copy(m.boundingSphere);
			b.applyMatrix4(h);
			if (!1 !== c.ray.intersectsSphere(b)) {
				d.getInverse(h);
				a.copy(c.ray).applyMatrix4(d);
				var k = new g, q = new g, h = new g, f = new g, p = this && this.isLineSegments ? 2 : 1;
				if (m.isBufferGeometry) {
					var r = m.index, u = m.attributes.position.array;
					if (null !== r) {
						for (var r = r.array, m = 0, l = r.length - 1;m < l;m += p) {
							var w = r[m + 1];
							k.fromArray(u, 3 * r[m]);
							q.fromArray(u, 3 * w);
							w = a.distanceSqToSegment(k, q, f, h);
							w > n || (f.applyMatrix4(this.matrixWorld), w = c.ray.origin.distanceTo(f), w < c.near || w > c.far || e.push({distance:w, point:h.clone().applyMatrix4(this.matrixWorld), index:m, face:null, faceIndex:null, object:this}));
						}
					} else {
						for (m = 0, l = u.length / 3 - 1;m < l;m += p) {
							k.fromArray(u, 3 * m), q.fromArray(u, 3 * m + 3), w = a.distanceSqToSegment(k, q, f, h), w > n || (f.applyMatrix4(this.matrixWorld), w = c.ray.origin.distanceTo(f), w < c.near || w > c.far || e.push({distance:w, point:h.clone().applyMatrix4(this.matrixWorld), index:m, face:null, faceIndex:null, object:this}));
						}
					}
				} else {
					if (m.isGeometry) {
						for (k = m.vertices, q = k.length, m = 0;m < q - 1;m += p) {
							w = a.distanceSqToSegment(k[m], k[m + 1], f, h), w > n || (f.applyMatrix4(this.matrixWorld), w = c.ray.origin.distanceTo(f), w < c.near || w > c.far || e.push({distance:w, point:h.clone().applyMatrix4(this.matrixWorld), index:m, face:null, faceIndex:null, object:this}));
						}
					}
				}
			}
		};
	}(), clone:function() {
		return (new this.constructor(this.geometry, this.material)).copy(this);
	}});
	ta.prototype = Object.assign(Object.create(tb.prototype), {constructor:ta, isLineSegments:!0});
	gb.prototype = Object.create(Z.prototype);
	gb.prototype.constructor = gb;
	gb.prototype.isPointsMaterial = !0;
	gb.prototype.copy = function(d) {
		Z.prototype.copy.call(this, d);
		this.color.copy(d.color);
		this.map = d.map;
		this.size = d.size;
		this.sizeAttenuation = d.sizeAttenuation;
		return this;
	};
	bc.prototype = Object.assign(Object.create(X.prototype), {constructor:bc, isPoints:!0, raycast:function() {
		var d = new q, a = new jb, b = new Ca;
		return function(c, e) {
			function n(d, b) {
				var n = a.distanceSqToPoint(d);
				if (n < f) {
					d = a.closestPointToPoint(d);
					d.applyMatrix4(k);
					var g = c.ray.origin.distanceTo(d);
					g < c.near || g > c.far || e.push({distance:g, distanceToRay:Math.sqrt(n), point:d.clone(), index:b, face:null, object:m});
				}
			}
			var m = this, h = this.geometry, k = this.matrixWorld, q = c.params.Points.threshold;
			null === h.boundingSphere && h.computeBoundingSphere();
			b.copy(h.boundingSphere);
			b.applyMatrix4(k);
			if (!1 !== c.ray.intersectsSphere(b)) {
				d.getInverse(k);
				a.copy(c.ray).applyMatrix4(d);
				var q = q / ((this.scale.x + this.scale.y + this.scale.z) / 3), f = q * q, q = new g;
				if (h.isBufferGeometry) {
					var p = h.index, h = h.attributes.position.array;
					if (null !== p) {
						for (var r = p.array, p = 0, u = r.length;p < u;p++) {
							var l = r[p];
							q.fromArray(h, 3 * l);
							n(q, l);
						}
					} else {
						for (p = 0, r = h.length / 3;p < r;p++) {
							q.fromArray(h, 3 * p), n(q, p);
						}
					}
				} else {
					for (q = h.vertices, p = 0, r = q.length;p < r;p++) {
						n(q[p], p);
					}
				}
			}
		};
	}(), clone:function() {
		return (new this.constructor(this.geometry, this.material)).copy(this);
	}});
	Mc.prototype = Object.assign(Object.create(X.prototype), {constructor:Mc});
	wd.prototype = Object.create(b.prototype);
	wd.prototype.constructor = wd;
	cc.prototype = Object.create(b.prototype);
	cc.prototype.constructor = cc;
	cc.prototype.isCompressedTexture = !0;
	xd.prototype = Object.create(b.prototype);
	xd.prototype.constructor = xd;
	Nc.prototype = Object.create(b.prototype);
	Nc.prototype.constructor = Nc;
	Nc.prototype.isDepthTexture = !0;
	dc.prototype = Object.create(ca.prototype);
	dc.prototype.constructor = dc;
	ec.prototype = Object.create(ca.prototype);
	ec.prototype.constructor = ec;
	Oc.prototype = Object.create(ja.prototype);
	Oc.prototype.constructor = Oc;
	Wa.prototype = Object.create(ca.prototype);
	Wa.prototype.constructor = Wa;
	fc.prototype = Object.create(Wa.prototype);
	fc.prototype.constructor = fc;
	Pc.prototype = Object.create(ja.prototype);
	Pc.prototype.constructor = Pc;
	Eb.prototype = Object.create(Wa.prototype);
	Eb.prototype.constructor = Eb;
	Qc.prototype = Object.create(ja.prototype);
	Qc.prototype.constructor = Qc;
	gc.prototype = Object.create(Wa.prototype);
	gc.prototype.constructor = gc;
	Rc.prototype = Object.create(ja.prototype);
	Rc.prototype.constructor = Rc;
	hc.prototype = Object.create(Wa.prototype);
	hc.prototype.constructor = hc;
	Sc.prototype = Object.create(ja.prototype);
	Sc.prototype.constructor = Sc;
	Tc.prototype = Object.create(ja.prototype);
	Tc.prototype.constructor = Tc;
	ic.prototype = Object.create(ca.prototype);
	ic.prototype.constructor = ic;
	Uc.prototype = Object.create(ja.prototype);
	Uc.prototype.constructor = Uc;
	jc.prototype = Object.create(ca.prototype);
	jc.prototype.constructor = jc;
	Vc.prototype = Object.create(ja.prototype);
	Vc.prototype.constructor = Vc;
	kc.prototype = Object.create(ca.prototype);
	kc.prototype.constructor = kc;
	Wc.prototype = Object.create(ja.prototype);
	Wc.prototype.constructor = Wc;
	var Ea = {area:function(d) {
		for (var a = d.length, b = 0, c = a - 1, e = 0;e < a;c = e++) {
			b += d[c].x * d[e].y - d[e].x * d[c].y;
		}
		return .5 * b;
	}, triangulate:function() {
		return function(d, a) {
			var b = d.length;
			if (3 > b) {
				return null;
			}
			var c = [], e = [], n = [], g, m, h;
			if (0 < Ea.area(d)) {
				for (m = 0;m < b;m++) {
					e[m] = m;
				}
			} else {
				for (m = 0;m < b;m++) {
					e[m] = b - 1 - m;
				}
			}
			var k = 2 * b;
			for (m = b - 1;2 < b;) {
				if (0 >= k--) {
					console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
					break;
				}
				g = m;
				b <= g && (g = 0);
				m = g + 1;
				b <= m && (m = 0);
				h = m + 1;
				b <= h && (h = 0);
				var q;
				a: {
					var f, p, r, u, l, w, t, v;
					f = d[e[g]].x;
					p = d[e[g]].y;
					r = d[e[m]].x;
					u = d[e[m]].y;
					l = d[e[h]].x;
					w = d[e[h]].y;
					if (0 >= (r - f) * (w - p) - (u - p) * (l - f)) {
						q = !1;
					} else {
						var B, y, A, x, C, G, F, D, L, W;
						B = l - r;
						y = w - u;
						A = f - l;
						x = p - w;
						C = r - f;
						G = u - p;
						for (q = 0;q < b;q++) {
							if (t = d[e[q]].x, v = d[e[q]].y, !(t === f && v === p || t === r && v === u || t === l && v === w) && (F = t - f, D = v - p, L = t - r, W = v - u, t -= l, v -= w, L = B * W - y * L, F = C * D - G * F, D = A * v - x * t, L >= -Number.EPSILON && D >= -Number.EPSILON && F >= -Number.EPSILON)) {
								q = !1;
								break a;
							}
						}
						q = !0;
					}
				}
				if (q) {
					c.push([d[e[g]], d[e[m]], d[e[h]]]);
					n.push([e[g], e[m], e[h]]);
					g = m;
					for (h = m + 1;h < b;g++, h++) {
						e[g] = e[h];
					}
					b--;
					k = 2 * b;
				}
			}
			return a ? n : c;
		};
	}(), triangulateShape:function(d, a) {
		function b(d) {
			var a = d.length;
			2 < a && d[a - 1].equals(d[0]) && d.pop();
		}
		function c(d, a, b) {
			return d.x !== a.x ? d.x < a.x ? d.x <= b.x && b.x <= a.x : a.x <= b.x && b.x <= d.x : d.y < a.y ? d.y <= b.y && b.y <= a.y : a.y <= b.y && b.y <= d.y;
		}
		function e(d, a, b, e, n) {
			var g = a.x - d.x, m = a.y - d.y, h = e.x - b.x, k = e.y - b.y, q = d.x - b.x, f = d.y - b.y, p = m * h - g * k, r = m * q - g * f;
			if (Math.abs(p) > Number.EPSILON) {
				if (0 < p) {
					if (0 > r || r > p) {
						return [];
					}
					h = k * q - h * f;
					if (0 > h || h > p) {
						return [];
					}
				} else {
					if (0 < r || r < p) {
						return [];
					}
					h = k * q - h * f;
					if (0 < h || h < p) {
						return [];
					}
				}
				if (0 === h) {
					return !n || 0 !== r && r !== p ? [d] : [];
				}
				if (h === p) {
					return !n || 0 !== r && r !== p ? [a] : [];
				}
				if (0 === r) {
					return [b];
				}
				if (r === p) {
					return [e];
				}
				n = h / p;
				return [{x:d.x + n * g, y:d.y + n * m}];
			}
			if (0 !== r || k * q !== h * f) {
				return [];
			}
			m = 0 === g && 0 === m;
			h = 0 === h && 0 === k;
			if (m && h) {
				return d.x !== b.x || d.y !== b.y ? [] : [d];
			}
			if (m) {
				return c(b, e, d) ? [d] : [];
			}
			if (h) {
				return c(d, a, b) ? [b] : [];
			}
			0 !== g ? (d.x < a.x ? (g = d, h = d.x, m = a, d = a.x) : (g = a, h = a.x, m = d, d = d.x), b.x < e.x ? (a = b, p = b.x, k = e, b = e.x) : (a = e, p = e.x, k = b, b = b.x)) : (d.y < a.y ? (g = d, h = d.y, m = a, d = a.y) : (g = a, h = a.y, m = d, d = d.y), b.y < e.y ? (a = b, p = b.y, k = e, b = e.y) : (a = e, p = e.y, k = b, b = b.y));
			return h <= p ? d < p ? [] : d === p ? n ? [] : [a] : d <= b ? [a, m] : [a, k] : h > b ? [] : h === b ? n ? [] : [g] : d <= b ? [g, m] : [g, k];
		}
		function n(d, a, b, c) {
			var e = a.x - d.x, n = a.y - d.y;
			a = b.x - d.x;
			b = b.y - d.y;
			var g = c.x - d.x;
			c = c.y - d.y;
			d = e * b - n * a;
			e = e * c - n * g;
			return Math.abs(d) > Number.EPSILON ? (a = g * b - c * a, 0 < d ? 0 <= e && 0 <= a : 0 <= e || 0 <= a) : 0 < e;
		}
		b(d);
		a.forEach(b);
		var g, m, h, k, q = {};
		h = d.concat();
		g = 0;
		for (m = a.length;g < m;g++) {
			Array.prototype.push.apply(h, a[g]);
		}
		g = 0;
		for (m = h.length;g < m;g++) {
			k = h[g].x + ":" + h[g].y, void 0 !== q[k] && console.warn("THREE.ShapeUtils: Duplicate point", k, g), q[k] = g;
		}
		g = function(d, a) {
			function b(d, a) {
				var b = m.length - 1, c = d - 1;
				0 > c && (c = b);
				var e = d + 1;
				e > b && (e = 0);
				b = n(m[d], m[c], m[e], h[a]);
				if (!b) {
					return !1;
				}
				b = h.length - 1;
				c = a - 1;
				0 > c && (c = b);
				e = a + 1;
				e > b && (e = 0);
				return n(h[a], h[c], h[e], m[d]) ? !0 : !1;
			}
			function c(d, a) {
				var b, c;
				for (b = 0;b < m.length;b++) {
					if (c = b + 1, c %= m.length, c = e(d, a, m[b], m[c], !0), 0 < c.length) {
						return !0;
					}
				}
				return !1;
			}
			function g(d, b) {
				var c, n, g, m;
				for (c = 0;c < k.length;c++) {
					for (n = a[k[c]], g = 0;g < n.length;g++) {
						if (m = g + 1, m %= n.length, m = e(d, b, n[g], n[m], !0), 0 < m.length) {
							return !0;
						}
					}
				}
				return !1;
			}
			var m = d.concat(), h, k = [], q, f, p, r, u = [], l, w, z, t = 0;
			for (d = a.length;t < d;t++) {
				k.push(t);
			}
			l = 0;
			for (var v = 2 * k.length;0 < k.length;) {
				v--;
				if (0 > v) {
					console.log("Infinite Loop! Holes left:" + k.length + ", Probably Hole outside Shape!");
					break;
				}
				for (q = l;q < m.length;q++) {
					f = m[q];
					d = -1;
					for (t = 0;t < k.length;t++) {
						if (p = k[t], r = f.x + ":" + f.y + ":" + p, void 0 === u[r]) {
							h = a[p];
							for (w = 0;w < h.length;w++) {
								if (p = h[w], b(q, w) && !c(f, p) && !g(f, p)) {
									d = w;
									k.splice(t, 1);
									l = m.slice(0, q + 1);
									p = m.slice(q);
									w = h.slice(d);
									z = h.slice(0, d + 1);
									m = l.concat(w).concat(z).concat(p);
									l = q;
									break;
								}
							}
							if (0 <= d) {
								break;
							}
							u[r] = !0;
						}
					}
					if (0 <= d) {
						break;
					}
				}
			}
			return m;
		}(d, a);
		a = Ea.triangulate(g, !1);
		g = 0;
		for (m = a.length;g < m;g++) {
			for (d = a[g], h = 0;3 > h;h++) {
				k = d[h].x + ":" + d[h].y, k = q[k], void 0 !== k && (d[h] = k);
			}
		}
		return a.concat();
	}, isClockWise:function(d) {
		return 0 > Ea.area(d);
	}, b2:function() {
		return function(d, a, b, c) {
			var e = 1 - d;
			return e * e * a + 2 * (1 - d) * d * b + d * d * c;
		};
	}(), b3:function() {
		return function(d, a, b, c, e) {
			var n = 1 - d, g = 1 - d;
			return n * n * n * a + 3 * g * g * d * b + 3 * (1 - d) * d * d * c + d * d * d * e;
		};
	}()};
	eb.prototype = Object.create(ja.prototype);
	eb.prototype.constructor = eb;
	eb.prototype.addShapeList = function(d, a) {
		for (var b = d.length, c = 0;c < b;c++) {
			this.addShape(d[c], a);
		}
	};
	eb.prototype.addShape = function(d, a) {
		function b(d, a, b) {
			a || console.error("THREE.ExtrudeGeometry: vec does not exist");
			return a.clone().multiplyScalar(b).add(d);
		}
		function c(d, a, b) {
			var c, e, n;
			e = d.x - a.x;
			n = d.y - a.y;
			c = b.x - d.x;
			var g = b.y - d.y, m = e * e + n * n;
			if (Math.abs(e * g - n * c) > Number.EPSILON) {
				var h = Math.sqrt(m), k = Math.sqrt(c * c + g * g), m = a.x - n / h;
				a = a.y + e / h;
				g = ((b.x - g / k - m) * g - (b.y + c / k - a) * c) / (e * g - n * c);
				c = m + e * g - d.x;
				e = a + n * g - d.y;
				n = c * c + e * e;
				if (2 >= n) {
					return new l(c, e);
				}
				n = Math.sqrt(n / 2);
			} else {
				d = !1, e > Number.EPSILON ? c > Number.EPSILON && (d = !0) : e < -Number.EPSILON ? c < -Number.EPSILON && (d = !0) : Math.sign(n) === Math.sign(g) && (d = !0), d ? (c = -n, n = Math.sqrt(m)) : (c = e, e = n, n = Math.sqrt(m / 2));
			}
			return new l(c / n, e / n);
		}
		function e(d, a) {
			var b, c;
			for (H = d.length;0 <= --H;) {
				b = H;
				c = H - 1;
				0 > c && (c = d.length - 1);
				var e, n = u + 2 * f;
				for (e = 0;e < n;e++) {
					var g = N * e, m = N * (e + 1), h = a + b + g, g = a + c + g, k = a + c + m, m = a + b + m, h = h + W, g = g + W, k = k + W, m = m + W;
					L.faces.push(new Ja(h, g, m, null, null, 1));
					L.faces.push(new Ja(g, k, m, null, null, 1));
					h = B.generateSideWallUV(L, h, g, k, m);
					L.faceVertexUvs[0].push([h[0], h[1], h[3]]);
					L.faceVertexUvs[0].push([h[1], h[2], h[3]]);
				}
			}
		}
		function n(d, a, b) {
			L.vertices.push(new g(d, a, b));
		}
		function m(d, a, b) {
			d += W;
			a += W;
			b += W;
			L.faces.push(new Ja(d, a, b, null, null, 0));
			d = B.generateTopUV(L, d, a, b);
			L.faceVertexUvs[0].push(d);
		}
		var h = void 0 !== a.amount ? a.amount : 100, k = void 0 !== a.bevelThickness ? a.bevelThickness : 6, q = void 0 !== a.bevelSize ? a.bevelSize : k - 2, f = void 0 !== a.bevelSegments ? a.bevelSegments : 3, p = void 0 !== a.bevelEnabled ? a.bevelEnabled : !0, r = void 0 !== a.curveSegments ? a.curveSegments : 12, u = void 0 !== a.steps ? a.steps : 1, w = a.extrudePath, t, v = !1, B = void 0 !== a.UVGenerator ? a.UVGenerator : eb.WorldUVGenerator, y, A, x, C;
		w && (t = w.getSpacedPoints(u), v = !0, p = !1, y = void 0 !== a.frames ? a.frames : w.computeFrenetFrames(u, !1), A = new g, x = new g, C = new g);
		p || (q = k = f = 0);
		var G, F, D, L = this, W = this.vertices.length, w = d.extractPoints(r), r = w.shape, J = w.holes;
		if (w = !Ea.isClockWise(r)) {
			r = r.reverse();
			F = 0;
			for (D = J.length;F < D;F++) {
				G = J[F], Ea.isClockWise(G) && (J[F] = G.reverse());
			}
			w = !1;
		}
		var I = Ea.triangulateShape(r, J), Y = r;
		F = 0;
		for (D = J.length;F < D;F++) {
			G = J[F], r = r.concat(G);
		}
		var M, S, ia, N = r.length, ga, Q = I.length, w = [], H = 0;
		M = Y.length;
		d = M - 1;
		for (a = H + 1;H < M;H++, d++, a++) {
			d === M && (d = 0), a === M && (a = 0), w[H] = c(Y[H], Y[d], Y[a]);
		}
		var ba = [], R, T = w.concat();
		F = 0;
		for (D = J.length;F < D;F++) {
			G = J[F];
			R = [];
			H = 0;
			M = G.length;
			d = M - 1;
			for (a = H + 1;H < M;H++, d++, a++) {
				d === M && (d = 0), a === M && (a = 0), R[H] = c(G[H], G[d], G[a]);
			}
			ba.push(R);
			T = T.concat(R);
		}
		for (d = 0;d < f;d++) {
			M = d / f;
			S = k * Math.cos(M * Math.PI / 2);
			a = q * Math.sin(M * Math.PI / 2);
			H = 0;
			for (M = Y.length;H < M;H++) {
				ia = b(Y[H], w[H], a), n(ia.x, ia.y, -S);
			}
			F = 0;
			for (D = J.length;F < D;F++) {
				for (G = J[F], R = ba[F], H = 0, M = G.length;H < M;H++) {
					ia = b(G[H], R[H], a), n(ia.x, ia.y, -S);
				}
			}
		}
		a = q;
		for (H = 0;H < N;H++) {
			ia = p ? b(r[H], T[H], a) : r[H], v ? (x.copy(y.normals[0]).multiplyScalar(ia.x), A.copy(y.binormals[0]).multiplyScalar(ia.y), C.copy(t[0]).add(x).add(A), n(C.x, C.y, C.z)) : n(ia.x, ia.y, 0);
		}
		for (M = 1;M <= u;M++) {
			for (H = 0;H < N;H++) {
				ia = p ? b(r[H], T[H], a) : r[H], v ? (x.copy(y.normals[M]).multiplyScalar(ia.x), A.copy(y.binormals[M]).multiplyScalar(ia.y), C.copy(t[M]).add(x).add(A), n(C.x, C.y, C.z)) : n(ia.x, ia.y, h / u * M);
			}
		}
		for (d = f - 1;0 <= d;d--) {
			M = d / f;
			S = k * Math.cos(M * Math.PI / 2);
			a = q * Math.sin(M * Math.PI / 2);
			H = 0;
			for (M = Y.length;H < M;H++) {
				ia = b(Y[H], w[H], a), n(ia.x, ia.y, h + S);
			}
			F = 0;
			for (D = J.length;F < D;F++) {
				for (G = J[F], R = ba[F], H = 0, M = G.length;H < M;H++) {
					ia = b(G[H], R[H], a), v ? n(ia.x, ia.y + t[u - 1].y, t[u - 1].x + S) : n(ia.x, ia.y, h + S);
				}
			}
		}
		(function() {
			if (p) {
				var d = 0 * N;
				for (H = 0;H < Q;H++) {
					ga = I[H], m(ga[2] + d, ga[1] + d, ga[0] + d);
				}
				d = N * (u + 2 * f);
				for (H = 0;H < Q;H++) {
					ga = I[H], m(ga[0] + d, ga[1] + d, ga[2] + d);
				}
			} else {
				for (H = 0;H < Q;H++) {
					ga = I[H], m(ga[2], ga[1], ga[0]);
				}
				for (H = 0;H < Q;H++) {
					ga = I[H], m(ga[0] + N * u, ga[1] + N * u, ga[2] + N * u);
				}
			}
		})();
		(function() {
			var d = 0;
			e(Y, d);
			d += Y.length;
			F = 0;
			for (D = J.length;F < D;F++) {
				G = J[F], e(G, d), d += G.length;
			}
		})();
	};
	eb.WorldUVGenerator = {generateTopUV:function(d, a, b, c) {
		d = d.vertices;
		a = d[a];
		b = d[b];
		c = d[c];
		return [new l(a.x, a.y), new l(b.x, b.y), new l(c.x, c.y)];
	}, generateSideWallUV:function(d, a, b, c, e) {
		d = d.vertices;
		a = d[a];
		b = d[b];
		c = d[c];
		e = d[e];
		return .01 > Math.abs(a.y - b.y) ? [new l(a.x, 1 - a.z), new l(b.x, 1 - b.z), new l(c.x, 1 - c.z), new l(e.x, 1 - e.z)] : [new l(a.y, 1 - a.z), new l(b.y, 1 - b.z), new l(c.y, 1 - c.z), new l(e.y, 1 - e.z)];
	}};
	Xc.prototype = Object.create(eb.prototype);
	Xc.prototype.constructor = Xc;
	Fb.prototype = Object.create(ca.prototype);
	Fb.prototype.constructor = Fb;
	Yc.prototype = Object.create(ja.prototype);
	Yc.prototype.constructor = Yc;
	lc.prototype = Object.create(ca.prototype);
	lc.prototype.constructor = lc;
	Zc.prototype = Object.create(ja.prototype);
	Zc.prototype.constructor = Zc;
	$c.prototype = Object.create(ja.prototype);
	$c.prototype.constructor = $c;
	mc.prototype = Object.create(ca.prototype);
	mc.prototype.constructor = mc;
	ad.prototype = Object.create(ja.prototype);
	ad.prototype.constructor = ad;
	nc.prototype = Object.create(ca.prototype);
	nc.prototype.constructor = nc;
	oc.prototype = Object.create(ja.prototype);
	oc.prototype.constructor = oc;
	pc.prototype = Object.create(ca.prototype);
	pc.prototype.constructor = pc;
	ub.prototype = Object.create(ca.prototype);
	ub.prototype.constructor = ub;
	Gb.prototype = Object.create(ja.prototype);
	Gb.prototype.constructor = Gb;
	bd.prototype = Object.create(Gb.prototype);
	bd.prototype.constructor = bd;
	cd.prototype = Object.create(ub.prototype);
	cd.prototype.constructor = cd;
	qc.prototype = Object.create(ca.prototype);
	qc.prototype.constructor = qc;
	dd.prototype = Object.create(ja.prototype);
	dd.prototype.constructor = dd;
	rc.prototype = Object.create(ja.prototype);
	rc.prototype.constructor = rc;
	var ib = Object.freeze({WireframeGeometry:dc, ParametricGeometry:Oc, ParametricBufferGeometry:ec, TetrahedronGeometry:Pc, TetrahedronBufferGeometry:fc, OctahedronGeometry:Qc, OctahedronBufferGeometry:Eb, IcosahedronGeometry:Rc, IcosahedronBufferGeometry:gc, DodecahedronGeometry:Sc, DodecahedronBufferGeometry:hc, PolyhedronGeometry:Tc, PolyhedronBufferGeometry:Wa, TubeGeometry:Uc, TubeBufferGeometry:ic, TorusKnotGeometry:Vc, TorusKnotBufferGeometry:jc, TorusGeometry:Wc, TorusBufferGeometry:kc, TextGeometry:Xc, 
	SphereBufferGeometry:Fb, SphereGeometry:Yc, RingGeometry:Zc, RingBufferGeometry:lc, PlaneBufferGeometry:Ra, PlaneGeometry:$c, LatheGeometry:ad, LatheBufferGeometry:mc, ShapeGeometry:oc, ShapeBufferGeometry:nc, ExtrudeGeometry:eb, EdgesGeometry:pc, ConeGeometry:bd, ConeBufferGeometry:cd, CylinderGeometry:Gb, CylinderBufferGeometry:ub, CircleBufferGeometry:qc, CircleGeometry:dd, BoxBufferGeometry:mb, BoxGeometry:rc});
	sc.prototype = Object.create(ua.prototype);
	sc.prototype.constructor = sc;
	sc.prototype.isShadowMaterial = !0;
	tc.prototype = Object.create(ua.prototype);
	tc.prototype.constructor = tc;
	tc.prototype.isRawShaderMaterial = !0;
	ed.prototype = {constructor:ed, isMultiMaterial:!0, toJSON:function(d) {
		for (var a = {metadata:{version:4.2, type:"material", generator:"MaterialExporter"}, uuid:this.uuid, type:this.type, materials:[]}, b = this.materials, c = 0, e = b.length;c < e;c++) {
			var g = b[c].toJSON(d);
			delete g.metadata;
			a.materials.push(g);
		}
		a.visible = this.visible;
		return a;
	}, clone:function() {
		for (var d = new this.constructor, a = 0;a < this.materials.length;a++) {
			d.materials.push(this.materials[a].clone());
		}
		d.visible = this.visible;
		return d;
	}};
	ob.prototype = Object.create(Z.prototype);
	ob.prototype.constructor = ob;
	ob.prototype.isMeshStandardMaterial = !0;
	ob.prototype.copy = function(d) {
		Z.prototype.copy.call(this, d);
		this.defines = {STANDARD:""};
		this.color.copy(d.color);
		this.roughness = d.roughness;
		this.metalness = d.metalness;
		this.map = d.map;
		this.lightMap = d.lightMap;
		this.lightMapIntensity = d.lightMapIntensity;
		this.aoMap = d.aoMap;
		this.aoMapIntensity = d.aoMapIntensity;
		this.emissive.copy(d.emissive);
		this.emissiveMap = d.emissiveMap;
		this.emissiveIntensity = d.emissiveIntensity;
		this.bumpMap = d.bumpMap;
		this.bumpScale = d.bumpScale;
		this.normalMap = d.normalMap;
		this.normalScale.copy(d.normalScale);
		this.displacementMap = d.displacementMap;
		this.displacementScale = d.displacementScale;
		this.displacementBias = d.displacementBias;
		this.roughnessMap = d.roughnessMap;
		this.metalnessMap = d.metalnessMap;
		this.alphaMap = d.alphaMap;
		this.envMap = d.envMap;
		this.envMapIntensity = d.envMapIntensity;
		this.refractionRatio = d.refractionRatio;
		this.wireframe = d.wireframe;
		this.wireframeLinewidth = d.wireframeLinewidth;
		this.wireframeLinecap = d.wireframeLinecap;
		this.wireframeLinejoin = d.wireframeLinejoin;
		this.skinning = d.skinning;
		this.morphTargets = d.morphTargets;
		this.morphNormals = d.morphNormals;
		return this;
	};
	Hb.prototype = Object.create(ob.prototype);
	Hb.prototype.constructor = Hb;
	Hb.prototype.isMeshPhysicalMaterial = !0;
	Hb.prototype.copy = function(d) {
		ob.prototype.copy.call(this, d);
		this.defines = {PHYSICAL:""};
		this.reflectivity = d.reflectivity;
		this.clearCoat = d.clearCoat;
		this.clearCoatRoughness = d.clearCoatRoughness;
		return this;
	};
	hb.prototype = Object.create(Z.prototype);
	hb.prototype.constructor = hb;
	hb.prototype.isMeshPhongMaterial = !0;
	hb.prototype.copy = function(d) {
		Z.prototype.copy.call(this, d);
		this.color.copy(d.color);
		this.specular.copy(d.specular);
		this.shininess = d.shininess;
		this.map = d.map;
		this.lightMap = d.lightMap;
		this.lightMapIntensity = d.lightMapIntensity;
		this.aoMap = d.aoMap;
		this.aoMapIntensity = d.aoMapIntensity;
		this.emissive.copy(d.emissive);
		this.emissiveMap = d.emissiveMap;
		this.emissiveIntensity = d.emissiveIntensity;
		this.bumpMap = d.bumpMap;
		this.bumpScale = d.bumpScale;
		this.normalMap = d.normalMap;
		this.normalScale.copy(d.normalScale);
		this.displacementMap = d.displacementMap;
		this.displacementScale = d.displacementScale;
		this.displacementBias = d.displacementBias;
		this.specularMap = d.specularMap;
		this.alphaMap = d.alphaMap;
		this.envMap = d.envMap;
		this.combine = d.combine;
		this.reflectivity = d.reflectivity;
		this.refractionRatio = d.refractionRatio;
		this.wireframe = d.wireframe;
		this.wireframeLinewidth = d.wireframeLinewidth;
		this.wireframeLinecap = d.wireframeLinecap;
		this.wireframeLinejoin = d.wireframeLinejoin;
		this.skinning = d.skinning;
		this.morphTargets = d.morphTargets;
		this.morphNormals = d.morphNormals;
		return this;
	};
	Ib.prototype = Object.create(hb.prototype);
	Ib.prototype.constructor = Ib;
	Ib.prototype.isMeshToonMaterial = !0;
	Ib.prototype.copy = function(d) {
		hb.prototype.copy.call(this, d);
		this.gradientMap = d.gradientMap;
		return this;
	};
	Jb.prototype = Object.create(Z.prototype);
	Jb.prototype.constructor = Jb;
	Jb.prototype.isMeshNormalMaterial = !0;
	Jb.prototype.copy = function(d) {
		Z.prototype.copy.call(this, d);
		this.wireframe = d.wireframe;
		this.wireframeLinewidth = d.wireframeLinewidth;
		return this;
	};
	Kb.prototype = Object.create(Z.prototype);
	Kb.prototype.constructor = Kb;
	Kb.prototype.isMeshLambertMaterial = !0;
	Kb.prototype.copy = function(d) {
		Z.prototype.copy.call(this, d);
		this.color.copy(d.color);
		this.map = d.map;
		this.lightMap = d.lightMap;
		this.lightMapIntensity = d.lightMapIntensity;
		this.aoMap = d.aoMap;
		this.aoMapIntensity = d.aoMapIntensity;
		this.emissive.copy(d.emissive);
		this.emissiveMap = d.emissiveMap;
		this.emissiveIntensity = d.emissiveIntensity;
		this.specularMap = d.specularMap;
		this.alphaMap = d.alphaMap;
		this.envMap = d.envMap;
		this.combine = d.combine;
		this.reflectivity = d.reflectivity;
		this.refractionRatio = d.refractionRatio;
		this.wireframe = d.wireframe;
		this.wireframeLinewidth = d.wireframeLinewidth;
		this.wireframeLinecap = d.wireframeLinecap;
		this.wireframeLinejoin = d.wireframeLinejoin;
		this.skinning = d.skinning;
		this.morphTargets = d.morphTargets;
		this.morphNormals = d.morphNormals;
		return this;
	};
	Lb.prototype = Object.create(Z.prototype);
	Lb.prototype.constructor = Lb;
	Lb.prototype.isLineDashedMaterial = !0;
	Lb.prototype.copy = function(d) {
		Z.prototype.copy.call(this, d);
		this.color.copy(d.color);
		this.linewidth = d.linewidth;
		this.scale = d.scale;
		this.dashSize = d.dashSize;
		this.gapSize = d.gapSize;
		return this;
	};
	var df = Object.freeze({ShadowMaterial:sc, SpriteMaterial:Db, RawShaderMaterial:tc, ShaderMaterial:ua, PointsMaterial:gb, MultiMaterial:ed, MeshPhysicalMaterial:Hb, MeshStandardMaterial:ob, MeshPhongMaterial:hb, MeshToonMaterial:Ib, MeshNormalMaterial:Jb, MeshLambertMaterial:Kb, MeshDepthMaterial:sa, MeshBasicMaterial:La, LineDashedMaterial:Lb, LineBasicMaterial:za, Material:Z}), we = {enabled:!1, files:{}, add:function(d, a) {
		!1 !== this.enabled && (this.files[d] = a);
	}, get:function(d) {
		if (!1 !== this.enabled) {
			return this.files[d];
		}
	}, remove:function(d) {
		delete this.files[d];
	}, clear:function() {
		this.files = {};
	}}, $a = new Zd;
	Object.assign(fb.prototype, {load:function(d, a, b, c) {
		void 0 === d && (d = "");
		void 0 !== this.path && (d = this.path + d);
		var e = this, n = we.get(d);
		if (void 0 !== n) {
			return e.manager.itemStart(d), setTimeout(function() {
				a && a(n);
				e.manager.itemEnd(d);
			}, 0), n;
		}
		var g = d.match(/^data:(.*?)(;base64)?,(.*)$/);
		if (g) {
			var m = g[1], h = !!g[2], g = g[3], g = window.decodeURIComponent(g);
			h && (g = window.atob(g));
			try {
				var k, q = (this.responseType || "").toLowerCase();
				switch(q) {
					case "arraybuffer":
					;
					case "blob":
						k = new ArrayBuffer(g.length);
						for (var f = new Uint8Array(k), h = 0;h < g.length;h++) {
							f[h] = g.charCodeAt(h);
						}
						"blob" === q && (k = new Blob([k], {type:m}));
						break;
					case "document":
						k = (new DOMParser).parseFromString(g, m);
						break;
					case "json":
						k = JSON.parse(g);
						break;
					default:
						k = g;
				}
				window.setTimeout(function() {
					a && a(k);
					e.manager.itemEnd(d);
				}, 0);
			} catch (Ne) {
				window.setTimeout(function() {
					c && c(Ne);
					e.manager.itemError(d);
				}, 0);
			}
		} else {
			var p = new XMLHttpRequest;
			p.open("GET", d, !0);
			p.addEventListener("load", function(b) {
				var n = b.target.response;
				we.add(d, n);
				200 === this.status ? (a && a(n), e.manager.itemEnd(d)) : 0 === this.status ? (console.warn("THREE.FileLoader: HTTP Status 0 received."), a && a(n), e.manager.itemEnd(d)) : (c && c(b), e.manager.itemError(d));
			}, !1);
			void 0 !== b && p.addEventListener("progress", function(d) {
				b(d);
			}, !1);
			p.addEventListener("error", function(a) {
				c && c(a);
				e.manager.itemError(d);
			}, !1);
			void 0 !== this.responseType && (p.responseType = this.responseType);
			void 0 !== this.withCredentials && (p.withCredentials = this.withCredentials);
			p.overrideMimeType && p.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
			p.send(null);
		}
		e.manager.itemStart(d);
		return p;
	}, setPath:function(d) {
		this.path = d;
		return this;
	}, setResponseType:function(d) {
		this.responseType = d;
		return this;
	}, setWithCredentials:function(d) {
		this.withCredentials = d;
		return this;
	}, setMimeType:function(d) {
		this.mimeType = d;
		return this;
	}});
	Object.assign(Ce.prototype, {load:function(d, a, b, c) {
		function e(e) {
			h.load(d[e], function(d) {
				d = n._parser(d, !0);
				g[e] = {width:d.width, height:d.height, format:d.format, mipmaps:d.mipmaps};
				k += 1;
				6 === k && (1 === d.mipmapCount && (m.minFilter = 1006), m.format = d.format, m.needsUpdate = !0, a && a(m));
			}, b, c);
		}
		var n = this, g = [], m = new cc;
		m.image = g;
		var h = new fb(this.manager);
		h.setPath(this.path);
		h.setResponseType("arraybuffer");
		if (Array.isArray(d)) {
			for (var k = 0, q = 0, f = d.length;q < f;++q) {
				e(q);
			}
		} else {
			h.load(d, function(d) {
				d = n._parser(d, !0);
				if (d.isCubemap) {
					for (var b = d.mipmaps.length / d.mipmapCount, c = 0;c < b;c++) {
						g[c] = {mipmaps:[]};
						for (var e = 0;e < d.mipmapCount;e++) {
							g[c].mipmaps.push(d.mipmaps[c * d.mipmapCount + e]), g[c].format = d.format, g[c].width = d.width, g[c].height = d.height;
						}
					}
				} else {
					m.image.width = d.width, m.image.height = d.height, m.mipmaps = d.mipmaps;
				}
				1 === d.mipmapCount && (m.minFilter = 1006);
				m.format = d.format;
				m.needsUpdate = !0;
				a && a(m);
			}, b, c);
		}
		return m;
	}, setPath:function(d) {
		this.path = d;
		return this;
	}});
	Object.assign($d.prototype, {load:function(d, a, b, c) {
		var e = this, n = new pa, g = new fb(this.manager);
		g.setResponseType("arraybuffer");
		g.load(d, function(d) {
			if (d = e._parser(d)) {
				void 0 !== d.image ? n.image = d.image : void 0 !== d.data && (n.image.width = d.width, n.image.height = d.height, n.image.data = d.data), n.wrapS = void 0 !== d.wrapS ? d.wrapS : 1001, n.wrapT = void 0 !== d.wrapT ? d.wrapT : 1001, n.magFilter = void 0 !== d.magFilter ? d.magFilter : 1006, n.minFilter = void 0 !== d.minFilter ? d.minFilter : 1008, n.anisotropy = void 0 !== d.anisotropy ? d.anisotropy : 1, void 0 !== d.format && (n.format = d.format), void 0 !== d.type && (n.type = d.type), 
				void 0 !== d.mipmaps && (n.mipmaps = d.mipmaps), 1 === d.mipmapCount && (n.minFilter = 1006), n.needsUpdate = !0, a && a(n, d);
			}
		}, b, c);
		return n;
	}});
	Object.assign(fd.prototype, {load:function(d, a, b, c) {
		var e = this, n = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
		n.onload = function() {
			n.onload = null;
			URL.revokeObjectURL(n.src);
			a && a(n);
			e.manager.itemEnd(d);
		};
		n.onerror = c;
		if (0 === d.indexOf("data:")) {
			n.src = d;
		} else {
			if (void 0 !== this.crossOrigin) {
				n.crossOrigin = this.crossOrigin, n.src = d;
			} else {
				var g = new fb;
				g.setPath(this.path);
				g.setResponseType("blob");
				g.setWithCredentials(this.withCredentials);
				g.load(d, function(d) {
					n.src = URL.createObjectURL(d);
				}, b, c);
			}
		}
		e.manager.itemStart(d);
		return n;
	}, setCrossOrigin:function(d) {
		this.crossOrigin = d;
		return this;
	}, setWithCredentials:function(d) {
		this.withCredentials = d;
		return this;
	}, setPath:function(d) {
		this.path = d;
		return this;
	}});
	Object.assign(ae.prototype, {load:function(d, a, b, c) {
		function e(b) {
			g.load(d[b], function(d) {
				n.images[b] = d;
				m++;
				6 === m && (n.needsUpdate = !0, a && a(n));
			}, void 0, c);
		}
		var n = new r, g = new fd(this.manager);
		g.setCrossOrigin(this.crossOrigin);
		g.setPath(this.path);
		var m = 0;
		for (b = 0;b < d.length;++b) {
			e(b);
		}
		return n;
	}, setCrossOrigin:function(d) {
		this.crossOrigin = d;
		return this;
	}, setPath:function(d) {
		this.path = d;
		return this;
	}});
	Object.assign(yd.prototype, {load:function(d, a, c, e) {
		var n = new b, g = new fd(this.manager);
		g.setCrossOrigin(this.crossOrigin);
		g.setWithCredentials(this.withCredentials);
		g.setPath(this.path);
		g.load(d, function(b) {
			var c = 0 < d.search(/\.(jpg|jpeg)$/) || 0 === d.search(/^data\:image\/jpeg/);
			n.format = c ? 1022 : 1023;
			n.image = b;
			n.needsUpdate = !0;
			void 0 !== a && a(n);
		}, c, e);
		return n;
	}, setCrossOrigin:function(d) {
		this.crossOrigin = d;
		return this;
	}, setWithCredentials:function(d) {
		this.withCredentials = d;
		return this;
	}, setPath:function(d) {
		this.path = d;
		return this;
	}});
	Aa.prototype = Object.assign(Object.create(X.prototype), {constructor:Aa, isLight:!0, copy:function(d) {
		X.prototype.copy.call(this, d);
		this.color.copy(d.color);
		this.intensity = d.intensity;
		return this;
	}, toJSON:function(d) {
		d = X.prototype.toJSON.call(this, d);
		d.object.color = this.color.getHex();
		d.object.intensity = this.intensity;
		void 0 !== this.groundColor && (d.object.groundColor = this.groundColor.getHex());
		void 0 !== this.distance && (d.object.distance = this.distance);
		void 0 !== this.angle && (d.object.angle = this.angle);
		void 0 !== this.decay && (d.object.decay = this.decay);
		void 0 !== this.penumbra && (d.object.penumbra = this.penumbra);
		void 0 !== this.shadow && (d.object.shadow = this.shadow.toJSON());
		return d;
	}});
	zd.prototype = Object.assign(Object.create(Aa.prototype), {constructor:zd, isHemisphereLight:!0, copy:function(d) {
		Aa.prototype.copy.call(this, d);
		this.groundColor.copy(d.groundColor);
		return this;
	}});
	Object.assign(Mb.prototype, {copy:function(d) {
		this.camera = d.camera.clone();
		this.bias = d.bias;
		this.radius = d.radius;
		this.mapSize.copy(d.mapSize);
		return this;
	}, clone:function() {
		return (new this.constructor).copy(this);
	}, toJSON:function() {
		var d = {};
		0 !== this.bias && (d.bias = this.bias);
		1 !== this.radius && (d.radius = this.radius);
		if (512 !== this.mapSize.x || 512 !== this.mapSize.y) {
			d.mapSize = this.mapSize.toArray();
		}
		d.camera = this.camera.toJSON(!1).object;
		delete d.camera.matrix;
		return d;
	}});
	Ad.prototype = Object.assign(Object.create(Mb.prototype), {constructor:Ad, isSpotLightShadow:!0, update:function(d) {
		var a = 2 * da.RAD2DEG * d.angle, b = this.mapSize.width / this.mapSize.height;
		d = d.distance || 500;
		var c = this.camera;
		if (a !== c.fov || b !== c.aspect || d !== c.far) {
			c.fov = a, c.aspect = b, c.far = d, c.updateProjectionMatrix();
		}
	}});
	Bd.prototype = Object.assign(Object.create(Aa.prototype), {constructor:Bd, isSpotLight:!0, copy:function(d) {
		Aa.prototype.copy.call(this, d);
		this.distance = d.distance;
		this.angle = d.angle;
		this.penumbra = d.penumbra;
		this.decay = d.decay;
		this.target = d.target.clone();
		this.shadow = d.shadow.clone();
		return this;
	}});
	Cd.prototype = Object.assign(Object.create(Aa.prototype), {constructor:Cd, isPointLight:!0, copy:function(d) {
		Aa.prototype.copy.call(this, d);
		this.distance = d.distance;
		this.decay = d.decay;
		this.shadow = d.shadow.clone();
		return this;
	}});
	Dd.prototype = Object.assign(Object.create(Mb.prototype), {constructor:Dd});
	Ed.prototype = Object.assign(Object.create(Aa.prototype), {constructor:Ed, isDirectionalLight:!0, copy:function(d) {
		Aa.prototype.copy.call(this, d);
		this.target = d.target.clone();
		this.shadow = d.shadow.clone();
		return this;
	}});
	Fd.prototype = Object.assign(Object.create(Aa.prototype), {constructor:Fd, isAmbientLight:!0});
	var Ma = {arraySlice:function(d, a, b) {
		return Ma.isTypedArray(d) ? new d.constructor(d.subarray(a, b)) : d.slice(a, b);
	}, convertArray:function(d, a, b) {
		return !d || !b && d.constructor === a ? d : "number" === typeof a.BYTES_PER_ELEMENT ? new a(d) : Array.prototype.slice.call(d);
	}, isTypedArray:function(d) {
		return ArrayBuffer.isView(d) && !(d instanceof DataView);
	}, getKeyframeOrder:function(d) {
		for (var a = d.length, b = Array(a), c = 0;c !== a;++c) {
			b[c] = c;
		}
		b.sort(function(a, b) {
			return d[a] - d[b];
		});
		return b;
	}, sortedArray:function(d, a, b) {
		for (var c = d.length, e = new d.constructor(c), n = 0, g = 0;g !== c;++n) {
			for (var m = b[n] * a, h = 0;h !== a;++h) {
				e[g++] = d[m + h];
			}
		}
		return e;
	}, flattenJSON:function(d, a, b, c) {
		for (var e = 1, n = d[0];void 0 !== n && void 0 === n[c];) {
			n = d[e++];
		}
		if (void 0 !== n) {
			var g = n[c];
			if (void 0 !== g) {
				if (Array.isArray(g)) {
					do {
						g = n[c], void 0 !== g && (a.push(n.time), b.push.apply(b, g)), n = d[e++];
					} while (void 0 !== n);
				} else {
					if (void 0 !== g.toArray) {
						do {
							g = n[c], void 0 !== g && (a.push(n.time), g.toArray(b, b.length)), n = d[e++];
						} while (void 0 !== n);
					} else {
						do {
							g = n[c], void 0 !== g && (a.push(n.time), b.push(g)), n = d[e++];
						} while (void 0 !== n);
					}
				}
			}
		}
	}};
	Xa.prototype = {constructor:Xa, evaluate:function(d) {
		var a = this.parameterPositions, b = this._cachedIndex, c = a[b], e = a[b - 1];
		a: {
			b: {
				c: {
					d: {
						if (!(d < c)) {
							for (var g = b + 2;;) {
								if (void 0 === c) {
									if (d < e) {
										break d;
									}
									this._cachedIndex = b = a.length;
									return this.afterEnd_(b - 1, d, e);
								}
								if (b === g) {
									break;
								}
								e = c;
								c = a[++b];
								if (d < c) {
									break b;
								}
							}
							c = a.length;
							break c;
						}
					}
					if (d >= e) {
						break a;
					} else {
						g = a[1];
						d < g && (b = 2, e = g);
						for (g = b - 2;;) {
							if (void 0 === e) {
								return this._cachedIndex = 0, this.beforeStart_(0, d, c);
							}
							if (b === g) {
								break;
							}
							c = e;
							e = a[--b - 1];
							if (d >= e) {
								break b;
							}
						}
						c = b;
						b = 0;
					}
				}
				for (;b < c;) {
					e = b + c >>> 1, d < a[e] ? c = e : b = e + 1;
				}
				c = a[b];
				e = a[b - 1];
				if (void 0 === e) {
					return this._cachedIndex = 0, this.beforeStart_(0, d, c);
				}
				if (void 0 === c) {
					return this._cachedIndex = b = a.length, this.afterEnd_(b - 1, e, d);
				}
			}
			this._cachedIndex = b;
			this.intervalChanged_(b, e, c);
		}
		return this.interpolate_(b, e, d, c);
	}, settings:null, DefaultSettings_:{}, getSettings_:function() {
		return this.settings || this.DefaultSettings_;
	}, copySampleValue_:function(d) {
		var a = this.resultBuffer, b = this.sampleValues, c = this.valueSize;
		d *= c;
		for (var e = 0;e !== c;++e) {
			a[e] = b[d + e];
		}
		return a;
	}, interpolate_:function(d, a, b, c) {
		throw Error("call to abstract method");
	}, intervalChanged_:function(d, a, b) {
	}};
	Object.assign(Xa.prototype, {beforeStart_:Xa.prototype.copySampleValue_, afterEnd_:Xa.prototype.copySampleValue_});
	Gd.prototype = Object.assign(Object.create(Xa.prototype), {constructor:Gd, DefaultSettings_:{endingStart:2400, endingEnd:2400}, intervalChanged_:function(d, a, b) {
		var c = this.parameterPositions, e = d - 2, n = d + 1, g = c[e], m = c[n];
		if (void 0 === g) {
			switch(this.getSettings_().endingStart) {
				case 2401:
					e = d;
					g = 2 * a - b;
					break;
				case 2402:
					e = c.length - 2;
					g = a + c[e] - c[e + 1];
					break;
				default:
					e = d, g = b;
			}
		}
		if (void 0 === m) {
			switch(this.getSettings_().endingEnd) {
				case 2401:
					n = d;
					m = 2 * b - a;
					break;
				case 2402:
					n = 1;
					m = b + c[1] - c[0];
					break;
				default:
					n = d - 1, m = a;
			}
		}
		d = .5 * (b - a);
		c = this.valueSize;
		this._weightPrev = d / (a - g);
		this._weightNext = d / (m - b);
		this._offsetPrev = e * c;
		this._offsetNext = n * c;
	}, interpolate_:function(d, a, b, c) {
		var e = this.resultBuffer, n = this.sampleValues, g = this.valueSize;
		d *= g;
		var m = d - g, h = this._offsetPrev, k = this._offsetNext, q = this._weightPrev, f = this._weightNext, p = (b - a) / (c - a);
		b = p * p;
		c = b * p;
		a = -q * c + 2 * q * b - q * p;
		q = (1 + q) * c + (-1.5 - 2 * q) * b + (-.5 + q) * p + 1;
		p = (-1 - f) * c + (1.5 + f) * b + .5 * p;
		f = f * c - f * b;
		for (b = 0;b !== g;++b) {
			e[b] = a * n[h + b] + q * n[m + b] + p * n[d + b] + f * n[k + b];
		}
		return e;
	}});
	gd.prototype = Object.assign(Object.create(Xa.prototype), {constructor:gd, interpolate_:function(d, a, b, c) {
		var e = this.resultBuffer, n = this.sampleValues, g = this.valueSize;
		d *= g;
		var m = d - g;
		a = (b - a) / (c - a);
		b = 1 - a;
		for (c = 0;c !== g;++c) {
			e[c] = n[m + c] * b + n[d + c] * a;
		}
		return e;
	}});
	Hd.prototype = Object.assign(Object.create(Xa.prototype), {constructor:Hd, interpolate_:function(d, a, b, c) {
		return this.copySampleValue_(d - 1);
	}});
	var wb;
	wb = {TimeBufferType:Float32Array, ValueBufferType:Float32Array, DefaultInterpolation:2301, InterpolantFactoryMethodDiscrete:function(d) {
		return new Hd(this.times, this.values, this.getValueSize(), d);
	}, InterpolantFactoryMethodLinear:function(d) {
		return new gd(this.times, this.values, this.getValueSize(), d);
	}, InterpolantFactoryMethodSmooth:function(d) {
		return new Gd(this.times, this.values, this.getValueSize(), d);
	}, setInterpolation:function(d) {
		var a;
		switch(d) {
			case 2300:
				a = this.InterpolantFactoryMethodDiscrete;
				break;
			case 2301:
				a = this.InterpolantFactoryMethodLinear;
				break;
			case 2302:
				a = this.InterpolantFactoryMethodSmooth;
		}
		if (void 0 === a) {
			a = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
			if (void 0 === this.createInterpolant) {
				if (d !== this.DefaultInterpolation) {
					this.setInterpolation(this.DefaultInterpolation);
				} else {
					throw Error(a);
				}
			}
			console.warn(a);
		} else {
			this.createInterpolant = a;
		}
	}, getInterpolation:function() {
		switch(this.createInterpolant) {
			case this.InterpolantFactoryMethodDiscrete:
				return 2300;
			case this.InterpolantFactoryMethodLinear:
				return 2301;
			case this.InterpolantFactoryMethodSmooth:
				return 2302;
		}
	}, getValueSize:function() {
		return this.values.length / this.times.length;
	}, shift:function(d) {
		if (0 !== d) {
			for (var a = this.times, b = 0, c = a.length;b !== c;++b) {
				a[b] += d;
			}
		}
		return this;
	}, scale:function(d) {
		if (1 !== d) {
			for (var a = this.times, b = 0, c = a.length;b !== c;++b) {
				a[b] *= d;
			}
		}
		return this;
	}, trim:function(d, a) {
		for (var b = this.times, c = b.length, e = 0, n = c - 1;e !== c && b[e] < d;) {
			++e;
		}
		for (;-1 !== n && b[n] > a;) {
			--n;
		}
		++n;
		if (0 !== e || n !== c) {
			e >= n && (n = Math.max(n, 1), e = n - 1), c = this.getValueSize(), this.times = Ma.arraySlice(b, e, n), this.values = Ma.arraySlice(this.values, e * c, n * c);
		}
		return this;
	}, validate:function() {
		var d = !0, a = this.getValueSize();
		0 !== a - Math.floor(a) && (console.error("invalid value size in track", this), d = !1);
		var b = this.times, a = this.values, c = b.length;
		0 === c && (console.error("track is empty", this), d = !1);
		for (var e = null, g = 0;g !== c;g++) {
			var m = b[g];
			if ("number" === typeof m && isNaN(m)) {
				console.error("time is not a valid number", this, g, m);
				d = !1;
				break;
			}
			if (null !== e && e > m) {
				console.error("out of order keys", this, g, m, e);
				d = !1;
				break;
			}
			e = m;
		}
		if (void 0 !== a && Ma.isTypedArray(a)) {
			for (g = 0, b = a.length;g !== b;++g) {
				if (c = a[g], isNaN(c)) {
					console.error("value is not a valid number", this, g, c);
					d = !1;
					break;
				}
			}
		}
		return d;
	}, optimize:function() {
		for (var d = this.times, a = this.values, b = this.getValueSize(), c = 2302 === this.getInterpolation(), e = 1, g = d.length - 1, m = 1;m < g;++m) {
			var h = !1, k = d[m];
			if (k !== d[m + 1] && (1 !== m || k !== k[0])) {
				if (c) {
					h = !0;
				} else {
					for (var q = m * b, f = q - b, p = q + b, k = 0;k !== b;++k) {
						var r = a[q + k];
						if (r !== a[f + k] || r !== a[p + k]) {
							h = !0;
							break;
						}
					}
				}
			}
			if (h) {
				if (m !== e) {
					for (d[e] = d[m], h = m * b, q = e * b, k = 0;k !== b;++k) {
						a[q + k] = a[h + k];
					}
				}
				++e;
			}
		}
		if (0 < g) {
			d[e] = d[g];
			h = g * b;
			q = e * b;
			for (k = 0;k !== b;++k) {
				a[q + k] = a[h + k];
			}
			++e;
		}
		e !== d.length && (this.times = Ma.arraySlice(d, 0, e), this.values = Ma.arraySlice(a, 0, e * b));
		return this;
	}};
	uc.prototype = Object.assign(Object.create(wb), {constructor:uc, ValueTypeName:"vector"});
	Id.prototype = Object.assign(Object.create(Xa.prototype), {constructor:Id, interpolate_:function(d, a, b, c) {
		var n = this.resultBuffer, g = this.sampleValues, m = this.valueSize;
		d *= m;
		a = (b - a) / (c - a);
		for (b = d + m;d !== b;d += 4) {
			e.slerpFlat(n, 0, g, d - m, g, d, a);
		}
		return n;
	}});
	hd.prototype = Object.assign(Object.create(wb), {constructor:hd, ValueTypeName:"quaternion", DefaultInterpolation:2301, InterpolantFactoryMethodLinear:function(d) {
		return new Id(this.times, this.values, this.getValueSize(), d);
	}, InterpolantFactoryMethodSmooth:void 0});
	vc.prototype = Object.assign(Object.create(wb), {constructor:vc, ValueTypeName:"number"});
	Jd.prototype = Object.assign(Object.create(wb), {constructor:Jd, ValueTypeName:"string", ValueBufferType:Array, DefaultInterpolation:2300, InterpolantFactoryMethodLinear:void 0, InterpolantFactoryMethodSmooth:void 0});
	Kd.prototype = Object.assign(Object.create(wb), {constructor:Kd, ValueTypeName:"bool", ValueBufferType:Array, DefaultInterpolation:2300, InterpolantFactoryMethodLinear:void 0, InterpolantFactoryMethodSmooth:void 0});
	Ld.prototype = Object.assign(Object.create(wb), {constructor:Ld, ValueTypeName:"color"});
	Ob.prototype = wb;
	wb.constructor = Ob;
	Object.assign(Ob, {parse:function(d) {
		if (void 0 === d.type) {
			throw Error("track type undefined, can not parse");
		}
		var a = Ob._getTrackTypeForValueTypeName(d.type);
		if (void 0 === d.times) {
			var b = [], c = [];
			Ma.flattenJSON(d.keys, b, c, "value");
			d.times = b;
			d.values = c;
		}
		return void 0 !== a.parse ? a.parse(d) : new a(d.name, d.times, d.values, d.interpolation);
	}, toJSON:function(d) {
		var a = d.constructor;
		if (void 0 !== a.toJSON) {
			a = a.toJSON(d);
		} else {
			var a = {name:d.name, times:Ma.convertArray(d.times, Array), values:Ma.convertArray(d.values, Array)}, b = d.getInterpolation();
			b !== d.DefaultInterpolation && (a.interpolation = b);
		}
		a.type = d.ValueTypeName;
		return a;
	}, _getTrackTypeForValueTypeName:function(d) {
		switch(d.toLowerCase()) {
			case "scalar":
			;
			case "double":
			;
			case "float":
			;
			case "number":
			;
			case "integer":
				return vc;
			case "vector":
			;
			case "vector2":
			;
			case "vector3":
			;
			case "vector4":
				return uc;
			case "color":
				return Ld;
			case "quaternion":
				return hd;
			case "bool":
			;
			case "boolean":
				return Kd;
			case "string":
				return Jd;
		}
		throw Error("Unsupported typeName: " + d);
	}});
	ab.prototype = {constructor:ab, resetDuration:function() {
		for (var d = 0, a = 0, b = this.tracks.length;a !== b;++a) {
			var c = this.tracks[a], d = Math.max(d, c.times[c.times.length - 1])
		}
		this.duration = d;
	}, trim:function() {
		for (var d = 0;d < this.tracks.length;d++) {
			this.tracks[d].trim(0, this.duration);
		}
		return this;
	}, optimize:function() {
		for (var d = 0;d < this.tracks.length;d++) {
			this.tracks[d].optimize();
		}
		return this;
	}};
	Object.assign(ab, {parse:function(d) {
		for (var a = [], b = d.tracks, c = 1 / (d.fps || 1), e = 0, g = b.length;e !== g;++e) {
			a.push(Ob.parse(b[e]).scale(c));
		}
		return new ab(d.name, d.duration, a);
	}, toJSON:function(d) {
		var a = [], b = d.tracks;
		d = {name:d.name, duration:d.duration, tracks:a};
		for (var c = 0, e = b.length;c !== e;++c) {
			a.push(Ob.toJSON(b[c]));
		}
		return d;
	}, CreateFromMorphTargetSequence:function(d, a, b, c) {
		for (var e = a.length, g = [], n = 0;n < e;n++) {
			var m = [], h = [];
			m.push((n + e - 1) % e, n, (n + 1) % e);
			h.push(0, 1, 0);
			var k = Ma.getKeyframeOrder(m), m = Ma.sortedArray(m, 1, k), h = Ma.sortedArray(h, 1, k);
			c || 0 !== m[0] || (m.push(e), h.push(h[0]));
			g.push((new vc(".morphTargetInfluences[" + a[n].name + "]", m, h)).scale(1 / b));
		}
		return new ab(d, -1, g);
	}, findByName:function(d, a) {
		var b = d;
		Array.isArray(d) || (b = d.geometry && d.geometry.animations || d.animations);
		for (d = 0;d < b.length;d++) {
			if (b[d].name === a) {
				return b[d];
			}
		}
		return null;
	}, CreateClipsFromMorphTargetSequences:function(d, a, b) {
		for (var c = {}, e = /^([\w-]*?)([\d]+)$/, g = 0, n = d.length;g < n;g++) {
			var m = d[g], h = m.name.match(e);
			if (h && 1 < h.length) {
				var k = h[1];
				(h = c[k]) || (c[k] = h = []);
				h.push(m);
			}
		}
		d = [];
		for (k in c) {
			d.push(ab.CreateFromMorphTargetSequence(k, c[k], a, b));
		}
		return d;
	}, parseAnimation:function(d, a) {
		if (!d) {
			return console.error("  no animation in JSONLoader data"), null;
		}
		var b = function(d, a, b, c, e) {
			if (0 !== b.length) {
				var g = [], n = [];
				Ma.flattenJSON(b, g, n, c);
				0 !== g.length && e.push(new d(a, g, n));
			}
		}, c = [], e = d.name || "default", g = d.length || -1, n = d.fps || 30;
		d = d.hierarchy || [];
		for (var m = 0;m < d.length;m++) {
			var h = d[m].keys;
			if (h && 0 !== h.length) {
				if (h[0].morphTargets) {
					for (var g = {}, k = 0;k < h.length;k++) {
						if (h[k].morphTargets) {
							for (var q = 0;q < h[k].morphTargets.length;q++) {
								g[h[k].morphTargets[q]] = -1;
							}
						}
					}
					for (var f in g) {
						for (var p = [], r = [], q = 0;q !== h[k].morphTargets.length;++q) {
							var u = h[k];
							p.push(u.time);
							r.push(u.morphTarget === f ? 1 : 0);
						}
						c.push(new vc(".morphTargetInfluence[" + f + "]", p, r));
					}
					g = g.length * (n || 1);
				} else {
					k = ".bones[" + a[m].name + "]", b(uc, k + ".position", h, "pos", c), b(hd, k + ".quaternion", h, "rot", c), b(uc, k + ".scale", h, "scl", c);
				}
			}
		}
		return 0 === c.length ? null : new ab(e, g, c);
	}});
	Object.assign(Md.prototype, {load:function(d, a, b, c) {
		var e = this;
		(new fb(e.manager)).load(d, function(d) {
			a(e.parse(JSON.parse(d)));
		}, b, c);
	}, setTextures:function(d) {
		this.textures = d;
	}, parse:function(d) {
		function a(d) {
			void 0 === b[d] && console.warn("THREE.MaterialLoader: Undefined texture", d);
			return b[d];
		}
		var b = this.textures, c = new df[d.type];
		void 0 !== d.uuid && (c.uuid = d.uuid);
		void 0 !== d.name && (c.name = d.name);
		void 0 !== d.color && c.color.setHex(d.color);
		void 0 !== d.roughness && (c.roughness = d.roughness);
		void 0 !== d.metalness && (c.metalness = d.metalness);
		void 0 !== d.emissive && c.emissive.setHex(d.emissive);
		void 0 !== d.specular && c.specular.setHex(d.specular);
		void 0 !== d.shininess && (c.shininess = d.shininess);
		void 0 !== d.clearCoat && (c.clearCoat = d.clearCoat);
		void 0 !== d.clearCoatRoughness && (c.clearCoatRoughness = d.clearCoatRoughness);
		void 0 !== d.uniforms && (c.uniforms = d.uniforms);
		void 0 !== d.vertexShader && (c.vertexShader = d.vertexShader);
		void 0 !== d.fragmentShader && (c.fragmentShader = d.fragmentShader);
		void 0 !== d.vertexColors && (c.vertexColors = d.vertexColors);
		void 0 !== d.fog && (c.fog = d.fog);
		void 0 !== d.shading && (c.shading = d.shading);
		void 0 !== d.blending && (c.blending = d.blending);
		void 0 !== d.side && (c.side = d.side);
		void 0 !== d.opacity && (c.opacity = d.opacity);
		void 0 !== d.transparent && (c.transparent = d.transparent);
		void 0 !== d.alphaTest && (c.alphaTest = d.alphaTest);
		void 0 !== d.depthTest && (c.depthTest = d.depthTest);
		void 0 !== d.depthWrite && (c.depthWrite = d.depthWrite);
		void 0 !== d.colorWrite && (c.colorWrite = d.colorWrite);
		void 0 !== d.wireframe && (c.wireframe = d.wireframe);
		void 0 !== d.wireframeLinewidth && (c.wireframeLinewidth = d.wireframeLinewidth);
		void 0 !== d.wireframeLinecap && (c.wireframeLinecap = d.wireframeLinecap);
		void 0 !== d.wireframeLinejoin && (c.wireframeLinejoin = d.wireframeLinejoin);
		void 0 !== d.skinning && (c.skinning = d.skinning);
		void 0 !== d.morphTargets && (c.morphTargets = d.morphTargets);
		void 0 !== d.size && (c.size = d.size);
		void 0 !== d.sizeAttenuation && (c.sizeAttenuation = d.sizeAttenuation);
		void 0 !== d.map && (c.map = a(d.map));
		void 0 !== d.alphaMap && (c.alphaMap = a(d.alphaMap), c.transparent = !0);
		void 0 !== d.bumpMap && (c.bumpMap = a(d.bumpMap));
		void 0 !== d.bumpScale && (c.bumpScale = d.bumpScale);
		void 0 !== d.normalMap && (c.normalMap = a(d.normalMap));
		if (void 0 !== d.normalScale) {
			var e = d.normalScale;
			!1 === Array.isArray(e) && (e = [e, e]);
			c.normalScale = (new l).fromArray(e);
		}
		void 0 !== d.displacementMap && (c.displacementMap = a(d.displacementMap));
		void 0 !== d.displacementScale && (c.displacementScale = d.displacementScale);
		void 0 !== d.displacementBias && (c.displacementBias = d.displacementBias);
		void 0 !== d.roughnessMap && (c.roughnessMap = a(d.roughnessMap));
		void 0 !== d.metalnessMap && (c.metalnessMap = a(d.metalnessMap));
		void 0 !== d.emissiveMap && (c.emissiveMap = a(d.emissiveMap));
		void 0 !== d.emissiveIntensity && (c.emissiveIntensity = d.emissiveIntensity);
		void 0 !== d.specularMap && (c.specularMap = a(d.specularMap));
		void 0 !== d.envMap && (c.envMap = a(d.envMap));
		void 0 !== d.reflectivity && (c.reflectivity = d.reflectivity);
		void 0 !== d.lightMap && (c.lightMap = a(d.lightMap));
		void 0 !== d.lightMapIntensity && (c.lightMapIntensity = d.lightMapIntensity);
		void 0 !== d.aoMap && (c.aoMap = a(d.aoMap));
		void 0 !== d.aoMapIntensity && (c.aoMapIntensity = d.aoMapIntensity);
		void 0 !== d.gradientMap && (c.gradientMap = a(d.gradientMap));
		if (void 0 !== d.materials) {
			for (var e = 0, g = d.materials.length;e < g;e++) {
				c.materials.push(this.parse(d.materials[e]));
			}
		}
		return c;
	}});
	Object.assign(be.prototype, {load:function(d, a, b, c) {
		var e = this;
		(new fb(e.manager)).load(d, function(d) {
			a(e.parse(JSON.parse(d)));
		}, b, c);
	}, parse:function(d) {
		var a = new ca, b = d.data.index, c = {Int8Array:Int8Array, Uint8Array:Uint8Array, Uint8ClampedArray:Uint8ClampedArray, Int16Array:Int16Array, Uint16Array:Uint16Array, Int32Array:Int32Array, Uint32Array:Uint32Array, Float32Array:Float32Array, Float64Array:Float64Array};
		void 0 !== b && (b = new c[b.type](b.array), a.setIndex(new U(b, 1)));
		var e = d.data.attributes, m;
		for (m in e) {
			var h = e[m], b = new c[h.type](h.array);
			a.addAttribute(m, new U(b, h.itemSize, h.normalized));
		}
		c = d.data.groups || d.data.drawcalls || d.data.offsets;
		if (void 0 !== c) {
			for (m = 0, b = c.length;m !== b;++m) {
				e = c[m], a.addGroup(e.start, e.count, e.materialIndex);
			}
		}
		d = d.data.boundingSphere;
		void 0 !== d && (c = new g, void 0 !== d.center && c.fromArray(d.center), a.boundingSphere = new Ca(c, d.radius));
		return a;
	}});
	Pb.prototype = {constructor:Pb, crossOrigin:void 0, extractUrlBase:function(d) {
		d = d.split("/");
		if (1 === d.length) {
			return "./";
		}
		d.pop();
		return d.join("/") + "/";
	}, initMaterials:function(d, a, b) {
		for (var c = [], e = 0;e < d.length;++e) {
			c[e] = this.createMaterial(d[e], a, b);
		}
		return c;
	}, createMaterial:function() {
		var d, a, b;
		return function(c, e, g) {
			function n(d, b, c, n, h) {
				d = e + d;
				var k = Pb.Handlers.get(d);
				null !== k ? d = k.load(d) : (a.setCrossOrigin(g), d = a.load(d));
				void 0 !== b && (d.repeat.fromArray(b), 1 !== b[0] && (d.wrapS = 1E3), 1 !== b[1] && (d.wrapT = 1E3));
				void 0 !== c && d.offset.fromArray(c);
				void 0 !== n && ("repeat" === n[0] && (d.wrapS = 1E3), "mirror" === n[0] && (d.wrapS = 1002), "repeat" === n[1] && (d.wrapT = 1E3), "mirror" === n[1] && (d.wrapT = 1002));
				void 0 !== h && (d.anisotropy = h);
				b = da.generateUUID();
				m[b] = d;
				return b;
			}
			void 0 === d && (d = new T);
			void 0 === a && (a = new yd);
			void 0 === b && (b = new Md);
			var m = {}, h = {uuid:da.generateUUID(), type:"MeshLambertMaterial"}, k;
			for (k in c) {
				var q = c[k];
				switch(k) {
					case "DbgColor":
					;
					case "DbgIndex":
					;
					case "opticalDensity":
					;
					case "illumination":
						break;
					case "DbgName":
						h.name = q;
						break;
					case "blending":
						h.blending = Ke[q];
						break;
					case "colorAmbient":
					;
					case "mapAmbient":
						console.warn("THREE.Loader.createMaterial:", k, "is no longer supported.");
						break;
					case "colorDiffuse":
						h.color = d.fromArray(q).getHex();
						break;
					case "colorSpecular":
						h.specular = d.fromArray(q).getHex();
						break;
					case "colorEmissive":
						h.emissive = d.fromArray(q).getHex();
						break;
					case "specularCoef":
						h.shininess = q;
						break;
					case "shading":
						"basic" === q.toLowerCase() && (h.type = "MeshBasicMaterial");
						"phong" === q.toLowerCase() && (h.type = "MeshPhongMaterial");
						"standard" === q.toLowerCase() && (h.type = "MeshStandardMaterial");
						break;
					case "mapDiffuse":
						h.map = n(q, c.mapDiffuseRepeat, c.mapDiffuseOffset, c.mapDiffuseWrap, c.mapDiffuseAnisotropy);
						break;
					case "mapDiffuseRepeat":
					;
					case "mapDiffuseOffset":
					;
					case "mapDiffuseWrap":
					;
					case "mapDiffuseAnisotropy":
						break;
					case "mapEmissive":
						h.emissiveMap = n(q, c.mapEmissiveRepeat, c.mapEmissiveOffset, c.mapEmissiveWrap, c.mapEmissiveAnisotropy);
						break;
					case "mapEmissiveRepeat":
					;
					case "mapEmissiveOffset":
					;
					case "mapEmissiveWrap":
					;
					case "mapEmissiveAnisotropy":
						break;
					case "mapLight":
						h.lightMap = n(q, c.mapLightRepeat, c.mapLightOffset, c.mapLightWrap, c.mapLightAnisotropy);
						break;
					case "mapLightRepeat":
					;
					case "mapLightOffset":
					;
					case "mapLightWrap":
					;
					case "mapLightAnisotropy":
						break;
					case "mapAO":
						h.aoMap = n(q, c.mapAORepeat, c.mapAOOffset, c.mapAOWrap, c.mapAOAnisotropy);
						break;
					case "mapAORepeat":
					;
					case "mapAOOffset":
					;
					case "mapAOWrap":
					;
					case "mapAOAnisotropy":
						break;
					case "mapBump":
						h.bumpMap = n(q, c.mapBumpRepeat, c.mapBumpOffset, c.mapBumpWrap, c.mapBumpAnisotropy);
						break;
					case "mapBumpScale":
						h.bumpScale = q;
						break;
					case "mapBumpRepeat":
					;
					case "mapBumpOffset":
					;
					case "mapBumpWrap":
					;
					case "mapBumpAnisotropy":
						break;
					case "mapNormal":
						h.normalMap = n(q, c.mapNormalRepeat, c.mapNormalOffset, c.mapNormalWrap, c.mapNormalAnisotropy);
						break;
					case "mapNormalFactor":
						h.normalScale = [q, q];
						break;
					case "mapNormalRepeat":
					;
					case "mapNormalOffset":
					;
					case "mapNormalWrap":
					;
					case "mapNormalAnisotropy":
						break;
					case "mapSpecular":
						h.specularMap = n(q, c.mapSpecularRepeat, c.mapSpecularOffset, c.mapSpecularWrap, c.mapSpecularAnisotropy);
						break;
					case "mapSpecularRepeat":
					;
					case "mapSpecularOffset":
					;
					case "mapSpecularWrap":
					;
					case "mapSpecularAnisotropy":
						break;
					case "mapMetalness":
						h.metalnessMap = n(q, c.mapMetalnessRepeat, c.mapMetalnessOffset, c.mapMetalnessWrap, c.mapMetalnessAnisotropy);
						break;
					case "mapMetalnessRepeat":
					;
					case "mapMetalnessOffset":
					;
					case "mapMetalnessWrap":
					;
					case "mapMetalnessAnisotropy":
						break;
					case "mapRoughness":
						h.roughnessMap = n(q, c.mapRoughnessRepeat, c.mapRoughnessOffset, c.mapRoughnessWrap, c.mapRoughnessAnisotropy);
						break;
					case "mapRoughnessRepeat":
					;
					case "mapRoughnessOffset":
					;
					case "mapRoughnessWrap":
					;
					case "mapRoughnessAnisotropy":
						break;
					case "mapAlpha":
						h.alphaMap = n(q, c.mapAlphaRepeat, c.mapAlphaOffset, c.mapAlphaWrap, c.mapAlphaAnisotropy);
						break;
					case "mapAlphaRepeat":
					;
					case "mapAlphaOffset":
					;
					case "mapAlphaWrap":
					;
					case "mapAlphaAnisotropy":
						break;
					case "flipSided":
						h.side = 1;
						break;
					case "doubleSided":
						h.side = 2;
						break;
					case "transparency":
						console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
						h.opacity = q;
						break;
					case "depthTest":
					;
					case "depthWrite":
					;
					case "colorWrite":
					;
					case "opacity":
					;
					case "reflectivity":
					;
					case "transparent":
					;
					case "visible":
					;
					case "wireframe":
						h[k] = q;
						break;
					case "vertexColors":
						!0 === q && (h.vertexColors = 2);
						"face" === q && (h.vertexColors = 1);
						break;
					default:
						console.error("THREE.Loader.createMaterial: Unsupported", k, q);
				}
			}
			"MeshBasicMaterial" === h.type && delete h.emissive;
			"MeshPhongMaterial" !== h.type && delete h.specular;
			1 > h.opacity && (h.transparent = !0);
			b.setTextures(m);
			return b.parse(h);
		};
	}()};
	Pb.Handlers = {handlers:[], add:function(d, a) {
		this.handlers.push(d, a);
	}, get:function(d) {
		for (var a = this.handlers, b = 0, c = a.length;b < c;b += 2) {
			var e = a[b + 1];
			if (a[b].test(d)) {
				return e;
			}
		}
		return null;
	}};
	Object.assign(ce.prototype, {load:function(d, a, b, c) {
		var e = this, g = this.texturePath && "string" === typeof this.texturePath ? this.texturePath : Pb.prototype.extractUrlBase(d), n = new fb(this.manager);
		n.setWithCredentials(this.withCredentials);
		n.load(d, function(b) {
			b = JSON.parse(b);
			var c = b.metadata;
			if (void 0 !== c && (c = c.type, void 0 !== c)) {
				if ("object" === c.toLowerCase()) {
					console.error("THREE.JSONLoader: " + d + " should be loaded with THREE.ObjectLoader instead.");
					return;
				}
				if ("scene" === c.toLowerCase()) {
					console.error("THREE.JSONLoader: " + d + " should be loaded with THREE.SceneLoader instead.");
					return;
				}
			}
			b = e.parse(b, g);
			a(b.geometry, b.materials);
		}, b, c);
	}, setTexturePath:function(d) {
		this.texturePath = d;
	}, parse:function(d, a) {
		var b = new ja, c = void 0 !== d.scale ? 1 / d.scale : 1;
		(function(a) {
			var c, e, n, m, h, k, q, f, p, r, u, w, t, v = d.faces;
			k = d.vertices;
			var B = d.normals, y = d.colors, z = 0;
			if (void 0 !== d.uvs) {
				for (c = 0;c < d.uvs.length;c++) {
					d.uvs[c].length && z++;
				}
				for (c = 0;c < z;c++) {
					b.faceVertexUvs[c] = [];
				}
			}
			m = 0;
			for (h = k.length;m < h;) {
				c = new g, c.x = k[m++] * a, c.y = k[m++] * a, c.z = k[m++] * a, b.vertices.push(c);
			}
			m = 0;
			for (h = v.length;m < h;) {
				if (a = v[m++], p = a & 1, n = a & 2, c = a & 8, q = a & 16, r = a & 32, k = a & 64, a &= 128, p) {
					p = new Ja;
					p.a = v[m];
					p.b = v[m + 1];
					p.c = v[m + 3];
					u = new Ja;
					u.a = v[m + 1];
					u.b = v[m + 2];
					u.c = v[m + 3];
					m += 4;
					n && (n = v[m++], p.materialIndex = n, u.materialIndex = n);
					n = b.faces.length;
					if (c) {
						for (c = 0;c < z;c++) {
							for (w = d.uvs[c], b.faceVertexUvs[c][n] = [], b.faceVertexUvs[c][n + 1] = [], e = 0;4 > e;e++) {
								f = v[m++], t = w[2 * f], f = w[2 * f + 1], t = new l(t, f), 2 !== e && b.faceVertexUvs[c][n].push(t), 0 !== e && b.faceVertexUvs[c][n + 1].push(t);
							}
						}
					}
					q && (q = 3 * v[m++], p.normal.set(B[q++], B[q++], B[q]), u.normal.copy(p.normal));
					if (r) {
						for (c = 0;4 > c;c++) {
							q = 3 * v[m++], r = new g(B[q++], B[q++], B[q]), 2 !== c && p.vertexNormals.push(r), 0 !== c && u.vertexNormals.push(r);
						}
					}
					k && (k = v[m++], k = y[k], p.color.setHex(k), u.color.setHex(k));
					if (a) {
						for (c = 0;4 > c;c++) {
							k = v[m++], k = y[k], 2 !== c && p.vertexColors.push(new T(k)), 0 !== c && u.vertexColors.push(new T(k));
						}
					}
					b.faces.push(p);
					b.faces.push(u);
				} else {
					p = new Ja;
					p.a = v[m++];
					p.b = v[m++];
					p.c = v[m++];
					n && (n = v[m++], p.materialIndex = n);
					n = b.faces.length;
					if (c) {
						for (c = 0;c < z;c++) {
							for (w = d.uvs[c], b.faceVertexUvs[c][n] = [], e = 0;3 > e;e++) {
								f = v[m++], t = w[2 * f], f = w[2 * f + 1], t = new l(t, f), b.faceVertexUvs[c][n].push(t);
							}
						}
					}
					q && (q = 3 * v[m++], p.normal.set(B[q++], B[q++], B[q]));
					if (r) {
						for (c = 0;3 > c;c++) {
							q = 3 * v[m++], r = new g(B[q++], B[q++], B[q]), p.vertexNormals.push(r);
						}
					}
					k && (k = v[m++], p.color.setHex(y[k]));
					if (a) {
						for (c = 0;3 > c;c++) {
							k = v[m++], p.vertexColors.push(new T(y[k]));
						}
					}
					b.faces.push(p);
				}
			}
		})(c);
		(function() {
			var a = void 0 !== d.influencesPerVertex ? d.influencesPerVertex : 2;
			if (d.skinWeights) {
				for (var c = 0, e = d.skinWeights.length;c < e;c += a) {
					b.skinWeights.push(new k(d.skinWeights[c], 1 < a ? d.skinWeights[c + 1] : 0, 2 < a ? d.skinWeights[c + 2] : 0, 3 < a ? d.skinWeights[c + 3] : 0));
				}
			}
			if (d.skinIndices) {
				for (c = 0, e = d.skinIndices.length;c < e;c += a) {
					b.skinIndices.push(new k(d.skinIndices[c], 1 < a ? d.skinIndices[c + 1] : 0, 2 < a ? d.skinIndices[c + 2] : 0, 3 < a ? d.skinIndices[c + 3] : 0));
				}
			}
			b.bones = d.bones;
			b.bones && 0 < b.bones.length && (b.skinWeights.length !== b.skinIndices.length || b.skinIndices.length !== b.vertices.length) && console.warn("When skinning, number of vertices (" + b.vertices.length + "), skinIndices (" + b.skinIndices.length + "), and skinWeights (" + b.skinWeights.length + ") should match.");
		})();
		(function(a) {
			if (void 0 !== d.morphTargets) {
				for (var c = 0, e = d.morphTargets.length;c < e;c++) {
					b.morphTargets[c] = {};
					b.morphTargets[c].name = d.morphTargets[c].name;
					b.morphTargets[c].vertices = [];
					for (var n = b.morphTargets[c].vertices, m = d.morphTargets[c].vertices, h = 0, k = m.length;h < k;h += 3) {
						var q = new g;
						q.x = m[h] * a;
						q.y = m[h + 1] * a;
						q.z = m[h + 2] * a;
						n.push(q);
					}
				}
			}
			if (void 0 !== d.morphColors && 0 < d.morphColors.length) {
				for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), a = b.faces, n = d.morphColors[0].colors, c = 0, e = a.length;c < e;c++) {
					a[c].color.fromArray(n, 3 * c);
				}
			}
		})(c);
		(function() {
			var a = [], c = [];
			void 0 !== d.animation && c.push(d.animation);
			void 0 !== d.animations && (d.animations.length ? c = c.concat(d.animations) : c.push(d.animations));
			for (var e = 0;e < c.length;e++) {
				var g = ab.parseAnimation(c[e], b.bones);
				g && a.push(g);
			}
			b.morphTargets && (c = ab.CreateClipsFromMorphTargetSequences(b.morphTargets, 10), a = a.concat(c));
			0 < a.length && (b.animations = a);
		})();
		b.computeFaceNormals();
		b.computeBoundingSphere();
		if (void 0 === d.materials || 0 === d.materials.length) {
			return {geometry:b};
		}
		c = Pb.prototype.initMaterials(d.materials, a, this.crossOrigin);
		return {geometry:b, materials:c};
	}});
	Object.assign(De.prototype, {load:function(d, a, b, c) {
		"" === this.texturePath && (this.texturePath = d.substring(0, d.lastIndexOf("/") + 1));
		var e = this;
		(new fb(e.manager)).load(d, function(b) {
			var c = null;
			try {
				c = JSON.parse(b);
			} catch (O) {
				console.error("THREE:ObjectLoader: Can't parse " + d + ".", O.message);
				return;
			}
			b = c.metadata;
			void 0 === b || void 0 === b.type || "geometry" === b.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + d + ". Use THREE.JSONLoader instead.") : e.parse(c, a);
		}, b, c);
	}, setTexturePath:function(d) {
		this.texturePath = d;
	}, setCrossOrigin:function(d) {
		this.crossOrigin = d;
	}, parse:function(d, a) {
		var b = this.parseGeometries(d.geometries), c = this.parseImages(d.images, function() {
			void 0 !== a && a(e);
		}), c = this.parseTextures(d.textures, c), c = this.parseMaterials(d.materials, c), e = this.parseObject(d.object, b, c);
		d.animations && (e.animations = this.parseAnimations(d.animations));
		void 0 !== d.images && 0 !== d.images.length || void 0 === a || a(e);
		return e;
	}, parseGeometries:function(d) {
		var a = {};
		if (void 0 !== d) {
			for (var b = new ce, c = new be, e = 0, g = d.length;e < g;e++) {
				var m, h = d[e];
				switch(h.type) {
					case "PlaneGeometry":
					;
					case "PlaneBufferGeometry":
						m = new ib[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
						break;
					case "BoxGeometry":
					;
					case "BoxBufferGeometry":
					;
					case "CubeGeometry":
						m = new ib[h.type](h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
						break;
					case "CircleGeometry":
					;
					case "CircleBufferGeometry":
						m = new ib[h.type](h.radius, h.segments, h.thetaStart, h.thetaLength);
						break;
					case "CylinderGeometry":
					;
					case "CylinderBufferGeometry":
						m = new ib[h.type](h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
						break;
					case "ConeGeometry":
					;
					case "ConeBufferGeometry":
						m = new ib[h.type](h.radius, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
						break;
					case "SphereGeometry":
					;
					case "SphereBufferGeometry":
						m = new ib[h.type](h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
						break;
					case "DodecahedronGeometry":
					;
					case "IcosahedronGeometry":
					;
					case "OctahedronGeometry":
					;
					case "TetrahedronGeometry":
						m = new ib[h.type](h.radius, h.detail);
						break;
					case "RingGeometry":
					;
					case "RingBufferGeometry":
						m = new ib[h.type](h.innerRadius, h.outerRadius, h.thetaSegments, h.phiSegments, h.thetaStart, h.thetaLength);
						break;
					case "TorusGeometry":
					;
					case "TorusBufferGeometry":
						m = new ib[h.type](h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
						break;
					case "TorusKnotGeometry":
					;
					case "TorusKnotBufferGeometry":
						m = new ib[h.type](h.radius, h.tube, h.tubularSegments, h.radialSegments, h.p, h.q);
						break;
					case "LatheGeometry":
					;
					case "LatheBufferGeometry":
						m = new ib[h.type](h.points, h.segments, h.phiStart, h.phiLength);
						break;
					case "BufferGeometry":
						m = c.parse(h);
						break;
					case "Geometry":
						m = b.parse(h.data, this.texturePath).geometry;
						break;
					default:
						console.warn('THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"');
						continue;
				}
				m.uuid = h.uuid;
				void 0 !== h.name && (m.name = h.name);
				a[h.uuid] = m;
			}
		}
		return a;
	}, parseMaterials:function(d, a) {
		var b = {};
		if (void 0 !== d) {
			var c = new Md;
			c.setTextures(a);
			a = 0;
			for (var e = d.length;a < e;a++) {
				var g = c.parse(d[a]);
				b[g.uuid] = g;
			}
		}
		return b;
	}, parseAnimations:function(d) {
		for (var a = [], b = 0;b < d.length;b++) {
			var c = ab.parse(d[b]);
			a.push(c);
		}
		return a;
	}, parseImages:function(d, a) {
		function b(d) {
			c.manager.itemStart(d);
			return g.load(d, function() {
				c.manager.itemEnd(d);
			}, void 0, function() {
				c.manager.itemError(d);
			});
		}
		var c = this, e = {};
		if (void 0 !== d && 0 < d.length) {
			a = new Zd(a);
			var g = new fd(a);
			g.setCrossOrigin(this.crossOrigin);
			a = 0;
			for (var n = d.length;a < n;a++) {
				var m = d[a], h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(m.url) ? m.url : c.texturePath + m.url;
				e[m.uuid] = b(h);
			}
		}
		return e;
	}, parseTextures:function(d, a) {
		function c(d, a) {
			if ("number" === typeof d) {
				return d;
			}
			console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", d);
			return a[d];
		}
		var e = {};
		if (void 0 !== d) {
			for (var g = 0, n = d.length;g < n;g++) {
				var m = d[g];
				void 0 === m.image && console.warn('THREE.ObjectLoader: No "image" specified for', m.uuid);
				void 0 === a[m.image] && console.warn("THREE.ObjectLoader: Undefined image", m.image);
				var h = new b(a[m.image]);
				h.needsUpdate = !0;
				h.uuid = m.uuid;
				void 0 !== m.name && (h.name = m.name);
				void 0 !== m.mapping && (h.mapping = c(m.mapping, Le));
				void 0 !== m.offset && h.offset.fromArray(m.offset);
				void 0 !== m.repeat && h.repeat.fromArray(m.repeat);
				void 0 !== m.wrap && (h.wrapS = c(m.wrap[0], ue), h.wrapT = c(m.wrap[1], ue));
				void 0 !== m.minFilter && (h.minFilter = c(m.minFilter, ve));
				void 0 !== m.magFilter && (h.magFilter = c(m.magFilter, ve));
				void 0 !== m.anisotropy && (h.anisotropy = m.anisotropy);
				void 0 !== m.flipY && (h.flipY = m.flipY);
				e[m.uuid] = h;
			}
		}
		return e;
	}, parseObject:function() {
		var d = new q;
		return function(a, b, c) {
			function e(d) {
				void 0 === b[d] && console.warn("THREE.ObjectLoader: Undefined geometry", d);
				return b[d];
			}
			function g(d) {
				if (void 0 !== d) {
					return void 0 === c[d] && console.warn("THREE.ObjectLoader: Undefined material", d), c[d];
				}
			}
			var m;
			switch(a.type) {
				case "Scene":
					m = new Cb;
					void 0 !== a.background && Number.isInteger(a.background) && (m.background = new T(a.background));
					void 0 !== a.fog && ("Fog" === a.fog.type ? m.fog = new ac(a.fog.color, a.fog.near, a.fog.far) : "FogExp2" === a.fog.type && (m.fog = new $b(a.fog.color, a.fog.density)));
					break;
				case "PerspectiveCamera":
					m = new Oa(a.fov, a.aspect, a.near, a.far);
					void 0 !== a.focus && (m.focus = a.focus);
					void 0 !== a.zoom && (m.zoom = a.zoom);
					void 0 !== a.filmGauge && (m.filmGauge = a.filmGauge);
					void 0 !== a.filmOffset && (m.filmOffset = a.filmOffset);
					void 0 !== a.view && (m.view = Object.assign({}, a.view));
					break;
				case "OrthographicCamera":
					m = new Yb(a.left, a.right, a.top, a.bottom, a.near, a.far);
					break;
				case "AmbientLight":
					m = new Fd(a.color, a.intensity);
					break;
				case "DirectionalLight":
					m = new Ed(a.color, a.intensity);
					break;
				case "PointLight":
					m = new Cd(a.color, a.intensity, a.distance, a.decay);
					break;
				case "SpotLight":
					m = new Bd(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay);
					break;
				case "HemisphereLight":
					m = new zd(a.color, a.groundColor, a.intensity);
					break;
				case "Mesh":
					m = e(a.geometry);
					var n = g(a.material);
					m = m.bones && 0 < m.bones.length ? new vd(m, n) : new Da(m, n);
					break;
				case "LOD":
					m = new Lc;
					break;
				case "Line":
					m = new tb(e(a.geometry), g(a.material), a.mode);
					break;
				case "LineSegments":
					m = new ta(e(a.geometry), g(a.material));
					break;
				case "PointCloud":
				;
				case "Points":
					m = new bc(e(a.geometry), g(a.material));
					break;
				case "Sprite":
					m = new Kc(g(a.material));
					break;
				case "Group":
					m = new Mc;
					break;
				default:
					m = new X;
			}
			m.uuid = a.uuid;
			void 0 !== a.name && (m.name = a.name);
			void 0 !== a.matrix ? (d.fromArray(a.matrix), d.decompose(m.position, m.quaternion, m.scale)) : (void 0 !== a.position && m.position.fromArray(a.position), void 0 !== a.rotation && m.rotation.fromArray(a.rotation), void 0 !== a.quaternion && m.quaternion.fromArray(a.quaternion), void 0 !== a.scale && m.scale.fromArray(a.scale));
			void 0 !== a.castShadow && (m.castShadow = a.castShadow);
			void 0 !== a.receiveShadow && (m.receiveShadow = a.receiveShadow);
			a.shadow && (void 0 !== a.shadow.bias && (m.shadow.bias = a.shadow.bias), void 0 !== a.shadow.radius && (m.shadow.radius = a.shadow.radius), void 0 !== a.shadow.mapSize && m.shadow.mapSize.fromArray(a.shadow.mapSize), void 0 !== a.shadow.camera && (m.shadow.camera = this.parseObject(a.shadow.camera)));
			void 0 !== a.visible && (m.visible = a.visible);
			void 0 !== a.userData && (m.userData = a.userData);
			if (void 0 !== a.children) {
				for (var h in a.children) {
					m.add(this.parseObject(a.children[h], b, c));
				}
			}
			if ("LOD" === a.type) {
				for (a = a.levels, n = 0;n < a.length;n++) {
					var k = a[n];
					h = m.getObjectByProperty("uuid", k.object);
					void 0 !== h && m.addLevel(h, k.distance);
				}
			}
			return m;
		};
	}()});
	Na.prototype = {constructor:Na, getPoint:function(d) {
		console.warn("THREE.Curve: Warning, getPoint() not implemented!");
		return null;
	}, getPointAt:function(d) {
		d = this.getUtoTmapping(d);
		return this.getPoint(d);
	}, getPoints:function(d) {
		d || (d = 5);
		for (var a = [], b = 0;b <= d;b++) {
			a.push(this.getPoint(b / d));
		}
		return a;
	}, getSpacedPoints:function(d) {
		d || (d = 5);
		for (var a = [], b = 0;b <= d;b++) {
			a.push(this.getPointAt(b / d));
		}
		return a;
	}, getLength:function() {
		var d = this.getLengths();
		return d[d.length - 1];
	}, getLengths:function(d) {
		d || (d = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
		if (this.cacheArcLengths && this.cacheArcLengths.length === d + 1 && !this.needsUpdate) {
			return this.cacheArcLengths;
		}
		this.needsUpdate = !1;
		var a = [], b, c = this.getPoint(0), e, g = 0;
		a.push(0);
		for (e = 1;e <= d;e++) {
			b = this.getPoint(e / d), g += b.distanceTo(c), a.push(g), c = b;
		}
		return this.cacheArcLengths = a;
	}, updateArcLengths:function() {
		this.needsUpdate = !0;
		this.getLengths();
	}, getUtoTmapping:function(d, a) {
		var b = this.getLengths(), c, e = b.length;
		d = a ? a : d * b[e - 1];
		a = 0;
		for (var g = e - 1, m;a <= g;) {
			if (c = Math.floor(a + (g - a) / 2), m = b[c] - d, 0 > m) {
				a = c + 1;
			} else {
				if (0 < m) {
					g = c - 1;
				} else {
					g = c;
					break;
				}
			}
		}
		c = g;
		if (b[c] === d) {
			return c / (e - 1);
		}
		a = b[c];
		return (c + (d - a) / (b[c + 1] - a)) / (e - 1);
	}, getTangent:function(d) {
		var a = d - 1E-4;
		d += 1E-4;
		0 > a && (a = 0);
		1 < d && (d = 1);
		a = this.getPoint(a);
		return this.getPoint(d).clone().sub(a).normalize();
	}, getTangentAt:function(d) {
		d = this.getUtoTmapping(d);
		return this.getTangent(d);
	}, computeFrenetFrames:function(d, a) {
		var b = new g, c = [], e = [], m = [], n = new g, h = new q, k, f;
		for (k = 0;k <= d;k++) {
			f = k / d, c[k] = this.getTangentAt(f), c[k].normalize();
		}
		e[0] = new g;
		m[0] = new g;
		k = Number.MAX_VALUE;
		f = Math.abs(c[0].x);
		var p = Math.abs(c[0].y), r = Math.abs(c[0].z);
		f <= k && (k = f, b.set(1, 0, 0));
		p <= k && (k = p, b.set(0, 1, 0));
		r <= k && b.set(0, 0, 1);
		n.crossVectors(c[0], b).normalize();
		e[0].crossVectors(c[0], n);
		m[0].crossVectors(c[0], e[0]);
		for (k = 1;k <= d;k++) {
			e[k] = e[k - 1].clone(), m[k] = m[k - 1].clone(), n.crossVectors(c[k - 1], c[k]), n.length() > Number.EPSILON && (n.normalize(), b = Math.acos(da.clamp(c[k - 1].dot(c[k]), -1, 1)), e[k].applyMatrix4(h.makeRotationAxis(n, b))), m[k].crossVectors(c[k], e[k]);
		}
		if (!0 === a) {
			for (b = Math.acos(da.clamp(e[0].dot(e[d]), -1, 1)), b /= d, 0 < c[0].dot(n.crossVectors(e[0], e[d])) && (b = -b), k = 1;k <= d;k++) {
				e[k].applyMatrix4(h.makeRotationAxis(c[k], b * k)), m[k].crossVectors(c[k], e[k]);
			}
		}
		return {tangents:c, normals:e, binormals:m};
	}};
	Na.create = function(d, a) {
		d.prototype = Object.create(Na.prototype);
		d.prototype.constructor = d;
		d.prototype.getPoint = a;
		return d;
	};
	pb.prototype = Object.create(Na.prototype);
	pb.prototype.constructor = pb;
	pb.prototype.isLineCurve = !0;
	pb.prototype.getPoint = function(d) {
		if (1 === d) {
			return this.v2.clone();
		}
		var a = this.v2.clone().sub(this.v1);
		a.multiplyScalar(d).add(this.v1);
		return a;
	};
	pb.prototype.getPointAt = function(d) {
		return this.getPoint(d);
	};
	pb.prototype.getTangent = function(d) {
		return this.v2.clone().sub(this.v1).normalize();
	};
	id.prototype = Object.assign(Object.create(Na.prototype), {constructor:id, add:function(d) {
		this.curves.push(d);
	}, closePath:function() {
		var d = this.curves[0].getPoint(0), a = this.curves[this.curves.length - 1].getPoint(1);
		d.equals(a) || this.curves.push(new pb(a, d));
	}, getPoint:function(d) {
		var a = d * this.getLength(), b = this.getCurveLengths();
		for (d = 0;d < b.length;) {
			if (b[d] >= a) {
				return a = b[d] - a, d = this.curves[d], b = d.getLength(), d.getPointAt(0 === b ? 0 : 1 - a / b);
			}
			d++;
		}
		return null;
	}, getLength:function() {
		var d = this.getCurveLengths();
		return d[d.length - 1];
	}, updateArcLengths:function() {
		this.needsUpdate = !0;
		this.cacheLengths = null;
		this.getLengths();
	}, getCurveLengths:function() {
		if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
			return this.cacheLengths;
		}
		for (var d = [], a = 0, b = 0, c = this.curves.length;b < c;b++) {
			a += this.curves[b].getLength(), d.push(a);
		}
		return this.cacheLengths = d;
	}, getSpacedPoints:function(d) {
		d || (d = 40);
		for (var a = [], b = 0;b <= d;b++) {
			a.push(this.getPoint(b / d));
		}
		this.autoClose && a.push(a[0]);
		return a;
	}, getPoints:function(d) {
		d = d || 12;
		for (var a = [], b, c = 0, e = this.curves;c < e.length;c++) {
			for (var g = e[c], g = g.getPoints(g && g.isEllipseCurve ? 2 * d : g && g.isLineCurve ? 1 : g && g.isSplineCurve ? d * g.points.length : d), m = 0;m < g.length;m++) {
				var h = g[m];
				b && b.equals(h) || (a.push(h), b = h);
			}
		}
		this.autoClose && 1 < a.length && !a[a.length - 1].equals(a[0]) && a.push(a[0]);
		return a;
	}, createPointsGeometry:function(d) {
		d = this.getPoints(d);
		return this.createGeometry(d);
	}, createSpacedPointsGeometry:function(d) {
		d = this.getSpacedPoints(d);
		return this.createGeometry(d);
	}, createGeometry:function(d) {
		for (var a = new ja, b = 0, c = d.length;b < c;b++) {
			var e = d[b];
			a.vertices.push(new g(e.x, e.y, e.z || 0));
		}
		return a;
	}});
	vb.prototype = Object.create(Na.prototype);
	vb.prototype.constructor = vb;
	vb.prototype.isEllipseCurve = !0;
	vb.prototype.getPoint = function(d) {
		for (var a = 2 * Math.PI, b = this.aEndAngle - this.aStartAngle, c = Math.abs(b) < Number.EPSILON;0 > b;) {
			b += a;
		}
		for (;b > a;) {
			b -= a;
		}
		b < Number.EPSILON && (b = c ? 0 : a);
		!0 !== this.aClockwise || c || (b = b === a ? -a : b - a);
		a = this.aStartAngle + d * b;
		d = this.aX + this.xRadius * Math.cos(a);
		var e = this.aY + this.yRadius * Math.sin(a);
		0 !== this.aRotation && (a = Math.cos(this.aRotation), b = Math.sin(this.aRotation), c = d - this.aX, e -= this.aY, d = c * a - e * b + this.aX, e = c * b + e * a + this.aY);
		return new l(d, e);
	};
	var pd = {tangentQuadraticBezier:function(d, a, b, c) {
		return 2 * (1 - d) * (b - a) + 2 * d * (c - b);
	}, tangentCubicBezier:function(d, a, b, c, e) {
		return -3 * a * (1 - d) * (1 - d) + 3 * b * (1 - d) * (1 - d) - 6 * d * b * (1 - d) + 6 * d * c * (1 - d) - 3 * d * d * c + 3 * d * d * e;
	}, tangentSpline:function(d, a, b, c, e) {
		return 6 * d * d - 6 * d + (3 * d * d - 4 * d + 1) + (-6 * d * d + 6 * d) + (3 * d * d - 2 * d);
	}, interpolate:function(d, a, b, c, e) {
		d = .5 * (b - d);
		c = .5 * (c - a);
		var g = e * e;
		return (2 * a - 2 * b + d + c) * e * g + (-3 * a + 3 * b - 2 * d - c) * g + d * e + a;
	}};
	Qb.prototype = Object.create(Na.prototype);
	Qb.prototype.constructor = Qb;
	Qb.prototype.isSplineCurve = !0;
	Qb.prototype.getPoint = function(d) {
		var a = this.points;
		d *= a.length - 1;
		var b = Math.floor(d);
		d -= b;
		var c = a[0 === b ? b : b - 1], e = a[b], g = a[b > a.length - 2 ? a.length - 1 : b + 1], a = a[b > a.length - 3 ? a.length - 1 : b + 2], b = pd.interpolate;
		return new l(b(c.x, e.x, g.x, a.x, d), b(c.y, e.y, g.y, a.y, d));
	};
	Rb.prototype = Object.create(Na.prototype);
	Rb.prototype.constructor = Rb;
	Rb.prototype.getPoint = function(d) {
		var a = Ea.b3;
		return new l(a(d, this.v0.x, this.v1.x, this.v2.x, this.v3.x), a(d, this.v0.y, this.v1.y, this.v2.y, this.v3.y));
	};
	Rb.prototype.getTangent = function(d) {
		var a = pd.tangentCubicBezier;
		return (new l(a(d, this.v0.x, this.v1.x, this.v2.x, this.v3.x), a(d, this.v0.y, this.v1.y, this.v2.y, this.v3.y))).normalize();
	};
	Sb.prototype = Object.create(Na.prototype);
	Sb.prototype.constructor = Sb;
	Sb.prototype.getPoint = function(d) {
		var a = Ea.b2;
		return new l(a(d, this.v0.x, this.v1.x, this.v2.x), a(d, this.v0.y, this.v1.y, this.v2.y));
	};
	Sb.prototype.getTangent = function(d) {
		var a = pd.tangentQuadraticBezier;
		return (new l(a(d, this.v0.x, this.v1.x, this.v2.x), a(d, this.v0.y, this.v1.y, this.v2.y))).normalize();
	};
	var xe = Object.assign(Object.create(id.prototype), {fromPoints:function(d) {
		this.moveTo(d[0].x, d[0].y);
		for (var a = 1, b = d.length;a < b;a++) {
			this.lineTo(d[a].x, d[a].y);
		}
	}, moveTo:function(d, a) {
		this.currentPoint.set(d, a);
	}, lineTo:function(d, a) {
		var b = new pb(this.currentPoint.clone(), new l(d, a));
		this.curves.push(b);
		this.currentPoint.set(d, a);
	}, quadraticCurveTo:function(d, a, b, c) {
		d = new Sb(this.currentPoint.clone(), new l(d, a), new l(b, c));
		this.curves.push(d);
		this.currentPoint.set(b, c);
	}, bezierCurveTo:function(d, a, b, c, e, g) {
		d = new Rb(this.currentPoint.clone(), new l(d, a), new l(b, c), new l(e, g));
		this.curves.push(d);
		this.currentPoint.set(e, g);
	}, splineThru:function(d) {
		var a = [this.currentPoint.clone()].concat(d), a = new Qb(a);
		this.curves.push(a);
		this.currentPoint.copy(d[d.length - 1]);
	}, arc:function(d, a, b, c, e, g) {
		this.absarc(d + this.currentPoint.x, a + this.currentPoint.y, b, c, e, g);
	}, absarc:function(d, a, b, c, e, g) {
		this.absellipse(d, a, b, b, c, e, g);
	}, ellipse:function(d, a, b, c, e, g, m, h) {
		this.absellipse(d + this.currentPoint.x, a + this.currentPoint.y, b, c, e, g, m, h);
	}, absellipse:function(d, a, b, c, e, g, m, h) {
		d = new vb(d, a, b, c, e, g, m, h);
		0 < this.curves.length && (a = d.getPoint(0), a.equals(this.currentPoint) || this.lineTo(a.x, a.y));
		this.curves.push(d);
		d = d.getPoint(1);
		this.currentPoint.copy(d);
	}});
	Tb.prototype = Object.assign(Object.create(xe), {constructor:Tb, getPointsHoles:function(d) {
		for (var a = [], b = 0, c = this.holes.length;b < c;b++) {
			a[b] = this.holes[b].getPoints(d);
		}
		return a;
	}, extractAllPoints:function(d) {
		return {shape:this.getPoints(d), holes:this.getPointsHoles(d)};
	}, extractPoints:function(d) {
		return this.extractAllPoints(d);
	}});
	jd.prototype = xe;
	xe.constructor = jd;
	de.prototype = {moveTo:function(d, a) {
		this.currentPath = new jd;
		this.subPaths.push(this.currentPath);
		this.currentPath.moveTo(d, a);
	}, lineTo:function(d, a) {
		this.currentPath.lineTo(d, a);
	}, quadraticCurveTo:function(d, a, b, c) {
		this.currentPath.quadraticCurveTo(d, a, b, c);
	}, bezierCurveTo:function(d, a, b, c, e, g) {
		this.currentPath.bezierCurveTo(d, a, b, c, e, g);
	}, splineThru:function(d) {
		this.currentPath.splineThru(d);
	}, toShapes:function(d, a) {
		function b(d) {
			for (var a = [], b = 0, c = d.length;b < c;b++) {
				var e = d[b], g = new Tb;
				g.curves = e.curves;
				a.push(g);
			}
			return a;
		}
		function c(d, a) {
			for (var b = a.length, c = !1, e = b - 1, g = 0;g < b;e = g++) {
				var m = a[e], n = a[g], h = n.x - m.x, k = n.y - m.y;
				if (Math.abs(k) > Number.EPSILON) {
					if (0 > k && (m = a[g], h = -h, n = a[e], k = -k), !(d.y < m.y || d.y > n.y)) {
						if (d.y === m.y) {
							if (d.x === m.x) {
								return !0;
							}
						} else {
							e = k * (d.x - m.x) - h * (d.y - m.y);
							if (0 === e) {
								return !0;
							}
							0 > e || (c = !c);
						}
					}
				} else {
					if (d.y === m.y && (n.x <= d.x && d.x <= m.x || m.x <= d.x && d.x <= n.x)) {
						return !0;
					}
				}
			}
			return c;
		}
		var e = Ea.isClockWise, g = this.subPaths;
		if (0 === g.length) {
			return [];
		}
		if (!0 === a) {
			return b(g);
		}
		var m, n, h = [];
		if (1 === g.length) {
			return m = g[0], n = new Tb, n.curves = m.curves, h.push(n), h;
		}
		var k = !e(g[0].getPoints()), k = d ? !k : k;
		n = [];
		var q = [], f = [], p = 0, r;
		q[p] = void 0;
		f[p] = [];
		for (var u = 0, l = g.length;u < l;u++) {
			m = g[u], r = m.getPoints(), a = e(r), (a = d ? !a : a) ? (!k && q[p] && p++, q[p] = {s:new Tb, p:r}, q[p].s.curves = m.curves, k && p++, f[p] = []) : f[p].push({h:m, p:r[0]});
		}
		if (!q[0]) {
			return b(g);
		}
		if (1 < q.length) {
			u = !1;
			m = [];
			e = 0;
			for (g = q.length;e < g;e++) {
				n[e] = [];
			}
			e = 0;
			for (g = q.length;e < g;e++) {
				for (a = f[e], k = 0;k < a.length;k++) {
					p = a[k];
					r = !0;
					for (l = 0;l < q.length;l++) {
						c(p.p, q[l].p) && (e !== l && m.push({froms:e, tos:l, hole:k}), r ? (r = !1, n[l].push(p)) : u = !0);
					}
					r && n[e].push(p);
				}
			}
			0 < m.length && (u || (f = n));
		}
		u = 0;
		for (e = q.length;u < e;u++) {
			for (n = q[u].s, h.push(n), m = f[u], g = 0, a = m.length;g < a;g++) {
				n.holes.push(m[g].h);
			}
		}
		return h;
	}};
	Object.assign(ee.prototype, {isFont:!0, generateShapes:function(d, a, b) {
		void 0 === a && (a = 100);
		void 0 === b && (b = 4);
		var c = this.data;
		d = String(d).split("");
		var e = a / c.resolution, g = 0;
		a = [];
		for (var m = 0;m < d.length;m++) {
			var n;
			n = e;
			var h = g, k = c.glyphs[d[m]] || c.glyphs["?"];
			if (k) {
				var q = new de, f = [], p = Ea.b2, r = Ea.b3, u, l, w, t, v, B, y, A;
				if (k.o) {
					for (var x = k._cachedOutline || (k._cachedOutline = k.o.split(" ")), z = 0, C = x.length;z < C;) {
						switch(x[z++]) {
							case "m":
								u = x[z++] * n + h;
								l = x[z++] * n;
								q.moveTo(u, l);
								break;
							case "l":
								u = x[z++] * n + h;
								l = x[z++] * n;
								q.lineTo(u, l);
								break;
							case "q":
								u = x[z++] * n + h;
								l = x[z++] * n;
								v = x[z++] * n + h;
								B = x[z++] * n;
								q.quadraticCurveTo(v, B, u, l);
								if (t = f[f.length - 1]) {
									w = t.x;
									t = t.y;
									for (var G = 1;G <= b;G++) {
										var F = G / b;
										p(F, w, v, u);
										p(F, t, B, l);
									}
								}
								break;
							case "b":
								if (u = x[z++] * n + h, l = x[z++] * n, v = x[z++] * n + h, B = x[z++] * n, y = x[z++] * n + h, A = x[z++] * n, q.bezierCurveTo(v, B, y, A, u, l), t = f[f.length - 1]) {
									for (w = t.x, t = t.y, G = 1;G <= b;G++) {
										F = G / b, r(F, w, v, y, u), r(F, t, B, A, l);
									}
								}
							;
						}
					}
				}
				n = {offset:k.ha * n, path:q};
			} else {
				n = void 0;
			}
			g += n.offset;
			a.push(n.path);
		}
		b = [];
		c = 0;
		for (d = a.length;c < d;c++) {
			Array.prototype.push.apply(b, a[c].toShapes());
		}
		return b;
	}});
	Object.assign(Ee.prototype, {load:function(d, a, b, c) {
		var e = this;
		(new fb(this.manager)).load(d, function(d) {
			var b;
			try {
				b = JSON.parse(d);
			} catch (O) {
				console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), b = JSON.parse(d.substring(65, d.length - 2));
			}
			d = e.parse(b);
			a && a(d);
		}, b, c);
	}, parse:function(d) {
		return new ee(d);
	}});
	var Td, ie = {getContext:function() {
		void 0 === Td && (Td = new (window.AudioContext || window.webkitAudioContext));
		return Td;
	}, setContext:function(d) {
		Td = d;
	}};
	Object.assign(fe.prototype, {load:function(d, a, b, c) {
		var e = new fb(this.manager);
		e.setResponseType("arraybuffer");
		e.load(d, function(d) {
			ie.getContext().decodeAudioData(d, function(d) {
				a(d);
			});
		}, b, c);
	}});
	ge.prototype = Object.assign(Object.create(Aa.prototype), {constructor:ge, isRectAreaLight:!0, copy:function(d) {
		Aa.prototype.copy.call(this, d);
		this.width = d.width;
		this.height = d.height;
		return this;
	}});
	Object.assign(Fe.prototype, {update:function() {
		var d, a, b, c, e, g, m, h = new q, k = new q;
		return function(n) {
			if (d !== this || a !== n.focus || b !== n.fov || c !== n.aspect * this.aspect || e !== n.near || g !== n.far || m !== n.zoom) {
				d = this;
				a = n.focus;
				b = n.fov;
				c = n.aspect * this.aspect;
				e = n.near;
				g = n.far;
				m = n.zoom;
				var q = n.projectionMatrix.clone(), f = this.eyeSep / 2, p = f * e / a, r = e * Math.tan(da.DEG2RAD * b * .5) / m, u;
				k.elements[12] = -f;
				h.elements[12] = f;
				f = -r * c + p;
				u = r * c + p;
				q.elements[0] = 2 * e / (u - f);
				q.elements[8] = (u + f) / (u - f);
				this.cameraL.projectionMatrix.copy(q);
				f = -r * c - p;
				u = r * c - p;
				q.elements[0] = 2 * e / (u - f);
				q.elements[8] = (u + f) / (u - f);
				this.cameraR.projectionMatrix.copy(q);
			}
			this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(k);
			this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(h);
		};
	}()});
	Nd.prototype = Object.create(X.prototype);
	Nd.prototype.constructor = Nd;
	he.prototype = Object.assign(Object.create(X.prototype), {constructor:he, getInput:function() {
		return this.gain;
	}, removeFilter:function() {
		null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null);
	}, getFilter:function() {
		return this.filter;
	}, setFilter:function(d) {
		null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination);
		this.filter = d;
		this.gain.connect(this.filter);
		this.filter.connect(this.context.destination);
	}, getMasterVolume:function() {
		return this.gain.gain.value;
	}, setMasterVolume:function(d) {
		this.gain.gain.value = d;
	}, updateMatrixWorld:function() {
		var d = new g, a = new e, b = new g, c = new g;
		return function(e) {
			X.prototype.updateMatrixWorld.call(this, e);
			e = this.context.listener;
			var g = this.up;
			this.matrixWorld.decompose(d, a, b);
			c.set(0, 0, -1).applyQuaternion(a);
			e.positionX ? (e.positionX.setValueAtTime(d.x, this.context.currentTime), e.positionY.setValueAtTime(d.y, this.context.currentTime), e.positionZ.setValueAtTime(d.z, this.context.currentTime), e.forwardX.setValueAtTime(c.x, this.context.currentTime), e.forwardY.setValueAtTime(c.y, this.context.currentTime), e.forwardZ.setValueAtTime(c.z, this.context.currentTime), e.upX.setValueAtTime(g.x, this.context.currentTime), e.upY.setValueAtTime(g.y, this.context.currentTime), e.upZ.setValueAtTime(g.z, 
			this.context.currentTime)) : (e.setPosition(d.x, d.y, d.z), e.setOrientation(c.x, c.y, c.z, g.x, g.y, g.z));
		};
	}()});
	wc.prototype = Object.assign(Object.create(X.prototype), {constructor:wc, getOutput:function() {
		return this.gain;
	}, setNodeSource:function(d) {
		this.hasPlaybackControl = !1;
		this.sourceType = "audioNode";
		this.source = d;
		this.connect();
		return this;
	}, setBuffer:function(d) {
		this.buffer = d;
		this.sourceType = "buffer";
		this.autoplay && this.play();
		return this;
	}, play:function() {
		if (!0 === this.isPlaying) {
			console.warn("THREE.Audio: Audio is already playing.");
		} else {
			if (!1 === this.hasPlaybackControl) {
				console.warn("THREE.Audio: this Audio has no playback control.");
			} else {
				var d = this.context.createBufferSource();
				d.buffer = this.buffer;
				d.loop = this.loop;
				d.onended = this.onEnded.bind(this);
				d.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
				d.start(0, this.startTime);
				this.isPlaying = !0;
				this.source = d;
				return this.connect();
			}
		}
	}, pause:function() {
		if (!1 === this.hasPlaybackControl) {
			console.warn("THREE.Audio: this Audio has no playback control.");
		} else {
			return this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = !1, this;
		}
	}, stop:function() {
		if (!1 === this.hasPlaybackControl) {
			console.warn("THREE.Audio: this Audio has no playback control.");
		} else {
			return this.source.stop(), this.startTime = 0, this.isPlaying = !1, this;
		}
	}, connect:function() {
		if (0 < this.filters.length) {
			this.source.connect(this.filters[0]);
			for (var d = 1, a = this.filters.length;d < a;d++) {
				this.filters[d - 1].connect(this.filters[d]);
			}
			this.filters[this.filters.length - 1].connect(this.getOutput());
		} else {
			this.source.connect(this.getOutput());
		}
		return this;
	}, disconnect:function() {
		if (0 < this.filters.length) {
			this.source.disconnect(this.filters[0]);
			for (var d = 1, a = this.filters.length;d < a;d++) {
				this.filters[d - 1].disconnect(this.filters[d]);
			}
			this.filters[this.filters.length - 1].disconnect(this.getOutput());
		} else {
			this.source.disconnect(this.getOutput());
		}
		return this;
	}, getFilters:function() {
		return this.filters;
	}, setFilters:function(d) {
		d || (d = []);
		!0 === this.isPlaying ? (this.disconnect(), this.filters = d, this.connect()) : this.filters = d;
		return this;
	}, getFilter:function() {
		return this.getFilters()[0];
	}, setFilter:function(d) {
		return this.setFilters(d ? [d] : []);
	}, setPlaybackRate:function(d) {
		if (!1 === this.hasPlaybackControl) {
			console.warn("THREE.Audio: this Audio has no playback control.");
		} else {
			return this.playbackRate = d, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
		}
	}, getPlaybackRate:function() {
		return this.playbackRate;
	}, onEnded:function() {
		this.isPlaying = !1;
	}, getLoop:function() {
		return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
	}, setLoop:function(d) {
		if (!1 === this.hasPlaybackControl) {
			console.warn("THREE.Audio: this Audio has no playback control.");
		} else {
			return this.loop = d, !0 === this.isPlaying && (this.source.loop = this.loop), this;
		}
	}, getVolume:function() {
		return this.gain.gain.value;
	}, setVolume:function(d) {
		this.gain.gain.value = d;
		return this;
	}});
	je.prototype = Object.assign(Object.create(wc.prototype), {constructor:je, getOutput:function() {
		return this.panner;
	}, getRefDistance:function() {
		return this.panner.refDistance;
	}, setRefDistance:function(d) {
		this.panner.refDistance = d;
	}, getRolloffFactor:function() {
		return this.panner.rolloffFactor;
	}, setRolloffFactor:function(d) {
		this.panner.rolloffFactor = d;
	}, getDistanceModel:function() {
		return this.panner.distanceModel;
	}, setDistanceModel:function(d) {
		this.panner.distanceModel = d;
	}, getMaxDistance:function() {
		return this.panner.maxDistance;
	}, setMaxDistance:function(d) {
		this.panner.maxDistance = d;
	}, updateMatrixWorld:function() {
		var d = new g;
		return function(a) {
			X.prototype.updateMatrixWorld.call(this, a);
			d.setFromMatrixPosition(this.matrixWorld);
			this.panner.setPosition(d.x, d.y, d.z);
		};
	}()});
	Object.assign(ke.prototype, {getFrequencyData:function() {
		this.analyser.getByteFrequencyData(this.data);
		return this.data;
	}, getAverageFrequency:function() {
		for (var d = 0, a = this.getFrequencyData(), b = 0;b < a.length;b++) {
			d += a[b];
		}
		return d / a.length;
	}});
	Od.prototype = {constructor:Od, accumulate:function(d, a) {
		var b = this.buffer, c = this.valueSize;
		d = d * c + c;
		var e = this.cumulativeWeight;
		if (0 === e) {
			for (e = 0;e !== c;++e) {
				b[d + e] = b[e];
			}
			e = a;
		} else {
			e += a, this._mixBufferRegion(b, d, 0, a / e, c);
		}
		this.cumulativeWeight = e;
	}, apply:function(d) {
		var a = this.valueSize, b = this.buffer;
		d = d * a + a;
		var c = this.cumulativeWeight, e = this.binding;
		this.cumulativeWeight = 0;
		1 > c && this._mixBufferRegion(b, d, 3 * a, 1 - c, a);
		for (var c = a, g = a + a;c !== g;++c) {
			if (b[c] !== b[c + a]) {
				e.setValue(b, d);
				break;
			}
		}
	}, saveOriginalState:function() {
		var d = this.buffer, a = this.valueSize, b = 3 * a;
		this.binding.getValue(d, b);
		for (var c = a;c !== b;++c) {
			d[c] = d[b + c % a];
		}
		this.cumulativeWeight = 0;
	}, restoreOriginalState:function() {
		this.binding.setValue(this.buffer, 3 * this.valueSize);
	}, _select:function(d, a, b, c, e) {
		if (.5 <= c) {
			for (c = 0;c !== e;++c) {
				d[a + c] = d[b + c];
			}
		}
	}, _slerp:function(d, a, b, c, g) {
		e.slerpFlat(d, a, d, a, d, b, c);
	}, _lerp:function(d, a, b, c, e) {
		for (var g = 1 - c, m = 0;m !== e;++m) {
			var n = a + m;
			d[n] = d[n] * g + d[b + m] * c;
		}
	}};
	Ha.prototype = {constructor:Ha, getValue:function(d, a) {
		this.bind();
		this.getValue(d, a);
	}, setValue:function(d, a) {
		this.bind();
		this.setValue(d, a);
	}, bind:function() {
		var d = this.node, a = this.parsedPath, b = a.objectName, c = a.propertyName, e = a.propertyIndex;
		d || (this.node = d = Ha.findNode(this.rootNode, a.nodeName) || this.rootNode);
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;
		if (d) {
			if (b) {
				var g = a.objectIndex;
				switch(b) {
					case "materials":
						if (!d.material) {
							console.error("  can not bind to material as node does not have a material", this);
							return;
						}
						if (!d.material.materials) {
							console.error("  can not bind to material.materials as node.material does not have a materials array", this);
							return;
						}
						d = d.material.materials;
						break;
					case "bones":
						if (!d.skeleton) {
							console.error("  can not bind to bones as node does not have a skeleton", this);
							return;
						}
						d = d.skeleton.bones;
						for (b = 0;b < d.length;b++) {
							if (d[b].name === g) {
								g = b;
								break;
							}
						}
						break;
					default:
						if (void 0 === d[b]) {
							console.error("  can not bind to objectName of node, undefined", this);
							return;
						}
						d = d[b];
				}
				if (void 0 !== g) {
					if (void 0 === d[g]) {
						console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, d);
						return;
					}
					d = d[g];
				}
			}
			g = d[c];
			if (void 0 === g) {
				console.error("  trying to update property for track: " + a.nodeName + "." + c + " but it wasn't found.", d);
			} else {
				a = this.Versioning.None;
				void 0 !== d.needsUpdate ? (a = this.Versioning.NeedsUpdate, this.targetObject = d) : void 0 !== d.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = d);
				b = this.BindingType.Direct;
				if (void 0 !== e) {
					if ("morphTargetInfluences" === c) {
						if (!d.geometry) {
							console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
							return;
						}
						if (!d.geometry.morphTargets) {
							console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
							return;
						}
						for (b = 0;b < this.node.geometry.morphTargets.length;b++) {
							if (d.geometry.morphTargets[b].name === e) {
								e = b;
								break;
							}
						}
					}
					b = this.BindingType.ArrayElement;
					this.resolvedProperty = g;
					this.propertyIndex = e;
				} else {
					void 0 !== g.fromArray && void 0 !== g.toArray ? (b = this.BindingType.HasFromToArray, this.resolvedProperty = g) : void 0 !== g.length ? (b = this.BindingType.EntireArray, this.resolvedProperty = g) : this.propertyName = c;
				}
				this.getValue = this.GetterByBindingType[b];
				this.setValue = this.SetterByBindingTypeAndVersioning[b][a];
			}
		} else {
			console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
		}
	}, unbind:function() {
		this.node = null;
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;
	}};
	Object.assign(Ha.prototype, {_getValue_unavailable:function() {
	}, _setValue_unavailable:function() {
	}, _getValue_unbound:Ha.prototype.getValue, _setValue_unbound:Ha.prototype.setValue, BindingType:{Direct:0, EntireArray:1, ArrayElement:2, HasFromToArray:3}, Versioning:{None:0, NeedsUpdate:1, MatrixWorldNeedsUpdate:2}, GetterByBindingType:[function(d, a) {
		d[a] = this.node[this.propertyName];
	}, function(d, a) {
		for (var b = this.resolvedProperty, c = 0, e = b.length;c !== e;++c) {
			d[a++] = b[c];
		}
	}, function(d, a) {
		d[a] = this.resolvedProperty[this.propertyIndex];
	}, function(d, a) {
		this.resolvedProperty.toArray(d, a);
	}], SetterByBindingTypeAndVersioning:[[function(d, a) {
		this.node[this.propertyName] = d[a];
	}, function(d, a) {
		this.node[this.propertyName] = d[a];
		this.targetObject.needsUpdate = !0;
	}, function(d, a) {
		this.node[this.propertyName] = d[a];
		this.targetObject.matrixWorldNeedsUpdate = !0;
	}], [function(d, a) {
		for (var b = this.resolvedProperty, c = 0, e = b.length;c !== e;++c) {
			b[c] = d[a++];
		}
	}, function(d, a) {
		for (var b = this.resolvedProperty, c = 0, e = b.length;c !== e;++c) {
			b[c] = d[a++];
		}
		this.targetObject.needsUpdate = !0;
	}, function(d, a) {
		for (var b = this.resolvedProperty, c = 0, e = b.length;c !== e;++c) {
			b[c] = d[a++];
		}
		this.targetObject.matrixWorldNeedsUpdate = !0;
	}], [function(d, a) {
		this.resolvedProperty[this.propertyIndex] = d[a];
	}, function(d, a) {
		this.resolvedProperty[this.propertyIndex] = d[a];
		this.targetObject.needsUpdate = !0;
	}, function(d, a) {
		this.resolvedProperty[this.propertyIndex] = d[a];
		this.targetObject.matrixWorldNeedsUpdate = !0;
	}], [function(d, a) {
		this.resolvedProperty.fromArray(d, a);
	}, function(d, a) {
		this.resolvedProperty.fromArray(d, a);
		this.targetObject.needsUpdate = !0;
	}, function(d, a) {
		this.resolvedProperty.fromArray(d, a);
		this.targetObject.matrixWorldNeedsUpdate = !0;
	}]]});
	Ha.Composite = function(d, a, b) {
		b = b || Ha.parseTrackName(a);
		this._targetGroup = d;
		this._bindings = d.subscribe_(a, b);
	};
	Ha.Composite.prototype = {constructor:Ha.Composite, getValue:function(d, a) {
		this.bind();
		var b = this._bindings[this._targetGroup.nCachedObjects_];
		void 0 !== b && b.getValue(d, a);
	}, setValue:function(d, a) {
		for (var b = this._bindings, c = this._targetGroup.nCachedObjects_, e = b.length;c !== e;++c) {
			b[c].setValue(d, a);
		}
	}, bind:function() {
		for (var d = this._bindings, a = this._targetGroup.nCachedObjects_, b = d.length;a !== b;++a) {
			d[a].bind();
		}
	}, unbind:function() {
		for (var d = this._bindings, a = this._targetGroup.nCachedObjects_, b = d.length;a !== b;++a) {
			d[a].unbind();
		}
	}};
	Ha.create = function(d, a, b) {
		return d && d.isAnimationObjectGroup ? new Ha.Composite(d, a, b) : new Ha(d, a, b);
	};
	Ha.parseTrackName = function(d) {
		var a = /^((?:\w+[\/:])*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/.exec(d);
		if (!a) {
			throw Error("cannot parse trackName at all: " + d);
		}
		a = {nodeName:a[2], objectName:a[3], objectIndex:a[4], propertyName:a[5], propertyIndex:a[6]};
		if (null === a.propertyName || 0 === a.propertyName.length) {
			throw Error("can not parse propertyName from trackName: " + d);
		}
		return a;
	};
	Ha.findNode = function(d, a) {
		if (!a || "" === a || "root" === a || "." === a || -1 === a || a === d.name || a === d.uuid) {
			return d;
		}
		if (d.skeleton) {
			var b = function(d) {
				for (var b = 0;b < d.bones.length;b++) {
					var c = d.bones[b];
					if (c.name === a) {
						return c;
					}
				}
				return null;
			}(d.skeleton);
			if (b) {
				return b;
			}
		}
		if (d.children) {
			var c = function(d) {
				for (var b = 0;b < d.length;b++) {
					var e = d[b];
					if (e.name === a || e.uuid === a || (e = c(e.children))) {
						return e;
					}
				}
				return null;
			};
			if (b = c(d.children)) {
				return b;
			}
		}
		return null;
	};
	le.prototype = {constructor:le, isAnimationObjectGroup:!0, add:function(d) {
		for (var a = this._objects, b = a.length, c = this.nCachedObjects_, e = this._indicesByUUID, g = this._paths, m = this._parsedPaths, h = this._bindings, k = h.length, q = 0, f = arguments.length;q !== f;++q) {
			var p = arguments[q], r = p.uuid, u = e[r];
			if (void 0 === u) {
				u = b++;
				e[r] = u;
				a.push(p);
				for (var r = 0, l = k;r !== l;++r) {
					h[r].push(new Ha(p, g[r], m[r]));
				}
			} else {
				if (u < c) {
					var w = a[u], t = --c, l = a[t];
					e[l.uuid] = u;
					a[u] = l;
					e[r] = t;
					a[t] = p;
					r = 0;
					for (l = k;r !== l;++r) {
						var v = h[r], B = v[u];
						v[u] = v[t];
						void 0 === B && (B = new Ha(p, g[r], m[r]));
						v[t] = B;
					}
				} else {
					a[u] !== w && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...");
				}
			}
		}
		this.nCachedObjects_ = c;
	}, remove:function(d) {
		for (var a = this._objects, b = this.nCachedObjects_, c = this._indicesByUUID, e = this._bindings, g = e.length, m = 0, h = arguments.length;m !== h;++m) {
			var k = arguments[m], q = k.uuid, f = c[q];
			if (void 0 !== f && f >= b) {
				var p = b++, r = a[p];
				c[r.uuid] = f;
				a[f] = r;
				c[q] = p;
				a[p] = k;
				k = 0;
				for (q = g;k !== q;++k) {
					var r = e[k], u = r[f];
					r[f] = r[p];
					r[p] = u;
				}
			}
		}
		this.nCachedObjects_ = b;
	}, uncache:function(d) {
		for (var a = this._objects, b = a.length, c = this.nCachedObjects_, e = this._indicesByUUID, g = this._bindings, m = g.length, h = 0, k = arguments.length;h !== k;++h) {
			var q = arguments[h].uuid, f = e[q];
			if (void 0 !== f) {
				if (delete e[q], f < c) {
					var q = --c, p = a[q], r = --b, u = a[r];
					e[p.uuid] = f;
					a[f] = p;
					e[u.uuid] = q;
					a[q] = u;
					a.pop();
					p = 0;
					for (u = m;p !== u;++p) {
						var l = g[p], w = l[r];
						l[f] = l[q];
						l[q] = w;
						l.pop();
					}
				} else {
					for (r = --b, u = a[r], e[u.uuid] = f, a[f] = u, a.pop(), p = 0, u = m;p !== u;++p) {
						l = g[p], l[f] = l[r], l.pop();
					}
				}
			}
		}
		this.nCachedObjects_ = c;
	}, subscribe_:function(d, a) {
		var b = this._bindingsIndicesByPath, c = b[d], e = this._bindings;
		if (void 0 !== c) {
			return e[c];
		}
		var g = this._paths, m = this._parsedPaths, h = this._objects, n = this.nCachedObjects_, k = Array(h.length), c = e.length;
		b[d] = c;
		g.push(d);
		m.push(a);
		e.push(k);
		b = n;
		for (c = h.length;b !== c;++b) {
			k[b] = new Ha(h[b], d, a);
		}
		return k;
	}, unsubscribe_:function(d) {
		var a = this._bindingsIndicesByPath, b = a[d];
		if (void 0 !== b) {
			var c = this._paths, e = this._parsedPaths, g = this._bindings, m = g.length - 1, h = g[m];
			a[d[m]] = b;
			g[b] = h;
			g.pop();
			e[b] = e[m];
			e.pop();
			c[b] = c[m];
			c.pop();
		}
	}};
	me.prototype = {constructor:me, play:function() {
		this._mixer._activateAction(this);
		return this;
	}, stop:function() {
		this._mixer._deactivateAction(this);
		return this.reset();
	}, reset:function() {
		this.paused = !1;
		this.enabled = !0;
		this.time = 0;
		this._loopCount = -1;
		this._startTime = null;
		return this.stopFading().stopWarping();
	}, isRunning:function() {
		return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
	}, isScheduled:function() {
		return this._mixer._isActiveAction(this);
	}, startAt:function(d) {
		this._startTime = d;
		return this;
	}, setLoop:function(d, a) {
		this.loop = d;
		this.repetitions = a;
		return this;
	}, setEffectiveWeight:function(d) {
		this.weight = d;
		this._effectiveWeight = this.enabled ? d : 0;
		return this.stopFading();
	}, getEffectiveWeight:function() {
		return this._effectiveWeight;
	}, fadeIn:function(d) {
		return this._scheduleFading(d, 0, 1);
	}, fadeOut:function(d) {
		return this._scheduleFading(d, 1, 0);
	}, crossFadeFrom:function(d, a, b) {
		d.fadeOut(a);
		this.fadeIn(a);
		if (b) {
			b = this._clip.duration;
			var c = d._clip.duration, e = b / c;
			d.warp(1, c / b, a);
			this.warp(e, 1, a);
		}
		return this;
	}, crossFadeTo:function(d, a, b) {
		return d.crossFadeFrom(this, a, b);
	}, stopFading:function() {
		var d = this._weightInterpolant;
		null !== d && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(d));
		return this;
	}, setEffectiveTimeScale:function(d) {
		this.timeScale = d;
		this._effectiveTimeScale = this.paused ? 0 : d;
		return this.stopWarping();
	}, getEffectiveTimeScale:function() {
		return this._effectiveTimeScale;
	}, setDuration:function(d) {
		this.timeScale = this._clip.duration / d;
		return this.stopWarping();
	}, syncWith:function(d) {
		this.time = d.time;
		this.timeScale = d.timeScale;
		return this.stopWarping();
	}, halt:function(d) {
		return this.warp(this._effectiveTimeScale, 0, d);
	}, warp:function(d, a, b) {
		var c = this._mixer, e = c.time, g = this._timeScaleInterpolant, m = this.timeScale;
		null === g && (this._timeScaleInterpolant = g = c._lendControlInterpolant());
		c = g.parameterPositions;
		g = g.sampleValues;
		c[0] = e;
		c[1] = e + b;
		g[0] = d / m;
		g[1] = a / m;
		return this;
	}, stopWarping:function() {
		var d = this._timeScaleInterpolant;
		null !== d && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(d));
		return this;
	}, getMixer:function() {
		return this._mixer;
	}, getClip:function() {
		return this._clip;
	}, getRoot:function() {
		return this._localRoot || this._mixer._root;
	}, _update:function(d, a, b, c) {
		var e = this._startTime;
		if (null !== e) {
			a = (d - e) * b;
			if (0 > a || 0 === b) {
				return;
			}
			this._startTime = null;
			a *= b;
		}
		a *= this._updateTimeScale(d);
		b = this._updateTime(a);
		d = this._updateWeight(d);
		if (0 < d) {
			a = this._interpolants;
			for (var e = this._propertyBindings, g = 0, m = a.length;g !== m;++g) {
				a[g].evaluate(b), e[g].accumulate(c, d);
			}
		}
	}, _updateWeight:function(d) {
		var a = 0;
		if (this.enabled) {
			var a = this.weight, b = this._weightInterpolant;
			if (null !== b) {
				var c = b.evaluate(d)[0], a = a * c;
				d > b.parameterPositions[1] && (this.stopFading(), 0 === c && (this.enabled = !1));
			}
		}
		return this._effectiveWeight = a;
	}, _updateTimeScale:function(d) {
		var a = 0;
		if (!this.paused) {
			var a = this.timeScale, b = this._timeScaleInterpolant;
			if (null !== b) {
				var c = b.evaluate(d)[0], a = a * c;
				d > b.parameterPositions[1] && (this.stopWarping(), 0 === a ? this.paused = !0 : this.timeScale = a);
			}
		}
		return this._effectiveTimeScale = a;
	}, _updateTime:function(d) {
		var a = this.time + d;
		if (0 === d) {
			return a;
		}
		var b = this._clip.duration, c = this.loop, e = this._loopCount;
		if (2200 === c) {
			a: {
				if (-1 === e && (this.loopCount = 0, this._setEndings(!0, !0, !1)), a >= b) {
					a = b;
				} else {
					if (0 > a) {
						a = 0;
					} else {
						break a;
					}
				}
				this.clampWhenFinished ? this.paused = !0 : this.enabled = !1;
				this._mixer.dispatchEvent({type:"finished", action:this, direction:0 > d ? -1 : 1});
			}
		} else {
			c = 2202 === c;
			-1 === e && (0 <= d ? (e = 0, this._setEndings(!0, 0 === this.repetitions, c)) : this._setEndings(0 === this.repetitions, !0, c));
			if (a >= b || 0 > a) {
				var g = Math.floor(a / b), a = a - b * g, e = e + Math.abs(g), m = this.repetitions - e;
				0 > m ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, a = 0 < d ? b : 0, this._mixer.dispatchEvent({type:"finished", action:this, direction:0 < d ? 1 : -1})) : (0 === m ? (d = 0 > d, this._setEndings(d, !d, c)) : this._setEndings(!1, !1, c), this._loopCount = e, this._mixer.dispatchEvent({type:"loop", action:this, loopDelta:g}));
			}
			if (c && 1 === (e & 1)) {
				return this.time = a, b - a;
			}
		}
		return this.time = a;
	}, _setEndings:function(d, a, b) {
		var c = this._interpolantSettings;
		b ? (c.endingStart = 2401, c.endingEnd = 2401) : (c.endingStart = d ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, c.endingEnd = a ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
	}, _scheduleFading:function(d, a, b) {
		var c = this._mixer, e = c.time, g = this._weightInterpolant;
		null === g && (this._weightInterpolant = g = c._lendControlInterpolant());
		c = g.parameterPositions;
		g = g.sampleValues;
		c[0] = e;
		g[0] = a;
		c[1] = e + d;
		g[1] = b;
		return this;
	}};
	Object.assign(ne.prototype, f.prototype, {clipAction:function(d, a) {
		var b = a || this._root, c = b.uuid, e = "string" === typeof d ? ab.findByName(b, d) : d, b = null !== e ? e.uuid : d;
		d = this._actionsByClip[b];
		var g = null;
		if (void 0 !== d) {
			g = d.actionByRoot[c];
			if (void 0 !== g) {
				return g;
			}
			g = d.knownActions[0];
			null === e && (e = g._clip);
		}
		if (null === e) {
			return null;
		}
		e = new me(this, e, a);
		this._bindAction(e, g);
		this._addInactiveAction(e, b, c);
		return e;
	}, existingAction:function(d, a) {
		a = a || this._root;
		var b = a.uuid;
		a = "string" === typeof d ? ab.findByName(a, d) : d;
		a = this._actionsByClip[a ? a.uuid : d];
		return void 0 !== a ? a.actionByRoot[b] || null : null;
	}, stopAllAction:function() {
		for (var d = this._actions, a = this._nActiveActions, b = this._bindings, c = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0;e !== a;++e) {
			d[e].reset();
		}
		for (e = 0;e !== c;++e) {
			b[e].useCount = 0;
		}
		return this;
	}, update:function(d) {
		d *= this.timeScale;
		for (var a = this._actions, b = this._nActiveActions, c = this.time += d, e = Math.sign(d), g = this._accuIndex ^= 1, m = 0;m !== b;++m) {
			var h = a[m];
			h.enabled && h._update(c, d, e, g);
		}
		d = this._bindings;
		a = this._nActiveBindings;
		for (m = 0;m !== a;++m) {
			d[m].apply(g);
		}
		return this;
	}, getRoot:function() {
		return this._root;
	}, uncacheClip:function(d) {
		var a = this._actions;
		d = d.uuid;
		var b = this._actionsByClip, c = b[d];
		if (void 0 !== c) {
			for (var c = c.knownActions, e = 0, g = c.length;e !== g;++e) {
				var m = c[e];
				this._deactivateAction(m);
				var h = m._cacheIndex, k = a[a.length - 1];
				m._cacheIndex = null;
				m._byClipCacheIndex = null;
				k._cacheIndex = h;
				a[h] = k;
				a.pop();
				this._removeInactiveBindingsForAction(m);
			}
			delete b[d];
		}
	}, uncacheRoot:function(d) {
		d = d.uuid;
		var a = this._actionsByClip, b;
		for (b in a) {
			var c = a[b].actionByRoot[d];
			void 0 !== c && (this._deactivateAction(c), this._removeInactiveAction(c));
		}
		b = this._bindingsByRootAndName[d];
		if (void 0 !== b) {
			for (var e in b) {
				d = b[e], d.restoreOriginalState(), this._removeInactiveBinding(d);
			}
		}
	}, uncacheAction:function(d, a) {
		d = this.existingAction(d, a);
		null !== d && (this._deactivateAction(d), this._removeInactiveAction(d));
	}});
	Object.assign(ne.prototype, {_bindAction:function(d, a) {
		var b = d._localRoot || this._root, c = d._clip.tracks, e = c.length, g = d._propertyBindings;
		d = d._interpolants;
		var m = b.uuid, h = this._bindingsByRootAndName, k = h[m];
		void 0 === k && (k = {}, h[m] = k);
		for (h = 0;h !== e;++h) {
			var n = c[h], q = n.name, f = k[q];
			if (void 0 === f) {
				f = g[h];
				if (void 0 !== f) {
					null === f._cacheIndex && (++f.referenceCount, this._addInactiveBinding(f, m, q));
					continue;
				}
				f = new Od(Ha.create(b, q, a && a._propertyBindings[h].binding.parsedPath), n.ValueTypeName, n.getValueSize());
				++f.referenceCount;
				this._addInactiveBinding(f, m, q);
			}
			g[h] = f;
			d[h].resultBuffer = f.buffer;
		}
	}, _activateAction:function(d) {
		if (!this._isActiveAction(d)) {
			if (null === d._cacheIndex) {
				var a = (d._localRoot || this._root).uuid, b = d._clip.uuid, c = this._actionsByClip[b];
				this._bindAction(d, c && c.knownActions[0]);
				this._addInactiveAction(d, b, a);
			}
			a = d._propertyBindings;
			b = 0;
			for (c = a.length;b !== c;++b) {
				var e = a[b];
				0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState());
			}
			this._lendAction(d);
		}
	}, _deactivateAction:function(d) {
		if (this._isActiveAction(d)) {
			for (var a = d._propertyBindings, b = 0, c = a.length;b !== c;++b) {
				var e = a[b];
				0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e));
			}
			this._takeBackAction(d);
		}
	}, _initMemoryManager:function() {
		this._actions = [];
		this._nActiveActions = 0;
		this._actionsByClip = {};
		this._bindings = [];
		this._nActiveBindings = 0;
		this._bindingsByRootAndName = {};
		this._controlInterpolants = [];
		this._nActiveControlInterpolants = 0;
		var d = this;
		this.stats = {actions:{get total() {
			return d._actions.length;
		}, get inUse() {
			return d._nActiveActions;
		}}, bindings:{get total() {
			return d._bindings.length;
		}, get inUse() {
			return d._nActiveBindings;
		}}, controlInterpolants:{get total() {
			return d._controlInterpolants.length;
		}, get inUse() {
			return d._nActiveControlInterpolants;
		}}};
	}, _isActiveAction:function(d) {
		d = d._cacheIndex;
		return null !== d && d < this._nActiveActions;
	}, _addInactiveAction:function(d, a, b) {
		var c = this._actions, e = this._actionsByClip, g = e[a];
		void 0 === g ? (g = {knownActions:[d], actionByRoot:{}}, d._byClipCacheIndex = 0, e[a] = g) : (a = g.knownActions, d._byClipCacheIndex = a.length, a.push(d));
		d._cacheIndex = c.length;
		c.push(d);
		g.actionByRoot[b] = d;
	}, _removeInactiveAction:function(a) {
		var d = this._actions, b = d[d.length - 1], c = a._cacheIndex;
		b._cacheIndex = c;
		d[c] = b;
		d.pop();
		a._cacheIndex = null;
		var b = a._clip.uuid, c = this._actionsByClip, e = c[b], g = e.knownActions, m = g[g.length - 1], h = a._byClipCacheIndex;
		m._byClipCacheIndex = h;
		g[h] = m;
		g.pop();
		a._byClipCacheIndex = null;
		delete e.actionByRoot[(d._localRoot || this._root).uuid];
		0 === g.length && delete c[b];
		this._removeInactiveBindingsForAction(a);
	}, _removeInactiveBindingsForAction:function(a) {
		a = a._propertyBindings;
		for (var d = 0, b = a.length;d !== b;++d) {
			var c = a[d];
			0 === --c.referenceCount && this._removeInactiveBinding(c);
		}
	}, _lendAction:function(a) {
		var d = this._actions, b = a._cacheIndex, c = this._nActiveActions++, e = d[c];
		a._cacheIndex = c;
		d[c] = a;
		e._cacheIndex = b;
		d[b] = e;
	}, _takeBackAction:function(a) {
		var d = this._actions, b = a._cacheIndex, c = --this._nActiveActions, e = d[c];
		a._cacheIndex = c;
		d[c] = a;
		e._cacheIndex = b;
		d[b] = e;
	}, _addInactiveBinding:function(a, b, c) {
		var d = this._bindingsByRootAndName, e = d[b], g = this._bindings;
		void 0 === e && (e = {}, d[b] = e);
		e[c] = a;
		a._cacheIndex = g.length;
		g.push(a);
	}, _removeInactiveBinding:function(a) {
		var d = this._bindings, b = a.binding, c = b.rootNode.uuid, b = b.path, e = this._bindingsByRootAndName, g = e[c], m = d[d.length - 1];
		a = a._cacheIndex;
		m._cacheIndex = a;
		d[a] = m;
		d.pop();
		delete g[b];
		a: {
			for (var h in g) {
				break a;
			}
			delete e[c];
		}
	}, _lendBinding:function(a) {
		var d = this._bindings, b = a._cacheIndex, c = this._nActiveBindings++, e = d[c];
		a._cacheIndex = c;
		d[c] = a;
		e._cacheIndex = b;
		d[b] = e;
	}, _takeBackBinding:function(a) {
		var d = this._bindings, b = a._cacheIndex, c = --this._nActiveBindings, e = d[c];
		a._cacheIndex = c;
		d[c] = a;
		e._cacheIndex = b;
		d[b] = e;
	}, _lendControlInterpolant:function() {
		var a = this._controlInterpolants, b = this._nActiveControlInterpolants++, c = a[b];
		void 0 === c && (c = new gd(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c);
		return c;
	}, _takeBackControlInterpolant:function(a) {
		var d = this._controlInterpolants, b = a.__cacheIndex, c = --this._nActiveControlInterpolants, e = d[c];
		a.__cacheIndex = c;
		d[c] = a;
		e.__cacheIndex = b;
		d[b] = e;
	}, _controlInterpolantsResultBuffer:new Float32Array(1)});
	Pd.prototype.clone = function() {
		return new Pd(void 0 === this.value.clone ? this.value : this.value.clone());
	};
	Ub.prototype = Object.create(ca.prototype);
	Ub.prototype.constructor = Ub;
	Ub.prototype.isInstancedBufferGeometry = !0;
	Ub.prototype.addGroup = function(a, b, c) {
		this.groups.push({start:a, count:b, materialIndex:c});
	};
	Ub.prototype.copy = function(a) {
		var d = a.index;
		null !== d && this.setIndex(d.clone());
		var d = a.attributes, b;
		for (b in d) {
			this.addAttribute(b, d[b].clone());
		}
		a = a.groups;
		b = 0;
		for (d = a.length;b < d;b++) {
			var c = a[b];
			this.addGroup(c.start, c.count, c.materialIndex);
		}
		return this;
	};
	oe.prototype = {constructor:oe, isInterleavedBufferAttribute:!0, get count() {
		return this.data.count;
	}, get array() {
		return this.data.array;
	}, setX:function(a, b) {
		this.data.array[a * this.data.stride + this.offset] = b;
		return this;
	}, setY:function(a, b) {
		this.data.array[a * this.data.stride + this.offset + 1] = b;
		return this;
	}, setZ:function(a, b) {
		this.data.array[a * this.data.stride + this.offset + 2] = b;
		return this;
	}, setW:function(a, b) {
		this.data.array[a * this.data.stride + this.offset + 3] = b;
		return this;
	}, getX:function(a) {
		return this.data.array[a * this.data.stride + this.offset];
	}, getY:function(a) {
		return this.data.array[a * this.data.stride + this.offset + 1];
	}, getZ:function(a) {
		return this.data.array[a * this.data.stride + this.offset + 2];
	}, getW:function(a) {
		return this.data.array[a * this.data.stride + this.offset + 3];
	}, setXY:function(a, b, c) {
		a = a * this.data.stride + this.offset;
		this.data.array[a + 0] = b;
		this.data.array[a + 1] = c;
		return this;
	}, setXYZ:function(a, b, c, e) {
		a = a * this.data.stride + this.offset;
		this.data.array[a + 0] = b;
		this.data.array[a + 1] = c;
		this.data.array[a + 2] = e;
		return this;
	}, setXYZW:function(a, b, c, e, g) {
		a = a * this.data.stride + this.offset;
		this.data.array[a + 0] = b;
		this.data.array[a + 1] = c;
		this.data.array[a + 2] = e;
		this.data.array[a + 3] = g;
		return this;
	}};
	xc.prototype = {constructor:xc, isInterleavedBuffer:!0, set needsUpdate(a) {
		!0 === a && this.version++;
	}, setArray:function(a) {
		if (Array.isArray(a)) {
			throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
		}
		this.count = void 0 !== a ? a.length / this.stride : 0;
		this.array = a;
	}, setDynamic:function(a) {
		this.dynamic = a;
		return this;
	}, copy:function(a) {
		this.array = new a.array.constructor(a.array);
		this.count = a.count;
		this.stride = a.stride;
		this.dynamic = a.dynamic;
		return this;
	}, copyAt:function(a, b, c) {
		a *= this.stride;
		c *= b.stride;
		for (var d = 0, e = this.stride;d < e;d++) {
			this.array[a + d] = b.array[c + d];
		}
		return this;
	}, set:function(a, b) {
		void 0 === b && (b = 0);
		this.array.set(a, b);
		return this;
	}, clone:function() {
		return (new this.constructor).copy(this);
	}, onUpload:function(a) {
		this.onUploadCallback = a;
		return this;
	}};
	yc.prototype = Object.create(xc.prototype);
	yc.prototype.constructor = yc;
	yc.prototype.isInstancedInterleavedBuffer = !0;
	yc.prototype.copy = function(a) {
		xc.prototype.copy.call(this, a);
		this.meshPerAttribute = a.meshPerAttribute;
		return this;
	};
	zc.prototype = Object.create(U.prototype);
	zc.prototype.constructor = zc;
	zc.prototype.isInstancedBufferAttribute = !0;
	zc.prototype.copy = function(a) {
		U.prototype.copy.call(this, a);
		this.meshPerAttribute = a.meshPerAttribute;
		return this;
	};
	pe.prototype = {constructor:pe, linePrecision:1, set:function(a, b) {
		this.ray.set(a, b);
	}, setFromCamera:function(a, b) {
		b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize()) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
	}, intersectObject:function(a, b) {
		var d = [];
		qe(a, this, d, b);
		d.sort(Ge);
		return d;
	}, intersectObjects:function(a, b) {
		var d = [];
		if (!1 === Array.isArray(a)) {
			return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), d;
		}
		for (var c = 0, e = a.length;c < e;c++) {
			qe(a[c], this, d, b);
		}
		d.sort(Ge);
		return d;
	}};
	re.prototype = {constructor:re, start:function() {
		this.oldTime = this.startTime = (performance || Date).now();
		this.elapsedTime = 0;
		this.running = !0;
	}, stop:function() {
		this.getElapsedTime();
		this.running = !1;
	}, getElapsedTime:function() {
		this.getDelta();
		return this.elapsedTime;
	}, getDelta:function() {
		var a = 0;
		this.autoStart && !this.running && this.start();
		if (this.running) {
			var b = (performance || Date).now(), a = (b - this.oldTime) / 1E3;
			this.oldTime = b;
			this.elapsedTime += a;
		}
		return a;
	}};
	se.prototype = {constructor:se, set:function(a, b, c) {
		this.radius = a;
		this.phi = b;
		this.theta = c;
		return this;
	}, clone:function() {
		return (new this.constructor).copy(this);
	}, copy:function(a) {
		this.radius = a.radius;
		this.phi = a.phi;
		this.theta = a.theta;
		return this;
	}, makeSafe:function() {
		this.phi = Math.max(1E-6, Math.min(Math.PI - 1E-6, this.phi));
		return this;
	}, setFromVector3:function(a) {
		this.radius = a.length();
		0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a.x, a.z), this.phi = Math.acos(da.clamp(a.y / this.radius, -1, 1)));
		return this;
	}};
	Ka.prototype = Object.create(Da.prototype);
	Ka.prototype.constructor = Ka;
	Ka.prototype.createAnimation = function(a, b, c, e) {
		b = {start:b, end:c, length:c - b + 1, fps:e, duration:(c - b) / e, lastFrame:0, currentFrame:0, active:!1, time:0, direction:1, weight:1, directionBackwards:!1, mirroredLoop:!1};
		this.animationsMap[a] = b;
		this.animationsList.push(b);
	};
	Ka.prototype.autoCreateAnimations = function(a) {
		for (var d = /([a-z]+)_?(\d+)/i, b, c = {}, e = this.geometry, g = 0, m = e.morphTargets.length;g < m;g++) {
			var h = e.morphTargets[g].name.match(d);
			if (h && 1 < h.length) {
				var k = h[1];
				c[k] || (c[k] = {start:Infinity, end:-Infinity});
				h = c[k];
				g < h.start && (h.start = g);
				g > h.end && (h.end = g);
				b || (b = k);
			}
		}
		for (k in c) {
			h = c[k], this.createAnimation(k, h.start, h.end, a);
		}
		this.firstAnimation = b;
	};
	Ka.prototype.setAnimationDirectionForward = function(a) {
		if (a = this.animationsMap[a]) {
			a.direction = 1, a.directionBackwards = !1;
		}
	};
	Ka.prototype.setAnimationDirectionBackward = function(a) {
		if (a = this.animationsMap[a]) {
			a.direction = -1, a.directionBackwards = !0;
		}
	};
	Ka.prototype.setAnimationFPS = function(a, b) {
		(a = this.animationsMap[a]) && (a.fps = b, a.duration = (a.end - a.start) / a.fps);
	};
	Ka.prototype.setAnimationDuration = function(a, b) {
		(a = this.animationsMap[a]) && (a.duration = b, a.fps = (a.end - a.start) / a.duration);
	};
	Ka.prototype.setAnimationWeight = function(a, b) {
		(a = this.animationsMap[a]) && (a.weight = b);
	};
	Ka.prototype.setAnimationTime = function(a, b) {
		(a = this.animationsMap[a]) && (a.time = b);
	};
	Ka.prototype.getAnimationTime = function(a) {
		var d = 0;
		if (a = this.animationsMap[a]) {
			d = a.time;
		}
		return d;
	};
	Ka.prototype.getAnimationDuration = function(a) {
		var d = -1;
		if (a = this.animationsMap[a]) {
			d = a.duration;
		}
		return d;
	};
	Ka.prototype.playAnimation = function(a) {
		var d = this.animationsMap[a];
		d ? (d.time = 0, d.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + a + "] undefined in .playAnimation()");
	};
	Ka.prototype.stopAnimation = function(a) {
		if (a = this.animationsMap[a]) {
			a.active = !1;
		}
	};
	Ka.prototype.update = function(a) {
		for (var d = 0, b = this.animationsList.length;d < b;d++) {
			var c = this.animationsList[d];
			if (c.active) {
				var e = c.duration / c.length;
				c.time += c.direction * a;
				if (c.mirroredLoop) {
					if (c.time > c.duration || 0 > c.time) {
						c.direction *= -1, c.time > c.duration && (c.time = c.duration, c.directionBackwards = !0), 0 > c.time && (c.time = 0, c.directionBackwards = !1);
					}
				} else {
					c.time %= c.duration, 0 > c.time && (c.time += c.duration);
				}
				var g = c.start + da.clamp(Math.floor(c.time / e), 0, c.length - 1), m = c.weight;
				g !== c.currentFrame && (this.morphTargetInfluences[c.lastFrame] = 0, this.morphTargetInfluences[c.currentFrame] = 1 * m, this.morphTargetInfluences[g] = 0, c.lastFrame = c.currentFrame, c.currentFrame = g);
				e = c.time % e / e;
				c.directionBackwards && (e = 1 - e);
				c.currentFrame !== c.lastFrame ? (this.morphTargetInfluences[c.currentFrame] = e * m, this.morphTargetInfluences[c.lastFrame] = (1 - e) * m) : this.morphTargetInfluences[c.currentFrame] = m;
			}
		}
	};
	kd.prototype = Object.create(X.prototype);
	kd.prototype.constructor = kd;
	kd.prototype.isImmediateRenderObject = !0;
	ld.prototype = Object.create(ta.prototype);
	ld.prototype.constructor = ld;
	ld.prototype.update = function() {
		var a = new g, b = new g, c = new ya;
		return function() {
			var d = ["a", "b", "c"];
			this.object.updateMatrixWorld(!0);
			c.getNormalMatrix(this.object.matrixWorld);
			var e = this.object.matrixWorld, g = this.geometry.attributes.position, m = this.object.geometry;
			if (m && m.isGeometry) {
				for (var h = m.vertices, k = m.faces, q = m = 0, n = k.length;q < n;q++) {
					for (var f = k[q], p = 0, r = f.vertexNormals.length;p < r;p++) {
						var u = f.vertexNormals[p];
						a.copy(h[f[d[p]]]).applyMatrix4(e);
						b.copy(u).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
						g.setXYZ(m, a.x, a.y, a.z);
						m += 1;
						g.setXYZ(m, b.x, b.y, b.z);
						m += 1;
					}
				}
			} else {
				if (m && m.isBufferGeometry) {
					for (d = m.attributes.position, h = m.attributes.normal, p = m = 0, r = d.count;p < r;p++) {
						a.set(d.getX(p), d.getY(p), d.getZ(p)).applyMatrix4(e), b.set(h.getX(p), h.getY(p), h.getZ(p)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), g.setXYZ(m, a.x, a.y, a.z), m += 1, g.setXYZ(m, b.x, b.y, b.z), m += 1;
					}
				}
			}
			g.needsUpdate = !0;
			return this;
		};
	}();
	Ac.prototype = Object.create(X.prototype);
	Ac.prototype.constructor = Ac;
	Ac.prototype.dispose = function() {
		this.cone.geometry.dispose();
		this.cone.material.dispose();
	};
	Ac.prototype.update = function() {
		var a = new g, b = new g;
		return function() {
			var d = this.light.distance ? this.light.distance : 1E3, c = d * Math.tan(this.light.angle);
			this.cone.scale.set(c, c, d);
			a.setFromMatrixPosition(this.light.matrixWorld);
			b.setFromMatrixPosition(this.light.target.matrixWorld);
			this.cone.lookAt(b.sub(a));
			this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
		};
	}();
	Bc.prototype = Object.create(ta.prototype);
	Bc.prototype.constructor = Bc;
	Bc.prototype.getBoneList = function(a) {
		var d = [];
		a && a.isBone && d.push(a);
		for (var b = 0;b < a.children.length;b++) {
			d.push.apply(d, this.getBoneList(a.children[b]));
		}
		return d;
	};
	Bc.prototype.update = function() {
		var a = new g, b = new q, c = new q;
		return function() {
			var d = this.geometry, e = d.getAttribute("position");
			c.getInverse(this.root.matrixWorld);
			for (var g = 0, m = 0;g < this.bones.length;g++) {
				var h = this.bones[g];
				h.parent && h.parent.isBone && (b.multiplyMatrices(c, h.matrixWorld), a.setFromMatrixPosition(b), e.setXYZ(m, a.x, a.y, a.z), b.multiplyMatrices(c, h.parent.matrixWorld), a.setFromMatrixPosition(b), e.setXYZ(m + 1, a.x, a.y, a.z), m += 2);
			}
			d.getAttribute("position").needsUpdate = !0;
		};
	}();
	Cc.prototype = Object.create(Da.prototype);
	Cc.prototype.constructor = Cc;
	Cc.prototype.dispose = function() {
		this.geometry.dispose();
		this.material.dispose();
	};
	Cc.prototype.update = function() {
		this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
	};
	Dc.prototype = Object.create(X.prototype);
	Dc.prototype.constructor = Dc;
	Dc.prototype.dispose = function() {
		this.children[0].geometry.dispose();
		this.children[0].material.dispose();
		this.children[1].geometry.dispose();
		this.children[1].material.dispose();
	};
	Dc.prototype.update = function() {
		var a = new g, b = new g;
		return function() {
			var d = this.children[0], c = this.children[1];
			if (this.light.target) {
				a.setFromMatrixPosition(this.light.matrixWorld);
				b.setFromMatrixPosition(this.light.target.matrixWorld);
				var e = b.clone().sub(a);
				d.lookAt(e);
				c.lookAt(e);
			}
			d.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
			c.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
			var c = .5 * this.light.width, e = .5 * this.light.height, d = d.geometry.getAttribute("position"), g = d.array;
			g[0] = c;
			g[1] = -e;
			g[2] = 0;
			g[3] = c;
			g[4] = e;
			g[5] = 0;
			g[6] = -c;
			g[7] = e;
			g[8] = 0;
			g[9] = -c;
			g[10] = e;
			g[11] = 0;
			g[12] = -c;
			g[13] = -e;
			g[14] = 0;
			g[15] = c;
			g[16] = -e;
			g[17] = 0;
			d.needsUpdate = !0;
		};
	}();
	Ec.prototype = Object.create(X.prototype);
	Ec.prototype.constructor = Ec;
	Ec.prototype.dispose = function() {
		this.children[0].geometry.dispose();
		this.children[0].material.dispose();
	};
	Ec.prototype.update = function() {
		var a = new g, b = new T, c = new T;
		return function() {
			var d = this.children[0], e = d.geometry.getAttribute("color");
			b.copy(this.light.color).multiplyScalar(this.light.intensity);
			c.copy(this.light.groundColor).multiplyScalar(this.light.intensity);
			for (var g = 0, m = e.count;g < m;g++) {
				var h = g < m / 2 ? b : c;
				e.setXYZ(g, h.r, h.g, h.b);
			}
			d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
			e.needsUpdate = !0;
		};
	}();
	md.prototype = Object.create(ta.prototype);
	md.prototype.constructor = md;
	Qd.prototype = Object.create(ta.prototype);
	Qd.prototype.constructor = Qd;
	nd.prototype = Object.create(ta.prototype);
	nd.prototype.constructor = nd;
	nd.prototype.update = function() {
		var a = new g, b = new g, c = new ya;
		return function() {
			this.object.updateMatrixWorld(!0);
			c.getNormalMatrix(this.object.matrixWorld);
			for (var d = this.object.matrixWorld, e = this.geometry.attributes.position, g = this.object.geometry, m = g.vertices, g = g.faces, h = 0, k = 0, q = g.length;k < q;k++) {
				var n = g[k], f = n.normal;
				a.copy(m[n.a]).add(m[n.b]).add(m[n.c]).divideScalar(3).applyMatrix4(d);
				b.copy(f).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
				e.setXYZ(h, a.x, a.y, a.z);
				h += 1;
				e.setXYZ(h, b.x, b.y, b.z);
				h += 1;
			}
			e.needsUpdate = !0;
			return this;
		};
	}();
	Fc.prototype = Object.create(X.prototype);
	Fc.prototype.constructor = Fc;
	Fc.prototype.dispose = function() {
		var a = this.children[0], b = this.children[1];
		a.geometry.dispose();
		a.material.dispose();
		b.geometry.dispose();
		b.material.dispose();
	};
	Fc.prototype.update = function() {
		var a = new g, b = new g, c = new g;
		return function() {
			a.setFromMatrixPosition(this.light.matrixWorld);
			b.setFromMatrixPosition(this.light.target.matrixWorld);
			c.subVectors(b, a);
			var d = this.children[0], e = this.children[1];
			d.lookAt(c);
			d.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
			e.lookAt(c);
			e.scale.z = c.length();
		};
	}();
	od.prototype = Object.create(ta.prototype);
	od.prototype.constructor = od;
	od.prototype.update = function() {
		function a(a, d, g, h) {
			e.set(d, g, h).unproject(m);
			a = c[a];
			if (void 0 !== a) {
				for (d = b.getAttribute("position"), g = 0, h = a.length;g < h;g++) {
					d.setXYZ(a[g], e.x, e.y, e.z);
				}
			}
		}
		var b, c, e = new g, m = new xa;
		return function() {
			b = this.geometry;
			c = this.pointMap;
			m.projectionMatrix.copy(this.camera.projectionMatrix);
			a("c", 0, 0, -1);
			a("t", 0, 0, 1);
			a("n1", -1, -1, -1);
			a("n2", 1, -1, -1);
			a("n3", -1, 1, -1);
			a("n4", 1, 1, -1);
			a("f1", -1, -1, 1);
			a("f2", 1, -1, 1);
			a("f3", -1, 1, 1);
			a("f4", 1, 1, 1);
			a("u1", .7, 1.1, -1);
			a("u2", -.7, 1.1, -1);
			a("u3", 0, 2, -1);
			a("cf1", -1, 0, 1);
			a("cf2", 1, 0, 1);
			a("cf3", 0, -1, 1);
			a("cf4", 0, 1, 1);
			a("cn1", -1, 0, -1);
			a("cn2", 1, 0, -1);
			a("cn3", 0, -1, -1);
			a("cn4", 0, 1, -1);
			b.getAttribute("position").needsUpdate = !0;
		};
	}();
	Gc.prototype = Object.create(ta.prototype);
	Gc.prototype.constructor = Gc;
	Gc.prototype.update = function() {
		var a = new Ba;
		return function(d) {
			d && d.isBox3 ? a.copy(d) : a.setFromObject(d);
			if (!a.isEmpty()) {
				d = a.min;
				var b = a.max, c = this.geometry.attributes.position, e = c.array;
				e[0] = b.x;
				e[1] = b.y;
				e[2] = b.z;
				e[3] = d.x;
				e[4] = b.y;
				e[5] = b.z;
				e[6] = d.x;
				e[7] = d.y;
				e[8] = b.z;
				e[9] = b.x;
				e[10] = d.y;
				e[11] = b.z;
				e[12] = b.x;
				e[13] = b.y;
				e[14] = d.z;
				e[15] = d.x;
				e[16] = b.y;
				e[17] = d.z;
				e[18] = d.x;
				e[19] = d.y;
				e[20] = d.z;
				e[21] = b.x;
				e[22] = d.y;
				e[23] = d.z;
				c.needsUpdate = !0;
				this.geometry.computeBoundingSphere();
			}
		};
	}();
	var He = new ca;
	He.addAttribute("position", new la([0, 0, 0, 0, 1, 0], 3));
	var Ie = new ub(0, .5, 1, 5, 1);
	Ie.translate(0, -.5, 0);
	Vb.prototype = Object.create(X.prototype);
	Vb.prototype.constructor = Vb;
	Vb.prototype.setDirection = function() {
		var a = new g, b;
		return function(d) {
			.99999 < d.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > d.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(d.z, 0, -d.x).normalize(), b = Math.acos(d.y), this.quaternion.setFromAxisAngle(a, b));
		};
	}();
	Vb.prototype.setLength = function(a, b, c) {
		void 0 === b && (b = .2 * a);
		void 0 === c && (c = .2 * b);
		this.line.scale.set(1, Math.max(0, a - b), 1);
		this.line.updateMatrix();
		this.cone.scale.set(c, b, c);
		this.cone.position.y = a;
		this.cone.updateMatrix();
	};
	Vb.prototype.setColor = function(a) {
		this.line.material.color.copy(a);
		this.cone.material.color.copy(a);
	};
	Rd.prototype = Object.create(ta.prototype);
	Rd.prototype.constructor = Rd;
	var te = function() {
		function a() {
		}
		var b = new g, c = new a, e = new a, m = new a;
		a.prototype.init = function(a, d, b, c) {
			this.c0 = a;
			this.c1 = b;
			this.c2 = -3 * a + 3 * d - 2 * b - c;
			this.c3 = 2 * a - 2 * d + b + c;
		};
		a.prototype.initNonuniformCatmullRom = function(a, d, b, c, e, g, m) {
			this.init(d, b, ((d - a) / e - (b - a) / (e + g) + (b - d) / g) * g, ((b - d) / g - (c - d) / (g + m) + (c - b) / m) * g);
		};
		a.prototype.initCatmullRom = function(a, d, b, c, e) {
			this.init(d, b, e * (b - a), e * (c - d));
		};
		a.prototype.calc = function(a) {
			var d = a * a;
			return this.c0 + this.c1 * a + this.c2 * d + this.c3 * d * a;
		};
		return Na.create(function(a) {
			this.points = a || [];
			this.closed = !1;
		}, function(a) {
			var d = this.points, h, k;
			k = d.length;
			2 > k && console.log("duh, you need at least 2 points");
			a *= k - (this.closed ? 0 : 1);
			h = Math.floor(a);
			a -= h;
			this.closed ? h += 0 < h ? 0 : (Math.floor(Math.abs(h) / d.length) + 1) * d.length : 0 === a && h === k - 1 && (h = k - 2, a = 1);
			var q, n, f;
			this.closed || 0 < h ? q = d[(h - 1) % k] : (b.subVectors(d[0], d[1]).add(d[0]), q = b);
			n = d[h % k];
			f = d[(h + 1) % k];
			this.closed || h + 2 < k ? d = d[(h + 2) % k] : (b.subVectors(d[k - 1], d[k - 2]).add(d[k - 1]), d = b);
			if (void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
				var p = "chordal" === this.type ? .5 : .25;
				k = Math.pow(q.distanceToSquared(n), p);
				h = Math.pow(n.distanceToSquared(f), p);
				p = Math.pow(f.distanceToSquared(d), p);
				1E-4 > h && (h = 1);
				1E-4 > k && (k = h);
				1E-4 > p && (p = h);
				c.initNonuniformCatmullRom(q.x, n.x, f.x, d.x, k, h, p);
				e.initNonuniformCatmullRom(q.y, n.y, f.y, d.y, k, h, p);
				m.initNonuniformCatmullRom(q.z, n.z, f.z, d.z, k, h, p);
			} else {
				"catmullrom" === this.type && (k = void 0 !== this.tension ? this.tension : .5, c.initCatmullRom(q.x, n.x, f.x, d.x, k), e.initCatmullRom(q.y, n.y, f.y, d.y, k), m.initCatmullRom(q.z, n.z, f.z, d.z, k));
			}
			return new g(c.calc(a), e.calc(a), m.calc(a));
		});
	}(), ef = Na.create(function(a) {
		console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3");
		this.points = void 0 === a ? [] : a;
	}, function(a) {
		var d = this.points;
		a *= d.length - 1;
		var b = Math.floor(a);
		a -= b;
		var c = d[0 == b ? b : b - 1], e = d[b], m = d[b > d.length - 2 ? d.length - 1 : b + 1], d = d[b > d.length - 3 ? d.length - 1 : b + 2], b = pd.interpolate;
		return new g(b(c.x, e.x, m.x, d.x, a), b(c.y, e.y, m.y, d.y, a), b(c.z, e.z, m.z, d.z, a));
	}), ff = Na.create(function(a, b, c, e) {
		this.v0 = a;
		this.v1 = b;
		this.v2 = c;
		this.v3 = e;
	}, function(a) {
		var d = Ea.b3;
		return new g(d(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), d(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y), d(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z));
	}), gf = Na.create(function(a, b, c) {
		this.v0 = a;
		this.v1 = b;
		this.v2 = c;
	}, function(a) {
		var d = Ea.b2;
		return new g(d(a, this.v0.x, this.v1.x, this.v2.x), d(a, this.v0.y, this.v1.y, this.v2.y), d(a, this.v0.z, this.v1.z, this.v2.z));
	}), hf = Na.create(function(a, b) {
		this.v1 = a;
		this.v2 = b;
	}, function(a) {
		if (1 === a) {
			return this.v2.clone();
		}
		var d = new g;
		d.subVectors(this.v2, this.v1);
		d.multiplyScalar(a);
		d.add(this.v1);
		return d;
	});
	Sd.prototype = Object.create(vb.prototype);
	Sd.prototype.constructor = Sd;
	Je.prototype = Object.create(te.prototype);
	md.prototype.setColors = function() {
		console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
	};
	Object.assign(ra.prototype, {center:function(a) {
		console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
		return this.getCenter(a);
	}, empty:function() {
		console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
		return this.isEmpty();
	}, isIntersectionBox:function(a) {
		console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
		return this.intersectsBox(a);
	}, size:function(a) {
		console.warn("THREE.Box2: .size() has been renamed to .getSize().");
		return this.getSize(a);
	}});
	Object.assign(Ba.prototype, {center:function(a) {
		console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
		return this.getCenter(a);
	}, empty:function() {
		console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
		return this.isEmpty();
	}, isIntersectionBox:function(a) {
		console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
		return this.intersectsBox(a);
	}, isIntersectionSphere:function(a) {
		console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
		return this.intersectsSphere(a);
	}, size:function(a) {
		console.warn("THREE.Box3: .size() has been renamed to .getSize().");
		return this.getSize(a);
	}});
	qb.prototype.center = function(a) {
		console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
		return this.getCenter(a);
	};
	da.random16 = function() {
		console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead.");
		return Math.random();
	};
	Object.assign(ya.prototype, {flattenToArrayOffset:function(a, b) {
		console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
		return this.toArray(a, b);
	}, multiplyVector3:function(a) {
		console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
		return a.applyMatrix3(this);
	}, multiplyVector3Array:function(a) {
		console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
		return this.applyToVector3Array(a);
	}});
	Object.assign(q.prototype, {extractPosition:function(a) {
		console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
		return this.copyPosition(a);
	}, flattenToArrayOffset:function(a, b) {
		console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
		return this.toArray(a, b);
	}, getPosition:function() {
		var a;
		return function() {
			void 0 === a && (a = new g);
			console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
			return a.setFromMatrixColumn(this, 3);
		};
	}(), setRotationFromQuaternion:function(a) {
		console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
		return this.makeRotationFromQuaternion(a);
	}, multiplyVector3:function(a) {
		console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
		return a.applyProjection(this);
	}, multiplyVector4:function(a) {
		console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
		return a.applyMatrix4(this);
	}, multiplyVector3Array:function(a) {
		console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
		return this.applyToVector3Array(a);
	}, rotateAxis:function(a) {
		console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
		a.transformDirection(this);
	}, crossVector:function(a) {
		console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
		return a.applyMatrix4(this);
	}, translate:function() {
		console.error("THREE.Matrix4: .translate() has been removed.");
	}, rotateX:function() {
		console.error("THREE.Matrix4: .rotateX() has been removed.");
	}, rotateY:function() {
		console.error("THREE.Matrix4: .rotateY() has been removed.");
	}, rotateZ:function() {
		console.error("THREE.Matrix4: .rotateZ() has been removed.");
	}, rotateByAxis:function() {
		console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
	}});
	wa.prototype.isIntersectionLine = function(a) {
		console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
		return this.intersectsLine(a);
	};
	e.prototype.multiplyVector3 = function(a) {
		console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
		return a.applyQuaternion(this);
	};
	Object.assign(jb.prototype, {isIntersectionBox:function(a) {
		console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
		return this.intersectsBox(a);
	}, isIntersectionPlane:function(a) {
		console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
		return this.intersectsPlane(a);
	}, isIntersectionSphere:function(a) {
		console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
		return this.intersectsSphere(a);
	}});
	Object.assign(Tb.prototype, {extrude:function(a) {
		console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
		return new eb(this, a);
	}, makeGeometry:function(a) {
		console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
		return new oc(this, a);
	}});
	Object.assign(g.prototype, {setEulerFromRotationMatrix:function() {
		console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
	}, setEulerFromQuaternion:function() {
		console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
	}, getPositionFromMatrix:function(a) {
		console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
		return this.setFromMatrixPosition(a);
	}, getScaleFromMatrix:function(a) {
		console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
		return this.setFromMatrixScale(a);
	}, getColumnFromMatrix:function(a, b) {
		console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
		return this.setFromMatrixColumn(b, a);
	}});
	ja.prototype.computeTangents = function() {
		console.warn("THREE.Geometry: .computeTangents() has been removed.");
	};
	Object.assign(X.prototype, {getChildByName:function(a) {
		console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
		return this.getObjectByName(a);
	}, renderDepth:function() {
		console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
	}, translate:function(a, b) {
		console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
		return this.translateOnAxis(b, a);
	}});
	Object.defineProperties(X.prototype, {eulerOrder:{get:function() {
		console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
		return this.rotation.order;
	}, set:function(a) {
		console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
		this.rotation.order = a;
	}}, useQuaternion:{get:function() {
		console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
	}, set:function() {
		console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
	}}});
	Object.defineProperties(Lc.prototype, {objects:{get:function() {
		console.warn("THREE.LOD: .objects has been renamed to .levels.");
		return this.levels;
	}}});
	Oa.prototype.setLens = function(a, b) {
		console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
		void 0 !== b && (this.filmGauge = b);
		this.setFocalLength(a);
	};
	Object.defineProperties(Aa.prototype, {onlyShadow:{set:function() {
		console.warn("THREE.Light: .onlyShadow has been removed.");
	}}, shadowCameraFov:{set:function(a) {
		console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
		this.shadow.camera.fov = a;
	}}, shadowCameraLeft:{set:function(a) {
		console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
		this.shadow.camera.left = a;
	}}, shadowCameraRight:{set:function(a) {
		console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
		this.shadow.camera.right = a;
	}}, shadowCameraTop:{set:function(a) {
		console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
		this.shadow.camera.top = a;
	}}, shadowCameraBottom:{set:function(a) {
		console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
		this.shadow.camera.bottom = a;
	}}, shadowCameraNear:{set:function(a) {
		console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
		this.shadow.camera.near = a;
	}}, shadowCameraFar:{set:function(a) {
		console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
		this.shadow.camera.far = a;
	}}, shadowCameraVisible:{set:function() {
		console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
	}}, shadowBias:{set:function(a) {
		console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
		this.shadow.bias = a;
	}}, shadowDarkness:{set:function() {
		console.warn("THREE.Light: .shadowDarkness has been removed.");
	}}, shadowMapWidth:{set:function(a) {
		console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
		this.shadow.mapSize.width = a;
	}}, shadowMapHeight:{set:function(a) {
		console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
		this.shadow.mapSize.height = a;
	}}});
	Object.defineProperties(U.prototype, {length:{get:function() {
		console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
		return this.array.length;
	}}});
	Object.assign(ca.prototype, {addIndex:function(a) {
		console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
		this.setIndex(a);
	}, addDrawCall:function(a, b, c) {
		void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
		console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
		this.addGroup(a, b);
	}, clearDrawCalls:function() {
		console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
		this.clearGroups();
	}, computeTangents:function() {
		console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
	}, computeOffsets:function() {
		console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
	}});
	Object.defineProperties(ca.prototype, {drawcalls:{get:function() {
		console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
		return this.groups;
	}}, offsets:{get:function() {
		console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
		return this.groups;
	}}});
	Object.defineProperties(Pd.prototype, {dynamic:{set:function() {
		console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
	}}, onUpdate:{value:function() {
		console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
		return this;
	}}});
	Object.defineProperties(Z.prototype, {wrapAround:{get:function() {
		console.warn("THREE." + this.type + ": .wrapAround has been removed.");
	}, set:function() {
		console.warn("THREE." + this.type + ": .wrapAround has been removed.");
	}}, wrapRGB:{get:function() {
		console.warn("THREE." + this.type + ": .wrapRGB has been removed.");
		return new T;
	}}});
	Object.defineProperties(hb.prototype, {metal:{get:function() {
		console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
		return !1;
	}, set:function() {
		console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
	}}});
	Object.defineProperties(ua.prototype, {derivatives:{get:function() {
		console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
		return this.extensions.derivatives;
	}, set:function(a) {
		console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
		this.extensions.derivatives = a;
	}}});
	f.prototype = Object.assign(Object.create({constructor:f, apply:function(a) {
		console.warn("THREE.EventDispatcher: .apply is deprecated, just inherit or Object.assign the prototype to mix-in.");
		Object.assign(a, this);
	}}), f.prototype);
	Object.assign(Xd.prototype, {supportsFloatTextures:function() {
		console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
		return this.extensions.get("OES_texture_float");
	}, supportsHalfFloatTextures:function() {
		console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
		return this.extensions.get("OES_texture_half_float");
	}, supportsStandardDerivatives:function() {
		console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
		return this.extensions.get("OES_standard_derivatives");
	}, supportsCompressedTextureS3TC:function() {
		console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
		return this.extensions.get("WEBGL_compressed_texture_s3tc");
	}, supportsCompressedTexturePVRTC:function() {
		console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
		return this.extensions.get("WEBGL_compressed_texture_pvrtc");
	}, supportsBlendMinMax:function() {
		console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
		return this.extensions.get("EXT_blend_minmax");
	}, supportsVertexTextures:function() {
		console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
		return this.capabilities.vertexTextures;
	}, supportsInstancedArrays:function() {
		console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
		return this.extensions.get("ANGLE_instanced_arrays");
	}, enableScissorTest:function(a) {
		console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
		this.setScissorTest(a);
	}, initMaterial:function() {
		console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
	}, addPrePlugin:function() {
		console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
	}, addPostPlugin:function() {
		console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
	}, updateShadowMap:function() {
		console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
	}});
	Object.defineProperties(Xd.prototype, {shadowMapEnabled:{get:function() {
		return this.shadowMap.enabled;
	}, set:function(a) {
		console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
		this.shadowMap.enabled = a;
	}}, shadowMapType:{get:function() {
		return this.shadowMap.type;
	}, set:function(a) {
		console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
		this.shadowMap.type = a;
	}}, shadowMapCullFace:{get:function() {
		return this.shadowMap.cullFace;
	}, set:function(a) {
		console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.");
		this.shadowMap.cullFace = a;
	}}});
	Object.defineProperties(rd.prototype, {cullFace:{get:function() {
		return this.renderReverseSided ? 2 : 1;
	}, set:function(a) {
		a = 1 !== a;
		console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + a + ".");
		this.renderReverseSided = a;
	}}});
	Object.defineProperties(h.prototype, {wrapS:{get:function() {
		console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
		return this.texture.wrapS;
	}, set:function(a) {
		console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
		this.texture.wrapS = a;
	}}, wrapT:{get:function() {
		console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
		return this.texture.wrapT;
	}, set:function(a) {
		console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
		this.texture.wrapT = a;
	}}, magFilter:{get:function() {
		console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
		return this.texture.magFilter;
	}, set:function(a) {
		console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
		this.texture.magFilter = a;
	}}, minFilter:{get:function() {
		console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
		return this.texture.minFilter;
	}, set:function(a) {
		console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
		this.texture.minFilter = a;
	}}, anisotropy:{get:function() {
		console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
		return this.texture.anisotropy;
	}, set:function(a) {
		console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
		this.texture.anisotropy = a;
	}}, offset:{get:function() {
		console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
		return this.texture.offset;
	}, set:function(a) {
		console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
		this.texture.offset = a;
	}}, repeat:{get:function() {
		console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
		return this.texture.repeat;
	}, set:function(a) {
		console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
		this.texture.repeat = a;
	}}, format:{get:function() {
		console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
		return this.texture.format;
	}, set:function(a) {
		console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
		this.texture.format = a;
	}}, type:{get:function() {
		console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
		return this.texture.type;
	}, set:function(a) {
		console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
		this.texture.type = a;
	}}, generateMipmaps:{get:function() {
		console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
		return this.texture.generateMipmaps;
	}, set:function(a) {
		console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
		this.texture.generateMipmaps = a;
	}}});
	wc.prototype.load = function(a) {
		console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
		var d = this;
		(new fe).load(a, function(a) {
			d.setBuffer(a);
		});
		return this;
	};
	ke.prototype.getData = function() {
		console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
		return this.getFrequencyData();
	};
	a.WebGLRenderTargetCube = c;
	a.WebGLRenderTarget = h;
	a.WebGLRenderer = Xd;
	a.ShaderLib = Wb;
	a.UniformsLib = na;
	a.ShaderChunk = ka;
	a.FogExp2 = $b;
	a.Fog = ac;
	a.Scene = Cb;
	a.LensFlare = Yd;
	a.Sprite = Kc;
	a.LOD = Lc;
	a.SkinnedMesh = vd;
	a.Skeleton = td;
	a.Bone = ud;
	a.Mesh = Da;
	a.LineSegments = ta;
	a.Line = tb;
	a.Points = bc;
	a.Group = Mc;
	a.VideoTexture = wd;
	a.DataTexture = pa;
	a.CompressedTexture = cc;
	a.CubeTexture = r;
	a.CanvasTexture = xd;
	a.DepthTexture = Nc;
	a.Texture = b;
	a.CompressedTextureLoader = Ce;
	a.BinaryTextureLoader = $d;
	a.DataTextureLoader = $d;
	a.CubeTextureLoader = ae;
	a.TextureLoader = yd;
	a.ObjectLoader = De;
	a.MaterialLoader = Md;
	a.BufferGeometryLoader = be;
	a.DefaultLoadingManager = $a;
	a.LoadingManager = Zd;
	a.JSONLoader = ce;
	a.ImageLoader = fd;
	a.FontLoader = Ee;
	a.FileLoader = fb;
	a.Loader = Pb;
	a.Cache = we;
	a.AudioLoader = fe;
	a.SpotLightShadow = Ad;
	a.SpotLight = Bd;
	a.PointLight = Cd;
	a.RectAreaLight = ge;
	a.HemisphereLight = zd;
	a.DirectionalLightShadow = Dd;
	a.DirectionalLight = Ed;
	a.AmbientLight = Fd;
	a.LightShadow = Mb;
	a.Light = Aa;
	a.StereoCamera = Fe;
	a.PerspectiveCamera = Oa;
	a.OrthographicCamera = Yb;
	a.CubeCamera = Nd;
	a.Camera = xa;
	a.AudioListener = he;
	a.PositionalAudio = je;
	a.AudioContext = ie;
	a.AudioAnalyser = ke;
	a.Audio = wc;
	a.VectorKeyframeTrack = uc;
	a.StringKeyframeTrack = Jd;
	a.QuaternionKeyframeTrack = hd;
	a.NumberKeyframeTrack = vc;
	a.ColorKeyframeTrack = Ld;
	a.BooleanKeyframeTrack = Kd;
	a.PropertyMixer = Od;
	a.PropertyBinding = Ha;
	a.KeyframeTrack = Ob;
	a.AnimationUtils = Ma;
	a.AnimationObjectGroup = le;
	a.AnimationMixer = ne;
	a.AnimationClip = ab;
	a.Uniform = Pd;
	a.InstancedBufferGeometry = Ub;
	a.BufferGeometry = ca;
	a.GeometryIdCount = function() {
		return Wd++;
	};
	a.Geometry = ja;
	a.InterleavedBufferAttribute = oe;
	a.InstancedInterleavedBuffer = yc;
	a.InterleavedBuffer = xc;
	a.InstancedBufferAttribute = zc;
	a.Face3 = Ja;
	a.Object3D = X;
	a.Raycaster = pe;
	a.Layers = Xb;
	a.EventDispatcher = f;
	a.Clock = re;
	a.QuaternionLinearInterpolant = Id;
	a.LinearInterpolant = gd;
	a.DiscreteInterpolant = Hd;
	a.CubicInterpolant = Gd;
	a.Interpolant = Xa;
	a.Triangle = Ia;
	a.Spline = function(a) {
		function d(a, d, b, c, e, g, m) {
			a = .5 * (b - a);
			c = .5 * (c - d);
			return (2 * (d - b) + a + c) * m + (-3 * (d - b) - 2 * a - c) * g + a * e + d;
		}
		this.points = a;
		var b = [], c = {x:0, y:0, z:0}, e, m, h, k, q, f, p, r, u;
		this.initFromArray = function(a) {
			this.points = [];
			for (var d = 0;d < a.length;d++) {
				this.points[d] = {x:a[d][0], y:a[d][1], z:a[d][2]};
			}
		};
		this.getPoint = function(a) {
			e = (this.points.length - 1) * a;
			m = Math.floor(e);
			h = e - m;
			b[0] = 0 === m ? m : m - 1;
			b[1] = m;
			b[2] = m > this.points.length - 2 ? this.points.length - 1 : m + 1;
			b[3] = m > this.points.length - 3 ? this.points.length - 1 : m + 2;
			f = this.points[b[0]];
			p = this.points[b[1]];
			r = this.points[b[2]];
			u = this.points[b[3]];
			k = h * h;
			q = h * k;
			c.x = d(f.x, p.x, r.x, u.x, h, k, q);
			c.y = d(f.y, p.y, r.y, u.y, h, k, q);
			c.z = d(f.z, p.z, r.z, u.z, h, k, q);
			return c;
		};
		this.getControlPointsArray = function() {
			var a, d, b = this.points.length, c = [];
			for (a = 0;a < b;a++) {
				d = this.points[a], c[a] = [d.x, d.y, d.z];
			}
			return c;
		};
		this.getLength = function(a) {
			var d, b, c, e = 0, m = new g, h = new g, k = [], q = 0;
			k[0] = 0;
			a || (a = 100);
			b = this.points.length * a;
			m.copy(this.points[0]);
			for (a = 1;a < b;a++) {
				d = a / b, c = this.getPoint(d), h.copy(c), q += h.distanceTo(m), m.copy(c), d *= this.points.length - 1, d = Math.floor(d), d !== e && (k[d] = q, e = d);
			}
			k[k.length] = q;
			return {chunks:k, total:q};
		};
		this.reparametrizeByArcLength = function(a) {
			var d, b, c, e, m, h, k = [], q = new g, n = this.getLength();
			k.push(q.copy(this.points[0]).clone());
			for (d = 1;d < this.points.length;d++) {
				b = n.chunks[d] - n.chunks[d - 1];
				h = Math.ceil(a * b / n.total);
				e = (d - 1) / (this.points.length - 1);
				m = d / (this.points.length - 1);
				for (b = 1;b < h - 1;b++) {
					c = e + 1 / h * b * (m - e), c = this.getPoint(c), k.push(q.copy(c).clone());
				}
				k.push(q.copy(this.points[d]).clone());
			}
			this.points = k;
		};
	};
	a.Math = da;
	a.Spherical = se;
	a.Plane = wa;
	a.Frustum = Sa;
	a.Sphere = Ca;
	a.Ray = jb;
	a.Matrix4 = q;
	a.Matrix3 = ya;
	a.Box3 = Ba;
	a.Box2 = ra;
	a.Line3 = qb;
	a.Euler = kb;
	a.Vector4 = k;
	a.Vector3 = g;
	a.Vector2 = l;
	a.Quaternion = e;
	a.Color = T;
	a.MorphBlendMesh = Ka;
	a.ImmediateRenderObject = kd;
	a.VertexNormalsHelper = ld;
	a.SpotLightHelper = Ac;
	a.SkeletonHelper = Bc;
	a.PointLightHelper = Cc;
	a.RectAreaLightHelper = Dc;
	a.HemisphereLightHelper = Ec;
	a.GridHelper = md;
	a.PolarGridHelper = Qd;
	a.FaceNormalsHelper = nd;
	a.DirectionalLightHelper = Fc;
	a.CameraHelper = od;
	a.BoxHelper = Gc;
	a.ArrowHelper = Vb;
	a.AxisHelper = Rd;
	a.CatmullRomCurve3 = te;
	a.SplineCurve3 = ef;
	a.CubicBezierCurve3 = ff;
	a.QuadraticBezierCurve3 = gf;
	a.LineCurve3 = hf;
	a.ArcCurve = Sd;
	a.EllipseCurve = vb;
	a.SplineCurve = Qb;
	a.CubicBezierCurve = Rb;
	a.QuadraticBezierCurve = Sb;
	a.LineCurve = pb;
	a.Shape = Tb;
	a.ShapePath = de;
	a.Path = jd;
	a.Font = ee;
	a.CurvePath = id;
	a.Curve = Na;
	a.ShapeUtils = Ea;
	a.SceneUtils = {createMultiMaterialObject:function(a, b) {
		for (var d = new Mc, c = 0, e = b.length;c < e;c++) {
			d.add(new Da(a, b[c]));
		}
		return d;
	}, detach:function(a, b, c) {
		a.applyMatrix(b.matrixWorld);
		b.remove(a);
		c.add(a);
	}, attach:function(a, b, c) {
		var d = new q;
		d.getInverse(c.matrixWorld);
		a.applyMatrix(d);
		b.remove(a);
		c.add(a);
	}};
	a.CurveUtils = pd;
	a.WireframeGeometry = dc;
	a.ParametricGeometry = Oc;
	a.ParametricBufferGeometry = ec;
	a.TetrahedronGeometry = Pc;
	a.TetrahedronBufferGeometry = fc;
	a.OctahedronGeometry = Qc;
	a.OctahedronBufferGeometry = Eb;
	a.IcosahedronGeometry = Rc;
	a.IcosahedronBufferGeometry = gc;
	a.DodecahedronGeometry = Sc;
	a.DodecahedronBufferGeometry = hc;
	a.PolyhedronGeometry = Tc;
	a.PolyhedronBufferGeometry = Wa;
	a.TubeGeometry = Uc;
	a.TubeBufferGeometry = ic;
	a.TorusKnotGeometry = Vc;
	a.TorusKnotBufferGeometry = jc;
	a.TorusGeometry = Wc;
	a.TorusBufferGeometry = kc;
	a.TextGeometry = Xc;
	a.SphereBufferGeometry = Fb;
	a.SphereGeometry = Yc;
	a.RingGeometry = Zc;
	a.RingBufferGeometry = lc;
	a.PlaneBufferGeometry = Ra;
	a.PlaneGeometry = $c;
	a.LatheGeometry = ad;
	a.LatheBufferGeometry = mc;
	a.ShapeGeometry = oc;
	a.ShapeBufferGeometry = nc;
	a.ExtrudeGeometry = eb;
	a.EdgesGeometry = pc;
	a.ConeGeometry = bd;
	a.ConeBufferGeometry = cd;
	a.CylinderGeometry = Gb;
	a.CylinderBufferGeometry = ub;
	a.CircleBufferGeometry = qc;
	a.CircleGeometry = dd;
	a.BoxBufferGeometry = mb;
	a.BoxGeometry = rc;
	a.ShadowMaterial = sc;
	a.SpriteMaterial = Db;
	a.RawShaderMaterial = tc;
	a.ShaderMaterial = ua;
	a.PointsMaterial = gb;
	a.MultiMaterial = ed;
	a.MeshPhysicalMaterial = Hb;
	a.MeshStandardMaterial = ob;
	a.MeshPhongMaterial = hb;
	a.MeshToonMaterial = Ib;
	a.MeshNormalMaterial = Jb;
	a.MeshLambertMaterial = Kb;
	a.MeshDepthMaterial = sa;
	a.MeshBasicMaterial = La;
	a.LineDashedMaterial = Lb;
	a.LineBasicMaterial = za;
	a.Material = Z;
	a.Float64BufferAttribute = sb;
	a.Float32BufferAttribute = la;
	a.Uint32BufferAttribute = cb;
	a.Int32BufferAttribute = bb;
	a.Uint16BufferAttribute = Ta;
	a.Int16BufferAttribute = xb;
	a.Uint8ClampedBufferAttribute = Za;
	a.Uint8BufferAttribute = lb;
	a.Int8BufferAttribute = rb;
	a.BufferAttribute = U;
	a.REVISION = "83dev";
	a.MOUSE = {LEFT:0, MIDDLE:1, RIGHT:2};
	a.CullFaceNone = 0;
	a.CullFaceBack = 1;
	a.CullFaceFront = 2;
	a.CullFaceFrontBack = 3;
	a.FrontFaceDirectionCW = 0;
	a.FrontFaceDirectionCCW = 1;
	a.BasicShadowMap = 0;
	a.PCFShadowMap = 1;
	a.PCFSoftShadowMap = 2;
	a.FrontSide = 0;
	a.BackSide = 1;
	a.DoubleSide = 2;
	a.FlatShading = 1;
	a.SmoothShading = 2;
	a.NoColors = 0;
	a.FaceColors = 1;
	a.VertexColors = 2;
	a.NoBlending = 0;
	a.NormalBlending = 1;
	a.AdditiveBlending = 2;
	a.SubtractiveBlending = 3;
	a.MultiplyBlending = 4;
	a.CustomBlending = 5;
	a.BlendingMode = Ke;
	a.AddEquation = 100;
	a.SubtractEquation = 101;
	a.ReverseSubtractEquation = 102;
	a.MinEquation = 103;
	a.MaxEquation = 104;
	a.ZeroFactor = 200;
	a.OneFactor = 201;
	a.SrcColorFactor = 202;
	a.OneMinusSrcColorFactor = 203;
	a.SrcAlphaFactor = 204;
	a.OneMinusSrcAlphaFactor = 205;
	a.DstAlphaFactor = 206;
	a.OneMinusDstAlphaFactor = 207;
	a.DstColorFactor = 208;
	a.OneMinusDstColorFactor = 209;
	a.SrcAlphaSaturateFactor = 210;
	a.NeverDepth = 0;
	a.AlwaysDepth = 1;
	a.LessDepth = 2;
	a.LessEqualDepth = 3;
	a.EqualDepth = 4;
	a.GreaterEqualDepth = 5;
	a.GreaterDepth = 6;
	a.NotEqualDepth = 7;
	a.MultiplyOperation = 0;
	a.MixOperation = 1;
	a.AddOperation = 2;
	a.NoToneMapping = 0;
	a.LinearToneMapping = 1;
	a.ReinhardToneMapping = 2;
	a.Uncharted2ToneMapping = 3;
	a.CineonToneMapping = 4;
	a.UVMapping = 300;
	a.CubeReflectionMapping = 301;
	a.CubeRefractionMapping = 302;
	a.EquirectangularReflectionMapping = 303;
	a.EquirectangularRefractionMapping = 304;
	a.SphericalReflectionMapping = 305;
	a.CubeUVReflectionMapping = 306;
	a.CubeUVRefractionMapping = 307;
	a.TextureMapping = Le;
	a.RepeatWrapping = 1E3;
	a.ClampToEdgeWrapping = 1001;
	a.MirroredRepeatWrapping = 1002;
	a.TextureWrapping = ue;
	a.NearestFilter = 1003;
	a.NearestMipMapNearestFilter = 1004;
	a.NearestMipMapLinearFilter = 1005;
	a.LinearFilter = 1006;
	a.LinearMipMapNearestFilter = 1007;
	a.LinearMipMapLinearFilter = 1008;
	a.TextureFilter = ve;
	a.UnsignedByteType = 1009;
	a.ByteType = 1010;
	a.ShortType = 1011;
	a.UnsignedShortType = 1012;
	a.IntType = 1013;
	a.UnsignedIntType = 1014;
	a.FloatType = 1015;
	a.HalfFloatType = 1016;
	a.UnsignedShort4444Type = 1017;
	a.UnsignedShort5551Type = 1018;
	a.UnsignedShort565Type = 1019;
	a.UnsignedInt248Type = 1020;
	a.AlphaFormat = 1021;
	a.RGBFormat = 1022;
	a.RGBAFormat = 1023;
	a.LuminanceFormat = 1024;
	a.LuminanceAlphaFormat = 1025;
	a.RGBEFormat = 1023;
	a.DepthFormat = 1026;
	a.DepthStencilFormat = 1027;
	a.RGB_S3TC_DXT1_Format = 2001;
	a.RGBA_S3TC_DXT1_Format = 2002;
	a.RGBA_S3TC_DXT3_Format = 2003;
	a.RGBA_S3TC_DXT5_Format = 2004;
	a.RGB_PVRTC_4BPPV1_Format = 2100;
	a.RGB_PVRTC_2BPPV1_Format = 2101;
	a.RGBA_PVRTC_4BPPV1_Format = 2102;
	a.RGBA_PVRTC_2BPPV1_Format = 2103;
	a.RGB_ETC1_Format = 2151;
	a.LoopOnce = 2200;
	a.LoopRepeat = 2201;
	a.LoopPingPong = 2202;
	a.InterpolateDiscrete = 2300;
	a.InterpolateLinear = 2301;
	a.InterpolateSmooth = 2302;
	a.ZeroCurvatureEnding = 2400;
	a.ZeroSlopeEnding = 2401;
	a.WrapAroundEnding = 2402;
	a.TrianglesDrawMode = 0;
	a.TriangleStripDrawMode = 1;
	a.TriangleFanDrawMode = 2;
	a.LinearEncoding = 3E3;
	a.sRGBEncoding = 3001;
	a.GammaEncoding = 3007;
	a.RGBEEncoding = 3002;
	a.LogLuvEncoding = 3003;
	a.RGBM7Encoding = 3004;
	a.RGBM16Encoding = 3005;
	a.RGBDEncoding = 3006;
	a.BasicDepthPacking = 3200;
	a.RGBADepthPacking = 3201;
	a.CubeGeometry = rc;
	a.Face4 = function(a, b, c, e, g, m, h) {
		console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
		return new Ja(a, b, c, g, m, h);
	};
	a.LineStrip = 0;
	a.LinePieces = 1;
	a.MeshFaceMaterial = function(a) {
		console.warn("THREE.MeshFaceMaterial has been renamed to THREE.MultiMaterial.");
		return new ed(a);
	};
	a.PointCloud = function(a, b) {
		console.warn("THREE.PointCloud has been renamed to THREE.Points.");
		return new bc(a, b);
	};
	a.Particle = function(a) {
		console.warn("THREE.Particle has been renamed to THREE.Sprite.");
		return new Kc(a);
	};
	a.ParticleSystem = function(a, b) {
		console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
		return new bc(a, b);
	};
	a.PointCloudMaterial = function(a) {
		console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
		return new gb(a);
	};
	a.ParticleBasicMaterial = function(a) {
		console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
		return new gb(a);
	};
	a.ParticleSystemMaterial = function(a) {
		console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
		return new gb(a);
	};
	a.Vertex = function(a, b, c) {
		console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
		return new g(a, b, c);
	};
	a.DynamicBufferAttribute = function(a, b) {
		console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");
		return (new U(a, b)).setDynamic(!0);
	};
	a.Int8Attribute = function(a, b) {
		console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
		return new rb(a, b);
	};
	a.Uint8Attribute = function(a, b) {
		console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
		return new lb(a, b);
	};
	a.Uint8ClampedAttribute = function(a, b) {
		console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
		return new Za(a, b);
	};
	a.Int16Attribute = function(a, b) {
		console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
		return new xb(a, b);
	};
	a.Uint16Attribute = function(a, b) {
		console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
		return new Ta(a, b);
	};
	a.Int32Attribute = function(a, b) {
		console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
		return new bb(a, b);
	};
	a.Uint32Attribute = function(a, b) {
		console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
		return new cb(a, b);
	};
	a.Float32Attribute = function(a, b) {
		console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
		return new la(a, b);
	};
	a.Float64Attribute = function(a, b) {
		console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
		return new sb(a, b);
	};
	a.ClosedSplineCurve3 = Je;
	a.BoundingBoxHelper = function(a, b) {
		console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
		return new Gc(a, b);
	};
	a.EdgesHelper = function(a, b) {
		console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
		return new ta(new pc(a.geometry), new za({color:void 0 !== b ? b : 16777215}));
	};
	a.WireframeHelper = function(a, b) {
		console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
		return new ta(new dc(a.geometry), new za({color:void 0 !== b ? b : 16777215}));
	};
	a.XHRLoader = function(a) {
		console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
		return new fb(a);
	};
	a.GeometryUtils = {merge:function(a, b, c) {
		console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
		var d;
		b.isMesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, b = b.geometry);
		a.merge(b, d, c);
	}, center:function(a) {
		console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
		return a.center();
	}};
	a.ImageUtils = {crossOrigin:void 0, loadTexture:function(a, b, c, e) {
		console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
		var d = new yd;
		d.setCrossOrigin(this.crossOrigin);
		a = d.load(a, c, void 0, e);
		b && (a.mapping = b);
		return a;
	}, loadTextureCube:function(a, b, c, e) {
		console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
		var d = new ae;
		d.setCrossOrigin(this.crossOrigin);
		a = d.load(a, c, void 0, e);
		b && (a.mapping = b);
		return a;
	}, loadCompressedTexture:function() {
		console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
	}, loadCompressedTextureCube:function() {
		console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
	}};
	a.UniformsUtils = {merge:function(a) {
		console.warn("THREE.UniformsUtils.merge() has been deprecated. Use Object.assign() instead.");
		for (var d = {}, b = 0;b < a.length;b++) {
			var c = this.clone(a[b]), e;
			for (e in c) {
				d[e] = c[e];
			}
		}
		return d;
	}, clone:function(a) {
		console.warn("THREE.UniformsUtils.clone() has been deprecated.");
		var d = {}, b;
		for (b in a) {
			d[b] = {};
			for (var c in a[b]) {
				var e = a[b][c];
				e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? d[b][c] = e.clone() : Array.isArray(e) ? d[b][c] = e.slice() : d[b][c] = e;
			}
		}
		return d;
	}};
	a.Projector = function() {
		console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");
		this.projectVector = function(a, b) {
			console.warn("THREE.Projector: .projectVector() is now vector.project().");
			a.project(b);
		};
		this.unprojectVector = function(a, b) {
			console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
			a.unproject(b);
		};
		this.pickingRay = function() {
			console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
		};
	};
	a.CanvasRenderer = function() {
		console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js");
		this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
		this.clear = function() {
		};
		this.render = function() {
		};
		this.setClearColor = function() {
		};
		this.setSize = function() {
		};
	};
	Object.defineProperty(a, "__esModule", {value:!0});
});
THREE.VREffect = function(a, f) {
	var l, b, k, h, c, e, g, q;
	function r(a) {
		v = a;
		0 < a.length ? t = a[0] : f && f("HMD not available");
	}
	function w() {
		var b = u.isPresenting;
		u.isPresenting = void 0 !== t && t.isPresenting;
		if (u.isPresenting) {
			var c = t.getEyeParameters("left"), e = c.renderWidth, c = c.renderHeight;
			b || (D = a.getPixelRatio(), B = a.getSize(), a.setPixelRatio(1), a.setSize(2 * e, c, !1));
		} else {
			b && (a.setPixelRatio(D), a.setSize(B.width, B.height, A));
		}
	}
	function p(a, b, c, e) {
		var g, m = Math.PI / 180;
		g = Math.tan(a.upDegrees * m);
		var h = Math.tan(a.downDegrees * m), k = Math.tan(a.leftDegrees * m);
		a = Math.tan(a.rightDegrees * m);
		c = void 0 === c ? .01 : c;
		e = void 0 === e ? 1E4 : e;
		var m = void 0 === b || b ? -1 : 1, q = new THREE.Matrix4, f = q.elements, p = 2 / (k + a), r = 2 / (g + h);
		b = [p, r];
		g = [(k - a) * p * .5, (g - h) * r * .5];
		f[0] = b[0];
		f[1] = 0;
		f[2] = g[0] * m;
		f[3] = 0;
		f[4] = 0;
		f[5] = b[1];
		f[6] = -g[1] * m;
		f[7] = 0;
		f[8] = 0;
		f[9] = 0;
		f[10] = e / (c - e) * -m;
		f[11] = e * c / (c - e);
		f[12] = 0;
		f[13] = 0;
		f[14] = m;
		f[15] = 0;
		q.transpose();
		return q;
	}
	var t, v, y = new THREE.Vector3, x = new THREE.Vector3, m = null;
	"VRFrameData" in window && (m = new window.VRFrameData);
	navigator.getVRDisplays && navigator.getVRDisplays().then(r).catch(function() {
		console.warn("THREE.VREffect: Unable to get VR Displays");
	});
	this.isPresenting = !1;
	this.scale = 1;
	var u = this, B = a.getSize(), A = !1, D = a.getPixelRatio();
	this.getVRDisplay = function() {
		return t;
	};
	this.setVRDisplay = function(a) {
		t = a;
	};
	this.getVRDisplays = function() {
		console.warn("THREE.VREffect: getVRDisplays() is being deprecated.");
		return v;
	};
	this.setSize = function(b, c, e) {
		B = {width:b, height:c};
		A = e;
		u.isPresenting ? (b = t.getEyeParameters("left"), a.setPixelRatio(1), a.setSize(2 * b.renderWidth, b.renderHeight, !1)) : (a.setPixelRatio(D), a.setSize(b, c, e));
	};
	var G = a.domElement, F = [0, 0, .5, 1], C = [.5, 0, .5, 1];
	window.addEventListener("vrdisplaypresentchange", w, !1);
	this.setFullScreen = function(a) {
		return new Promise(function(b, c) {
			void 0 === t ? c(Error("No VR hardware found.")) : u.isPresenting === a ? b() : a ? b(t.requestPresent([{source:G}])) : b(t.exitPresent());
		});
	};
	this.requestPresent = function() {
		return this.setFullScreen(!0);
	};
	this.exitPresent = function() {
		return this.setFullScreen(!1);
	};
	this.requestAnimationFrame = function(a) {
		return void 0 !== t ? t.requestAnimationFrame(a) : window.requestAnimationFrame(a);
	};
	this.cancelAnimationFrame = function(a) {
		void 0 !== t ? t.cancelAnimationFrame(a) : window.cancelAnimationFrame(a);
	};
	this.submitFrame = function() {
		void 0 !== t && u.isPresenting && t.submitFrame();
	};
	this.autoSubmitFrame = !0;
	var J = new THREE.PerspectiveCamera;
	J.layers.enable(1);
	var I = new THREE.PerspectiveCamera;
	I.layers.enable(2);
	this.render = function(f, r, w, v) {
		if (t && u.isPresenting) {
			var B = f.autoUpdate;
			B && (f.updateMatrixWorld(), f.autoUpdate = !1);
			var A = t.getEyeParameters("left"), G = t.getEyeParameters("right");
			y.fromArray(A.offset);
			x.fromArray(G.offset);
			Array.isArray(f) && (console.warn("THREE.VREffect.render() no longer supports arrays. Use object.layers instead."), f = f[0]);
			var D = a.getSize(), M = t.getLayers(), S;
			M.length ? (S = M[0], M = null !== S.leftBounds && 4 === S.leftBounds.length ? S.leftBounds : F, S = null !== S.rightBounds && 4 === S.rightBounds.length ? S.rightBounds : C) : (M = F, S = C);
			c = Math.round(D.width * M[0]);
			e = Math.round(D.height * M[1]);
			g = Math.round(D.width * M[2]);
			q = Math.round(D.height * M[3]);
			l = Math.round(D.width * S[0]);
			b = Math.round(D.height * S[1]);
			k = Math.round(D.width * S[2]);
			h = Math.round(D.height * S[3]);
			w ? (a.setRenderTarget(w), w.scissorTest = !0) : (a.setRenderTarget(null), a.setScissorTest(!0));
			(a.autoClear || v) && a.clear();
			null === r.parent && r.updateMatrixWorld();
			r.matrixWorld.decompose(J.position, J.quaternion, J.scale);
			r.matrixWorld.decompose(I.position, I.quaternion, I.scale);
			M = this.scale;
			J.translateOnAxis(y, M);
			I.translateOnAxis(x, M);
			t.getFrameData ? (t.depthNear = r.near, t.depthFar = r.far, t.getFrameData(m), J.projectionMatrix.elements = m.leftProjectionMatrix, I.projectionMatrix.elements = m.rightProjectionMatrix) : (J.projectionMatrix = p(A.fieldOfView, !0, r.near, r.far), I.projectionMatrix = p(G.fieldOfView, !0, r.near, r.far));
			w ? (w.viewport.set(c, e, g, q), w.scissor.set(c, e, g, q)) : (a.setViewport(c, e, g, q), a.setScissor(c, e, g, q));
			a.render(f, J, w, v);
			w ? (w.viewport.set(l, b, k, h), w.scissor.set(l, b, k, h)) : (a.setViewport(l, b, k, h), a.setScissor(l, b, k, h));
			a.render(f, I, w, v);
			w ? (w.viewport.set(0, 0, D.width, D.height), w.scissor.set(0, 0, D.width, D.height), w.scissorTest = !1, a.setRenderTarget(null)) : (a.setViewport(0, 0, D.width, D.height), a.setScissorTest(!1));
			B && (f.autoUpdate = !0);
			u.autoSubmitFrame && u.submitFrame();
		} else {
			a.render(f, r, w, v);
		}
	};
	this.dispose = function() {
		window.removeEventListener("vrdisplaypresentchange", w, !1);
	};
};
THREE.Animation = function(a, f) {
	this.root = a;
	this.data = THREE.AnimationHandler.init(f);
	this.hierarchy = THREE.AnimationHandler.parse(a);
	this.currentTime = 0;
	this.timeScale = 1;
	this.isPlaying = !1;
	this.loop = !0;
	this.weight = 0;
	this.interpolationType = THREE.AnimationHandler.LINEAR;
};
THREE.Animation.prototype = {constructor:THREE.Animation, keyTypes:["pos", "rot", "scl"], play:function(a, f) {
	this.currentTime = void 0 !== a ? a : 0;
	this.weight = void 0 !== f ? f : 1;
	this.isPlaying = !0;
	this.reset();
	THREE.AnimationHandler.play(this);
}, stop:function() {
	this.isPlaying = !1;
	THREE.AnimationHandler.stop(this);
}, reset:function() {
	for (var a = 0, f = this.hierarchy.length;a < f;a++) {
		var l = this.hierarchy[a];
		void 0 === l.animationCache && (l.animationCache = {animations:{}, blending:{positionWeight:0, quaternionWeight:0, scaleWeight:0}});
		var b = this.data.name, k = l.animationCache.animations, h = k[b];
		void 0 === h && (h = {prevKey:{pos:0, rot:0, scl:0}, nextKey:{pos:0, rot:0, scl:0}, originalMatrix:l.matrix}, k[b] = h);
		for (l = 0;3 > l;l++) {
			for (var b = this.keyTypes[l], k = this.data.hierarchy[a].keys[0], c = this.getNextKeyWith(b, a, 1);c.time < this.currentTime && c.index > k.index;) {
				k = c, c = this.getNextKeyWith(b, a, c.index + 1);
			}
			h.prevKey[b] = k;
			h.nextKey[b] = c;
		}
	}
}, resetBlendWeights:function() {
	for (var a = 0, f = this.hierarchy.length;a < f;a++) {
		var l = this.hierarchy[a].animationCache;
		void 0 !== l && (l = l.blending, l.positionWeight = 0, l.quaternionWeight = 0, l.scaleWeight = 0);
	}
}, update:function() {
	var a = [], f = new THREE.Vector3, l = new THREE.Vector3, b = new THREE.Quaternion, k = function(a, b) {
		var c = [], e = [], k, f, p, l;
		b *= a.length - 1;
		k = Math.floor(b);
		b -= k;
		c[0] = 0 === k ? k : k - 1;
		c[1] = k;
		c[2] = k > a.length - 2 ? k : k + 1;
		c[3] = k > a.length - 3 ? k : k + 2;
		k = a[c[0]];
		f = a[c[1]];
		p = a[c[2]];
		l = a[c[3]];
		a = b * b;
		c = b * a;
		e[0] = h(k[0], f[0], p[0], l[0], b, a, c);
		e[1] = h(k[1], f[1], p[1], l[1], b, a, c);
		e[2] = h(k[2], f[2], p[2], l[2], b, a, c);
		return e;
	}, h = function(a, b, g, h, k, f, p) {
		a = .5 * (g - a);
		h = .5 * (h - b);
		return (2 * (b - g) + a + h) * p + (-3 * (b - g) - 2 * a - h) * f + a * k + b;
	};
	return function(c) {
		if (!1 !== this.isPlaying && (this.currentTime += c * this.timeScale, 0 !== this.weight)) {
			c = this.data.length;
			if (this.currentTime > c || 0 > this.currentTime) {
				this.loop ? (this.currentTime %= c, 0 > this.currentTime && (this.currentTime += c), this.reset()) : this.stop();
			}
			c = 0;
			for (var e = this.hierarchy.length;c < e;c++) {
				for (var g = this.hierarchy[c], h = g.animationCache.animations[this.data.name], r = g.animationCache.blending, w = 0;3 > w;w++) {
					var p = this.keyTypes[w], t = h.prevKey[p], v = h.nextKey[p];
					if (0 < this.timeScale && v.time <= this.currentTime || 0 > this.timeScale && t.time >= this.currentTime) {
						t = this.data.hierarchy[c].keys[0];
						for (v = this.getNextKeyWith(p, c, 1);v.time < this.currentTime && v.index > t.index;) {
							t = v, v = this.getNextKeyWith(p, c, v.index + 1);
						}
						h.prevKey[p] = t;
						h.nextKey[p] = v;
					}
					var y = (this.currentTime - t.time) / (v.time - t.time), x = t[p], m = v[p];
					0 > y && (y = 0);
					1 < y && (y = 1);
					if ("pos" === p) {
						if (this.interpolationType === THREE.AnimationHandler.LINEAR) {
							l.x = x[0] + (m[0] - x[0]) * y, l.y = x[1] + (m[1] - x[1]) * y, l.z = x[2] + (m[2] - x[2]) * y, t = this.weight / (this.weight + r.positionWeight), g.position.lerp(l, t), r.positionWeight += this.weight;
						} else {
							if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
								a[0] = this.getPrevKeyWith("pos", c, t.index - 1).pos, a[1] = x, a[2] = m, a[3] = this.getNextKeyWith("pos", c, v.index + 1).pos, y = .33 * y + .33, v = k(a, y), t = this.weight / (this.weight + r.positionWeight), r.positionWeight += this.weight, p = g.position, p.x += (v[0] - p.x) * t, p.y += (v[1] - p.y) * t, p.z += (v[2] - p.z) * t, this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (y = k(a, 1.01 * y), f.set(y[0], y[1], y[2]), f.sub(p), f.y = 0, f.normalize(), 
								g.rotation.set(0, Math.atan2(f.x, f.z), 0));
							}
						}
					} else {
						"rot" === p ? (THREE.Quaternion.slerp(x, m, b, y), 0 === r.quaternionWeight ? (g.quaternion.copy(b), r.quaternionWeight = this.weight) : (t = this.weight / (this.weight + r.quaternionWeight), THREE.Quaternion.slerp(g.quaternion, b, g.quaternion, t), r.quaternionWeight += this.weight)) : "scl" === p && (l.x = x[0] + (m[0] - x[0]) * y, l.y = x[1] + (m[1] - x[1]) * y, l.z = x[2] + (m[2] - x[2]) * y, t = this.weight / (this.weight + r.scaleWeight), g.scale.lerp(l, t), r.scaleWeight += this.weight)
						;
					}
				}
			}
			return !0;
		}
	};
}(), getNextKeyWith:function(a, f, l) {
	var b = this.data.hierarchy[f].keys;
	for (l = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? l < b.length - 1 ? l : b.length - 1 : l % b.length;l < b.length;l++) {
		if (void 0 !== b[l][a]) {
			return b[l];
		}
	}
	return this.data.hierarchy[f].keys[0];
}, getPrevKeyWith:function(a, f, l) {
	var b = this.data.hierarchy[f].keys;
	for (l = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < l ? l : 0 : 0 <= l ? l : l + b.length;0 <= l;l--) {
		if (void 0 !== b[l][a]) {
			return b[l];
		}
	}
	return this.data.hierarchy[f].keys[b.length - 1];
}};
THREE.AnimationHandler = {LINEAR:0, CATMULLROM:1, CATMULLROM_FORWARD:2, add:function() {
	console.warn("THREE.AnimationHandler.add() has been deprecated.");
}, get:function() {
	console.warn("THREE.AnimationHandler.get() has been deprecated.");
}, remove:function() {
	console.warn("THREE.AnimationHandler.remove() has been deprecated.");
}, animations:[], init:function(a) {
	if (!0 === a.initialized) {
		return a;
	}
	for (var f = 0;f < a.hierarchy.length;f++) {
		for (var l = 0;l < a.hierarchy[f].keys.length;l++) {
			if (0 > a.hierarchy[f].keys[l].time && (a.hierarchy[f].keys[l].time = 0), void 0 !== a.hierarchy[f].keys[l].rot && !(a.hierarchy[f].keys[l].rot instanceof THREE.Quaternion)) {
				var b = a.hierarchy[f].keys[l].rot;
				a.hierarchy[f].keys[l].rot = (new THREE.Quaternion).fromArray(b);
			}
		}
		if (a.hierarchy[f].keys.length && void 0 !== a.hierarchy[f].keys[0].morphTargets) {
			b = {};
			for (l = 0;l < a.hierarchy[f].keys.length;l++) {
				for (var k = 0;k < a.hierarchy[f].keys[l].morphTargets.length;k++) {
					var h = a.hierarchy[f].keys[l].morphTargets[k];
					b[h] = -1;
				}
			}
			a.hierarchy[f].usedMorphTargets = b;
			for (l = 0;l < a.hierarchy[f].keys.length;l++) {
				var c = {};
				for (h in b) {
					for (k = 0;k < a.hierarchy[f].keys[l].morphTargets.length;k++) {
						if (a.hierarchy[f].keys[l].morphTargets[k] === h) {
							c[h] = a.hierarchy[f].keys[l].morphTargetsInfluences[k];
							break;
						}
					}
					k === a.hierarchy[f].keys[l].morphTargets.length && (c[h] = 0);
				}
				a.hierarchy[f].keys[l].morphTargetsInfluences = c;
			}
		}
		for (l = 1;l < a.hierarchy[f].keys.length;l++) {
			a.hierarchy[f].keys[l].time === a.hierarchy[f].keys[l - 1].time && (a.hierarchy[f].keys.splice(l, 1), l--);
		}
		for (l = 0;l < a.hierarchy[f].keys.length;l++) {
			a.hierarchy[f].keys[l].index = l;
		}
	}
	a.initialized = !0;
	return a;
}, parse:function(a) {
	var f = function(a, b) {
		b.push(a);
		for (var c = 0;c < a.children.length;c++) {
			f(a.children[c], b);
		}
	}, l = [];
	if (a instanceof THREE.SkinnedMesh) {
		for (var b = 0;b < a.skeleton.bones.length;b++) {
			l.push(a.skeleton.bones[b]);
		}
	} else {
		f(a, l);
	}
	return l;
}, play:function(a) {
	-1 === this.animations.indexOf(a) && this.animations.push(a);
}, stop:function(a) {
	a = this.animations.indexOf(a);
	-1 !== a && this.animations.splice(a, 1);
}, update:function(a) {
	for (var f = 0;f < this.animations.length;f++) {
		this.animations[f].resetBlendWeights();
	}
	for (f = 0;f < this.animations.length;f++) {
		this.animations[f].update(a);
	}
}};
THREE.KeyFrameAnimation = function(a) {
	this.root = a.node;
	this.data = THREE.AnimationHandler.init(a);
	this.hierarchy = THREE.AnimationHandler.parse(this.root);
	this.currentTime = 0;
	this.timeScale = .001;
	this.isPlaying = !1;
	this.loop = this.isPaused = !0;
	a = 0;
	for (var f = this.hierarchy.length;a < f;a++) {
		var l = this.data.hierarchy[a].sids, b = this.hierarchy[a];
		if (this.data.hierarchy[a].keys.length && l) {
			for (var k = 0;k < l.length;k++) {
				var h = l[k], c = this.getNextKeyWith(h, a, 0);
				c && c.apply(h);
			}
			b.matrixAutoUpdate = !1;
			this.data.hierarchy[a].node.updateMatrix();
			b.matrixWorldNeedsUpdate = !0;
		}
	}
};
THREE.KeyFrameAnimation.prototype = {constructor:THREE.KeyFrameAnimation, play:function(a) {
	this.currentTime = void 0 !== a ? a : 0;
	if (!1 === this.isPlaying) {
		this.isPlaying = !0;
		var f = this.hierarchy.length, l, b;
		for (a = 0;a < f;a++) {
			l = this.hierarchy[a], b = this.data.hierarchy[a], void 0 === b.animationCache && (b.animationCache = {}, b.animationCache.prevKey = null, b.animationCache.nextKey = null, b.animationCache.originalMatrix = l.matrix), l = this.data.hierarchy[a].keys, 1 < l.length && (b.animationCache.prevKey = l[0], b.animationCache.nextKey = l[1], this.startTime = Math.min(l[0].time, this.startTime), this.endTime = Math.max(l[l.length - 1].time, this.endTime));
		}
		this.update(0);
	}
	this.isPaused = !1;
}, stop:function() {
	this.isPaused = this.isPlaying = !1;
	for (var a = 0;a < this.data.hierarchy.length;a++) {
		var f = this.hierarchy[a], l = this.data.hierarchy[a];
		if (void 0 !== l.animationCache) {
			var b = l.animationCache.originalMatrix;
			b.copy(f.matrix);
			f.matrix = b;
			delete l.animationCache;
		}
	}
}, update:function(a) {
	if (!1 !== this.isPlaying) {
		this.currentTime += a * this.timeScale;
		a = this.data.length;
		!0 === this.loop && this.currentTime > a && (this.currentTime %= a);
		this.currentTime = Math.min(this.currentTime, a);
		a = 0;
		for (var f = this.hierarchy.length;a < f;a++) {
			var l = this.hierarchy[a], b = this.data.hierarchy[a], k = b.keys, b = b.animationCache;
			if (k.length) {
				var h = b.prevKey, c = b.nextKey;
				if (c.time <= this.currentTime) {
					for (;c.time < this.currentTime && c.index > h.index;) {
						h = c, c = k[h.index + 1];
					}
					b.prevKey = h;
					b.nextKey = c;
				}
				c.time >= this.currentTime ? h.interpolate(c, this.currentTime) : h.interpolate(c, c.time);
				this.data.hierarchy[a].node.updateMatrix();
				l.matrixWorldNeedsUpdate = !0;
			}
		}
	}
}, getNextKeyWith:function(a, f, l) {
	f = this.data.hierarchy[f].keys;
	for (l %= f.length;l < f.length;l++) {
		if (f[l].hasTarget(a)) {
			return f[l];
		}
	}
	return f[0];
}, getPrevKeyWith:function(a, f, l) {
	f = this.data.hierarchy[f].keys;
	for (l = 0 <= l ? l : l + f.length;0 <= l;l--) {
		if (f[l].hasTarget(a)) {
			return f[l];
		}
	}
	return f[f.length - 1];
}};
!function(a) {
	if ("object" == typeof exports && "undefined" != typeof module) {
		module.exports = a();
	} else {
		var f;
		"undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self);
		f.CANNON = a();
	}
}(function() {
	return function f(l, b, k) {
		function h(e, q) {
			if (!b[e]) {
				if (!l[e]) {
					var g = "function" == typeof require && require;
					if (!q && g) {
						return g(e, !0);
					}
					if (c) {
						return c(e, !0);
					}
					throw Error("Cannot find module '" + e + "'");
				}
				q = b[e] = {exports:{}};
				l[e][0].call(q.exports, function(b) {
					var c = l[e][1][b];
					return h(c ? c : b);
				}, q, q.exports, f, l, b, k);
			}
			return b[e].exports;
		}
		for (var c = "function" == typeof require && require, e = 0;e < k.length;e++) {
			h(k[e]);
		}
		return h;
	}({1:[function(f, l) {
		l.exports = {name:"cannon", version:"0.6.2", description:"A lightweight 3D physics engine written in JavaScript.", homepage:"https://github.com/schteppe/cannon.js", author:"Stefan Hedman <schteppe@gmail.com> (http://steffe.se)", keywords:["cannon.js", "cannon", "physics", "engine", "3d"], main:"./build/cannon.js", engines:{node:"*"}, repository:{type:"git", url:"https://github.com/schteppe/cannon.js.git"}, bugs:{url:"https://github.com/schteppe/cannon.js/issues"}, licenses:[{type:"MIT"}], devDependencies:{jshint:"latest", 
		"uglify-js":"latest", nodeunit:"^0.9.0", grunt:"~0.4.0", "grunt-contrib-jshint":"~0.1.1", "grunt-contrib-nodeunit":"^0.4.1", "grunt-contrib-concat":"~0.1.3", "grunt-contrib-uglify":"^0.5.1", "grunt-browserify":"^2.1.4", "grunt-contrib-yuidoc":"^0.5.2", browserify:"*"}, dependencies:{}};
	}, {}], 2:[function(f, l) {
		l.exports = {version:f("../package.json").version, AABB:f("./collision/AABB"), ArrayCollisionMatrix:f("./collision/ArrayCollisionMatrix"), Body:f("./objects/Body"), Box:f("./shapes/Box"), Broadphase:f("./collision/Broadphase"), Constraint:f("./constraints/Constraint"), ContactEquation:f("./equations/ContactEquation"), Narrowphase:f("./world/Narrowphase"), ConeTwistConstraint:f("./constraints/ConeTwistConstraint"), ContactMaterial:f("./material/ContactMaterial"), ConvexPolyhedron:f("./shapes/ConvexPolyhedron"), 
		Cylinder:f("./shapes/Cylinder"), DistanceConstraint:f("./constraints/DistanceConstraint"), Equation:f("./equations/Equation"), EventTarget:f("./utils/EventTarget"), FrictionEquation:f("./equations/FrictionEquation"), GSSolver:f("./solver/GSSolver"), GridBroadphase:f("./collision/GridBroadphase"), Heightfield:f("./shapes/Heightfield"), HingeConstraint:f("./constraints/HingeConstraint"), LockConstraint:f("./constraints/LockConstraint"), Mat3:f("./math/Mat3"), Material:f("./material/Material"), 
		NaiveBroadphase:f("./collision/NaiveBroadphase"), ObjectCollisionMatrix:f("./collision/ObjectCollisionMatrix"), Pool:f("./utils/Pool"), Particle:f("./shapes/Particle"), Plane:f("./shapes/Plane"), PointToPointConstraint:f("./constraints/PointToPointConstraint"), Quaternion:f("./math/Quaternion"), Ray:f("./collision/Ray"), RaycastVehicle:f("./objects/RaycastVehicle"), RaycastResult:f("./collision/RaycastResult"), RigidVehicle:f("./objects/RigidVehicle"), RotationalEquation:f("./equations/RotationalEquation"), 
		RotationalMotorEquation:f("./equations/RotationalMotorEquation"), SAPBroadphase:f("./collision/SAPBroadphase"), SPHSystem:f("./objects/SPHSystem"), Shape:f("./shapes/Shape"), Solver:f("./solver/Solver"), Sphere:f("./shapes/Sphere"), SplitSolver:f("./solver/SplitSolver"), Spring:f("./objects/Spring"), Trimesh:f("./shapes/Trimesh"), Vec3:f("./math/Vec3"), Vec3Pool:f("./utils/Vec3Pool"), World:f("./world/World")};
	}, {"../package.json":1, "./collision/AABB":3, "./collision/ArrayCollisionMatrix":4, "./collision/Broadphase":5, "./collision/GridBroadphase":6, "./collision/NaiveBroadphase":7, "./collision/ObjectCollisionMatrix":8, "./collision/Ray":9, "./collision/RaycastResult":10, "./collision/SAPBroadphase":11, "./constraints/ConeTwistConstraint":12, "./constraints/Constraint":13, "./constraints/DistanceConstraint":14, "./constraints/HingeConstraint":15, "./constraints/LockConstraint":16, "./constraints/PointToPointConstraint":17, 
	"./equations/ContactEquation":19, "./equations/Equation":20, "./equations/FrictionEquation":21, "./equations/RotationalEquation":22, "./equations/RotationalMotorEquation":23, "./material/ContactMaterial":24, "./material/Material":25, "./math/Mat3":27, "./math/Quaternion":28, "./math/Vec3":30, "./objects/Body":31, "./objects/RaycastVehicle":32, "./objects/RigidVehicle":33, "./objects/SPHSystem":34, "./objects/Spring":35, "./shapes/Box":37, "./shapes/ConvexPolyhedron":38, "./shapes/Cylinder":39, 
	"./shapes/Heightfield":40, "./shapes/Particle":41, "./shapes/Plane":42, "./shapes/Shape":43, "./shapes/Sphere":44, "./shapes/Trimesh":45, "./solver/GSSolver":46, "./solver/Solver":47, "./solver/SplitSolver":48, "./utils/EventTarget":49, "./utils/Pool":51, "./utils/Vec3Pool":54, "./world/Narrowphase":55, "./world/World":56}], 3:[function(f, l) {
		function b(b) {
			b = b || {};
			this.lowerBound = new k;
			b.lowerBound && this.lowerBound.copy(b.lowerBound);
			this.upperBound = new k;
			b.upperBound && this.upperBound.copy(b.upperBound);
		}
		var k = f("../math/Vec3");
		f("../utils/Utils");
		l.exports = b;
		var h = new k;
		b.prototype.setFromPoints = function(b, c, k, f) {
			var e = this.lowerBound, g = this.upperBound;
			e.copy(b[0]);
			k && k.vmult(e, e);
			g.copy(e);
			for (var q = 1;q < b.length;q++) {
				var r = b[q];
				k && (k.vmult(r, h), r = h);
				r.x > g.x && (g.x = r.x);
				r.x < e.x && (e.x = r.x);
				r.y > g.y && (g.y = r.y);
				r.y < e.y && (e.y = r.y);
				r.z > g.z && (g.z = r.z);
				r.z < e.z && (e.z = r.z);
			}
			return c && (c.vadd(e, e), c.vadd(g, g)), f && (e.x -= f, e.y -= f, e.z -= f, g.x += f, g.y += f, g.z += f), this;
		};
		b.prototype.copy = function(b) {
			return this.lowerBound.copy(b.lowerBound), this.upperBound.copy(b.upperBound), this;
		};
		b.prototype.clone = function() {
			return (new b).copy(this);
		};
		b.prototype.extend = function(b) {
			var c = b.lowerBound.x;
			this.lowerBound.x > c && (this.lowerBound.x = c);
			c = b.upperBound.x;
			this.upperBound.x < c && (this.upperBound.x = c);
			c = b.lowerBound.y;
			this.lowerBound.y > c && (this.lowerBound.y = c);
			c = b.upperBound.y;
			this.upperBound.y < c && (this.upperBound.y = c);
			c = b.lowerBound.z;
			this.lowerBound.z > c && (this.lowerBound.z = c);
			c = b.upperBound.z;
			this.upperBound.z < c && (this.upperBound.z = c);
		};
		b.prototype.overlaps = function(b) {
			var c = this.lowerBound, e = this.upperBound, h = b.lowerBound;
			b = b.upperBound;
			return (h.x <= e.x && e.x <= b.x || c.x <= b.x && b.x <= e.x) && (h.y <= e.y && e.y <= b.y || c.y <= b.y && b.y <= e.y) && (h.z <= e.z && e.z <= b.z || c.z <= b.z && b.z <= e.z);
		};
		b.prototype.contains = function(b) {
			var c = this.lowerBound, e = this.upperBound, h = b.lowerBound;
			b = b.upperBound;
			return c.x <= h.x && e.x >= b.x && c.y <= h.y && e.y >= b.y && c.z <= h.z && e.z >= b.z;
		};
		b.prototype.getCorners = function(b, c, h, k, f, p, l, v) {
			var e = this.lowerBound, g = this.upperBound;
			b.copy(e);
			c.set(g.x, e.y, e.z);
			h.set(g.x, g.y, e.z);
			k.set(e.x, g.y, g.z);
			f.set(g.x, e.y, e.z);
			p.set(e.x, g.y, e.z);
			l.set(e.x, e.y, g.z);
			v.copy(g);
		};
		var c = [new k, new k, new k, new k, new k, new k, new k, new k];
		b.prototype.toLocalFrame = function(b, g) {
			this.getCorners(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7]);
			for (var e = 0;8 !== e;e++) {
				var h = c[e];
				b.pointToLocal(h, h);
			}
			return g.setFromPoints(c);
		};
		b.prototype.toWorldFrame = function(b, g) {
			this.getCorners(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7]);
			for (var e = 0;8 !== e;e++) {
				var h = c[e];
				b.pointToWorld(h, h);
			}
			return g.setFromPoints(c);
		};
	}, {"../math/Vec3":30, "../utils/Utils":53}], 4:[function(f, l) {
		function b() {
			this.matrix = [];
		}
		l.exports = b;
		b.prototype.get = function(b, h) {
			if (b = b.index, h = h.index, h > b) {
				b = h = b;
			}
			return this.matrix[(b * (b + 1) >> 1) + h - 1];
		};
		b.prototype.set = function(b, h, c) {
			if (b = b.index, h = h.index, h > b) {
				b = h = b;
			}
			this.matrix[(b * (b + 1) >> 1) + h - 1] = c ? 1 : 0;
		};
		b.prototype.reset = function() {
			for (var b = 0, h = this.matrix.length;b !== h;b++) {
				this.matrix[b] = 0;
			}
		};
		b.prototype.setNumObjects = function(b) {
			this.matrix.length = b * (b - 1) >> 1;
		};
	}, {}], 5:[function(f, l) {
		function b() {
			this.world = null;
			this.useBoundingBoxes = !1;
			this.dirty = !0;
		}
		var k = f("../objects/Body"), h = f("../math/Vec3"), c = f("../math/Quaternion");
		f("../shapes/Shape");
		f("../shapes/Plane");
		l.exports = b;
		b.prototype.collisionPairs = function() {
			throw Error("collisionPairs not implemented for this BroadPhase class!");
		};
		var e = k.STATIC | k.KINEMATIC;
		b.prototype.needBroadphaseCollision = function(b, c) {
			return 0 === (b.collisionFilterGroup & c.collisionFilterMask) || 0 === (c.collisionFilterGroup & b.collisionFilterMask) ? !1 : 0 === (b.type & e) && b.sleepState !== k.SLEEPING || 0 === (c.type & e) && c.sleepState !== k.SLEEPING ? !0 : !1;
		};
		b.prototype.intersectionTest = function(b, c, e, g) {
			this.useBoundingBoxes ? this.doBoundingBoxBroadphase(b, c, e, g) : this.doBoundingSphereBroadphase(b, c, e, g);
		};
		var g = new h;
		new h;
		new c;
		new h;
		b.prototype.doBoundingSphereBroadphase = function(b, c, e, h) {
			c.position.vsub(b.position, g);
			var m = Math.pow(b.boundingRadius + c.boundingRadius, 2), k = g.norm2();
			m > k && (e.push(b), h.push(c));
		};
		b.prototype.doBoundingBoxBroadphase = function(b, c, e, g) {
			b.aabbNeedsUpdate && b.computeAABB();
			c.aabbNeedsUpdate && c.computeAABB();
			b.aabb.overlaps(c.aabb) && (e.push(b), g.push(c));
		};
		var q = {keys:[]}, r = [], w = [];
		b.prototype.makePairsUnique = function(b, c) {
			for (var e = b.length, g = 0;g !== e;g++) {
				r[g] = b[g], w[g] = c[g];
			}
			b.length = 0;
			for (g = c.length = 0;g !== e;g++) {
				var m = r[g].id, h = w[g].id, m = h > m ? m + "," + h : h + "," + m;
				q[m] = g;
				q.keys.push(m);
			}
			for (g = 0;g !== q.keys.length;g++) {
				m = q.keys.pop(), e = q[m], b.push(r[e]), c.push(w[e]), delete q[m];
			}
		};
		b.prototype.setWorld = function() {
		};
		var p = new h;
		b.boundingSphereCheck = function(b, c) {
			return b.position.vsub(c.position, p), Math.pow(b.shape.boundingSphereRadius + c.shape.boundingSphereRadius, 2) > p.norm2();
		};
		b.prototype.aabbQuery = function() {
			return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), [];
		};
	}, {"../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "../shapes/Plane":42, "../shapes/Shape":43}], 6:[function(f, l) {
		function b(b, c, e, f, p) {
			k.apply(this);
			this.nx = e || 10;
			this.ny = f || 10;
			this.nz = p || 10;
			this.aabbMin = b || new h(100, 100, 100);
			this.aabbMax = c || new h(-100, -100, -100);
			b = this.nx * this.ny * this.nz;
			if (0 >= b) {
				throw "GridBroadphase: Each dimension's n must be >0";
			}
			this.bins = [];
			this.binLengths = [];
			this.bins.length = b;
			this.binLengths.length = b;
			for (c = 0;b > c;c++) {
				this.bins[c] = [], this.binLengths[c] = 0;
			}
		}
		l.exports = b;
		var k = f("./Broadphase"), h = f("../math/Vec3"), c = f("../shapes/Shape");
		b.prototype = new k;
		b.prototype.constructor = b;
		var e = new h;
		new h;
		b.prototype.collisionPairs = function(b, h, k) {
			function g(b, c, e, g, h, k, q) {
				b = (b - C) * Q | 0;
				c = (c - J) * M | 0;
				e = (e - I) * N | 0;
				g = S((g - C) * Q);
				h = S((h - J) * M);
				k = S((k - I) * N);
				0 > b ? b = 0 : b >= l && (b = l - 1);
				0 > c ? c = 0 : c >= x && (c = x - 1);
				0 > e ? e = 0 : e >= m && (e = m - 1);
				0 > g ? g = 0 : g >= l && (g = l - 1);
				0 > h ? h = 0 : h >= x && (h = x - 1);
				0 > k ? k = 0 : k >= m && (k = m - 1);
				b *= u;
				c *= B;
				e *= A;
				g *= u;
				h *= B;
				for (k *= A;g >= b;b += u) {
					for (var f = c;h >= f;f += B) {
						for (var p = e;k >= p;p += A) {
							var r = b + f + p;
							Y[r][ga[r]++] = q;
						}
					}
				}
			}
			var q = b.numObjects();
			b = b.bodies;
			for (var f = this.aabbMax, r = this.aabbMin, l = this.nx, x = this.ny, m = this.nz, u = x * m, B = m, A = 1, D = f.x, G = f.y, F = f.z, C = r.x, J = r.y, I = r.z, Q = l / (D - C), M = x / (G - J), N = m / (F - I), D = (D - C) / l, R = (G - J) / x, F = (F - I) / m, H = .5 * Math.sqrt(D * D + R * R + F * F), G = c.types, ba = G.SPHERE, ha = G.PLANE, Y = (G.BOX, G.COMPOUND, G.CONVEXPOLYHEDRON, this.bins), ga = this.binLengths, G = this.bins.length, r = 0;r !== G;r++) {
				ga[r] = 0;
			}
			for (var S = Math.ceil, r = Math.min, f = Math.max, r = 0;r !== q;r++) {
				var f = b[r], V = f.shape;
				switch(V.type) {
					case ba:
						var L = f.position.x, W = f.position.y, ia = f.position.z, V = V.radius;
						g(L - V, W - V, ia - V, L + V, W + V, ia + V, f);
						break;
					case ha:
						V.worldNormalNeedsUpdate && V.computeWorldNormal(f.quaternion);
						var ia = V.worldNormal, V = J + .5 * R - f.position.y, va = I + .5 * F - f.position.z, T = e;
						T.set(C + .5 * D - f.position.x, V, va);
						for (var pa = L = 0;L !== l;L++, pa += u, T.y = V, T.x += D) {
							for (var ra = W = 0;W !== x;W++, ra += B, T.z = va, T.y += R) {
								for (var qa = 0, ea = 0;qa !== m;qa++, ea += A, T.z += F) {
									if (T.dot(ia) < H) {
										var Z = pa + ra + ea;
										Y[Z][ga[Z]++] = f;
									}
								}
							}
						}
						break;
					default:
						f.aabbNeedsUpdate && f.computeAABB(), g(f.aabb.lowerBound.x, f.aabb.lowerBound.y, f.aabb.lowerBound.z, f.aabb.upperBound.x, f.aabb.upperBound.y, f.aabb.upperBound.z, f);
				}
			}
			for (r = 0;r !== G;r++) {
				if (q = ga[r], 1 < q) {
					for (b = Y[r], L = 0;L !== q;L++) {
						for (f = b[L], W = 0;W !== L;W++) {
							D = b[W], this.needBroadphaseCollision(f, D) && this.intersectionTest(f, D, h, k);
						}
					}
				}
			}
			this.makePairsUnique(h, k);
		};
	}, {"../math/Vec3":30, "../shapes/Shape":43, "./Broadphase":5}], 7:[function(f, l) {
		function b() {
			k.apply(this);
		}
		l.exports = b;
		var k = f("./Broadphase");
		f = f("./AABB");
		b.prototype = new k;
		b.prototype.constructor = b;
		b.prototype.collisionPairs = function(b, c, e) {
			var g, h, k, f = b.bodies, p = f.length;
			for (b = 0;b !== p;b++) {
				for (g = 0;g !== b;g++) {
					h = f[b], k = f[g], this.needBroadphaseCollision(h, k) && this.intersectionTest(h, k, c, e);
				}
			}
		};
		new f;
		b.prototype.aabbQuery = function(b, c, e) {
			e = e || [];
			for (var g = 0;g < b.bodies.length;g++) {
				var h = b.bodies[g];
				h.aabbNeedsUpdate && h.computeAABB();
				h.aabb.overlaps(c) && e.push(h);
			}
			return e;
		};
	}, {"./AABB":3, "./Broadphase":5}], 8:[function(f, l) {
		function b() {
			this.matrix = {};
		}
		l.exports = b;
		b.prototype.get = function(b, h) {
			if (b = b.id, h = h.id, h > b) {
				b = h = b;
			}
			return b + "-" + h in this.matrix;
		};
		b.prototype.set = function(b, h, c) {
			if (b = b.id, h = h.id, h > b) {
				b = h = b;
			}
			c ? this.matrix[b + "-" + h] = !0 : delete this.matrix[b + "-" + h];
		};
		b.prototype.reset = function() {
			this.matrix = {};
		};
		b.prototype.setNumObjects = function() {
		};
	}, {}], 9:[function(f, l) {
		function b(c, g) {
			this.from = c ? c.clone() : new h;
			this.to = g ? g.clone() : new h;
			this._direction = new h;
			this.precision = 1E-4;
			this.checkCollisionResponse = !0;
			this.skipBackfaces = !1;
			this.collisionFilterGroup = this.collisionFilterMask = -1;
			this.mode = b.ANY;
			this.result = new e;
			this.hasHit = !1;
			this.callback = function() {
			};
		}
		function k(b, c, e, g) {
			g.vsub(c, ba);
			e.vsub(c, w);
			b.vsub(c, p);
			var m, h;
			b = ba.dot(ba);
			c = ba.dot(w);
			e = ba.dot(p);
			g = w.dot(w);
			var k = w.dot(p);
			return 0 <= (m = g * e - c * k) && 0 <= (h = b * k - c * e) && b * g - c * c > m + h;
		}
		l.exports = b;
		var h = f("../math/Vec3");
		l = f("../math/Quaternion");
		var c = f("../math/Transform"), e = (f("../shapes/ConvexPolyhedron"), f("../shapes/Box"), f("../collision/RaycastResult")), g = f("../shapes/Shape");
		f = f("../collision/AABB");
		b.prototype.constructor = b;
		b.CLOSEST = 1;
		b.ANY = 2;
		b.ALL = 4;
		var q = new f, r = [];
		b.prototype.intersectWorld = function(c, g) {
			return this.mode = g.mode || b.ANY, this.result = g.result || new e, this.skipBackfaces = !!g.skipBackfaces, this.collisionFilterMask = "undefined" != typeof g.collisionFilterMask ? g.collisionFilterMask : -1, this.collisionFilterGroup = "undefined" != typeof g.collisionFilterGroup ? g.collisionFilterGroup : -1, g.from && this.from.copy(g.from), g.to && this.to.copy(g.to), this.callback = g.callback || function() {
			}, this.hasHit = !1, this.result.reset(), this._updateDirection(), this.getAABB(q), r.length = 0, c.broadphase.aabbQuery(c, q, r), this.intersectBodies(r), this.hasHit;
		};
		var w = new h, p = new h;
		b.pointInTriangle = k;
		var t = new h, v = new l;
		b.prototype.intersectBody = function(b, c) {
			c && (this.result = c, this._updateDirection());
			c = this.checkCollisionResponse;
			if ((!c || b.collisionResponse) && 0 !== (this.collisionFilterGroup & b.collisionFilterMask) && 0 !== (b.collisionFilterGroup & this.collisionFilterMask)) {
				for (var e = 0, g = b.shapes.length;g > e;e++) {
					var m = b.shapes[e];
					if ((!c || m.collisionResponse) && (b.quaternion.mult(b.shapeOrientations[e], v), b.quaternion.vmult(b.shapeOffsets[e], t), t.vadd(b.position, t), this.intersectShape(m, v, t, b), this.result._shouldStop)) {
						break;
					}
				}
			}
		};
		b.prototype.intersectBodies = function(b, c) {
			c && (this.result = c, this._updateDirection());
			c = 0;
			for (var e = b.length;!this.result._shouldStop && e > c;c++) {
				this.intersectBody(b[c]);
			}
		};
		b.prototype._updateDirection = function() {
			this.to.vsub(this.from, this._direction);
			this._direction.normalize();
		};
		b.prototype.intersectShape = function(b, c, e, g) {
			var m = this.from, h = this._direction;
			e.vsub(m, ba);
			var k = ba.dot(h);
			h.mult(k, ha);
			ha.vadd(m, ha);
			e.distanceTo(ha) > b.boundingSphereRadius || (m = this[b.type]) && m.call(this, b, c, e, g);
		};
		var y = (new h, new h, new h), x = new h, m = new h, u = new h;
		new h;
		new e;
		b.prototype.intersectBox = function(b, c, e, g) {
			return this.intersectConvex(b.convexPolyhedronRepresentation, c, e, g);
		};
		b.prototype[g.types.BOX] = b.prototype.intersectBox;
		b.prototype.intersectPlane = function(b, c, e, g) {
			var m = this.from, k = this.to, q = this._direction, f = new h(0, 0, 1);
			c.vmult(f, f);
			var p = new h;
			m.vsub(e, p);
			c = p.dot(f);
			k.vsub(e, p);
			p = p.dot(f);
			if (!(0 < c * p || m.distanceTo(k) < c || (p = f.dot(q), Math.abs(p) < this.precision))) {
				var r = new h, k = new h;
				c = new h;
				m.vsub(e, r);
				e = -f.dot(r) / p;
				q.scale(e, k);
				m.vadd(k, c);
				this.reportIntersection(f, c, b, g, -1);
			}
		};
		b.prototype[g.types.PLANE] = b.prototype.intersectPlane;
		b.prototype.getAABB = function(b) {
			var c = this.to, e = this.from;
			b.lowerBound.x = Math.min(c.x, e.x);
			b.lowerBound.y = Math.min(c.y, e.y);
			b.lowerBound.z = Math.min(c.z, e.z);
			b.upperBound.x = Math.max(c.x, e.x);
			b.upperBound.y = Math.max(c.y, e.y);
			b.upperBound.z = Math.max(c.z, e.z);
		};
		var B = {faceList:[0]};
		b.prototype.intersectHeightfield = function(e, g, m, k) {
			var q = (e.data, e.elementSize, new h), f = new b(this.from, this.to);
			c.pointToLocalFrame(m, g, f.from, f.from);
			c.pointToLocalFrame(m, g, f.to, f.to);
			var p = [], r = null, u = null, l = null, w = null, t = e.getIndexOfPosition(f.from.x, f.from.y, p, !1);
			if (t && (r = p[0], u = p[1], l = p[0], w = p[1]), t = e.getIndexOfPosition(f.to.x, f.to.y, p, !1), t && ((null === r || p[0] < r) && (r = p[0]), (null === l || p[0] > l) && (l = p[0]), (null === u || p[1] < u) && (u = p[1]), (null === w || p[1] > w) && (w = p[1])), null !== r) {
				for (f = [], e.getRectMinMax(r, u, l, w, f), r = (f[0], f[1], r);l >= r;r++) {
					for (f = u;w >= f;f++) {
						if (this.result._shouldStop || (e.getConvexTrianglePillar(r, f, !1), c.pointToWorldFrame(m, g, e.pillarOffset, q), this.intersectConvex(e.pillarConvex, g, q, k, B), this.result._shouldStop)) {
							return;
						}
						e.getConvexTrianglePillar(r, f, !0);
						c.pointToWorldFrame(m, g, e.pillarOffset, q);
						this.intersectConvex(e.pillarConvex, g, q, k, B);
					}
				}
			}
		};
		b.prototype[g.types.HEIGHTFIELD] = b.prototype.intersectHeightfield;
		var A = new h, D = new h;
		b.prototype.intersectSphere = function(b, c, e, g) {
			c = this.from;
			var m = this.to, h = Math.pow(m.x - c.x, 2) + Math.pow(m.y - c.y, 2) + Math.pow(m.z - c.z, 2), k = 2 * ((m.x - c.x) * (c.x - e.x) + (m.y - c.y) * (c.y - e.y) + (m.z - c.z) * (c.z - e.z)), q = Math.pow(k, 2) - 4 * h * (Math.pow(c.x - e.x, 2) + Math.pow(c.y - e.y, 2) + Math.pow(c.z - e.z, 2) - Math.pow(b.radius, 2));
			if (!(0 > q)) {
				if (0 === q) {
					c.lerp(m, q, A), A.vsub(e, D), D.normalize(), this.reportIntersection(D, A, b, g, -1);
				} else {
					var f = (-k - Math.sqrt(q)) / (2 * h), h = (-k + Math.sqrt(q)) / (2 * h);
					(0 <= f && 1 >= f && (c.lerp(m, f, A), A.vsub(e, D), D.normalize(), this.reportIntersection(D, A, b, g, -1)), this.result._shouldStop) || 0 <= h && 1 >= h && (c.lerp(m, h, A), A.vsub(e, D), D.normalize(), this.reportIntersection(D, A, b, g, -1));
				}
			}
		};
		b.prototype[g.types.SPHERE] = b.prototype.intersectSphere;
		var G = new h, F = (new h, new h, new h);
		b.prototype.intersectConvex = function(b, c, e, g, h) {
			h = h && h.faceList || null;
			for (var q = b.faces, f = b.vertices, p = b.faceNormals, r = this._direction, l = this.from, w = l.distanceTo(this.to), t = h ? h.length : q.length, v = this.result, B = 0;!v._shouldStop && t > B;B++) {
				var A = h ? h[B] : B, C = q[A], D = p[A], L = c, J = e;
				F.copy(f[C[0]]);
				L.vmult(F, F);
				F.vadd(J, F);
				F.vsub(l, F);
				L.vmult(D, G);
				D = r.dot(G);
				if (!(Math.abs(D) < this.precision || (D = G.dot(F) / D, 0 > D))) {
					for (r.mult(D, y), y.vadd(l, y), x.copy(f[C[0]]), L.vmult(x, x), J.vadd(x, x), D = 1;!v._shouldStop && D < C.length - 1;D++) {
						m.copy(f[C[D]]);
						u.copy(f[C[D + 1]]);
						L.vmult(m, m);
						L.vmult(u, u);
						J.vadd(m, m);
						J.vadd(u, u);
						var I = y.distanceTo(l);
						!k(y, x, m, u) && !k(y, m, x, u) || I > w || this.reportIntersection(G, y, b, g, A);
					}
				}
			}
		};
		b.prototype[g.types.CONVEXPOLYHEDRON] = b.prototype.intersectConvex;
		var C = new h, J = new h, I = new h, Q = new h, M = new h, N = new h, R = (new f, []), H = new c;
		b.prototype.intersectTrimesh = function(b, e, g, h, q) {
			q = (q && q.faceList || null, b.indices);
			var f = (b.vertices, b.faceNormals, this.from), p = this.to, r = this._direction;
			H.position.copy(g);
			H.quaternion.copy(e);
			c.vectorToLocalFrame(g, e, r, J);
			c.pointToLocalFrame(g, e, f, I);
			c.pointToLocalFrame(g, e, p, Q);
			f = I.distanceSquared(Q);
			b.tree.rayQuery(this, H, R);
			p = 0;
			for (r = R.length;!this.result._shouldStop && p !== r;p++) {
				var l = R[p];
				b.getNormal(l, C);
				b.getVertex(q[3 * l], x);
				x.vsub(I, F);
				var w = J.dot(C), w = C.dot(F) / w;
				0 > w || (J.scale(w, y), y.vadd(I, y), b.getVertex(q[3 * l + 1], m), b.getVertex(q[3 * l + 2], u), w = y.distanceSquared(I), !k(y, m, x, u) && !k(y, x, m, u) || w > f || (c.vectorToWorldFrame(e, C, M), c.pointToWorldFrame(g, e, y, N), this.reportIntersection(M, N, b, h, l)));
			}
			R.length = 0;
		};
		b.prototype[g.types.TRIMESH] = b.prototype.intersectTrimesh;
		b.prototype.reportIntersection = function(c, e, g, m, h) {
			var k = this.from, q = this.to, f = k.distanceTo(e), p = this.result;
			if (!(this.skipBackfaces && 0 < c.dot(this._direction))) {
				switch(p.hitFaceIndex = "undefined" != typeof h ? h : -1, this.mode) {
					case b.ALL:
						this.hasHit = !0;
						p.set(k, q, c, e, g, m, f);
						p.hasHit = !0;
						this.callback(p);
						break;
					case b.CLOSEST:
						(f < p.distance || !p.hasHit) && (this.hasHit = !0, p.hasHit = !0, p.set(k, q, c, e, g, m, f));
						break;
					case b.ANY:
						this.hasHit = !0, p.hasHit = !0, p.set(k, q, c, e, g, m, f), p._shouldStop = !0;
				}
			}
		};
		var ba = new h, ha = new h;
	}, {"../collision/AABB":3, "../collision/RaycastResult":10, "../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "../shapes/Box":37, "../shapes/ConvexPolyhedron":38, "../shapes/Shape":43}], 10:[function(f, l) {
		function b() {
			this.rayFromWorld = new k;
			this.rayToWorld = new k;
			this.hitNormalWorld = new k;
			this.hitPointWorld = new k;
			this.hasHit = !1;
			this.body = this.shape = null;
			this.distance = this.hitFaceIndex = -1;
			this._shouldStop = !1;
		}
		var k = f("../math/Vec3");
		l.exports = b;
		b.prototype.reset = function() {
			this.rayFromWorld.setZero();
			this.rayToWorld.setZero();
			this.hitNormalWorld.setZero();
			this.hitPointWorld.setZero();
			this.hasHit = !1;
			this.body = this.shape = null;
			this.distance = this.hitFaceIndex = -1;
			this._shouldStop = !1;
		};
		b.prototype.abort = function() {
			this._shouldStop = !0;
		};
		b.prototype.set = function(b, c, e, g, k, f, l) {
			this.rayFromWorld.copy(b);
			this.rayToWorld.copy(c);
			this.hitNormalWorld.copy(e);
			this.hitPointWorld.copy(g);
			this.shape = k;
			this.body = f;
			this.distance = l;
		};
	}, {"../math/Vec3":30}], 11:[function(f, l) {
		function b(b) {
			k.apply(this);
			this.axisList = [];
			this.world = null;
			this.axisIndex = 0;
			var c = this.axisList;
			this._addBodyHandler = function(b) {
				c.push(b.body);
			};
			this._removeBodyHandler = function(b) {
				b = c.indexOf(b.body);
				-1 !== b && c.splice(b, 1);
			};
			b && this.setWorld(b);
		}
		var k = (f("../shapes/Shape"), f("../collision/Broadphase"));
		l.exports = b;
		b.prototype = new k;
		b.prototype.setWorld = function(b) {
			for (var c = this.axisList.length = 0;c < b.bodies.length;c++) {
				this.axisList.push(b.bodies[c]);
			}
			b.removeEventListener("addBody", this._addBodyHandler);
			b.removeEventListener("removeBody", this._removeBodyHandler);
			b.addEventListener("addBody", this._addBodyHandler);
			b.addEventListener("removeBody", this._removeBodyHandler);
			this.world = b;
			this.dirty = !0;
		};
		b.insertionSortX = function(b) {
			for (var c = 1, e = b.length;e > c;c++) {
				for (var g = b[c], h = c - 1;0 <= h && !(b[h].aabb.lowerBound.x <= g.aabb.lowerBound.x);h--) {
					b[h + 1] = b[h];
				}
				b[h + 1] = g;
			}
			return b;
		};
		b.insertionSortY = function(b) {
			for (var c = 1, e = b.length;e > c;c++) {
				for (var g = b[c], h = c - 1;0 <= h && !(b[h].aabb.lowerBound.y <= g.aabb.lowerBound.y);h--) {
					b[h + 1] = b[h];
				}
				b[h + 1] = g;
			}
			return b;
		};
		b.insertionSortZ = function(b) {
			for (var c = 1, e = b.length;e > c;c++) {
				for (var g = b[c], h = c - 1;0 <= h && !(b[h].aabb.lowerBound.z <= g.aabb.lowerBound.z);h--) {
					b[h + 1] = b[h];
				}
				b[h + 1] = g;
			}
			return b;
		};
		b.prototype.collisionPairs = function(h, c, e) {
			var g, k = this.axisList, f = k.length, l = this.axisIndex;
			this.dirty && (this.sortList(), this.dirty = !1);
			for (h = 0;h !== f;h++) {
				var p = k[h];
				for (g = h + 1;f > g;g++) {
					var t = k[g];
					if (this.needBroadphaseCollision(p, t)) {
						if (!b.checkBounds(p, t, l)) {
							break;
						}
						this.intersectionTest(p, t, c, e);
					}
				}
			}
		};
		b.prototype.sortList = function() {
			for (var h = this.axisList, c = this.axisIndex, e = h.length, g = 0;g !== e;g++) {
				var k = h[g];
				k.aabbNeedsUpdate && k.computeAABB();
			}
			0 === c ? b.insertionSortX(h) : 1 === c ? b.insertionSortY(h) : 2 === c && b.insertionSortZ(h);
		};
		b.checkBounds = function(b, c, e) {
			var g, h;
			0 === e ? (g = b.position.x, h = c.position.x) : 1 === e ? (g = b.position.y, h = c.position.y) : 2 === e && (g = b.position.z, h = c.position.z);
			return g + b.boundingRadius > h - c.boundingRadius;
		};
		b.prototype.autoDetectAxis = function() {
			for (var b = 0, c = 0, e = 0, g = 0, k = 0, f = 0, l = this.axisList, p = l.length, t = 1 / p, v = 0;v !== p;v++) {
				var y = l[v], x = y.position.x, b = b + x, c = c + x * x, x = y.position.y, e = e + x, g = g + x * x, y = y.position.z, k = k + y, f = f + y * y
			}
			b = c - b * b * t;
			e = g - e * e * t;
			k = f - k * k * t;
			this.axisIndex = b > e ? b > k ? 0 : 2 : e > k ? 1 : 2;
		};
		b.prototype.aabbQuery = function(b, c, e) {
			e = e || [];
			this.dirty && (this.sortList(), this.dirty = !1);
			b = this.axisIndex;
			var g = "x";
			1 === b && (g = "y");
			2 === b && (g = "z");
			b = this.axisList;
			for (g = (c.lowerBound[g], c.upperBound[g], 0);g < b.length;g++) {
				var h = b[g];
				h.aabbNeedsUpdate && h.computeAABB();
				h.aabb.overlaps(c) && e.push(h);
			}
			return e;
		};
	}, {"../collision/Broadphase":5, "../shapes/Shape":43}], 12:[function(f, l) {
		function b(b, q, f) {
			f = f || {};
			var g = "undefined" != typeof f.maxForce ? f.maxForce : 1E6, p = f.pivotA ? f.pivotA.clone() : new e, r = f.pivotB ? f.pivotB.clone() : new e;
			this.axisA = f.axisA ? f.axisA.clone() : new e;
			this.axisB = f.axisB ? f.axisB.clone() : new e;
			k.call(this, b, p, q, r, g);
			this.collideConnected = !!f.collideConnected;
			this.angle = "undefined" != typeof f.angle ? f.angle : 0;
			p = this.coneEquation = new h(b, q, f);
			b = this.twistEquation = new c(b, q, f);
			this.twistAngle = "undefined" != typeof f.twistAngle ? f.twistAngle : 0;
			p.maxForce = 0;
			p.minForce = -g;
			b.maxForce = 0;
			b.minForce = -g;
			this.equations.push(p, b);
		}
		l.exports = b;
		var k = (f("./Constraint"), f("./PointToPointConstraint")), h = f("../equations/ConeEquation"), c = f("../equations/RotationalEquation"), e = (f("../equations/ContactEquation"), f("../math/Vec3"));
		b.prototype = new k;
		b.constructor = b;
		new e;
		new e;
		b.prototype.update = function() {
			var b = this.bodyA, c = this.bodyB, e = this.coneEquation, h = this.twistEquation;
			k.prototype.update.call(this);
			b.vectorToWorldFrame(this.axisA, e.axisA);
			c.vectorToWorldFrame(this.axisB, e.axisB);
			this.axisA.tangents(h.axisA, h.axisA);
			b.vectorToWorldFrame(h.axisA, h.axisA);
			this.axisB.tangents(h.axisB, h.axisB);
			c.vectorToWorldFrame(h.axisB, h.axisB);
			e.angle = this.angle;
			h.maxAngle = this.twistAngle;
		};
	}, {"../equations/ConeEquation":18, "../equations/ContactEquation":19, "../equations/RotationalEquation":22, "../math/Vec3":30, "./Constraint":13, "./PointToPointConstraint":17}], 13:[function(f, l) {
		function b(h, c, e) {
			e = k.defaults(e, {collideConnected:!0, wakeUpBodies:!0});
			this.equations = [];
			this.bodyA = h;
			this.bodyB = c;
			this.id = b.idCounter++;
			this.collideConnected = e.collideConnected;
			e.wakeUpBodies && (h && h.wakeUp(), c && c.wakeUp());
		}
		l.exports = b;
		var k = f("../utils/Utils");
		b.prototype.update = function() {
			throw Error("method update() not implmemented in this Constraint subclass!");
		};
		b.prototype.enable = function() {
			for (var b = this.equations, c = 0;c < b.length;c++) {
				b[c].enabled = !0;
			}
		};
		b.prototype.disable = function() {
			for (var b = this.equations, c = 0;c < b.length;c++) {
				b[c].enabled = !1;
			}
		};
		b.idCounter = 0;
	}, {"../utils/Utils":53}], 14:[function(f, l) {
		function b(b, e, g, q) {
			k.call(this, b, e);
			"undefined" == typeof g && (g = b.position.distanceTo(e.position));
			"undefined" == typeof q && (q = 1E6);
			this.distance = g;
			b = this.distanceEquation = new h(b, e);
			this.equations.push(b);
			b.minForce = -q;
			b.maxForce = q;
		}
		l.exports = b;
		var k = f("./Constraint"), h = f("../equations/ContactEquation");
		b.prototype = new k;
		b.prototype.update = function() {
			var b = this.distanceEquation, e = .5 * this.distance, g = b.ni;
			this.bodyB.position.vsub(this.bodyA.position, g);
			g.normalize();
			g.mult(e, b.ri);
			g.mult(-e, b.rj);
		};
	}, {"../equations/ContactEquation":19, "./Constraint":13}], 15:[function(f, l) {
		function b(b, g, q) {
			q = q || {};
			var f = "undefined" != typeof q.maxForce ? q.maxForce : 1E6, p = q.pivotA ? q.pivotA.clone() : new e, r = q.pivotB ? q.pivotB.clone() : new e;
			k.call(this, b, p, g, r, f);
			(this.axisA = q.axisA ? q.axisA.clone() : new e(1, 0, 0)).normalize();
			(this.axisB = q.axisB ? q.axisB.clone() : new e(1, 0, 0)).normalize();
			p = this.rotationalEquation1 = new h(b, g, q);
			q = this.rotationalEquation2 = new h(b, g, q);
			b = this.motorEquation = new c(b, g, f);
			b.enabled = !1;
			this.equations.push(p, q, b);
		}
		l.exports = b;
		var k = (f("./Constraint"), f("./PointToPointConstraint")), h = f("../equations/RotationalEquation"), c = f("../equations/RotationalMotorEquation"), e = (f("../equations/ContactEquation"), f("../math/Vec3"));
		b.prototype = new k;
		b.constructor = b;
		b.prototype.enableMotor = function() {
			this.motorEquation.enabled = !0;
		};
		b.prototype.disableMotor = function() {
			this.motorEquation.enabled = !1;
		};
		b.prototype.setMotorSpeed = function(b) {
			this.motorEquation.targetVelocity = b;
		};
		b.prototype.setMotorMaxForce = function(b) {
			this.motorEquation.maxForce = b;
			this.motorEquation.minForce = -b;
		};
		var g = new e, q = new e;
		b.prototype.update = function() {
			var b = this.bodyA, c = this.bodyB, e = this.motorEquation, h = this.rotationalEquation1, f = this.rotationalEquation2, l = this.axisA, x = this.axisB;
			k.prototype.update.call(this);
			b.quaternion.vmult(l, g);
			c.quaternion.vmult(x, q);
			g.tangents(h.axisA, f.axisA);
			h.axisB.copy(q);
			f.axisB.copy(q);
			this.motorEquation.enabled && (b.quaternion.vmult(this.axisA, e.axisA), c.quaternion.vmult(this.axisB, e.axisB));
		};
	}, {"../equations/ContactEquation":19, "../equations/RotationalEquation":22, "../equations/RotationalMotorEquation":23, "../math/Vec3":30, "./Constraint":13, "./PointToPointConstraint":17}], 16:[function(f, l) {
		function b(b, g, q) {
			q = q || {};
			var e = "undefined" != typeof q.maxForce ? q.maxForce : 1E6, f = new c, p = new c, l = new c;
			b.position.vadd(g.position, l);
			l.scale(.5, l);
			g.pointToLocalFrame(l, p);
			b.pointToLocalFrame(l, f);
			k.call(this, b, f, g, p, e);
			e = this.rotationalEquation1 = new h(b, g, q);
			f = this.rotationalEquation2 = new h(b, g, q);
			b = this.rotationalEquation3 = new h(b, g, q);
			this.equations.push(e, f, b);
		}
		l.exports = b;
		var k = (f("./Constraint"), f("./PointToPointConstraint")), h = f("../equations/RotationalEquation"), c = (f("../equations/RotationalMotorEquation"), f("../equations/ContactEquation"), f("../math/Vec3"));
		b.prototype = new k;
		b.constructor = b;
		new c;
		new c;
		b.prototype.update = function() {
			var b = this.bodyA, g = this.bodyB, h = (this.motorEquation, this.rotationalEquation1), f = this.rotationalEquation2, l = this.rotationalEquation3;
			k.prototype.update.call(this);
			b.vectorToWorldFrame(c.UNIT_X, h.axisA);
			g.vectorToWorldFrame(c.UNIT_Y, h.axisB);
			b.vectorToWorldFrame(c.UNIT_Y, f.axisA);
			g.vectorToWorldFrame(c.UNIT_Z, f.axisB);
			b.vectorToWorldFrame(c.UNIT_Z, l.axisA);
			g.vectorToWorldFrame(c.UNIT_X, l.axisB);
		};
	}, {"../equations/ContactEquation":19, "../equations/RotationalEquation":22, "../equations/RotationalMotorEquation":23, "../math/Vec3":30, "./Constraint":13, "./PointToPointConstraint":17}], 17:[function(f, l) {
		function b(b, g, q, f, l) {
			k.call(this, b, q);
			l = "undefined" != typeof l ? l : 1E6;
			this.pivotA = g ? g.clone() : new c;
			this.pivotB = f ? f.clone() : new c;
			g = this.equationX = new h(b, q);
			f = this.equationY = new h(b, q);
			b = this.equationZ = new h(b, q);
			this.equations.push(g, f, b);
			g.minForce = f.minForce = b.minForce = -l;
			g.maxForce = f.maxForce = b.maxForce = l;
			g.ni.set(1, 0, 0);
			f.ni.set(0, 1, 0);
			b.ni.set(0, 0, 1);
		}
		l.exports = b;
		var k = f("./Constraint"), h = f("../equations/ContactEquation"), c = f("../math/Vec3");
		b.prototype = new k;
		b.prototype.update = function() {
			var b = this.bodyB, c = this.equationX, h = this.equationY, k = this.equationZ;
			this.bodyA.quaternion.vmult(this.pivotA, c.ri);
			b.quaternion.vmult(this.pivotB, c.rj);
			h.ri.copy(c.ri);
			h.rj.copy(c.rj);
			k.ri.copy(c.ri);
			k.rj.copy(c.rj);
		};
	}, {"../equations/ContactEquation":19, "../math/Vec3":30, "./Constraint":13}], 18:[function(f, l) {
		function b(b, c, e) {
			e = e || {};
			var g = "undefined" != typeof e.maxForce ? e.maxForce : 1E6;
			h.call(this, b, c, -g, g);
			this.axisA = e.axisA ? e.axisA.clone() : new k(1, 0, 0);
			this.axisB = e.axisB ? e.axisB.clone() : new k(0, 1, 0);
			this.angle = "undefined" != typeof e.angle ? e.angle : 0;
		}
		l.exports = b;
		var k = f("../math/Vec3"), h = (f("../math/Mat3"), f("./Equation"));
		b.prototype = new h;
		b.prototype.constructor = b;
		var c = new k, e = new k;
		b.prototype.computeB = function(b) {
			var g = this.a, h = this.b, k = this.axisA, f = this.axisB, l = this.jacobianElementA, v = this.jacobianElementB;
			k.cross(f, c);
			f.cross(k, e);
			l.rotational.copy(e);
			v.rotational.copy(c);
			k = Math.cos(this.angle) - k.dot(f);
			f = this.computeGW();
			l = this.computeGiMf();
			return -k * g - f * h - b * l;
		};
	}, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 19:[function(f, l) {
		function b(b, c, e) {
			k.call(this, b, c, 0, "undefined" != typeof e ? e : 1E6);
			this.restitution = 0;
			this.ri = new h;
			this.rj = new h;
			this.ni = new h;
		}
		l.exports = b;
		var k = f("./Equation"), h = f("../math/Vec3");
		f("../math/Mat3");
		b.prototype = new k;
		b.prototype.constructor = b;
		var c = new h, e = new h, g = new h;
		b.prototype.computeB = function(b) {
			var h = this.a, k = this.b, m = this.bi, q = this.bj, f = this.ri, p = this.rj, r = m.velocity, l = m.angularVelocity, w = (m.force, m.torque, q.velocity), t = q.angularVelocity, v = (q.force, q.torque, g), I = this.jacobianElementA, Q = this.jacobianElementB, M = this.ni;
			f.cross(M, c);
			p.cross(M, e);
			M.negate(I.spatial);
			c.negate(I.rotational);
			Q.spatial.copy(M);
			Q.rotational.copy(e);
			v.copy(q.position);
			v.vadd(p, v);
			v.vsub(m.position, v);
			v.vsub(f, v);
			m = M.dot(v);
			q = this.restitution + 1;
			r = q * w.dot(M) - q * r.dot(M) + t.dot(e) - l.dot(c);
			l = this.computeGiMf();
			return -m * h - r * k - b * l;
		};
		var q = new h, r = new h, w = new h, p = new h, t = new h;
		b.prototype.getImpactVelocityAlongNormal = function() {
			return this.bi.position.vadd(this.ri, w), this.bj.position.vadd(this.rj, p), this.bi.getVelocityAtWorldPoint(w, q), this.bj.getVelocityAtWorldPoint(p, r), q.vsub(r, t), this.ni.dot(t);
		};
	}, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 20:[function(f, l) {
		function b(c, e, g, h) {
			this.id = b.id++;
			this.minForce = "undefined" == typeof g ? -1E6 : g;
			this.maxForce = "undefined" == typeof h ? 1E6 : h;
			this.bi = c;
			this.bj = e;
			this.eps = this.b = this.a = 0;
			this.jacobianElementA = new k;
			this.jacobianElementB = new k;
			this.enabled = !0;
			this.setSpookParams(1E7, 4, 1 / 60);
		}
		l.exports = b;
		var k = f("../math/JacobianElement");
		f = f("../math/Vec3");
		b.prototype.constructor = b;
		b.id = 0;
		b.prototype.setSpookParams = function(b, c, e) {
			this.a = 4 / (e * (1 + 4 * c));
			this.b = 4 * c / (1 + 4 * c);
			this.eps = 4 / (e * e * b * (1 + 4 * c));
		};
		b.prototype.computeB = function(b, c, e) {
			var g = this.computeGW(), h = this.computeGq(), m = this.computeGiMf();
			return -h * b - g * c - m * e;
		};
		b.prototype.computeGq = function() {
			var b = this.jacobianElementB, c = this.bj.position;
			return this.jacobianElementA.spatial.dot(this.bi.position) + b.spatial.dot(c);
		};
		var h = new f;
		b.prototype.computeGW = function() {
			var b = this.jacobianElementB, c = this.bi, e = this.bj, g = e.velocity, e = e.angularVelocity || h;
			return this.jacobianElementA.multiplyVectors(c.velocity, c.angularVelocity || h) + b.multiplyVectors(g, e);
		};
		b.prototype.computeGWlambda = function() {
			var b = this.jacobianElementB, c = this.bi, e = this.bj, g = e.vlambda, e = e.wlambda || h;
			return this.jacobianElementA.multiplyVectors(c.vlambda, c.wlambda || h) + b.multiplyVectors(g, e);
		};
		var c = new f, e = new f, g = new f, q = new f;
		b.prototype.computeGiMf = function() {
			var b = this.jacobianElementA, h = this.jacobianElementB, k = this.bi, f = this.bj, r = k.force, m = k.torque, u = f.force, l = f.torque, w = k.invMassSolve, D = f.invMassSolve;
			return k.invInertiaWorldSolve ? k.invInertiaWorldSolve.vmult(m, g) : g.set(0, 0, 0), f.invInertiaWorldSolve ? f.invInertiaWorldSolve.vmult(l, q) : q.set(0, 0, 0), r.mult(w, c), u.mult(D, e), b.multiplyVectors(c, g) + h.multiplyVectors(e, q);
		};
		var r = new f;
		b.prototype.computeGiMGt = function() {
			var b = this.jacobianElementA, c = this.jacobianElementB, e = this.bi, g = this.bj, h = e.invInertiaWorldSolve, m = g.invInertiaWorldSolve, e = e.invMassSolve + g.invMassSolve;
			return h && (h.vmult(b.rotational, r), e += r.dot(b.rotational)), m && (m.vmult(c.rotational, r), e += r.dot(c.rotational)), e;
		};
		var w = new f;
		new f;
		new f;
		new f;
		new f;
		new f;
		b.prototype.addToWlambda = function(b) {
			var c = this.jacobianElementA, e = this.jacobianElementB, g = this.bi, h = this.bj;
			c.spatial.mult(g.invMassSolve * b, w);
			g.vlambda.vadd(w, g.vlambda);
			e.spatial.mult(h.invMassSolve * b, w);
			h.vlambda.vadd(w, h.vlambda);
			g.invInertiaWorldSolve && (g.invInertiaWorldSolve.vmult(c.rotational, w), w.mult(b, w), g.wlambda.vadd(w, g.wlambda));
			h.invInertiaWorldSolve && (h.invInertiaWorldSolve.vmult(e.rotational, w), w.mult(b, w), h.wlambda.vadd(w, h.wlambda));
		};
		b.prototype.computeC = function() {
			return this.computeGiMGt() + this.eps;
		};
	}, {"../math/JacobianElement":26, "../math/Vec3":30}], 21:[function(f, l) {
		function b(b, c, e) {
			k.call(this, b, c, -e, e);
			this.ri = new h;
			this.rj = new h;
			this.t = new h;
		}
		l.exports = b;
		var k = f("./Equation"), h = f("../math/Vec3");
		f("../math/Mat3");
		b.prototype = new k;
		b.prototype.constructor = b;
		var c = new h, e = new h;
		b.prototype.computeB = function(b) {
			var g = (this.a, this.b), h = (this.bi, this.bj, this.ri), k = this.rj, f = this.t;
			h.cross(f, c);
			k.cross(f, e);
			h = this.jacobianElementA;
			k = this.jacobianElementB;
			f.negate(h.spatial);
			c.negate(h.rotational);
			k.spatial.copy(f);
			k.rotational.copy(e);
			f = this.computeGW();
			h = this.computeGiMf();
			return -f * g - b * h;
		};
	}, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 22:[function(f, l) {
		function b(b, c, e) {
			e = e || {};
			var g = "undefined" != typeof e.maxForce ? e.maxForce : 1E6;
			h.call(this, b, c, -g, g);
			this.axisA = e.axisA ? e.axisA.clone() : new k(1, 0, 0);
			this.axisB = e.axisB ? e.axisB.clone() : new k(0, 1, 0);
			this.maxAngle = Math.PI / 2;
		}
		l.exports = b;
		var k = f("../math/Vec3"), h = (f("../math/Mat3"), f("./Equation"));
		b.prototype = new h;
		b.prototype.constructor = b;
		var c = new k, e = new k;
		b.prototype.computeB = function(b) {
			var g = this.a, h = this.b, k = this.axisA, f = this.axisB, l = this.jacobianElementA, v = this.jacobianElementB;
			k.cross(f, c);
			f.cross(k, e);
			l.rotational.copy(e);
			v.rotational.copy(c);
			k = Math.cos(this.maxAngle) - k.dot(f);
			f = this.computeGW();
			l = this.computeGiMf();
			return -k * g - f * h - b * l;
		};
	}, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 23:[function(f, l) {
		function b(b, e, g) {
			g = "undefined" != typeof g ? g : 1E6;
			h.call(this, b, e, -g, g);
			this.axisA = new k;
			this.axisB = new k;
			this.targetVelocity = 0;
		}
		l.exports = b;
		var k = f("../math/Vec3"), h = (f("../math/Mat3"), f("./Equation"));
		b.prototype = new h;
		b.prototype.constructor = b;
		b.prototype.computeB = function(b) {
			var c = (this.a, this.b), g = (this.bi, this.bj, this.axisA), h = this.axisB, k = this.jacobianElementB;
			this.jacobianElementA.rotational.copy(g);
			h.negate(k.rotational);
			g = this.computeGW() - this.targetVelocity;
			h = this.computeGiMf();
			return -g * c - b * h;
		};
	}, {"../math/Mat3":27, "../math/Vec3":30, "./Equation":20}], 24:[function(f, l) {
		function b(h, c, e) {
			e = k.defaults(e, {friction:.3, restitution:.3, contactEquationStiffness:1E7, contactEquationRelaxation:3, frictionEquationStiffness:1E7, frictionEquationRelaxation:3});
			this.id = b.idCounter++;
			this.materials = [h, c];
			this.friction = e.friction;
			this.restitution = e.restitution;
			this.contactEquationStiffness = e.contactEquationStiffness;
			this.contactEquationRelaxation = e.contactEquationRelaxation;
			this.frictionEquationStiffness = e.frictionEquationStiffness;
			this.frictionEquationRelaxation = e.frictionEquationRelaxation;
		}
		var k = f("../utils/Utils");
		l.exports = b;
		b.idCounter = 0;
	}, {"../utils/Utils":53}], 25:[function(f, l) {
		function b(k) {
			var h = "";
			k = k || {};
			"string" == typeof k ? (h = k, k = {}) : "object" == typeof k && (h = "");
			this.name = h;
			this.id = b.idCounter++;
			this.friction = "undefined" != typeof k.friction ? k.friction : -1;
			this.restitution = "undefined" != typeof k.restitution ? k.restitution : -1;
		}
		l.exports = b;
		b.idCounter = 0;
	}, {}], 26:[function(f, l) {
		function b() {
			this.spatial = new k;
			this.rotational = new k;
		}
		l.exports = b;
		var k = f("./Vec3");
		b.prototype.multiplyElement = function(b) {
			return b.spatial.dot(this.spatial) + b.rotational.dot(this.rotational);
		};
		b.prototype.multiplyVectors = function(b, c) {
			return b.dot(this.spatial) + c.dot(this.rotational);
		};
	}, {"./Vec3":30}], 27:[function(f, l) {
		function b(b) {
			this.elements = b ? b : [0, 0, 0, 0, 0, 0, 0, 0, 0];
		}
		l.exports = b;
		var k = f("./Vec3");
		b.prototype.identity = function() {
			var b = this.elements;
			b[0] = 1;
			b[1] = 0;
			b[2] = 0;
			b[3] = 0;
			b[4] = 1;
			b[5] = 0;
			b[6] = 0;
			b[7] = 0;
			b[8] = 1;
		};
		b.prototype.setZero = function() {
			var b = this.elements;
			b[0] = 0;
			b[1] = 0;
			b[2] = 0;
			b[3] = 0;
			b[4] = 0;
			b[5] = 0;
			b[6] = 0;
			b[7] = 0;
			b[8] = 0;
		};
		b.prototype.setTrace = function(b) {
			var c = this.elements;
			c[0] = b.x;
			c[4] = b.y;
			c[8] = b.z;
		};
		b.prototype.getTrace = function(b) {
			b = b || new k;
			var c = this.elements;
			b.x = c[0];
			b.y = c[4];
			b.z = c[8];
		};
		b.prototype.vmult = function(b, c) {
			c = c || new k;
			var e = this.elements, g = b.x, h = b.y;
			b = b.z;
			return c.x = e[0] * g + e[1] * h + e[2] * b, c.y = e[3] * g + e[4] * h + e[5] * b, c.z = e[6] * g + e[7] * h + e[8] * b, c;
		};
		b.prototype.smult = function(b) {
			for (var c = 0;c < this.elements.length;c++) {
				this.elements[c] *= b;
			}
		};
		b.prototype.mmult = function(h, c) {
			c = c || new b;
			for (var e = 0;3 > e;e++) {
				for (var g = 0;3 > g;g++) {
					for (var k = 0, f = 0;3 > f;f++) {
						k += h.elements[e + 3 * f] * this.elements[f + 3 * g];
					}
					c.elements[e + 3 * g] = k;
				}
			}
			return c;
		};
		b.prototype.scale = function(h, c) {
			c = c || new b;
			for (var e = this.elements, g = c.elements, k = 0;3 !== k;k++) {
				g[3 * k + 0] = h.x * e[3 * k + 0], g[3 * k + 1] = h.y * e[3 * k + 1], g[3 * k + 2] = h.z * e[3 * k + 2];
			}
			return c;
		};
		b.prototype.solve = function(b, c) {
			c = c || new k;
			for (var e = [], g = 0;12 > g;g++) {
				e.push(0);
			}
			for (var h, g = 0;3 > g;g++) {
				for (h = 0;3 > h;h++) {
					e[g + 4 * h] = this.elements[g + 3 * h];
				}
			}
			e[3] = b.x;
			e[7] = b.y;
			e[11] = b.z;
			var f, l, p = 3, t = p;
			do {
				if (g = t - p, 0 === e[g + 4 * g]) {
					for (h = g + 1;t > h;h++) {
						if (0 !== e[g + 4 * h]) {
							f = 4;
							do {
								l = 4 - f, e[l + 4 * g] += e[l + 4 * h];
							} while (--f);
							break;
						}
					}
				}
				if (0 !== e[g + 4 * g]) {
					for (h = g + 1;t > h;h++) {
						var v = e[g + 4 * h] / e[g + 4 * g];
						f = 4;
						do {
							l = 4 - f, e[l + 4 * h] = g >= l ? 0 : e[l + 4 * h] - e[l + 4 * g] * v;
						} while (--f);
					}
				}
			} while (--p);
			if (c.z = e[11] / e[10], c.y = (e[7] - e[6] * c.z) / e[5], c.x = (e[3] - e[2] * c.z - e[1] * c.y) / e[0], isNaN(c.x) || isNaN(c.y) || isNaN(c.z) || 1 / 0 === c.x || 1 / 0 === c.y || 1 / 0 === c.z) {
				throw "Could not solve equation! Got x=[" + c.toString() + "], b=[" + b.toString() + "], A=[" + this.toString() + "]";
			}
			return c;
		};
		b.prototype.e = function(b, c, e) {
			return void 0 === e ? this.elements[c + 3 * b] : void(this.elements[c + 3 * b] = e);
		};
		b.prototype.copy = function(b) {
			for (var c = 0;c < b.elements.length;c++) {
				this.elements[c] = b.elements[c];
			}
			return this;
		};
		b.prototype.toString = function() {
			for (var b = "", c = 0;9 > c;c++) {
				b += this.elements[c] + ",";
			}
			return b;
		};
		b.prototype.reverse = function(h) {
			h = h || new b;
			for (var c = [], e = 0;18 > e;e++) {
				c.push(0);
			}
			for (var g, e = 0;3 > e;e++) {
				for (g = 0;3 > g;g++) {
					c[e + 6 * g] = this.elements[e + 3 * g];
				}
			}
			c[3] = 1;
			c[9] = 0;
			c[15] = 0;
			c[4] = 0;
			c[10] = 1;
			c[16] = 0;
			c[5] = 0;
			c[11] = 0;
			c[17] = 1;
			var k, f, l = 3, p = l;
			do {
				if (e = p - l, 0 === c[e + 6 * e]) {
					for (g = e + 1;p > g;g++) {
						if (0 !== c[e + 6 * g]) {
							k = 6;
							do {
								f = 6 - k, c[f + 6 * e] += c[f + 6 * g];
							} while (--k);
							break;
						}
					}
				}
				if (0 !== c[e + 6 * e]) {
					for (g = e + 1;p > g;g++) {
						var t = c[e + 6 * g] / c[e + 6 * e];
						k = 6;
						do {
							f = 6 - k, c[f + 6 * g] = e >= f ? 0 : c[f + 6 * g] - c[f + 6 * e] * t;
						} while (--k);
					}
				}
			} while (--l);
			e = 2;
			do {
				g = e - 1;
				do {
					t = c[e + 6 * g] / c[e + 6 * e];
					k = 6;
					do {
						f = 6 - k, c[f + 6 * g] -= c[f + 6 * e] * t;
					} while (--k);
				} while (g--);
			} while (--e);
			e = 2;
			do {
				t = 1 / c[e + 6 * e];
				k = 6;
				do {
					f = 6 - k, c[f + 6 * e] *= t;
				} while (--k);
			} while (e--);
			e = 2;
			do {
				g = 2;
				do {
					if (f = c[3 + g + 6 * e], isNaN(f) || 1 / 0 === f) {
						throw "Could not reverse! A=[" + this.toString() + "]";
					}
					h.e(e, g, f);
				} while (g--);
			} while (e--);
			return h;
		};
		b.prototype.setRotationFromQuaternion = function(b) {
			var c = b.x, e = b.y, g = b.z, h = b.w, k = c + c, f = e + e, p = g + g;
			b = c * k;
			var l = c * f, c = c * p, v = e * f, e = e * p, g = g * p, k = h * k, f = h * f, h = h * p, p = this.elements;
			return p[0] = 1 - (v + g), p[1] = l - h, p[2] = c + f, p[3] = l + h, p[4] = 1 - (b + g), p[5] = e - k, p[6] = c - f, p[7] = e + k, p[8] = 1 - (b + v), this;
		};
		b.prototype.transpose = function(h) {
			h = h || new b;
			for (var c = h.elements, e = this.elements, g = 0;3 !== g;g++) {
				for (var k = 0;3 !== k;k++) {
					c[3 * g + k] = e[3 * k + g];
				}
			}
			return h;
		};
	}, {"./Vec3":30}], 28:[function(f, l) {
		function b(b, c, e, g) {
			this.x = void 0 !== b ? b : 0;
			this.y = void 0 !== c ? c : 0;
			this.z = void 0 !== e ? e : 0;
			this.w = void 0 !== g ? g : 1;
		}
		l.exports = b;
		var k = f("./Vec3");
		b.prototype.set = function(b, c, e, g) {
			this.x = b;
			this.y = c;
			this.z = e;
			this.w = g;
		};
		b.prototype.toString = function() {
			return this.x + "," + this.y + "," + this.z + "," + this.w;
		};
		b.prototype.toArray = function() {
			return [this.x, this.y, this.z, this.w];
		};
		b.prototype.setFromAxisAngle = function(b, c) {
			var e = Math.sin(.5 * c);
			this.x = b.x * e;
			this.y = b.y * e;
			this.z = b.z * e;
			this.w = Math.cos(.5 * c);
		};
		b.prototype.toAxisAngle = function(b) {
			b = b || new k;
			this.normalize();
			var c = 2 * Math.acos(this.w), e = Math.sqrt(1 - this.w * this.w);
			return .001 > e ? (b.x = this.x, b.y = this.y, b.z = this.z) : (b.x = this.x / e, b.y = this.y / e, b.z = this.z / e), [b, c];
		};
		var h = new k, c = new k;
		b.prototype.setFromVectors = function(b, e) {
			if (b.isAntiparallelTo(e)) {
				b.tangents(h, c), this.setFromAxisAngle(h, Math.PI);
			} else {
				var g = b.cross(e);
				this.x = g.x;
				this.y = g.y;
				this.z = g.z;
				this.w = Math.sqrt(Math.pow(b.norm(), 2) * Math.pow(e.norm(), 2)) + b.dot(e);
				this.normalize();
			}
		};
		var e = new k, g = new k, q = new k;
		b.prototype.mult = function(c, h) {
			h = h || new b;
			var k = this.w;
			return e.set(this.x, this.y, this.z), g.set(c.x, c.y, c.z), h.w = k * c.w - e.dot(g), e.cross(g, q), h.x = k * g.x + c.w * e.x + q.x, h.y = k * g.y + c.w * e.y + q.y, h.z = k * g.z + c.w * e.z + q.z, h;
		};
		b.prototype.inverse = function(c) {
			var e = this.x, g = this.y, h = this.z, k = this.w;
			c = c || new b;
			this.conjugate(c);
			e = 1 / (e * e + g * g + h * h + k * k);
			return c.x *= e, c.y *= e, c.z *= e, c.w *= e, c;
		};
		b.prototype.conjugate = function(c) {
			return c = c || new b, c.x = -this.x, c.y = -this.y, c.z = -this.z, c.w = this.w, c;
		};
		b.prototype.normalize = function() {
			var b = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
			0 === b ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (b = 1 / b, this.x *= b, this.y *= b, this.z *= b, this.w *= b);
		};
		b.prototype.normalizeFast = function() {
			var b = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
			0 === b ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= b, this.y *= b, this.z *= b, this.w *= b);
		};
		b.prototype.vmult = function(b, c) {
			c = c || new k;
			var e = b.x, g = b.y, h = b.z;
			b = this.x;
			var f = this.y, q = this.z, m = this.w, l = m * e + f * h - q * g, r = m * g + q * e - b * h, w = m * h + b * g - f * e, e = -b * e - f * g - q * h;
			return c.x = l * m + e * -b + r * -q - w * -f, c.y = r * m + e * -f + w * -b - l * -q, c.z = w * m + e * -q + l * -f - r * -b, c;
		};
		b.prototype.copy = function(b) {
			return this.x = b.x, this.y = b.y, this.z = b.z, this.w = b.w, this;
		};
		b.prototype.toEuler = function(b, c) {
			c = c || "YZX";
			var e, g, h, k = this.x, f = this.y, m = this.z, q = this.w;
			switch(c) {
				case "YZX":
					c = k * f + m * q;
					if (.499 < c && (e = 2 * Math.atan2(k, q), g = Math.PI / 2, h = 0), -.499 > c && (e = -2 * Math.atan2(k, q), g = -Math.PI / 2, h = 0), isNaN(e)) {
						h = m * m, e = Math.atan2(2 * f * q - 2 * k * m, 1 - 2 * f * f - 2 * h), g = Math.asin(2 * c), h = Math.atan2(2 * k * q - 2 * f * m, 1 - 2 * k * k - 2 * h);
					}
					break;
				default:
					throw Error("Euler order " + c + " not supported yet.");;
			}
			b.y = e;
			b.z = g;
			b.x = h;
		};
		b.prototype.setFromEuler = function(b, c, e, g) {
			g = g || "XYZ";
			var h = Math.cos(b / 2), k = Math.cos(c / 2), f = Math.cos(e / 2);
			b = Math.sin(b / 2);
			c = Math.sin(c / 2);
			e = Math.sin(e / 2);
			return "XYZ" === g ? (this.x = b * k * f + h * c * e, this.y = h * c * f - b * k * e, this.z = h * k * e + b * c * f, this.w = h * k * f - b * c * e) : "YXZ" === g ? (this.x = b * k * f + h * c * e, this.y = h * c * f - b * k * e, this.z = h * k * e - b * c * f, this.w = h * k * f + b * c * e) : "ZXY" === g ? (this.x = b * k * f - h * c * e, this.y = h * c * f + b * k * e, this.z = h * k * e + b * c * f, this.w = h * k * f - b * c * e) : "ZYX" === g ? (this.x = b * k * f - h * c * e, this.y = 
			h * c * f + b * k * e, this.z = h * k * e - b * c * f, this.w = h * k * f + b * c * e) : "YZX" === g ? (this.x = b * k * f + h * c * e, this.y = h * c * f + b * k * e, this.z = h * k * e - b * c * f, this.w = h * k * f - b * c * e) : "XZY" === g && (this.x = b * k * f - h * c * e, this.y = h * c * f - b * k * e, this.z = h * k * e + b * c * f, this.w = h * k * f + b * c * e), this;
		};
		b.prototype.clone = function() {
			return new b(this.x, this.y, this.z, this.w);
		};
	}, {"./Vec3":30}], 29:[function(f, l) {
		function b(b) {
			b = b || {};
			this.position = new k;
			b.position && this.position.copy(b.position);
			this.quaternion = new h;
			b.quaternion && this.quaternion.copy(b.quaternion);
		}
		var k = f("./Vec3"), h = f("./Quaternion");
		l.exports = b;
		var c = new h;
		b.pointToLocalFrame = function(b, g, h, f) {
			f = f || new k;
			return h.vsub(b, f), g.conjugate(c), c.vmult(f, f), f;
		};
		b.prototype.pointToLocal = function(c, g) {
			return b.pointToLocalFrame(this.position, this.quaternion, c, g);
		};
		b.pointToWorldFrame = function(b, c, h, f) {
			f = f || new k;
			return c.vmult(h, f), f.vadd(b, f), f;
		};
		b.prototype.pointToWorld = function(c, g) {
			return b.pointToWorldFrame(this.position, this.quaternion, c, g);
		};
		b.prototype.vectorToWorldFrame = function(b, c) {
			c = c || new k;
			return this.quaternion.vmult(b, c), c;
		};
		b.vectorToWorldFrame = function(b, c, h) {
			return b.vmult(c, h), h;
		};
		b.vectorToLocalFrame = function(b, c, h, f) {
			f = f || new k;
			return c.w *= -1, c.vmult(h, f), c.w *= -1, f;
		};
	}, {"./Quaternion":28, "./Vec3":30}], 30:[function(f, l) {
		function b(b, c, e) {
			this.x = b || 0;
			this.y = c || 0;
			this.z = e || 0;
		}
		l.exports = b;
		var k = f("./Mat3");
		b.ZERO = new b(0, 0, 0);
		b.UNIT_X = new b(1, 0, 0);
		b.UNIT_Y = new b(0, 1, 0);
		b.UNIT_Z = new b(0, 0, 1);
		b.prototype.cross = function(c, e) {
			var g = c.x, h = c.y;
			c = c.z;
			var k = this.x, f = this.y, q = this.z;
			return e = e || new b, e.x = f * c - q * h, e.y = q * g - k * c, e.z = k * h - f * g, e;
		};
		b.prototype.set = function(b, c, e) {
			return this.x = b, this.y = c, this.z = e, this;
		};
		b.prototype.setZero = function() {
			this.x = this.y = this.z = 0;
		};
		b.prototype.vadd = function(c, e) {
			return e ? (e.x = c.x + this.x, e.y = c.y + this.y, e.z = c.z + this.z, void 0) : new b(this.x + c.x, this.y + c.y, this.z + c.z);
		};
		b.prototype.vsub = function(c, e) {
			return e ? (e.x = this.x - c.x, e.y = this.y - c.y, e.z = this.z - c.z, void 0) : new b(this.x - c.x, this.y - c.y, this.z - c.z);
		};
		b.prototype.crossmat = function() {
			return new k([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
		};
		b.prototype.normalize = function() {
			var b = this.x, c = this.y, e = this.z, b = Math.sqrt(b * b + c * c + e * e);
			0 < b ? (c = 1 / b, this.x *= c, this.y *= c, this.z *= c) : this.z = this.y = this.x = 0;
			return b;
		};
		b.prototype.unit = function(c) {
			c = c || new b;
			var e = this.x, g = this.y, h = this.z, k = Math.sqrt(e * e + g * g + h * h);
			return 0 < k ? (k = 1 / k, c.x = e * k, c.y = g * k, c.z = h * k) : (c.x = 1, c.y = 0, c.z = 0), c;
		};
		b.prototype.norm = function() {
			var b = this.x, c = this.y, e = this.z;
			return Math.sqrt(b * b + c * c + e * e);
		};
		b.prototype.length = b.prototype.norm;
		b.prototype.norm2 = function() {
			return this.dot(this);
		};
		b.prototype.lengthSquared = b.prototype.norm2;
		b.prototype.distanceTo = function(b) {
			var c = this.x, e = this.y, g = this.z, h = b.x, k = b.y;
			b = b.z;
			return Math.sqrt((h - c) * (h - c) + (k - e) * (k - e) + (b - g) * (b - g));
		};
		b.prototype.distanceSquared = function(b) {
			var c = this.x, e = this.y, g = this.z, h = b.x, k = b.y;
			b = b.z;
			return (h - c) * (h - c) + (k - e) * (k - e) + (b - g) * (b - g);
		};
		b.prototype.mult = function(c, e) {
			e = e || new b;
			var g = this.y, h = this.z;
			return e.x = c * this.x, e.y = c * g, e.z = c * h, e;
		};
		b.prototype.scale = b.prototype.mult;
		b.prototype.dot = function(b) {
			return this.x * b.x + this.y * b.y + this.z * b.z;
		};
		b.prototype.isZero = function() {
			return 0 === this.x && 0 === this.y && 0 === this.z;
		};
		b.prototype.negate = function(c) {
			return c = c || new b, c.x = -this.x, c.y = -this.y, c.z = -this.z, c;
		};
		var h = new b, c = new b;
		b.prototype.tangents = function(b, e) {
			var g = this.norm();
			0 < g ? (g = 1 / g, h.set(this.x * g, this.y * g, this.z * g), .9 > Math.abs(h.x) ? (c.set(1, 0, 0), h.cross(c, b)) : (c.set(0, 1, 0), h.cross(c, b)), h.cross(b, e)) : (b.set(1, 0, 0), e.set(0, 1, 0));
		};
		b.prototype.toString = function() {
			return this.x + "," + this.y + "," + this.z;
		};
		b.prototype.toArray = function() {
			return [this.x, this.y, this.z];
		};
		b.prototype.copy = function(b) {
			return this.x = b.x, this.y = b.y, this.z = b.z, this;
		};
		b.prototype.lerp = function(b, c, e) {
			var g = this.x, h = this.y, k = this.z;
			e.x = g + (b.x - g) * c;
			e.y = h + (b.y - h) * c;
			e.z = k + (b.z - k) * c;
		};
		b.prototype.almostEquals = function(b, c) {
			return void 0 === c && (c = 1E-6), Math.abs(this.x - b.x) > c || Math.abs(this.y - b.y) > c || Math.abs(this.z - b.z) > c ? !1 : !0;
		};
		b.prototype.almostZero = function(b) {
			return void 0 === b && (b = 1E-6), Math.abs(this.x) > b || Math.abs(this.y) > b || Math.abs(this.z) > b ? !1 : !0;
		};
		var e = new b;
		b.prototype.isAntiparallelTo = function(b, c) {
			return this.negate(e), e.almostEquals(b, c);
		};
		b.prototype.clone = function() {
			return new b(this.x, this.y, this.z);
		};
	}, {"./Mat3":27}], 31:[function(f, l) {
		function b(m) {
			m = m || {};
			k.apply(this);
			this.id = b.idCounter++;
			this.postStep = this.preStep = this.world = null;
			this.vlambda = new h;
			this.collisionFilterGroup = "number" == typeof m.collisionFilterGroup ? m.collisionFilterGroup : 1;
			this.collisionFilterMask = "number" == typeof m.collisionFilterMask ? m.collisionFilterMask : 1;
			this.collisionResponse = !0;
			this.position = new h;
			m.position && this.position.copy(m.position);
			this.previousPosition = new h;
			this.initPosition = new h;
			this.velocity = new h;
			m.velocity && this.velocity.copy(m.velocity);
			this.initVelocity = new h;
			this.force = new h;
			var f = "number" == typeof m.mass ? m.mass : 0;
			this.mass = f;
			this.invMass = 0 < f ? 1 / f : 0;
			this.material = m.material || null;
			this.linearDamping = "number" == typeof m.linearDamping ? m.linearDamping : .01;
			this.type = 0 >= f ? b.STATIC : b.DYNAMIC;
			typeof m.type == typeof b.STATIC && (this.type = m.type);
			this.allowSleep = "undefined" != typeof m.allowSleep ? m.allowSleep : !0;
			this.sleepState = 0;
			this.sleepSpeedLimit = "undefined" != typeof m.sleepSpeedLimit ? m.sleepSpeedLimit : .1;
			this.sleepTimeLimit = "undefined" != typeof m.sleepTimeLimit ? m.sleepTimeLimit : 1;
			this.timeLastSleepy = 0;
			this._wakeUpAfterNarrowphase = !1;
			this.torque = new h;
			this.quaternion = new e;
			m.quaternion && this.quaternion.copy(m.quaternion);
			this.initQuaternion = new e;
			this.angularVelocity = new h;
			m.angularVelocity && this.angularVelocity.copy(m.angularVelocity);
			this.initAngularVelocity = new h;
			this.interpolatedPosition = new h;
			this.interpolatedQuaternion = new e;
			this.shapes = [];
			this.shapeOffsets = [];
			this.shapeOrientations = [];
			this.inertia = new h;
			this.invInertia = new h;
			this.invInertiaWorld = new c;
			this.invMassSolve = 0;
			this.invInertiaSolve = new h;
			this.invInertiaWorldSolve = new c;
			this.fixedRotation = "undefined" != typeof m.fixedRotation ? m.fixedRotation : !1;
			this.angularDamping = "undefined" != typeof m.angularDamping ? m.angularDamping : .01;
			this.aabb = new g;
			this.aabbNeedsUpdate = !0;
			this.wlambda = new h;
			m.shape && this.addShape(m.shape);
			this.updateMassProperties();
		}
		l.exports = b;
		var k = f("../utils/EventTarget"), h = (f("../shapes/Shape"), f("../math/Vec3")), c = f("../math/Mat3"), e = f("../math/Quaternion"), g = (f("../material/Material"), f("../collision/AABB")), q = f("../shapes/Box");
		b.prototype = new k;
		b.prototype.constructor = b;
		b.DYNAMIC = 1;
		b.STATIC = 2;
		b.KINEMATIC = 4;
		b.AWAKE = 0;
		b.SLEEPY = 1;
		b.SLEEPING = 2;
		b.idCounter = 0;
		b.prototype.wakeUp = function() {
			var c = this.sleepState;
			this.sleepState = 0;
			c === b.SLEEPING && this.dispatchEvent({type:"wakeup"});
		};
		b.prototype.sleep = function() {
			this.sleepState = b.SLEEPING;
			this.velocity.set(0, 0, 0);
			this.angularVelocity.set(0, 0, 0);
		};
		b.sleepyEvent = {type:"sleepy"};
		b.sleepEvent = {type:"sleep"};
		b.prototype.sleepTick = function(c) {
			if (this.allowSleep) {
				var e = this.sleepState, g = this.velocity.norm2() + this.angularVelocity.norm2(), m = Math.pow(this.sleepSpeedLimit, 2);
				e === b.AWAKE && m > g ? (this.sleepState = b.SLEEPY, this.timeLastSleepy = c, this.dispatchEvent(b.sleepyEvent)) : e === b.SLEEPY && g > m ? this.wakeUp() : e === b.SLEEPY && c - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), this.dispatchEvent(b.sleepEvent));
			}
		};
		b.prototype.updateSolveMassProperties = function() {
			this.sleepState === b.SLEEPING || this.type === b.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld));
		};
		b.prototype.pointToLocalFrame = function(b, c) {
			c = c || new h;
			return b.vsub(this.position, c), this.quaternion.conjugate().vmult(c, c), c;
		};
		b.prototype.vectorToLocalFrame = function(b, c) {
			c = c || new h;
			return this.quaternion.conjugate().vmult(b, c), c;
		};
		b.prototype.pointToWorldFrame = function(b, c) {
			c = c || new h;
			return this.quaternion.vmult(b, c), c.vadd(this.position, c), c;
		};
		b.prototype.vectorToWorldFrame = function(b, c) {
			c = c || new h;
			return this.quaternion.vmult(b, c), c;
		};
		var r = new h, w = new e;
		b.prototype.addShape = function(b, c, g) {
			var m = new h, k = new e;
			return c && m.copy(c), g && k.copy(g), this.shapes.push(b), this.shapeOffsets.push(m), this.shapeOrientations.push(k), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, this;
		};
		b.prototype.updateBoundingRadius = function() {
			for (var b = this.shapes, c = this.shapeOffsets, e = b.length, g = 0, m = 0;m !== e;m++) {
				var h = b[m];
				h.updateBoundingSphereRadius();
				var k = c[m].norm(), h = h.boundingSphereRadius;
				k + h > g && (g = k + h);
			}
			this.boundingRadius = g;
		};
		var p = new g;
		b.prototype.computeAABB = function() {
			for (var b = this.shapes, c = this.shapeOffsets, e = this.shapeOrientations, g = b.length, m = this.quaternion, h = this.aabb, k = 0;k !== g;k++) {
				var f = b[k];
				e[k].mult(m, w);
				w.vmult(c[k], r);
				r.vadd(this.position, r);
				f.calculateWorldAABB(r, w, p.lowerBound, p.upperBound);
				0 === k ? h.copy(p) : h.extend(p);
			}
			this.aabbNeedsUpdate = !1;
		};
		var t = new c, v = new c;
		new c;
		b.prototype.updateInertiaWorld = function(b) {
			var c = this.invInertia;
			if (c.x !== c.y || c.y !== c.z || b) {
				t.setRotationFromQuaternion(this.quaternion), t.transpose(v), t.scale(c, t), t.mmult(v, this.invInertiaWorld);
			}
		};
		var y = new h, x = new h;
		b.prototype.applyForce = function(c, e) {
			this.type === b.DYNAMIC && (e.vsub(this.position, y), y.cross(c, x), this.force.vadd(c, this.force), this.torque.vadd(x, this.torque));
		};
		var m = new h, u = new h;
		b.prototype.applyLocalForce = function(c, e) {
			this.type === b.DYNAMIC && (this.vectorToWorldFrame(c, m), this.pointToWorldFrame(e, u), this.applyForce(m, u));
		};
		var B = new h, A = new h, D = new h;
		b.prototype.applyImpulse = function(c, e) {
			this.type === b.DYNAMIC && (e.vsub(this.position, B), A.copy(c), A.mult(this.invMass, A), this.velocity.vadd(A, this.velocity), B.cross(c, D), this.invInertiaWorld.vmult(D, D), this.angularVelocity.vadd(D, this.angularVelocity));
		};
		var G = new h, F = new h;
		b.prototype.applyLocalImpulse = function(c, e) {
			this.type === b.DYNAMIC && (this.vectorToWorldFrame(c, G), this.pointToWorldFrame(e, F), this.applyImpulse(G, F));
		};
		var C = new h;
		b.prototype.updateMassProperties = function() {
			this.invMass = 0 < this.mass ? 1 / this.mass : 0;
			var b = this.inertia, c = this.fixedRotation;
			this.computeAABB();
			C.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);
			q.calculateInertia(C, this.mass, b);
			this.invInertia.set(0 < b.x && !c ? 1 / b.x : 0, 0 < b.y && !c ? 1 / b.y : 0, 0 < b.z && !c ? 1 / b.z : 0);
			this.updateInertiaWorld(!0);
		};
		b.prototype.getVelocityAtWorldPoint = function(b, c) {
			var e = new h;
			return b.vsub(this.position, e), this.angularVelocity.cross(e, c), this.velocity.vadd(c, c), c;
		};
	}, {"../collision/AABB":3, "../material/Material":25, "../math/Mat3":27, "../math/Quaternion":28, "../math/Vec3":30, "../shapes/Box":37, "../shapes/Shape":43, "../utils/EventTarget":49}], 32:[function(f, l) {
		function b(b) {
			this.chassisBody = b.chassisBody;
			this.wheelInfos = [];
			this.sliding = !1;
			this.world = null;
			this.indexRightAxis = "undefined" != typeof b.indexRightAxis ? b.indexRightAxis : 1;
			this.indexForwardAxis = "undefined" != typeof b.indexForwardAxis ? b.indexForwardAxis : 0;
			this.indexUpAxis = "undefined" != typeof b.indexUpAxis ? b.indexUpAxis : 2;
		}
		function k(b, c, e) {
			var g = D, m = G, h = F, k = C;
			return c.vsub(b.position, g), g.cross(e, m), b.invInertiaWorld.vmult(m, k), k.cross(g, h), b.invMass + e.dot(h);
		}
		var h = (f("./Body"), f("../math/Vec3")), c = f("../math/Quaternion"), e = (f("../collision/RaycastResult"), f("../collision/Ray")), g = f("../objects/WheelInfo");
		l.exports = b;
		var q = (new h, new h, new h, new h), r = new h, w = new h;
		new e;
		b.prototype.addWheel = function(b) {
			b = b || {};
			b = new g(b);
			var c = this.wheelInfos.length;
			return this.wheelInfos.push(b), c;
		};
		b.prototype.setSteeringValue = function(b, c) {
			this.wheelInfos[c].steering = b;
		};
		new h;
		b.prototype.applyEngineForce = function(b, c) {
			this.wheelInfos[c].engineForce = b;
		};
		b.prototype.setBrake = function(b, c) {
			this.wheelInfos[c].brake = b;
		};
		b.prototype.addToWorld = function(b) {
			this.constraints;
			b.add(this.chassisBody);
			var c = this;
			this.preStepCallback = function() {
				c.updateVehicle(b.dt);
			};
			b.addEventListener("preStep", this.preStepCallback);
			this.world = b;
		};
		b.prototype.getVehicleAxisWorld = function(b, c) {
			c.set(0 === b ? 1 : 0, 1 === b ? 1 : 0, 2 === b ? 1 : 0);
			this.chassisBody.vectorToWorldFrame(c, c);
		};
		b.prototype.updateVehicle = function(b) {
			for (var c = this.wheelInfos, e = c.length, g = this.chassisBody, m = 0;e > m;m++) {
				this.updateWheelTransform(m);
			}
			this.currentVehicleSpeedKmHour = 3.6 * g.velocity.norm();
			m = new h;
			this.getVehicleAxisWorld(this.indexForwardAxis, m);
			0 > m.dot(g.velocity) && (this.currentVehicleSpeedKmHour *= -1);
			for (m = 0;e > m;m++) {
				this.castRay(c[m]);
			}
			this.updateSuspension(b);
			for (var k = new h, f = new h, m = 0;e > m;m++) {
				var q = c[m], p = q.suspensionForce;
				p > q.maxSuspensionForce && (p = q.maxSuspensionForce);
				q.raycastResult.hitNormalWorld.scale(p * b, k);
				q.raycastResult.hitPointWorld.vsub(g.position, f);
				g.applyImpulse(k, q.raycastResult.hitPointWorld);
			}
			this.updateFriction(b);
			k = new h;
			f = new h;
			p = new h;
			for (m = 0;e > m;m++) {
				q = c[m];
				g.getVelocityAtWorldPoint(q.chassisConnectionPointWorld, p);
				var l = 1;
				switch(this.indexUpAxis) {
					case 1:
						l = -1;
				}
				if (q.isInContact) {
					this.getVehicleAxisWorld(this.indexForwardAxis, f);
					var u = f.dot(q.raycastResult.hitNormalWorld);
					q.raycastResult.hitNormalWorld.scale(u, k);
					f.vsub(k, f);
					u = f.dot(p);
					q.deltaRotation = l * u * b / q.radius;
				}
				!q.sliding && q.isInContact || 0 === q.engineForce || !q.useCustomSlidingRotationalSpeed || (q.deltaRotation = (0 < q.engineForce ? 1 : -1) * q.customSlidingRotationalSpeed * b);
				Math.abs(q.brake) > Math.abs(q.engineForce) && (q.deltaRotation = 0);
				q.rotation += q.deltaRotation;
				q.deltaRotation *= .99;
			}
		};
		b.prototype.updateSuspension = function() {
			for (var b = this.chassisBody.mass, c = this.wheelInfos, e = c.length, g = 0;e > g;g++) {
				var m = c[g];
				if (m.isInContact) {
					var h;
					h = m.suspensionStiffness * (m.suspensionRestLength - m.suspensionLength) * m.clippedInvContactDotSuspension;
					var k = m.suspensionRelativeVelocity;
					h -= (0 > k ? m.dampingCompression : m.dampingRelaxation) * k;
					m.suspensionForce = h * b;
					0 > m.suspensionForce && (m.suspensionForce = 0);
				} else {
					m.suspensionForce = 0;
				}
			}
		};
		b.prototype.removeFromWorld = function(b) {
			this.constraints;
			b.remove(this.chassisBody);
			b.removeEventListener("preStep", this.preStepCallback);
			this.world = null;
		};
		var p = new h, t = new h;
		b.prototype.castRay = function(b) {
			this.updateWheelTransformWorld(b);
			var c = this.chassisBody, e = -1;
			b.directionWorld.scale(b.suspensionRestLength + b.radius, p);
			var g = b.chassisConnectionPointWorld;
			g.vadd(p, t);
			var m = b.raycastResult;
			m.reset();
			var k = c.collisionResponse;
			c.collisionResponse = !1;
			this.world.rayTest(g, t, m);
			c.collisionResponse = k;
			g = m.body;
			(b.raycastResult.groundObject = 0, g) ? (e = m.distance, b.raycastResult.hitNormalWorld = m.hitNormalWorld, b.isInContact = !0, b.suspensionLength = m.distance - b.radius, m = b.suspensionRestLength - b.maxSuspensionTravel, g = b.suspensionRestLength + b.maxSuspensionTravel, b.suspensionLength < m && (b.suspensionLength = m), b.suspensionLength > g && (b.suspensionLength = g, b.raycastResult.reset()), m = b.raycastResult.hitNormalWorld.dot(b.directionWorld), g = new h, c.getVelocityAtWorldPoint(b.raycastResult.hitPointWorld, 
			g), c = b.raycastResult.hitNormalWorld.dot(g), -.1 <= m ? (b.suspensionRelativeVelocity = 0, b.clippedInvContactDotSuspension = 10) : (m = -1 / m, b.suspensionRelativeVelocity = c * m, b.clippedInvContactDotSuspension = m)) : (b.suspensionLength = b.suspensionRestLength + 0 * b.maxSuspensionTravel, b.suspensionRelativeVelocity = 0, b.directionWorld.scale(-1, b.raycastResult.hitNormalWorld), b.clippedInvContactDotSuspension = 1);
			return e;
		};
		b.prototype.updateWheelTransformWorld = function(b) {
			b.isInContact = !1;
			var c = this.chassisBody;
			c.pointToWorldFrame(b.chassisConnectionPointLocal, b.chassisConnectionPointWorld);
			c.vectorToWorldFrame(b.directionLocal, b.directionWorld);
			c.vectorToWorldFrame(b.axleLocal, b.axleWorld);
		};
		b.prototype.updateWheelTransform = function(b) {
			b = this.wheelInfos[b];
			this.updateWheelTransformWorld(b);
			b.directionLocal.scale(-1, q);
			r.copy(b.axleLocal);
			q.cross(r, w);
			w.normalize();
			r.normalize();
			var e = b.steering, g = new c;
			g.setFromAxisAngle(q, e);
			e = new c;
			e.setFromAxisAngle(r, b.rotation);
			var m = b.worldTransform.quaternion;
			this.chassisBody.quaternion.mult(g, m);
			m.mult(e, m);
			m.normalize();
			g = b.worldTransform.position;
			g.copy(b.directionWorld);
			g.scale(b.suspensionLength, g);
			g.vadd(b.chassisConnectionPointWorld, g);
		};
		var v = [new h(1, 0, 0), new h(0, 1, 0), new h(0, 0, 1)];
		b.prototype.getWheelTransformWorld = function(b) {
			return this.wheelInfos[b].worldTransform;
		};
		var y = new h, x = [], m = [];
		b.prototype.updateFriction = function(b) {
			for (var c = this.wheelInfos, e = c.length, g = this.chassisBody, f = 0, q = 0;e > q;q++) {
				var p = c[q], l = p.raycastResult.body;
				l && f++;
				p.sideImpulse = 0;
				p.forwardImpulse = 0;
				m[q] || (m[q] = new h);
				x[q] || (x[q] = new h);
			}
			for (q = 0;e > q;q++) {
				if (p = c[q], l = p.raycastResult.body) {
					var r = x[q];
					this.getWheelTransformWorld(q).vectorToWorldFrame(v[this.indexRightAxis], r);
					var f = p.raycastResult.hitNormalWorld, w = r.dot(f);
					f.scale(w, y);
					r.vsub(y, r);
					r.normalize();
					f.cross(r, m[q]);
					m[q].normalize();
					f = p;
					var w = g, t = p.raycastResult.hitPointWorld, C = p.raycastResult.hitPointWorld;
					if (1.1 < r.norm2()) {
						l = 0;
					} else {
						var G = J, F = I, D = Q;
						w.getVelocityAtWorldPoint(t, G);
						l.getVelocityAtWorldPoint(C, F);
						G.vsub(F, D);
						l = -.2 * r.dot(D) * (1 / (w.invMass + l.invMass));
					}
					f.sideImpulse = l;
					p.sideImpulse *= 1;
				}
			}
			this.sliding = !1;
			for (q = 0;e > q;q++) {
				p = c[q];
				l = p.raycastResult.body;
				t = 0;
				if (p.slipInfo = 1, l) {
					var f = p.brake ? p.brake : 0, F = g, C = l, r = p.raycastResult.hitPointWorld, G = m[q], t = f, w = 0, D = r, M = u, ra = B, qa = A;
					F.getVelocityAtWorldPoint(D, M);
					C.getVelocityAtWorldPoint(D, ra);
					M.vsub(ra, qa);
					D = G.dot(qa);
					F = k(F, r, G);
					C = k(C, r, G);
					t = (w = 1 / (F + C) * -D, w > t && (w = t), -t > w && (w = -t), w);
					t += p.engineForce * b;
					f /= t;
					p.slipInfo *= f;
				}
				if (p.forwardImpulse = 0, p.skidInfo = 1, l) {
					if (p.skidInfo = 1, l = p.suspensionForce * b * p.frictionSlip, f = l * l, p.forwardImpulse = t, w = .5 * p.forwardImpulse, t = 1 * p.sideImpulse, w = w * w + t * t, p.sliding = !1, w > f) {
						this.sliding = !0, p.sliding = !0, f = l / Math.sqrt(w), p.skidInfo *= f;
					}
				}
			}
			if (this.sliding) {
				for (q = 0;e > q;q++) {
					p = c[q], 0 !== p.sideImpulse && 1 > p.skidInfo && (p.forwardImpulse *= p.skidInfo, p.sideImpulse *= p.skidInfo);
				}
			}
			for (q = 0;e > q;q++) {
				p = c[q];
				b = new h;
				if (b.copy(p.raycastResult.hitPointWorld), 0 !== p.forwardImpulse) {
					l = new h, m[q].scale(p.forwardImpulse, l), g.applyImpulse(l, b);
				}
				0 !== p.sideImpulse && (l = p.raycastResult.body, f = new h, f.copy(p.raycastResult.hitPointWorld), w = new h, x[q].scale(p.sideImpulse, w), g.pointToLocalFrame(b, b), b["xyz"[this.indexUpAxis]] *= p.rollInfluence, g.pointToWorldFrame(b, b), g.applyImpulse(w, b), w.scale(-1, w), l.applyImpulse(w, f));
			}
		};
		var u = new h, B = new h, A = new h, D = new h, G = new h, F = new h, C = new h, J = new h, I = new h, Q = new h;
	}, {"../collision/Ray":9, "../collision/RaycastResult":10, "../math/Quaternion":28, "../math/Vec3":30, "../objects/WheelInfo":36, "./Body":31}], 33:[function(f, l) {
		function b(b) {
			(this.wheelBodies = [], this.coordinateSystem = "undefined" == typeof b.coordinateSystem ? new e(1, 2, 3) : b.coordinateSystem.clone(), this.chassisBody = b.chassisBody, this.chassisBody) || (b = new c(new e(5, 2, .5)), this.chassisBody = new k(1, b));
			this.constraints = [];
			this.wheelAxes = [];
			this.wheelForces = [];
		}
		var k = f("./Body"), h = f("../shapes/Sphere"), c = f("../shapes/Box"), e = f("../math/Vec3"), g = f("../constraints/HingeConstraint");
		l.exports = b;
		b.prototype.addWheel = function(b) {
			b = b || {};
			var c = b.body;
			c || (c = new k(1, new h(1.2)));
			this.wheelBodies.push(c);
			this.wheelForces.push(0);
			var f = (new e, "undefined" != typeof b.position ? b.position.clone() : new e), q = new e;
			this.chassisBody.pointToWorldFrame(f, q);
			c.position.set(q.x, q.y, q.z);
			b = "undefined" != typeof b.axis ? b.axis.clone() : new e(0, 1, 0);
			this.wheelAxes.push(b);
			c = new g(this.chassisBody, c, {pivotA:f, axisA:b, pivotB:e.ZERO, axisB:b, collideConnected:!1});
			return this.constraints.push(c), this.wheelBodies.length - 1;
		};
		b.prototype.setSteeringValue = function(b, c) {
			var e = this.wheelAxes[c], g = Math.cos(b);
			b = Math.sin(b);
			var h = e.x, e = e.y;
			this.constraints[c].axisA.set(g * h - b * e, b * h + g * e, 0);
		};
		b.prototype.setMotorSpeed = function(b, c) {
			c = this.constraints[c];
			c.enableMotor();
			c.motorTargetVelocity = b;
		};
		b.prototype.disableMotor = function(b) {
			this.constraints[b].disableMotor();
		};
		var q = new e;
		b.prototype.setWheelForce = function(b, c) {
			this.wheelForces[c] = b;
		};
		b.prototype.applyWheelForce = function(b, c) {
			var e = this.wheelBodies[c], g = e.torque;
			this.wheelAxes[c].scale(b, q);
			e.vectorToWorldFrame(q, q);
			g.vadd(q, g);
		};
		b.prototype.addToWorld = function(b) {
			for (var c = this.constraints, e = this.wheelBodies.concat([this.chassisBody]), g = 0;g < e.length;g++) {
				b.add(e[g]);
			}
			for (g = 0;g < c.length;g++) {
				b.addConstraint(c[g]);
			}
			b.addEventListener("preStep", this._update.bind(this));
		};
		b.prototype._update = function() {
			for (var b = this.wheelForces, c = 0;c < b.length;c++) {
				this.applyWheelForce(b[c], c);
			}
		};
		b.prototype.removeFromWorld = function(b) {
			for (var c = this.constraints, e = this.wheelBodies.concat([this.chassisBody]), g = 0;g < e.length;g++) {
				b.remove(e[g]);
			}
			for (g = 0;g < c.length;g++) {
				b.removeConstraint(c[g]);
			}
		};
		var r = new e;
		b.prototype.getWheelSpeed = function(b) {
			var c = this.wheelBodies[b].angularVelocity;
			return this.chassisBody.vectorToWorldFrame(this.wheelAxes[b], r), c.dot(r);
		};
	}, {"../constraints/HingeConstraint":15, "../math/Vec3":30, "../shapes/Box":37, "../shapes/Sphere":44, "./Body":31}], 34:[function(f, l) {
		function b() {
			this.particles = [];
			this.speedOfSound = this.smoothingRadius = this.density = 1;
			this.viscosity = .01;
			this.eps = 1E-6;
			this.pressures = [];
			this.densities = [];
			this.neighbors = [];
		}
		l.exports = b;
		l = (f("../shapes/Shape"), f("../math/Vec3"));
		f("../math/Quaternion");
		f("../shapes/Particle");
		f("../objects/Body");
		f("../material/Material");
		b.prototype.add = function(b) {
			this.particles.push(b);
			this.neighbors.length < this.particles.length && this.neighbors.push([]);
		};
		b.prototype.remove = function(b) {
			b = this.particles.indexOf(b);
			-1 !== b && (this.particles.splice(b, 1), this.neighbors.length > this.particles.length && this.neighbors.pop());
		};
		var k = new l;
		b.prototype.getNeighbors = function(b, c) {
			for (var e = this.particles.length, g = b.id, h = this.smoothingRadius * this.smoothingRadius, f = 0;f !== e;f++) {
				var m = this.particles[f];
				m.position.vsub(b.position, k);
				g !== m.id && k.norm2() < h && c.push(m);
			}
		};
		var h = new l, c = new l, e = new l, g = new l, q = new l, r = new l;
		b.prototype.update = function() {
			for (var b = this.particles.length, k = this.speedOfSound, f = this.eps, l = 0;l !== b;l++) {
				var y = this.particles[l], x = this.neighbors[l];
				x.length = 0;
				this.getNeighbors(y, x);
				x.push(this.particles[l]);
				for (var m = x.length, u = 0, B = 0;B !== m;B++) {
					y.position.vsub(x[B].position, h);
					var A = h.norm(), A = this.w(A), u = u + x[B].mass * A;
				}
				this.densities[l] = u;
				this.pressures[l] = k * k * (this.densities[l] - this.density);
			}
			for (l = 0;l !== b;l++) {
				k = this.particles[l];
				c.set(0, 0, 0);
				e.set(0, 0, 0);
				x = this.neighbors[l];
				m = x.length;
				for (B = 0;B !== m;B++) {
					u = x[B], k.position.vsub(u.position, q), A = q.norm(), y = -u.mass * (this.pressures[l] / (this.densities[l] * this.densities[l] + f) + this.pressures[B] / (this.densities[B] * this.densities[B] + f)), this.gradw(q, g), g.mult(y, g), c.vadd(g, c), u.velocity.vsub(k.velocity, r), r.mult(1 / (1E-4 + this.densities[l] * this.densities[B]) * this.viscosity * u.mass, r), y = this.nablaw(A), r.mult(y, r), e.vadd(r, e);
				}
				e.mult(k.mass, e);
				c.mult(k.mass, c);
				k.force.vadd(e, k.force);
				k.force.vadd(c, k.force);
			}
		};
		b.prototype.w = function(b) {
			var c = this.smoothingRadius;
			return 315 / (64 * Math.PI * Math.pow(c, 9)) * Math.pow(c * c - b * b, 3);
		};
		b.prototype.gradw = function(b, c) {
			var e = b.norm(), g = this.smoothingRadius;
			b.mult(945 / (32 * Math.PI * Math.pow(g, 9)) * Math.pow(g * g - e * e, 2), c);
		};
		b.prototype.nablaw = function(b) {
			var c = this.smoothingRadius;
			return 945 / (32 * Math.PI * Math.pow(c, 9)) * (c * c - b * b) * (7 * b * b - 3 * c * c);
		};
	}, {"../material/Material":25, "../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "../shapes/Particle":41, "../shapes/Shape":43}], 35:[function(f, l) {
		function b(b, c, e) {
			e = e || {};
			this.restLength = "number" == typeof e.restLength ? e.restLength : 1;
			this.stiffness = e.stiffness || 100;
			this.damping = e.damping || 1;
			this.bodyA = b;
			this.bodyB = c;
			this.localAnchorA = new k;
			this.localAnchorB = new k;
			e.localAnchorA && this.localAnchorA.copy(e.localAnchorA);
			e.localAnchorB && this.localAnchorB.copy(e.localAnchorB);
			e.worldAnchorA && this.setWorldAnchorA(e.worldAnchorA);
			e.worldAnchorB && this.setWorldAnchorB(e.worldAnchorB);
		}
		var k = f("../math/Vec3");
		l.exports = b;
		b.prototype.setWorldAnchorA = function(b) {
			this.bodyA.pointToLocalFrame(b, this.localAnchorA);
		};
		b.prototype.setWorldAnchorB = function(b) {
			this.bodyB.pointToLocalFrame(b, this.localAnchorB);
		};
		b.prototype.getWorldAnchorA = function(b) {
			this.bodyA.pointToWorldFrame(this.localAnchorA, b);
		};
		b.prototype.getWorldAnchorB = function(b) {
			this.bodyB.pointToWorldFrame(this.localAnchorB, b);
		};
		var h = new k, c = new k, e = new k, g = new k, q = new k, r = new k, w = new k, p = new k, t = new k, v = new k, y = new k;
		b.prototype.applyForce = function() {
			var b = this.stiffness, m = this.damping, k = this.restLength, f = this.bodyA, l = this.bodyB;
			this.getWorldAnchorA(q);
			this.getWorldAnchorB(r);
			q.vsub(f.position, w);
			r.vsub(l.position, p);
			r.vsub(q, h);
			var D = h.norm();
			c.copy(h);
			c.normalize();
			l.velocity.vsub(f.velocity, e);
			l.angularVelocity.cross(p, y);
			e.vadd(y, e);
			f.angularVelocity.cross(w, y);
			e.vsub(y, e);
			c.mult(-b * (D - k) - m * e.dot(c), g);
			f.force.vsub(g, f.force);
			l.force.vadd(g, l.force);
			w.cross(g, t);
			p.cross(g, v);
			f.torque.vsub(t, f.torque);
			l.torque.vadd(v, l.torque);
		};
	}, {"../math/Vec3":30}], 36:[function(f, l) {
		function b(b) {
			b = e.defaults(b, {chassisConnectionPointLocal:new k, chassisConnectionPointWorld:new k, directionLocal:new k, directionWorld:new k, axleLocal:new k, axleWorld:new k, suspensionRestLength:1, suspensionMaxLength:2, radius:1, suspensionStiffness:100, dampingCompression:10, dampingRelaxation:10, frictionSlip:1E4, steering:0, rotation:0, deltaRotation:0, rollInfluence:.01, maxSuspensionForce:Number.MAX_VALUE, isFrontWheel:!0, clippedInvContactDotSuspension:1, suspensionRelativeVelocity:0, suspensionForce:0, 
			skidInfo:0, suspensionLength:0, maxSuspensionTravel:1, useCustomSlidingRotationalSpeed:!1, customSlidingRotationalSpeed:-.1});
			this.maxSuspensionTravel = b.maxSuspensionTravel;
			this.customSlidingRotationalSpeed = b.customSlidingRotationalSpeed;
			this.useCustomSlidingRotationalSpeed = b.useCustomSlidingRotationalSpeed;
			this.sliding = !1;
			this.chassisConnectionPointLocal = b.chassisConnectionPointLocal.clone();
			this.chassisConnectionPointWorld = b.chassisConnectionPointWorld.clone();
			this.directionLocal = b.directionLocal.clone();
			this.directionWorld = b.directionWorld.clone();
			this.axleLocal = b.axleLocal.clone();
			this.axleWorld = b.axleWorld.clone();
			this.suspensionRestLength = b.suspensionRestLength;
			this.suspensionMaxLength = b.suspensionMaxLength;
			this.radius = b.radius;
			this.suspensionStiffness = b.suspensionStiffness;
			this.dampingCompression = b.dampingCompression;
			this.dampingRelaxation = b.dampingRelaxation;
			this.frictionSlip = b.frictionSlip;
			this.deltaRotation = this.rotation = this.steering = 0;
			this.rollInfluence = b.rollInfluence;
			this.maxSuspensionForce = b.maxSuspensionForce;
			this.brake = this.engineForce = 0;
			this.isFrontWheel = b.isFrontWheel;
			this.clippedInvContactDotSuspension = 1;
			this.forwardImpulse = this.sideImpulse = this.suspensionLength = this.skidInfo = this.suspensionForce = this.suspensionRelativeVelocity = 0;
			this.raycastResult = new c;
			this.worldTransform = new h;
			this.isInContact = !1;
		}
		var k = f("../math/Vec3"), h = f("../math/Transform"), c = f("../collision/RaycastResult"), e = f("../utils/Utils");
		l.exports = b;
		var g = new k, q = new k, g = new k;
		b.prototype.updateWheel = function(b) {
			var c = this.raycastResult;
			if (this.isInContact) {
				var e = c.hitNormalWorld.dot(c.directionWorld);
				c.hitPointWorld.vsub(b.position, q);
				b.getVelocityAtWorldPoint(q, g);
				b = c.hitNormalWorld.dot(g);
				-.1 <= e ? (this.suspensionRelativeVelocity = 0, this.clippedInvContactDotSuspension = 10) : (e = -1 / e, this.suspensionRelativeVelocity = b * e, this.clippedInvContactDotSuspension = e);
			} else {
				c.suspensionLength = this.suspensionRestLength, this.suspensionRelativeVelocity = 0, c.directionWorld.scale(-1, c.hitNormalWorld), this.clippedInvContactDotSuspension = 1;
			}
		};
	}, {"../collision/RaycastResult":10, "../math/Transform":29, "../math/Vec3":30, "../utils/Utils":53}], 37:[function(f, l) {
		function b(b) {
			k.call(this);
			this.type = k.types.BOX;
			this.halfExtents = b;
			this.convexPolyhedronRepresentation = null;
			this.updateConvexPolyhedronRepresentation();
			this.updateBoundingSphereRadius();
		}
		l.exports = b;
		var k = f("./Shape"), h = f("../math/Vec3"), c = f("./ConvexPolyhedron");
		b.prototype = new k;
		b.prototype.constructor = b;
		b.prototype.updateConvexPolyhedronRepresentation = function() {
			var b = this.halfExtents.x, e = this.halfExtents.y, g = this.halfExtents.z, b = [new h(-b, -e, -g), new h(b, -e, -g), new h(b, e, -g), new h(-b, e, -g), new h(-b, -e, g), new h(b, -e, g), new h(b, e, g), new h(-b, e, g)];
			this.convexPolyhedronRepresentation = b = (new h(0, 0, 1), new h(0, 1, 0), new h(1, 0, 0), new c(b, [[3, 2, 1, 0], [4, 5, 6, 7], [5, 4, 0, 1], [2, 3, 7, 6], [0, 4, 7, 3], [1, 2, 6, 5]]));
			b.material = this.material;
		};
		b.prototype.calculateLocalInertia = function(c, e) {
			return e = e || new h, b.calculateInertia(this.halfExtents, c, e), e;
		};
		b.calculateInertia = function(b, c, e) {
			e.x = 1 / 12 * c * (4 * b.y * b.y + 4 * b.z * b.z);
			e.y = 1 / 12 * c * (4 * b.x * b.x + 4 * b.z * b.z);
			e.z = 1 / 12 * c * (4 * b.y * b.y + 4 * b.x * b.x);
		};
		b.prototype.getSideNormals = function(b, c) {
			var e = this.halfExtents;
			if (b[0].set(e.x, 0, 0), b[1].set(0, e.y, 0), b[2].set(0, 0, e.z), b[3].set(-e.x, 0, 0), b[4].set(0, -e.y, 0), b[5].set(0, 0, -e.z), void 0 !== c) {
				for (e = 0;e !== b.length;e++) {
					c.vmult(b[e], b[e]);
				}
			}
			return b;
		};
		b.prototype.volume = function() {
			return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
		};
		b.prototype.updateBoundingSphereRadius = function() {
			this.boundingSphereRadius = this.halfExtents.norm();
		};
		var e = new h;
		new h;
		b.prototype.forEachWorldCorner = function(b, c, g) {
			for (var h = this.halfExtents, h = [[h.x, h.y, h.z], [-h.x, h.y, h.z], [-h.x, -h.y, h.z], [-h.x, -h.y, -h.z], [h.x, -h.y, -h.z], [h.x, h.y, -h.z], [-h.x, h.y, -h.z], [h.x, -h.y, h.z]], k = 0;k < h.length;k++) {
				e.set(h[k][0], h[k][1], h[k][2]), c.vmult(e, e), b.vadd(e, e), g(e.x, e.y, e.z);
			}
		};
		var g = [new h, new h, new h, new h, new h, new h, new h, new h];
		b.prototype.calculateWorldAABB = function(b, c, e, h) {
			var k = this.halfExtents;
			g[0].set(k.x, k.y, k.z);
			g[1].set(-k.x, k.y, k.z);
			g[2].set(-k.x, -k.y, k.z);
			g[3].set(-k.x, -k.y, -k.z);
			g[4].set(k.x, -k.y, -k.z);
			g[5].set(k.x, k.y, -k.z);
			g[6].set(-k.x, k.y, -k.z);
			g[7].set(k.x, -k.y, k.z);
			var f = g[0];
			c.vmult(f, f);
			b.vadd(f, f);
			h.copy(f);
			e.copy(f);
			for (k = 1;8 > k;k++) {
				f = g[k];
				c.vmult(f, f);
				b.vadd(f, f);
				var q = f.x, p = f.y, f = f.z;
				q > h.x && (h.x = q);
				p > h.y && (h.y = p);
				f > h.z && (h.z = f);
				q < e.x && (e.x = q);
				p < e.y && (e.y = p);
				f < e.z && (e.z = f);
			}
		};
	}, {"../math/Vec3":30, "./ConvexPolyhedron":38, "./Shape":43}], 38:[function(f, l) {
		function b(b, c, e) {
			k.call(this);
			this.type = k.types.CONVEXPOLYHEDRON;
			this.vertices = b || [];
			this.worldVertices = [];
			this.worldVerticesNeedsUpdate = !0;
			this.faces = c || [];
			this.faceNormals = [];
			this.computeNormals();
			this.worldFaceNormalsNeedsUpdate = !0;
			this.worldFaceNormals = [];
			this.uniqueEdges = [];
			this.uniqueAxes = e ? e.slice() : null;
			this.computeEdges();
			this.updateBoundingSphereRadius();
		}
		l.exports = b;
		var k = f("./Shape"), h = f("../math/Vec3"), c = (f("../math/Quaternion"), f("../math/Transform"));
		b.prototype = new k;
		b.prototype.constructor = b;
		var e = new h;
		b.prototype.computeEdges = function() {
			for (var b = this.faces, c = this.vertices, g = (c.length, this.uniqueEdges), m = g.length = 0;m !== b.length;m++) {
				for (var h = b[m], k = h.length, f = 0;f !== k;f++) {
					c[h[f]].vsub(c[h[(f + 1) % k]], e);
					e.normalize();
					for (var q = !1, p = 0;p !== g.length;p++) {
						if (g[p].almostEquals(e) || g[p].almostEquals(e)) {
							q = !0;
							break;
						}
					}
					q || g.push(e.clone());
				}
			}
		};
		b.prototype.computeNormals = function() {
			this.faceNormals.length = this.faces.length;
			for (var b = 0;b < this.faces.length;b++) {
				for (var c = 0;c < this.faces[b].length;c++) {
					if (!this.vertices[this.faces[b][c]]) {
						throw Error("Vertex " + this.faces[b][c] + " not found!");
					}
				}
				c = this.faceNormals[b] || new h;
				this.getFaceNormal(b, c);
				c.negate(c);
				this.faceNormals[b] = c;
				if (0 > c.dot(this.vertices[this.faces[b][0]])) {
					for (console.error(".faceNormals[" + b + "] = Vec3(" + c.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule."), c = 0;c < this.faces[b].length;c++) {
						console.warn(".vertices[" + this.faces[b][c] + "] = Vec3(" + this.vertices[this.faces[b][c]].toString() + ")");
					}
				}
			}
		};
		var g = new h, q = new h;
		b.computeNormal = function(b, c, e, m) {
			c.vsub(b, q);
			e.vsub(c, g);
			g.cross(q, m);
			m.isZero() || m.normalize();
		};
		b.prototype.getFaceNormal = function(c, e) {
			c = this.faces[c];
			return b.computeNormal(this.vertices[c[0]], this.vertices[c[1]], this.vertices[c[2]], e);
		};
		var r = new h;
		b.prototype.clipAgainstHull = function(b, c, e, g, m, k, f, q, p) {
			for (var l = -1, u = -Number.MAX_VALUE, w = 0;w < e.faces.length;w++) {
				r.copy(e.faceNormals[w]);
				m.vmult(r, r);
				var B = r.dot(k);
				B > u && (u = B, l = w);
			}
			for (var u = [], w = e.faces[l], B = w.length, t = 0;B > t;t++) {
				var v = e.vertices[w[t]], y = new h;
				y.copy(v);
				m.vmult(y, y);
				g.vadd(y, y);
				u.push(y);
			}
			0 <= l && this.clipFaceAgainstHull(k, b, c, u, f, q, p);
		};
		var w = new h, p = new h, t = new h, v = new h, y = new h, x = new h;
		b.prototype.findSeparatingAxis = function(b, c, e, g, m, h, k, f) {
			var q = Number.MAX_VALUE, l = 0;
			if (this.uniqueAxes) {
				for (var u = 0;u !== this.uniqueAxes.length;u++) {
					e.vmult(this.uniqueAxes[u], w);
					var r = this.testSepAxis(w, b, c, e, g, m);
					if (!1 === r) {
						return !1;
					}
					q > r && (q = r, h.copy(w));
				}
			} else {
				for (var B = k ? k.length : this.faces.length, u = 0;B > u;u++) {
					r = k ? k[u] : u;
					w.copy(this.faceNormals[r]);
					e.vmult(w, w);
					r = this.testSepAxis(w, b, c, e, g, m);
					if (!1 === r) {
						return !1;
					}
					q > r && (q = r, h.copy(w));
				}
			}
			if (b.uniqueAxes) {
				for (u = 0;u !== b.uniqueAxes.length;u++) {
					m.vmult(b.uniqueAxes[u], p);
					l++;
					r = this.testSepAxis(p, b, c, e, g, m);
					if (!1 === r) {
						return !1;
					}
					q > r && (q = r, h.copy(p));
				}
			} else {
				for (k = f ? f.length : b.faces.length, u = 0;k > u;u++) {
					r = f ? f[u] : u;
					p.copy(b.faceNormals[r]);
					m.vmult(p, p);
					l++;
					r = this.testSepAxis(p, b, c, e, g, m);
					if (!1 === r) {
						return !1;
					}
					q > r && (q = r, h.copy(p));
				}
			}
			for (f = 0;f !== this.uniqueEdges.length;f++) {
				for (e.vmult(this.uniqueEdges[f], v), l = 0;l !== b.uniqueEdges.length;l++) {
					if (m.vmult(b.uniqueEdges[l], y), v.cross(y, x), !x.almostZero()) {
						x.normalize();
						u = this.testSepAxis(x, b, c, e, g, m);
						if (!1 === u) {
							return !1;
						}
						q > u && (q = u, h.copy(x));
					}
				}
			}
			return g.vsub(c, t), 0 < t.dot(h) && h.negate(h), !0;
		};
		var m = [], u = [];
		b.prototype.testSepAxis = function(c, e, g, h, k, f) {
			b.project(this, c, g, h, m);
			b.project(e, c, k, f, u);
			g = m[0];
			c = m[1];
			e = u[0];
			h = u[1];
			if (h > g || c > e) {
				return !1;
			}
			g -= h;
			c = e - c;
			return c > g ? g : c;
		};
		var B = new h, A = new h;
		b.prototype.calculateLocalInertia = function(b, c) {
			this.computeLocalAABB(B, A);
			var e = A.x - B.x, g = A.y - B.y, m = A.z - B.z;
			c.x = 1 / 12 * b * (4 * g * g + 4 * m * m);
			c.y = 1 / 12 * b * (4 * e * e + 4 * m * m);
			c.z = 1 / 12 * b * (4 * g * g + 4 * e * e);
		};
		b.prototype.getPlaneConstantOfFace = function(b) {
			return -this.faceNormals[b].dot(this.vertices[this.faces[b][0]]);
		};
		var D = new h, G = new h, F = new h, C = new h, J = new h, I = new h, Q = new h, M = new h;
		b.prototype.clipFaceAgainstHull = function(b, c, e, g, m, h, k) {
			for (var f = [], q = -1, p = Number.MAX_VALUE, l = 0;l < this.faces.length;l++) {
				D.copy(this.faceNormals[l]);
				e.vmult(D, D);
				var u = D.dot(b);
				p > u && (p = u, q = l);
			}
			if (!(0 > q)) {
				b = this.faces[q];
				b.connectedFaces = [];
				for (p = 0;p < this.faces.length;p++) {
					for (l = 0;l < this.faces[p].length;l++) {
						-1 !== b.indexOf(this.faces[p][l]) && p !== q && -1 === b.connectedFaces.indexOf(p) && b.connectedFaces.push(p);
					}
				}
				p = (g.length, b.length);
				for (l = 0;p > l;l++) {
					u = this.vertices[b[l]];
					u.vsub(this.vertices[b[(l + 1) % p]], G);
					F.copy(G);
					e.vmult(F, F);
					c.vadd(F, F);
					C.copy(this.faceNormals[q]);
					e.vmult(C, C);
					c.vadd(C, C);
					F.cross(C, J);
					J.negate(J);
					I.copy(u);
					e.vmult(I, I);
					c.vadd(I, I);
					u = (-I.dot(J), b.connectedFaces[l]);
					Q.copy(this.faceNormals[u]);
					u = this.getPlaneConstantOfFace(u);
					M.copy(Q);
					e.vmult(M, M);
					u -= M.dot(c);
					for (this.clipFaceAgainstPlane(g, f, M, u);g.length;) {
						g.shift();
					}
					for (;f.length;) {
						g.push(f.shift());
					}
				}
				Q.copy(this.faceNormals[q]);
				u = this.getPlaneConstantOfFace(q);
				M.copy(Q);
				e.vmult(M, M);
				u -= M.dot(c);
				for (p = 0;p < g.length;p++) {
					if (c = M.dot(g[p]) + u, m >= c && (console.log("clamped: depth=" + c + " to minDist=" + (m + "")), c = m), h >= c) {
						e = g[p], 0 >= c && k.push({point:e, normal:M, depth:c});
					}
				}
			}
		};
		b.prototype.clipFaceAgainstPlane = function(b, c, e, g) {
			var m, k, f = b.length;
			if (2 > f) {
				return c;
			}
			var q = b[b.length - 1], p = b[0];
			m = e.dot(q) + g;
			for (var l = 0;f > l;l++) {
				if (p = b[l], k = e.dot(p) + g, 0 > m) {
					if (0 > k) {
						var u = new h;
						u.copy(p);
					} else {
						u = new h, q.lerp(p, m / (m - k), u);
					}
					c.push(u);
				} else {
					0 > k && (u = new h, q.lerp(p, m / (m - k), u), c.push(u), c.push(p));
				}
				q = p;
				m = k;
			}
			return c;
		};
		b.prototype.computeWorldVertices = function(b, c) {
			for (var e = this.vertices.length;this.worldVertices.length < e;) {
				this.worldVertices.push(new h);
			}
			for (var g = this.vertices, m = this.worldVertices, k = 0;k !== e;k++) {
				c.vmult(g[k], m[k]), b.vadd(m[k], m[k]);
			}
			this.worldVerticesNeedsUpdate = !1;
		};
		new h;
		b.prototype.computeLocalAABB = function(b, c) {
			var e = this.vertices.length, g = this.vertices;
			b.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
			c.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
			for (var m = 0;e > m;m++) {
				var h = g[m];
				h.x < b.x ? b.x = h.x : h.x > c.x && (c.x = h.x);
				h.y < b.y ? b.y = h.y : h.y > c.y && (c.y = h.y);
				h.z < b.z ? b.z = h.z : h.z > c.z && (c.z = h.z);
			}
		};
		b.prototype.computeWorldFaceNormals = function(b) {
			for (var c = this.faceNormals.length;this.worldFaceNormals.length < c;) {
				this.worldFaceNormals.push(new h);
			}
			for (var e = this.faceNormals, g = this.worldFaceNormals, m = 0;m !== c;m++) {
				b.vmult(e[m], g[m]);
			}
			this.worldFaceNormalsNeedsUpdate = !1;
		};
		b.prototype.updateBoundingSphereRadius = function() {
			for (var b = 0, c = this.vertices, e = 0, g = c.length;e !== g;e++) {
				var m = c[e].norm2();
				m > b && (b = m);
			}
			this.boundingSphereRadius = Math.sqrt(b);
		};
		var N = new h;
		b.prototype.calculateWorldAABB = function(b, c, e, g) {
			for (var m, h, k, f, q, p, l = this.vertices.length, u = this.vertices, r = 0;l > r;r++) {
				N.copy(u[r]);
				c.vmult(N, N);
				b.vadd(N, N);
				var w = N;
				w.x < m || void 0 === m ? m = w.x : (w.x > f || void 0 === f) && (f = w.x);
				w.y < h || void 0 === h ? h = w.y : (w.y > q || void 0 === q) && (q = w.y);
				w.z < k || void 0 === k ? k = w.z : (w.z > p || void 0 === p) && (p = w.z);
			}
			e.set(m, h, k);
			g.set(f, q, p);
		};
		b.prototype.volume = function() {
			return 4 * Math.PI * this.boundingSphereRadius / 3;
		};
		b.prototype.getAveragePointLocal = function(b) {
			b = b || new h;
			for (var c = this.vertices.length, e = this.vertices, g = 0;c > g;g++) {
				b.vadd(e[g], b);
			}
			return b.mult(1 / c, b), b;
		};
		b.prototype.transformAllPoints = function(b, c) {
			var e = this.vertices.length, g = this.vertices;
			if (c) {
				for (var m = 0;e > m;m++) {
					var h = g[m];
					c.vmult(h, h);
				}
				for (m = 0;m < this.faceNormals.length;m++) {
					h = this.faceNormals[m], c.vmult(h, h);
				}
			}
			if (b) {
				for (m = 0;e > m;m++) {
					h = g[m], h.vadd(b, h);
				}
			}
		};
		var R = new h, H = new h, ba = new h;
		b.prototype.pointIsInside = function(b) {
			var c, e = this.vertices, g = this.faces, m = this.faceNormals, h = this.faces.length;
			this.getAveragePointLocal(R);
			for (var k = 0;h > k;k++) {
				c = (this.faces[k].length, m[k]);
				var f = e[g[k][0]], q = H;
				b.vsub(f, q);
				var q = c.dot(q), p = ba;
				R.vsub(f, p);
				c = c.dot(p);
				if (0 > q && 0 < c || 0 < q && 0 > c) {
					return !1;
				}
			}
			return -1;
		};
		var ha = (new h, new h), Y = new h;
		b.project = function(b, e, g, m, h) {
			var k = b.vertices.length;
			b = b.vertices;
			Y.setZero();
			c.vectorToLocalFrame(g, m, e, ha);
			c.pointToLocalFrame(g, m, Y, Y);
			m = Y.dot(ha);
			g = e = b[0].dot(ha);
			for (var f = 1;k > f;f++) {
				var q = b[f].dot(ha);
				q > e && (e = q);
				g > q && (g = q);
			}
			if (g -= m, e -= m, g > e) {
				e = g = e;
			}
			h[0] = e;
			h[1] = g;
		};
	}, {"../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "./Shape":43}], 39:[function(f, l) {
		function b(b, g, f, l) {
			var e = [], q = [], r = [], v = [], y = [], x = Math.cos, m = Math.sin;
			e.push(new h(g * x(0), g * m(0), .5 * -f));
			v.push(0);
			e.push(new h(b * x(0), b * m(0), .5 * f));
			y.push(1);
			for (var u = 0;l > u;u++) {
				var B = 2 * Math.PI / l * (u + 1), A = 2 * Math.PI / l * (u + .5);
				l - 1 > u ? (e.push(new h(g * x(B), g * m(B), .5 * -f)), v.push(2 * u + 2), e.push(new h(b * x(B), b * m(B), .5 * f)), y.push(2 * u + 3), r.push([2 * u + 2, 2 * u + 3, 2 * u + 1, 2 * u])) : r.push([0, 1, 2 * u + 1, 2 * u]);
				(1 === l % 2 || l / 2 > u) && q.push(new h(x(A), m(A), 0));
			}
			r.push(y);
			q.push(new h(0, 0, 1));
			b = [];
			for (u = 0;u < v.length;u++) {
				b.push(v[v.length - u - 1]);
			}
			r.push(b);
			this.type = k.types.CONVEXPOLYHEDRON;
			c.call(this, e, r, q);
		}
		l.exports = b;
		var k = f("./Shape"), h = f("../math/Vec3"), c = (f("../math/Quaternion"), f("./ConvexPolyhedron"));
		b.prototype = new c;
	}, {"../math/Quaternion":28, "../math/Vec3":30, "./ConvexPolyhedron":38, "./Shape":43}], 40:[function(f, l) {
		function b(b, f) {
			f = e.defaults(f, {maxValue:null, minValue:null, elementSize:1});
			this.data = b;
			this.maxValue = f.maxValue;
			this.minValue = f.minValue;
			this.elementSize = f.elementSize;
			null === f.minValue && this.updateMinValue();
			null === f.maxValue && this.updateMaxValue();
			this.cacheEnabled = !0;
			k.call(this);
			this.pillarConvex = new h;
			this.pillarOffset = new c;
			this.type = k.types.HEIGHTFIELD;
			this.updateBoundingSphereRadius();
			this._cachedPillars = {};
		}
		var k = f("./Shape"), h = f("./ConvexPolyhedron"), c = f("../math/Vec3"), e = f("../utils/Utils");
		l.exports = b;
		b.prototype = new k;
		b.prototype.update = function() {
			this._cachedPillars = {};
		};
		b.prototype.updateMinValue = function() {
			for (var b = this.data, c = b[0][0], e = 0;e !== b.length;e++) {
				for (var h = 0;h !== b[e].length;h++) {
					var k = b[e][h];
					c > k && (c = k);
				}
			}
			this.minValue = c;
		};
		b.prototype.updateMaxValue = function() {
			for (var b = this.data, c = b[0][0], e = 0;e !== b.length;e++) {
				for (var h = 0;h !== b[e].length;h++) {
					var k = b[e][h];
					k > c && (c = k);
				}
			}
			this.maxValue = c;
		};
		b.prototype.setHeightValueAtIndex = function(b, c, e) {
			this.data[b][c] = e;
			this.clearCachedConvexTrianglePillar(b, c, !1);
			0 < b && (this.clearCachedConvexTrianglePillar(b - 1, c, !0), this.clearCachedConvexTrianglePillar(b - 1, c, !1));
			0 < c && (this.clearCachedConvexTrianglePillar(b, c - 1, !0), this.clearCachedConvexTrianglePillar(b, c - 1, !1));
			0 < c && 0 < b && this.clearCachedConvexTrianglePillar(b - 1, c - 1, !0);
		};
		b.prototype.getRectMinMax = function(b, c, e, h, k) {
			k = k || [];
			for (var g = this.data, f = this.minValue;e >= b;b++) {
				for (var q = c;h >= q;q++) {
					var p = g[b][q];
					p > f && (f = p);
				}
			}
			k[0] = this.minValue;
			k[1] = f;
		};
		b.prototype.getIndexOfPosition = function(b, c, e, h) {
			var g = this.elementSize, k = this.data;
			b = Math.floor(b / g);
			c = Math.floor(c / g);
			return e[0] = b, e[1] = c, h && (0 > b && (b = 0), 0 > c && (c = 0), b >= k.length - 1 && (b = k.length - 1), c >= k[0].length - 1 && (c = k[0].length - 1)), 0 > b || 0 > c || b >= k.length - 1 || c >= k[0].length - 1 ? !1 : !0;
		};
		b.prototype.getHeightAt = function(b, c, e) {
			var g = [];
			this.getIndexOfPosition(b, c, g, e);
			b = [];
			return this.getRectMinMax(g[0], g[1] + 1, g[0], g[1] + 1, b), (b[0] + b[1]) / 2;
		};
		b.prototype.getCacheConvexTrianglePillarKey = function(b, c, e) {
			return b + "_" + c + "_" + (e ? 1 : 0);
		};
		b.prototype.getCachedConvexTrianglePillar = function(b, c, e) {
			return this._cachedPillars[this.getCacheConvexTrianglePillarKey(b, c, e)];
		};
		b.prototype.setCachedConvexTrianglePillar = function(b, c, e, h, k) {
			this._cachedPillars[this.getCacheConvexTrianglePillarKey(b, c, e)] = {convex:h, offset:k};
		};
		b.prototype.clearCachedConvexTrianglePillar = function(b, c, e) {
			delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(b, c, e)];
		};
		b.prototype.getConvexTrianglePillar = function(b, e, k) {
			var g = this.pillarConvex, f = this.pillarOffset;
			if (this.cacheEnabled) {
				var q = this.getCachedConvexTrianglePillar(b, e, k);
				if (q) {
					return this.pillarConvex = q.convex, void(this.pillarOffset = q.offset);
				}
				g = new h;
				f = new c;
				this.pillarConvex = g;
				this.pillarOffset = f;
			}
			var q = this.data, l = this.elementSize, r = g.faces;
			g.vertices.length = 6;
			for (var x = 0;6 > x;x++) {
				g.vertices[x] || (g.vertices[x] = new c);
			}
			r.length = 5;
			for (x = 0;5 > x;x++) {
				r[x] || (r[x] = []);
			}
			var x = g.vertices, m = (Math.min(q[b][e], q[b + 1][e], q[b][e + 1], q[b + 1][e + 1]) - this.minValue) / 2 + this.minValue;
			k ? (f.set((b + .75) * l, (e + .75) * l, m), x[0].set(.25 * l, .25 * l, q[b + 1][e + 1] - m), x[1].set(-.75 * l, .25 * l, q[b][e + 1] - m), x[2].set(.25 * l, -.75 * l, q[b + 1][e] - m), x[3].set(.25 * l, .25 * l, -m - 1), x[4].set(-.75 * l, .25 * l, -m - 1), x[5].set(.25 * l, -.75 * l, -m - 1), r[0][0] = 0, r[0][1] = 1, r[0][2] = 2, r[1][0] = 5, r[1][1] = 4, r[1][2] = 3, r[2][0] = 2, r[2][1] = 5, r[2][2] = 3, r[2][3] = 0, r[3][0] = 3, r[3][1] = 4, r[3][2] = 1, r[3][3] = 0, r[4][0] = 1, r[4][1] = 
			4, r[4][2] = 5, r[4][3] = 2) : (f.set((b + .25) * l, (e + .25) * l, m), x[0].set(-.25 * l, -.25 * l, q[b][e] - m), x[1].set(.75 * l, -.25 * l, q[b + 1][e] - m), x[2].set(-.25 * l, .75 * l, q[b][e + 1] - m), x[3].set(-.25 * l, -.25 * l, -m - 1), x[4].set(.75 * l, -.25 * l, -m - 1), x[5].set(-.25 * l, .75 * l, -m - 1), r[0][0] = 0, r[0][1] = 1, r[0][2] = 2, r[1][0] = 5, r[1][1] = 4, r[1][2] = 3, r[2][0] = 0, r[2][1] = 2, r[2][2] = 5, r[2][3] = 3, r[3][0] = 1, r[3][1] = 0, r[3][2] = 3, r[3][3] = 
			4, r[4][0] = 4, r[4][1] = 5, r[4][2] = 2, r[4][3] = 1);
			g.computeNormals();
			g.computeEdges();
			g.updateBoundingSphereRadius();
			this.setCachedConvexTrianglePillar(b, e, k, g, f);
		};
		b.prototype.calculateLocalInertia = function(b, e) {
			return e = e || new c, e.set(0, 0, 0), e;
		};
		b.prototype.volume = function() {
			return Number.MAX_VALUE;
		};
		b.prototype.calculateWorldAABB = function(b, c, e, h) {
			e.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
			h.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
		};
		b.prototype.updateBoundingSphereRadius = function() {
			var b = this.data, e = this.elementSize;
			this.boundingSphereRadius = (new c(b.length * e, b[0].length * e, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue)))).norm();
		};
	}, {"../math/Vec3":30, "../utils/Utils":53, "./ConvexPolyhedron":38, "./Shape":43}], 41:[function(f, l) {
		function b() {
			k.call(this);
			this.type = k.types.PARTICLE;
		}
		l.exports = b;
		var k = f("./Shape"), h = f("../math/Vec3");
		b.prototype = new k;
		b.prototype.constructor = b;
		b.prototype.calculateLocalInertia = function(b, e) {
			return e = e || new h, e.set(0, 0, 0), e;
		};
		b.prototype.volume = function() {
			return 0;
		};
		b.prototype.updateBoundingSphereRadius = function() {
			this.boundingSphereRadius = 0;
		};
		b.prototype.calculateWorldAABB = function(b, e, g, h) {
			g.copy(b);
			h.copy(b);
		};
	}, {"../math/Vec3":30, "./Shape":43}], 42:[function(f, l) {
		function b() {
			k.call(this);
			this.type = k.types.PLANE;
			this.worldNormal = new h;
			this.worldNormalNeedsUpdate = !0;
			this.boundingSphereRadius = Number.MAX_VALUE;
		}
		l.exports = b;
		var k = f("./Shape"), h = f("../math/Vec3");
		b.prototype = new k;
		b.prototype.constructor = b;
		b.prototype.computeWorldNormal = function(b) {
			var c = this.worldNormal;
			c.set(0, 0, 1);
			b.vmult(c, c);
			this.worldNormalNeedsUpdate = !1;
		};
		b.prototype.calculateLocalInertia = function(b, c) {
			return c || new h;
		};
		b.prototype.volume = function() {
			return Number.MAX_VALUE;
		};
		var c = new h;
		b.prototype.calculateWorldAABB = function(b, g, h, k) {
			c.set(0, 0, 1);
			g.vmult(c, c);
			g = Number.MAX_VALUE;
			h.set(-g, -g, -g);
			k.set(g, g, g);
			1 === c.x && (k.x = b.x);
			1 === c.y && (k.y = b.y);
			1 === c.z && (k.z = b.z);
			-1 === c.x && (h.x = b.x);
			-1 === c.y && (h.y = b.y);
			-1 === c.z && (h.z = b.z);
		};
		b.prototype.updateBoundingSphereRadius = function() {
			this.boundingSphereRadius = Number.MAX_VALUE;
		};
	}, {"../math/Vec3":30, "./Shape":43}], 43:[function(f, l) {
		function b() {
			this.id = b.idCounter++;
			this.boundingSphereRadius = this.type = 0;
			this.collisionResponse = !0;
			this.material = null;
		}
		l.exports = b;
		b = f("./Shape");
		f("../math/Vec3");
		f("../math/Quaternion");
		f("../material/Material");
		b.prototype.constructor = b;
		b.prototype.updateBoundingSphereRadius = function() {
			throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
		};
		b.prototype.volume = function() {
			throw "volume() not implemented for shape type " + this.type;
		};
		b.prototype.calculateLocalInertia = function() {
			throw "calculateLocalInertia() not implemented for shape type " + this.type;
		};
		b.idCounter = 0;
		b.types = {SPHERE:1, PLANE:2, BOX:4, COMPOUND:8, CONVEXPOLYHEDRON:16, HEIGHTFIELD:32, PARTICLE:64, CYLINDER:128, TRIMESH:256};
	}, {"../material/Material":25, "../math/Quaternion":28, "../math/Vec3":30, "./Shape":43}], 44:[function(f, l) {
		function b(b) {
			if (k.call(this), this.radius = void 0 !== b ? Number(b) : 1, this.type = k.types.SPHERE, 0 > this.radius) {
				throw Error("The sphere radius cannot be negative.");
			}
			this.updateBoundingSphereRadius();
		}
		l.exports = b;
		var k = f("./Shape"), h = f("../math/Vec3");
		b.prototype = new k;
		b.prototype.constructor = b;
		b.prototype.calculateLocalInertia = function(b, e) {
			e = e || new h;
			b = 2 * b * this.radius * this.radius / 5;
			return e.x = b, e.y = b, e.z = b, e;
		};
		b.prototype.volume = function() {
			return 4 * Math.PI * this.radius / 3;
		};
		b.prototype.updateBoundingSphereRadius = function() {
			this.boundingSphereRadius = this.radius;
		};
		b.prototype.calculateWorldAABB = function(b, e, g, h) {
			e = this.radius;
			for (var c = ["x", "y", "z"], k = 0;k < c.length;k++) {
				var f = c[k];
				g[f] = b[f] - e;
				h[f] = b[f] + e;
			}
		};
	}, {"../math/Vec3":30, "./Shape":43}], 45:[function(f, l) {
		function b(b, c) {
			k.call(this);
			this.type = k.types.TRIMESH;
			this.vertices = new Float32Array(b);
			this.indices = new Int16Array(c);
			this.normals = new Float32Array(c.length);
			this.aabb = new e;
			this.edges = null;
			this.scale = new h(1, 1, 1);
			this.tree = new g;
			this.updateEdges();
			this.updateNormals();
			this.updateAABB();
			this.updateBoundingSphereRadius();
			this.updateTree();
		}
		l.exports = b;
		var k = f("./Shape"), h = f("../math/Vec3"), c = (f("../math/Quaternion"), f("../math/Transform")), e = f("../collision/AABB"), g = f("../utils/Octree");
		b.prototype = new k;
		b.prototype.constructor = b;
		var q = new h;
		b.prototype.updateTree = function() {
			var b = this.tree;
			b.reset();
			b.aabb.copy(this.aabb);
			var c = this.scale;
			b.aabb.lowerBound.x *= 1 / c.x;
			b.aabb.lowerBound.y *= 1 / c.y;
			b.aabb.lowerBound.z *= 1 / c.z;
			b.aabb.upperBound.x *= 1 / c.x;
			b.aabb.upperBound.y *= 1 / c.y;
			b.aabb.upperBound.z *= 1 / c.z;
			for (var c = new e, g = new h, m = new h, k = new h, f = [g, m, k], q = 0;q < this.indices.length / 3;q++) {
				var p = 3 * q;
				this._getUnscaledVertex(this.indices[p], g);
				this._getUnscaledVertex(this.indices[p + 1], m);
				this._getUnscaledVertex(this.indices[p + 2], k);
				c.setFromPoints(f);
				b.insert(c, q);
			}
			b.removeEmptyNodes();
		};
		var r = new e;
		b.prototype.getTrianglesInAABB = function(b, c) {
			r.copy(b);
			var e = this.scale;
			b = e.x;
			var g = e.y, e = e.z, m = r.lowerBound, h = r.upperBound;
			return m.x /= b, m.y /= g, m.z /= e, h.x /= b, h.y /= g, h.z /= e, this.tree.aabbQuery(r, c);
		};
		b.prototype.setScale = function(b) {
			var c = b.x === b.y === b.z;
			this.scale.x === this.scale.y === this.scale.z && c || this.updateNormals();
			this.scale.copy(b);
			this.updateAABB();
			this.updateBoundingSphereRadius();
		};
		b.prototype.updateNormals = function() {
			for (var c = this.normals, e = 0;e < this.indices.length / 3;e++) {
				var g = 3 * e, h = this.indices[g + 1], k = this.indices[g + 2];
				this.getVertex(this.indices[g], y);
				this.getVertex(h, x);
				this.getVertex(k, m);
				b.computeNormal(x, y, m, q);
				c[g] = q.x;
				c[g + 1] = q.y;
				c[g + 2] = q.z;
			}
		};
		b.prototype.updateEdges = function() {
			for (var b = {}, c = function() {
				b[h > m ? m + "_" + h : h + "_" + m] = !0;
			}, e = 0;e < this.indices.length / 3;e++) {
				var g = 3 * e, m = this.indices[g], h = this.indices[g + 1], g = this.indices[g + 2];
				c(m, h);
				c(h, g);
				c(g, m);
			}
			c = Object.keys(b);
			this.edges = new Int16Array(2 * c.length);
			for (e = 0;e < c.length;e++) {
				g = c[e].split("_"), this.edges[2 * e] = parseInt(g[0], 10), this.edges[2 * e + 1] = parseInt(g[1], 10);
			}
		};
		b.prototype.getEdgeVertex = function(b, c, e) {
			this.getVertex(this.edges[2 * b + (c ? 1 : 0)], e);
		};
		var w = new h, p = new h;
		b.prototype.getEdgeVector = function(b, c) {
			this.getEdgeVertex(b, 0, w);
			this.getEdgeVertex(b, 1, p);
			p.vsub(w, c);
		};
		var t = new h, v = new h;
		b.computeNormal = function(b, c, e, g) {
			c.vsub(b, v);
			e.vsub(c, t);
			t.cross(v, g);
			g.isZero() || g.normalize();
		};
		var y = new h, x = new h, m = new h;
		b.prototype.getVertex = function(b, c) {
			var e = this.scale;
			return this._getUnscaledVertex(b, c), c.x *= e.x, c.y *= e.y, c.z *= e.z, c;
		};
		b.prototype._getUnscaledVertex = function(b, c) {
			b *= 3;
			var e = this.vertices;
			return c.set(e[b], e[b + 1], e[b + 2]);
		};
		b.prototype.getWorldVertex = function(b, e, g, m) {
			return this.getVertex(b, m), c.pointToWorldFrame(e, g, m, m), m;
		};
		b.prototype.getTriangleVertices = function(b, c, e, g) {
			b *= 3;
			this.getVertex(this.indices[b], c);
			this.getVertex(this.indices[b + 1], e);
			this.getVertex(this.indices[b + 2], g);
		};
		b.prototype.getNormal = function(b, c) {
			b *= 3;
			return c.set(this.normals[b], this.normals[b + 1], this.normals[b + 2]);
		};
		var u = new e;
		b.prototype.calculateLocalInertia = function(b, c) {
			this.computeLocalAABB(u);
			var e = u.upperBound.x - u.lowerBound.x, g = u.upperBound.y - u.lowerBound.y, m = u.upperBound.z - u.lowerBound.z;
			return c.set(1 / 12 * b * (4 * g * g + 4 * m * m), 1 / 12 * b * (4 * e * e + 4 * m * m), 1 / 12 * b * (4 * g * g + 4 * e * e));
		};
		var B = new h;
		b.prototype.computeLocalAABB = function(b) {
			var c = b.lowerBound;
			b = b.upperBound;
			var e = this.vertices.length, g = (this.vertices, B);
			this.getVertex(0, g);
			c.copy(g);
			b.copy(g);
			for (var m = 0;m !== e;m++) {
				this.getVertex(m, g), g.x < c.x ? c.x = g.x : g.x > b.x && (b.x = g.x), g.y < c.y ? c.y = g.y : g.y > b.y && (b.y = g.y), g.z < c.z ? c.z = g.z : g.z > b.z && (b.z = g.z);
			}
		};
		b.prototype.updateAABB = function() {
			this.computeLocalAABB(this.aabb);
		};
		b.prototype.updateBoundingSphereRadius = function() {
			for (var b = 0, c = this.vertices, e = new h, g = 0, c = c.length / 3;g !== c;g++) {
				this.getVertex(g, e);
				var m = e.norm2();
				m > b && (b = m);
			}
			this.boundingSphereRadius = Math.sqrt(b);
		};
		var A = (new h, new c), D = new e;
		b.prototype.calculateWorldAABB = function(b, c, e, g) {
			A.position = b;
			A.quaternion = c;
			this.aabb.toWorldFrame(A, D);
			e.copy(D.lowerBound);
			g.copy(D.upperBound);
		};
		b.prototype.volume = function() {
			return 4 * Math.PI * this.boundingSphereRadius / 3;
		};
		b.createTorus = function(c, e, g, m, h) {
			c = c || 1;
			e = e || .5;
			g = g || 8;
			m = m || 6;
			h = h || 2 * Math.PI;
			for (var k = [], f = [], q = 0;g >= q;q++) {
				for (var p = 0;m >= p;p++) {
					var l = p / m * h, u = q / g * Math.PI * 2;
					k.push((c + e * Math.cos(u)) * Math.cos(l), (c + e * Math.cos(u)) * Math.sin(l), e * Math.sin(u));
				}
			}
			for (q = 1;g >= q;q++) {
				for (p = 1;m >= p;p++) {
					c = (m + 1) * (q - 1) + p - 1, e = (m + 1) * (q - 1) + p, h = (m + 1) * q + p, f.push((m + 1) * q + p - 1, c, h), f.push(c, e, h);
				}
			}
			return new b(k, f);
		};
	}, {"../collision/AABB":3, "../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "../utils/Octree":50, "./Shape":43}], 46:[function(f, l) {
		function b() {
			k.call(this);
			this.iterations = 10;
			this.tolerance = 1E-7;
		}
		l.exports = b;
		var k = (f("../math/Vec3"), f("../math/Quaternion"), f("./Solver"));
		b.prototype = new k;
		var h = [], c = [], e = [];
		b.prototype.solve = function(b, k) {
			var g, f, q, l, v = 0, y = this.iterations, x = this.tolerance * this.tolerance, m = this.equations, u = m.length;
			k = k.bodies;
			var B = k.length;
			if (0 !== u) {
				for (q = 0;q !== B;q++) {
					k[q].updateSolveMassProperties();
				}
			}
			c.length = u;
			e.length = u;
			h.length = u;
			for (q = 0;q !== u;q++) {
				var A = m[q];
				h[q] = 0;
				e[q] = A.computeB(b);
				c[q] = 1 / A.computeC();
			}
			if (0 !== u) {
				for (q = 0;q !== B;q++) {
					A = k[q], v = A.wlambda, A.vlambda.set(0, 0, 0), v && v.set(0, 0, 0);
				}
				for (v = 0;v !== y;v++) {
					for (var D = q = 0;D !== u;D++) {
						A = m[D], g = e[D], f = c[D], b = h[D], l = A.computeGWlambda(), g = f * (g - l - A.eps * b), b + g < A.minForce ? g = A.minForce - b : b + g > A.maxForce && (g = A.maxForce - b), h[D] += g, q += 0 < g ? g : -g, A.addToWlambda(g);
					}
					if (x > q * q) {
						break;
					}
				}
				for (q = 0;q !== B;q++) {
					A = k[q], y = A.velocity, x = A.angularVelocity, y.vadd(A.vlambda, y), x && x.vadd(A.wlambda, x);
				}
			}
			return v;
		};
	}, {"../math/Quaternion":28, "../math/Vec3":30, "./Solver":47}], 47:[function(f, l) {
		function b() {
			this.equations = [];
		}
		l.exports = b;
		b.prototype.solve = function() {
			return 0;
		};
		b.prototype.addEquation = function(b) {
			b.enabled && this.equations.push(b);
		};
		b.prototype.removeEquation = function(b) {
			var h = this.equations;
			b = h.indexOf(b);
			-1 !== b && h.splice(b, 1);
		};
		b.prototype.removeAllEquations = function() {
			this.equations.length = 0;
		};
	}, {}], 48:[function(f, l) {
		function b(b) {
			e.call(this);
			this.iterations = 10;
			this.tolerance = 1E-7;
			this.subsolver = b;
			this.nodes = [];
			for (this.nodePool = [];128 > this.nodePool.length;) {
				this.nodePool.push(this.createNode());
			}
		}
		function k(b) {
			for (var c = b.length, e = 0;e !== c;e++) {
				var g = b[e];
				if (!(g.visited || g.body.type & w)) {
					return g;
				}
			}
			return !1;
		}
		function h(b, c, e) {
			c.push(b.body);
			c = b.eqs.length;
			for (var g = 0;g !== c;g++) {
				var m = b.eqs[g];
				-1 === e.indexOf(m) && e.push(m);
			}
		}
		function c(b, c) {
			return c.id - b.id;
		}
		l.exports = b;
		var e = (f("../math/Vec3"), f("../math/Quaternion"), f("./Solver"));
		f = f("../objects/Body");
		b.prototype = new e;
		var g = [], q = [], r = {bodies:[]}, w = f.STATIC, p = [];
		b.prototype.createNode = function() {
			return {body:null, children:[], eqs:[], visited:!1};
		};
		b.prototype.solve = function(b, e) {
			var f = this.nodePool, l = e.bodies, m = this.equations, u = m.length, w = l.length;
			for (e = this.subsolver;f.length < w;) {
				f.push(this.createNode());
			}
			g.length = w;
			for (var t = 0;w > t;t++) {
				g[t] = f[t];
			}
			for (t = 0;t !== w;t++) {
				f = g[t], f.body = l[t], f.children.length = 0, f.eqs.length = 0, f.visited = !1;
			}
			for (f = 0;f !== u;f++) {
				var w = m[f], t = l.indexOf(w.bi), v = l.indexOf(w.bj), t = g[t], v = g[v];
				t.children.push(v);
				t.eqs.push(w);
				v.children.push(t);
				v.eqs.push(w);
			}
			l = 0;
			m = q;
			e.tolerance = this.tolerance;
			for (e.iterations = this.iterations;t = k(g);) {
				m.length = 0;
				r.bodies.length = 0;
				w = t;
				t = h;
				u = r.bodies;
				f = m;
				p.push(w);
				w.visited = !0;
				for (t(w, u, f);p.length;) {
					for (v = p.pop();w = k(v.children);) {
						w.visited = !0, t(w, u, f), p.push(w);
					}
				}
				u = m.length;
				m = m.sort(c);
				for (t = 0;t !== u;t++) {
					e.addEquation(m[t]);
				}
				e.solve(b, r);
				e.removeAllEquations();
				l++;
			}
			return l;
		};
	}, {"../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "./Solver":47}], 49:[function(f, l) {
		f = function() {
		};
		l.exports = f;
		f.prototype = {constructor:f, addEventListener:function(b, k) {
			void 0 === this._listeners && (this._listeners = {});
			var h = this._listeners;
			return void 0 === h[b] && (h[b] = []), -1 === h[b].indexOf(k) && h[b].push(k), this;
		}, hasEventListener:function(b, k) {
			if (void 0 === this._listeners) {
				return !1;
			}
			var h = this._listeners;
			return void 0 !== h[b] && -1 !== h[b].indexOf(k) ? !0 : !1;
		}, removeEventListener:function(b, k) {
			if (void 0 === this._listeners) {
				return this;
			}
			var h = this._listeners;
			if (void 0 === h[b]) {
				return this;
			}
			k = h[b].indexOf(k);
			return -1 !== k && h[b].splice(k, 1), this;
		}, dispatchEvent:function(b) {
			if (void 0 === this._listeners) {
				return this;
			}
			var k = this._listeners[b.type];
			if (void 0 !== k) {
				b.target = this;
				for (var h = 0, c = k.length;c > h;h++) {
					k[h].call(this, b);
				}
			}
			return this;
		}};
	}, {}], 50:[function(f, l) {
		function b(b) {
			b = b || {};
			this.root = b.root || null;
			this.aabb = b.aabb ? b.aabb.clone() : new h;
			this.data = [];
			this.children = [];
		}
		function k(c, e) {
			e = e || {};
			e.root = null;
			e.aabb = c;
			b.call(this, e);
			this.maxDepth = "undefined" != typeof e.maxDepth ? e.maxDepth : 8;
		}
		var h = f("../collision/AABB"), c = f("../math/Vec3");
		l.exports = k;
		k.prototype = new b;
		b.prototype.reset = function() {
			this.children.length = this.data.length = 0;
		};
		b.prototype.insert = function(b, c, e) {
			var g = this.data;
			if (e = e || 0, !this.aabb.contains(b)) {
				return !1;
			}
			var h = this.children;
			if (e < (this.maxDepth || this.root.maxDepth)) {
				var k = !1;
				h.length || (this.subdivide(), k = !0);
				for (var f = 0;8 !== f;f++) {
					if (h[f].insert(b, c, e + 1)) {
						return !0;
					}
				}
				k && (h.length = 0);
			}
			return g.push(c), !0;
		};
		var e = new c;
		b.prototype.subdivide = function() {
			var g = this.aabb, k = g.lowerBound, f = g.upperBound, g = this.children;
			g.push(new b({aabb:new h({lowerBound:new c(0, 0, 0)})}), new b({aabb:new h({lowerBound:new c(1, 0, 0)})}), new b({aabb:new h({lowerBound:new c(1, 1, 0)})}), new b({aabb:new h({lowerBound:new c(1, 1, 1)})}), new b({aabb:new h({lowerBound:new c(0, 1, 1)})}), new b({aabb:new h({lowerBound:new c(0, 0, 1)})}), new b({aabb:new h({lowerBound:new c(1, 0, 1)})}), new b({aabb:new h({lowerBound:new c(0, 1, 0)})}));
			f.vsub(k, e);
			e.scale(.5, e);
			for (var f = this.root || this, p = 0;8 !== p;p++) {
				var l = g[p];
				l.root = f;
				var v = l.aabb.lowerBound;
				v.x *= e.x;
				v.y *= e.y;
				v.z *= e.z;
				v.vadd(k, v);
				v.vadd(e, l.aabb.upperBound);
			}
		};
		b.prototype.aabbQuery = function(b, c) {
			for (var e = (this.data, this.children, [this]);e.length;) {
				var g = e.pop();
				g.aabb.overlaps(b) && Array.prototype.push.apply(c, g.data);
				Array.prototype.push.apply(e, g.children);
			}
			return c;
		};
		var g = new h;
		b.prototype.rayQuery = function(b, c, e) {
			return b.getAABB(g), g.toLocalFrame(c, g), this.aabbQuery(g, e), e;
		};
		b.prototype.removeEmptyNodes = function() {
			for (var b = [this];b.length;) {
				for (var c = b.pop(), e = c.children.length - 1;0 <= e;e--) {
					c.children[e].data.length || c.children.splice(e, 1);
				}
				Array.prototype.push.apply(b, c.children);
			}
		};
	}, {"../collision/AABB":3, "../math/Vec3":30}], 51:[function(f, l) {
		function b() {
			this.objects = [];
			this.type = Object;
		}
		l.exports = b;
		b.prototype.release = function() {
			for (var b = arguments.length, h = 0;h !== b;h++) {
				this.objects.push(arguments[h]);
			}
		};
		b.prototype.get = function() {
			return 0 === this.objects.length ? this.constructObject() : this.objects.pop();
		};
		b.prototype.constructObject = function() {
			throw Error("constructObject() not implemented in this Pool subclass yet!");
		};
	}, {}], 52:[function(f, l) {
		function b() {
			this.data = {keys:[]};
		}
		l.exports = b;
		b.prototype.get = function(b, h) {
			b > h && (b = h = b);
			return this.data[b + "-" + h];
		};
		b.prototype.set = function(b, h, c) {
			b > h && (b = h = b);
			var e = b + "-" + h;
			this.get(b, h) || this.data.keys.push(e);
			this.data[e] = c;
		};
		b.prototype.reset = function() {
			for (var b = this.data, h = b.keys;0 < h.length;) {
				var c = h.pop();
				delete b[c];
			}
		};
	}, {}], 53:[function(f, l) {
		function b() {
		}
		l.exports = b;
		b.defaults = function(b, h) {
			b = b || {};
			for (var c in h) {
				c in b || (b[c] = h[c]);
			}
			return b;
		};
	}, {}], 54:[function(f, l) {
		function b() {
			h.call(this);
			this.type = k;
		}
		l.exports = b;
		var k = f("../math/Vec3"), h = f("./Pool");
		b.prototype = new h;
		b.prototype.constructObject = function() {
			return new k;
		};
	}, {"../math/Vec3":30, "./Pool":51}], 55:[function(f, l) {
		function b(b) {
			this.contactPointPool = [];
			this.frictionEquationPool = [];
			this.result = [];
			this.frictionResult = [];
			this.v3pool = new q;
			this.world = b;
			this.currentContactMaterial = null;
			this.enableFrictionReduction = !1;
		}
		l.exports = b;
		l = f("../collision/AABB");
		var k = f("../shapes/Shape"), h = f("../collision/Ray"), c = f("../math/Vec3"), e = f("../math/Transform"), g = (f("../shapes/ConvexPolyhedron"), f("../math/Quaternion")), q = (f("../solver/Solver"), f("../utils/Vec3Pool")), r = f("../equations/ContactEquation"), w = f("../equations/FrictionEquation");
		b.prototype.createContactEquation = function(b, c, e, g, m, h) {
			var k;
			this.contactPointPool.length ? (k = this.contactPointPool.pop(), k.bi = b, k.bj = c) : k = new r(b, c);
			k.enabled = b.collisionResponse && c.collisionResponse && e.collisionResponse && g.collisionResponse;
			var f = this.currentContactMaterial;
			k.restitution = f.restitution;
			k.setSpookParams(f.contactEquationStiffness, f.contactEquationRelaxation, this.world.dt);
			b = e.material || b.material;
			c = g.material || c.material;
			return b && c && 0 <= b.restitution && 0 <= c.restitution && (k.restitution = b.restitution * c.restitution), k.si = m || e, k.sj = h || g, k;
		};
		b.prototype.createFrictionEquationsFromContact = function(b, c) {
			var e = b.bi, g = b.bj, m = this.world, h = this.currentContactMaterial, k = h.friction, f = b.si.material || e.material, q = b.sj.material || g.material;
			if (f && q && 0 <= f.friction && 0 <= q.friction && (k = f.friction * q.friction), 0 < k) {
				k *= m.gravity.length();
				f = e.invMass + g.invMass;
				0 < f && (f = 1 / f);
				var l = this.frictionEquationPool, q = l.length ? l.pop() : new w(e, g, k * f), l = l.length ? l.pop() : new w(e, g, k * f);
				return q.bi = l.bi = e, q.bj = l.bj = g, q.minForce = l.minForce = -k * f, q.maxForce = l.maxForce = k * f, q.ri.copy(b.ri), q.rj.copy(b.rj), l.ri.copy(b.ri), l.rj.copy(b.rj), b.ni.tangents(q.t, l.t), q.setSpookParams(h.frictionEquationStiffness, h.frictionEquationRelaxation, m.dt), l.setSpookParams(h.frictionEquationStiffness, h.frictionEquationRelaxation, m.dt), q.enabled = l.enabled = b.enabled, c.push(q, l), !0;
			}
			return !1;
		};
		var p = new c, t = new c, v = new c;
		b.prototype.createFrictionFromAverage = function(b) {
			var c = this.result[this.result.length - 1];
			if (this.createFrictionEquationsFromContact(c, this.frictionResult) && 1 !== b) {
				var e = this.frictionResult[this.frictionResult.length - 2], g = this.frictionResult[this.frictionResult.length - 1];
				p.setZero();
				t.setZero();
				v.setZero();
				for (var m = c.bi, h = (c.bj, 0);h !== b;h++) {
					c = this.result[this.result.length - 1 - h], c.bodyA !== m ? (p.vadd(c.ni, p), t.vadd(c.ri, t), v.vadd(c.rj, v)) : (p.vsub(c.ni, p), t.vadd(c.rj, t), v.vadd(c.ri, v));
				}
				b = 1 / b;
				t.scale(b, e.ri);
				v.scale(b, e.rj);
				g.ri.copy(e.ri);
				g.rj.copy(e.rj);
				p.normalize();
				p.tangents(e.t, g.t);
			}
		};
		var y = new c, x = new c, m = new g, u = new g;
		b.prototype.getContacts = function(b, c, e, g, h, k, f) {
			this.contactPointPool = h;
			this.frictionEquationPool = f;
			this.result = g;
			this.frictionResult = k;
			g = 0;
			for (h = b.length;g !== h;g++) {
				k = b[g];
				f = c[g];
				var q = null;
				k.material && f.material && (q = e.getContactMaterial(k.material, f.material) || null);
				for (var l = 0;l < k.shapes.length;l++) {
					k.quaternion.mult(k.shapeOrientations[l], m);
					k.quaternion.vmult(k.shapeOffsets[l], y);
					y.vadd(k.position, y);
					for (var p = k.shapes[l], r = 0;r < f.shapes.length;r++) {
						f.quaternion.mult(f.shapeOrientations[r], u);
						f.quaternion.vmult(f.shapeOffsets[r], x);
						x.vadd(f.position, x);
						var w = f.shapes[r];
						if (!(y.distanceTo(x) > p.boundingSphereRadius + w.boundingSphereRadius)) {
							var B = null;
							p.material && w.material && (B = e.getContactMaterial(p.material, w.material) || null);
							this.currentContactMaterial = B || q || e.defaultContactMaterial;
							(B = this[p.type | w.type]) && (p.type < w.type ? B.call(this, p, w, y, x, m, u, k, f, p, w) : B.call(this, w, p, x, y, u, m, f, k, p, w));
						}
					}
				}
			}
		};
		b.prototype[k.types.BOX | k.types.BOX] = b.prototype.boxBox = function(b, c, e, g, m, h, k, f) {
			b.convexPolyhedronRepresentation.material = b.material;
			c.convexPolyhedronRepresentation.material = c.material;
			b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
			c.convexPolyhedronRepresentation.collisionResponse = c.collisionResponse;
			this.convexConvex(b.convexPolyhedronRepresentation, c.convexPolyhedronRepresentation, e, g, m, h, k, f, b, c);
		};
		b.prototype[k.types.BOX | k.types.CONVEXPOLYHEDRON] = b.prototype.boxConvex = function(b, c, e, g, m, h, k, f) {
			b.convexPolyhedronRepresentation.material = b.material;
			b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
			this.convexConvex(b.convexPolyhedronRepresentation, c, e, g, m, h, k, f, b, c);
		};
		b.prototype[k.types.BOX | k.types.PARTICLE] = b.prototype.boxParticle = function(b, c, e, g, m, h, k, f) {
			b.convexPolyhedronRepresentation.material = b.material;
			b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
			this.convexParticle(b.convexPolyhedronRepresentation, c, e, g, m, h, k, f, b, c);
		};
		b.prototype[k.types.SPHERE] = b.prototype.sphereSphere = function(b, c, e, g, m, h, k, f) {
			m = this.createContactEquation(k, f, b, c);
			g.vsub(e, m.ni);
			m.ni.normalize();
			m.ri.copy(m.ni);
			m.rj.copy(m.ni);
			m.ri.mult(b.radius, m.ri);
			m.rj.mult(-c.radius, m.rj);
			m.ri.vadd(e, m.ri);
			m.ri.vsub(k.position, m.ri);
			m.rj.vadd(g, m.rj);
			m.rj.vsub(f.position, m.rj);
			this.result.push(m);
			this.createFrictionEquationsFromContact(m, this.frictionResult);
		};
		var B = new c, A = new c, D = new c;
		b.prototype[k.types.PLANE | k.types.TRIMESH] = b.prototype.planeTrimesh = function(b, g, m, h, k, f, q, l) {
			var p = new c;
			B.set(0, 0, 1);
			k.vmult(B, B);
			for (k = 0;k < g.vertices.length / 3;k++) {
				g.getVertex(k, p);
				var u = new c;
				u.copy(p);
				e.pointToWorldFrame(h, f, u, p);
				u = A;
				p.vsub(m, u);
				if (0 >= B.dot(u)) {
					var r = this.createContactEquation(q, l, b, g);
					r.ni.copy(B);
					var w = D;
					B.scale(u.dot(B), w);
					p.vsub(w, w);
					r.ri.copy(w);
					r.ri.vsub(q.position, r.ri);
					r.rj.copy(p);
					r.rj.vsub(l.position, r.rj);
					this.result.push(r);
					this.createFrictionEquationsFromContact(r, this.frictionResult);
				}
			}
		};
		var G = new c, F = new c, C = (new c, new c), J = new c, I = new c, Q = new c, M = new c, N = new c, R = new c, H = new c, ba = new c, ha = new c, Y = new c, ga = new l, S = [];
		b.prototype[k.types.SPHERE | k.types.TRIMESH] = b.prototype.sphereTrimesh = function(b, c, g, m, k, f, q, l) {
			e.pointToLocalFrame(m, f, g, R);
			k = b.radius;
			ga.lowerBound.set(R.x - k, R.y - k, R.z - k);
			ga.upperBound.set(R.x + k, R.y + k, R.z + k);
			c.getTrianglesInAABB(ga, S);
			var p = b.radius * b.radius;
			for (k = 0;k < S.length;k++) {
				for (var u = 0;3 > u;u++) {
					if (c.getVertex(c.indices[3 * S[k] + u], C), C.vsub(R, F), F.norm2() <= p) {
						J.copy(C);
						e.pointToWorldFrame(m, f, J, C);
						C.vsub(g, F);
						var r = this.createContactEquation(q, l, b, c);
						r.ni.copy(F);
						r.ni.normalize();
						r.ri.copy(r.ni);
						r.ri.scale(b.radius, r.ri);
						r.ri.vadd(g, r.ri);
						r.ri.vsub(q.position, r.ri);
						r.rj.copy(C);
						r.rj.vsub(l.position, r.rj);
						this.result.push(r);
						this.createFrictionEquationsFromContact(r, this.frictionResult);
					}
				}
			}
			for (k = 0;k < S.length;k++) {
				for (u = 0;3 > u;u++) {
					c.getVertex(c.indices[3 * S[k] + u], I), c.getVertex(c.indices[3 * S[k] + (u + 1) % 3], Q), Q.vsub(I, M), R.vsub(Q, H), g = H.dot(M), R.vsub(I, H), r = H.dot(M), 0 < r && 0 > g && (R.vsub(I, H), N.copy(M), N.normalize(), r = H.dot(N), N.scale(r, H), H.vadd(I, H), g = H.distanceTo(R), g < b.radius && (r = this.createContactEquation(q, l, b, c), H.vsub(R, r.ni), r.ni.normalize(), r.ni.scale(b.radius, r.ri), e.pointToWorldFrame(m, f, H, H), H.vsub(l.position, r.rj), e.vectorToWorldFrame(f, 
					r.ni, r.ni), e.vectorToWorldFrame(f, r.ri, r.ri), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult)));
				}
			}
			k = 0;
			for (u = S.length;k !== u;k++) {
				if (c.getTriangleVertices(S[k], ba, ha, Y), c.getNormal(S[k], G), R.vsub(ba, H), g = H.dot(G), G.scale(g, H), R.vsub(H, H), g = H.distanceTo(R), h.pointInTriangle(H, ba, ha, Y) && g < b.radius) {
					r = this.createContactEquation(q, l, b, c), H.vsub(R, r.ni), r.ni.normalize(), r.ni.scale(b.radius, r.ri), e.pointToWorldFrame(m, f, H, H), H.vsub(l.position, r.rj), e.vectorToWorldFrame(f, r.ni, r.ni), e.vectorToWorldFrame(f, r.ri, r.ri), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
				}
			}
			S.length = 0;
		};
		var V = new c, L = new c;
		b.prototype[k.types.SPHERE | k.types.PLANE] = b.prototype.spherePlane = function(b, c, e, g, m, h, k, f) {
			c = this.createContactEquation(k, f, b, c);
			if (c.ni.set(0, 0, 1), h.vmult(c.ni, c.ni), c.ni.negate(c.ni), c.ni.normalize(), c.ni.mult(b.radius, c.ri), e.vsub(g, V), c.ni.mult(c.ni.dot(V), L), V.vsub(L, c.rj), -V.dot(c.ni) <= b.radius) {
				b = c.ri, h = c.rj, b.vadd(e, b), b.vsub(k.position, b), h.vadd(g, h), h.vsub(f.position, h), this.result.push(c), this.createFrictionEquationsFromContact(c, this.frictionResult);
			}
		};
		var W = new c, ia = new c, va = new c, T = new c, pa = new c, ra = new c, qa = new c, ea = [new c, new c, new c, new c, new c, new c], Z = new c, ua = new c, sa = new c, Ba = new c;
		b.prototype[k.types.SPHERE | k.types.BOX] = b.prototype.sphereBox = function(b, c, e, g, m, h, k, f) {
			m = this.v3pool;
			e.vsub(g, T);
			c.getSideNormals(ea, h);
			h = b.radius;
			for (var q = !1, l = null, p = 0, u = 0, r = 0, w = null, B = 0, t = ea.length;B !== t && !1 === q;B++) {
				var v = pa;
				v.copy(ea[B]);
				var y = v.norm();
				v.normalize();
				var A = T.dot(v);
				if (y + h > A && 0 < A) {
					var C = ra, x = qa;
					C.copy(ea[(B + 1) % 3]);
					x.copy(ea[(B + 2) % 3]);
					var D = C.norm(), G = x.norm();
					C.normalize();
					x.normalize();
					var F = T.dot(C), L = T.dot(x);
					D > F && F > -D && G > L && L > -G && (A = Math.abs(A - y - h), (null === w || w > A) && (w = A, u = F, r = L, l = y, ua.copy(v), sa.copy(C), Ba.copy(x), p++));
				}
			}
			p && (q = !0, p = this.createContactEquation(k, f, b, c), ua.mult(-h, p.ri), p.ni.copy(ua), p.ni.negate(p.ni), ua.mult(l, ua), sa.mult(u, sa), ua.vadd(sa, ua), Ba.mult(r, Ba), ua.vadd(Ba, p.rj), p.ri.vadd(e, p.ri), p.ri.vsub(k.position, p.ri), p.rj.vadd(g, p.rj), p.rj.vsub(f.position, p.rj), this.result.push(p), this.createFrictionEquationsFromContact(p, this.frictionResult));
			A = m.get();
			for (l = 0;2 !== l && !q;l++) {
				for (u = 0;2 !== u && !q;u++) {
					for (r = 0;2 !== r && !q;r++) {
						if (A.set(0, 0, 0), l ? A.vadd(ea[0], A) : A.vsub(ea[0], A), u ? A.vadd(ea[1], A) : A.vsub(ea[1], A), r ? A.vadd(ea[2], A) : A.vsub(ea[2], A), g.vadd(A, Z), Z.vsub(e, Z), Z.norm2() < h * h) {
							q = !0, p = this.createContactEquation(k, f, b, c), p.ri.copy(Z), p.ri.normalize(), p.ni.copy(p.ri), p.ri.mult(h, p.ri), p.rj.copy(A), p.ri.vadd(e, p.ri), p.ri.vsub(k.position, p.ri), p.rj.vadd(g, p.rj), p.rj.vsub(f.position, p.rj), this.result.push(p), this.createFrictionEquationsFromContact(p, this.frictionResult);
						}
					}
				}
			}
			m.release(A);
			w = m.get();
			B = m.get();
			p = m.get();
			t = m.get();
			A = m.get();
			v = ea.length;
			for (l = 0;l !== v && !q;l++) {
				for (u = 0;u !== v && !q;u++) {
					if (l % 3 !== u % 3) {
						ea[u].cross(ea[l], w);
						w.normalize();
						ea[l].vadd(ea[u], B);
						p.copy(e);
						p.vsub(B, p);
						p.vsub(g, p);
						y = p.dot(w);
						w.mult(y, t);
						for (r = 0;r === l % 3 || r === u % 3;) {
							r++;
						}
						A.copy(e);
						A.vsub(t, A);
						A.vsub(B, A);
						A.vsub(g, A);
						y = Math.abs(y);
						C = A.norm();
						y < ea[r].norm() && h > C && (q = !0, r = this.createContactEquation(k, f, b, c), B.vadd(t, r.rj), r.rj.copy(r.rj), A.negate(r.ni), r.ni.normalize(), r.ri.copy(r.rj), r.ri.vadd(g, r.ri), r.ri.vsub(e, r.ri), r.ri.normalize(), r.ri.mult(h, r.ri), r.ri.vadd(e, r.ri), r.ri.vsub(k.position, r.ri), r.rj.vadd(g, r.rj), r.rj.vsub(f.position, r.rj), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult));
					}
				}
			}
			m.release(w, B, p, t, A);
		};
		var Ca = new c, ya = new c, wa = new c, Sa = new c, rd = new c, jb = new c, kb = new c, Xb = new c, X = new c, qb = new c;
		b.prototype[k.types.SPHERE | k.types.CONVEXPOLYHEDRON] = b.prototype.sphereConvex = function(b, c, e, g, m, h, k, f) {
			m = this.v3pool;
			e.vsub(g, Ca);
			for (var q = c.faceNormals, p = c.faces, l = c.vertices, u = b.radius, r = 0;r !== l.length;r++) {
				var w = rd;
				h.vmult(l[r], w);
				g.vadd(w, w);
				var B = Sa;
				if (w.vsub(e, B), B.norm2() < u * u) {
					return b = this.createContactEquation(k, f, b, c), b.ri.copy(B), b.ri.normalize(), b.ni.copy(b.ri), b.ri.mult(u, b.ri), w.vsub(g, b.rj), b.ri.vadd(e, b.ri), b.ri.vsub(k.position, b.ri), b.rj.vadd(g, b.rj), b.rj.vsub(f.position, b.rj), this.result.push(b), void this.createFrictionEquationsFromContact(b, this.frictionResult);
				}
			}
			r = 0;
			for (w = p.length;r !== w;r++) {
				var B = p[r], t = jb;
				h.vmult(q[r], t);
				var v = kb;
				h.vmult(l[B[0]], v);
				v.vadd(g, v);
				var y = Xb;
				t.mult(-u, y);
				e.vadd(y, y);
				var A = X;
				y.vsub(v, A);
				y = A.dot(t);
				A = qb;
				if (e.vsub(v, A), 0 > y && 0 < A.dot(t)) {
					for (var v = [], A = 0, C = B.length;A !== C;A++) {
						var x = m.get();
						h.vmult(l[B[A]], x);
						g.vadd(x, x);
						v.push(x);
					}
					a: {
						for (var A = v, C = t, x = e, D = null, G = A.length, F = 0;F !== G;F++) {
							var L = A[F], I = W;
							A[(F + 1) % G].vsub(L, I);
							var J = ia;
							I.cross(C, J);
							I = va;
							x.vsub(L, I);
							L = J.dot(I);
							if (!(null === D || 0 < L && !0 === D || 0 >= L && !1 === D)) {
								A = !1;
								break a;
							}
							null === D && (D = 0 < L);
						}
						A = !0;
					}
					if (A) {
						b = this.createContactEquation(k, f, b, c);
						t.mult(-u, b.ri);
						t.negate(b.ni);
						c = m.get();
						t.mult(-y, c);
						h = m.get();
						t.mult(-u, h);
						e.vsub(g, b.rj);
						b.rj.vadd(h, b.rj);
						b.rj.vadd(c, b.rj);
						b.rj.vadd(g, b.rj);
						b.rj.vsub(f.position, b.rj);
						b.ri.vadd(e, b.ri);
						b.ri.vsub(k.position, b.ri);
						m.release(c);
						m.release(h);
						this.result.push(b);
						this.createFrictionEquationsFromContact(b, this.frictionResult);
						A = 0;
						for (B = v.length;A !== B;A++) {
							m.release(v[A]);
						}
						break;
					}
					for (A = 0;A !== B.length;A++) {
						t = m.get();
						y = m.get();
						h.vmult(l[B[(A + 1) % B.length]], t);
						h.vmult(l[B[(A + 2) % B.length]], y);
						g.vadd(t, t);
						g.vadd(y, y);
						G = ya;
						y.vsub(t, G);
						D = wa;
						G.unit(D);
						C = m.get();
						x = m.get();
						e.vsub(t, x);
						F = x.dot(D);
						D.mult(F, C);
						C.vadd(t, C);
						D = m.get();
						if (C.vsub(e, D), 0 < F && F * F < G.norm2() && D.norm2() < u * u) {
							b = this.createContactEquation(k, f, b, c);
							C.vsub(g, b.rj);
							C.vsub(e, b.ni);
							b.ni.normalize();
							b.ni.mult(u, b.ri);
							b.rj.vadd(g, b.rj);
							b.rj.vsub(f.position, b.rj);
							b.ri.vadd(e, b.ri);
							b.ri.vsub(k.position, b.ri);
							this.result.push(b);
							this.createFrictionEquationsFromContact(b, this.frictionResult);
							A = 0;
							for (B = v.length;A !== B;A++) {
								m.release(v[A]);
							}
							return m.release(t), m.release(y), m.release(C), m.release(D), void m.release(x);
						}
						m.release(t);
						m.release(y);
						m.release(C);
						m.release(D);
						m.release(x);
					}
					A = 0;
					for (B = v.length;A !== B;A++) {
						m.release(v[A]);
					}
				}
			}
		};
		new c;
		new c;
		b.prototype[k.types.PLANE | k.types.BOX] = b.prototype.planeBox = function(b, c, e, g, m, h, k, f) {
			c.convexPolyhedronRepresentation.material = c.material;
			c.convexPolyhedronRepresentation.collisionResponse = c.collisionResponse;
			this.planeConvex(b, c.convexPolyhedronRepresentation, e, g, m, h, k, f);
		};
		var Ia = new c, Ja = new c, La = new c, U = new c;
		b.prototype[k.types.PLANE | k.types.CONVEXPOLYHEDRON] = b.prototype.planeConvex = function(b, c, e, g, m, h, k, f) {
			Ja.set(0, 0, 1);
			m.vmult(Ja, Ja);
			for (var q = m = 0;q !== c.vertices.length;q++) {
				if (Ia.copy(c.vertices[q]), h.vmult(Ia, Ia), g.vadd(Ia, Ia), Ia.vsub(e, La), 0 >= Ja.dot(La)) {
					var p = this.createContactEquation(k, f, b, c), l = U;
					Ja.mult(Ja.dot(La), l);
					Ia.vsub(l, l);
					l.vsub(e, p.ri);
					p.ni.copy(Ja);
					Ia.vsub(g, p.rj);
					p.ri.vadd(e, p.ri);
					p.ri.vsub(k.position, p.ri);
					p.rj.vadd(g, p.rj);
					p.rj.vsub(f.position, p.rj);
					this.result.push(p);
					m++;
					this.enableFrictionReduction || this.createFrictionEquationsFromContact(p, this.frictionResult);
				}
			}
			this.enableFrictionReduction && m && this.createFrictionFromAverage(m);
		};
		var rb = new c, lb = new c;
		b.prototype[k.types.CONVEXPOLYHEDRON] = b.prototype.convexConvex = function(b, c, e, g, m, h, k, f, q, p, l, u) {
			if (!(e.distanceTo(g) > b.boundingSphereRadius + c.boundingSphereRadius) && b.findSeparatingAxis(c, e, m, g, h, rb, l, u)) {
				l = [];
				b.clipAgainstHull(e, m, c, g, h, rb, -100, 100, l);
				for (h = m = 0;h !== l.length;h++) {
					u = this.createContactEquation(k, f, b, c, q, p);
					var r = u.ri, w = u.rj;
					rb.negate(u.ni);
					l[h].normal.negate(lb);
					lb.mult(l[h].depth, lb);
					l[h].point.vadd(lb, r);
					w.copy(l[h].point);
					r.vsub(e, r);
					w.vsub(g, w);
					r.vadd(e, r);
					r.vsub(k.position, r);
					w.vadd(g, w);
					w.vsub(f.position, w);
					this.result.push(u);
					m++;
					this.enableFrictionReduction || this.createFrictionEquationsFromContact(u, this.frictionResult);
				}
				this.enableFrictionReduction && m && this.createFrictionFromAverage(m);
			}
		};
		var Za = new c, xb = new c, Ta = new c;
		b.prototype[k.types.PLANE | k.types.PARTICLE] = b.prototype.planeParticle = function(b, c, e, g, m, h, k, f) {
			Za.set(0, 0, 1);
			k.quaternion.vmult(Za, Za);
			g.vsub(k.position, xb);
			0 >= Za.dot(xb) && (b = this.createContactEquation(f, k, c, b), b.ni.copy(Za), b.ni.negate(b.ni), b.ri.set(0, 0, 0), Za.mult(Za.dot(g), Ta), g.vsub(Ta, Ta), b.rj.copy(Ta), this.result.push(b), this.createFrictionEquationsFromContact(b, this.frictionResult));
		};
		var bb = new c;
		b.prototype[k.types.PARTICLE | k.types.SPHERE] = b.prototype.sphereParticle = function(b, c, e, g, m, h, k, f) {
			bb.set(0, 0, 1);
			g.vsub(e, bb);
			bb.norm2() <= b.radius * b.radius && (c = this.createContactEquation(f, k, c, b), bb.normalize(), c.rj.copy(bb), c.rj.mult(b.radius, c.rj), c.ni.copy(bb), c.ni.negate(c.ni), c.ri.set(0, 0, 0), this.result.push(c), this.createFrictionEquationsFromContact(c, this.frictionResult));
		};
		var cb = new g, la = new c, sb = (new c, new c), Hc = new c, ja = new c;
		b.prototype[k.types.PARTICLE | k.types.CONVEXPOLYHEDRON] = b.prototype.convexParticle = function(b, c, e, g, m, h, k, f) {
			var q = -1;
			h = null;
			var p = 0;
			if (la.copy(g), la.vsub(e, la), m.conjugate(cb), cb.vmult(la, la), b.pointIsInside(la)) {
				b.worldVerticesNeedsUpdate && b.computeWorldVertices(e, m);
				b.worldFaceNormalsNeedsUpdate && b.computeWorldFaceNormals(m);
				m = 0;
				for (var l = b.faces.length;m !== l;m++) {
					var u = b.worldFaceNormals[m];
					g.vsub(b.worldVertices[b.faces[m][0]], Hc);
					var r = -u.dot(Hc);
					(null === h || Math.abs(r) < Math.abs(h)) && (h = r, q = m, sb.copy(u), p++);
				}
				-1 !== q ? (b = this.createContactEquation(f, k, c, b), sb.mult(h, ja), ja.vadd(g, ja), ja.vsub(e, ja), b.rj.copy(ja), sb.negate(b.ni), b.ri.set(0, 0, 0), c = b.ri, h = b.rj, c.vadd(g, c), c.vsub(f.position, c), h.vadd(e, h), h.vsub(k.position, h), this.result.push(b), this.createFrictionEquationsFromContact(b, this.frictionResult)) : console.warn("Point found inside convex, but did not find penetrating face!");
			}
		};
		b.prototype[k.types.BOX | k.types.HEIGHTFIELD] = b.prototype.boxHeightfield = function(b, c, e, g, m, h, k, f) {
			b.convexPolyhedronRepresentation.material = b.material;
			b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
			this.convexHeightfield(b.convexPolyhedronRepresentation, c, e, g, m, h, k, f);
		};
		var ca = new c, Da = new c, mb = [0];
		b.prototype[k.types.CONVEXPOLYHEDRON | k.types.HEIGHTFIELD] = b.prototype.convexHeightfield = function(b, c, g, m, h, k, f, q) {
			var p = c.data, l = c.elementSize, u = b.boundingSphereRadius;
			e.pointToLocalFrame(m, k, g, ca);
			var r = Math.floor((ca.x - u) / l) - 1, w = Math.ceil((ca.x + u) / l) + 1, B = Math.floor((ca.y - u) / l) - 1, l = Math.ceil((ca.y + u) / l) + 1;
			if (!(0 > w || 0 > l || r > p.length || B > p[0].length)) {
				0 > r && (r = 0);
				0 > w && (w = 0);
				0 > B && (B = 0);
				0 > l && (l = 0);
				r >= p.length && (r = p.length - 1);
				w >= p.length && (w = p.length - 1);
				l >= p[0].length && (l = p[0].length - 1);
				B >= p[0].length && (B = p[0].length - 1);
				p = [];
				c.getRectMinMax(r, B, w, l, p);
				var t = p[0];
				if (!(ca.z - u > p[1] || ca.z + u < t)) {
					for (u = r;w > u;u++) {
						for (r = B;l > r;r++) {
							c.getConvexTrianglePillar(u, r, !1), e.pointToWorldFrame(m, k, c.pillarOffset, Da), g.distanceTo(Da) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.convexConvex(b, c.pillarConvex, g, Da, h, k, f, q, null, null, mb, null), c.getConvexTrianglePillar(u, r, !0), e.pointToWorldFrame(m, k, c.pillarOffset, Da), g.distanceTo(Da) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.convexConvex(b, c.pillarConvex, g, Da, h, k, f, q, null, null, mb, null)
							;
						}
					}
				}
			}
		};
		var Ra = new c, xa = new c;
		b.prototype[k.types.SPHERE | k.types.HEIGHTFIELD] = b.prototype.sphereHeightfield = function(b, c, g, m, h, k, f, q) {
			var p = c.data, l = b.radius, u = c.elementSize;
			e.pointToLocalFrame(m, k, g, Ra);
			var r = Math.floor((Ra.x - l) / u) - 1, w = Math.ceil((Ra.x + l) / u) + 1, B = Math.floor((Ra.y - l) / u) - 1, u = Math.ceil((Ra.y + l) / u) + 1;
			if (!(0 > w || 0 > u || r > p.length || u > p[0].length)) {
				0 > r && (r = 0);
				0 > w && (w = 0);
				0 > B && (B = 0);
				0 > u && (u = 0);
				r >= p.length && (r = p.length - 1);
				w >= p.length && (w = p.length - 1);
				u >= p[0].length && (u = p[0].length - 1);
				B >= p[0].length && (B = p[0].length - 1);
				p = [];
				c.getRectMinMax(r, B, w, u, p);
				var t = p[0];
				if (!(Ra.z - l > p[1] || Ra.z + l < t)) {
					for (l = this.result;w > r;r++) {
						for (p = B;u > p;p++) {
							if (t = l.length, c.getConvexTrianglePillar(r, p, !1), e.pointToWorldFrame(m, k, c.pillarOffset, xa), g.distanceTo(xa) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.sphereConvex(b, c.pillarConvex, g, xa, h, k, f, q), c.getConvexTrianglePillar(r, p, !0), e.pointToWorldFrame(m, k, c.pillarOffset, xa), g.distanceTo(xa) < c.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.sphereConvex(b, c.pillarConvex, g, xa, h, k, f, q), 2 < l.length - t) {
								return;
							}
						}
					}
				}
			}
		};
	}, {"../collision/AABB":3, "../collision/Ray":9, "../equations/ContactEquation":19, "../equations/FrictionEquation":21, "../math/Quaternion":28, "../math/Transform":29, "../math/Vec3":30, "../shapes/ConvexPolyhedron":38, "../shapes/Shape":43, "../solver/Solver":47, "../utils/Vec3Pool":54}], 56:[function(f, l) {
		function b() {
			g.apply(this);
			this.dt = -1;
			this.allowSleep = !1;
			this.contacts = [];
			this.frictionEquations = [];
			this.quatNormalizeSkip = 0;
			this.quatNormalizeFast = !1;
			this.stepnumber = this.time = 0;
			this.default_dt = 1 / 60;
			this.nextId = 0;
			this.gravity = new h;
			this.broadphase = new m;
			this.bodies = [];
			this.solver = new c;
			this.constraints = [];
			this.narrowphase = new e(this);
			this.collisionMatrix = new q;
			this.collisionMatrixPrevious = new q;
			this.materials = [];
			this.contactmaterials = [];
			this.contactMaterialTable = new t;
			this.defaultMaterial = new r("default");
			this.defaultContactMaterial = new w(this.defaultMaterial, this.defaultMaterial, {friction:.3, restitution:0});
			this.doProfiling = !1;
			this.profile = {solve:0, makeContactConstraints:0, broadphase:0, integrate:0, narrowphase:0};
			this.subsystems = [];
			this.addBodyEvent = {type:"addBody", body:null};
			this.removeBodyEvent = {type:"removeBody", body:null};
		}
		l.exports = b;
		var k = f("../shapes/Shape"), h = f("../math/Vec3");
		l = f("../math/Quaternion");
		var c = f("../solver/GSSolver"), e = (f("../utils/Vec3Pool"), f("../equations/ContactEquation"), f("../equations/FrictionEquation"), f("./Narrowphase")), g = f("../utils/EventTarget"), q = f("../collision/ArrayCollisionMatrix"), r = f("../material/Material"), w = f("../material/ContactMaterial"), p = f("../objects/Body"), t = f("../utils/TupleDictionary"), v = f("../collision/RaycastResult"), y = f("../collision/AABB"), x = f("../collision/Ray"), m = f("../collision/NaiveBroadphase");
		b.prototype = new g;
		var u = (new y, new x);
		if (b.prototype.getContactMaterial = function(b, c) {
			return this.contactMaterialTable.get(b.id, c.id);
		}, b.prototype.numObjects = function() {
			return this.bodies.length;
		}, b.prototype.collisionMatrixTick = function() {
			var b = this.collisionMatrixPrevious;
			this.collisionMatrixPrevious = this.collisionMatrix;
			this.collisionMatrix = b;
			this.collisionMatrix.reset();
		}, b.prototype.add = b.prototype.addBody = function(b) {
			-1 === this.bodies.indexOf(b) && (b.index = this.bodies.length, this.bodies.push(b), b.world = this, b.initPosition.copy(b.position), b.initVelocity.copy(b.velocity), b.timeLastSleepy = this.time, b instanceof p && (b.initAngularVelocity.copy(b.angularVelocity), b.initQuaternion.copy(b.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), this.addBodyEvent.body = b, this.dispatchEvent(this.addBodyEvent));
		}, b.prototype.addConstraint = function(b) {
			this.constraints.push(b);
		}, b.prototype.removeConstraint = function(b) {
			b = this.constraints.indexOf(b);
			-1 !== b && this.constraints.splice(b, 1);
		}, b.prototype.rayTest = function(b, c, e) {
			e instanceof v ? this.raycastClosest(b, c, {skipBackfaces:!0}, e) : this.raycastAll(b, c, {skipBackfaces:!0}, e);
		}, b.prototype.raycastAll = function(b, c, e, g) {
			return e.mode = x.ALL, e.from = b, e.to = c, e.callback = g, u.intersectWorld(this, e);
		}, b.prototype.raycastAny = function(b, c, e, g) {
			return e.mode = x.ANY, e.from = b, e.to = c, e.result = g, u.intersectWorld(this, e);
		}, b.prototype.raycastClosest = function(b, c, e, g) {
			return e.mode = x.CLOSEST, e.from = b, e.to = c, e.result = g, u.intersectWorld(this, e);
		}, b.prototype.remove = function(b) {
			b.world = null;
			var c = this.bodies.length - 1, e = this.bodies, g = e.indexOf(b);
			if (-1 !== g) {
				e.splice(g, 1);
				for (g = 0;g !== e.length;g++) {
					e[g].index = g;
				}
				this.collisionMatrix.setNumObjects(c);
				this.removeBodyEvent.body = b;
				this.dispatchEvent(this.removeBodyEvent);
			}
		}, b.prototype.removeBody = b.prototype.remove, b.prototype.addMaterial = function(b) {
			this.materials.push(b);
		}, b.prototype.addContactMaterial = function(b) {
			this.contactmaterials.push(b);
			this.contactMaterialTable.set(b.materials[0].id, b.materials[1].id, b);
		}, "undefined" == typeof performance && (performance = {}), !performance.now) {
			var B = Date.now();
			performance.timing && performance.timing.navigationStart && (B = performance.timing.navigationStart);
			performance.now = function() {
				return Date.now() - B;
			};
		}
		var A = new h;
		b.prototype.step = function(b, c, e) {
			if (e = e || 10, c = c || 0, 0 === c) {
				this.internalStep(b), this.time += b;
			} else {
				var g = Math.floor((this.time + c) / b) - Math.floor(this.time / b), g = Math.min(g, e);
				e = performance.now();
				for (var m = 0;m !== g && (this.internalStep(b), !(performance.now() - e > 1E3 * b));m++) {
				}
				this.time += c;
				b = this.time % b / b;
				c = this.bodies;
				for (g = 0;g !== c.length;g++) {
					e = c[g], e.type !== p.STATIC && e.sleepState !== p.SLEEPING ? (e.position.vsub(e.previousPosition, A), A.scale(b, A), e.position.vadd(A, e.interpolatedPosition)) : (e.interpolatedPosition.copy(e.position), e.interpolatedQuaternion.copy(e.quaternion));
				}
			}
		};
		var D = {type:"postStep"}, G = {type:"preStep"}, F = {type:"collide", body:null, contact:null}, C = [], J = [], I = [], Q = [], M = (new h, new h, new h, new h, new h, new h, new h, new h, new h, new l, new l), N = new l, R = new h;
		b.prototype.internalStep = function(b) {
			this.dt = b;
			var c, e = this.contacts, g = this.numObjects(), m = this.bodies, h = this.solver, f = this.gravity, q = this.doProfiling, l = this.profile, u = p.DYNAMIC, r = this.constraints, w = (f.norm(), f.x), B = f.y, t = f.z;
			q && (c = performance.now());
			for (f = 0;f !== g;f++) {
				var v = m[f];
				if (v.type & u) {
					var A = v.force, v = v.mass;
					A.x += v * w;
					A.y += v * B;
					A.z += v * t;
				}
			}
			f = 0;
			for (v = this.subsystems.length;f !== v;f++) {
				this.subsystems[f].update();
			}
			q && (c = performance.now());
			I.length = 0;
			Q.length = 0;
			this.broadphase.collisionPairs(this, I, Q);
			q && (l.broadphase = performance.now() - c);
			v = r.length;
			for (f = 0;f !== v;f++) {
				if (w = r[f], !w.collideConnected) {
					for (B = I.length - 1;0 <= B;--B) {
						(w.bodyA === I[B] && w.bodyB === Q[B] || w.bodyB === I[B] && w.bodyA === Q[B]) && (I.splice(B, 1), Q.splice(B, 1));
					}
				}
			}
			this.collisionMatrixTick();
			q && (c = performance.now());
			v = e.length;
			for (f = 0;f !== v;f++) {
				C.push(e[f]);
			}
			e.length = 0;
			v = this.frictionEquations.length;
			for (f = 0;f !== v;f++) {
				J.push(this.frictionEquations[f]);
			}
			this.frictionEquations.length = 0;
			this.narrowphase.getContacts(I, Q, this, e, C, this.frictionEquations, J);
			q && (l.narrowphase = performance.now() - c);
			q && (c = performance.now());
			for (f = 0;f < this.frictionEquations.length;f++) {
				h.addEquation(this.frictionEquations[f]);
			}
			f = e.length;
			for (B = 0;B !== f;B++) {
				w = e[B], v = w.bi, t = w.bj, w.si, w.sj, v.material && t.material && this.getContactMaterial(v.material, t.material), (v.material && t.material && 0 <= v.material.restitution && 0 <= t.material.restitution && (w.restitution = v.material.restitution * t.material.restitution), h.addEquation(w), v.allowSleep && v.type === p.DYNAMIC && v.sleepState === p.SLEEPING && t.sleepState === p.AWAKE && t.type !== p.STATIC) && t.velocity.norm2() + t.angularVelocity.norm2() >= 2 * Math.pow(t.sleepSpeedLimit, 
				2) && (v._wakeUpAfterNarrowphase = !0), t.allowSleep && t.type === p.DYNAMIC && t.sleepState === p.SLEEPING && v.sleepState === p.AWAKE && v.type !== p.STATIC && v.velocity.norm2() + v.angularVelocity.norm2() >= 2 * Math.pow(v.sleepSpeedLimit, 2) && (t._wakeUpAfterNarrowphase = !0), this.collisionMatrix.set(v, t, !0), this.collisionMatrixPrevious.get(v, t) || (F.body = t, F.contact = w, v.dispatchEvent(F), F.body = v, t.dispatchEvent(F));
			}
			q && (l.makeContactConstraints = performance.now() - c, c = performance.now());
			for (f = 0;f !== g;f++) {
				v = m[f], v._wakeUpAfterNarrowphase && (v.wakeUp(), v._wakeUpAfterNarrowphase = !1);
			}
			v = r.length;
			for (f = 0;f !== v;f++) {
				for (w = r[f], w.update(), B = 0, e = w.equations.length;B !== e;B++) {
					h.addEquation(w.equations[B]);
				}
			}
			h.solve(b, this);
			q && (l.solve = performance.now() - c);
			h.removeAllEquations();
			h = Math.pow;
			for (f = 0;f !== g;f++) {
				if (v = m[f], v.type & u && (r = h(1 - v.linearDamping, b), e = v.velocity, e.mult(r, e), r = v.angularVelocity)) {
					e = h(1 - v.angularDamping, b), r.mult(e, r);
				}
			}
			this.dispatchEvent(G);
			for (f = 0;f !== g;f++) {
				v = m[f], v.preStep && v.preStep.call(v);
			}
			q && (c = performance.now());
			u = p.DYNAMIC | p.KINEMATIC;
			h = 0 === this.stepnumber % (this.quatNormalizeSkip + 1);
			r = this.quatNormalizeFast;
			e = .5 * b;
			k.types.PLANE;
			k.types.CONVEXPOLYHEDRON;
			for (f = 0;f !== g;f++) {
				if (v = m[f], w = v.force, B = v.torque, v.type & u && v.sleepState !== p.SLEEPING) {
					var t = v.velocity, A = v.angularVelocity, y = v.position, x = v.quaternion, H = v.invMass, Ba = v.invInertiaWorld;
					t.x += w.x * H * b;
					t.y += w.y * H * b;
					t.z += w.z * H * b;
					v.angularVelocity && (Ba.vmult(B, R), R.mult(b, R), R.vadd(A, A));
					y.x += t.x * b;
					y.y += t.y * b;
					y.z += t.z * b;
					v.angularVelocity && (M.set(A.x, A.y, A.z, 0), M.mult(x, N), x.x += e * N.x, x.y += e * N.y, x.z += e * N.z, x.w += e * N.w, h && (r ? x.normalizeFast() : x.normalize()));
					v.aabb && (v.aabbNeedsUpdate = !0);
					v.updateInertiaWorld && v.updateInertiaWorld();
				}
			}
			this.clearForces();
			this.broadphase.dirty = !0;
			q && (l.integrate = performance.now() - c);
			this.time += b;
			this.stepnumber += 1;
			this.dispatchEvent(D);
			for (f = 0;f !== g;f++) {
				v = m[f], (b = v.postStep) && b.call(v);
			}
			if (this.allowSleep) {
				for (f = 0;f !== g;f++) {
					m[f].sleepTick(this.time);
				}
			}
		};
		b.prototype.clearForces = function() {
			for (var b = this.bodies, c = b.length, e = 0;e !== c;e++) {
				var g = b[e];
				g.force;
				g.torque;
				g.force.set(0, 0, 0);
				g.torque.set(0, 0, 0);
			}
		};
	}, {"../collision/AABB":3, "../collision/ArrayCollisionMatrix":4, "../collision/NaiveBroadphase":7, "../collision/Ray":9, "../collision/RaycastResult":10, "../equations/ContactEquation":19, "../equations/FrictionEquation":21, "../material/ContactMaterial":24, "../material/Material":25, "../math/Quaternion":28, "../math/Vec3":30, "../objects/Body":31, "../shapes/Shape":43, "../solver/GSSolver":46, "../utils/EventTarget":49, "../utils/TupleDictionary":52, "../utils/Vec3Pool":54, "./Narrowphase":55}]}, 
	{}, [2])(2);
});
!function(a, f, l) {
	function b(c, e) {
		if (!f[c]) {
			if (!a[c]) {
				var g = "function" == typeof require && require;
				if (!e && g) {
					return g(c, !0);
				}
				if (k) {
					return k(c, !0);
				}
				throw Error("Cannot find module '" + c + "'");
			}
			e = f[c] = {exports:{}};
			a[c][0].call(e.exports, function(e) {
				var g = a[c][1][e];
				return b(g ? g : e);
			}, e, e.exports);
		}
		return f[c].exports;
	}
	for (var k = "function" == typeof require && require, h = 0;h < l.length;h++) {
		b(l[h]);
	}
	return b;
}({1:[function(a, f) {
	var l = (a("./pointable"), a("gl-matrix")), b = l.vec3, k = l.mat3, h = l.mat4;
	a = (a("underscore"), f.exports = function(a, e) {
		this.finger = a;
		this._matrix = this._center = null;
		this.type = e.type;
		this.prevJoint = e.prevJoint;
		this.nextJoint = e.nextJoint;
		this.width = e.width;
		a = Array(3);
		b.sub(a, e.nextJoint, e.prevJoint);
		this.length = b.length(a);
		this.basis = e.basis;
	});
	a.prototype.left = function() {
		return this._left ? this._left : (this._left = 0 > k.determinant(this.basis[0].concat(this.basis[1]).concat(this.basis[2])), this._left);
	};
	a.prototype.matrix = function() {
		if (this._matrix) {
			return this._matrix;
		}
		var a = this.basis, b = this._matrix = h.create();
		return b[0] = a[0][0], b[1] = a[0][1], b[2] = a[0][2], b[4] = a[1][0], b[5] = a[1][1], b[6] = a[1][2], b[8] = a[2][0], b[9] = a[2][1], b[10] = a[2][2], b[3] = this.center()[0], b[7] = this.center()[1], b[11] = this.center()[2], this.left() && (b[0] *= -1, b[1] *= -1, b[2] *= -1), this._matrix;
	};
	a.prototype.lerp = function(a, e) {
		b.lerp(a, this.prevJoint, this.nextJoint, e);
	};
	a.prototype.center = function() {
		if (this._center) {
			return this._center;
		}
		var a = b.create();
		return this.lerp(a, .5), this._center = a, a;
	};
	a.prototype.direction = function() {
		return [-1 * this.basis[2][0], -1 * this.basis[2][1], -1 * this.basis[2][2]];
	};
}, {"./pointable":14, "gl-matrix":23, underscore:24}], 2:[function(a, f) {
	a = f.exports = function(a) {
		this.pos = 0;
		this._buf = [];
		this.size = a;
	};
	a.prototype.get = function(a) {
		return void 0 == a && (a = 0), a >= this.size ? void 0 : a >= this._buf.length ? void 0 : this._buf[(this.pos - a - 1) % this.size];
	};
	a.prototype.push = function(a) {
		return this._buf[this.pos % this.size] = a, this.pos++;
	};
}, {}], 3:[function(a, f) {
	var l = a("../protocol").chooseProtocol, b = a("events").EventEmitter, k = a("underscore"), h = f.exports = function(a) {
		this.opts = k.defaults(a || {}, {host:"127.0.0.1", enableGestures:!1, scheme:this.getScheme(), port:this.getPort(), background:!1, optimizeHMD:!1, requestProtocolVersion:h.defaultProtocolVersion});
		this.host = this.opts.host;
		this.port = this.opts.port;
		this.scheme = this.opts.scheme;
		this.protocolVersionVerified = !1;
		this.optimizeHMD = this.background = null;
		this.on("ready", function() {
			this.enableGestures(this.opts.enableGestures);
			this.setBackground(this.opts.background);
			this.setOptimizeHMD(this.opts.optimizeHMD);
			console.log(this.opts.optimizeHMD ? "Optimized for head mounted display usage." : "Optimized for desktop usage.");
		});
	};
	h.defaultProtocolVersion = 6;
	h.prototype.getUrl = function() {
		return this.scheme + "//" + this.host + ":" + this.port + "/v" + this.opts.requestProtocolVersion + ".json";
	};
	h.prototype.getScheme = function() {
		return "ws:";
	};
	h.prototype.getPort = function() {
		return 6437;
	};
	h.prototype.setBackground = function(a) {
		this.opts.background = a;
		this.protocol && this.protocol.sendBackground && this.background !== this.opts.background && (this.background = this.opts.background, this.protocol.sendBackground(this, this.opts.background));
	};
	h.prototype.setOptimizeHMD = function(a) {
		this.opts.optimizeHMD = a;
		this.protocol && this.protocol.sendOptimizeHMD && this.optimizeHMD !== this.opts.optimizeHMD && (this.optimizeHMD = this.opts.optimizeHMD, this.protocol.sendOptimizeHMD(this, this.opts.optimizeHMD));
	};
	h.prototype.handleOpen = function() {
		this.connected || (this.connected = !0, this.emit("connect"));
	};
	h.prototype.enableGestures = function(a) {
		this.gesturesEnabled = a ? !0 : !1;
		this.send(this.protocol.encode({enableGestures:this.gesturesEnabled}));
	};
	h.prototype.handleClose = function(a) {
		this.connected && (this.disconnect(), 1001 === a && 1 < this.opts.requestProtocolVersion && (this.protocolVersionVerified ? this.protocolVersionVerified = !1 : this.opts.requestProtocolVersion--), this.startReconnection());
	};
	h.prototype.startReconnection = function() {
		var a = this;
		this.reconnectionTimer || (this.reconnectionTimer = setInterval(function() {
			a.reconnect();
		}, 500));
	};
	h.prototype.stopReconnection = function() {
		this.reconnectionTimer = clearInterval(this.reconnectionTimer);
	};
	h.prototype.disconnect = function(a) {
		return a || this.stopReconnection(), this.socket ? (this.socket.close(), delete this.socket, delete this.protocol, delete this.background, delete this.optimizeHMD, delete this.focusedState, this.connected && (this.connected = !1, this.emit("disconnect")), !0) : void 0;
	};
	h.prototype.reconnect = function() {
		this.connected ? this.stopReconnection() : (this.disconnect(!0), this.connect());
	};
	h.prototype.handleData = function(a) {
		var b;
		a = JSON.parse(a);
		void 0 === this.protocol ? (b = this.protocol = l(a), this.protocolVersionVerified = !0, this.emit("ready")) : b = this.protocol(a);
		this.emit(b.type, b);
	};
	h.prototype.connect = function() {
		return this.socket ? void 0 : (this.socket = this.setupSocket(), !0);
	};
	h.prototype.send = function(a) {
		this.socket.send(a);
	};
	h.prototype.reportFocus = function(a) {
		this.connected && this.focusedState !== a && (this.focusedState = a, this.emit(this.focusedState ? "focus" : "blur"), this.protocol && this.protocol.sendFocused && this.protocol.sendFocused(this, this.focusedState));
	};
	k.extend(h.prototype, b.prototype);
}, {"../protocol":15, events:21, underscore:24}], 4:[function(a, f) {
	var l = f.exports = a("./base");
	a = a("underscore");
	f = f.exports = function(a) {
		l.call(this, a);
		var b = this;
		this.on("ready", function() {
			b.startFocusLoop();
		});
		this.on("disconnect", function() {
			b.stopFocusLoop();
		});
	};
	a.extend(f.prototype, l.prototype);
	f.__proto__ = l;
	f.prototype.useSecure = function() {
		return "https:" === location.protocol;
	};
	f.prototype.getScheme = function() {
		return this.useSecure() ? "wss:" : "ws:";
	};
	f.prototype.getPort = function() {
		return this.useSecure() ? 6436 : 6437;
	};
	f.prototype.setupSocket = function() {
		var a = this, k = new WebSocket(this.getUrl());
		return k.onopen = function() {
			a.handleOpen();
		}, k.onclose = function(b) {
			a.handleClose(b.code, b.reason);
		}, k.onmessage = function(b) {
			a.handleData(b.data);
		}, k.onerror = function() {
			a.useSecure() && "wss:" === a.scheme && (a.scheme = "ws:", a.port = 6437, a.disconnect(), a.connect());
		}, k;
	};
	f.prototype.startFocusLoop = function() {
		if (!this.focusDetectorTimer) {
			var a = this, k = null, k = "undefined" != typeof document.hidden ? "hidden" : "undefined" != typeof document.mozHidden ? "mozHidden" : "undefined" != typeof document.msHidden ? "msHidden" : "undefined" != typeof document.webkitHidden ? "webkitHidden" : void 0;
			void 0 === a.windowVisible && (a.windowVisible = void 0 === k ? !0 : !1 === document[k]);
			var h = window.addEventListener("focus", function() {
				a.windowVisible = !0;
				e();
			}), c = window.addEventListener("blur", function() {
				a.windowVisible = !1;
				e();
			});
			this.on("disconnect", function() {
				window.removeEventListener("focus", h);
				window.removeEventListener("blur", c);
			});
			var e = function() {
				a.reportFocus((void 0 === k ? !0 : !1 === document[k]) && a.windowVisible);
			};
			e();
			this.focusDetectorTimer = setInterval(e, 100);
		}
	};
	f.prototype.stopFocusLoop = function() {
		this.focusDetectorTimer && (clearTimeout(this.focusDetectorTimer), delete this.focusDetectorTimer);
	};
}, {"./base":3, underscore:24}], 5:[function(a, f) {
	var l = a("__browserify_process"), b = a("./frame"), k = a("./hand"), h = a("./pointable"), c = a("./finger"), e = a("./circular_buffer"), g = a("./pipeline"), q = a("events").EventEmitter, r = a("./gesture").gestureListener, w = a("./dialog"), p = a("underscore"), t = f.exports = function(c) {
		var g = this;
		c = p.defaults(c || {}, {inNode:"undefined" != typeof l && l.versions && l.versions.node});
		this.inNode = c.inNode;
		c = p.defaults(c || {}, {frameEventName:this.useAnimationLoop() ? "animationFrame" : "deviceFrame", suppressAnimationLoop:!this.useAnimationLoop(), loopWhileDisconnected:!0, useAllPlugins:!1, checkVersion:!0});
		this.animationFrameRequested = !1;
		this.onAnimationFrame = function(a) {
			g.lastConnectionFrame.valid && g.emit("animationFrame", g.lastConnectionFrame);
			g.emit("frameEnd", a);
			g.loopWhileDisconnected && (!1 !== g.connection.focusedState || g.connection.opts.background) ? window.requestAnimationFrame(g.onAnimationFrame) : g.animationFrameRequested = !1;
		};
		this.suppressAnimationLoop = c.suppressAnimationLoop;
		this.loopWhileDisconnected = c.loopWhileDisconnected;
		this.frameEventName = c.frameEventName;
		this.useAllPlugins = c.useAllPlugins;
		this.history = new e(200);
		this.lastConnectionFrame = this.lastValidFrame = this.lastFrame = b.Invalid;
		this.accumulatedGestures = [];
		this.checkVersion = c.checkVersion;
		this.connectionType = void 0 === c.connectionType ? a(this.inBrowser() ? "./connection/browser" : "./connection/node") : c.connectionType;
		this.connection = new this.connectionType(c);
		this.streamingCount = 0;
		this.devices = {};
		this.plugins = {};
		this._pluginPipelineSteps = {};
		this._pluginExtendedMethods = {};
		c.useAllPlugins && this.useRegisteredPlugins();
		this.setupFrameEvents(c);
		this.setupConnectionEvents();
		this.startAnimationLoop();
	};
	t.prototype.gesture = function(a, b) {
		a = r(this, a);
		return void 0 !== b && a.stop(b), a;
	};
	t.prototype.setBackground = function(a) {
		return this.connection.setBackground(a), this;
	};
	t.prototype.setOptimizeHMD = function(a) {
		return this.connection.setOptimizeHMD(a), this;
	};
	t.prototype.inBrowser = function() {
		return !this.inNode;
	};
	t.prototype.useAnimationLoop = function() {
		return this.inBrowser() && !this.inBackgroundPage();
	};
	t.prototype.inBackgroundPage = function() {
		return "undefined" != typeof chrome && chrome.extension && chrome.extension.getBackgroundPage && chrome.extension.getBackgroundPage() === window;
	};
	t.prototype.connect = function() {
		return this.connection.connect(), this;
	};
	t.prototype.streaming = function() {
		return 0 < this.streamingCount;
	};
	t.prototype.connected = function() {
		return !!this.connection.connected;
	};
	t.prototype.startAnimationLoop = function() {
		this.suppressAnimationLoop || this.animationFrameRequested || (this.animationFrameRequested = !0, window.requestAnimationFrame(this.onAnimationFrame));
	};
	t.prototype.disconnect = function() {
		return this.connection.disconnect(), this;
	};
	t.prototype.frame = function(a) {
		return this.history.get(a) || b.Invalid;
	};
	t.prototype.loop = function(a) {
		return a && ("function" == typeof a ? this.on(this.frameEventName, a) : this.setupFrameEvents(a)), this.connect();
	};
	t.prototype.addStep = function(a) {
		this.pipeline || (this.pipeline = new g(this));
		this.pipeline.addStep(a);
	};
	t.prototype.processFrame = function(a) {
		a.gestures && (this.accumulatedGestures = this.accumulatedGestures.concat(a.gestures));
		this.lastConnectionFrame = a;
		this.startAnimationLoop();
		this.emit("deviceFrame", a);
	};
	t.prototype.processFinishedFrame = function(a) {
		if (this.lastFrame = a, a.valid && (this.lastValidFrame = a), a.controller = this, a.historyIdx = this.history.push(a), a.gestures) {
			a.gestures = this.accumulatedGestures;
			this.accumulatedGestures = [];
			for (var c = 0;c != a.gestures.length;c++) {
				this.emit("gesture", a.gestures[c], a);
			}
		}
		this.pipeline && (a = this.pipeline.run(a), a || (a = b.Invalid));
		this.emit("frame", a);
		this.emitHandEvents(a);
	};
	t.prototype.emitHandEvents = function(a) {
		for (var b = 0;b < a.hands.length;b++) {
			this.emit("hand", a.hands[b]);
		}
	};
	t.prototype.setupFrameEvents = function(a) {
		a.frame && this.on("frame", a.frame);
		a.hand && this.on("hand", a.hand);
	};
	t.prototype.setupConnectionEvents = function() {
		var a = this;
		this.connection.on("frame", function(b) {
			a.processFrame(b);
		});
		this.on(this.frameEventName, function(b) {
			a.processFinishedFrame(b);
		});
		var b = function() {
			if (5 > a.connection.opts.requestProtocolVersion && 0 == a.streamingCount) {
				a.streamingCount = 1;
				var c = {attached:!0, streaming:!0, type:"unknown", id:"Lx00000000000"};
				a.devices[c.id] = c;
				a.emit("deviceAttached", c);
				a.emit("deviceStreaming", c);
				a.emit("streamingStarted", c);
				a.connection.removeListener("frame", b);
			}
		}, c = function() {
			if (0 < a.streamingCount) {
				for (var b in a.devices) {
					a.emit("deviceStopped", a.devices[b]), a.emit("deviceRemoved", a.devices[b]);
				}
				a.emit("streamingStopped", a.devices[b]);
				a.streamingCount = 0;
				for (b in a.devices) {
					delete a.devices[b];
				}
			}
		};
		this.connection.on("focus", function() {
			a.loopWhileDisconnected && a.startAnimationLoop();
			a.emit("focus");
		});
		this.connection.on("blur", function() {
			a.emit("blur");
		});
		this.connection.on("protocol", function(b) {
			b.on("beforeFrameCreated", function(b) {
				a.emit("beforeFrameCreated", b);
			});
			b.on("afterFrameCreated", function(b, c) {
				a.emit("afterFrameCreated", b, c);
			});
			a.emit("protocol", b);
		});
		this.connection.on("ready", function() {
			a.checkVersion && !a.inNode && a.checkOutOfDate();
			a.emit("ready");
		});
		this.connection.on("connect", function() {
			a.emit("connect");
			a.connection.removeListener("frame", b);
			a.connection.on("frame", b);
		});
		this.connection.on("disconnect", function() {
			a.emit("disconnect");
			c();
		});
		this.connection.on("deviceConnect", function(e) {
			e.state ? (a.emit("deviceConnected"), a.connection.removeListener("frame", b), a.connection.on("frame", b)) : (a.emit("deviceDisconnected"), c());
		});
		this.connection.on("deviceEvent", function(b) {
			b = b.state;
			var c = a.devices[b.id], e = {}, g;
			for (g in b) {
				c && c.hasOwnProperty(g) && c[g] == b[g] || (e[g] = !0);
			}
			a.devices[b.id] = b;
			e.attached && a.emit(b.attached ? "deviceAttached" : "deviceRemoved", b);
			e.streaming && (b.streaming ? (a.streamingCount++, a.emit("deviceStreaming", b), 1 == a.streamingCount && a.emit("streamingStarted", b), e.attached || a.emit("deviceConnected")) : e.attached && b.attached || (a.streamingCount--, a.emit("deviceStopped", b), 0 == a.streamingCount && a.emit("streamingStopped", b), a.emit("deviceDisconnected")));
		});
		this.on("newListener", function(a) {
			"deviceConnected" != a && "deviceDisconnected" != a || console.warn(a + " events are depricated.  Consider using 'streamingStarted/streamingStopped' or 'deviceStreaming/deviceStopped' instead");
		});
	};
	t.prototype.checkOutOfDate = function() {
		console.assert(this.connection && this.connection.protocol);
		var a = this.connection.protocol.serviceVersion, b = this.connection.protocol.version, c = this.connectionType.defaultProtocolVersion;
		return c > b ? (console.warn("Your Protocol Version is v" + b + ", this app was designed for v" + c), w.warnOutOfDate({sV:a, pV:b}), !0) : !1;
	};
	t._pluginFactories = {};
	t.plugin = function(a, b) {
		return this._pluginFactories[a] && console.warn('Plugin "' + a + '" already registered'), this._pluginFactories[a] = b;
	};
	t.plugins = function() {
		return p.keys(this._pluginFactories);
	};
	t.prototype.use = function(a, e) {
		var f, m;
		if (f = "function" == typeof a ? a : t._pluginFactories[a], !f) {
			throw "Leap Plugin " + a + " not found.";
		}
		if (e || (e = {}), this.plugins[a]) {
			return p.extend(this.plugins[a], e), this;
		}
		this.plugins[a] = e;
		e = f.call(this, e);
		for (m in e) {
			if (f = e[m], "function" == typeof f) {
				var q = a, l = m;
				-1 != ["beforeFrameCreated", "afterFrameCreated"].indexOf(l) ? this.on(l, f) : (this.pipeline || (this.pipeline = new g(this)), this._pluginPipelineSteps[q] || (this._pluginPipelineSteps[q] = []), this._pluginPipelineSteps[q].push(this.pipeline.addWrappedStep(l, f)));
			} else {
				q = a;
				l = m;
				switch(this._pluginExtendedMethods[q] || (this._pluginExtendedMethods[q] = []), l) {
					case "frame":
						l = b;
						break;
					case "hand":
						l = k;
						break;
					case "pointable":
						l = h;
						p.extend(c.prototype, f);
						p.extend(c.Invalid, f);
						break;
					case "finger":
						l = c;
						break;
					default:
						throw q + ' specifies invalid object type "' + l + '" for prototypical extension';;
				}
				p.extend(l.prototype, f);
				p.extend(l.Invalid, f);
				this._pluginExtendedMethods[q].push([l, f]);
			}
		}
		return this;
	};
	t.prototype.stopUsing = function(a) {
		var b, c;
		b = this._pluginPipelineSteps[a];
		var e = this._pluginExtendedMethods[a], g;
		if (this.plugins[a]) {
			if (b) {
				for (g = 0;g < b.length;g++) {
					this.pipeline.removeStep(b[g]);
				}
			}
			if (e) {
				for (g = 0;g < e.length;g++) {
					b = e[g][0];
					c = e[g][1];
					for (var h in c) {
						delete b.prototype[h], delete b.Invalid[h];
					}
				}
			}
			return delete this.plugins[a], this;
		}
	};
	t.prototype.useRegisteredPlugins = function() {
		for (var a in t._pluginFactories) {
			this.use(a);
		}
	};
	p.extend(t.prototype, q.prototype);
}, {"./circular_buffer":2, "./connection/browser":4, "./connection/node":20, "./dialog":6, "./finger":7, "./frame":8, "./gesture":9, "./hand":10, "./pipeline":13, "./pointable":14, __browserify_process:22, events:21, underscore:24}], 6:[function(a, f) {
	var l = a("__browserify_process"), b = f.exports = function(a, b) {
		this.options = b || {};
		this.message = a;
		this.createElement();
	};
	b.prototype.createElement = function() {
		this.element = document.createElement("div");
		this.element.className = "leapjs-dialog";
		this.element.style.position = "fixed";
		this.element.style.top = "8px";
		this.element.style.left = 0;
		this.element.style.right = 0;
		this.element.style.textAlign = "center";
		this.element.style.zIndex = 1E3;
		var a = document.createElement("div");
		this.element.appendChild(a);
		a.style.className = "leapjs-dialog";
		a.style.display = "inline-block";
		a.style.margin = "auto";
		a.style.padding = "8px";
		a.style.color = "#222";
		a.style.background = "#eee";
		a.style.borderRadius = "4px";
		a.style.border = "1px solid #999";
		a.style.textAlign = "left";
		a.style.cursor = "pointer";
		a.style.whiteSpace = "nowrap";
		a.style.transition = "box-shadow 1s linear";
		a.innerHTML = this.message;
		this.options.onclick && a.addEventListener("click", this.options.onclick);
		this.options.onmouseover && a.addEventListener("mouseover", this.options.onmouseover);
		this.options.onmouseout && a.addEventListener("mouseout", this.options.onmouseout);
		this.options.onmousemove && a.addEventListener("mousemove", this.options.onmousemove);
	};
	b.prototype.show = function() {
		return document.body.appendChild(this.element), this;
	};
	b.prototype.hide = function() {
		return document.body.removeChild(this.element), this;
	};
	b.warnOutOfDate = function(a) {
		a || (a = {});
		var h = "http://developer.leapmotion.com?";
		a.returnTo = window.location.href;
		for (var c in a) {
			h += c + "=" + encodeURIComponent(a[c]) + "&";
		}
		var e;
		return e = new b("This site requires Leap Motion Tracking V2.<button id='leapjs-accept-upgrade'  style='color: #444; transition: box-shadow 100ms linear; cursor: pointer; vertical-align: baseline; margin-left: 16px;'>Upgrade</button><button id='leapjs-decline-upgrade' style='color: #444; transition: box-shadow 100ms linear; cursor: pointer; vertical-align: baseline; margin-left: 8px; '>Not Now</button>", {onclick:function(a) {
			"leapjs-decline-upgrade" != a.target.id && (a = window.open(h, "_blank", "height=800,width=1000,location=1,menubar=1,resizable=1,status=1,toolbar=1,scrollbars=1"), window.focus && a.focus());
			return e.hide(), !0;
		}, onmousemove:function(a) {
			a.target == document.getElementById("leapjs-decline-upgrade") ? (document.getElementById("leapjs-decline-upgrade").style.color = "#000", document.getElementById("leapjs-decline-upgrade").style.boxShadow = "0px 0px 2px #5daa00", document.getElementById("leapjs-accept-upgrade").style.color = "#444", document.getElementById("leapjs-accept-upgrade").style.boxShadow = "none") : (document.getElementById("leapjs-accept-upgrade").style.color = "#000", document.getElementById("leapjs-accept-upgrade").style.boxShadow = 
			"0px 0px 2px #5daa00", document.getElementById("leapjs-decline-upgrade").style.color = "#444", document.getElementById("leapjs-decline-upgrade").style.boxShadow = "none");
		}, onmouseout:function() {
			document.getElementById("leapjs-decline-upgrade").style.color = "#444";
			document.getElementById("leapjs-decline-upgrade").style.boxShadow = "none";
			document.getElementById("leapjs-accept-upgrade").style.color = "#444";
			document.getElementById("leapjs-accept-upgrade").style.boxShadow = "none";
		}}), e.show();
	};
	b.hasWarnedBones = !1;
	b.warnBones = function() {
		this.hasWarnedBones || (this.hasWarnedBones = !0, console.warn("Your Leap Service is out of date"), "undefined" != typeof l && l.versions && l.versions.node || this.warnOutOfDate({reason:"bones"}));
	};
}, {__browserify_process:22}], 7:[function(a, f) {
	var l = a("./pointable"), b = a("./bone"), k = a("./dialog");
	a = a("underscore");
	f = f.exports = function(a) {
		l.call(this, a);
		this.dipPosition = a.dipPosition;
		this.pipPosition = a.pipPosition;
		this.mcpPosition = a.mcpPosition;
		this.carpPosition = a.carpPosition;
		this.extended = a.extended;
		this.type = a.type;
		this.finger = !0;
		this.positions = [this.carpPosition, this.mcpPosition, this.pipPosition, this.dipPosition, this.tipPosition];
		a.bases ? this.addBones(a) : k.warnBones();
	};
	a.extend(f.prototype, l.prototype);
	f.prototype.addBones = function(a) {
		this.metacarpal = new b(this, {type:0, width:this.width, prevJoint:this.carpPosition, nextJoint:this.mcpPosition, basis:a.bases[0]});
		this.proximal = new b(this, {type:1, width:this.width, prevJoint:this.mcpPosition, nextJoint:this.pipPosition, basis:a.bases[1]});
		this.medial = new b(this, {type:2, width:this.width, prevJoint:this.pipPosition, nextJoint:this.dipPosition, basis:a.bases[2]});
		this.distal = new b(this, {type:3, width:this.width, prevJoint:this.dipPosition, nextJoint:a.btipPosition, basis:a.bases[3]});
		this.bones = [this.metacarpal, this.proximal, this.medial, this.distal];
	};
	f.prototype.toString = function() {
		return "Finger [ id:" + this.id + " " + this.length + "mmx | width:" + this.width + "mm | direction:" + this.direction + " ]";
	};
	f.Invalid = {valid:!1};
}, {"./bone":1, "./dialog":6, "./pointable":14, underscore:24}], 8:[function(a, f) {
	var l = a("./hand"), b = a("./pointable"), k = a("./gesture").createGesture, h = a("gl-matrix"), c = h.mat3, e = h.vec3, g = a("./interaction_box"), q = a("./finger"), r = a("underscore");
	a = f.exports = function(a) {
		if (this.valid = !0, this.id = a.id, this.timestamp = a.timestamp, this.hands = [], this.handsMap = {}, this.pointables = [], this.tools = [], this.fingers = [], a.interactionBox && (this.interactionBox = new g(a.interactionBox)), this.gestures = [], this.pointablesMap = {}, this._translation = a.t, this._rotation = r.flatten(a.r), this._scaleFactor = a.s, this.data = a, this.type = "frame", this.currentFrameRate = a.currentFrameRate, a.gestures) {
			for (var b = 0, c = a.gestures.length;b != c;b++) {
				this.gestures.push(k(a.gestures[b]));
			}
		}
		this.postprocessData(a);
	};
	a.prototype.postprocessData = function(a) {
		a || (a = this.data);
		for (var c = 0, e = a.hands.length;c != e;c++) {
			var g = new l(a.hands[c]);
			g.frame = this;
			this.hands.push(g);
			this.handsMap[g.id] = g;
		}
		a.pointables = r.sortBy(a.pointables, function(a) {
			return a.id;
		});
		c = 0;
		for (e = a.pointables.length;c != e;c++) {
			g = a.pointables[c], g = g.dipPosition ? new q(g) : new b(g), g.frame = this, this.addPointable(g);
		}
	};
	a.prototype.addPointable = function(a) {
		if (this.pointables.push(a), this.pointablesMap[a.id] = a, (a.tool ? this.tools : this.fingers).push(a), void 0 !== a.handId && this.handsMap.hasOwnProperty(a.handId)) {
			var b = this.handsMap[a.handId];
			switch(b.pointables.push(a), (a.tool ? b.tools : b.fingers).push(a), a.type) {
				case 0:
					b.thumb = a;
					break;
				case 1:
					b.indexFinger = a;
					break;
				case 2:
					b.middleFinger = a;
					break;
				case 3:
					b.ringFinger = a;
					break;
				case 4:
					b.pinky = a;
			}
		}
	};
	a.prototype.tool = function(a) {
		a = this.pointable(a);
		return a.tool ? a : b.Invalid;
	};
	a.prototype.pointable = function(a) {
		return this.pointablesMap[a] || b.Invalid;
	};
	a.prototype.finger = function(a) {
		a = this.pointable(a);
		return a.tool ? b.Invalid : a;
	};
	a.prototype.hand = function(a) {
		return this.handsMap[a] || l.Invalid;
	};
	a.prototype.rotationAngle = function(a, b) {
		if (!this.valid || !a.valid) {
			return 0;
		}
		var c = this.rotationMatrix(a), c = Math.acos(.5 * (c[0] + c[4] + c[8] - 1));
		if (c = isNaN(c) ? 0 : c, void 0 !== b) {
			a = this.rotationAxis(a), c *= e.dot(a, e.normalize(e.create(), b));
		}
		return c;
	};
	a.prototype.rotationAxis = function(a) {
		return this.valid && a.valid ? e.normalize(e.create(), [this._rotation[7] - a._rotation[5], this._rotation[2] - a._rotation[6], this._rotation[3] - a._rotation[1]]) : e.create();
	};
	a.prototype.rotationMatrix = function(a) {
		if (!this.valid || !a.valid) {
			return c.create();
		}
		var b = c.transpose(c.create(), this._rotation);
		return c.multiply(c.create(), a._rotation, b);
	};
	a.prototype.scaleFactor = function(a) {
		return this.valid && a.valid ? Math.exp(this._scaleFactor - a._scaleFactor) : 1;
	};
	a.prototype.translation = function(a) {
		return this.valid && a.valid ? e.subtract(e.create(), this._translation, a._translation) : e.create();
	};
	a.prototype.toString = function() {
		var a = "Frame [ id:" + this.id + " | timestamp:" + this.timestamp + " | Hand count:(" + this.hands.length + ") | Pointable count:(" + this.pointables.length + ")";
		return this.gestures && (a += " | Gesture count:(" + this.gestures.length + ")"), a + " ]";
	};
	a.prototype.dump = function() {
		var a;
		a = "Frame Info:<br/>" + this.toString();
		a += "<br/><br/>Hands:<br/>";
		for (var b = 0, c = this.hands.length;b != c;b++) {
			a += "  " + this.hands[b].toString() + "<br/>";
		}
		a += "<br/><br/>Pointables:<br/>";
		b = 0;
		for (c = this.pointables.length;b != c;b++) {
			a += "  " + this.pointables[b].toString() + "<br/>";
		}
		if (this.gestures) {
			for (a += "<br/><br/>Gestures:<br/>", b = 0, c = this.gestures.length;b != c;b++) {
				a += "  " + this.gestures[b].toString() + "<br/>";
			}
		}
		return a += "<br/><br/>Raw JSON:<br/>", a + JSON.stringify(this.data);
	};
	a.Invalid = {valid:!1, hands:[], fingers:[], tools:[], gestures:[], pointables:[], pointable:function() {
		return b.Invalid;
	}, finger:function() {
		return b.Invalid;
	}, hand:function() {
		return l.Invalid;
	}, toString:function() {
		return "invalid frame";
	}, dump:function() {
		return this.toString();
	}, rotationAngle:function() {
		return 0;
	}, rotationMatrix:function() {
		return c.create();
	}, rotationAxis:function() {
		return e.create();
	}, scaleFactor:function() {
		return 1;
	}, translation:function() {
		return e.create();
	}};
}, {"./finger":7, "./gesture":9, "./hand":10, "./interaction_box":12, "./pointable":14, "gl-matrix":23, underscore:24}], 9:[function(a, f, l) {
	var b = a("gl-matrix").vec3;
	f = a("events").EventEmitter;
	var k = a("underscore"), h = (l.createGesture = function(a) {
		var b;
		switch(a.type) {
			case "circle":
				b = new c(a);
				break;
			case "swipe":
				b = new e(a);
				break;
			case "screenTap":
				b = new g(a);
				break;
			case "keyTap":
				b = new q(a);
				break;
			default:
				throw "unknown gesture type";;
		}
		return b.id = a.id, b.handIds = a.handIds.slice(), b.pointableIds = a.pointableIds.slice(), b.duration = a.duration, b.state = a.state, b.type = a.type, b;
	}, l.gestureListener = function(a, b) {
		var c = {}, e = {};
		a.on("gesture", function(a, g) {
			if (a.type == b) {
				if (("start" == a.state || "stop" == a.state) && void 0 === e[a.id]) {
					var m = new h(a, g);
					e[a.id] = m;
					k.each(c, function(a, b) {
						m.on(b, a);
					});
				}
				e[a.id].update(a, g);
				"stop" == a.state && delete e[a.id];
			}
		});
		var g = {start:function(a) {
			return c.start = a, g;
		}, stop:function(a) {
			return c.stop = a, g;
		}, complete:function(a) {
			return c.stop = a, g;
		}, update:function(a) {
			return c.update = a, g;
		}};
		return g;
	}, l.Gesture = function(a, b) {
		this.gestures = [a];
		this.frames = [b];
	});
	h.prototype.update = function(a, b) {
		this.lastGesture = a;
		this.lastFrame = b;
		this.gestures.push(a);
		this.frames.push(b);
		this.emit(a.state, this);
	};
	h.prototype.translation = function() {
		return b.subtract(b.create(), this.lastGesture.startPosition, this.lastGesture.position);
	};
	k.extend(h.prototype, f.prototype);
	var c = function(a) {
		this.center = a.center;
		this.normal = a.normal;
		this.progress = a.progress;
		this.radius = a.radius;
	};
	c.prototype.toString = function() {
		return "CircleGesture [" + JSON.stringify(this) + "]";
	};
	var e = function(a) {
		this.startPosition = a.startPosition;
		this.position = a.position;
		this.direction = a.direction;
		this.speed = a.speed;
	};
	e.prototype.toString = function() {
		return "SwipeGesture [" + JSON.stringify(this) + "]";
	};
	var g = function(a) {
		this.position = a.position;
		this.direction = a.direction;
		this.progress = a.progress;
	};
	g.prototype.toString = function() {
		return "ScreenTapGesture [" + JSON.stringify(this) + "]";
	};
	var q = function(a) {
		this.position = a.position;
		this.direction = a.direction;
		this.progress = a.progress;
	};
	q.prototype.toString = function() {
		return "KeyTapGesture [" + JSON.stringify(this) + "]";
	};
}, {events:21, "gl-matrix":23, underscore:24}], 10:[function(a, f) {
	var l = a("./pointable"), b = a("./bone"), k = a("gl-matrix"), h = k.mat3, c = k.vec3, e = a("underscore");
	a = f.exports = function(a) {
		this.id = a.id;
		this.palmPosition = a.palmPosition;
		this.direction = a.direction;
		this.palmVelocity = a.palmVelocity;
		this.palmNormal = a.palmNormal;
		this.sphereCenter = a.sphereCenter;
		this.sphereRadius = a.sphereRadius;
		this.valid = !0;
		this.pointables = [];
		this.fingers = [];
		this.arm = a.armBasis ? new b(this, {type:4, width:a.armWidth, prevJoint:a.elbow, nextJoint:a.wrist, basis:a.armBasis}) : null;
		this.tools = [];
		this._translation = a.t;
		this._rotation = e.flatten(a.r);
		this._scaleFactor = a.s;
		this.timeVisible = a.timeVisible;
		this.stabilizedPalmPosition = a.stabilizedPalmPosition;
		this.type = a.type;
		this.grabStrength = a.grabStrength;
		this.pinchStrength = a.pinchStrength;
		this.confidence = a.confidence;
	};
	a.prototype.finger = function(a) {
		return (a = this.frame.finger(a)) && a.handId == this.id ? a : l.Invalid;
	};
	a.prototype.rotationAngle = function(a, b) {
		if (!this.valid || !a.valid || !a.hand(this.id).valid) {
			return 0;
		}
		var e = this.rotationMatrix(a), e = Math.acos(.5 * (e[0] + e[4] + e[8] - 1));
		if (e = isNaN(e) ? 0 : e, void 0 !== b) {
			a = this.rotationAxis(a), e *= c.dot(a, c.normalize(c.create(), b));
		}
		return e;
	};
	a.prototype.rotationAxis = function(a) {
		if (!this.valid || !a.valid) {
			return c.create();
		}
		a = a.hand(this.id);
		return a.valid ? c.normalize(c.create(), [this._rotation[7] - a._rotation[5], this._rotation[2] - a._rotation[6], this._rotation[3] - a._rotation[1]]) : c.create();
	};
	a.prototype.rotationMatrix = function(a) {
		if (!this.valid || !a.valid) {
			return h.create();
		}
		a = a.hand(this.id);
		if (!a.valid) {
			return h.create();
		}
		var b = h.transpose(h.create(), this._rotation);
		return h.multiply(h.create(), a._rotation, b);
	};
	a.prototype.scaleFactor = function(a) {
		if (!this.valid || !a.valid) {
			return 1;
		}
		a = a.hand(this.id);
		return a.valid ? Math.exp(this._scaleFactor - a._scaleFactor) : 1;
	};
	a.prototype.translation = function(a) {
		if (!this.valid || !a.valid) {
			return c.create();
		}
		a = a.hand(this.id);
		return a.valid ? [this._translation[0] - a._translation[0], this._translation[1] - a._translation[1], this._translation[2] - a._translation[2]] : c.create();
	};
	a.prototype.toString = function() {
		return "Hand (" + this.type + ") [ id: " + this.id + " | palm velocity:" + this.palmVelocity + " | sphere center:" + this.sphereCenter + " ] ";
	};
	a.prototype.pitch = function() {
		return Math.atan2(this.direction[1], -this.direction[2]);
	};
	a.prototype.yaw = function() {
		return Math.atan2(this.direction[0], -this.direction[2]);
	};
	a.prototype.roll = function() {
		return Math.atan2(this.palmNormal[0], -this.palmNormal[1]);
	};
	a.Invalid = {valid:!1, fingers:[], tools:[], pointables:[], left:!1, pointable:function() {
		return l.Invalid;
	}, finger:function() {
		return l.Invalid;
	}, toString:function() {
		return "invalid frame";
	}, dump:function() {
		return this.toString();
	}, rotationAngle:function() {
		return 0;
	}, rotationMatrix:function() {
		return h.create();
	}, rotationAxis:function() {
		return c.create();
	}, scaleFactor:function() {
		return 1;
	}, translation:function() {
		return c.create();
	}};
}, {"./bone":1, "./pointable":14, "gl-matrix":23, underscore:24}], 11:[function(a, f) {
	f.exports = {Controller:a("./controller"), Frame:a("./frame"), Gesture:a("./gesture"), Hand:a("./hand"), Pointable:a("./pointable"), Finger:a("./finger"), InteractionBox:a("./interaction_box"), CircularBuffer:a("./circular_buffer"), UI:a("./ui"), JSONProtocol:a("./protocol").JSONProtocol, glMatrix:a("gl-matrix"), mat3:a("gl-matrix").mat3, vec3:a("gl-matrix").vec3, loopController:void 0, version:a("./version.js"), _:a("underscore"), EventEmitter:a("events").EventEmitter, loop:function(a, b) {
		return a && void 0 === b && "[object Function]" === {}.toString.call(a) && (b = a, a = {}), this.loopController ? a && this.loopController.setupFrameEvents(a) : this.loopController = new this.Controller(a), this.loopController.loop(b), this.loopController;
	}, plugin:function(a, b) {
		this.Controller.plugin(a, b);
	}};
}, {"./circular_buffer":2, "./controller":5, "./finger":7, "./frame":8, "./gesture":9, "./hand":10, "./interaction_box":12, "./pointable":14, "./protocol":15, "./ui":16, "./version.js":19, events:21, "gl-matrix":23, underscore:24}], 12:[function(a, f) {
	var l = a("gl-matrix").vec3;
	a = f.exports = function(a) {
		this.valid = !0;
		this.center = a.center;
		this.size = a.size;
		this.width = a.size[0];
		this.height = a.size[1];
		this.depth = a.size[2];
	};
	a.prototype.denormalizePoint = function(a) {
		return l.fromValues((a[0] - .5) * this.size[0] + this.center[0], (a[1] - .5) * this.size[1] + this.center[1], (a[2] - .5) * this.size[2] + this.center[2]);
	};
	a.prototype.normalizePoint = function(a, k) {
		a = l.fromValues((a[0] - this.center[0]) / this.size[0] + .5, (a[1] - this.center[1]) / this.size[1] + .5, (a[2] - this.center[2]) / this.size[2] + .5);
		return k && (a[0] = Math.min(Math.max(a[0], 0), 1), a[1] = Math.min(Math.max(a[1], 0), 1), a[2] = Math.min(Math.max(a[2], 0), 1)), a;
	};
	a.prototype.toString = function() {
		return "InteractionBox [ width:" + this.width + " | height:" + this.height + " | depth:" + this.depth + " ]";
	};
	a.Invalid = {valid:!1};
}, {"gl-matrix":23}], 13:[function(a, f) {
	a = f.exports = function(a) {
		this.steps = [];
		this.controller = a;
	};
	a.prototype.addStep = function(a) {
		this.steps.push(a);
	};
	a.prototype.run = function(a) {
		for (var b = this.steps.length, k = 0;k != b && a;k++) {
			a = this.steps[k](a);
		}
		return a;
	};
	a.prototype.removeStep = function(a) {
		a = this.steps.indexOf(a);
		if (-1 === a) {
			throw "Step not found in pipeline";
		}
		this.steps.splice(a, 1);
	};
	a.prototype.addWrappedStep = function(a, b) {
		var k = this.controller, h = function(c) {
			var e, g, h;
			e = "frame" == a ? [c] : c[a + "s"] || [];
			g = 0;
			for (h = e.length;h > g;g++) {
				b.call(k, e[g]);
			}
			return c;
		};
		return this.addStep(h), h;
	};
}, {}], 14:[function(a, f) {
	a = a("gl-matrix");
	f = (a.vec3, f.exports = function(a) {
		this.valid = !0;
		this.id = a.id;
		this.handId = a.handId;
		this.length = a.length;
		this.tool = a.tool;
		this.width = a.width;
		this.direction = a.direction;
		this.stabilizedTipPosition = a.stabilizedTipPosition;
		this.tipPosition = a.tipPosition;
		this.tipVelocity = a.tipVelocity;
		this.touchZone = a.touchZone;
		this.touchDistance = a.touchDistance;
		this.timeVisible = a.timeVisible;
	});
	f.prototype.toString = function() {
		return "Pointable [ id:" + this.id + " " + this.length + "mmx | width:" + this.width + "mm | direction:" + this.direction + " ]";
	};
	f.prototype.hand = function() {
		return this.frame.hand(this.handId);
	};
	f.Invalid = {valid:!1};
}, {"gl-matrix":23}], 15:[function(a, f, l) {
	var b = a("./frame"), k = (a("./hand"), a("./pointable"), a("./finger"), a("underscore")), h = a("events").EventEmitter, c = function(a) {
		this.type = a.type;
		this.state = a.state;
	};
	l.chooseProtocol = function(a) {
		var b;
		switch(a.version) {
			case 1:
			;
			case 2:
			;
			case 3:
			;
			case 4:
			;
			case 5:
			;
			case 6:
				b = e(a);
				b.sendBackground = function(a, c) {
					a.send(b.encode({background:c}));
				};
				b.sendFocused = function(a, c) {
					a.send(b.encode({focused:c}));
				};
				b.sendOptimizeHMD = function(a, c) {
					a.send(b.encode({optimizeHMD:c}));
				};
				break;
			default:
				throw "unrecognized version";;
		}
		return b;
	};
	var e = l.JSONProtocol = function(a) {
		var e = function(a) {
			if (a.event) {
				return new c(a.event);
			}
			e.emit("beforeFrameCreated", a);
			var g = new b(a);
			return e.emit("afterFrameCreated", g, a), g;
		};
		return e.encode = function(a) {
			return JSON.stringify(a);
		}, e.version = a.version, e.serviceVersion = a.serviceVersion, e.versionLong = "Version " + a.version, e.type = "protocol", k.extend(e, h.prototype), e;
	};
}, {"./finger":7, "./frame":8, "./hand":10, "./pointable":14, events:21, underscore:24}], 16:[function(a, f, l) {
	l.UI = {Region:a("./ui/region"), Cursor:a("./ui/cursor")};
}, {"./ui/cursor":17, "./ui/region":18}], 17:[function(a, f) {
	f.exports = function() {
		return function(a) {
			var b = a.pointables.sort(function(a, b) {
				return a.z - b.z;
			})[0];
			return b && b.valid && (a.cursorPosition = b.tipPosition), a;
		};
	};
}, {}], 18:[function(a, f) {
	var l = a("events").EventEmitter;
	a = a("underscore");
	var b = f.exports = function(a, b) {
		this.start = new Vector(a);
		this.end = new Vector(b);
		this.enteredFrame = null;
	};
	b.prototype.hasPointables = function(a) {
		for (var b = 0;b != a.pointables.length;b++) {
			var c = a.pointables[b].tipPosition;
			if (c.x >= this.start.x && c.x <= this.end.x && c.y >= this.start.y && c.y <= this.end.y && c.z >= this.start.z && c.z <= this.end.z) {
				return !0;
			}
		}
		return !1;
	};
	b.prototype.listener = function(a) {
		var b = this;
		return a && a.nearThreshold && this.setupNearRegion(a.nearThreshold), function(a) {
			return b.updatePosition(a);
		};
	};
	b.prototype.clipper = function() {
		var a = this;
		return function(b) {
			return a.updatePosition(b), a.enteredFrame ? b : null;
		};
	};
	b.prototype.setupNearRegion = function(a) {
		a = this.nearRegion = new b([this.start.x - a, this.start.y - a, this.start.z - a], [this.end.x + a, this.end.y + a, this.end.z + a]);
		var h = this;
		a.on("enter", function(a) {
			h.emit("near", a);
		});
		a.on("exit", function(a) {
			h.emit("far", a);
		});
		h.on("exit", function(a) {
			h.emit("near", a);
		});
	};
	b.prototype.updatePosition = function(a) {
		return this.nearRegion && this.nearRegion.updatePosition(a), this.hasPointables(a) && null == this.enteredFrame ? (this.enteredFrame = a, this.emit("enter", this.enteredFrame)) : this.hasPointables(a) || null == this.enteredFrame || (this.enteredFrame = null, this.emit("exit", this.enteredFrame)), a;
	};
	b.prototype.normalize = function(a) {
		return new Vector([(a.x - this.start.x) / (this.end.x - this.start.x), (a.y - this.start.y) / (this.end.y - this.start.y), (a.z - this.start.z) / (this.end.z - this.start.z)]);
	};
	b.prototype.mapToXY = function(a, b, c) {
		a = this.normalize(a);
		var e = a.x, g = a.y;
		return 1 < e ? e = 1 : -1 > e && (e = -1), 1 < g ? g = 1 : -1 > g && (g = -1), [(e + 1) / 2 * b, (1 - g) / 2 * c, a.z];
	};
	a.extend(b.prototype, l.prototype);
}, {events:21, underscore:24}], 19:[function(a, f) {
	f.exports = {full:"0.6.4", major:0, minor:6, dot:4};
}, {}], 20:[function() {
}, {}], 21:[function(a, f, l) {
	a = a("__browserify_process");
	a.EventEmitter || (a.EventEmitter = function() {
	});
	l = l.EventEmitter = a.EventEmitter;
	var b = "function" == typeof Array.isArray ? Array.isArray : function(a) {
		return "[object Array]" === Object.prototype.toString.call(a);
	};
	l.prototype.setMaxListeners = function(a) {
		this._events || (this._events = {});
		this._events.maxListeners = a;
	};
	l.prototype.emit = function(a) {
		if ("error" === a && (!this._events || !this._events.error || b(this._events.error) && !this._events.error.length)) {
			throw arguments[1] instanceof Error ? arguments[1] : Error("Uncaught, unspecified 'error' event.");
		}
		if (!this._events) {
			return !1;
		}
		var h = this._events[a];
		if (!h) {
			return !1;
		}
		if ("function" == typeof h) {
			switch(arguments.length) {
				case 1:
					h.call(this);
					break;
				case 2:
					h.call(this, arguments[1]);
					break;
				case 3:
					h.call(this, arguments[1], arguments[2]);
					break;
				default:
					var c = Array.prototype.slice.call(arguments, 1);
					h.apply(this, c);
			}
			return !0;
		}
		if (b(h)) {
			for (var c = Array.prototype.slice.call(arguments, 1), h = h.slice(), e = 0, g = h.length;g > e;e++) {
				h[e].apply(this, c);
			}
			return !0;
		}
		return !1;
	};
	l.prototype.addListener = function(a, h) {
		if ("function" != typeof h) {
			throw Error("addListener only takes instances of Function");
		}
		if (this._events || (this._events = {}), this.emit("newListener", a, h), this._events[a]) {
			if (b(this._events[a])) {
				if (!this._events[a].warned) {
					var c;
					(c = void 0 !== this._events.maxListeners ? this._events.maxListeners : 10) && 0 < c && this._events[a].length > c && (this._events[a].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[a].length), console.trace());
				}
				this._events[a].push(h);
			} else {
				this._events[a] = [this._events[a], h];
			}
		} else {
			this._events[a] = h;
		}
		return this;
	};
	l.prototype.on = l.prototype.addListener;
	l.prototype.once = function(a, b) {
		var c = this;
		return c.on(a, function g() {
			c.removeListener(a, g);
			b.apply(this, arguments);
		}), this;
	};
	l.prototype.removeListener = function(a, h) {
		if ("function" != typeof h) {
			throw Error("removeListener only takes instances of Function");
		}
		if (!this._events || !this._events[a]) {
			return this;
		}
		var c = this._events[a];
		if (b(c)) {
			a: {
				if (c.indexOf) {
					h = c.indexOf(h);
				} else {
					for (var e = 0;e < c.length;e++) {
						if (h === c[e]) {
							h = e;
							break a;
						}
					}
					h = -1;
				}
			}
			if (0 > h) {
				return this;
			}
			c.splice(h, 1);
			0 == c.length && delete this._events[a];
		} else {
			this._events[a] === h && delete this._events[a];
		}
		return this;
	};
	l.prototype.removeAllListeners = function(a) {
		return 0 === arguments.length ? (this._events = {}, this) : (a && this._events && this._events[a] && (this._events[a] = null), this);
	};
	l.prototype.listeners = function(a) {
		return this._events || (this._events = {}), this._events[a] || (this._events[a] = []), b(this._events[a]) || (this._events[a] = [this._events[a]]), this._events[a];
	};
	l.listenerCount = function(a, b) {
		return a._events && a._events[b] ? "function" == typeof a._events[b] ? 1 : a._events[b].length : 0;
	};
}, {__browserify_process:22}], 22:[function(a, f) {
	a = f.exports = {};
	a.nextTick = function() {
		if ("undefined" != typeof window && window.setImmediate) {
			return function(a) {
				return window.setImmediate(a);
			};
		}
		if ("undefined" != typeof window && window.postMessage && window.addEventListener) {
			var a = [];
			return window.addEventListener("message", function(b) {
				var k = b.source;
				(k === window || null === k) && "process-tick" === b.data && (b.stopPropagation(), 0 < a.length) && a.shift()();
			}, !0), function(b) {
				a.push(b);
				window.postMessage("process-tick", "*");
			};
		}
		return function(a) {
			setTimeout(a, 0);
		};
	}();
	a.title = "browser";
	a.browser = !0;
	a.env = {};
	a.argv = [];
	a.binding = function() {
		throw Error("process.binding is not supported");
	};
	a.cwd = function() {
		return "/";
	};
	a.chdir = function() {
		throw Error("process.chdir is not supported");
	};
}, {}], 23:[function(a, f, l) {
	!function(a) {
		var b;
		"undefined" == typeof l ? "function" == typeof define && "object" == typeof define.amd && define.amd ? (b = {}, define(function() {
			return b;
		})) : b = "undefined" != typeof window ? window : a : b = l;
		(function(a) {
			if (!b) {
				var b = 1E-6
			}
			if (!e) {
				var e = "undefined" != typeof Float32Array ? Float32Array : Array
			}
			if (!g) {
				var g = Math.random
			}
			var h = {setMatrixArrayType:function(a) {
				e = a;
			}};
			"undefined" != typeof a && (a.glMatrix = h);
			var k = Math.PI / 180;
			h.toRadian = function(a) {
				return a * k;
			};
			var f = {create:function() {
				var a = new e(2);
				return a[0] = 0, a[1] = 0, a;
			}, clone:function(a) {
				var b = new e(2);
				return b[0] = a[0], b[1] = a[1], b;
			}, fromValues:function(a, b) {
				var c = new e(2);
				return c[0] = a, c[1] = b, c;
			}, copy:function(a, b) {
				return a[0] = b[0], a[1] = b[1], a;
			}, set:function(a, b, c) {
				return a[0] = b, a[1] = c, a;
			}, add:function(a, b, c) {
				return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a;
			}, subtract:function(a, b, c) {
				return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a;
			}};
			f.sub = f.subtract;
			f.multiply = function(a, b, c) {
				return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a;
			};
			f.mul = f.multiply;
			f.divide = function(a, b, c) {
				return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a;
			};
			f.div = f.divide;
			f.min = function(a, b, c) {
				return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a;
			};
			f.max = function(a, b, c) {
				return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a;
			};
			f.scale = function(a, b, c) {
				return a[0] = b[0] * c, a[1] = b[1] * c, a;
			};
			f.scaleAndAdd = function(a, b, c, e) {
				return a[0] = b[0] + c[0] * e, a[1] = b[1] + c[1] * e, a;
			};
			f.distance = function(a, b) {
				var c = b[0] - a[0];
				a = b[1] - a[1];
				return Math.sqrt(c * c + a * a);
			};
			f.dist = f.distance;
			f.squaredDistance = function(a, b) {
				var c = b[0] - a[0];
				a = b[1] - a[1];
				return c * c + a * a;
			};
			f.sqrDist = f.squaredDistance;
			f.length = function(a) {
				var b = a[0];
				a = a[1];
				return Math.sqrt(b * b + a * a);
			};
			f.len = f.length;
			f.squaredLength = function(a) {
				var b = a[0];
				a = a[1];
				return b * b + a * a;
			};
			f.sqrLen = f.squaredLength;
			f.negate = function(a, b) {
				return a[0] = -b[0], a[1] = -b[1], a;
			};
			f.normalize = function(a, b) {
				var c = b[0], e = b[1], c = c * c + e * e;
				return 0 < c && (c = 1 / Math.sqrt(c), a[0] = b[0] * c, a[1] = b[1] * c), a;
			};
			f.dot = function(a, b) {
				return a[0] * b[0] + a[1] * b[1];
			};
			f.cross = function(a, b, c) {
				b = b[0] * c[1] - b[1] * c[0];
				return a[0] = a[1] = 0, a[2] = b, a;
			};
			f.lerp = function(a, b, c, e) {
				var g = b[0];
				b = b[1];
				return a[0] = g + e * (c[0] - g), a[1] = b + e * (c[1] - b), a;
			};
			f.random = function(a, b) {
				b = b || 1;
				var c = 2 * g() * Math.PI;
				return a[0] = Math.cos(c) * b, a[1] = Math.sin(c) * b, a;
			};
			f.transformMat2 = function(a, b, c) {
				var e = b[0];
				b = b[1];
				return a[0] = c[0] * e + c[2] * b, a[1] = c[1] * e + c[3] * b, a;
			};
			f.transformMat2d = function(a, b, c) {
				var e = b[0];
				b = b[1];
				return a[0] = c[0] * e + c[2] * b + c[4], a[1] = c[1] * e + c[3] * b + c[5], a;
			};
			f.transformMat3 = function(a, b, c) {
				var e = b[0];
				b = b[1];
				return a[0] = c[0] * e + c[3] * b + c[6], a[1] = c[1] * e + c[4] * b + c[7], a;
			};
			f.transformMat4 = function(a, b, c) {
				var e = b[0];
				b = b[1];
				return a[0] = c[0] * e + c[4] * b + c[12], a[1] = c[1] * e + c[5] * b + c[13], a;
			};
			f.forEach = function() {
				var a = f.create();
				return function(b, c, e, g, m, h) {
					c || (c = 2);
					e || (e = 0);
					for (g = g ? Math.min(g * c + e, b.length) : b.length;g > e;e += c) {
						a[0] = b[e], a[1] = b[e + 1], m(a, a, h), b[e] = a[0], b[e + 1] = a[1];
					}
					return b;
				};
			}();
			f.str = function(a) {
				return "vec2(" + a[0] + ", " + a[1] + ")";
			};
			"undefined" != typeof a && (a.vec2 = f);
			var p = {create:function() {
				var a = new e(3);
				return a[0] = 0, a[1] = 0, a[2] = 0, a;
			}, clone:function(a) {
				var b = new e(3);
				return b[0] = a[0], b[1] = a[1], b[2] = a[2], b;
			}, fromValues:function(a, b, c) {
				var g = new e(3);
				return g[0] = a, g[1] = b, g[2] = c, g;
			}, copy:function(a, b) {
				return a[0] = b[0], a[1] = b[1], a[2] = b[2], a;
			}, set:function(a, b, c, e) {
				return a[0] = b, a[1] = c, a[2] = e, a;
			}, add:function(a, b, c) {
				return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a[2] = b[2] + c[2], a;
			}, subtract:function(a, b, c) {
				return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a[2] = b[2] - c[2], a;
			}};
			p.sub = p.subtract;
			p.multiply = function(a, b, c) {
				return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a[2] = b[2] * c[2], a;
			};
			p.mul = p.multiply;
			p.divide = function(a, b, c) {
				return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a[2] = b[2] / c[2], a;
			};
			p.div = p.divide;
			p.min = function(a, b, c) {
				return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a[2] = Math.min(b[2], c[2]), a;
			};
			p.max = function(a, b, c) {
				return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a[2] = Math.max(b[2], c[2]), a;
			};
			p.scale = function(a, b, c) {
				return a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a;
			};
			p.scaleAndAdd = function(a, b, c, e) {
				return a[0] = b[0] + c[0] * e, a[1] = b[1] + c[1] * e, a[2] = b[2] + c[2] * e, a;
			};
			p.distance = function(a, b) {
				var c = b[0] - a[0], e = b[1] - a[1];
				a = b[2] - a[2];
				return Math.sqrt(c * c + e * e + a * a);
			};
			p.dist = p.distance;
			p.squaredDistance = function(a, b) {
				var c = b[0] - a[0], e = b[1] - a[1];
				a = b[2] - a[2];
				return c * c + e * e + a * a;
			};
			p.sqrDist = p.squaredDistance;
			p.length = function(a) {
				var b = a[0], c = a[1];
				a = a[2];
				return Math.sqrt(b * b + c * c + a * a);
			};
			p.len = p.length;
			p.squaredLength = function(a) {
				var b = a[0], c = a[1];
				a = a[2];
				return b * b + c * c + a * a;
			};
			p.sqrLen = p.squaredLength;
			p.negate = function(a, b) {
				return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a;
			};
			p.normalize = function(a, b) {
				var c = b[0], e = b[1], g = b[2], c = c * c + e * e + g * g;
				return 0 < c && (c = 1 / Math.sqrt(c), a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c), a;
			};
			p.dot = function(a, b) {
				return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
			};
			p.cross = function(a, b, c) {
				var e = b[0], g = b[1];
				b = b[2];
				var m = c[0], h = c[1];
				c = c[2];
				return a[0] = g * c - b * h, a[1] = b * m - e * c, a[2] = e * h - g * m, a;
			};
			p.lerp = function(a, b, c, e) {
				var g = b[0], m = b[1];
				b = b[2];
				return a[0] = g + e * (c[0] - g), a[1] = m + e * (c[1] - m), a[2] = b + e * (c[2] - b), a;
			};
			p.random = function(a, b) {
				b = b || 1;
				var c = 2 * g() * Math.PI, e = 2 * g() - 1, m = Math.sqrt(1 - e * e) * b;
				return a[0] = Math.cos(c) * m, a[1] = Math.sin(c) * m, a[2] = e * b, a;
			};
			p.transformMat4 = function(a, b, c) {
				var e = b[0], g = b[1];
				b = b[2];
				return a[0] = c[0] * e + c[4] * g + c[8] * b + c[12], a[1] = c[1] * e + c[5] * g + c[9] * b + c[13], a[2] = c[2] * e + c[6] * g + c[10] * b + c[14], a;
			};
			p.transformMat3 = function(a, b, c) {
				var e = b[0], g = b[1];
				b = b[2];
				return a[0] = e * c[0] + g * c[3] + b * c[6], a[1] = e * c[1] + g * c[4] + b * c[7], a[2] = e * c[2] + g * c[5] + b * c[8], a;
			};
			p.transformQuat = function(a, b, c) {
				var e = b[0], g = b[1], m = b[2];
				b = c[0];
				var h = c[1], k = c[2];
				c = c[3];
				var f = c * e + h * m - k * g, q = c * g + k * e - b * m, l = c * m + b * g - h * e, e = -b * e - h * g - k * m;
				return a[0] = f * c + e * -b + q * -k - l * -h, a[1] = q * c + e * -h + l * -b - f * -k, a[2] = l * c + e * -k + f * -h - q * -b, a;
			};
			p.rotateX = function(a, b, c, e) {
				var g = [], m = [];
				return g[0] = b[0] - c[0], g[1] = b[1] - c[1], g[2] = b[2] - c[2], m[0] = g[0], m[1] = g[1] * Math.cos(e) - g[2] * Math.sin(e), m[2] = g[1] * Math.sin(e) + g[2] * Math.cos(e), a[0] = m[0] + c[0], a[1] = m[1] + c[1], a[2] = m[2] + c[2], a;
			};
			p.rotateY = function(a, b, c, e) {
				var g = [], m = [];
				return g[0] = b[0] - c[0], g[1] = b[1] - c[1], g[2] = b[2] - c[2], m[0] = g[2] * Math.sin(e) + g[0] * Math.cos(e), m[1] = g[1], m[2] = g[2] * Math.cos(e) - g[0] * Math.sin(e), a[0] = m[0] + c[0], a[1] = m[1] + c[1], a[2] = m[2] + c[2], a;
			};
			p.rotateZ = function(a, b, c, e) {
				var g = [], m = [];
				return g[0] = b[0] - c[0], g[1] = b[1] - c[1], g[2] = b[2] - c[2], m[0] = g[0] * Math.cos(e) - g[1] * Math.sin(e), m[1] = g[0] * Math.sin(e) + g[1] * Math.cos(e), m[2] = g[2], a[0] = m[0] + c[0], a[1] = m[1] + c[1], a[2] = m[2] + c[2], a;
			};
			p.forEach = function() {
				var a = p.create();
				return function(b, c, e, g, m, h) {
					c || (c = 3);
					e || (e = 0);
					for (g = g ? Math.min(g * c + e, b.length) : b.length;g > e;e += c) {
						a[0] = b[e], a[1] = b[e + 1], a[2] = b[e + 2], m(a, a, h), b[e] = a[0], b[e + 1] = a[1], b[e + 2] = a[2];
					}
					return b;
				};
			}();
			p.str = function(a) {
				return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
			};
			"undefined" != typeof a && (a.vec3 = p);
			var l = {create:function() {
				var a = new e(4);
				return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 0, a;
			}, clone:function(a) {
				var b = new e(4);
				return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b;
			}, fromValues:function(a, b, c, g) {
				var m = new e(4);
				return m[0] = a, m[1] = b, m[2] = c, m[3] = g, m;
			}, copy:function(a, b) {
				return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a;
			}, set:function(a, b, c, e, g) {
				return a[0] = b, a[1] = c, a[2] = e, a[3] = g, a;
			}, add:function(a, b, c) {
				return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a[2] = b[2] + c[2], a[3] = b[3] + c[3], a;
			}, subtract:function(a, b, c) {
				return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a[2] = b[2] - c[2], a[3] = b[3] - c[3], a;
			}};
			l.sub = l.subtract;
			l.multiply = function(a, b, c) {
				return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a[2] = b[2] * c[2], a[3] = b[3] * c[3], a;
			};
			l.mul = l.multiply;
			l.divide = function(a, b, c) {
				return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a[2] = b[2] / c[2], a[3] = b[3] / c[3], a;
			};
			l.div = l.divide;
			l.min = function(a, b, c) {
				return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a[2] = Math.min(b[2], c[2]), a[3] = Math.min(b[3], c[3]), a;
			};
			l.max = function(a, b, c) {
				return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a[2] = Math.max(b[2], c[2]), a[3] = Math.max(b[3], c[3]), a;
			};
			l.scale = function(a, b, c) {
				return a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a[3] = b[3] * c, a;
			};
			l.scaleAndAdd = function(a, b, c, e) {
				return a[0] = b[0] + c[0] * e, a[1] = b[1] + c[1] * e, a[2] = b[2] + c[2] * e, a[3] = b[3] + c[3] * e, a;
			};
			l.distance = function(a, b) {
				var c = b[0] - a[0], e = b[1] - a[1], g = b[2] - a[2];
				a = b[3] - a[3];
				return Math.sqrt(c * c + e * e + g * g + a * a);
			};
			l.dist = l.distance;
			l.squaredDistance = function(a, b) {
				var c = b[0] - a[0], e = b[1] - a[1], g = b[2] - a[2];
				a = b[3] - a[3];
				return c * c + e * e + g * g + a * a;
			};
			l.sqrDist = l.squaredDistance;
			l.length = function(a) {
				var b = a[0], c = a[1], e = a[2];
				a = a[3];
				return Math.sqrt(b * b + c * c + e * e + a * a);
			};
			l.len = l.length;
			l.squaredLength = function(a) {
				var b = a[0], c = a[1], e = a[2];
				a = a[3];
				return b * b + c * c + e * e + a * a;
			};
			l.sqrLen = l.squaredLength;
			l.negate = function(a, b) {
				return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a[3] = -b[3], a;
			};
			l.normalize = function(a, b) {
				var c = b[0], e = b[1], g = b[2], h = b[3], c = c * c + e * e + g * g + h * h;
				return 0 < c && (c = 1 / Math.sqrt(c), a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a[3] = b[3] * c), a;
			};
			l.dot = function(a, b) {
				return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
			};
			l.lerp = function(a, b, c, e) {
				var g = b[0], h = b[1], m = b[2];
				b = b[3];
				return a[0] = g + e * (c[0] - g), a[1] = h + e * (c[1] - h), a[2] = m + e * (c[2] - m), a[3] = b + e * (c[3] - b), a;
			};
			l.random = function(a, b) {
				return b = b || 1, a[0] = g(), a[1] = g(), a[2] = g(), a[3] = g(), l.normalize(a, a), l.scale(a, a, b), a;
			};
			l.transformMat4 = function(a, b, c) {
				var e = b[0], g = b[1], h = b[2];
				b = b[3];
				return a[0] = c[0] * e + c[4] * g + c[8] * h + c[12] * b, a[1] = c[1] * e + c[5] * g + c[9] * h + c[13] * b, a[2] = c[2] * e + c[6] * g + c[10] * h + c[14] * b, a[3] = c[3] * e + c[7] * g + c[11] * h + c[15] * b, a;
			};
			l.transformQuat = function(a, b, c) {
				var e = b[0], g = b[1], h = b[2];
				b = c[0];
				var m = c[1], k = c[2];
				c = c[3];
				var f = c * e + m * h - k * g, q = c * g + k * e - b * h, l = c * h + b * g - m * e, e = -b * e - m * g - k * h;
				return a[0] = f * c + e * -b + q * -k - l * -m, a[1] = q * c + e * -m + l * -b - f * -k, a[2] = l * c + e * -k + f * -m - q * -b, a;
			};
			l.forEach = function() {
				var a = l.create();
				return function(b, c, e, g, h, m) {
					c || (c = 4);
					e || (e = 0);
					for (g = g ? Math.min(g * c + e, b.length) : b.length;g > e;e += c) {
						a[0] = b[e], a[1] = b[e + 1], a[2] = b[e + 2], a[3] = b[e + 3], h(a, a, m), b[e] = a[0], b[e + 1] = a[1], b[e + 2] = a[2], b[e + 3] = a[3];
					}
					return b;
				};
			}();
			l.str = function(a) {
				return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
			};
			"undefined" != typeof a && (a.vec4 = l);
			h = {create:function() {
				var a = new e(4);
				return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a;
			}, clone:function(a) {
				var b = new e(4);
				return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b;
			}, copy:function(a, b) {
				return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a;
			}, identity:function(a) {
				return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a;
			}, transpose:function(a, b) {
				if (a === b) {
					var c = b[1];
					a[1] = b[2];
					a[2] = c;
				} else {
					a[0] = b[0], a[1] = b[2], a[2] = b[1], a[3] = b[3];
				}
				return a;
			}, invert:function(a, b) {
				var c = b[0], e = b[1], g = b[2];
				b = b[3];
				var h = c * b - g * e;
				return h ? (h = 1 / h, a[0] = b * h, a[1] = -e * h, a[2] = -g * h, a[3] = c * h, a) : null;
			}, adjoint:function(a, b) {
				var c = b[0];
				return a[0] = b[3], a[1] = -b[1], a[2] = -b[2], a[3] = c, a;
			}, determinant:function(a) {
				return a[0] * a[3] - a[2] * a[1];
			}, multiply:function(a, b, c) {
				var e = b[0], g = b[1], h = b[2];
				b = b[3];
				var m = c[0], k = c[1], f = c[2];
				c = c[3];
				return a[0] = e * m + h * k, a[1] = g * m + b * k, a[2] = e * f + h * c, a[3] = g * f + b * c, a;
			}};
			h.mul = h.multiply;
			h.rotate = function(a, b, c) {
				var e = b[0], g = b[1], h = b[2];
				b = b[3];
				var m = Math.sin(c);
				c = Math.cos(c);
				return a[0] = e * c + h * m, a[1] = g * c + b * m, a[2] = e * -m + h * c, a[3] = g * -m + b * c, a;
			};
			h.scale = function(a, b, c) {
				var e = b[1], g = b[2], h = b[3], m = c[0];
				c = c[1];
				return a[0] = b[0] * m, a[1] = e * m, a[2] = g * c, a[3] = h * c, a;
			};
			h.str = function(a) {
				return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
			};
			h.frob = function(a) {
				return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
			};
			h.LDU = function(a, b, c, e) {
				return a[2] = e[2] / e[0], c[0] = e[0], c[1] = e[1], c[3] = e[3] - a[2] * c[1], [a, b, c];
			};
			"undefined" != typeof a && (a.mat2 = h);
			h = {create:function() {
				var a = new e(6);
				return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a[4] = 0, a[5] = 0, a;
			}, clone:function(a) {
				var b = new e(6);
				return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b;
			}, copy:function(a, b) {
				return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], a;
			}, identity:function(a) {
				return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a[4] = 0, a[5] = 0, a;
			}, invert:function(a, b) {
				var c = b[0], e = b[1], g = b[2], h = b[3], m = b[4];
				b = b[5];
				var k = c * h - e * g;
				return k ? (k = 1 / k, a[0] = h * k, a[1] = -e * k, a[2] = -g * k, a[3] = c * k, a[4] = (g * b - h * m) * k, a[5] = (e * m - c * b) * k, a) : null;
			}, determinant:function(a) {
				return a[0] * a[3] - a[1] * a[2];
			}, multiply:function(a, b, c) {
				var e = b[0], g = b[1], h = b[2], m = b[3], k = b[4];
				b = b[5];
				var f = c[0], q = c[1], l = c[2], p = c[3], r = c[4];
				c = c[5];
				return a[0] = e * f + h * q, a[1] = g * f + m * q, a[2] = e * l + h * p, a[3] = g * l + m * p, a[4] = e * r + h * c + k, a[5] = g * r + m * c + b, a;
			}};
			h.mul = h.multiply;
			h.rotate = function(a, b, c) {
				var e = b[0], g = b[1], h = b[2], m = b[3], k = b[4];
				b = b[5];
				var f = Math.sin(c);
				c = Math.cos(c);
				return a[0] = e * c + h * f, a[1] = g * c + m * f, a[2] = e * -f + h * c, a[3] = g * -f + m * c, a[4] = k, a[5] = b, a;
			};
			h.scale = function(a, b, c) {
				var e = b[1], g = b[2], h = b[3], m = b[4], k = b[5], f = c[0];
				c = c[1];
				return a[0] = b[0] * f, a[1] = e * f, a[2] = g * c, a[3] = h * c, a[4] = m, a[5] = k, a;
			};
			h.translate = function(a, b, c) {
				var e = b[0], g = b[1], h = b[2], k = b[3], m = b[4];
				b = b[5];
				var f = c[0];
				c = c[1];
				return a[0] = e, a[1] = g, a[2] = h, a[3] = k, a[4] = e * f + h * c + m, a[5] = g * f + k * c + b, a;
			};
			h.str = function(a) {
				return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
			};
			h.frob = function(a) {
				return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
			};
			"undefined" != typeof a && (a.mat2d = h);
			var v = {create:function() {
				var a = new e(9);
				return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 1, a[5] = 0, a[6] = 0, a[7] = 0, a[8] = 1, a;
			}, fromMat4:function(a, b) {
				return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[4], a[4] = b[5], a[5] = b[6], a[6] = b[8], a[7] = b[9], a[8] = b[10], a;
			}, clone:function(a) {
				var b = new e(9);
				return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], b;
			}, copy:function(a, b) {
				return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[8] = b[8], a;
			}, identity:function(a) {
				return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 1, a[5] = 0, a[6] = 0, a[7] = 0, a[8] = 1, a;
			}, transpose:function(a, b) {
				if (a === b) {
					var c = b[1], e = b[2], g = b[5];
					a[1] = b[3];
					a[2] = b[6];
					a[3] = c;
					a[5] = b[7];
					a[6] = e;
					a[7] = g;
				} else {
					a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], a[6] = b[2], a[7] = b[5], a[8] = b[8];
				}
				return a;
			}, invert:function(a, b) {
				var c = b[0], e = b[1], g = b[2], h = b[3], k = b[4], f = b[5], m = b[6], q = b[7];
				b = b[8];
				var l = b * k - f * q, p = -b * h + f * m, r = q * h - k * m, u = c * l + e * p + g * r;
				return u ? (u = 1 / u, a[0] = l * u, a[1] = (-b * e + g * q) * u, a[2] = (f * e - g * k) * u, a[3] = p * u, a[4] = (b * c - g * m) * u, a[5] = (-f * c + g * h) * u, a[6] = r * u, a[7] = (-q * c + e * m) * u, a[8] = (k * c - e * h) * u, a) : null;
			}, adjoint:function(a, b) {
				var c = b[0], e = b[1], g = b[2], h = b[3], k = b[4], f = b[5], m = b[6], q = b[7];
				b = b[8];
				return a[0] = k * b - f * q, a[1] = g * q - e * b, a[2] = e * f - g * k, a[3] = f * m - h * b, a[4] = c * b - g * m, a[5] = g * h - c * f, a[6] = h * q - k * m, a[7] = e * m - c * q, a[8] = c * k - e * h, a;
			}, determinant:function(a) {
				var b = a[3], c = a[4], e = a[5], g = a[6], h = a[7], k = a[8];
				return a[0] * (k * c - e * h) + a[1] * (-k * b + e * g) + a[2] * (h * b - c * g);
			}, multiply:function(a, b, c) {
				var e = b[0], g = b[1], h = b[2], k = b[3], f = b[4], m = b[5], q = b[6], l = b[7];
				b = b[8];
				var p = c[0], r = c[1], u = c[2], w = c[3], t = c[4], v = c[5], y = c[6], x = c[7];
				c = c[8];
				return a[0] = p * e + r * k + u * q, a[1] = p * g + r * f + u * l, a[2] = p * h + r * m + u * b, a[3] = w * e + t * k + v * q, a[4] = w * g + t * f + v * l, a[5] = w * h + t * m + v * b, a[6] = y * e + x * k + c * q, a[7] = y * g + x * f + c * l, a[8] = y * h + x * m + c * b, a;
			}};
			v.mul = v.multiply;
			v.translate = function(a, b, c) {
				var e = b[0], g = b[1], h = b[2], k = b[3], f = b[4], m = b[5], q = b[6], l = b[7];
				b = b[8];
				var p = c[0];
				c = c[1];
				return a[0] = e, a[1] = g, a[2] = h, a[3] = k, a[4] = f, a[5] = m, a[6] = p * e + c * k + q, a[7] = p * g + c * f + l, a[8] = p * h + c * m + b, a;
			};
			v.rotate = function(a, b, c) {
				var e = b[0], g = b[1], h = b[2], k = b[3], f = b[4], m = b[5], q = b[6], l = b[7];
				b = b[8];
				var p = Math.sin(c);
				c = Math.cos(c);
				return a[0] = c * e + p * k, a[1] = c * g + p * f, a[2] = c * h + p * m, a[3] = c * k - p * e, a[4] = c * f - p * g, a[5] = c * m - p * h, a[6] = q, a[7] = l, a[8] = b, a;
			};
			v.scale = function(a, b, c) {
				var e = c[0];
				c = c[1];
				return a[0] = e * b[0], a[1] = e * b[1], a[2] = e * b[2], a[3] = c * b[3], a[4] = c * b[4], a[5] = c * b[5], a[6] = b[6], a[7] = b[7], a[8] = b[8], a;
			};
			v.fromMat2d = function(a, b) {
				return a[0] = b[0], a[1] = b[1], a[2] = 0, a[3] = b[2], a[4] = b[3], a[5] = 0, a[6] = b[4], a[7] = b[5], a[8] = 1, a;
			};
			v.fromQuat = function(a, b) {
				var c = b[0], e = b[1], g = b[2];
				b = b[3];
				var h = c + c, k = e + e, f = g + g, c = c * h, m = e * h, e = e * k, q = g * h, l = g * k, g = g * f, h = b * h, k = b * k;
				b *= f;
				return a[0] = 1 - e - g, a[3] = m - b, a[6] = q + k, a[1] = m + b, a[4] = 1 - c - g, a[7] = l - h, a[2] = q - k, a[5] = l + h, a[8] = 1 - c - e, a;
			};
			v.normalFromMat4 = function(a, b) {
				var c = b[0], e = b[1], g = b[2], h = b[3], k = b[4], f = b[5], m = b[6], q = b[7], l = b[8], p = b[9], r = b[10], u = b[11], w = b[12], t = b[13], v = b[14];
				b = b[15];
				var y = c * f - e * k, x = c * m - g * k, S = c * q - h * k, V = e * m - g * f, L = e * q - h * f, W = g * q - h * m, ia = l * t - p * w, va = l * v - r * w, l = l * b - u * w, T = p * v - r * t, p = p * b - u * t, r = r * b - u * v;
				return (u = y * r - x * p + S * T + V * l - L * va + W * ia) ? (u = 1 / u, a[0] = (f * r - m * p + q * T) * u, a[1] = (m * l - k * r - q * va) * u, a[2] = (k * p - f * l + q * ia) * u, a[3] = (g * p - e * r - h * T) * u, a[4] = (c * r - g * l + h * va) * u, a[5] = (e * l - c * p - h * ia) * u, a[6] = (t * W - v * L + b * V) * u, a[7] = (v * S - w * W - b * x) * u, a[8] = (w * L - t * S + b * y) * u, a) : null;
			};
			v.str = function(a) {
				return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
			};
			v.frob = function(a) {
				return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
			};
			"undefined" != typeof a && (a.mat3 = v);
			var y = {create:function() {
				var a = new e(16);
				return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
			}, clone:function(a) {
				var b = new e(16);
				return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], b[9] = a[9], b[10] = a[10], b[11] = a[11], b[12] = a[12], b[13] = a[13], b[14] = a[14], b[15] = a[15], b;
			}, copy:function(a, b) {
				return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[8] = b[8], a[9] = b[9], a[10] = b[10], a[11] = b[11], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15], a;
			}, identity:function(a) {
				return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
			}, transpose:function(a, b) {
				if (a === b) {
					var c = b[1], e = b[2], g = b[3], h = b[6], k = b[7], f = b[11];
					a[1] = b[4];
					a[2] = b[8];
					a[3] = b[12];
					a[4] = c;
					a[6] = b[9];
					a[7] = b[13];
					a[8] = e;
					a[9] = h;
					a[11] = b[14];
					a[12] = g;
					a[13] = k;
					a[14] = f;
				} else {
					a[0] = b[0], a[1] = b[4], a[2] = b[8], a[3] = b[12], a[4] = b[1], a[5] = b[5], a[6] = b[9], a[7] = b[13], a[8] = b[2], a[9] = b[6], a[10] = b[10], a[11] = b[14], a[12] = b[3], a[13] = b[7], a[14] = b[11], a[15] = b[15];
				}
				return a;
			}, invert:function(a, b) {
				var c = b[0], e = b[1], g = b[2], h = b[3], k = b[4], f = b[5], m = b[6], q = b[7], l = b[8], p = b[9], r = b[10], w = b[11], u = b[12], t = b[13], v = b[14];
				b = b[15];
				var y = c * f - e * k, x = c * m - g * k, S = c * q - h * k, V = e * m - g * f, L = e * q - h * f, W = g * q - h * m, ia = l * t - p * u, va = l * v - r * u, T = l * b - w * u, pa = p * v - r * t, ra = p * b - w * t, qa = r * b - w * v, ea = y * qa - x * ra + S * pa + V * T - L * va + W * ia;
				return ea ? (ea = 1 / ea, a[0] = (f * qa - m * ra + q * pa) * ea, a[1] = (g * ra - e * qa - h * pa) * ea, a[2] = (t * W - v * L + b * V) * ea, a[3] = (r * L - p * W - w * V) * ea, a[4] = (m * T - k * qa - q * va) * ea, a[5] = (c * qa - g * T + h * va) * ea, a[6] = (v * S - u * W - b * x) * ea, a[7] = (l * W - r * S + w * x) * ea, a[8] = (k * ra - f * T + q * ia) * ea, a[9] = (e * T - c * ra - h * ia) * ea, a[10] = (u * L - t * S + b * y) * ea, a[11] = (p * S - l * L - w * y) * ea, a[12] = 
				(f * va - k * pa - m * ia) * ea, a[13] = (c * pa - e * va + g * ia) * ea, a[14] = (t * x - u * V - v * y) * ea, a[15] = (l * V - p * x + r * y) * ea, a) : null;
			}, adjoint:function(a, b) {
				var c = b[0], e = b[1], g = b[2], h = b[3], k = b[4], f = b[5], m = b[6], q = b[7], l = b[8], p = b[9], r = b[10], w = b[11], u = b[12], t = b[13], v = b[14];
				b = b[15];
				return a[0] = f * (r * b - w * v) - p * (m * b - q * v) + t * (m * w - q * r), a[1] = -(e * (r * b - w * v) - p * (g * b - h * v) + t * (g * w - h * r)), a[2] = e * (m * b - q * v) - f * (g * b - h * v) + t * (g * q - h * m), a[3] = -(e * (m * w - q * r) - f * (g * w - h * r) + p * (g * q - h * m)), a[4] = -(k * (r * b - w * v) - l * (m * b - q * v) + u * (m * w - q * r)), a[5] = c * (r * b - w * v) - l * (g * b - h * v) + u * (g * w - h * r), a[6] = -(c * (m * b - q * v) - k * (g * b - h * 
				v) + u * (g * q - h * m)), a[7] = c * (m * w - q * r) - k * (g * w - h * r) + l * (g * q - h * m), a[8] = k * (p * b - w * t) - l * (f * b - q * t) + u * (f * w - q * p), a[9] = -(c * (p * b - w * t) - l * (e * b - h * t) + u * (e * w - h * p)), a[10] = c * (f * b - q * t) - k * (e * b - h * t) + u * (e * q - h * f), a[11] = -(c * (f * w - q * p) - k * (e * w - h * p) + l * (e * q - h * f)), a[12] = -(k * (p * v - r * t) - l * (f * v - m * t) + u * (f * r - m * p)), a[13] = c * (p * v - r * 
				t) - l * (e * v - g * t) + u * (e * r - g * p), a[14] = -(c * (f * v - m * t) - k * (e * v - g * t) + u * (e * m - g * f)), a[15] = c * (f * r - m * p) - k * (e * r - g * p) + l * (e * m - g * f), a;
			}, determinant:function(a) {
				var b = a[0], c = a[1], e = a[2], g = a[3], h = a[4], k = a[5], f = a[6], m = a[7], q = a[8], l = a[9], p = a[10], r = a[11], w = a[12], t = a[13], v = a[14];
				a = a[15];
				return (b * k - c * h) * (p * a - r * v) - (b * f - e * h) * (l * a - r * t) + (b * m - g * h) * (l * v - p * t) + (c * f - e * k) * (q * a - r * w) - (c * m - g * k) * (q * v - p * w) + (e * m - g * f) * (q * t - l * w);
			}, multiply:function(a, b, c) {
				var e = b[0], g = b[1], h = b[2], k = b[3], f = b[4], m = b[5], q = b[6], l = b[7], p = b[8], r = b[9], w = b[10], u = b[11], t = b[12], v = b[13], y = b[14];
				b = b[15];
				var x = c[0], B = c[1], V = c[2], L = c[3];
				return a[0] = x * e + B * f + V * p + L * t, a[1] = x * g + B * m + V * r + L * v, a[2] = x * h + B * q + V * w + L * y, a[3] = x * k + B * l + V * u + L * b, x = c[4], B = c[5], V = c[6], L = c[7], a[4] = x * e + B * f + V * p + L * t, a[5] = x * g + B * m + V * r + L * v, a[6] = x * h + B * q + V * w + L * y, a[7] = x * k + B * l + V * u + L * b, x = c[8], B = c[9], V = c[10], L = c[11], a[8] = x * e + B * f + V * p + L * t, a[9] = x * g + B * m + V * r + L * v, a[10] = x * h + B * q + 
				V * w + L * y, a[11] = x * k + B * l + V * u + L * b, x = c[12], B = c[13], V = c[14], L = c[15], a[12] = x * e + B * f + V * p + L * t, a[13] = x * g + B * m + V * r + L * v, a[14] = x * h + B * q + V * w + L * y, a[15] = x * k + B * l + V * u + L * b, a;
			}};
			y.mul = y.multiply;
			y.translate = function(a, b, c) {
				var e, g, h, k, f, m, q, l, p, r, w, u, t = c[0], v = c[1];
				c = c[2];
				return b === a ? (a[12] = b[0] * t + b[4] * v + b[8] * c + b[12], a[13] = b[1] * t + b[5] * v + b[9] * c + b[13], a[14] = b[2] * t + b[6] * v + b[10] * c + b[14], a[15] = b[3] * t + b[7] * v + b[11] * c + b[15]) : (e = b[0], g = b[1], h = b[2], k = b[3], f = b[4], m = b[5], q = b[6], l = b[7], p = b[8], r = b[9], w = b[10], u = b[11], a[0] = e, a[1] = g, a[2] = h, a[3] = k, a[4] = f, a[5] = m, a[6] = q, a[7] = l, a[8] = p, a[9] = r, a[10] = w, a[11] = u, a[12] = e * t + f * v + p * c + b[12], 
				a[13] = g * t + m * v + r * c + b[13], a[14] = h * t + q * v + w * c + b[14], a[15] = k * t + l * v + u * c + b[15]), a;
			};
			y.scale = function(a, b, c) {
				var e = c[0], g = c[1];
				c = c[2];
				return a[0] = b[0] * e, a[1] = b[1] * e, a[2] = b[2] * e, a[3] = b[3] * e, a[4] = b[4] * g, a[5] = b[5] * g, a[6] = b[6] * g, a[7] = b[7] * g, a[8] = b[8] * c, a[9] = b[9] * c, a[10] = b[10] * c, a[11] = b[11] * c, a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15], a;
			};
			y.rotate = function(a, c, e, g) {
				var h, k, f, m, q, l, p, r, w, t, u, v, y, x, B, A, V, L, W, ia, va, T, pa, ra, qa = g[0], ea = g[1];
				g = g[2];
				var Z = Math.sqrt(qa * qa + ea * ea + g * g);
				return Math.abs(Z) < b ? null : (Z = 1 / Z, qa *= Z, ea *= Z, g *= Z, h = Math.sin(e), k = Math.cos(e), f = 1 - k, m = c[0], q = c[1], l = c[2], p = c[3], r = c[4], w = c[5], t = c[6], u = c[7], v = c[8], y = c[9], x = c[10], B = c[11], A = qa * qa * f + k, V = ea * qa * f + g * h, L = g * qa * f - ea * h, W = qa * ea * f - g * h, ia = ea * ea * f + k, va = g * ea * f + qa * h, T = qa * g * f + ea * h, pa = ea * g * f - qa * h, ra = g * g * f + k, a[0] = m * A + r * V + v * L, a[1] = q * 
				A + w * V + y * L, a[2] = l * A + t * V + x * L, a[3] = p * A + u * V + B * L, a[4] = m * W + r * ia + v * va, a[5] = q * W + w * ia + y * va, a[6] = l * W + t * ia + x * va, a[7] = p * W + u * ia + B * va, a[8] = m * T + r * pa + v * ra, a[9] = q * T + w * pa + y * ra, a[10] = l * T + t * pa + x * ra, a[11] = p * T + u * pa + B * ra, c !== a && (a[12] = c[12], a[13] = c[13], a[14] = c[14], a[15] = c[15]), a);
			};
			y.rotateX = function(a, b, c) {
				var e = Math.sin(c);
				c = Math.cos(c);
				var g = b[4], h = b[5], k = b[6], f = b[7], m = b[8], q = b[9], l = b[10], p = b[11];
				return b !== a && (a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[4] = g * c + m * e, a[5] = h * c + q * e, a[6] = k * c + l * e, a[7] = f * c + p * e, a[8] = m * c - g * e, a[9] = q * c - h * e, a[10] = l * c - k * e, a[11] = p * c - f * e, a;
			};
			y.rotateY = function(a, b, c) {
				var e = Math.sin(c);
				c = Math.cos(c);
				var g = b[0], h = b[1], k = b[2], f = b[3], m = b[8], q = b[9], l = b[10], p = b[11];
				return b !== a && (a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[0] = g * c - m * e, a[1] = h * c - q * e, a[2] = k * c - l * e, a[3] = f * c - p * e, a[8] = g * e + m * c, a[9] = h * e + q * c, a[10] = k * e + l * c, a[11] = f * e + p * c, a;
			};
			y.rotateZ = function(a, b, c) {
				var e = Math.sin(c);
				c = Math.cos(c);
				var g = b[0], h = b[1], k = b[2], f = b[3], m = b[4], q = b[5], l = b[6], p = b[7];
				return b !== a && (a[8] = b[8], a[9] = b[9], a[10] = b[10], a[11] = b[11], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[0] = g * c + m * e, a[1] = h * c + q * e, a[2] = k * c + l * e, a[3] = f * c + p * e, a[4] = m * c - g * e, a[5] = q * c - h * e, a[6] = l * c - k * e, a[7] = p * c - f * e, a;
			};
			y.fromRotationTranslation = function(a, b, c) {
				var e = b[0], g = b[1], h = b[2], k = b[3], f = e + e, m = g + g, q = h + h;
				b = e * f;
				var l = e * m, e = e * q, p = g * m, g = g * q, h = h * q, f = k * f, m = k * m, k = k * q;
				return a[0] = 1 - (p + h), a[1] = l + k, a[2] = e - m, a[3] = 0, a[4] = l - k, a[5] = 1 - (b + h), a[6] = g + f, a[7] = 0, a[8] = e + m, a[9] = g - f, a[10] = 1 - (b + p), a[11] = 0, a[12] = c[0], a[13] = c[1], a[14] = c[2], a[15] = 1, a;
			};
			y.fromQuat = function(a, b) {
				var c = b[0], e = b[1], g = b[2];
				b = b[3];
				var h = c + c, k = e + e, f = g + g, c = c * h, m = e * h, e = e * k, q = g * h, l = g * k, g = g * f, h = b * h, k = b * k;
				b *= f;
				return a[0] = 1 - e - g, a[1] = m + b, a[2] = q - k, a[3] = 0, a[4] = m - b, a[5] = 1 - c - g, a[6] = l + h, a[7] = 0, a[8] = q + k, a[9] = l - h, a[10] = 1 - c - e, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
			};
			y.frustum = function(a, b, c, e, g, h, k) {
				var f = 1 / (c - b), m = 1 / (g - e), q = 1 / (h - k);
				return a[0] = 2 * h * f, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 * h * m, a[6] = 0, a[7] = 0, a[8] = (c + b) * f, a[9] = (g + e) * m, a[10] = (k + h) * q, a[11] = -1, a[12] = 0, a[13] = 0, a[14] = k * h * 2 * q, a[15] = 0, a;
			};
			y.perspective = function(a, b, c, e, g) {
				b = 1 / Math.tan(b / 2);
				var h = 1 / (e - g);
				return a[0] = b / c, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = b, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = (g + e) * h, a[11] = -1, a[12] = 0, a[13] = 0, a[14] = 2 * g * e * h, a[15] = 0, a;
			};
			y.ortho = function(a, b, c, e, g, h, k) {
				var f = 1 / (b - c), q = 1 / (e - g), m = 1 / (h - k);
				return a[0] = -2 * f, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = -2 * q, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 2 * m, a[11] = 0, a[12] = (b + c) * f, a[13] = (g + e) * q, a[14] = (k + h) * m, a[15] = 1, a;
			};
			y.lookAt = function(a, c, e, g) {
				var h, k, f, q, m, l, p, r, w, t, u = c[0], v = c[1];
				c = c[2];
				var x = g[0], B = g[1];
				g = g[2];
				var A = e[0], S = e[1];
				e = e[2];
				return Math.abs(u - A) < b && Math.abs(v - S) < b && Math.abs(c - e) < b ? y.identity(a) : (p = u - A, r = v - S, w = c - e, t = 1 / Math.sqrt(p * p + r * r + w * w), p *= t, r *= t, w *= t, h = B * w - g * r, k = g * p - x * w, f = x * r - B * p, t = Math.sqrt(h * h + k * k + f * f), t ? (t = 1 / t, h *= t, k *= t, f *= t) : (h = 0, k = 0, f = 0), q = r * f - w * k, m = w * h - p * f, l = p * k - r * h, t = Math.sqrt(q * q + m * m + l * l), t ? (t = 1 / t, q *= t, m *= t, l *= t) : (q = 
				0, m = 0, l = 0), a[0] = h, a[1] = q, a[2] = p, a[3] = 0, a[4] = k, a[5] = m, a[6] = r, a[7] = 0, a[8] = f, a[9] = l, a[10] = w, a[11] = 0, a[12] = -(h * u + k * v + f * c), a[13] = -(q * u + m * v + l * c), a[14] = -(p * u + r * v + w * c), a[15] = 1, a);
			};
			y.str = function(a) {
				return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
			};
			y.frob = function(a) {
				return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
			};
			"undefined" != typeof a && (a.mat4 = y);
			var x = {create:function() {
				var a = new e(4);
				return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a;
			}};
			x.rotationTo = function() {
				var a = p.create(), b = p.fromValues(1, 0, 0), c = p.fromValues(0, 1, 0);
				return function(e, g, h) {
					var k = p.dot(g, h);
					return -.999999 > k ? (p.cross(a, b, g), 1E-6 > p.length(a) && p.cross(a, c, g), p.normalize(a, a), x.setAxisAngle(e, a, Math.PI), e) : .999999 < k ? (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e) : (p.cross(a, g, h), e[0] = a[0], e[1] = a[1], e[2] = a[2], e[3] = 1 + k, x.normalize(e, e));
				};
			}();
			x.setAxes = function() {
				var a = v.create();
				return function(b, c, e, g) {
					return a[0] = e[0], a[3] = e[1], a[6] = e[2], a[1] = g[0], a[4] = g[1], a[7] = g[2], a[2] = -c[0], a[5] = -c[1], a[8] = -c[2], x.normalize(b, x.fromMat3(b, a));
				};
			}();
			x.clone = l.clone;
			x.fromValues = l.fromValues;
			x.copy = l.copy;
			x.set = l.set;
			x.identity = function(a) {
				return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a;
			};
			x.setAxisAngle = function(a, b, c) {
				c *= .5;
				var e = Math.sin(c);
				return a[0] = e * b[0], a[1] = e * b[1], a[2] = e * b[2], a[3] = Math.cos(c), a;
			};
			x.add = l.add;
			x.multiply = function(a, b, c) {
				var e = b[0], g = b[1], h = b[2];
				b = b[3];
				var k = c[0], f = c[1], q = c[2];
				c = c[3];
				return a[0] = e * c + b * k + g * q - h * f, a[1] = g * c + b * f + h * k - e * q, a[2] = h * c + b * q + e * f - g * k, a[3] = b * c - e * k - g * f - h * q, a;
			};
			x.mul = x.multiply;
			x.scale = l.scale;
			x.rotateX = function(a, b, c) {
				c *= .5;
				var e = b[0], g = b[1], h = b[2];
				b = b[3];
				var k = Math.sin(c);
				c = Math.cos(c);
				return a[0] = e * c + b * k, a[1] = g * c + h * k, a[2] = h * c - g * k, a[3] = b * c - e * k, a;
			};
			x.rotateY = function(a, b, c) {
				c *= .5;
				var e = b[0], g = b[1], h = b[2];
				b = b[3];
				var k = Math.sin(c);
				c = Math.cos(c);
				return a[0] = e * c - h * k, a[1] = g * c + b * k, a[2] = h * c + e * k, a[3] = b * c - g * k, a;
			};
			x.rotateZ = function(a, b, c) {
				c *= .5;
				var e = b[0], g = b[1], h = b[2];
				b = b[3];
				var k = Math.sin(c);
				c = Math.cos(c);
				return a[0] = e * c + g * k, a[1] = g * c - e * k, a[2] = h * c + b * k, a[3] = b * c - h * k, a;
			};
			x.calculateW = function(a, b) {
				var c = b[0], e = b[1];
				b = b[2];
				return a[0] = c, a[1] = e, a[2] = b, a[3] = -Math.sqrt(Math.abs(1 - c * c - e * e - b * b)), a;
			};
			x.dot = l.dot;
			x.lerp = l.lerp;
			x.slerp = function(a, b, c, e) {
				var g, h, k, f, q, m = b[0], l = b[1], p = b[2];
				b = b[3];
				var r = c[0], w = c[1], t = c[2];
				c = c[3];
				return h = m * r + l * w + p * t + b * c, 0 > h && (h = -h, r = -r, w = -w, t = -t, c = -c), 1E-6 < 1 - h ? (g = Math.acos(h), k = Math.sin(g), f = Math.sin((1 - e) * g) / k, q = Math.sin(e * g) / k) : (f = 1 - e, q = e), a[0] = f * m + q * r, a[1] = f * l + q * w, a[2] = f * p + q * t, a[3] = f * b + q * c, a;
			};
			x.invert = function(a, b) {
				var c = b[0], e = b[1], g = b[2];
				b = b[3];
				var h = c * c + e * e + g * g + b * b, h = h ? 1 / h : 0;
				return a[0] = -c * h, a[1] = -e * h, a[2] = -g * h, a[3] = b * h, a;
			};
			x.conjugate = function(a, b) {
				return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a[3] = b[3], a;
			};
			x.length = l.length;
			x.len = x.length;
			x.squaredLength = l.squaredLength;
			x.sqrLen = x.squaredLength;
			x.normalize = l.normalize;
			x.fromMat3 = function(a, b) {
				var c;
				c = b[0] + b[4] + b[8];
				if (0 < c) {
					c = Math.sqrt(c + 1), a[3] = .5 * c, c = .5 / c, a[0] = (b[7] - b[5]) * c, a[1] = (b[2] - b[6]) * c, a[2] = (b[3] - b[1]) * c;
				} else {
					var e = 0;
					b[4] > b[0] && (e = 1);
					b[8] > b[3 * e + e] && (e = 2);
					var g = (e + 1) % 3, h = (e + 2) % 3;
					c = Math.sqrt(b[3 * e + e] - b[3 * g + g] - b[3 * h + h] + 1);
					a[e] = .5 * c;
					c = .5 / c;
					a[3] = (b[3 * h + g] - b[3 * g + h]) * c;
					a[g] = (b[3 * g + e] + b[3 * e + g]) * c;
					a[h] = (b[3 * h + e] + b[3 * e + h]) * c;
				}
				return a;
			};
			x.str = function(a) {
				return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
			};
			"undefined" != typeof a && (a.quat = x);
		})(b);
	}(this);
}, {}], 24:[function(a, f, l) {
	(function() {
		var a = this, k = a._, h = {}, c = Array.prototype, e = Object.prototype, g = c.push, q = c.slice, r = c.concat, w = e.toString, p = e.hasOwnProperty, t = c.forEach, v = c.map, y = c.reduce, x = c.reduceRight, m = c.filter, u = c.every, B = c.some, A = c.indexOf, D = c.lastIndexOf, e = Array.isArray, G = Object.keys, F = Function.prototype.bind, C = function(a) {
			return a instanceof C ? a : this instanceof C ? void(this._wrapped = a) : new C(a);
		};
		"undefined" != typeof l ? ("undefined" != typeof f && f.exports && (l = f.exports = C), l._ = C) : a._ = C;
		C.VERSION = "1.4.4";
		var J = C.each = C.forEach = function(a, b, c) {
			if (null != a) {
				if (t && a.forEach === t) {
					a.forEach(b, c);
				} else {
					if (a.length === +a.length) {
						for (var e = 0, g = a.length;g > e && b.call(c, a[e], e, a) !== h;e++) {
						}
					} else {
						for (e in a) {
							if (C.has(a, e) && b.call(c, a[e], e, a) === h) {
								break;
							}
						}
					}
				}
			}
		};
		C.map = C.collect = function(a, b, c) {
			var e = [];
			return null == a ? e : v && a.map === v ? a.map(b, c) : (J(a, function(a, g, h) {
				e[e.length] = b.call(c, a, g, h);
			}), e);
		};
		C.reduce = C.foldl = C.inject = function(a, b, c, e) {
			var g = 2 < arguments.length;
			if (null == a && (a = []), y && a.reduce === y) {
				return e && (b = C.bind(b, e)), g ? a.reduce(b, c) : a.reduce(b);
			}
			if (J(a, function(a, h, k) {
				g ? c = b.call(e, c, a, h, k) : (c = a, g = !0);
			}), !g) {
				throw new TypeError("Reduce of empty array with no initial value");
			}
			return c;
		};
		C.reduceRight = C.foldr = function(a, b, c, e) {
			var g = 2 < arguments.length;
			if (null == a && (a = []), x && a.reduceRight === x) {
				return e && (b = C.bind(b, e)), g ? a.reduceRight(b, c) : a.reduceRight(b);
			}
			var h = a.length;
			if (h !== +h) {
				var k = C.keys(a), h = k.length
			}
			if (J(a, function(f, q, m) {
				q = k ? k[--h] : --h;
				g ? c = b.call(e, c, a[q], q, m) : (c = a[q], g = !0);
			}), !g) {
				throw new TypeError("Reduce of empty array with no initial value");
			}
			return c;
		};
		C.find = C.detect = function(a, b, c) {
			var e;
			return I(a, function(a, g, h) {
				return b.call(c, a, g, h) ? (e = a, !0) : void 0;
			}), e;
		};
		C.filter = C.select = function(a, b, c) {
			var e = [];
			return null == a ? e : m && a.filter === m ? a.filter(b, c) : (J(a, function(a, g, h) {
				b.call(c, a, g, h) && (e[e.length] = a);
			}), e);
		};
		C.reject = function(a, b, c) {
			return C.filter(a, function(a, e, g) {
				return !b.call(c, a, e, g);
			}, c);
		};
		C.every = C.all = function(a, b, c) {
			b || (b = C.identity);
			var e = !0;
			return null == a ? e : u && a.every === u ? a.every(b, c) : (J(a, function(a, g, k) {
				return (e = e && b.call(c, a, g, k)) ? void 0 : h;
			}), !!e);
		};
		var I = C.some = C.any = function(a, b, c) {
			b || (b = C.identity);
			var e = !1;
			return null == a ? e : B && a.some === B ? a.some(b, c) : (J(a, function(a, g, k) {
				return e || (e = b.call(c, a, g, k)) ? h : void 0;
			}), !!e);
		};
		C.contains = C.include = function(a, b) {
			return null == a ? !1 : A && a.indexOf === A ? -1 != a.indexOf(b) : I(a, function(a) {
				return a === b;
			});
		};
		C.invoke = function(a, b) {
			var c = q.call(arguments, 2), e = C.isFunction(b);
			return C.map(a, function(a) {
				return (e ? b : a[b]).apply(a, c);
			});
		};
		C.pluck = function(a, b) {
			return C.map(a, function(a) {
				return a[b];
			});
		};
		C.where = function(a, b, c) {
			return C.isEmpty(b) ? c ? null : [] : C[c ? "find" : "filter"](a, function(a) {
				for (var c in b) {
					if (b[c] !== a[c]) {
						return !1;
					}
				}
				return !0;
			});
		};
		C.findWhere = function(a, b) {
			return C.where(a, b, !0);
		};
		C.max = function(a, b, c) {
			if (!b && C.isArray(a) && a[0] === +a[0] && 65535 > a.length) {
				return Math.max.apply(Math, a);
			}
			if (!b && C.isEmpty(a)) {
				return -1 / 0;
			}
			var e = {computed:-1 / 0, value:-1 / 0};
			return J(a, function(a, g, h) {
				g = b ? b.call(c, a, g, h) : a;
				g >= e.computed && (e = {value:a, computed:g});
			}), e.value;
		};
		C.min = function(a, b, c) {
			if (!b && C.isArray(a) && a[0] === +a[0] && 65535 > a.length) {
				return Math.min.apply(Math, a);
			}
			if (!b && C.isEmpty(a)) {
				return 1 / 0;
			}
			var e = {computed:1 / 0, value:1 / 0};
			return J(a, function(a, g, h) {
				g = b ? b.call(c, a, g, h) : a;
				g < e.computed && (e = {value:a, computed:g});
			}), e.value;
		};
		C.shuffle = function(a) {
			var b, c = 0, e = [];
			return J(a, function(a) {
				b = C.random(c++);
				e[c - 1] = e[b];
				e[b] = a;
			}), e;
		};
		var Q = function(a) {
			return C.isFunction(a) ? a : function(b) {
				return b[a];
			};
		};
		C.sortBy = function(a, b, c) {
			var e = Q(b);
			return C.pluck(C.map(a, function(a, b, g) {
				return {value:a, index:b, criteria:e.call(c, a, b, g)};
			}).sort(function(a, b) {
				var c = a.criteria, e = b.criteria;
				if (c !== e) {
					if (c > e || void 0 === c) {
						return 1;
					}
					if (e > c || void 0 === e) {
						return -1;
					}
				}
				return a.index < b.index ? -1 : 1;
			}), "value");
		};
		var M = function(a, b, c, e) {
			var g = {}, h = Q(b || C.identity);
			return J(a, function(b, k) {
				k = h.call(c, b, k, a);
				e(g, k, b);
			}), g;
		};
		C.groupBy = function(a, b, c) {
			return M(a, b, c, function(a, b, c) {
				(C.has(a, b) ? a[b] : a[b] = []).push(c);
			});
		};
		C.countBy = function(a, b, c) {
			return M(a, b, c, function(a, b) {
				C.has(a, b) || (a[b] = 0);
				a[b]++;
			});
		};
		C.sortedIndex = function(a, b, c, e) {
			c = null == c ? C.identity : Q(c);
			b = c.call(e, b);
			for (var g = 0, h = a.length;h > g;) {
				var k = g + h >>> 1;
				c.call(e, a[k]) < b ? g = k + 1 : h = k;
			}
			return g;
		};
		C.toArray = function(a) {
			return a ? C.isArray(a) ? q.call(a) : a.length === +a.length ? C.map(a, C.identity) : C.values(a) : [];
		};
		C.size = function(a) {
			return null == a ? 0 : a.length === +a.length ? a.length : C.keys(a).length;
		};
		C.first = C.head = C.take = function(a, b, c) {
			return null == a ? void 0 : null == b || c ? a[0] : q.call(a, 0, b);
		};
		C.initial = function(a, b, c) {
			return q.call(a, 0, a.length - (null == b || c ? 1 : b));
		};
		C.last = function(a, b, c) {
			return null == a ? void 0 : null == b || c ? a[a.length - 1] : q.call(a, Math.max(a.length - b, 0));
		};
		C.rest = C.tail = C.drop = function(a, b, c) {
			return q.call(a, null == b || c ? 1 : b);
		};
		C.compact = function(a) {
			return C.filter(a, C.identity);
		};
		var N = function(a, b, c) {
			return J(a, function(a) {
				C.isArray(a) ? b ? g.apply(c, a) : N(a, b, c) : c.push(a);
			}), c;
		};
		C.flatten = function(a, b) {
			return N(a, b, []);
		};
		C.without = function(a) {
			return C.difference(a, q.call(arguments, 1));
		};
		C.uniq = C.unique = function(a, b, c, e) {
			C.isFunction(b) && (e = c, c = b, b = !1);
			c = c ? C.map(a, c, e) : a;
			var g = [], h = [];
			return J(c, function(c, e) {
				(b ? e && h[h.length - 1] === c : C.contains(h, c)) || (h.push(c), g.push(a[e]));
			}), g;
		};
		C.union = function() {
			return C.uniq(r.apply(c, arguments));
		};
		C.intersection = function(a) {
			var b = q.call(arguments, 1);
			return C.filter(C.uniq(a), function(a) {
				return C.every(b, function(b) {
					return 0 <= C.indexOf(b, a);
				});
			});
		};
		C.difference = function(a) {
			var b = r.apply(c, q.call(arguments, 1));
			return C.filter(a, function(a) {
				return !C.contains(b, a);
			});
		};
		C.zip = function() {
			for (var a = q.call(arguments), b = C.max(C.pluck(a, "length")), c = Array(b), e = 0;b > e;e++) {
				c[e] = C.pluck(a, "" + e);
			}
			return c;
		};
		C.object = function(a, b) {
			if (null == a) {
				return {};
			}
			for (var c = {}, e = 0, g = a.length;g > e;e++) {
				b ? c[a[e]] = b[e] : c[a[e][0]] = a[e][1];
			}
			return c;
		};
		C.indexOf = function(a, b, c) {
			if (null == a) {
				return -1;
			}
			var e = 0, g = a.length;
			if (c) {
				if ("number" != typeof c) {
					return e = C.sortedIndex(a, b), a[e] === b ? e : -1;
				}
				e = 0 > c ? Math.max(0, g + c) : c;
			}
			if (A && a.indexOf === A) {
				return a.indexOf(b, c);
			}
			for (;g > e;e++) {
				if (a[e] === b) {
					return e;
				}
			}
			return -1;
		};
		C.lastIndexOf = function(a, b, c) {
			if (null == a) {
				return -1;
			}
			var e = null != c;
			if (D && a.lastIndexOf === D) {
				return e ? a.lastIndexOf(b, c) : a.lastIndexOf(b);
			}
			for (c = e ? c : a.length;c--;) {
				if (a[c] === b) {
					return c;
				}
			}
			return -1;
		};
		C.range = function(a, b, c) {
			1 >= arguments.length && (b = a || 0, a = 0);
			c = arguments[2] || 1;
			for (var e = Math.max(Math.ceil((b - a) / c), 0), g = 0, h = Array(e);e > g;) {
				h[g++] = a, a += c;
			}
			return h;
		};
		C.bind = function(a, b) {
			if (a.bind === F && F) {
				return F.apply(a, q.call(arguments, 1));
			}
			var c = q.call(arguments, 2);
			return function() {
				return a.apply(b, c.concat(q.call(arguments)));
			};
		};
		C.partial = function(a) {
			var b = q.call(arguments, 1);
			return function() {
				return a.apply(this, b.concat(q.call(arguments)));
			};
		};
		C.bindAll = function(a) {
			var b = q.call(arguments, 1);
			return 0 === b.length && (b = C.functions(a)), J(b, function(b) {
				a[b] = C.bind(a[b], a);
			}), a;
		};
		C.memoize = function(a, b) {
			var c = {};
			return b || (b = C.identity), function() {
				var e = b.apply(this, arguments);
				return C.has(c, e) ? c[e] : c[e] = a.apply(this, arguments);
			};
		};
		C.delay = function(a, b) {
			var c = q.call(arguments, 2);
			return setTimeout(function() {
				return a.apply(null, c);
			}, b);
		};
		C.defer = function(a) {
			return C.delay.apply(C, [a, 1].concat(q.call(arguments, 1)));
		};
		C.throttle = function(a, b) {
			var c, e, g, h, k = 0, f = function() {
				k = new Date;
				g = null;
				h = a.apply(c, e);
			};
			return function() {
				var q = new Date, m = b - (q - k);
				return c = this, e = arguments, 0 >= m ? (clearTimeout(g), g = null, k = q, h = a.apply(c, e)) : g || (g = setTimeout(f, m)), h;
			};
		};
		C.debounce = function(a, b, c) {
			var e, g;
			return function() {
				var h = this, k = arguments, f = c && !e;
				return clearTimeout(e), e = setTimeout(function() {
					e = null;
					c || (g = a.apply(h, k));
				}, b), f && (g = a.apply(h, k)), g;
			};
		};
		C.once = function(a) {
			var b, c = !1;
			return function() {
				return c ? b : (c = !0, b = a.apply(this, arguments), a = null, b);
			};
		};
		C.wrap = function(a, b) {
			return function() {
				var c = [a];
				return g.apply(c, arguments), b.apply(this, c);
			};
		};
		C.compose = function() {
			var a = arguments;
			return function() {
				for (var b = arguments, c = a.length - 1;0 <= c;c--) {
					b = [a[c].apply(this, b)];
				}
				return b[0];
			};
		};
		C.after = function(a, b) {
			return 0 >= a ? b() : function() {
				return 1 > --a ? b.apply(this, arguments) : void 0;
			};
		};
		C.keys = G || function(a) {
			if (a !== Object(a)) {
				throw new TypeError("Invalid object");
			}
			var b = [], c;
			for (c in a) {
				C.has(a, c) && (b[b.length] = c);
			}
			return b;
		};
		C.values = function(a) {
			var b = [], c;
			for (c in a) {
				C.has(a, c) && b.push(a[c]);
			}
			return b;
		};
		C.pairs = function(a) {
			var b = [], c;
			for (c in a) {
				C.has(a, c) && b.push([c, a[c]]);
			}
			return b;
		};
		C.invert = function(a) {
			var b = {}, c;
			for (c in a) {
				C.has(a, c) && (b[a[c]] = c);
			}
			return b;
		};
		C.functions = C.methods = function(a) {
			var b = [], c;
			for (c in a) {
				C.isFunction(a[c]) && b.push(c);
			}
			return b.sort();
		};
		C.extend = function(a) {
			return J(q.call(arguments, 1), function(b) {
				if (b) {
					for (var c in b) {
						a[c] = b[c];
					}
				}
			}), a;
		};
		C.pick = function(a) {
			var b = {}, e = r.apply(c, q.call(arguments, 1));
			return J(e, function(c) {
				c in a && (b[c] = a[c]);
			}), b;
		};
		C.omit = function(a) {
			var b = {}, e = r.apply(c, q.call(arguments, 1)), g;
			for (g in a) {
				C.contains(e, g) || (b[g] = a[g]);
			}
			return b;
		};
		C.defaults = function(a) {
			return J(q.call(arguments, 1), function(b) {
				if (b) {
					for (var c in b) {
						null == a[c] && (a[c] = b[c]);
					}
				}
			}), a;
		};
		C.clone = function(a) {
			return C.isObject(a) ? C.isArray(a) ? a.slice() : C.extend({}, a) : a;
		};
		C.tap = function(a, b) {
			return b(a), a;
		};
		var R = function(a, b, c, e) {
			if (a === b) {
				return 0 !== a || 1 / a == 1 / b;
			}
			if (null == a || null == b) {
				return a === b;
			}
			a instanceof C && (a = a._wrapped);
			b instanceof C && (b = b._wrapped);
			var g = w.call(a);
			if (g != w.call(b)) {
				return !1;
			}
			switch(g) {
				case "[object String]":
					return a == String(b);
				case "[object Number]":
					return a != +a ? b != +b : 0 == a ? 1 / a == 1 / b : a == +b;
				case "[object Date]":
				;
				case "[object Boolean]":
					return +a == +b;
				case "[object RegExp]":
					return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
			}
			if ("object" != typeof a || "object" != typeof b) {
				return !1;
			}
			for (var h = c.length;h--;) {
				if (c[h] == a) {
					return e[h] == b;
				}
			}
			c.push(a);
			e.push(b);
			var h = 0, k = !0;
			if ("[object Array]" == g) {
				if (h = a.length, k = h == b.length) {
					for (;h-- && (k = R(a[h], b[h], c, e));) {
					}
				}
			} else {
				var g = a.constructor, f = b.constructor;
				if (g !== f && !(C.isFunction(g) && g instanceof g && C.isFunction(f) && f instanceof f)) {
					return !1;
				}
				for (var q in a) {
					if (C.has(a, q) && (h++, !(k = C.has(b, q) && R(a[q], b[q], c, e)))) {
						break;
					}
				}
				if (k) {
					for (q in b) {
						if (C.has(b, q) && !h--) {
							break;
						}
					}
					k = !h;
				}
			}
			return c.pop(), e.pop(), k;
		};
		C.isEqual = function(a, b) {
			return R(a, b, [], []);
		};
		C.isEmpty = function(a) {
			if (null == a) {
				return !0;
			}
			if (C.isArray(a) || C.isString(a)) {
				return 0 === a.length;
			}
			for (var b in a) {
				if (C.has(a, b)) {
					return !1;
				}
			}
			return !0;
		};
		C.isElement = function(a) {
			return !(!a || 1 !== a.nodeType);
		};
		C.isArray = e || function(a) {
			return "[object Array]" == w.call(a);
		};
		C.isObject = function(a) {
			return a === Object(a);
		};
		J("Arguments Function String Number Date RegExp".split(" "), function(a) {
			C["is" + a] = function(b) {
				return w.call(b) == "[object " + a + "]";
			};
		});
		C.isArguments(arguments) || (C.isArguments = function(a) {
			return !(!a || !C.has(a, "callee"));
		});
		"function" != typeof/./ && (C.isFunction = function(a) {
			return "function" == typeof a;
		});
		C.isFinite = function(a) {
			return isFinite(a) && !isNaN(parseFloat(a));
		};
		C.isNaN = function(a) {
			return C.isNumber(a) && a != +a;
		};
		C.isBoolean = function(a) {
			return !0 === a || !1 === a || "[object Boolean]" == w.call(a);
		};
		C.isNull = function(a) {
			return null === a;
		};
		C.isUndefined = function(a) {
			return void 0 === a;
		};
		C.has = function(a, b) {
			return p.call(a, b);
		};
		C.noConflict = function() {
			return a._ = k, this;
		};
		C.identity = function(a) {
			return a;
		};
		C.times = function(a, b, c) {
			for (var e = Array(a), g = 0;a > g;g++) {
				e[g] = b.call(c, g);
			}
			return e;
		};
		C.random = function(a, b) {
			return null == b && (b = a, a = 0), a + Math.floor(Math.random() * (b - a + 1));
		};
		var H = {escape:{"&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#x27;", "/":"&#x2F;"}};
		H.unescape = C.invert(H.escape);
		var ba = {escape:new RegExp("[" + C.keys(H.escape).join("") + "]", "g"), unescape:new RegExp("(" + C.keys(H.unescape).join("|") + ")", "g")};
		C.each(["escape", "unescape"], function(a) {
			C[a] = function(b) {
				return null == b ? "" : ("" + b).replace(ba[a], function(b) {
					return H[a][b];
				});
			};
		});
		C.result = function(a, b) {
			if (null == a) {
				return null;
			}
			b = a[b];
			return C.isFunction(b) ? b.call(a) : b;
		};
		C.mixin = function(a) {
			J(C.functions(a), function(b) {
				var c = C[b] = a[b];
				C.prototype[b] = function() {
					var a = [this._wrapped];
					return g.apply(a, arguments), V.call(this, c.apply(C, a));
				};
			});
		};
		var ha = 0;
		C.uniqueId = function(a) {
			var b = ++ha + "";
			return a ? a + b : b;
		};
		C.templateSettings = {evaluate:/<%([\s\S]+?)%>/g, interpolate:/<%=([\s\S]+?)%>/g, escape:/<%-([\s\S]+?)%>/g};
		var Y = /(.)^/, ga = {"'":"'", "\\":"\\", "\r":"r", "\n":"n", "\t":"t", "\u2028":"u2028", "\u2029":"u2029"}, S = /\\|'|\r|\n|\t|\u2028|\u2029/g;
		C.template = function(a, b, c) {
			var e;
			c = C.defaults({}, c, C.templateSettings);
			var g = new RegExp([(c.escape || Y).source, (c.interpolate || Y).source, (c.evaluate || Y).source].join("|") + "|$", "g"), h = 0, k = "__p+='";
			a.replace(g, function(b, c, e, g, f) {
				return k += a.slice(h, f).replace(S, function(a) {
					return "\\" + ga[a];
				}), c && (k += "'+\n((__t=(" + c + "))==null?'':_.escape(__t))+\n'"), e && (k += "'+\n((__t=(" + e + "))==null?'':__t)+\n'"), g && (k += "';\n" + g + "\n__p+='"), h = f + b.length, b;
			});
			k += "';\n";
			c.variable || (k = "with(obj||{}){\n" + k + "}\n");
			k = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + k + "return __p;\n";
			try {
				e = new Function(c.variable || "obj", "_", k);
			} catch (qa) {
				throw qa.source = k, qa;
			}
			if (b) {
				return e(b, C);
			}
			b = function(a) {
				return e.call(this, a, C);
			};
			return b.source = "function(" + (c.variable || "obj") + "){\n" + k + "}", b;
		};
		C.chain = function(a) {
			return C(a).chain();
		};
		var V = function(a) {
			return this._chain ? C(a).chain() : a;
		};
		C.mixin(C);
		J("pop push reverse shift sort splice unshift".split(" "), function(a) {
			var b = c[a];
			C.prototype[a] = function() {
				var c = this._wrapped;
				return b.apply(c, arguments), "shift" != a && "splice" != a || 0 !== c.length || delete c[0], V.call(this, c);
			};
		});
		J(["concat", "join", "slice"], function(a) {
			var b = c[a];
			C.prototype[a] = function() {
				return V.call(this, b.apply(this._wrapped, arguments));
			};
		});
		C.extend(C.prototype, {chain:function() {
			return this._chain = !0, this;
		}, value:function() {
			return this._wrapped;
		}});
	}).call(this);
}, {}], 25:[function(a) {
	"undefined" != typeof window && "function" != typeof window.requestAnimationFrame && (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a) {
		setTimeout(a, 1E3 / 60);
	});
	Leap = a("../lib/index");
}, {"../lib/index":11}]}, {}, [25]);
var Stats = function() {
	function a(a) {
		b.appendChild(a.dom);
		return a;
	}
	function f(a) {
		for (var c = 0;c < b.children.length;c++) {
			b.children[c].style.display = c === a ? "block" : "none";
		}
		l = a;
	}
	var l = 0, b = document.createElement("div");
	b.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";
	b.addEventListener("click", function(a) {
		a.preventDefault();
		f(++l % b.children.length);
	}, !1);
	var k = (performance || Date).now(), h = k, c = 0, e = a(new Stats.Panel("FPS", "#fff", "#222")), g = a(new Stats.Panel("MS", "#fff", "#222"));
	if (self.performance && self.performance.memory) {
		var q = a(new Stats.Panel("MB", "#fff", "#222"))
	}
	f(0);
	return {REVISION:17, dom:b, addPanel:a, showPanel:f, begin:function() {
		k = (performance || Date).now();
	}, end:function() {
		c++;
		var a = (performance || Date).now();
		g.update(a - k, 200);
		if (a > h + 1E3 && (e.update(1E3 * c / (a - h), 100), h = a, c = 0, q)) {
			var b = performance.memory;
			q.update(b.usedJSHeapSize / 1048576, b.jsHeapSizeLimit / 1048576);
		}
		return a;
	}, update:function() {
		k = this.end();
	}, domElement:b, setMode:f};
};
Stats.Panel = function(a, f, l) {
	var b = Infinity, k = 0, h = Math.round, c = h(window.devicePixelRatio || 1), e = 80 * c, g = 48 * c, q = 3 * c, r = 2 * c, w = 3 * c, p = 15 * c, t = 74 * c, v = 30 * c, y = document.createElement("canvas");
	y.width = e;
	y.height = g;
	y.style.cssText = "width:80px;height:48px";
	var x = y.getContext("2d");
	x.font = "bold " + 9 * c + "px Helvetica,Arial,sans-serif";
	x.textBaseline = "top";
	x.fillStyle = l;
	x.fillRect(0, 0, e, g);
	x.fillStyle = f;
	x.fillText(a, q, r);
	x.fillRect(w, p, t, v);
	x.fillStyle = l;
	x.globalAlpha = .9;
	x.fillRect(w, p, t, v);
	return {dom:y, update:function(g, u) {
		b = Math.min(b, g);
		k = Math.max(k, g);
		x.fillStyle = l;
		x.globalAlpha = 1;
		x.fillRect(0, 0, e, p);
		x.fillStyle = f;
		x.fillText(h(g) + " " + a + " (" + h(b) + "-" + h(k) + ")", q, r);
		x.drawImage(y, w + c, p, t - c, v, w, p, t - c, v);
		x.fillRect(w + t - c, p, c, v);
		x.fillStyle = l;
		x.globalAlpha = .9;
		x.fillRect(w + t - c, p, c, h((1 - g / u) * v));
	}};
};
"object" === typeof module && (module.exports = Stats);
var SPE = {distributions:{BOX:1, SPHERE:2, DISC:3}, valueOverLifetimeLength:4};
"function" == typeof define && define.amd ? define("spe", SPE) : "undefined" != typeof exports && "undefined" != typeof module && (module.exports = SPE);
SPE.TypedArrayHelper = function(a, f, l, b) {
	this.componentSize = l || 1;
	this.size = f || 1;
	this.TypedArrayConstructor = a || Float32Array;
	this.array = new a(f * this.componentSize);
	this.indexOffset = b || 0;
};
SPE.TypedArrayHelper.constructor = SPE.TypedArrayHelper;
SPE.TypedArrayHelper.prototype.setSize = function(a, f) {
	var l = this.array.length;
	return f || (a *= this.componentSize), l > a ? this.shrink(a) : a > l ? this.grow(a) : void console.info("TypedArray is already of size:", a + ".", "Will not resize.");
};
SPE.TypedArrayHelper.prototype.shrink = function(a) {
	return this.array = this.array.subarray(0, a), this.size = a, this;
};
SPE.TypedArrayHelper.prototype.grow = function(a) {
	var f = this.array, l = new this.TypedArrayConstructor(a);
	return l.set(f), this.array = l, this.size = a, this;
};
SPE.TypedArrayHelper.prototype.splice = function(a, f) {
	a *= this.componentSize;
	f *= this.componentSize;
	for (var l = [], b = this.array, k = b.length, h = 0;k > h;++h) {
		(a > h || h >= f) && l.push(b[h]);
	}
	return this.setFromArray(0, l), this;
};
SPE.TypedArrayHelper.prototype.setFromArray = function(a, f) {
	var l = a + f.length;
	return l > this.array.length ? this.grow(l) : l < this.array.length && this.shrink(l), this.array.set(f, this.indexOffset + a), this;
};
SPE.TypedArrayHelper.prototype.setVec2 = function(a, f) {
	return this.setVec2Components(a, f.x, f.y);
};
SPE.TypedArrayHelper.prototype.setVec2Components = function(a, f, l) {
	var b = this.array;
	a = this.indexOffset + a * this.componentSize;
	return b[a] = f, b[a + 1] = l, this;
};
SPE.TypedArrayHelper.prototype.setVec3 = function(a, f) {
	return this.setVec3Components(a, f.x, f.y, f.z);
};
SPE.TypedArrayHelper.prototype.setVec3Components = function(a, f, l, b) {
	var k = this.array;
	a = this.indexOffset + a * this.componentSize;
	return k[a] = f, k[a + 1] = l, k[a + 2] = b, this;
};
SPE.TypedArrayHelper.prototype.setVec4 = function(a, f) {
	return this.setVec4Components(a, f.x, f.y, f.z, f.w);
};
SPE.TypedArrayHelper.prototype.setVec4Components = function(a, f, l, b, k) {
	var h = this.array;
	a = this.indexOffset + a * this.componentSize;
	return h[a] = f, h[a + 1] = l, h[a + 2] = b, h[a + 3] = k, this;
};
SPE.TypedArrayHelper.prototype.setMat3 = function(a, f) {
	return this.setFromArray(this.indexOffset + a * this.componentSize, f.elements);
};
SPE.TypedArrayHelper.prototype.setMat4 = function(a, f) {
	return this.setFromArray(this.indexOffset + a * this.componentSize, f.elements);
};
SPE.TypedArrayHelper.prototype.setColor = function(a, f) {
	return this.setVec3Components(a, f.r, f.g, f.b);
};
SPE.TypedArrayHelper.prototype.setNumber = function(a, f) {
	return this.array[this.indexOffset + a * this.componentSize] = f, this;
};
SPE.TypedArrayHelper.prototype.getValueAtIndex = function(a) {
	return this.array[this.indexOffset + a];
};
SPE.TypedArrayHelper.prototype.getComponentValueAtIndex = function(a) {
	return this.array.subarray(this.indexOffset + a * this.componentSize);
};
SPE.ShaderAttribute = function(a, f, l) {
	var b = SPE.ShaderAttribute.typeSizeMap;
	this.type = "string" == typeof a && b.hasOwnProperty(a) ? a : "f";
	this.componentSize = b[this.type];
	this.arrayType = l || Float32Array;
	this.bufferAttribute = this.typedArray = null;
	this.dynamicBuffer = !!f;
	this.updateMax = this.updateMin = 0;
};
SPE.ShaderAttribute.constructor = SPE.ShaderAttribute;
SPE.ShaderAttribute.typeSizeMap = {f:1, v2:2, v3:3, v4:4, c:3, m3:9, m4:16};
SPE.ShaderAttribute.prototype.setUpdateRange = function(a, f) {
	this.updateMin = Math.min(a * this.componentSize, this.updateMin * this.componentSize);
	this.updateMax = Math.max(f * this.componentSize, this.updateMax * this.componentSize);
};
SPE.ShaderAttribute.prototype.flagUpdate = function() {
	var a = this.bufferAttribute, f = a.updateRange;
	f.offset = this.updateMin;
	f.count = Math.min(this.updateMax - this.updateMin + this.componentSize, this.typedArray.array.length);
	a.needsUpdate = !0;
};
SPE.ShaderAttribute.prototype.resetUpdateRange = function() {
	this.updateMax = this.updateMin = 0;
};
SPE.ShaderAttribute.prototype.resetDynamic = function() {
	this.bufferAttribute.dynamic = this.dynamicBuffer;
};
SPE.ShaderAttribute.prototype.splice = function(a, f) {
	this.typedArray.splice(a, f);
	this.forceUpdateAll();
};
SPE.ShaderAttribute.prototype.forceUpdateAll = function() {
	this.bufferAttribute.array = this.typedArray.array;
	this.bufferAttribute.updateRange.offset = 0;
	this.bufferAttribute.updateRange.count = -1;
	this.bufferAttribute.dynamic = !1;
	this.bufferAttribute.needsUpdate = !0;
};
SPE.ShaderAttribute.prototype._ensureTypedArray = function(a) {
	null !== this.typedArray && this.typedArray.size === a * this.componentSize || (null !== this.typedArray && this.typedArray.size !== a ? this.typedArray.setSize(a) : null === this.typedArray && (this.typedArray = new SPE.TypedArrayHelper(this.arrayType, a, this.componentSize)));
};
SPE.ShaderAttribute.prototype._createBufferAttribute = function(a) {
	return this._ensureTypedArray(a), null !== this.bufferAttribute ? (this.bufferAttribute.array = this.typedArray.array, void(this.bufferAttribute.needsUpdate = !0)) : (this.bufferAttribute = new THREE.BufferAttribute(this.typedArray.array, this.componentSize), void(this.bufferAttribute.dynamic = this.dynamicBuffer));
};
SPE.ShaderAttribute.prototype.getLength = function() {
	return null === this.typedArray ? 0 : this.typedArray.array.length;
};
SPE.shaderChunks = {defines:"#define PACKED_COLOR_SIZE 256.0\n#define PACKED_COLOR_DIVISOR 255.0", uniforms:"uniform float deltaTime;\nuniform float runTime;\nuniform sampler2D texture;\nuniform vec4 textureAnimation;\nuniform float scale;", attributes:"attribute vec4 acceleration;\nattribute vec3 velocity;\nattribute vec4 rotation;\nattribute vec3 rotationCenter;\nattribute vec4 params;\nattribute vec4 size;\nattribute vec4 angle;\nattribute vec4 color;\nattribute vec4 opacity;", varyings:"varying vec4 vColor;\n#ifdef SHOULD_ROTATE_TEXTURE\n    varying float vAngle;\n#endif\n#ifdef SHOULD_CALCULATE_SPRITE\n    varying vec4 vSpriteSheet;\n#endif", 
branchAvoidanceFunctions:"float when_gt(float x, float y) {\n    return max(sign(x - y), 0.0);\n}\nfloat when_lt(float x, float y) {\n    return min( max(1.0 - sign(x - y), 0.0), 1.0 );\n}\nfloat when_eq( float x, float y ) {\n    return 1.0 - abs( sign( x - y ) );\n}\nfloat when_ge(float x, float y) {\n  return 1.0 - when_lt(x, y);\n}\nfloat when_le(float x, float y) {\n  return 1.0 - when_gt(x, y);\n}\nfloat and(float a, float b) {\n    return a * b;\n}\nfloat or(float a, float b) {\n    return min(a + b, 1.0);\n}", 
unpackColor:"vec3 unpackColor( in float hex ) {\n   vec3 c = vec3( 0.0 );\n   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );\n   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );\n   float b = mod( hex, PACKED_COLOR_SIZE );\n   c.r = r / PACKED_COLOR_DIVISOR;\n   c.g = g / PACKED_COLOR_DIVISOR;\n   c.b = b / PACKED_COLOR_DIVISOR;\n   return c;\n}", unpackRotationAxis:"vec3 unpackRotationAxis( in float hex ) {\n   vec3 c = vec3( 0.0 );\n   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );\n   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );\n   float b = mod( hex, PACKED_COLOR_SIZE );\n   c.r = r / PACKED_COLOR_DIVISOR;\n   c.g = g / PACKED_COLOR_DIVISOR;\n   c.b = b / PACKED_COLOR_DIVISOR;\n   c *= vec3( 2.0 );\n   c -= vec3( 1.0 );\n   return c;\n}", 
floatOverLifetime:"float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {\n    highp float value = 0.0;\n    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );\n    float fIndex = 0.0;\n    float shouldApplyValue = 0.0;\n    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );\n\n    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {\n       fIndex = float( i );\n       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );\n       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );\n    }\n\n    return value;\n}", 
colorOverLifetime:"vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {\n    vec3 value = vec3( 0.0 );\n    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );\n    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );\n    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );\n    return value;\n}", 
paramFetchingFunctions:"float getAlive() {\n   return params.x;\n}\nfloat getAge() {\n   return params.y;\n}\nfloat getMaxAge() {\n   return params.z;\n}\nfloat getWiggle() {\n   return params.w;\n}", forceFetchingFunctions:"vec4 getPosition( in float age ) {\n   return modelViewMatrix * vec4( position, 1.0 );\n}\nvec3 getVelocity( in float age ) {\n   return velocity * age;\n}\nvec3 getAcceleration( in float age ) {\n   return acceleration.xyz * age;\n}", rotationFunctions:"#ifdef SHOULD_ROTATE_PARTICLES\n   mat4 getRotationMatrix( in vec3 axis, in float angle) {\n       axis = normalize(axis);\n       float s = sin(angle);\n       float c = cos(angle);\n       float oc = 1.0 - c;\n\n       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                   0.0,                                0.0,                                0.0,                                1.0);\n   }\n\n   vec3 getRotation( in vec3 pos, in float positionInTime ) {\n      if( rotation.y == 0.0 ) {\n           return pos;\n      }\n\n      vec3 axis = unpackRotationAxis( rotation.x );\n      vec3 center = rotationCenter;\n      vec3 translated;\n      mat4 rotationMatrix;\n      float angle = 0.0;\n      angle += when_eq( rotation.z, 0.0 ) * rotation.y;\n      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );\n      translated = rotationCenter - pos;\n      rotationMatrix = getRotationMatrix( axis, angle );\n      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );\n   }\n#endif", 
rotateTexture:"    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );\n\n    #ifdef SHOULD_ROTATE_TEXTURE\n       float x = gl_PointCoord.x - 0.5;\n       float y = 1.0 - gl_PointCoord.y - 0.5;\n       float c = cos( -vAngle );\n       float s = sin( -vAngle );\n       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );\n    #endif\n\n    #ifdef SHOULD_CALCULATE_SPRITE\n        float framesX = vSpriteSheet.x;\n        float framesY = vSpriteSheet.y;\n        float columnNorm = vSpriteSheet.z;\n        float rowNorm = vSpriteSheet.w;\n        vUv.x = gl_PointCoord.x * framesX + columnNorm;\n        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);\n    #endif\n\n    vec4 rotatedTexture = texture2D( texture, vUv );"};
SPE.shaders = {vertex:[SPE.shaderChunks.defines, SPE.shaderChunks.uniforms, SPE.shaderChunks.attributes, SPE.shaderChunks.varyings, THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, SPE.shaderChunks.branchAvoidanceFunctions, SPE.shaderChunks.unpackColor, SPE.shaderChunks.unpackRotationAxis, SPE.shaderChunks.floatOverLifetime, SPE.shaderChunks.colorOverLifetime, SPE.shaderChunks.paramFetchingFunctions, SPE.shaderChunks.forceFetchingFunctions, SPE.shaderChunks.rotationFunctions, 
"void main() {\n    highp float age = getAge();\n    highp float alive = getAlive();\n    highp float maxAge = getMaxAge();\n    highp float positionInTime = (age / maxAge);\n    highp float isAlive = when_gt( alive, 0.0 );\n    #ifdef SHOULD_WIGGLE_PARTICLES\n        float wiggleAmount = positionInTime * getWiggle();\n        float wiggleSin = isAlive * sin( wiggleAmount );\n        float wiggleCos = isAlive * cos( wiggleAmount );\n    #endif\n    vec3 vel = getVelocity( age );\n    vec3 accel = getAcceleration( age );\n    vec3 force = vec3( 0.0 );\n    vec3 pos = vec3( position );\n    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;\n    force += vel;\n    force *= drag;\n    force += accel * age;\n    pos += force;\n    #ifdef SHOULD_WIGGLE_PARTICLES\n        pos.x += wiggleSin;\n        pos.y += wiggleCos;\n        pos.z += wiggleSin;\n    #endif\n    #ifdef SHOULD_ROTATE_PARTICLES\n        pos = getRotation( pos, positionInTime );\n    #endif\n    vec4 mvPos = modelViewMatrix * vec4( pos, 1.0 );\n    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;\n    #ifdef HAS_PERSPECTIVE\n        float perspective = scale / length( mvPos.xyz );\n    #else\n        float perspective = 1.0;\n    #endif\n    float pointSizePerspective = pointSize * perspective;\n    #ifdef COLORIZE\n       vec3 c = isAlive * getColorOverLifetime(\n           positionInTime,\n           unpackColor( color.x ),\n           unpackColor( color.y ),\n           unpackColor( color.z ),\n           unpackColor( color.w )\n       );\n    #else\n       vec3 c = vec3(1.0);\n    #endif\n    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );\n    vColor = vec4( c, o );\n    #ifdef SHOULD_ROTATE_TEXTURE\n        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );\n    #endif\n    #ifdef SHOULD_CALCULATE_SPRITE\n        float framesX = textureAnimation.x;\n        float framesY = textureAnimation.y;\n        float loopCount = textureAnimation.w;\n        float totalFrames = textureAnimation.z;\n        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );\n        float column = floor(mod( frameNumber, framesX ));\n        float row = floor( (frameNumber - column) / framesX );\n        float columnNorm = column / framesX;\n        float rowNorm = row / framesY;\n        vSpriteSheet.x = 1.0 / framesX;\n        vSpriteSheet.y = 1.0 / framesY;\n        vSpriteSheet.z = columnNorm;\n        vSpriteSheet.w = rowNorm;\n    #endif\n    gl_PointSize = pointSizePerspective;\n    gl_Position = projectionMatrix * mvPos;", 
THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"), fragment:[SPE.shaderChunks.uniforms, THREE.ShaderChunk.common, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, SPE.shaderChunks.varyings, SPE.shaderChunks.branchAvoidanceFunctions, "void main() {\n    vec3 outgoingLight = vColor.xyz;\n    \n    #ifdef ALPHATEST\n       if ( vColor.w < float(ALPHATEST) ) discard;\n    #endif", SPE.shaderChunks.rotateTexture, THREE.ShaderChunk.logdepthbuf_fragment, "    outgoingLight = vColor.xyz * rotatedTexture.xyz;", 
THREE.ShaderChunk.fog_fragment, "    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );\n}"].join("\n")};
SPE.utils = {types:{BOOLEAN:"boolean", STRING:"string", NUMBER:"number", OBJECT:"object"}, ensureTypedArg:function(a, f, l) {
	return typeof a === f ? a : l;
}, ensureArrayTypedArg:function(a, f, l) {
	if (Array.isArray(a)) {
		for (var b = a.length - 1;0 <= b;--b) {
			if (typeof a[b] !== f) {
				return l;
			}
		}
		return a;
	}
	return this.ensureTypedArg(a, f, l);
}, ensureInstanceOf:function(a, f, l) {
	return void 0 !== f && a instanceof f ? a : l;
}, ensureArrayInstanceOf:function(a, f, l) {
	if (Array.isArray(a)) {
		for (var b = a.length - 1;0 <= b;--b) {
			if (void 0 !== f && 0 == a[b] instanceof f) {
				return l;
			}
		}
		return a;
	}
	return this.ensureInstanceOf(a, f, l);
}, ensureValueOverLifetimeCompliance:function(a, f, l) {
	f = f || 3;
	l = l || 3;
	!1 === Array.isArray(a._value) && (a._value = [a._value]);
	!1 === Array.isArray(a._spread) && (a._spread = [a._spread]);
	var b = this.clamp(a._value.length, f, l);
	f = this.clamp(a._spread.length, f, l);
	b = Math.max(b, f);
	a._value.length !== b && (a._value = this.interpolateArray(a._value, b));
	a._spread.length !== b && (a._spread = this.interpolateArray(a._spread, b));
}, interpolateArray:function(a, f) {
	for (var l = a.length, b = ["function" == typeof a[0].clone ? a[0].clone() : a[0]], k = (l - 1) / (f - 1), h = 1;f - 1 > h;++h) {
		var c = h * k, e = Math.floor(c);
		b[h] = this.lerpTypeAgnostic(a[e], a[Math.ceil(c)], c - e);
	}
	return b.push("function" == typeof a[l - 1].clone ? a[l - 1].clone() : a[l - 1]), b;
}, clamp:function(a, f, l) {
	return Math.max(f, Math.min(a, l));
}, zeroToEpsilon:function(a, f) {
	var l = a;
	return l = f ? 1E-4 * Math.random() : 1E-5, 0 > a && -1E-5 < a && (l = -l), l;
}, lerpTypeAgnostic:function(a, f, l) {
	var b, k = this.types;
	return typeof a === k.NUMBER && typeof f === k.NUMBER ? a + (f - a) * l : a instanceof THREE.Vector2 && f instanceof THREE.Vector2 ? (b = a.clone(), b.x = this.lerp(a.x, f.x, l), b.y = this.lerp(a.y, f.y, l), b) : a instanceof THREE.Vector3 && f instanceof THREE.Vector3 ? (b = a.clone(), b.x = this.lerp(a.x, f.x, l), b.y = this.lerp(a.y, f.y, l), b.z = this.lerp(a.z, f.z, l), b) : a instanceof THREE.Vector4 && f instanceof THREE.Vector4 ? (b = a.clone(), b.x = this.lerp(a.x, f.x, l), b.y = this.lerp(a.y, 
	f.y, l), b.z = this.lerp(a.z, f.z, l), b.w = this.lerp(a.w, f.w, l), b) : a instanceof THREE.Color && f instanceof THREE.Color ? (b = a.clone(), b.r = this.lerp(a.r, f.r, l), b.g = this.lerp(a.g, f.g, l), b.b = this.lerp(a.b, f.b, l), b) : void console.warn("Invalid argument types, or argument types do not match:", a, f);
}, lerp:function(a, f, l) {
	return a + (f - a) * l;
}, roundToNearestMultiple:function(a, f) {
	var l = 0;
	return 0 === f ? a : (l = Math.abs(a) % f, 0 === l ? a : 0 > a ? -(Math.abs(a) - l) : a + f - l);
}, arrayValuesAreEqual:function(a) {
	for (var f = 0;f < a.length - 1;++f) {
		if (a[f] !== a[f + 1]) {
			return !1;
		}
	}
	return !0;
}, randomFloat:function(a, f) {
	return a + f * (Math.random() - .5);
}, randomVector3:function(a, f, l, b, k) {
	var h = l.x + (Math.random() * b.x - .5 * b.x), c = l.y + (Math.random() * b.y - .5 * b.y);
	l = l.z + (Math.random() * b.z - .5 * b.z);
	k && (h = .5 * -k.x + this.roundToNearestMultiple(h, k.x), c = .5 * -k.y + this.roundToNearestMultiple(c, k.y), l = .5 * -k.z + this.roundToNearestMultiple(l, k.z));
	a.typedArray.setVec3Components(f, h, c, l);
}, randomColor:function(a, f, l, b) {
	var k = l.r + Math.random() * b.x, h = l.g + Math.random() * b.y;
	l = l.b + Math.random() * b.z;
	k = this.clamp(k, 0, 1);
	h = this.clamp(h, 0, 1);
	l = this.clamp(l, 0, 1);
	a.typedArray.setVec3Components(f, k, h, l);
}, randomColorAsHex:function() {
	var a = new THREE.Color;
	return function(f, l, b, k) {
		for (var h = b.length, c = [], e = 0;h > e;++e) {
			var g = k[e];
			a.copy(b[e]);
			a.r += Math.random() * g.x - .5 * g.x;
			a.g += Math.random() * g.y - .5 * g.y;
			a.b += Math.random() * g.z - .5 * g.z;
			a.r = this.clamp(a.r, 0, 1);
			a.g = this.clamp(a.g, 0, 1);
			a.b = this.clamp(a.b, 0, 1);
			c.push(a.getHex());
		}
		f.typedArray.setVec4Components(l, c[0], c[1], c[2], c[3]);
	};
}(), randomVector3OnSphere:function(a, f, l, b, k, h, c, e) {
	e = 2 * Math.random() - 1;
	var g = 6.2832 * Math.random(), q = Math.sqrt(1 - e * e);
	b = this.randomFloat(b, k);
	c && (b = Math.round(b / c) * c);
	c = q * Math.cos(g) * b;
	g = q * Math.sin(g) * b;
	c *= h.x;
	g *= h.y;
	h = e * b * h.z;
	c += l.x;
	g += l.y;
	h += l.z;
	a.typedArray.setVec3Components(f, c, g, h);
}, seededRandom:function(a) {
	a = 1E4 * Math.sin(a);
	return a - (0 | a);
}, randomVector3OnDisc:function(a, f, l, b, k, h, c) {
	var e = 6.2832 * Math.random();
	b = Math.abs(this.randomFloat(b, k));
	c && (b = Math.round(b / c) * c);
	c = Math.cos(e) * b;
	e = Math.sin(e) * b;
	c *= h.x;
	e *= h.y;
	c += l.x;
	e += l.y;
	l = 0 + l.z;
	a.typedArray.setVec3Components(f, c, e, l);
}, randomDirectionVector3OnSphere:function() {
	var a = new THREE.Vector3;
	return function(f, l, b, k, h, c, e, g) {
		a.copy(c);
		a.x -= b;
		a.y -= k;
		a.z -= h;
		a.normalize().multiplyScalar(-this.randomFloat(e, g));
		f.typedArray.setVec3Components(l, a.x, a.y, a.z);
	};
}(), randomDirectionVector3OnDisc:function() {
	var a = new THREE.Vector3;
	return function(f, l, b, k, h, c, e, g) {
		a.copy(c);
		a.x -= b;
		a.y -= k;
		a.z -= h;
		a.normalize().multiplyScalar(-this.randomFloat(e, g));
		f.typedArray.setVec3Components(l, a.x, a.y, 0);
	};
}(), getPackedRotationAxis:function() {
	var a = new THREE.Vector3, f = new THREE.Vector3, l = new THREE.Color, b = new THREE.Vector3(1, 1, 1);
	return function(k, h) {
		return a.copy(k).normalize(), f.copy(h).normalize(), a.x += .5 * -h.x + Math.random() * h.x, a.y += .5 * -h.y + Math.random() * h.y, a.z += .5 * -h.z + Math.random() * h.z, a.normalize().add(b).multiplyScalar(.5), l.setRGB(a.x, a.y, a.z), l.getHex();
	};
}()};
SPE.Group = function(a) {
	var f = SPE.utils, l = f.types;
	a = f.ensureTypedArg(a, l.OBJECT, {});
	a.texture = f.ensureTypedArg(a.texture, l.OBJECT, {});
	this.uuid = THREE.Math.generateUUID();
	this.fixedTimeStep = f.ensureTypedArg(a.fixedTimeStep, l.NUMBER, .016);
	this.texture = f.ensureInstanceOf(a.texture.value, THREE.Texture, null);
	this.textureFrames = f.ensureInstanceOf(a.texture.frames, THREE.Vector2, new THREE.Vector2(1, 1));
	this.textureFrameCount = f.ensureTypedArg(a.texture.frameCount, l.NUMBER, this.textureFrames.x * this.textureFrames.y);
	this.textureLoop = f.ensureTypedArg(a.texture.loop, l.NUMBER, 1);
	this.textureFrames.max(new THREE.Vector2(1, 1));
	this.hasPerspective = f.ensureTypedArg(a.hasPerspective, l.BOOLEAN, !0);
	this.colorize = f.ensureTypedArg(a.colorize, l.BOOLEAN, !0);
	this.maxParticleCount = f.ensureTypedArg(a.maxParticleCount, l.NUMBER, null);
	this.blending = f.ensureTypedArg(a.blending, l.NUMBER, THREE.AdditiveBlending);
	this.transparent = f.ensureTypedArg(a.transparent, l.BOOLEAN, !0);
	this.alphaTest = parseFloat(f.ensureTypedArg(a.alphaTest, l.NUMBER, 0));
	this.depthWrite = f.ensureTypedArg(a.depthWrite, l.BOOLEAN, !1);
	this.depthTest = f.ensureTypedArg(a.depthTest, l.BOOLEAN, !0);
	this.fog = f.ensureTypedArg(a.fog, l.BOOLEAN, !0);
	this.scale = f.ensureTypedArg(a.scale, l.NUMBER, 300);
	this.emitters = [];
	this.emitterIDs = [];
	this._pool = [];
	this._poolCreationSettings = null;
	this._createNewWhenPoolEmpty = 0;
	this._attributesNeedDynamicReset = this._attributesNeedRefresh = !1;
	this.particleCount = 0;
	this.uniforms = {texture:{type:"t", value:this.texture}, textureAnimation:{type:"v4", value:new THREE.Vector4(this.textureFrames.x, this.textureFrames.y, this.textureFrameCount, Math.max(Math.abs(this.textureLoop), 1))}, fogColor:{type:"c", value:null}, fogNear:{type:"f", value:10}, fogFar:{type:"f", value:200}, fogDensity:{type:"f", value:.5}, deltaTime:{type:"f", value:0}, runTime:{type:"f", value:0}, scale:{type:"f", value:this.scale}};
	this.defines = {HAS_PERSPECTIVE:this.hasPerspective, COLORIZE:this.colorize, VALUE_OVER_LIFETIME_LENGTH:SPE.valueOverLifetimeLength, SHOULD_ROTATE_TEXTURE:!1, SHOULD_ROTATE_PARTICLES:!1, SHOULD_WIGGLE_PARTICLES:!1, SHOULD_CALCULATE_SPRITE:1 < this.textureFrames.x || 1 < this.textureFrames.y};
	this.attributes = {position:new SPE.ShaderAttribute("v3", !0), acceleration:new SPE.ShaderAttribute("v4", !0), velocity:new SPE.ShaderAttribute("v3", !0), rotation:new SPE.ShaderAttribute("v4", !0), rotationCenter:new SPE.ShaderAttribute("v3", !0), params:new SPE.ShaderAttribute("v4", !0), size:new SPE.ShaderAttribute("v4", !0), angle:new SPE.ShaderAttribute("v4", !0), color:new SPE.ShaderAttribute("v4", !0), opacity:new SPE.ShaderAttribute("v4", !0)};
	this.attributeKeys = Object.keys(this.attributes);
	this.attributeCount = this.attributeKeys.length;
	this.material = new THREE.ShaderMaterial({uniforms:this.uniforms, vertexShader:SPE.shaders.vertex, fragmentShader:SPE.shaders.fragment, blending:this.blending, transparent:this.transparent, alphaTest:this.alphaTest, depthWrite:this.depthWrite, depthTest:this.depthTest, defines:this.defines, fog:this.fog});
	this.geometry = new THREE.BufferGeometry;
	this.mesh = new THREE.Points(this.geometry, this.material);
	null === this.maxParticleCount && console.warn("SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.");
};
SPE.Group.constructor = SPE.Group;
SPE.Group.prototype._updateDefines = function() {
	var a, f = this.emitters, l = f.length - 1, b = this.defines;
	for (l;0 <= l;--l) {
		a = f[l], b.SHOULD_CALCULATE_SPRITE || (b.SHOULD_ROTATE_TEXTURE = b.SHOULD_ROTATE_TEXTURE || !!Math.max(Math.max.apply(null, a.angle.value), Math.max.apply(null, a.angle.spread))), b.SHOULD_ROTATE_PARTICLES = b.SHOULD_ROTATE_PARTICLES || !!Math.max(a.rotation.angle, a.rotation.angleSpread), b.SHOULD_WIGGLE_PARTICLES = b.SHOULD_WIGGLE_PARTICLES || !!Math.max(a.wiggle.value, a.wiggle.spread);
	}
	this.material.needsUpdate = !0;
};
SPE.Group.prototype._applyAttributesToGeometry = function() {
	var a, f, l = this.attributes, b = this.geometry, k = b.attributes, h;
	for (h in l) {
		l.hasOwnProperty(h) && (a = l[h], f = k[h], f ? f.array = a.typedArray.array : b.addAttribute(h, a.bufferAttribute), a.bufferAttribute.needsUpdate = !0);
	}
	this.geometry.setDrawRange(0, this.particleCount);
};
SPE.Group.prototype.addEmitter = function(a) {
	if (0 == a instanceof SPE.Emitter) {
		return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", a);
	}
	if (-1 < this.emitterIDs.indexOf(a.uuid)) {
		return void console.error("Emitter already exists in this group. Will not add again.");
	}
	if (null !== a.group) {
		return void console.error("Emitter already belongs to another group. Will not add to requested group.");
	}
	var f = this.attributes, l = this.particleCount, b = l + a.particleCount;
	this.particleCount = b;
	null !== this.maxParticleCount && this.particleCount > this.maxParticleCount && console.warn("SPE.Group: maxParticleCount exceeded. Requesting", this.particleCount, "particles, can support only", this.maxParticleCount);
	a._calculatePPSValue(a.maxAge._value + a.maxAge._spread);
	a._setBufferUpdateRanges(this.attributeKeys);
	a._setAttributeOffset(l);
	a.group = this;
	a.attributes = this.attributes;
	for (var k in f) {
		f.hasOwnProperty(k) && f[k]._createBufferAttribute(null !== this.maxParticleCount ? this.maxParticleCount : this.particleCount);
	}
	for (f = l;b > f;++f) {
		a._assignPositionValue(f), a._assignForceValue(f, "velocity"), a._assignForceValue(f, "acceleration"), a._assignAbsLifetimeValue(f, "opacity"), a._assignAbsLifetimeValue(f, "size"), a._assignAngleValue(f), a._assignRotationValue(f), a._assignParamsValue(f), a._assignColorValue(f);
	}
	return this._applyAttributesToGeometry(), this.emitters.push(a), this.emitterIDs.push(a.uuid), this._updateDefines(a), this.material.needsUpdate = !0, this.geometry.needsUpdate = !0, this._attributesNeedRefresh = !0, this;
};
SPE.Group.prototype.removeEmitter = function(a) {
	var f = this.emitterIDs.indexOf(a.uuid);
	if (0 == a instanceof SPE.Emitter) {
		return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", a);
	}
	if (-1 === f) {
		return void console.error("Emitter does not exist in this group. Will not remove.");
	}
	for (var l = a.attributeOffset, b = l + a.particleCount, k = this.attributes.params.typedArray, h = l;b > h;++h) {
		k.array[4 * h] = 0, k.array[4 * h + 1] = 0;
	}
	this.emitters.splice(f, 1);
	this.emitterIDs.splice(f, 1);
	for (var c in this.attributes) {
		this.attributes.hasOwnProperty(c) && this.attributes[c].splice(l, b);
	}
	this.particleCount -= a.particleCount;
	a._onRemove();
	this._attributesNeedRefresh = !0;
};
SPE.Group.prototype.getFromPool = function() {
	var a = this._pool, f = this._createNewWhenPoolEmpty;
	return a.length ? a.pop() : f ? new SPE.Emitter(this._poolCreationSettings) : null;
};
SPE.Group.prototype.releaseIntoPool = function(a) {
	return 0 == a instanceof SPE.Emitter ? void console.error("Argument is not instanceof SPE.Emitter:", a) : (a.reset(), this._pool.unshift(a), this);
};
SPE.Group.prototype.getPool = function() {
	return this._pool;
};
SPE.Group.prototype.addPool = function(a, f, l) {
	this._poolCreationSettings = f;
	this._createNewWhenPoolEmpty = !!l;
	for (var b = 0;a > b;++b) {
		l = Array.isArray(f) ? new SPE.Emitter(f[b]) : new SPE.Emitter(f), this.addEmitter(l), this.releaseIntoPool(l);
	}
	return this;
};
SPE.Group.prototype._triggerSingleEmitter = function(a) {
	var f = this.getFromPool(), l = this;
	return null === f ? void console.log("SPE.Group pool ran out.") : (a instanceof THREE.Vector3 && (f.position.value.copy(a), f.position.value = f.position.value), f.enable(), setTimeout(function() {
		f.disable();
		l.releaseIntoPool(f);
	}, 1E3 * Math.max(f.duration, f.maxAge.value + f.maxAge.spread)), this);
};
SPE.Group.prototype.triggerPoolEmitter = function(a, f) {
	if ("number" == typeof a && 1 < a) {
		for (var l = 0;a > l;++l) {
			this._triggerSingleEmitter(f);
		}
	} else {
		this._triggerSingleEmitter(f);
	}
	return this;
};
SPE.Group.prototype._updateUniforms = function(a) {
	this.uniforms.runTime.value += a;
	this.uniforms.deltaTime.value = a;
};
SPE.Group.prototype._resetBufferRanges = function() {
	var a = this.attributeKeys, f = this.attributeCount - 1, l = this.attributes;
	for (f;0 <= f;--f) {
		l[a[f]].resetUpdateRange();
	}
};
SPE.Group.prototype._updateBuffers = function(a) {
	var f, l = this.attributeKeys, b = this.attributeCount - 1, k = this.attributes, h = a.bufferUpdateRanges;
	for (b;0 <= b;--b) {
		f = l[b], a = h[f], f = k[f], f.setUpdateRange(a.min, a.max), f.flagUpdate();
	}
};
SPE.Group.prototype.tick = function(a) {
	var f = this.emitters, l = f.length, b = a || this.fixedTimeStep, k = this.attributeKeys, h = this.attributes;
	if (this._updateUniforms(b), this._resetBufferRanges(), 0 !== l || !1 !== this._attributesNeedRefresh || !1 !== this._attributesNeedDynamicReset) {
		var c;
		for (a = 0;l > a;++a) {
			c = f[a], c.tick(b), this._updateBuffers(c);
		}
		if (!0 === this._attributesNeedDynamicReset) {
			for (a = this.attributeCount - 1;0 <= a;--a) {
				h[k[a]].resetDynamic();
			}
			this._attributesNeedDynamicReset = !1;
		}
		if (!0 === this._attributesNeedRefresh) {
			for (a = this.attributeCount - 1;0 <= a;--a) {
				h[k[a]].forceUpdateAll();
			}
			this._attributesNeedRefresh = !1;
			this._attributesNeedDynamicReset = !0;
		}
	}
};
SPE.Group.prototype.dispose = function() {
	return this.geometry.dispose(), this.material.dispose(), this;
};
SPE.Emitter = function(a) {
	var f = SPE.utils, l = f.types, b = SPE.valueOverLifetimeLength;
	a = f.ensureTypedArg(a, l.OBJECT, {});
	a.position = f.ensureTypedArg(a.position, l.OBJECT, {});
	a.velocity = f.ensureTypedArg(a.velocity, l.OBJECT, {});
	a.acceleration = f.ensureTypedArg(a.acceleration, l.OBJECT, {});
	a.radius = f.ensureTypedArg(a.radius, l.OBJECT, {});
	a.drag = f.ensureTypedArg(a.drag, l.OBJECT, {});
	a.rotation = f.ensureTypedArg(a.rotation, l.OBJECT, {});
	a.color = f.ensureTypedArg(a.color, l.OBJECT, {});
	a.opacity = f.ensureTypedArg(a.opacity, l.OBJECT, {});
	a.size = f.ensureTypedArg(a.size, l.OBJECT, {});
	a.angle = f.ensureTypedArg(a.angle, l.OBJECT, {});
	a.wiggle = f.ensureTypedArg(a.wiggle, l.OBJECT, {});
	a.maxAge = f.ensureTypedArg(a.maxAge, l.OBJECT, {});
	a.onParticleSpawn && console.warn("onParticleSpawn has been removed. Please set properties directly to alter values at runtime.");
	this.uuid = THREE.Math.generateUUID();
	this.type = f.ensureTypedArg(a.type, l.NUMBER, SPE.distributions.BOX);
	this.position = {_value:f.ensureInstanceOf(a.position.value, THREE.Vector3, new THREE.Vector3), _spread:f.ensureInstanceOf(a.position.spread, THREE.Vector3, new THREE.Vector3), _spreadClamp:f.ensureInstanceOf(a.position.spreadClamp, THREE.Vector3, new THREE.Vector3), _distribution:f.ensureTypedArg(a.position.distribution, l.NUMBER, this.type), _randomise:f.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1), _radius:f.ensureTypedArg(a.position.radius, l.NUMBER, 10), _radiusScale:f.ensureInstanceOf(a.position.radiusScale, 
	THREE.Vector3, new THREE.Vector3(1, 1, 1)), _distributionClamp:f.ensureTypedArg(a.position.distributionClamp, l.NUMBER, 0)};
	this.velocity = {_value:f.ensureInstanceOf(a.velocity.value, THREE.Vector3, new THREE.Vector3), _spread:f.ensureInstanceOf(a.velocity.spread, THREE.Vector3, new THREE.Vector3), _distribution:f.ensureTypedArg(a.velocity.distribution, l.NUMBER, this.type), _randomise:f.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1)};
	this.acceleration = {_value:f.ensureInstanceOf(a.acceleration.value, THREE.Vector3, new THREE.Vector3), _spread:f.ensureInstanceOf(a.acceleration.spread, THREE.Vector3, new THREE.Vector3), _distribution:f.ensureTypedArg(a.acceleration.distribution, l.NUMBER, this.type), _randomise:f.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1)};
	this.drag = {_value:f.ensureTypedArg(a.drag.value, l.NUMBER, 0), _spread:f.ensureTypedArg(a.drag.spread, l.NUMBER, 0), _randomise:f.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1)};
	this.wiggle = {_value:f.ensureTypedArg(a.wiggle.value, l.NUMBER, 0), _spread:f.ensureTypedArg(a.wiggle.spread, l.NUMBER, 0)};
	this.rotation = {_axis:f.ensureInstanceOf(a.rotation.axis, THREE.Vector3, new THREE.Vector3(0, 1, 0)), _axisSpread:f.ensureInstanceOf(a.rotation.axisSpread, THREE.Vector3, new THREE.Vector3), _angle:f.ensureTypedArg(a.rotation.angle, l.NUMBER, 0), _angleSpread:f.ensureTypedArg(a.rotation.angleSpread, l.NUMBER, 0), _static:f.ensureTypedArg(a.rotation["static"], l.BOOLEAN, !1), _center:f.ensureInstanceOf(a.rotation.center, THREE.Vector3, this.position._value.clone()), _randomise:f.ensureTypedArg(a.position.randomise, 
	l.BOOLEAN, !1)};
	this.maxAge = {_value:f.ensureTypedArg(a.maxAge.value, l.NUMBER, 2), _spread:f.ensureTypedArg(a.maxAge.spread, l.NUMBER, 0)};
	this.color = {_value:f.ensureArrayInstanceOf(a.color.value, THREE.Color, new THREE.Color), _spread:f.ensureArrayInstanceOf(a.color.spread, THREE.Vector3, new THREE.Vector3), _randomise:f.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1)};
	this.opacity = {_value:f.ensureArrayTypedArg(a.opacity.value, l.NUMBER, 1), _spread:f.ensureArrayTypedArg(a.opacity.spread, l.NUMBER, 0), _randomise:f.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1)};
	this.size = {_value:f.ensureArrayTypedArg(a.size.value, l.NUMBER, 1), _spread:f.ensureArrayTypedArg(a.size.spread, l.NUMBER, 0), _randomise:f.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1)};
	this.angle = {_value:f.ensureArrayTypedArg(a.angle.value, l.NUMBER, 0), _spread:f.ensureArrayTypedArg(a.angle.spread, l.NUMBER, 0), _randomise:f.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1)};
	this.particleCount = f.ensureTypedArg(a.particleCount, l.NUMBER, 100);
	this.duration = f.ensureTypedArg(a.duration, l.NUMBER, null);
	this.isStatic = f.ensureTypedArg(a.isStatic, l.BOOLEAN, !1);
	this.activeMultiplier = f.ensureTypedArg(a.activeMultiplier, l.NUMBER, 1);
	this.direction = f.ensureTypedArg(a.direction, l.NUMBER, 1);
	this.alive = f.ensureTypedArg(a.alive, l.BOOLEAN, !0);
	this.activeParticleCount = this.age = this.attributeEnd = this.attributeOffset = this.activationIndex = this.particlesPerSecond = 0;
	this.paramsArray = this.attributes = this.group = null;
	this.resetFlags = {position:f.ensureTypedArg(a.position.randomise, l.BOOLEAN, !1) || f.ensureTypedArg(a.radius.randomise, l.BOOLEAN, !1), velocity:f.ensureTypedArg(a.velocity.randomise, l.BOOLEAN, !1), acceleration:f.ensureTypedArg(a.acceleration.randomise, l.BOOLEAN, !1) || f.ensureTypedArg(a.drag.randomise, l.BOOLEAN, !1), rotation:f.ensureTypedArg(a.rotation.randomise, l.BOOLEAN, !1), rotationCenter:f.ensureTypedArg(a.rotation.randomise, l.BOOLEAN, !1), size:f.ensureTypedArg(a.size.randomise, 
	l.BOOLEAN, !1), color:f.ensureTypedArg(a.color.randomise, l.BOOLEAN, !1), opacity:f.ensureTypedArg(a.opacity.randomise, l.BOOLEAN, !1), angle:f.ensureTypedArg(a.angle.randomise, l.BOOLEAN, !1)};
	this.updateFlags = {};
	this.updateCounts = {};
	this.updateMap = {maxAge:"params", position:"position", velocity:"velocity", acceleration:"acceleration", drag:"acceleration", wiggle:"params", rotation:"rotation", size:"size", color:"color", opacity:"opacity", angle:"angle"};
	for (var k in this.updateMap) {
		this.updateMap.hasOwnProperty(k) && (this.updateCounts[this.updateMap[k]] = 0, this.updateFlags[this.updateMap[k]] = !1, this._createGetterSetters(this[k], k));
	}
	this.bufferUpdateRanges = {};
	this.attributeKeys = null;
	this.attributeCount = 0;
	f.ensureValueOverLifetimeCompliance(this.color, b, b);
	f.ensureValueOverLifetimeCompliance(this.opacity, b, b);
	f.ensureValueOverLifetimeCompliance(this.size, b, b);
	f.ensureValueOverLifetimeCompliance(this.angle, b, b);
};
SPE.Emitter.constructor = SPE.Emitter;
SPE.Emitter.prototype._createGetterSetters = function(a, f) {
	var l = this, b;
	for (b in a) {
		if (a.hasOwnProperty(b)) {
			var k = b.replace("_", "");
			Object.defineProperty(a, k, {get:function(a) {
				return function() {
					return this[a];
				};
			}(b), set:function(a) {
				return function(b) {
					var c = l.updateMap[f], g = this[a], h = SPE.valueOverLifetimeLength;
					"_rotationCenter" === a ? (l.updateFlags.rotationCenter = !0, l.updateCounts.rotationCenter = 0) : "_randomise" === a ? l.resetFlags[c] = b : (l.updateFlags[c] = !0, l.updateCounts[c] = 0);
					l.group._updateDefines();
					this[a] = b;
					Array.isArray(g) && SPE.utils.ensureValueOverLifetimeCompliance(l[f], h, h);
				};
			}(b)});
		}
	}
};
SPE.Emitter.prototype._setBufferUpdateRanges = function(a) {
	this.attributeKeys = a;
	this.attributeCount = a.length;
	for (var f = this.attributeCount - 1;0 <= f;--f) {
		this.bufferUpdateRanges[a[f]] = {min:Number.POSITIVE_INFINITY, max:Number.NEGATIVE_INFINITY};
	}
};
SPE.Emitter.prototype._calculatePPSValue = function(a) {
	var f = this.particleCount;
	this.duration ? this.particlesPerSecond = f / (a < this.duration ? a : this.duration) : this.particlesPerSecond = f / a;
};
SPE.Emitter.prototype._setAttributeOffset = function(a) {
	this.activationIndex = this.attributeOffset = a;
	this.activationEnd = a + this.particleCount;
};
SPE.Emitter.prototype._assignValue = function(a, f) {
	switch(a) {
		case "position":
			this._assignPositionValue(f);
			break;
		case "velocity":
		;
		case "acceleration":
			this._assignForceValue(f, a);
			break;
		case "size":
		;
		case "opacity":
			this._assignAbsLifetimeValue(f, a);
			break;
		case "angle":
			this._assignAngleValue(f);
			break;
		case "params":
			this._assignParamsValue(f);
			break;
		case "rotation":
			this._assignRotationValue(f);
			break;
		case "color":
			this._assignColorValue(f);
	}
};
SPE.Emitter.prototype._assignPositionValue = function(a) {
	var f = SPE.distributions, l = SPE.utils, b = this.position, k = this.attributes.position, h = b._value, c = b._spread;
	switch(b._distribution) {
		case f.BOX:
			l.randomVector3(k, a, h, c, b._spreadClamp);
			break;
		case f.SPHERE:
			l.randomVector3OnSphere(k, a, h, b._radius, b._spread.x, b._radiusScale, b._spreadClamp.x, b._distributionClamp || this.particleCount);
			break;
		case f.DISC:
			l.randomVector3OnDisc(k, a, h, b._radius, b._spread.x, b._radiusScale, b._spreadClamp.x);
	}
};
SPE.Emitter.prototype._assignForceValue = function(a, f) {
	var l, b, k, h;
	b = SPE.distributions;
	var c = SPE.utils, e = this[f];
	k = e._value;
	l = e._spread;
	switch(e._distribution) {
		case b.BOX:
			c.randomVector3(this.attributes[f], a, k, l);
			break;
		case b.SPHERE:
			l = this.attributes.position.typedArray.array;
			h = 3 * a;
			b = l[h];
			k = l[h + 1];
			l = l[h + 2];
			c.randomDirectionVector3OnSphere(this.attributes[f], a, b, k, l, this.position._value, e._value.x, e._spread.x);
			break;
		case b.DISC:
			l = this.attributes.position.typedArray.array, h = 3 * a, b = l[h], k = l[h + 1], l = l[h + 2], c.randomDirectionVector3OnDisc(this.attributes[f], a, b, k, l, this.position._value, e._value.x, e._spread.x);
	}
	"acceleration" === f && (f = c.clamp(c.randomFloat(this.drag._value, this.drag._spread), 0, 1), this.attributes.acceleration.typedArray.array[4 * a + 3] = f);
};
SPE.Emitter.prototype._assignAbsLifetimeValue = function(a, f) {
	var l, b = this.attributes[f].typedArray;
	f = this[f];
	var k = SPE.utils;
	k.arrayValuesAreEqual(f._value) && k.arrayValuesAreEqual(f._spread) ? (l = Math.abs(k.randomFloat(f._value[0], f._spread[0])), b.setVec4Components(a, l, l, l, l)) : b.setVec4Components(a, Math.abs(k.randomFloat(f._value[0], f._spread[0])), Math.abs(k.randomFloat(f._value[1], f._spread[1])), Math.abs(k.randomFloat(f._value[2], f._spread[2])), Math.abs(k.randomFloat(f._value[3], f._spread[3])));
};
SPE.Emitter.prototype._assignAngleValue = function(a) {
	var f, l = this.attributes.angle.typedArray, b = this.angle, k = SPE.utils;
	k.arrayValuesAreEqual(b._value) && k.arrayValuesAreEqual(b._spread) ? (f = k.randomFloat(b._value[0], b._spread[0]), l.setVec4Components(a, f, f, f, f)) : l.setVec4Components(a, k.randomFloat(b._value[0], b._spread[0]), k.randomFloat(b._value[1], b._spread[1]), k.randomFloat(b._value[2], b._spread[2]), k.randomFloat(b._value[3], b._spread[3]));
};
SPE.Emitter.prototype._assignParamsValue = function(a) {
	this.attributes.params.typedArray.setVec4Components(a, this.isStatic ? 1 : 0, 0, Math.abs(SPE.utils.randomFloat(this.maxAge._value, this.maxAge._spread)), SPE.utils.randomFloat(this.wiggle._value, this.wiggle._spread));
};
SPE.Emitter.prototype._assignRotationValue = function(a) {
	this.attributes.rotation.typedArray.setVec3Components(a, SPE.utils.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread), SPE.utils.randomFloat(this.rotation._angle, this.rotation._angleSpread), this.rotation._static ? 0 : 1);
	this.attributes.rotationCenter.typedArray.setVec3(a, this.rotation._center);
};
SPE.Emitter.prototype._assignColorValue = function(a) {
	SPE.utils.randomColorAsHex(this.attributes.color, a, this.color._value, this.color._spread);
};
SPE.Emitter.prototype._resetParticle = function(a) {
	for (var f, l, b = this.resetFlags, k = this.updateFlags, h = this.updateCounts, c = this.attributeKeys, e = this.attributeCount - 1;0 <= e;--e) {
		f = c[e], l = k[f], !0 !== b[f] && !0 !== l || (this._assignValue(f, a), this._updateAttributeUpdateRange(f, a), !0 === l && h[f] === this.particleCount ? (k[f] = !1, h[f] = 0) : 1 == l && ++h[f]);
	}
};
SPE.Emitter.prototype._updateAttributeUpdateRange = function(a, f) {
	a = this.bufferUpdateRanges[a];
	a.min = Math.min(f, a.min);
	a.max = Math.max(f, a.max);
};
SPE.Emitter.prototype._resetBufferRanges = function() {
	var a, f = this.bufferUpdateRanges, l = this.bufferUpdateKeys, b = this.bufferUpdateCount - 1;
	for (b;0 <= b;--b) {
		a = l[b], f[a].min = Number.POSITIVE_INFINITY, f[a].max = Number.NEGATIVE_INFINITY;
	}
};
SPE.Emitter.prototype._onRemove = function() {
	this.activeParticleCount = this.activationIndex = this.attributeOffset = this.particlesPerSecond = 0;
	this.paramsArray = this.attributes = this.group = null;
	this.age = 0;
};
SPE.Emitter.prototype._decrementParticleCount = function() {
	--this.activeParticleCount;
};
SPE.Emitter.prototype._incrementParticleCount = function() {
	++this.activeParticleCount;
};
SPE.Emitter.prototype._checkParticleAges = function(a, f, l, b) {
	for (var k, h, c, e = f - 1;e >= a;--e) {
		f = 4 * e, c = l[f], 0 !== c && (h = l[f + 1], k = l[f + 2], 1 === this.direction ? (h += b, h >= k && (h = 0, c = 0, this._decrementParticleCount())) : (h -= b, 0 >= h && (h = k, c = 0, this._decrementParticleCount())), l[f] = c, l[f + 1] = h, this._updateAttributeUpdateRange("params", e));
	}
};
SPE.Emitter.prototype._activateParticles = function(a, f, l, b) {
	for (var k, h, c = this.direction, e = a;f > e;++e) {
		k = 4 * e, 0 != l[k] && 1 !== this.particleCount || (this._incrementParticleCount(), l[k] = 1, this._resetParticle(e), h = b * (e - a), l[k + 1] = -1 === c ? l[k + 2] - h : h, this._updateAttributeUpdateRange("params", e));
	}
};
SPE.Emitter.prototype.tick = function(a) {
	if (!this.isStatic) {
		null === this.paramsArray && (this.paramsArray = this.attributes.params.typedArray.array);
		var f = this.attributeOffset, l = f + this.particleCount, b = this.paramsArray, k = this.particlesPerSecond * this.activeMultiplier * a, h = this.activationIndex;
		if (this._resetBufferRanges(), this._checkParticleAges(f, l, b, a), !1 === this.alive) {
			return void(this.age = 0);
		}
		if (null !== this.duration && this.age > this.duration) {
			return this.alive = !1, void(this.age = 0);
		}
		var h = 1 === this.particleCount ? h : 0 | h, c = Math.min(h + k, this.activationEnd), e = c - this.activationIndex | 0;
		this._activateParticles(h, c, b, 0 < e ? a / e : 0);
		this.activationIndex += k;
		this.activationIndex > l && (this.activationIndex = f);
		this.age += a;
	}
};
SPE.Emitter.prototype.reset = function(a) {
	if (this.age = 0, this.alive = !1, !0 === a) {
		for (var f = this.attributeOffset, l = this.paramsArray, b = this.attributes.params.bufferAttribute, k = f + this.particleCount - 1;k >= f;--k) {
			a = 4 * k, l[a] = 0, l[a + 1] = 0;
		}
		b.updateRange.offset = 0;
		b.updateRange.count = -1;
		b.needsUpdate = !0;
	}
	return this;
};
SPE.Emitter.prototype.enable = function() {
	return this.alive = !0, this;
};
SPE.Emitter.prototype.disable = function() {
	return this.alive = !1, this;
};
SPE.Emitter.prototype.remove = function() {
	return null !== this.group ? this.group.removeEmitter(this) : console.error("Emitter does not belong to a group, cannot remove."), this;
};
var __extends = this && this.__extends || function(a, f) {
	function l() {
		this.constructor = a;
	}
	for (var b in f) {
		f.hasOwnProperty(b) && (a[b] = f[b]);
	}
	a.prototype = null === f ? Object.create(f) : (l.prototype = f.prototype, new l);
}, spine;
(function(a) {
	var f = function() {
		function a(a, b, c) {
			if (null == a) {
				throw Error("name cannot be null.");
			}
			if (null == b) {
				throw Error("timelines cannot be null.");
			}
			this.name = a;
			this.timelines = b;
			this.duration = c;
		}
		a.prototype.apply = function(a, b, c, h, k, f, l, v) {
			if (null == a) {
				throw Error("skeleton cannot be null.");
			}
			h && 0 != this.duration && (c %= this.duration, 0 < b && (b %= this.duration));
			h = this.timelines;
			for (var e = 0, g = h.length;e < g;e++) {
				h[e].apply(a, b, c, k, f, l, v);
			}
		};
		a.binarySearch = function(a, b, c) {
			void 0 === c && (c = 1);
			var e = 0, g = a.length / c - 2;
			if (0 == g) {
				return c;
			}
			for (var h = g >>> 1;;) {
				a[(h + 1) * c] <= b ? e = h + 1 : g = h;
				if (e == g) {
					return (e + 1) * c;
				}
				h = e + g >>> 1;
			}
		};
		a.linearSearch = function(a, b, c) {
			for (var e = 0, g = a.length - c;e <= g;e += c) {
				if (a[e] > b) {
					return e;
				}
			}
			return -1;
		};
		return a;
	}();
	a.Animation = f;
	(function(a) {
		a[a.rotate = 0] = "rotate";
		a[a.translate = 1] = "translate";
		a[a.scale = 2] = "scale";
		a[a.shear = 3] = "shear";
		a[a.attachment = 4] = "attachment";
		a[a.color = 5] = "color";
		a[a.deform = 6] = "deform";
		a[a.event = 7] = "event";
		a[a.drawOrder = 8] = "drawOrder";
		a[a.ikConstraint = 9] = "ikConstraint";
		a[a.transformConstraint = 10] = "transformConstraint";
		a[a.pathConstraintPosition = 11] = "pathConstraintPosition";
		a[a.pathConstraintSpacing = 12] = "pathConstraintSpacing";
		a[a.pathConstraintMix = 13] = "pathConstraintMix";
	})(a.TimelineType || (a.TimelineType = {}));
	var l = a.TimelineType, b = function() {
		function b(c) {
			if (0 >= c) {
				throw Error("frameCount must be > 0: " + c);
			}
			this.curves = a.Utils.newFloatArray((c - 1) * b.BEZIER_SIZE);
		}
		b.prototype.getFrameCount = function() {
			return this.curves.length / b.BEZIER_SIZE + 1;
		};
		b.prototype.setLinear = function(a) {
			this.curves[a * b.BEZIER_SIZE] = b.LINEAR;
		};
		b.prototype.setStepped = function(a) {
			this.curves[a * b.BEZIER_SIZE] = b.STEPPED;
		};
		b.prototype.getCurveType = function(a) {
			a *= b.BEZIER_SIZE;
			if (a == this.curves.length) {
				return b.LINEAR;
			}
			a = this.curves[a];
			return a == b.LINEAR ? b.LINEAR : a == b.STEPPED ? b.STEPPED : b.BEZIER;
		};
		b.prototype.setCurve = function(a, c, h, k, f) {
			var e = .03 * (2 * -c + k), g = .03 * (2 * -h + f);
			k = .006 * (3 * (c - k) + 1);
			f = .006 * (3 * (h - f) + 1);
			var q = 2 * e + k, l = 2 * g + f;
			c = .3 * c + e + .16666667 * k;
			h = .3 * h + g + .16666667 * f;
			a *= b.BEZIER_SIZE;
			g = this.curves;
			g[a++] = b.BEZIER;
			for (var e = c, r = h, m = a + b.BEZIER_SIZE - 1;a < m;a += 2) {
				g[a] = e, g[a + 1] = r, c += q, h += l, q += k, l += f, e += c, r += h;
			}
		};
		b.prototype.getCurvePercent = function(c, g) {
			g = a.MathUtils.clamp(g, 0, 1);
			var e = this.curves;
			c *= b.BEZIER_SIZE;
			var h = e[c];
			if (h == b.LINEAR) {
				return g;
			}
			if (h == b.STEPPED) {
				return 0;
			}
			c++;
			for (var h = 0, k = c, f = c + b.BEZIER_SIZE - 1;c < f;c += 2) {
				if (h = e[c], h >= g) {
					return c == k ? f = k = 0 : (k = e[c - 2], f = e[c - 1]), f + (e[c + 1] - f) * (g - k) / (h - k);
				}
			}
			e = e[c - 1];
			return e + (1 - e) * (g - h) / (1 - h);
		};
		b.LINEAR = 0;
		b.STEPPED = 1;
		b.BEZIER = 2;
		b.BEZIER_SIZE = 19;
		return b;
	}();
	a.CurveTimeline = b;
	var k = function(b) {
		function c(c) {
			b.call(this, c);
			this.frames = a.Utils.newFloatArray(c << 1);
		}
		__extends(c, b);
		c.prototype.getPropertyId = function() {
			return (l.rotate << 24) + this.boneIndex;
		};
		c.prototype.setFrame = function(a, b, e) {
			a <<= 1;
			this.frames[a] = b;
			this.frames[a + c.ROTATION] = e;
		};
		c.prototype.apply = function(a, b, e, h, k, l, v) {
			b = this.frames;
			a = a.bones[this.boneIndex];
			if (e < b[0]) {
				l && (a.rotation = a.data.rotation);
			} else {
				if (e >= b[b.length - c.ENTRIES]) {
					l ? a.rotation = a.data.rotation + b[b.length + c.PREV_ROTATION] * k : (l = a.data.rotation + b[b.length + c.PREV_ROTATION] - a.rotation, a.rotation += (l - 360 * (16384 - (16384.499999999996 - l / 360 | 0))) * k);
				} else {
					v = f.binarySearch(b, e, c.ENTRIES);
					h = b[v + c.PREV_ROTATION];
					var g = b[v];
					e = this.getCurvePercent((v >> 1) - 1, 1 - (e - g) / (b[v + c.PREV_TIME] - g));
					b = b[v + c.ROTATION] - h;
					b = h + (b - 360 * (16384 - (16384.499999999996 - b / 360 | 0))) * e;
					l ? a.rotation = a.data.rotation + (b - 360 * (16384 - (16384.499999999996 - b / 360 | 0))) * k : (b = a.data.rotation + b - a.rotation, a.rotation += (b - 360 * (16384 - (16384.499999999996 - b / 360 | 0))) * k);
				}
			}
		};
		c.ENTRIES = 2;
		c.PREV_TIME = -2;
		c.PREV_ROTATION = -1;
		c.ROTATION = 1;
		return c;
	}(b);
	a.RotateTimeline = k;
	k = function(b) {
		function c(e) {
			b.call(this, e);
			this.frames = a.Utils.newFloatArray(e * c.ENTRIES);
		}
		__extends(c, b);
		c.prototype.getPropertyId = function() {
			return (l.translate << 24) + this.boneIndex;
		};
		c.prototype.setFrame = function(a, b, e, h) {
			a *= c.ENTRIES;
			this.frames[a] = b;
			this.frames[a + c.X] = e;
			this.frames[a + c.Y] = h;
		};
		c.prototype.apply = function(a, b, e, h, k, l, v) {
			b = this.frames;
			a = a.bones[this.boneIndex];
			if (e < b[0]) {
				l && (a.x = a.data.x, a.y = a.data.y);
			} else {
				if (e >= b[b.length - c.ENTRIES]) {
					h = b[b.length + c.PREV_X], v = b[b.length + c.PREV_Y];
				} else {
					var g = f.binarySearch(b, e, c.ENTRIES);
					h = b[g + c.PREV_X];
					v = b[g + c.PREV_Y];
					var q = b[g];
					e = this.getCurvePercent(g / c.ENTRIES - 1, 1 - (e - q) / (b[g + c.PREV_TIME] - q));
					h += (b[g + c.X] - h) * e;
					v += (b[g + c.Y] - v) * e;
				}
				l ? (a.x = a.data.x + h * k, a.y = a.data.y + v * k) : (a.x += (a.data.x + h - a.x) * k, a.y += (a.data.y + v - a.y) * k);
			}
		};
		c.ENTRIES = 3;
		c.PREV_TIME = -3;
		c.PREV_X = -2;
		c.PREV_Y = -1;
		c.X = 1;
		c.Y = 2;
		return c;
	}(b);
	a.TranslateTimeline = k;
	var h = function(b) {
		function c(a) {
			b.call(this, a);
		}
		__extends(c, b);
		c.prototype.getPropertyId = function() {
			return (l.scale << 24) + this.boneIndex;
		};
		c.prototype.apply = function(b, e, h, k, l, t, v) {
			var g = this.frames;
			b = b.bones[this.boneIndex];
			if (h < g[0]) {
				t && (b.scaleX = b.data.scaleX, b.scaleY = b.data.scaleY);
			} else {
				if (h >= g[g.length - c.ENTRIES]) {
					e = g[g.length + c.PREV_X] * b.data.scaleX, k = g[g.length + c.PREV_Y] * b.data.scaleY;
				} else {
					var q = f.binarySearch(g, h, c.ENTRIES);
					e = g[q + c.PREV_X];
					k = g[q + c.PREV_Y];
					var m = g[q];
					h = this.getCurvePercent(q / c.ENTRIES - 1, 1 - (h - m) / (g[q + c.PREV_TIME] - m));
					e = (e + (g[q + c.X] - e) * h) * b.data.scaleX;
					k = (k + (g[q + c.Y] - k) * h) * b.data.scaleY;
				}
				1 == l ? (b.scaleX = e, b.scaleY = k) : (t ? (t = b.data.scaleX, h = b.data.scaleY) : (t = b.scaleX, h = b.scaleY), v ? (e = Math.abs(e) * a.MathUtils.signum(t), k = Math.abs(k) * a.MathUtils.signum(h)) : (t = Math.abs(t) * a.MathUtils.signum(e), h = Math.abs(h) * a.MathUtils.signum(k)), b.scaleX = t + (e - t) * l, b.scaleY = h + (k - h) * l);
			}
		};
		return c;
	}(k);
	a.ScaleTimeline = h;
	k = function(a) {
		function b(b) {
			a.call(this, b);
		}
		__extends(b, a);
		b.prototype.getPropertyId = function() {
			return (l.shear << 24) + this.boneIndex;
		};
		b.prototype.apply = function(a, c, e, h, k, l, v) {
			c = this.frames;
			a = a.bones[this.boneIndex];
			if (e < c[0]) {
				l && (a.shearX = a.data.shearX, a.shearY = a.data.shearY);
			} else {
				if (e >= c[c.length - b.ENTRIES]) {
					h = c[c.length + b.PREV_X], v = c[c.length + b.PREV_Y];
				} else {
					var g = f.binarySearch(c, e, b.ENTRIES);
					h = c[g + b.PREV_X];
					v = c[g + b.PREV_Y];
					var q = c[g];
					e = this.getCurvePercent(g / b.ENTRIES - 1, 1 - (e - q) / (c[g + b.PREV_TIME] - q));
					h += (c[g + b.X] - h) * e;
					v += (c[g + b.Y] - v) * e;
				}
				l ? (a.shearX = a.data.shearX + h * k, a.shearY = a.data.shearY + v * k) : (a.shearX += (a.data.shearX + h - a.shearX) * k, a.shearY += (a.data.shearY + v - a.shearY) * k);
			}
		};
		return b;
	}(k);
	a.ShearTimeline = k;
	k = function(b) {
		function c(e) {
			b.call(this, e);
			this.frames = a.Utils.newFloatArray(e * c.ENTRIES);
		}
		__extends(c, b);
		c.prototype.getPropertyId = function() {
			return (l.color << 24) + this.slotIndex;
		};
		c.prototype.setFrame = function(a, b, e, h, k, f) {
			a *= c.ENTRIES;
			this.frames[a] = b;
			this.frames[a + c.R] = e;
			this.frames[a + c.G] = h;
			this.frames[a + c.B] = k;
			this.frames[a + c.A] = f;
		};
		c.prototype.apply = function(a, b, e, h, k, l, v) {
			a = a.slots[this.slotIndex];
			var g = this.frames;
			if (e < g[0]) {
				l && a.color.setFromColor(a.data.color);
			} else {
				var q;
				if (e >= g[g.length - c.ENTRIES]) {
					e = g.length, b = g[e + c.PREV_R], h = g[e + c.PREV_G], v = g[e + c.PREV_B], q = g[e + c.PREV_A];
				} else {
					var m = f.binarySearch(g, e, c.ENTRIES);
					b = g[m + c.PREV_R];
					h = g[m + c.PREV_G];
					v = g[m + c.PREV_B];
					q = g[m + c.PREV_A];
					var p = g[m];
					e = this.getCurvePercent(m / c.ENTRIES - 1, 1 - (e - p) / (g[m + c.PREV_TIME] - p));
					b += (g[m + c.R] - b) * e;
					h += (g[m + c.G] - h) * e;
					v += (g[m + c.B] - v) * e;
					q += (g[m + c.A] - q) * e;
				}
				1 == k ? a.color.set(b, h, v, q) : (e = a.color, l && e.setFromColor(a.data.color), e.add((b - e.r) * k, (h - e.g) * k, (v - e.b) * k, (q - e.a) * k));
			}
		};
		c.ENTRIES = 5;
		c.PREV_TIME = -5;
		c.PREV_R = -4;
		c.PREV_G = -3;
		c.PREV_B = -2;
		c.PREV_A = -1;
		c.R = 1;
		c.G = 2;
		c.B = 3;
		c.A = 4;
		return c;
	}(b);
	a.ColorTimeline = k;
	k = function() {
		function b(b) {
			this.frames = a.Utils.newFloatArray(b);
			this.attachmentNames = Array(b);
		}
		b.prototype.getPropertyId = function() {
			return (l.attachment << 24) + this.slotIndex;
		};
		b.prototype.getFrameCount = function() {
			return this.frames.length;
		};
		b.prototype.setFrame = function(a, b, c) {
			this.frames[a] = b;
			this.attachmentNames[a] = c;
		};
		b.prototype.apply = function(a, b, c, h, k, l, t) {
			b = a.slots[this.slotIndex];
			t && l ? (c = b.data.attachmentName, b.setAttachment(null == c ? null : a.getAttachment(this.slotIndex, c))) : (t = this.frames, c < t[0] ? l && (c = b.data.attachmentName, b.setAttachment(null == c ? null : a.getAttachment(this.slotIndex, c))) : (c = c >= t[t.length - 1] ? t.length - 1 : f.binarySearch(t, c, 1) - 1, c = this.attachmentNames[c], a.slots[this.slotIndex].setAttachment(null == c ? null : a.getAttachment(this.slotIndex, c))));
		};
		return b;
	}();
	a.AttachmentTimeline = k;
	k = function(b) {
		function c(c) {
			b.call(this, c);
			this.frames = a.Utils.newFloatArray(c);
			this.frameVertices = Array(c);
		}
		__extends(c, b);
		c.prototype.getPropertyId = function() {
			return (l.deform << 24) + this.slotIndex;
		};
		c.prototype.setFrame = function(a, b, c) {
			this.frames[a] = b;
			this.frameVertices[a] = c;
		};
		c.prototype.apply = function(b, c, e, h, k, l, v) {
			b = b.slots[this.slotIndex];
			var g = b.getAttachment();
			if (g instanceof a.VertexAttachment && g.applyDeform(this.attachment)) {
				var q = this.frames;
				c = b.attachmentVertices;
				if (e < q[0]) {
					l && a.Utils.setArraySize(c, 0);
				} else {
					if (v = this.frameVertices, b = v[0].length, c.length != b && (k = 1), c = a.Utils.setArraySize(c, b), e >= q[q.length - 1]) {
						if (e = v[q.length - 1], 1 == k) {
							a.Utils.arrayCopy(e, 0, c, 0, b);
						} else {
							if (l) {
								if (l = g, null == l.bones) {
									for (l = l.vertices, g = 0;g < b;g++) {
										q = l[g], c[g] = q + (e[g] - q) * k;
									}
								} else {
									for (g = 0;g < b;g++) {
										c[g] = e[g] * k;
									}
								}
							} else {
								for (g = 0;g < b;g++) {
									c[g] += (e[g] - c[g]) * k;
								}
							}
						}
					} else {
						var m = f.binarySearch(q, e);
						h = v[m - 1];
						v = v[m];
						var p = q[m];
						e = this.getCurvePercent(m - 1, 1 - (e - p) / (q[m - 1] - p));
						if (1 == k) {
							for (g = 0;g < b;g++) {
								m = h[g], c[g] = m + (v[g] - m) * e;
							}
						} else {
							if (l) {
								if (l = g, null == l.bones) {
									for (l = l.vertices, g = 0;g < b;g++) {
										m = h[g], q = l[g], c[g] = q + (m + (v[g] - m) * e - q) * k;
									}
								} else {
									for (g = 0;g < b;g++) {
										m = h[g], c[g] = (m + (v[g] - m) * e) * k;
									}
								}
							} else {
								for (g = 0;g < b;g++) {
									m = h[g], c[g] += (m + (v[g] - m) * e - c[g]) * k;
								}
							}
						}
					}
				}
			}
		};
		return c;
	}(b);
	a.DeformTimeline = k;
	k = function() {
		function b(b) {
			this.frames = a.Utils.newFloatArray(b);
			this.events = Array(b);
		}
		b.prototype.getPropertyId = function() {
			return l.event << 24;
		};
		b.prototype.getFrameCount = function() {
			return this.frames.length;
		};
		b.prototype.setFrame = function(a, b) {
			this.frames[a] = b.time;
			this.events[a] = b;
		};
		b.prototype.apply = function(a, b, c, h, k, l, t) {
			if (null != h) {
				var e = this.frames, g = this.frames.length;
				if (b > c) {
					this.apply(a, b, Number.MAX_VALUE, h, k, l, t), b = -1;
				} else {
					if (b >= e[g - 1]) {
						return;
					}
				}
				if (!(c < e[0])) {
					if (b < e[0]) {
						a = 0;
					} else {
						for (a = f.binarySearch(e, b), b = e[a];0 < a && e[a - 1] == b;) {
							a--;
						}
					}
					for (;a < g && c >= e[a];a++) {
						h.push(this.events[a]);
					}
				}
			}
		};
		return b;
	}();
	a.EventTimeline = k;
	k = function() {
		function b(b) {
			this.frames = a.Utils.newFloatArray(b);
			this.drawOrders = Array(b);
		}
		b.prototype.getPropertyId = function() {
			return l.drawOrder << 24;
		};
		b.prototype.getFrameCount = function() {
			return this.frames.length;
		};
		b.prototype.setFrame = function(a, b, c) {
			this.frames[a] = b;
			this.drawOrders[a] = c;
		};
		b.prototype.apply = function(b, c, h, k, l, p, t) {
			c = b.drawOrder;
			k = b.slots;
			if (t && p) {
				a.Utils.arrayCopy(b.slots, 0, b.drawOrder, 0, b.slots.length);
			} else {
				if (t = this.frames, h < t[0]) {
					p && a.Utils.arrayCopy(b.slots, 0, b.drawOrder, 0, b.slots.length);
				} else {
					if (b = h >= t[t.length - 1] ? t.length - 1 : f.binarySearch(t, h) - 1, b = this.drawOrders[b], null == b) {
						a.Utils.arrayCopy(k, 0, c, 0, k.length);
					} else {
						for (h = 0, p = b.length;h < p;h++) {
							c[h] = k[b[h]];
						}
					}
				}
			}
		};
		return b;
	}();
	a.DrawOrderTimeline = k;
	k = function(b) {
		function c(e) {
			b.call(this, e);
			this.frames = a.Utils.newFloatArray(e * c.ENTRIES);
		}
		__extends(c, b);
		c.prototype.getPropertyId = function() {
			return (l.ikConstraint << 24) + this.ikConstraintIndex;
		};
		c.prototype.setFrame = function(a, b, e, h) {
			a *= c.ENTRIES;
			this.frames[a] = b;
			this.frames[a + c.MIX] = e;
			this.frames[a + c.BEND_DIRECTION] = h;
		};
		c.prototype.apply = function(a, b, e, h, k, l, v) {
			b = this.frames;
			a = a.ikConstraints[this.ikConstraintIndex];
			if (e < b[0]) {
				l && (a.mix = a.data.mix, a.bendDirection = a.data.bendDirection);
			} else {
				if (e >= b[b.length - c.ENTRIES]) {
					l ? (a.mix = a.data.mix + (b[b.length + c.PREV_MIX] - a.data.mix) * k, a.bendDirection = v ? a.data.bendDirection : b[b.length + c.PREV_BEND_DIRECTION]) : (a.mix += (b[b.length + c.PREV_MIX] - a.mix) * k, v || (a.bendDirection = b[b.length + c.PREV_BEND_DIRECTION]));
				} else {
					h = f.binarySearch(b, e, c.ENTRIES);
					var g = b[h + c.PREV_MIX], q = b[h];
					e = this.getCurvePercent(h / c.ENTRIES - 1, 1 - (e - q) / (b[h + c.PREV_TIME] - q));
					l ? (a.mix = a.data.mix + (g + (b[h + c.MIX] - g) * e - a.data.mix) * k, a.bendDirection = v ? a.data.bendDirection : b[h + c.PREV_BEND_DIRECTION]) : (a.mix += (g + (b[h + c.MIX] - g) * e - a.mix) * k, v || (a.bendDirection = b[h + c.PREV_BEND_DIRECTION]));
				}
			}
		};
		c.ENTRIES = 3;
		c.PREV_TIME = -3;
		c.PREV_MIX = -2;
		c.PREV_BEND_DIRECTION = -1;
		c.MIX = 1;
		c.BEND_DIRECTION = 2;
		return c;
	}(b);
	a.IkConstraintTimeline = k;
	k = function(b) {
		function c(e) {
			b.call(this, e);
			this.frames = a.Utils.newFloatArray(e * c.ENTRIES);
		}
		__extends(c, b);
		c.prototype.getPropertyId = function() {
			return (l.transformConstraint << 24) + this.transformConstraintIndex;
		};
		c.prototype.setFrame = function(a, b, e, h, k, f) {
			a *= c.ENTRIES;
			this.frames[a] = b;
			this.frames[a + c.ROTATE] = e;
			this.frames[a + c.TRANSLATE] = h;
			this.frames[a + c.SCALE] = k;
			this.frames[a + c.SHEAR] = f;
		};
		c.prototype.apply = function(a, b, e, h, k, l, v) {
			b = this.frames;
			a = a.transformConstraints[this.transformConstraintIndex];
			if (e < b[0]) {
				l && (l = a.data, a.rotateMix = l.rotateMix, a.translateMix = l.rotateMix, a.scaleMix = l.scaleMix, a.shearMix = l.shearMix);
			} else {
				var g, q;
				if (e >= b[b.length - c.ENTRIES]) {
					e = b.length, h = b[e + c.PREV_ROTATE], v = b[e + c.PREV_TRANSLATE], g = b[e + c.PREV_SCALE], q = b[e + c.PREV_SHEAR];
				} else {
					var m = f.binarySearch(b, e, c.ENTRIES);
					h = b[m + c.PREV_ROTATE];
					v = b[m + c.PREV_TRANSLATE];
					g = b[m + c.PREV_SCALE];
					q = b[m + c.PREV_SHEAR];
					var p = b[m];
					e = this.getCurvePercent(m / c.ENTRIES - 1, 1 - (e - p) / (b[m + c.PREV_TIME] - p));
					h += (b[m + c.ROTATE] - h) * e;
					v += (b[m + c.TRANSLATE] - v) * e;
					g += (b[m + c.SCALE] - g) * e;
					q += (b[m + c.SHEAR] - q) * e;
				}
				l ? (l = a.data, a.rotateMix = l.rotateMix + (h - l.rotateMix) * k, a.translateMix = l.translateMix + (v - l.translateMix) * k, a.scaleMix = l.scaleMix + (g - l.scaleMix) * k, a.shearMix = l.shearMix + (q - l.shearMix) * k) : (a.rotateMix += (h - a.rotateMix) * k, a.translateMix += (v - a.translateMix) * k, a.scaleMix += (g - a.scaleMix) * k, a.shearMix += (q - a.shearMix) * k);
			}
		};
		c.ENTRIES = 5;
		c.PREV_TIME = -5;
		c.PREV_ROTATE = -4;
		c.PREV_TRANSLATE = -3;
		c.PREV_SCALE = -2;
		c.PREV_SHEAR = -1;
		c.ROTATE = 1;
		c.TRANSLATE = 2;
		c.SCALE = 3;
		c.SHEAR = 4;
		return c;
	}(b);
	a.TransformConstraintTimeline = k;
	k = function(b) {
		function c(e) {
			b.call(this, e);
			this.frames = a.Utils.newFloatArray(e * c.ENTRIES);
		}
		__extends(c, b);
		c.prototype.getPropertyId = function() {
			return (l.pathConstraintPosition << 24) + this.pathConstraintIndex;
		};
		c.prototype.setFrame = function(a, b, e) {
			a *= c.ENTRIES;
			this.frames[a] = b;
			this.frames[a + c.VALUE] = e;
		};
		c.prototype.apply = function(a, b, e, h, k, l, v) {
			b = this.frames;
			a = a.pathConstraints[this.pathConstraintIndex];
			if (e < b[0]) {
				l && (a.position = a.data.position);
			} else {
				if (e >= b[b.length - c.ENTRIES]) {
					h = b[b.length + c.PREV_VALUE];
				} else {
					v = f.binarySearch(b, e, c.ENTRIES);
					h = b[v + c.PREV_VALUE];
					var g = b[v];
					e = this.getCurvePercent(v / c.ENTRIES - 1, 1 - (e - g) / (b[v + c.PREV_TIME] - g));
					h += (b[v + c.VALUE] - h) * e;
				}
				a.position = l ? a.data.position + (h - a.data.position) * k : a.position + (h - a.position) * k;
			}
		};
		c.ENTRIES = 2;
		c.PREV_TIME = -2;
		c.PREV_VALUE = -1;
		c.VALUE = 1;
		return c;
	}(b);
	a.PathConstraintPositionTimeline = k;
	k = function(a) {
		function b(b) {
			a.call(this, b);
		}
		__extends(b, a);
		b.prototype.getPropertyId = function() {
			return (l.pathConstraintSpacing << 24) + this.pathConstraintIndex;
		};
		b.prototype.apply = function(a, c, e, h, k, l, v) {
			c = this.frames;
			a = a.pathConstraints[this.pathConstraintIndex];
			if (e < c[0]) {
				l && (a.spacing = a.data.spacing);
			} else {
				if (e >= c[c.length - b.ENTRIES]) {
					h = c[c.length + b.PREV_VALUE];
				} else {
					v = f.binarySearch(c, e, b.ENTRIES);
					h = c[v + b.PREV_VALUE];
					var g = c[v];
					e = this.getCurvePercent(v / b.ENTRIES - 1, 1 - (e - g) / (c[v + b.PREV_TIME] - g));
					h += (c[v + b.VALUE] - h) * e;
				}
				a.spacing = l ? a.data.spacing + (h - a.data.spacing) * k : a.spacing + (h - a.spacing) * k;
			}
		};
		return b;
	}(k);
	a.PathConstraintSpacingTimeline = k;
	b = function(b) {
		function c(e) {
			b.call(this, e);
			this.frames = a.Utils.newFloatArray(e * c.ENTRIES);
		}
		__extends(c, b);
		c.prototype.getPropertyId = function() {
			return (l.pathConstraintMix << 24) + this.pathConstraintIndex;
		};
		c.prototype.setFrame = function(a, b, e, h) {
			a *= c.ENTRIES;
			this.frames[a] = b;
			this.frames[a + c.ROTATE] = e;
			this.frames[a + c.TRANSLATE] = h;
		};
		c.prototype.apply = function(a, b, e, h, k, l, v) {
			b = this.frames;
			a = a.pathConstraints[this.pathConstraintIndex];
			if (e < b[0]) {
				l && (a.rotateMix = a.data.rotateMix, a.translateMix = a.data.translateMix);
			} else {
				if (e >= b[b.length - c.ENTRIES]) {
					h = b[b.length + c.PREV_ROTATE], v = b[b.length + c.PREV_TRANSLATE];
				} else {
					var g = f.binarySearch(b, e, c.ENTRIES);
					h = b[g + c.PREV_ROTATE];
					v = b[g + c.PREV_TRANSLATE];
					var q = b[g];
					e = this.getCurvePercent(g / c.ENTRIES - 1, 1 - (e - q) / (b[g + c.PREV_TIME] - q));
					h += (b[g + c.ROTATE] - h) * e;
					v += (b[g + c.TRANSLATE] - v) * e;
				}
				l ? (a.rotateMix = a.data.rotateMix + (h - a.data.rotateMix) * k, a.translateMix = a.data.translateMix + (v - a.data.translateMix) * k) : (a.rotateMix += (h - a.rotateMix) * k, a.translateMix += (v - a.translateMix) * k);
			}
		};
		c.ENTRIES = 3;
		c.PREV_TIME = -3;
		c.PREV_ROTATE = -2;
		c.PREV_TRANSLATE = -1;
		c.ROTATE = 1;
		c.TRANSLATE = 2;
		return c;
	}(b);
	a.PathConstraintMixTimeline = b;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function h(c) {
			this.tracks = [];
			this.events = [];
			this.listeners = [];
			this.queue = new b(this);
			this.propertyIDs = new a.IntSet;
			this.animationsChanged = !1;
			this.timeScale = 1;
			this.trackEntryPool = new a.Pool(function() {
				return new l;
			});
			this.data = c;
		}
		h.prototype.update = function(a) {
			a *= this.timeScale;
			for (var b = this.tracks, c = 0, h = b.length;c < h;c++) {
				var k = b[c];
				if (null != k) {
					k.animationLast = k.nextAnimationLast;
					k.trackLast = k.nextTrackLast;
					var f = a * k.timeScale;
					if (0 < k.delay) {
						k.delay -= f;
						if (0 < k.delay) {
							continue;
						}
						f = -k.delay;
						k.delay = 0;
					}
					var l = k.next;
					if (null != l) {
						var t = k.trackLast - l.delay;
						if (0 <= t) {
							l.delay = 0;
							l.trackTime = t + a * l.timeScale;
							k.trackTime += f;
							for (this.setCurrent(c, l);null != l.mixingFrom;) {
								l.mixTime += f, l = l.mixingFrom;
							}
							continue;
						}
					} else {
						if (k.trackLast >= k.trackEnd && null == k.mixingFrom) {
							b[c] = null;
							this.queue.end(k);
							this.disposeNext(k);
							continue;
						}
					}
					this.updateMixingFrom(k, a);
					k.trackTime += f;
				}
			}
			this.queue.drain();
		};
		h.prototype.updateMixingFrom = function(a, b) {
			var c = a.mixingFrom;
			null != c && (this.updateMixingFrom(c, b), a.mixTime >= a.mixDuration && null != c.mixingFrom && 0 < a.mixTime ? (a.mixingFrom = null, this.queue.end(c)) : (c.animationLast = c.nextAnimationLast, c.trackLast = c.nextTrackLast, c.trackTime += b * c.timeScale, a.mixTime += b * c.timeScale));
		};
		h.prototype.apply = function(b) {
			if (null == b) {
				throw Error("skeleton cannot be null.");
			}
			this.animationsChanged && this._animationsChanged();
			for (var c = this.events, g = this.tracks, h = 0, k = g.length;h < k;h++) {
				var f = g[h];
				if (!(null == f || 0 < f.delay)) {
					var l = f.alpha;
					null != f.mixingFrom ? l *= this.applyMixingFrom(f, b) : f.trackTime >= f.trackEnd && (l = 0);
					var t = f.animationLast, v = f.getAnimationTime(), y = f.animation.timelines.length, x = f.animation.timelines;
					if (1 == l) {
						for (var m = 0;m < y;m++) {
							x[m].apply(b, t, v, c, 1, !0, !1);
						}
					} else {
						var u = 0 == f.timelinesRotation.length;
						u && a.Utils.setArraySize(f.timelinesRotation, y << 1, null);
						for (var B = f.timelinesRotation, A = f.timelinesFirst, m = 0;m < y;m++) {
							var D = x[m];
							D instanceof a.RotateTimeline ? this.applyRotateTimeline(D, b, v, l, A[m], B, m << 1, u) : D.apply(b, t, v, c, l, A[m], !1);
						}
					}
					this.queueEvents(f, v);
					f.nextAnimationLast = v;
					f.nextTrackLast = f.trackTime;
				}
			}
			this.queue.drain();
		};
		h.prototype.applyMixingFrom = function(b, e) {
			var c = b.mixingFrom;
			null != c.mixingFrom && this.applyMixingFrom(c, e);
			var h;
			0 == b.mixDuration ? h = 1 : (h = b.mixTime / b.mixDuration, 1 < h && (h = 1));
			var k = h < c.eventThreshold ? this.events : null, f = h < c.attachmentThreshold, l = h < c.drawOrderThreshold, t = c.animationLast, v = c.getAnimationTime(), y = c.animation.timelines.length, x = c.animation.timelines, m = c.timelinesFirst;
			b = c.alpha * b.mixAlpha * (1 - h);
			var u = 0 == c.timelinesRotation.length;
			u && a.Utils.setArraySize(c.timelinesRotation, y << 1, null);
			for (var B = c.timelinesRotation, A = 0;A < y;A++) {
				var D = x[A], G = m[A];
				if (D instanceof a.RotateTimeline) {
					this.applyRotateTimeline(D, e, v, b, G, B, A << 1, u);
				} else {
					if (!G) {
						if (!f && D instanceof a.AttachmentTimeline) {
							continue;
						}
						if (!l && D instanceof a.DrawOrderTimeline) {
							continue;
						}
					}
					D.apply(e, t, v, k, b, G, !0);
				}
			}
			this.queueEvents(c, v);
			c.nextAnimationLast = v;
			c.nextTrackLast = c.trackTime;
			return h;
		};
		h.prototype.applyRotateTimeline = function(b, e, g, h, k, f, l, t) {
			if (1 == h) {
				b.apply(e, 0, g, null, 1, k, !1);
			} else {
				var c = b.frames;
				e = e.bones[b.boneIndex];
				if (g < c[0]) {
					k && (e.rotation = e.data.rotation);
				} else {
					if (g >= c[c.length - a.RotateTimeline.ENTRIES]) {
						c = e.data.rotation + c[c.length + a.RotateTimeline.PREV_ROTATION];
					} else {
						var q = a.Animation.binarySearch(c, g, a.RotateTimeline.ENTRIES), p = c[q + a.RotateTimeline.PREV_ROTATION], m = c[q];
						b = b.getCurvePercent((q >> 1) - 1, 1 - (g - m) / (c[q + a.RotateTimeline.PREV_TIME] - m));
						c = c[q + a.RotateTimeline.ROTATION] - p;
						c = p + (c - 360 * (16384 - (16384.499999999996 - c / 360 | 0))) * b + e.data.rotation;
						c -= 360 * (16384 - (16384.499999999996 - c / 360 | 0));
					}
					k = k ? e.data.rotation : e.rotation;
					c -= k;
					0 == c ? g = t ? f[l] = 0 : f[l] : (c -= 360 * (16384 - (16384.499999999996 - c / 360 | 0)), t ? (t = 0, g = c) : (t = f[l], g = f[l + 1]), p = 0 < c, b = 0 <= t, a.MathUtils.signum(g) != a.MathUtils.signum(c) && 90 >= Math.abs(g) && (180 < Math.abs(t) && (t += 360 * a.MathUtils.signum(t)), b = p), g = c + t - t % 360, b != p && (g += 360 * a.MathUtils.signum(t)), f[l] = g);
					f[l + 1] = c;
					k += g * h;
					e.rotation = k - 360 * (16384 - (16384.499999999996 - k / 360 | 0));
				}
			}
		};
		h.prototype.queueEvents = function(a, b) {
			for (var c = a.animationStart, e = a.animationEnd, h = e - c, k = a.trackLast % h, f = this.events, l = 0, v = f.length;l < v;l++) {
				var y = f[l];
				if (y.time < k) {
					break;
				}
				y.time > e || this.queue.event(a, y);
			}
			for ((a.loop ? k > a.trackTime % h : b >= e && a.animationLast < e) && this.queue.complete(a);l < v;l++) {
				f[l].time < c || this.queue.event(a, f[l]);
			}
			this.events.length = 0;
		};
		h.prototype.clearTracks = function() {
			this.queue.drainDisabled = !0;
			for (var a = 0, b = this.tracks.length;a < b;a++) {
				this.clearTrack(a);
			}
			this.tracks.length = 0;
			this.queue.drainDisabled = !1;
			this.queue.drain();
		};
		h.prototype.clearTrack = function(a) {
			if (!(a >= this.tracks.length) && (a = this.tracks[a], null != a)) {
				this.queue.end(a);
				this.disposeNext(a);
				for (var b = a;;) {
					var c = b.mixingFrom;
					if (null == c) {
						break;
					}
					this.queue.end(c);
					b.mixingFrom = null;
					b = c;
				}
				this.tracks[a.trackIndex] = null;
				this.queue.drain();
			}
		};
		h.prototype.setCurrent = function(a, b) {
			var c = this.expandToIndex(a);
			this.tracks[a] = b;
			null != c && (this.queue.interrupt(c), b.mixingFrom = c, b.mixTime = 0, null != c.mixingFrom && (b.mixAlpha *= Math.min(c.mixTime / c.mixDuration, 1)));
			this.queue.start(b);
		};
		h.prototype.setAnimation = function(a, b, g) {
			var c = this.data.skeletonData.findAnimation(b);
			if (null == c) {
				throw Error("Animation not found: " + b);
			}
			return this.setAnimationWith(a, c, g);
		};
		h.prototype.setAnimationWith = function(a, b, g) {
			if (null == b) {
				throw Error("animation cannot be null.");
			}
			var c = this.expandToIndex(a);
			null != c && (-1 == c.nextTrackLast ? (this.tracks[a] = c.mixingFrom, this.queue.interrupt(c), this.queue.end(c), this.disposeNext(c), c = c.mixingFrom) : this.disposeNext(c));
			b = this.trackEntry(a, b, g, c);
			this.setCurrent(a, b);
			this.queue.drain();
			return b;
		};
		h.prototype.addAnimation = function(a, b, g, h) {
			var c = this.data.skeletonData.findAnimation(b);
			if (null == c) {
				throw Error("Animation not found: " + b);
			}
			return this.addAnimationWith(a, c, g, h);
		};
		h.prototype.addAnimationWith = function(a, b, g, h) {
			if (null == b) {
				throw Error("animation cannot be null.");
			}
			var c = this.expandToIndex(a);
			if (null != c) {
				for (;null != c.next;) {
					c = c.next;
				}
			}
			g = this.trackEntry(a, b, g, c);
			null == c ? (this.setCurrent(a, g), this.queue.drain()) : (c.next = g, 0 >= h && (a = c.animationEnd - c.animationStart, h = 0 != a ? h + (a * (1 + (c.trackTime / a | 0)) - this.data.getMix(c.animation, b)) : 0));
			g.delay = h;
			return g;
		};
		h.prototype.setEmptyAnimation = function(a, b) {
			a = this.setAnimationWith(a, h.emptyAnimation, !1);
			a.mixDuration = b;
			a.trackEnd = b;
			return a;
		};
		h.prototype.addEmptyAnimation = function(a, b, g) {
			0 >= g && (g -= b);
			a = this.addAnimationWith(a, h.emptyAnimation, !1, g);
			a.mixDuration = b;
			a.trackEnd = b;
			return a;
		};
		h.prototype.setEmptyAnimations = function(a) {
			this.queue.drainDisabled = !0;
			for (var b = 0, c = this.tracks.length;b < c;b++) {
				var h = this.tracks[b];
				null != h && this.setEmptyAnimation(h.trackIndex, a);
			}
			this.queue.drainDisabled = !1;
			this.queue.drain();
		};
		h.prototype.expandToIndex = function(b) {
			if (b < this.tracks.length) {
				return this.tracks[b];
			}
			a.Utils.ensureArrayCapacity(this.tracks, b - this.tracks.length + 1, null);
			this.tracks.length = b + 1;
			return null;
		};
		h.prototype.trackEntry = function(a, b, g, h) {
			var c = this.trackEntryPool.obtain();
			c.trackIndex = a;
			c.animation = b;
			c.loop = g;
			c.eventThreshold = 0;
			c.attachmentThreshold = 0;
			c.drawOrderThreshold = 0;
			c.animationStart = 0;
			c.animationEnd = b.duration;
			c.animationLast = -1;
			c.nextAnimationLast = -1;
			c.delay = 0;
			c.trackTime = 0;
			c.trackLast = -1;
			c.nextTrackLast = -1;
			c.trackEnd = g ? Number.MAX_VALUE : c.animationEnd;
			c.timeScale = 1;
			c.alpha = 1;
			c.mixAlpha = 1;
			c.mixTime = 0;
			c.mixDuration = null == h ? 0 : this.data.getMix(h.animation, b);
			return c;
		};
		h.prototype.disposeNext = function(a) {
			for (var b = a.next;null != b;) {
				this.queue.dispose(b), b = b.next;
			}
			a.next = null;
		};
		h.prototype._animationsChanged = function() {
			this.animationsChanged = !1;
			var a = 0, b = this.tracks.length;
			for (this.propertyIDs.clear();a < b;a++) {
				var g = this.tracks[a];
				if (null != g) {
					this.setTimelinesFirst(g);
					a++;
					break;
				}
			}
			for (;a < b;a++) {
				g = this.tracks[a], null != g && this.checkTimelinesFirst(g);
			}
		};
		h.prototype.setTimelinesFirst = function(b) {
			if (null != b.mixingFrom) {
				this.setTimelinesFirst(b.mixingFrom), this.checkTimelinesUsage(b, b.timelinesFirst);
			} else {
				var c = this.propertyIDs, g = b.animation.timelines, h = g.length;
				b = a.Utils.setArraySize(b.timelinesFirst, h, !1);
				for (var k = 0;k < h;k++) {
					c.add(g[k].getPropertyId()), b[k] = !0;
				}
			}
		};
		h.prototype.checkTimelinesFirst = function(a) {
			null != a.mixingFrom && this.checkTimelinesFirst(a.mixingFrom);
			this.checkTimelinesUsage(a, a.timelinesFirst);
		};
		h.prototype.checkTimelinesUsage = function(b, e) {
			var c = this.propertyIDs;
			b = b.animation.timelines;
			var h = b.length;
			e = a.Utils.setArraySize(e, h);
			for (var k = 0;k < h;k++) {
				e[k] = c.add(b[k].getPropertyId());
			}
		};
		h.prototype.getCurrent = function(a) {
			return a >= this.tracks.length ? null : this.tracks[a];
		};
		h.prototype.addListener = function(a) {
			if (null == a) {
				throw Error("listener cannot be null.");
			}
			this.listeners.push(a);
		};
		h.prototype.removeListener = function(a) {
			a = this.listeners.indexOf(a);
			0 <= a && this.listeners.splice(a, 1);
		};
		h.prototype.clearListeners = function() {
			this.listeners.length = 0;
		};
		h.prototype.clearListenerNotifications = function() {
			this.queue.clear();
		};
		h.emptyAnimation = new a.Animation("<empty>", [], 0);
		return h;
	}();
	a.AnimationState = f;
	var l = function() {
		function a() {
			this.timelinesFirst = [];
			this.timelinesRotation = [];
		}
		a.prototype.reset = function() {
			this.listener = this.animation = this.mixingFrom = this.next = null;
			this.timelinesFirst.length = 0;
			this.timelinesRotation.length = 0;
		};
		a.prototype.getAnimationTime = function() {
			if (this.loop) {
				var a = this.animationEnd - this.animationStart;
				return 0 == a ? this.animationStart : this.trackTime % a + this.animationStart;
			}
			return Math.min(this.trackTime + this.animationStart, this.animationEnd);
		};
		a.prototype.setAnimationLast = function(a) {
			this.nextAnimationLast = this.animationLast = a;
		};
		a.prototype.isComplete = function() {
			return this.trackTime >= this.animationEnd - this.animationStart;
		};
		a.prototype.resetRotationDirections = function() {
			this.timelinesRotation.length = 0;
		};
		return a;
	}();
	a.TrackEntry = l;
	var b = function() {
		function a(a) {
			this.objects = [];
			this.drainDisabled = !1;
			this.animState = a;
		}
		a.prototype.start = function(a) {
			this.objects.push(k.start);
			this.objects.push(a);
			this.animState.animationsChanged = !0;
		};
		a.prototype.interrupt = function(a) {
			this.objects.push(k.interrupt);
			this.objects.push(a);
		};
		a.prototype.end = function(a) {
			this.objects.push(k.end);
			this.objects.push(a);
			this.animState.animationsChanged = !0;
		};
		a.prototype.dispose = function(a) {
			this.objects.push(k.dispose);
			this.objects.push(a);
		};
		a.prototype.complete = function(a) {
			this.objects.push(k.complete);
			this.objects.push(a);
		};
		a.prototype.event = function(a, b) {
			this.objects.push(k.event);
			this.objects.push(a);
			this.objects.push(b);
		};
		a.prototype.drain = function() {
			if (!this.drainDisabled) {
				this.drainDisabled = !0;
				for (var a = this.objects, b = this.animState.listeners, g = 0;g < a.length;g += 2) {
					var h = a[g + 1];
					switch(a[g]) {
						case k.start:
							null != h.listener && h.listener.start && h.listener.start(h);
							for (var f = 0;f < b.length;f++) {
								b[f].start && b[f].start(h);
							}
							break;
						case k.interrupt:
							null != h.listener && h.listener.interrupt && h.listener.interrupt(h);
							for (f = 0;f < b.length;f++) {
								b[f].interrupt && b[f].interrupt(h);
							}
							break;
						case k.end:
							for (null != h.listener && h.listener.end && h.listener.end(h), f = 0;f < b.length;f++) {
								b[f].end && b[f].end(h);
							}
						;
						case k.dispose:
							null != h.listener && h.listener.dispose && h.listener.dispose(h);
							for (f = 0;f < b.length;f++) {
								b[f].dispose && b[f].dispose(h);
							}
							this.animState.trackEntryPool.free(h);
							break;
						case k.complete:
							null != h.listener && h.listener.complete && h.listener.complete(h);
							for (f = 0;f < b.length;f++) {
								b[f].complete && b[f].complete(h);
							}
							break;
						case k.event:
							var l = a[g++ + 2];
							null != h.listener && h.listener.event && h.listener.event(h, l);
							for (f = 0;f < b.length;f++) {
								b[f].event && b[f].event(h, l);
							}
						;
					}
				}
				this.clear();
				this.drainDisabled = !1;
			}
		};
		a.prototype.clear = function() {
			this.objects.length = 0;
		};
		return a;
	}();
	a.EventQueue = b;
	(function(a) {
		a[a.start = 0] = "start";
		a[a.interrupt = 1] = "interrupt";
		a[a.end = 2] = "end";
		a[a.dispose = 3] = "dispose";
		a[a.complete = 4] = "complete";
		a[a.event = 5] = "event";
	})(a.EventType || (a.EventType = {}));
	var k = a.EventType, f = function() {
		function a() {
		}
		a.prototype.start = function(a) {
		};
		a.prototype.interrupt = function(a) {
		};
		a.prototype.end = function(a) {
		};
		a.prototype.dispose = function(a) {
		};
		a.prototype.complete = function(a) {
		};
		a.prototype.event = function(a, b) {
		};
		return a;
	}();
	a.AnimationStateAdapter2 = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function a(a) {
			this.animationToMixTime = {};
			this.defaultMix = 0;
			if (null == a) {
				throw Error("skeletonData cannot be null.");
			}
			this.skeletonData = a;
		}
		a.prototype.setMix = function(a, k, h) {
			var b = this.skeletonData.findAnimation(a);
			if (null == b) {
				throw Error("Animation not found: " + a);
			}
			a = this.skeletonData.findAnimation(k);
			if (null == a) {
				throw Error("Animation not found: " + k);
			}
			this.setMixWith(b, a, h);
		};
		a.prototype.setMixWith = function(a, k, h) {
			if (null == a) {
				throw Error("from cannot be null.");
			}
			if (null == k) {
				throw Error("to cannot be null.");
			}
			this.animationToMixTime[a.name + k.name] = h;
		};
		a.prototype.getMix = function(a, k) {
			a = this.animationToMixTime[a.name + k.name];
			return void 0 === a ? this.defaultMix : a;
		};
		return a;
	}();
	a.AnimationStateData = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function a(a, k) {
			void 0 === k && (k = "");
			this.assets = {};
			this.errors = {};
			this.loaded = this.toLoad = 0;
			this.textureLoader = a;
			this.pathPrefix = k;
		}
		a.prototype.loadText = function(a, k, h) {
			var b = this;
			void 0 === k && (k = null);
			void 0 === h && (h = null);
			a = this.pathPrefix + a;
			this.toLoad++;
			var e = new XMLHttpRequest;
			e.onreadystatechange = function() {
				e.readyState == XMLHttpRequest.DONE && (200 <= e.status && 300 > e.status ? (b.assets[a] = e.responseText, k && k(a, e.responseText)) : (b.errors[a] = "Couldn't load text " + a + ": status " + e.status + ", " + e.responseText, h && h(a, "Couldn't load text " + a + ": status " + e.status + ", " + e.responseText)), b.toLoad--, b.loaded++);
			};
			e.open("GET", a, !0);
			e.send();
		};
		a.prototype.loadTexture = function(a, k, h) {
			var b = this;
			void 0 === k && (k = null);
			void 0 === h && (h = null);
			a = this.pathPrefix + a;
			this.toLoad++;
			var e = new Image;
			e.crossOrigin = "anonymous";
			e.src = a;
			e.onload = function(c) {
				c = b.textureLoader(e);
				b.assets[a] = c;
				b.toLoad--;
				b.loaded++;
				k && k(a, e);
			};
			e.onerror = function(c) {
				b.errors[a] = "Couldn't load image " + a;
				b.toLoad--;
				b.loaded++;
				h && h(a, "Couldn't load image " + a);
			};
		};
		a.prototype.get = function(a) {
			a = this.pathPrefix + a;
			return this.assets[a];
		};
		a.prototype.remove = function(a) {
			a = this.pathPrefix + a;
			var b = this.assets[a];
			b.dispose && b.dispose();
			this.assets[a] = null;
		};
		a.prototype.removeAll = function() {
			for (var a in this.assets) {
				var k = this.assets[a];
				k.dispose && k.dispose();
			}
			this.assets = {};
		};
		a.prototype.isLoadingComplete = function() {
			return 0 == this.toLoad;
		};
		a.prototype.getToLoad = function() {
			return this.toLoad;
		};
		a.prototype.getLoaded = function() {
			return this.loaded;
		};
		a.prototype.dispose = function() {
			this.removeAll();
		};
		a.prototype.hasErrors = function() {
			return 0 < Object.keys(this.errors).length;
		};
		a.prototype.getErrors = function() {
			return this.errors;
		};
		return a;
	}();
	a.AssetManager = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function f(a) {
			this.atlas = a;
		}
		f.prototype.newRegionAttachment = function(b, k, h) {
			b = this.atlas.findRegion(h);
			if (null == b) {
				throw Error("Region not found in atlas: " + h + " (region attachment: " + k + ")");
			}
			b.renderObject = b;
			k = new a.RegionAttachment(k);
			k.setRegion(b);
			return k;
		};
		f.prototype.newMeshAttachment = function(b, k, h) {
			b = this.atlas.findRegion(h);
			if (null == b) {
				throw Error("Region not found in atlas: " + h + " (mesh attachment: " + k + ")");
			}
			b.renderObject = b;
			k = new a.MeshAttachment(k);
			k.region = b;
			return k;
		};
		f.prototype.newBoundingBoxAttachment = function(b, k) {
			return new a.BoundingBoxAttachment(k);
		};
		f.prototype.newPathAttachment = function(b, k) {
			return new a.PathAttachment(k);
		};
		return f;
	}();
	a.AtlasAttachmentLoader = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		return function(a) {
			if (null == a) {
				throw Error("name cannot be null.");
			}
			this.name = a;
		};
	}();
	a.Attachment = f;
	f = function(a) {
		function b(b) {
			a.call(this, b);
			this.worldVerticesLength = 0;
		}
		__extends(b, a);
		b.prototype.computeWorldVertices = function(a, b) {
			this.computeWorldVerticesWith(a, 0, this.worldVerticesLength, b, 0);
		};
		b.prototype.computeWorldVerticesWith = function(a, b, c, e, g) {
			c += g;
			var h = a.bone.skeleton, k = a.attachmentVertices, f = this.vertices, l = this.bones;
			if (null == l) {
				0 < k.length && (f = k);
				a = a.bone;
				var k = a.worldX, l = a.worldY, t = a.a, h = a.b, v = a.c;
				a = a.d;
				for (var y = b;g < c;y += 2, g += 2) {
					b = f[y];
					var x = f[y + 1];
					e[g] = b * t + x * h + k;
					e[g + 1] = b * v + x * a + l;
				}
			} else {
				for (x = a = t = 0;x < b;x += 2) {
					v = l[t], t += v + 1, a += v;
				}
				y = h.bones;
				if (0 == k.length) {
					for (h = 3 * a;g < c;g += 2) {
						for (var m = 0, u = 0, v = l[t++], v = v + t;t < v;t++, h += 3) {
							a = y[l[t]];
							b = f[h];
							var x = f[h + 1], B = f[h + 2], m = m + (b * a.a + x * a.b + a.worldX) * B, u = u + (b * a.c + x * a.d + a.worldY) * B;
						}
						e[g] = m;
						e[g + 1] = u;
					}
				} else {
					for (var h = 3 * a, A = a << 1;g < c;g += 2) {
						u = m = 0;
						v = l[t++];
						for (v += t;t < v;t++, h += 3, A += 2) {
							a = y[l[t]], b = f[h] + k[A], x = f[h + 1] + k[A + 1], B = f[h + 2], m += (b * a.a + x * a.b + a.worldX) * B, u += (b * a.c + x * a.d + a.worldY) * B;
						}
						e[g] = m;
						e[g + 1] = u;
					}
				}
			}
		};
		b.prototype.applyDeform = function(a) {
			return this == a;
		};
		return b;
	}(f);
	a.VertexAttachment = f;
})(spine || (spine = {}));
(function(a) {
	a = a.AttachmentType || (a.AttachmentType = {});
	a[a.Region = 0] = "Region";
	a[a.BoundingBox = 1] = "BoundingBox";
	a[a.Mesh = 2] = "Mesh";
	a[a.LinkedMesh = 3] = "LinkedMesh";
	a[a.Path = 4] = "Path";
})(spine || (spine = {}));
(function(a) {
	var f = function(f) {
		function b(b) {
			f.call(this, b);
			this.color = new a.Color(1, 1, 1, 1);
		}
		__extends(b, f);
		return b;
	}(a.VertexAttachment);
	a.BoundingBoxAttachment = f;
})(spine || (spine = {}));
(function(a) {
	var f = function(f) {
		function b(b) {
			f.call(this, b);
			this.color = new a.Color(1, 1, 1, 1);
			this.inheritDeform = !1;
			this.tempColor = new a.Color(0, 0, 0, 0);
		}
		__extends(b, f);
		b.prototype.updateUVs = function() {
			var b = this.regionUVs, h = b.length, c = 8 * (h >> 1);
			if (null == this.worldVertices || this.worldVertices.length != c) {
				this.worldVertices = a.Utils.newFloatArray(c);
			}
			var e, g, f;
			null == this.region ? (c = e = 0, g = f = 1) : (c = this.region.u, e = this.region.v, g = this.region.u2 - c, f = this.region.v2 - e);
			if (this.region.rotate) {
				for (var l = 0, w = 6;l < h;l += 2, w += 8) {
					this.worldVertices[w] = c + b[l + 1] * g, this.worldVertices[w + 1] = e + f - b[l] * f;
				}
			} else {
				for (l = 0, w = 6;l < h;l += 2, w += 8) {
					this.worldVertices[w] = c + b[l] * g, this.worldVertices[w + 1] = e + b[l + 1] * f;
				}
			}
		};
		b.prototype.updateWorldVertices = function(a, b) {
			var c = a.bone.skeleton, e = c.color, g = a.color, h = this.color, k = e.a * g.a * h.a;
			b = b ? k : 1;
			var f = this.tempColor;
			f.set(e.r * g.r * h.r * b, e.g * g.g * h.g * b, e.b * g.b * h.b * b, k);
			var l = a.attachmentVertices, e = this.vertices, g = this.worldVertices, t = this.bones;
			if (null == t) {
				t = e.length;
				0 < l.length && (e = l);
				a = a.bone;
				var l = a.worldX, v = a.worldY, y = a.a, c = a.b, x = a.c;
				a = a.d;
				for (k = h = 0;h < t;h += 2, k += 8) {
					b = e[h];
					var m = e[h + 1];
					g[k] = b * y + m * c + l;
					g[k + 1] = b * x + m * a + v;
					g[k + 2] = f.r;
					g[k + 3] = f.g;
					g[k + 4] = f.b;
					g[k + 5] = f.a;
				}
				return g;
			}
			v = c.bones;
			if (0 == l.length) {
				for (c = h = k = 0, y = t.length;h < y;k += 8) {
					for (var u = x = 0, B = t[h++] + h;h < B;h++, c += 3) {
						a = v[t[h]];
						b = e[c];
						var m = e[c + 1], A = e[c + 2], x = x + (b * a.a + m * a.b + a.worldX) * A, u = u + (b * a.c + m * a.d + a.worldY) * A;
					}
					g[k] = x;
					g[k + 1] = u;
					g[k + 2] = f.r;
					g[k + 3] = f.g;
					g[k + 4] = f.b;
					g[k + 5] = f.a;
				}
			} else {
				for (var D = c = h = k = 0, y = t.length;h < y;k += 8) {
					u = x = 0;
					for (B = t[h++] + h;h < B;h++, c += 3, D += 2) {
						a = v[t[h]], b = e[c] + l[D], m = e[c + 1] + l[D + 1], A = e[c + 2], x += (b * a.a + m * a.b + a.worldX) * A, u += (b * a.c + m * a.d + a.worldY) * A;
					}
					g[k] = x;
					g[k + 1] = u;
					g[k + 2] = f.r;
					g[k + 3] = f.g;
					g[k + 4] = f.b;
					g[k + 5] = f.a;
				}
			}
			return g;
		};
		b.prototype.applyDeform = function(a) {
			return this == a || this.inheritDeform && this.parentMesh == a;
		};
		b.prototype.getParentMesh = function() {
			return this.parentMesh;
		};
		b.prototype.setParentMesh = function(a) {
			this.parentMesh = a;
			null != a && (this.bones = a.bones, this.vertices = a.vertices, this.regionUVs = a.regionUVs, this.triangles = a.triangles, this.hullLength = a.hullLength);
		};
		return b;
	}(a.VertexAttachment);
	a.MeshAttachment = f;
})(spine || (spine = {}));
(function(a) {
	var f = function(f) {
		function b(b) {
			f.call(this, b);
			this.constantSpeed = this.closed = !1;
			this.color = new a.Color(1, 1, 1, 1);
		}
		__extends(b, f);
		return b;
	}(a.VertexAttachment);
	a.PathAttachment = f;
})(spine || (spine = {}));
(function(a) {
	var f = function(f) {
		function b(b) {
			f.call(this, b);
			this.y = this.x = 0;
			this.scaleY = this.scaleX = 1;
			this.height = this.width = this.rotation = 0;
			this.color = new a.Color(1, 1, 1, 1);
			this.offset = a.Utils.newFloatArray(8);
			this.vertices = a.Utils.newFloatArray(32);
			this.tempColor = new a.Color(1, 1, 1, 1);
		}
		__extends(b, f);
		b.prototype.setRegion = function(a) {
			var h = this.vertices;
			a.rotate ? (h[b.U2] = a.u, h[b.V2] = a.v2, h[b.U3] = a.u, h[b.V3] = a.v, h[b.U4] = a.u2, h[b.V4] = a.v, h[b.U1] = a.u2, h[b.V1] = a.v2) : (h[b.U1] = a.u, h[b.V1] = a.v2, h[b.U2] = a.u, h[b.V2] = a.v, h[b.U3] = a.u2, h[b.V3] = a.v, h[b.U4] = a.u2, h[b.V4] = a.v2);
			this.region = a;
		};
		b.prototype.updateOffset = function() {
			var a = this.width / this.region.originalWidth * this.scaleX, h = this.height / this.region.originalHeight * this.scaleY, c = -this.width / 2 * this.scaleX + this.region.offsetX * a, e = -this.height / 2 * this.scaleY + this.region.offsetY * h, g = c + this.region.width * a, a = e + this.region.height * h, h = this.rotation * Math.PI / 180, f = Math.cos(h), l = Math.sin(h), h = c * f + this.x, c = c * l, w = e * f + this.y, e = e * l, p = g * f + this.x, g = g * l, f = a * f + this.y, a = a * 
			l, l = this.offset;
			l[b.OX1] = h - e;
			l[b.OY1] = w + c;
			l[b.OX2] = h - a;
			l[b.OY2] = f + c;
			l[b.OX3] = p - a;
			l[b.OY3] = f + g;
			l[b.OX4] = p - e;
			l[b.OY4] = w + g;
		};
		b.prototype.updateWorldVertices = function(a, h) {
			var c = a.bone.skeleton.color, e = a.color, g = this.color, k = c.a * e.a * g.a;
			h = h ? k : 1;
			var f = this.tempColor;
			f.set(c.r * e.r * g.r * h, c.g * e.g * g.g * h, c.b * e.b * g.b * h, k);
			c = this.vertices;
			e = this.offset;
			a = a.bone;
			g = a.worldX;
			k = a.worldY;
			h = a.a;
			var l = a.b, p = a.c;
			a = a.d;
			var t, v;
			t = e[b.OX1];
			v = e[b.OY1];
			c[b.X1] = t * h + v * l + g;
			c[b.Y1] = t * p + v * a + k;
			c[b.C1R] = f.r;
			c[b.C1G] = f.g;
			c[b.C1B] = f.b;
			c[b.C1A] = f.a;
			t = e[b.OX2];
			v = e[b.OY2];
			c[b.X2] = t * h + v * l + g;
			c[b.Y2] = t * p + v * a + k;
			c[b.C2R] = f.r;
			c[b.C2G] = f.g;
			c[b.C2B] = f.b;
			c[b.C2A] = f.a;
			t = e[b.OX3];
			v = e[b.OY3];
			c[b.X3] = t * h + v * l + g;
			c[b.Y3] = t * p + v * a + k;
			c[b.C3R] = f.r;
			c[b.C3G] = f.g;
			c[b.C3B] = f.b;
			c[b.C3A] = f.a;
			t = e[b.OX4];
			v = e[b.OY4];
			c[b.X4] = t * h + v * l + g;
			c[b.Y4] = t * p + v * a + k;
			c[b.C4R] = f.r;
			c[b.C4G] = f.g;
			c[b.C4B] = f.b;
			c[b.C4A] = f.a;
			return c;
		};
		b.OX1 = 0;
		b.OY1 = 1;
		b.OX2 = 2;
		b.OY2 = 3;
		b.OX3 = 4;
		b.OY3 = 5;
		b.OX4 = 6;
		b.OY4 = 7;
		b.X1 = 0;
		b.Y1 = 1;
		b.C1R = 2;
		b.C1G = 3;
		b.C1B = 4;
		b.C1A = 5;
		b.U1 = 6;
		b.V1 = 7;
		b.X2 = 8;
		b.Y2 = 9;
		b.C2R = 10;
		b.C2G = 11;
		b.C2B = 12;
		b.C2A = 13;
		b.U2 = 14;
		b.V2 = 15;
		b.X3 = 16;
		b.Y3 = 17;
		b.C3R = 18;
		b.C3G = 19;
		b.C3B = 20;
		b.C3A = 21;
		b.U3 = 22;
		b.V3 = 23;
		b.X4 = 24;
		b.Y4 = 25;
		b.C4R = 26;
		b.C4G = 27;
		b.C4B = 28;
		b.C4A = 29;
		b.U4 = 30;
		b.V4 = 31;
		return b;
	}(a.Attachment);
	a.RegionAttachment = f;
})(spine || (spine = {}));
(function(a) {
	a = a.BlendMode || (a.BlendMode = {});
	a[a.Normal = 0] = "Normal";
	a[a.Additive = 1] = "Additive";
	a[a.Multiply = 2] = "Multiply";
	a[a.Screen = 3] = "Screen";
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function f(a, f, h) {
			this.children = [];
			this.ashearY = this.ashearX = this.ascaleY = this.ascaleX = this.arotation = this.ay = this.ax = this.shearY = this.shearX = this.scaleY = this.scaleX = this.rotation = this.y = this.x = 0;
			this.appliedValid = !1;
			this.worldY = this.d = this.c = this.worldX = this.b = this.a = 0;
			this.sorted = !1;
			if (null == a) {
				throw Error("data cannot be null.");
			}
			if (null == f) {
				throw Error("skeleton cannot be null.");
			}
			this.data = a;
			this.skeleton = f;
			this.parent = h;
			this.setToSetupPose();
		}
		f.prototype.update = function() {
			this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
		};
		f.prototype.updateWorldTransform = function() {
			this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
		};
		f.prototype.updateWorldTransformWith = function(b, f, h, c, e, g, l) {
			this.ax = b;
			this.ay = f;
			this.arotation = h;
			this.ascaleX = c;
			this.ascaleY = e;
			this.ashearX = g;
			this.ashearY = l;
			this.appliedValid = !0;
			var k = this.parent;
			if (null == k) {
				l = h + 90 + l;
				var k = a.MathUtils.cosDeg(h + g) * c, q = a.MathUtils.cosDeg(l) * e;
				c *= a.MathUtils.sinDeg(h + g);
				e *= a.MathUtils.sinDeg(l);
				var p = this.skeleton;
				p.flipX && (b = -b, k = -k, q = -q);
				p.flipY && (f = -f, c = -c, e = -e);
				this.a = k;
				this.b = q;
				this.c = c;
				this.d = e;
				this.worldX = b + p.x;
				this.worldY = f + p.y;
			} else {
				var p = k.a, t = k.b, v = k.c, y = k.d;
				this.worldX = p * b + t * f + k.worldX;
				this.worldY = v * b + y * f + k.worldY;
				switch(this.data.transformMode) {
					case a.TransformMode.Normal:
						l = h + 90 + l;
						k = a.MathUtils.cosDeg(h + g) * c;
						q = a.MathUtils.cosDeg(l) * e;
						c *= a.MathUtils.sinDeg(h + g);
						e *= a.MathUtils.sinDeg(l);
						this.a = p * k + t * c;
						this.b = p * q + t * e;
						this.c = v * k + y * c;
						this.d = v * q + y * e;
						return;
					case a.TransformMode.OnlyTranslation:
						l = h + 90 + l;
						this.a = a.MathUtils.cosDeg(h + g) * c;
						this.b = a.MathUtils.cosDeg(l) * e;
						this.c = a.MathUtils.sinDeg(h + g) * c;
						this.d = a.MathUtils.sinDeg(l) * e;
						break;
					case a.TransformMode.NoRotationOrReflection:
						k = p * p + v * v;
						1E-4 < k ? (k = Math.abs(p * y - t * v) / k, t = v * k, y = p * k, k = Math.atan2(v, p) * a.MathUtils.radDeg) : (v = p = 0, k = 90 - Math.atan2(y, t) * a.MathUtils.radDeg);
						g = h + g - k;
						l = h + l - k + 90;
						k = a.MathUtils.cosDeg(g) * c;
						q = a.MathUtils.cosDeg(l) * e;
						c *= a.MathUtils.sinDeg(g);
						e *= a.MathUtils.sinDeg(l);
						this.a = p * k - t * c;
						this.b = p * q - t * e;
						this.c = v * k + y * c;
						this.d = v * q + y * e;
						break;
					case a.TransformMode.NoScale:
					;
					case a.TransformMode.NoScaleOrReflection:
						k = a.MathUtils.cosDeg(h);
						q = a.MathUtils.sinDeg(h);
						h = p * k + t * q;
						b = v * k + y * q;
						k = Math.sqrt(h * h + b * b);
						1E-5 < k && (k = 1 / k);
						h *= k;
						b *= k;
						k = Math.sqrt(h * h + b * b);
						q = Math.PI / 2 + Math.atan2(b, h);
						f = Math.cos(q) * k;
						var x = Math.sin(q) * k, k = a.MathUtils.cosDeg(g) * c, q = a.MathUtils.cosDeg(90 + l) * e;
						c *= a.MathUtils.sinDeg(g);
						e *= a.MathUtils.sinDeg(90 + l);
						this.a = h * k + f * c;
						this.b = h * q + f * e;
						this.c = b * k + x * c;
						this.d = b * q + x * e;
						if (this.data.transformMode != a.TransformMode.NoScaleOrReflection ? 0 > p * y - t * v : this.skeleton.flipX != this.skeleton.flipY) {
							this.b = -this.b, this.d = -this.d;
						}
						return;
				}
				this.skeleton.flipX && (this.a = -this.a, this.b = -this.b);
				this.skeleton.flipY && (this.c = -this.c, this.d = -this.d);
			}
		};
		f.prototype.setToSetupPose = function() {
			var a = this.data;
			this.x = a.x;
			this.y = a.y;
			this.rotation = a.rotation;
			this.scaleX = a.scaleX;
			this.scaleY = a.scaleY;
			this.shearX = a.shearX;
			this.shearY = a.shearY;
		};
		f.prototype.getWorldRotationX = function() {
			return Math.atan2(this.c, this.a) * a.MathUtils.radDeg;
		};
		f.prototype.getWorldRotationY = function() {
			return Math.atan2(this.d, this.b) * a.MathUtils.radDeg;
		};
		f.prototype.getWorldScaleX = function() {
			return Math.sqrt(this.a * this.a + this.c * this.c);
		};
		f.prototype.getWorldScaleY = function() {
			return Math.sqrt(this.b * this.b + this.d * this.d);
		};
		f.prototype.worldToLocalRotationX = function() {
			var b = this.parent;
			if (null == b) {
				return this.arotation;
			}
			var k = this.a, h = this.c;
			return Math.atan2(b.a * h - b.c * k, b.d * k - b.b * h) * a.MathUtils.radDeg;
		};
		f.prototype.worldToLocalRotationY = function() {
			var b = this.parent;
			if (null == b) {
				return this.arotation;
			}
			var k = this.b, h = this.d;
			return Math.atan2(b.a * h - b.c * k, b.d * k - b.b * h) * a.MathUtils.radDeg;
		};
		f.prototype.rotateWorld = function(b) {
			var k = this.a, h = this.b, c = this.c, e = this.d, g = a.MathUtils.cosDeg(b);
			b = a.MathUtils.sinDeg(b);
			this.a = g * k - b * c;
			this.b = g * h - b * e;
			this.c = b * k + g * c;
			this.d = b * h + g * e;
			this.appliedValid = !1;
		};
		f.prototype.updateAppliedTransform = function() {
			this.appliedValid = !0;
			var b = this.parent;
			if (null == b) {
				this.ax = this.worldX, this.ay = this.worldY, this.arotation = Math.atan2(this.c, this.a) * a.MathUtils.radDeg, this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c), this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d), this.ashearX = 0, this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * a.MathUtils.radDeg;
			} else {
				var k = b.a, h = b.b, c = b.c, e = b.d, g = 1 / (k * e - h * c), f = this.worldX - b.worldX, b = this.worldY - b.worldY;
				this.ax = f * e * g - b * h * g;
				this.ay = b * k * g - f * c * g;
				e *= g;
				k *= g;
				h *= g;
				g *= c;
				c = e * this.a - h * this.c;
				h = e * this.b - h * this.d;
				e = k * this.c - g * this.a;
				g = k * this.d - g * this.b;
				this.ashearX = 0;
				this.ascaleX = Math.sqrt(c * c + e * e);
				1E-4 < this.ascaleX ? (k = c * g - h * e, this.ascaleY = k / this.ascaleX, this.ashearY = Math.atan2(c * h + e * g, k) * a.MathUtils.radDeg, this.arotation = Math.atan2(e, c) * a.MathUtils.radDeg) : (this.ascaleX = 0, this.ascaleY = Math.sqrt(h * h + g * g), this.ashearY = 0, this.arotation = 90 - Math.atan2(g, h) * a.MathUtils.radDeg);
			}
		};
		f.prototype.worldToLocal = function(a) {
			var b = this.a, h = this.b, c = this.c, e = this.d, g = 1 / (b * e - h * c), f = a.x - this.worldX, l = a.y - this.worldY;
			a.x = f * e * g - l * h * g;
			a.y = l * b * g - f * c * g;
			return a;
		};
		f.prototype.localToWorld = function(a) {
			var b = a.x, h = a.y;
			a.x = b * this.a + h * this.b + this.worldX;
			a.y = b * this.c + h * this.d + this.worldY;
			return a;
		};
		return f;
	}();
	a.Bone = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		return function(a, k, h) {
			this.rotation = this.y = this.x = 0;
			this.scaleY = this.scaleX = 1;
			this.shearY = this.shearX = 0;
			this.transformMode = l.Normal;
			if (0 > a) {
				throw Error("index must be >= 0.");
			}
			if (null == k) {
				throw Error("name cannot be null.");
			}
			this.index = a;
			this.name = k;
			this.parent = h;
		};
	}();
	a.BoneData = f;
	(function(a) {
		a[a.Normal = 0] = "Normal";
		a[a.OnlyTranslation = 1] = "OnlyTranslation";
		a[a.NoRotationOrReflection = 2] = "NoRotationOrReflection";
		a[a.NoScale = 3] = "NoScale";
		a[a.NoScaleOrReflection = 4] = "NoScaleOrReflection";
	})(a.TransformMode || (a.TransformMode = {}));
	var l = a.TransformMode;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		return function(a, b) {
			if (null == b) {
				throw Error("data cannot be null.");
			}
			this.time = a;
			this.data = b;
		};
	}();
	a.Event = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		return function(a) {
			this.name = a;
		};
	}();
	a.EventData = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function f(a, f) {
			this.mix = 1;
			this.bendDirection = 0;
			if (null == a) {
				throw Error("data cannot be null.");
			}
			if (null == f) {
				throw Error("skeleton cannot be null.");
			}
			this.data = a;
			this.mix = a.mix;
			this.bendDirection = a.bendDirection;
			this.bones = [];
			for (var b = 0;b < a.bones.length;b++) {
				this.bones.push(f.findBone(a.bones[b].name));
			}
			this.target = f.findBone(a.target.name);
		}
		f.prototype.getOrder = function() {
			return this.data.order;
		};
		f.prototype.apply = function() {
			this.update();
		};
		f.prototype.update = function() {
			var a = this.target, f = this.bones;
			switch(f.length) {
				case 1:
					this.apply1(f[0], a.worldX, a.worldY, this.mix);
					break;
				case 2:
					this.apply2(f[0], f[1], a.worldX, a.worldY, this.bendDirection, this.mix);
			}
		};
		f.prototype.apply1 = function(b, f, h, c) {
			b.appliedValid || b.updateAppliedTransform();
			var e = b.parent, g = 1 / (e.a * e.d - e.b * e.c);
			f -= e.worldX;
			h -= e.worldY;
			e = Math.atan2((h * e.a - f * e.c) * g - b.ay, (f * e.d - h * e.b) * g - b.ax) * a.MathUtils.radDeg - b.ashearX - b.arotation;
			0 > b.ascaleX && (e += 180);
			180 < e ? e -= 360 : -180 > e && (e += 360);
			b.updateWorldTransformWith(b.ax, b.ay, b.arotation + e * c, b.ascaleX, b.ascaleY, b.ashearX, b.ashearY);
		};
		f.prototype.apply2 = function(b, f, h, c, e, g) {
			if (0 == g) {
				f.updateWorldTransform();
			} else {
				b.appliedValid || b.updateAppliedTransform();
				f.appliedValid || f.updateAppliedTransform();
				var k = b.ax, l = b.ay, w = b.ascaleX, p = b.ascaleY, t = f.ascaleX, v, y, x;
				0 > w ? (w = -w, v = 180, x = -1) : (v = 0, x = 1);
				0 > p && (p = -p, x = -x);
				0 > t ? (t = -t, y = 180) : y = 0;
				var m = f.ax, u, B, A, D = b.a, G = b.b, F = b.c, C = b.d, J = 1E-4 >= Math.abs(w - p);
				J ? (u = f.ay, B = D * m + G * u + b.worldX, A = F * m + C * u + b.worldY) : (u = 0, B = D * m + b.worldX, A = F * m + b.worldY);
				var I = b.parent, D = I.a, G = I.b, F = I.c, C = I.d, Q = 1 / (D * C - G * F);
				h -= I.worldX;
				c -= I.worldY;
				var M = (h * C - c * G) * Q - k, N = (c * D - h * F) * Q - l;
				h = B - I.worldX;
				c = A - I.worldY;
				G = (h * C - c * G) * Q - k;
				D = (c * D - h * F) * Q - l;
				Q = Math.sqrt(G * G + D * D);
				G = f.data.length * t;
				if (J) {
					G *= w, D = (M * M + N * N - Q * Q - G * G) / (2 * Q * G), -1 > D ? D = -1 : 1 < D && (D = 1), e *= Math.acos(D), D = Q + G * D, G *= Math.sin(e), D = Math.atan2(N * D - M * G, M * D + N * G);
				} else {
					if (D = w * G, G *= p, c = D * D, t = G * G, J = M * M + N * N, M = Math.atan2(N, M), F = t * Q * Q + c * J - c * t, h = -2 * t * Q, N = t - c, C = h * h - 4 * N * F, 0 <= C && (C = Math.sqrt(C), 0 > h && (C = -C), C = -(h + C) / 2, h = C / N, C = F / C, C = Math.abs(h) < Math.abs(C) ? h : C, C * C <= J)) {
						c = Math.sqrt(J - C * C) * e, D = M - Math.atan2(c, C), e = Math.atan2(c / p, (C - Q) / w);
					} else {
						var w = 0, F = Number.MAX_VALUE, R = I = A = p = B = N = 0;
						h = Q + D;
						C = h * h;
						C > A && (p = 0, A = C, I = h);
						h = Q - D;
						C = h * h;
						C < F && (w = a.MathUtils.PI, F = C, N = h);
						t = Math.acos(-D * Q / (c - t));
						h = D * Math.cos(t) + Q;
						c = G * Math.sin(t);
						C = h * h + c * c;
						C < F && (w = t, F = C, N = h, B = c);
						C > A && (p = t, A = C, I = h, R = c);
						J <= (F + A) / 2 ? (D = M - Math.atan2(B * e, N), e *= w) : (D = M - Math.atan2(R * e, I), e *= p);
					}
				}
				G = Math.atan2(u, m) * x;
				Q = b.arotation;
				D = (D - G) * a.MathUtils.radDeg + v - Q;
				180 < D ? D -= 360 : -180 > D && (D += 360);
				b.updateWorldTransformWith(k, l, Q + D * g, b.ascaleX, b.ascaleY, 0, 0);
				Q = f.arotation;
				e = ((e + G) * a.MathUtils.radDeg - f.ashearX) * x + y - Q;
				180 < e ? e -= 360 : -180 > e && (e += 360);
				f.updateWorldTransformWith(m, u, Q + e * g, f.ascaleX, f.ascaleY, f.ashearX, f.ashearY);
			}
		};
		return f;
	}();
	a.IkConstraint = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		return function(a) {
			this.order = 0;
			this.bones = [];
			this.mix = this.bendDirection = 1;
			this.name = a;
		};
	}();
	a.IkConstraintData = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function f(a, f) {
			this.translateMix = this.rotateMix = this.spacing = this.position = 0;
			this.spaces = [];
			this.positions = [];
			this.world = [];
			this.curves = [];
			this.lengths = [];
			this.segments = [];
			if (null == a) {
				throw Error("data cannot be null.");
			}
			if (null == f) {
				throw Error("skeleton cannot be null.");
			}
			this.data = a;
			this.bones = [];
			for (var b = 0, c = a.bones.length;b < c;b++) {
				this.bones.push(f.findBone(a.bones[b].name));
			}
			this.target = f.findSlot(a.target.name);
			this.position = a.position;
			this.spacing = a.spacing;
			this.rotateMix = a.rotateMix;
			this.translateMix = a.translateMix;
		}
		f.prototype.apply = function() {
			this.update();
		};
		f.prototype.update = function() {
			var b = this.target.getAttachment();
			if (b instanceof a.PathAttachment) {
				var f = this.rotateMix, h = this.translateMix, c = 0 < f;
				if (0 < h || c) {
					var e = this.data, g = e.spacingMode, l = g == a.SpacingMode.Length, r = e.rotateMode, w = r == a.RotateMode.Tangent, p = r == a.RotateMode.ChainScale, t = this.bones.length, v = w ? t : t + 1, y = this.bones, x = a.Utils.setArraySize(this.spaces, v), m = null, u = this.spacing;
					if (p || l) {
						p && (m = a.Utils.setArraySize(this.lengths, t));
						for (var B = 0, A = v - 1;B < A;) {
							var D = y[B], G = D.data.length, F = G * D.a, G = G * D.c, G = Math.sqrt(F * F + G * G);
							p && (m[B] = G);
							x[++B] = l ? Math.max(0, G + u) : u;
						}
					} else {
						for (B = 1;B < v;B++) {
							x[B] = u;
						}
					}
					b = this.computeWorldPositions(b, v, w, e.positionMode == a.PositionMode.Percent, g == a.SpacingMode.Percent);
					g = b[0];
					l = b[1];
					e = e.offsetRotation;
					0 == e ? r = r == a.RotateMode.Chain : (r = !1, v = this.target.bone, e *= 0 < v.a * v.d - v.b * v.c ? a.MathUtils.degRad : -a.MathUtils.degRad);
					B = 0;
					for (v = 3;B < t;B++, v += 3) {
						D = y[B];
						D.worldX += (g - D.worldX) * h;
						D.worldY += (l - D.worldY) * h;
						F = b[v];
						G = b[v + 1];
						u = F - g;
						A = G - l;
						p && (g = m[B], 0 != g && (g = (Math.sqrt(u * u + A * A) / g - 1) * f + 1, D.a *= g, D.c *= g));
						g = F;
						l = G;
						if (c) {
							var F = D.a, G = D.b, C = D.c, J = D.d, I, Q, M;
							I = w ? b[v - 1] : 0 == x[B + 1] ? b[v + 2] : Math.atan2(A, u);
							I -= Math.atan2(C, F);
							if (r) {
								Q = Math.cos(I);
								M = Math.sin(I);
								var N = D.data.length, g = g + (N * (Q * F - M * C) - u) * f, l = l + (N * (M * F + Q * C) - A) * f;
							} else {
								I += e;
							}
							I > a.MathUtils.PI ? I -= a.MathUtils.PI2 : I < -a.MathUtils.PI && (I += a.MathUtils.PI2);
							I *= f;
							Q = Math.cos(I);
							M = Math.sin(I);
							D.a = Q * F - M * C;
							D.b = Q * G - M * J;
							D.c = M * F + Q * C;
							D.d = M * G + Q * J;
						}
						D.appliedValid = !1;
					}
				}
			}
		};
		f.prototype.computeWorldPositions = function(b, k, h, c, e) {
			var g = this.target, l = this.position, r = this.spaces, w = a.Utils.setArraySize(this.positions, 3 * k + 2), p, t = b.closed, v = b.worldVerticesLength, y = v / 6, x = f.NONE;
			if (!b.constantSpeed) {
				var m = b.lengths, y = y - (t ? 1 : 2), u = m[y];
				c && (l *= u);
				if (e) {
					for (var B = 0;B < k;B++) {
						r[B] *= u;
					}
				}
				p = a.Utils.setArraySize(this.world, 8);
				for (e = c = B = 0;B < k;B++, c += 3) {
					var A = r[B], D = l += A;
					if (t) {
						D %= u, 0 > D && (D += u), e = 0;
					} else {
						if (0 > D) {
							x != f.BEFORE && (x = f.BEFORE, b.computeWorldVerticesWith(g, 2, 4, p, 0));
							this.addBeforePosition(D, p, 0, w, c);
							continue;
						} else {
							if (D > u) {
								x != f.AFTER && (x = f.AFTER, b.computeWorldVerticesWith(g, v - 6, 4, p, 0));
								this.addAfterPosition(D - u, p, 0, w, c);
								continue;
							}
						}
					}
					for (;;e++) {
						var G = m[e];
						if (!(D > G)) {
							if (0 == e) {
								D /= G;
							} else {
								var F = m[e - 1], D = (D - F) / (G - F)
							}
							break;
						}
					}
					e != x && (x = e, t && e == y ? (b.computeWorldVerticesWith(g, v - 4, 4, p, 0), b.computeWorldVerticesWith(g, 0, 4, p, 4)) : b.computeWorldVerticesWith(g, 6 * e + 2, 8, p, 0));
					this.addCurvePosition(D, p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], w, c, h || 0 < B && 0 == A);
				}
				return w;
			}
			t ? (v += 2, p = a.Utils.setArraySize(this.world, v), b.computeWorldVerticesWith(g, 2, v - 4, p, 0), b.computeWorldVerticesWith(g, 0, 2, p, v - 4), p[v - 2] = p[0], p[v - 1] = p[1]) : (y--, v -= 4, p = a.Utils.setArraySize(this.world, v), b.computeWorldVerticesWith(g, 2, v, p, 0));
			b = a.Utils.setArraySize(this.curves, y);
			for (var g = 0, m = p[0], u = p[1], C = G = 0, J = 0, I = 0, Q = 0, M = 0, N, R, H, ba, ha, B = 0, A = 2;B < y;B++, A += 6) {
				G = p[A], C = p[A + 1], J = p[A + 2], I = p[A + 3], Q = p[A + 4], M = p[A + 5], N = .1875 * (m - 2 * G + J), R = .1875 * (u - 2 * C + I), F = .09375 * (3 * (G - J) - m + Q), H = .09375 * (3 * (C - I) - u + M), ba = 2 * N + F, ha = 2 * R + H, N = .75 * (G - m) + N + .16666667 * F, R = .75 * (C - u) + R + .16666667 * H, g += Math.sqrt(N * N + R * R), N += ba, R += ha, ba += F, ha += H, g += Math.sqrt(N * N + R * R), N += ba, R += ha, g += Math.sqrt(N * N + R * R), N += ba + F, R += ha + H, 
				g += Math.sqrt(N * N + R * R), b[B] = g, m = Q, u = M;
			}
			c && (l *= g);
			if (e) {
				for (B = 0;B < k;B++) {
					r[B] *= g;
				}
			}
			var y = this.segments, Y = 0;
			for (H = e = c = B = 0;B < k;B++, c += 3) {
				A = r[B];
				D = l += A;
				if (t) {
					D %= g, 0 > D && (D += g), e = 0;
				} else {
					if (0 > D) {
						this.addBeforePosition(D, p, 0, w, c);
						continue;
					} else {
						if (D > g) {
							this.addAfterPosition(D - g, p, v - 4, w, c);
							continue;
						}
					}
				}
				for (;;e++) {
					if (ba = b[e], !(D > ba)) {
						0 == e ? D /= ba : (F = b[e - 1], D = (D - F) / (ba - F));
						break;
					}
				}
				if (e != x) {
					var x = e, ga = 6 * e, m = p[ga], u = p[ga + 1], G = p[ga + 2], C = p[ga + 3], J = p[ga + 4], I = p[ga + 5], Q = p[ga + 6], M = p[ga + 7];
					N = .03 * (m - 2 * G + J);
					R = .03 * (u - 2 * C + I);
					F = .006 * (3 * (G - J) - m + Q);
					H = .006 * (3 * (C - I) - u + M);
					ba = 2 * N + F;
					ha = 2 * R + H;
					N = .3 * (G - m) + N + .16666667 * F;
					R = .3 * (C - u) + R + .16666667 * H;
					Y = Math.sqrt(N * N + R * R);
					y[0] = Y;
					for (ga = 1;8 > ga;ga++) {
						N += ba, R += ha, ba += F, ha += H, Y += Math.sqrt(N * N + R * R), y[ga] = Y;
					}
					N += ba;
					R += ha;
					Y += Math.sqrt(N * N + R * R);
					y[8] = Y;
					N += ba + F;
					R += ha + H;
					Y += Math.sqrt(N * N + R * R);
					y[9] = Y;
					H = 0;
				}
				for (D *= Y;;H++) {
					if (ba = y[H], !(D > ba)) {
						0 == H ? D /= ba : (F = y[H - 1], D = H + (D - F) / (ba - F));
						break;
					}
				}
				this.addCurvePosition(.1 * D, m, u, G, C, J, I, Q, M, w, c, h || 0 < B && 0 == A);
			}
			return w;
		};
		f.prototype.addBeforePosition = function(a, f, h, c, e) {
			var b = f[h], k = f[h + 1];
			f = Math.atan2(f[h + 3] - k, f[h + 2] - b);
			c[e] = b + a * Math.cos(f);
			c[e + 1] = k + a * Math.sin(f);
			c[e + 2] = f;
		};
		f.prototype.addAfterPosition = function(a, f, h, c, e) {
			var b = f[h + 2], k = f[h + 3];
			f = Math.atan2(k - f[h + 1], b - f[h]);
			c[e] = b + a * Math.cos(f);
			c[e + 1] = k + a * Math.sin(f);
			c[e + 2] = f;
		};
		f.prototype.addCurvePosition = function(a, f, h, c, e, g, l, r, w, p, t, v) {
			if (0 == a || isNaN(a)) {
				a = 1E-4;
			}
			var b = a * a, k = b * a, m = 1 - a, q = m * m, B = q * m, A = m * a, D = 3 * A, m = m * D;
			a *= D;
			r = f * B + c * m + g * a + r * k;
			w = h * B + e * m + l * a + w * k;
			p[t] = r;
			p[t + 1] = w;
			v && (p[t + 2] = Math.atan2(w - (h * q + e * A * 2 + l * b), r - (f * q + c * A * 2 + g * b)));
		};
		f.prototype.getOrder = function() {
			return this.data.order;
		};
		f.NONE = -1;
		f.BEFORE = -2;
		f.AFTER = -3;
		return f;
	}();
	a.PathConstraint = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		return function(a) {
			this.order = 0;
			this.bones = [];
			this.name = a;
		};
	}();
	a.PathConstraintData = f;
	(function(a) {
		a[a.Fixed = 0] = "Fixed";
		a[a.Percent = 1] = "Percent";
	})(a.PositionMode || (a.PositionMode = {}));
	(function(a) {
		a[a.Length = 0] = "Length";
		a[a.Fixed = 1] = "Fixed";
		a[a.Percent = 2] = "Percent";
	})(a.SpacingMode || (a.SpacingMode = {}));
	(function(a) {
		a[a.Tangent = 0] = "Tangent";
		a[a.Chain = 1] = "Chain";
		a[a.ChainScale = 2] = "ChainScale";
	})(a.RotateMode || (a.RotateMode = {}));
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function a(a) {
			this.toLoad = [];
			this.assets = {};
			this.clientId = a;
		}
		a.prototype.loaded = function() {
			var a = 0, b;
			for (b in this.assets) {
				a++;
			}
			return a;
		};
		return a;
	}(), l = function() {
		function a(a) {
			void 0 === a && (a = "");
			this.clientAssets = {};
			this.queuedAssets = {};
			this.rawAssets = {};
			this.errors = {};
			this.pathPrefix = a;
		}
		a.prototype.queueAsset = function(a, b, c) {
			var e = this.clientAssets[a];
			if (null === e || void 0 === e) {
				e = new f(a), this.clientAssets[a] = e;
			}
			null !== b && (e.textureLoader = b);
			e.toLoad.push(c);
			if (this.queuedAssets[c] === c) {
				return !1;
			}
			this.queuedAssets[c] = c;
			return !0;
		};
		a.prototype.loadText = function(a, b) {
			var c = this;
			b = this.pathPrefix + b;
			if (this.queueAsset(a, null, b)) {
				var e = new XMLHttpRequest;
				e.onreadystatechange = function() {
					e.readyState == XMLHttpRequest.DONE && (200 <= e.status && 300 > e.status ? c.rawAssets[b] = e.responseText : c.errors[b] = "Couldn't load text " + b + ": status " + e.status + ", " + e.responseText);
				};
				e.open("GET", b, !0);
				e.send();
			}
		};
		a.prototype.loadJson = function(a, b) {
			var c = this;
			b = this.pathPrefix + b;
			if (this.queueAsset(a, null, b)) {
				var e = new XMLHttpRequest;
				e.onreadystatechange = function() {
					e.readyState == XMLHttpRequest.DONE && (200 <= e.status && 300 > e.status ? c.rawAssets[b] = JSON.parse(e.responseText) : c.errors[b] = "Couldn't load text " + b + ": status " + e.status + ", " + e.responseText);
				};
				e.open("GET", b, !0);
				e.send();
			}
		};
		a.prototype.loadTexture = function(a, b, c) {
			var e = this;
			c = this.pathPrefix + c;
			if (this.queueAsset(a, b, c)) {
				var g = new Image;
				g.src = c;
				g.crossOrigin = "anonymous";
				g.onload = function(a) {
					e.rawAssets[c] = g;
				};
				g.onerror = function(a) {
					e.errors[c] = "Couldn't load image " + c;
				};
			}
		};
		a.prototype.get = function(a, b) {
			b = this.pathPrefix + b;
			a = this.clientAssets[a];
			return null === a || void 0 === a ? !0 : a.assets[b];
		};
		a.prototype.updateClientAssets = function(a) {
			for (var b = 0;b < a.toLoad.length;b++) {
				var c = a.toLoad[b], e = a.assets[c];
				if (null === e || void 0 === e) {
					e = this.rawAssets[c], null !== e && void 0 !== e && (a.assets[c] = e instanceof HTMLImageElement ? a.textureLoader(e) : e);
				}
			}
		};
		a.prototype.isLoadingComplete = function(a) {
			a = this.clientAssets[a];
			if (null === a || void 0 === a) {
				return !0;
			}
			this.updateClientAssets(a);
			return a.toLoad.length == a.loaded();
		};
		a.prototype.dispose = function() {
		};
		a.prototype.hasErrors = function() {
			return 0 < Object.keys(this.errors).length;
		};
		a.prototype.getErrors = function() {
			return this.errors;
		};
		return a;
	}();
	a.SharedAssetManager = l;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function f(b) {
			this._updateCache = [];
			this.updateCacheReset = [];
			this.time = 0;
			this.flipY = this.flipX = !1;
			this.y = this.x = 0;
			if (null == b) {
				throw Error("data cannot be null.");
			}
			this.data = b;
			this.bones = [];
			for (var f = 0;f < b.bones.length;f++) {
				var h = b.bones[f];
				if (null == h.parent) {
					h = new a.Bone(h, this, null);
				} else {
					var c = this.bones[h.parent.index], h = new a.Bone(h, this, c);
					c.children.push(h);
				}
				this.bones.push(h);
			}
			this.slots = [];
			this.drawOrder = [];
			for (f = 0;f < b.slots.length;f++) {
				c = b.slots[f], h = this.bones[c.boneData.index], h = new a.Slot(c, h), this.slots.push(h), this.drawOrder.push(h);
			}
			this.ikConstraints = [];
			for (f = 0;f < b.ikConstraints.length;f++) {
				this.ikConstraints.push(new a.IkConstraint(b.ikConstraints[f], this));
			}
			this.transformConstraints = [];
			for (f = 0;f < b.transformConstraints.length;f++) {
				this.transformConstraints.push(new a.TransformConstraint(b.transformConstraints[f], this));
			}
			this.pathConstraints = [];
			for (f = 0;f < b.pathConstraints.length;f++) {
				this.pathConstraints.push(new a.PathConstraint(b.pathConstraints[f], this));
			}
			this.color = new a.Color(1, 1, 1, 1);
			this.updateCache();
		}
		f.prototype.updateCache = function() {
			this._updateCache.length = 0;
			for (var a = this.bones, f = 0, h = a.length;f < h;f++) {
				a[f].sorted = !1;
			}
			var h = this.ikConstraints, c = this.transformConstraints, e = this.pathConstraints, g = h.length, l = c.length, r = e.length, w = g + l + r, f = 0;
			a: for (;f < w;f++) {
				for (var p = 0;p < g;p++) {
					var t = h[p];
					if (t.data.order == f) {
						this.sortIkConstraint(t);
						continue a;
					}
				}
				for (p = 0;p < l;p++) {
					if (t = c[p], t.data.order == f) {
						this.sortTransformConstraint(t);
						continue a;
					}
				}
				for (p = 0;p < r;p++) {
					if (t = e[p], t.data.order == f) {
						this.sortPathConstraint(t);
						continue a;
					}
				}
			}
			f = 0;
			for (h = a.length;f < h;f++) {
				this.sortBone(a[f]);
			}
		};
		f.prototype.sortIkConstraint = function(a) {
			this.sortBone(a.target);
			var b = a.bones, h = b[0];
			this.sortBone(h);
			if (1 < b.length) {
				var c = b[b.length - 1];
				-1 < this._updateCache.indexOf(c) || this.updateCacheReset.push(c);
			}
			this._updateCache.push(a);
			this.sortReset(h.children);
			b[b.length - 1].sorted = !0;
		};
		f.prototype.sortPathConstraint = function(b) {
			var f = b.target, h = f.data.index, c = f.bone;
			null != this.skin && this.sortPathConstraintAttachment(this.skin, h, c);
			null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, h, c);
			for (var e = 0, g = this.data.skins.length;e < g;e++) {
				this.sortPathConstraintAttachment(this.data.skins[e], h, c);
			}
			e = f.getAttachment();
			e instanceof a.PathAttachment && this.sortPathConstraintAttachmentWith(e, c);
			c = b.bones;
			f = c.length;
			for (e = 0;e < f;e++) {
				this.sortBone(c[e]);
			}
			this._updateCache.push(b);
			for (e = 0;e < f;e++) {
				this.sortReset(c[e].children);
			}
			for (e = 0;e < f;e++) {
				c[e].sorted = !0;
			}
		};
		f.prototype.sortTransformConstraint = function(a) {
			this.sortBone(a.target);
			for (var b = a.bones, h = b.length, c = 0;c < h;c++) {
				this.sortBone(b[c]);
			}
			this._updateCache.push(a);
			for (c = 0;c < h;c++) {
				this.sortReset(b[c].children);
			}
			for (c = 0;c < h;c++) {
				b[c].sorted = !0;
			}
		};
		f.prototype.sortPathConstraintAttachment = function(a, f, h) {
			if (a = a.attachments[f]) {
				for (var b in a) {
					this.sortPathConstraintAttachmentWith(a[b], h);
				}
			}
		};
		f.prototype.sortPathConstraintAttachmentWith = function(b, f) {
			if (b instanceof a.PathAttachment) {
				if (b = b.bones, null == b) {
					this.sortBone(f);
				} else {
					f = this.bones;
					for (var h = 0;h < b.length;) {
						for (var c = b[h++], c = h + c;h < c;h++) {
							this.sortBone(f[b[h]]);
						}
					}
				}
			}
		};
		f.prototype.sortBone = function(a) {
			if (!a.sorted) {
				var b = a.parent;
				null != b && this.sortBone(b);
				a.sorted = !0;
				this._updateCache.push(a);
			}
		};
		f.prototype.sortReset = function(a) {
			for (var b = 0, h = a.length;b < h;b++) {
				var c = a[b];
				c.sorted && this.sortReset(c.children);
				c.sorted = !1;
			}
		};
		f.prototype.updateWorldTransform = function() {
			for (var a = this.updateCacheReset, f = 0, h = a.length;f < h;f++) {
				var c = a[f];
				c.ax = c.x;
				c.ay = c.y;
				c.arotation = c.rotation;
				c.ascaleX = c.scaleX;
				c.ascaleY = c.scaleY;
				c.ashearX = c.shearX;
				c.ashearY = c.shearY;
				c.appliedValid = !0;
			}
			a = this._updateCache;
			f = 0;
			for (h = a.length;f < h;f++) {
				a[f].update();
			}
		};
		f.prototype.setToSetupPose = function() {
			this.setBonesToSetupPose();
			this.setSlotsToSetupPose();
		};
		f.prototype.setBonesToSetupPose = function() {
			for (var a = this.bones, f = 0, h = a.length;f < h;f++) {
				a[f].setToSetupPose();
			}
			for (var c = this.ikConstraints, f = 0, h = c.length;f < h;f++) {
				a = c[f], a.bendDirection = a.data.bendDirection, a.mix = a.data.mix;
			}
			for (var e = this.transformConstraints, f = 0, h = e.length;f < h;f++) {
				a = e[f], c = a.data, a.rotateMix = c.rotateMix, a.translateMix = c.translateMix, a.scaleMix = c.scaleMix, a.shearMix = c.shearMix;
			}
			e = this.pathConstraints;
			f = 0;
			for (h = e.length;f < h;f++) {
				a = e[f], c = a.data, a.position = c.position, a.spacing = c.spacing, a.rotateMix = c.rotateMix, a.translateMix = c.translateMix;
			}
		};
		f.prototype.setSlotsToSetupPose = function() {
			var b = this.slots;
			a.Utils.arrayCopy(b, 0, this.drawOrder, 0, b.length);
			for (var f = 0, h = b.length;f < h;f++) {
				b[f].setToSetupPose();
			}
		};
		f.prototype.getRootBone = function() {
			return 0 == this.bones.length ? null : this.bones[0];
		};
		f.prototype.findBone = function(a) {
			if (null == a) {
				throw Error("boneName cannot be null.");
			}
			for (var b = this.bones, h = 0, c = b.length;h < c;h++) {
				var e = b[h];
				if (e.data.name == a) {
					return e;
				}
			}
			return null;
		};
		f.prototype.findBoneIndex = function(a) {
			if (null == a) {
				throw Error("boneName cannot be null.");
			}
			for (var b = this.bones, h = 0, c = b.length;h < c;h++) {
				if (b[h].data.name == a) {
					return h;
				}
			}
			return -1;
		};
		f.prototype.findSlot = function(a) {
			if (null == a) {
				throw Error("slotName cannot be null.");
			}
			for (var b = this.slots, h = 0, c = b.length;h < c;h++) {
				var e = b[h];
				if (e.data.name == a) {
					return e;
				}
			}
			return null;
		};
		f.prototype.findSlotIndex = function(a) {
			if (null == a) {
				throw Error("slotName cannot be null.");
			}
			for (var b = this.slots, h = 0, c = b.length;h < c;h++) {
				if (b[h].data.name == a) {
					return h;
				}
			}
			return -1;
		};
		f.prototype.setSkinByName = function(a) {
			var b = this.data.findSkin(a);
			if (null == b) {
				throw Error("Skin not found: " + a);
			}
			this.setSkin(b);
		};
		f.prototype.setSkin = function(a) {
			if (null != a) {
				if (null != this.skin) {
					a.attachAll(this, this.skin);
				} else {
					for (var b = this.slots, h = 0, c = b.length;h < c;h++) {
						var e = b[h], g = e.data.attachmentName;
						null != g && (g = a.getAttachment(h, g), null != g && e.setAttachment(g));
					}
				}
			}
			this.skin = a;
		};
		f.prototype.getAttachmentByName = function(a, f) {
			return this.getAttachment(this.data.findSlotIndex(a), f);
		};
		f.prototype.getAttachment = function(a, f) {
			if (null == f) {
				throw Error("attachmentName cannot be null.");
			}
			if (null != this.skin) {
				var b = this.skin.getAttachment(a, f);
				if (null != b) {
					return b;
				}
			}
			return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(a, f) : null;
		};
		f.prototype.setAttachment = function(a, f) {
			if (null == a) {
				throw Error("slotName cannot be null.");
			}
			for (var b = this.slots, c = 0, e = b.length;c < e;c++) {
				var g = b[c];
				if (g.data.name == a) {
					b = null;
					if (null != f && (b = this.getAttachment(c, f), null == b)) {
						throw Error("Attachment not found: " + f + ", for slot: " + a);
					}
					g.setAttachment(b);
					return;
				}
			}
			throw Error("Slot not found: " + a);
		};
		f.prototype.findIkConstraint = function(a) {
			if (null == a) {
				throw Error("constraintName cannot be null.");
			}
			for (var b = this.ikConstraints, h = 0, c = b.length;h < c;h++) {
				var e = b[h];
				if (e.data.name == a) {
					return e;
				}
			}
			return null;
		};
		f.prototype.findTransformConstraint = function(a) {
			if (null == a) {
				throw Error("constraintName cannot be null.");
			}
			for (var b = this.transformConstraints, h = 0, c = b.length;h < c;h++) {
				var e = b[h];
				if (e.data.name == a) {
					return e;
				}
			}
			return null;
		};
		f.prototype.findPathConstraint = function(a) {
			if (null == a) {
				throw Error("constraintName cannot be null.");
			}
			for (var b = this.pathConstraints, h = 0, c = b.length;h < c;h++) {
				var e = b[h];
				if (e.data.name == a) {
					return e;
				}
			}
			return null;
		};
		f.prototype.getBounds = function(b, f) {
			if (null == b) {
				throw Error("offset cannot be null.");
			}
			if (null == f) {
				throw Error("size cannot be null.");
			}
			for (var h = this.drawOrder, c = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, g = Number.NEGATIVE_INFINITY, k = Number.NEGATIVE_INFINITY, l = 0, w = h.length;l < w;l++) {
				var p = h[l], t = null, v = p.getAttachment();
				v instanceof a.RegionAttachment ? t = v.updateWorldVertices(p, !1) : v instanceof a.MeshAttachment && (t = v.updateWorldVertices(p, !0));
				if (null != t) {
					for (p = 0, v = t.length;p < v;p += 8) {
						var y = t[p], x = t[p + 1], c = Math.min(c, y), e = Math.min(e, x), g = Math.max(g, y), k = Math.max(k, x)
					}
				}
			}
			b.set(c, e);
			f.set(g - c, k - e);
		};
		f.prototype.update = function(a) {
			this.time += a;
		};
		return f;
	}();
	a.Skeleton = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function f() {
			this.maxY = this.maxX = this.minY = this.minX = 0;
			this.boundingBoxes = [];
			this.polygons = [];
			this.polygonPool = new a.Pool(function() {
				return a.Utils.newFloatArray(16);
			});
		}
		f.prototype.update = function(b, f) {
			if (null == b) {
				throw Error("skeleton cannot be null.");
			}
			var h = this.boundingBoxes, c = this.polygons, e = this.polygonPool;
			b = b.slots;
			var g = b.length;
			h.length = 0;
			e.freeAll(c);
			for (var k = c.length = 0;k < g;k++) {
				var l = b[k], w = l.getAttachment();
				if (w instanceof a.BoundingBoxAttachment) {
					h.push(w);
					var p = e.obtain();
					p.length != w.worldVerticesLength && (p = a.Utils.newFloatArray(w.worldVerticesLength));
					c.push(p);
					w.computeWorldVertices(l, p);
				}
			}
			f ? this.aabbCompute() : (this.minY = this.minX = Number.POSITIVE_INFINITY, this.maxY = this.maxX = Number.NEGATIVE_INFINITY);
		};
		f.prototype.aabbCompute = function() {
			for (var a = Number.POSITIVE_INFINITY, f = Number.POSITIVE_INFINITY, h = Number.NEGATIVE_INFINITY, c = Number.NEGATIVE_INFINITY, e = this.polygons, g = 0, l = e.length;g < l;g++) {
				for (var r = e[g], w = r, p = 0, r = r.length;p < r;p += 2) {
					var t = w[p], v = w[p + 1], a = Math.min(a, t), f = Math.min(f, v), h = Math.max(h, t), c = Math.max(c, v)
				}
			}
			this.minX = a;
			this.minY = f;
			this.maxX = h;
			this.maxY = c;
		};
		f.prototype.aabbContainsPoint = function(a, f) {
			return a >= this.minX && a <= this.maxX && f >= this.minY && f <= this.maxY;
		};
		f.prototype.aabbIntersectsSegment = function(a, f, h, c) {
			var b = this.minX, g = this.minY, k = this.maxX, l = this.maxY;
			if (a <= b && h <= b || f <= g && c <= g || a >= k && h >= k || f >= l && c >= l) {
				return !1;
			}
			h = (c - f) / (h - a);
			c = h * (b - a) + f;
			if (c > g && c < l) {
				return !0;
			}
			c = h * (k - a) + f;
			if (c > g && c < l) {
				return !0;
			}
			g = (g - f) / h + a;
			if (g > b && g < k) {
				return !0;
			}
			g = (l - f) / h + a;
			return g > b && g < k ? !0 : !1;
		};
		f.prototype.aabbIntersectsSkeleton = function(a) {
			return this.minX < a.maxX && this.maxX > a.minX && this.minY < a.maxY && this.maxY > a.minY;
		};
		f.prototype.containsPoint = function(a, f) {
			for (var b = this.polygons, c = 0, e = b.length;c < e;c++) {
				if (this.containsPointPolygon(b[c], a, f)) {
					return this.boundingBoxes[c];
				}
			}
			return null;
		};
		f.prototype.containsPointPolygon = function(a, f, h) {
			for (var b = a.length, e = b - 2, g = !1, k = 0;k < b;k += 2) {
				var l = a[k + 1], w = a[e + 1];
				if (l < h && w >= h || w < h && l >= h) {
					var p = a[k];
					p + (h - l) / (w - l) * (a[e] - p) < f && (g = !g);
				}
				e = k;
			}
			return g;
		};
		f.prototype.intersectsSegment = function(a, f, h, c) {
			for (var b = this.polygons, g = 0, k = b.length;g < k;g++) {
				if (this.intersectsSegmentPolygon(b[g], a, f, h, c)) {
					return this.boundingBoxes[g];
				}
			}
			return null;
		};
		f.prototype.intersectsSegmentPolygon = function(a, f, h, c, e) {
			for (var b = a.length, k = f - c, l = h - e, w = f * e - h * c, p = a[b - 2], t = a[b - 1], v = 0;v < b;v += 2) {
				var y = a[v], x = a[v + 1], m = p * x - t * y, u = p - y, B = t - x, A = k * B - l * u, u = (w * u - k * m) / A;
				if ((u >= p && u <= y || u >= y && u <= p) && (u >= f && u <= c || u >= c && u <= f) && (p = (w * B - l * m) / A, (p >= t && p <= x || p >= x && p <= t) && (p >= h && p <= e || p >= e && p <= h))) {
					return !0;
				}
				p = y;
				t = x;
			}
			return !1;
		};
		f.prototype.getPolygon = function(a) {
			if (null == a) {
				throw Error("boundingBox cannot be null.");
			}
			a = this.boundingBoxes.indexOf(a);
			return -1 == a ? null : this.polygons[a];
		};
		f.prototype.getWidth = function() {
			return this.maxX - this.minX;
		};
		f.prototype.getHeight = function() {
			return this.maxY - this.minY;
		};
		return f;
	}();
	a.SkeletonBounds = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function a() {
			this.bones = [];
			this.slots = [];
			this.skins = [];
			this.events = [];
			this.animations = [];
			this.ikConstraints = [];
			this.transformConstraints = [];
			this.pathConstraints = [];
			this.fps = 0;
		}
		a.prototype.findBone = function(a) {
			if (null == a) {
				throw Error("boneName cannot be null.");
			}
			for (var b = this.bones, h = 0, c = b.length;h < c;h++) {
				var e = b[h];
				if (e.name == a) {
					return e;
				}
			}
			return null;
		};
		a.prototype.findBoneIndex = function(a) {
			if (null == a) {
				throw Error("boneName cannot be null.");
			}
			for (var b = this.bones, h = 0, c = b.length;h < c;h++) {
				if (b[h].name == a) {
					return h;
				}
			}
			return -1;
		};
		a.prototype.findSlot = function(a) {
			if (null == a) {
				throw Error("slotName cannot be null.");
			}
			for (var b = this.slots, h = 0, c = b.length;h < c;h++) {
				var e = b[h];
				if (e.name == a) {
					return e;
				}
			}
			return null;
		};
		a.prototype.findSlotIndex = function(a) {
			if (null == a) {
				throw Error("slotName cannot be null.");
			}
			for (var b = this.slots, h = 0, c = b.length;h < c;h++) {
				if (b[h].name == a) {
					return h;
				}
			}
			return -1;
		};
		a.prototype.findSkin = function(a) {
			if (null == a) {
				throw Error("skinName cannot be null.");
			}
			for (var b = this.skins, h = 0, c = b.length;h < c;h++) {
				var e = b[h];
				if (e.name == a) {
					return e;
				}
			}
			return null;
		};
		a.prototype.findEvent = function(a) {
			if (null == a) {
				throw Error("eventDataName cannot be null.");
			}
			for (var b = this.events, h = 0, c = b.length;h < c;h++) {
				var e = b[h];
				if (e.name == a) {
					return e;
				}
			}
			return null;
		};
		a.prototype.findAnimation = function(a) {
			if (null == a) {
				throw Error("animationName cannot be null.");
			}
			for (var b = this.animations, h = 0, c = b.length;h < c;h++) {
				var e = b[h];
				if (e.name == a) {
					return e;
				}
			}
			return null;
		};
		a.prototype.findIkConstraint = function(a) {
			if (null == a) {
				throw Error("constraintName cannot be null.");
			}
			for (var b = this.ikConstraints, h = 0, c = b.length;h < c;h++) {
				var e = b[h];
				if (e.name == a) {
					return e;
				}
			}
			return null;
		};
		a.prototype.findTransformConstraint = function(a) {
			if (null == a) {
				throw Error("constraintName cannot be null.");
			}
			for (var b = this.transformConstraints, h = 0, c = b.length;h < c;h++) {
				var e = b[h];
				if (e.name == a) {
					return e;
				}
			}
			return null;
		};
		a.prototype.findPathConstraint = function(a) {
			if (null == a) {
				throw Error("constraintName cannot be null.");
			}
			for (var b = this.pathConstraints, h = 0, c = b.length;h < c;h++) {
				var e = b[h];
				if (e.name == a) {
					return e;
				}
			}
			return null;
		};
		a.prototype.findPathConstraintIndex = function(a) {
			if (null == a) {
				throw Error("pathConstraintName cannot be null.");
			}
			for (var b = this.pathConstraints, h = 0, c = b.length;h < c;h++) {
				if (b[h].name == a) {
					return h;
				}
			}
			return -1;
		};
		return a;
	}();
	a.SkeletonData = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function b(a) {
			this.scale = 1;
			this.linkedMeshes = [];
			this.attachmentLoader = a;
		}
		b.prototype.readSkeletonData = function(f) {
			var h = this.scale, c = new a.SkeletonData;
			f = "string" === typeof f ? JSON.parse(f) : f;
			var e = f.skeleton;
			null != e && (c.hash = e.hash, c.version = e.spine, c.width = e.width, c.height = e.height, c.fps = e.fps, c.imagesPath = e.images);
			if (f.bones) {
				for (e = 0;e < f.bones.length;e++) {
					var g = f.bones[e], k = null, l = this.getValue(g, "parent", null);
					if (null != l && (k = c.findBone(l), null == k)) {
						throw Error("Parent bone not found: " + l);
					}
					k = new a.BoneData(c.bones.length, g.name, k);
					k.length = this.getValue(g, "length", 0) * h;
					k.x = this.getValue(g, "x", 0) * h;
					k.y = this.getValue(g, "y", 0) * h;
					k.rotation = this.getValue(g, "rotation", 0);
					k.scaleX = this.getValue(g, "scaleX", 1);
					k.scaleY = this.getValue(g, "scaleY", 1);
					k.shearX = this.getValue(g, "shearX", 0);
					k.shearY = this.getValue(g, "shearY", 0);
					k.transformMode = b.transformModeFromString(this.getValue(g, "transform", "normal"));
					c.bones.push(k);
				}
			}
			if (f.slots) {
				for (e = 0;e < f.slots.length;e++) {
					var g = f.slots[e], w = g.name, l = g.bone, k = c.findBone(l);
					if (null == k) {
						throw Error("Slot bone not found: " + l);
					}
					k = new a.SlotData(c.slots.length, w, k);
					l = this.getValue(g, "color", null);
					null != l && k.color.setFromString(l);
					k.attachmentName = this.getValue(g, "attachment", null);
					k.blendMode = b.blendModeFromString(this.getValue(g, "blend", "normal"));
					c.slots.push(k);
				}
			}
			if (f.ik) {
				for (e = 0;e < f.ik.length;e++) {
					g = f.ik[e];
					k = new a.IkConstraintData(g.name);
					k.order = this.getValue(g, "order", 0);
					for (var p = 0;p < g.bones.length;p++) {
						var l = g.bones[p], t = c.findBone(l);
						if (null == t) {
							throw Error("IK bone not found: " + l);
						}
						k.bones.push(t);
					}
					l = g.target;
					k.target = c.findBone(l);
					if (null == k.target) {
						throw Error("IK target bone not found: " + l);
					}
					k.bendDirection = this.getValue(g, "bendPositive", !0) ? 1 : -1;
					k.mix = this.getValue(g, "mix", 1);
					c.ikConstraints.push(k);
				}
			}
			if (f.transform) {
				for (e = 0;e < f.transform.length;e++) {
					g = f.transform[e];
					k = new a.TransformConstraintData(g.name);
					k.order = this.getValue(g, "order", 0);
					for (p = 0;p < g.bones.length;p++) {
						l = g.bones[p];
						t = c.findBone(l);
						if (null == t) {
							throw Error("Transform constraint bone not found: " + l);
						}
						k.bones.push(t);
					}
					l = g.target;
					k.target = c.findBone(l);
					if (null == k.target) {
						throw Error("Transform constraint target bone not found: " + l);
					}
					k.offsetRotation = this.getValue(g, "rotation", 0);
					k.offsetX = this.getValue(g, "x", 0) * h;
					k.offsetY = this.getValue(g, "y", 0) * h;
					k.offsetScaleX = this.getValue(g, "scaleX", 0);
					k.offsetScaleY = this.getValue(g, "scaleY", 0);
					k.offsetShearY = this.getValue(g, "shearY", 0);
					k.rotateMix = this.getValue(g, "rotateMix", 1);
					k.translateMix = this.getValue(g, "translateMix", 1);
					k.scaleMix = this.getValue(g, "scaleMix", 1);
					k.shearMix = this.getValue(g, "shearMix", 1);
					c.transformConstraints.push(k);
				}
			}
			if (f.path) {
				for (e = 0;e < f.path.length;e++) {
					g = f.path[e];
					k = new a.PathConstraintData(g.name);
					k.order = this.getValue(g, "order", 0);
					for (p = 0;p < g.bones.length;p++) {
						l = g.bones[p];
						t = c.findBone(l);
						if (null == t) {
							throw Error("Transform constraint bone not found: " + l);
						}
						k.bones.push(t);
					}
					l = g.target;
					k.target = c.findSlot(l);
					if (null == k.target) {
						throw Error("Path target slot not found: " + l);
					}
					k.positionMode = b.positionModeFromString(this.getValue(g, "positionMode", "percent"));
					k.spacingMode = b.spacingModeFromString(this.getValue(g, "spacingMode", "length"));
					k.rotateMode = b.rotateModeFromString(this.getValue(g, "rotateMode", "tangent"));
					k.offsetRotation = this.getValue(g, "rotation", 0);
					k.position = this.getValue(g, "position", 0);
					k.positionMode == a.PositionMode.Fixed && (k.position *= h);
					k.spacing = this.getValue(g, "spacing", 0);
					if (k.spacingMode == a.SpacingMode.Length || k.spacingMode == a.SpacingMode.Fixed) {
						k.spacing *= h;
					}
					k.rotateMix = this.getValue(g, "rotateMix", 1);
					k.translateMix = this.getValue(g, "translateMix", 1);
					c.pathConstraints.push(k);
				}
			}
			if (f.skins) {
				for (var v in f.skins) {
					e = f.skins[v];
					h = new a.Skin(v);
					for (w in e) {
						k = c.findSlotIndex(w);
						if (-1 == k) {
							throw Error("Slot not found: " + w);
						}
						var g = e[w], y;
						for (y in g) {
							l = this.readAttachment(g[y], h, k, y), null != l && h.addAttachment(k, y, l);
						}
					}
					c.skins.push(h);
					"default" == h.name && (c.defaultSkin = h);
				}
			}
			e = 0;
			for (w = this.linkedMeshes.length;e < w;e++) {
				v = this.linkedMeshes[e];
				h = null == v.skin ? c.defaultSkin : c.findSkin(v.skin);
				if (null == h) {
					throw Error("Skin not found: " + v.skin);
				}
				y = h.getAttachment(v.slotIndex, v.parent);
				if (null == y) {
					throw Error("Parent mesh not found: " + v.parent);
				}
				v.mesh.setParentMesh(y);
				v.mesh.updateUVs();
			}
			this.linkedMeshes.length = 0;
			if (f.events) {
				for (var x in f.events) {
					w = f.events[x], k = new a.EventData(x), k.intValue = this.getValue(w, "int", 0), k.floatValue = this.getValue(w, "float", 0), k.stringValue = this.getValue(w, "string", ""), c.events.push(k);
				}
			}
			if (f.animations) {
				for (var m in f.animations) {
					this.readAnimation(f.animations[m], m, c);
				}
			}
			return c;
		};
		b.prototype.readAttachment = function(b, h, c, e) {
			var g = this.scale;
			e = this.getValue(b, "name", e);
			switch(this.getValue(b, "type", "region")) {
				case "region":
					var f = this.getValue(b, "path", e);
					c = this.attachmentLoader.newRegionAttachment(h, e, f);
					if (null == c) {
						break;
					}
					c.path = f;
					c.x = this.getValue(b, "x", 0) * g;
					c.y = this.getValue(b, "y", 0) * g;
					c.scaleX = this.getValue(b, "scaleX", 1);
					c.scaleY = this.getValue(b, "scaleY", 1);
					c.rotation = this.getValue(b, "rotation", 0);
					c.width = b.width * g;
					c.height = b.height * g;
					g = this.getValue(b, "color", null);
					null != g && c.color.setFromString(g);
					c.updateOffset();
					return c;
				case "boundingbox":
					f = this.attachmentLoader.newBoundingBoxAttachment(h, e);
					if (null == f) {
						break;
					}
					this.readVertices(b, f, b.vertexCount << 1);
					g = this.getValue(b, "color", null);
					null != g && f.color.setFromString(g);
					return f;
				case "mesh":
				;
				case "linkedmesh":
					f = this.getValue(b, "path", e);
					h = this.attachmentLoader.newMeshAttachment(h, e, f);
					if (null == h) {
						break;
					}
					h.path = f;
					g = this.getValue(b, "color", null);
					null != g && h.color.setFromString(g);
					f = this.getValue(b, "parent", null);
					if (null != f) {
						return h.inheritDeform = this.getValue(b, "deform", !0), this.linkedMeshes.push(new l(h, this.getValue(b, "skin", null), c, f)), h;
					}
					f = b.uvs;
					this.readVertices(b, h, f.length);
					h.triangles = b.triangles;
					h.regionUVs = f;
					h.updateUVs();
					h.hullLength = 2 * this.getValue(b, "hull", 0);
					return h;
				case "path":
					if (f = this.attachmentLoader.newPathAttachment(h, e), null != f) {
						f.closed = this.getValue(b, "closed", !1);
						f.constantSpeed = this.getValue(b, "constantSpeed", !0);
						c = b.vertexCount;
						this.readVertices(b, f, c << 1);
						c = a.Utils.newArray(c / 3, 0);
						for (h = 0;h < b.lengths.length;h++) {
							c[h++] = b.lengths[h] * g;
						}
						f.lengths = c;
						g = this.getValue(b, "color", null);
						null != g && f.color.setFromString(g);
						return f;
					}
				;
			}
			return null;
		};
		b.prototype.readVertices = function(b, h, c) {
			var e = this.scale;
			h.worldVerticesLength = c;
			b = b.vertices;
			if (c == b.length) {
				if (1 != e) {
					c = 0;
					for (var g = b.length;c < g;c++) {
						b[c] *= e;
					}
				}
				h.vertices = a.Utils.toFloatArray(b);
			} else {
				var f = [], k = [];
				c = 0;
				for (g = b.length;c < g;) {
					var l = b[c++];
					k.push(l);
					for (l = c + 4 * l;c < l;c += 4) {
						k.push(b[c]), f.push(b[c + 1] * e), f.push(b[c + 2] * e), f.push(b[c + 3]);
					}
				}
				h.bones = k;
				h.vertices = a.Utils.toFloatArray(f);
			}
		};
		b.prototype.readAnimation = function(b, h, c) {
			var e = this.scale, g = [], f = 0;
			if (b.slots) {
				for (var k in b.slots) {
					var l = b.slots[k], p = c.findSlotIndex(k);
					if (-1 == p) {
						throw Error("Slot not found: " + k);
					}
					for (var t in l) {
						var v = l[t];
						if ("color" == t) {
							var y = new a.ColorTimeline(v.length);
							y.slotIndex = p;
							for (var x = 0, m = 0;m < v.length;m++) {
								var u = v[m], B = new a.Color;
								B.setFromString(u.color);
								y.setFrame(x, u.time, B.r, B.g, B.b, B.a);
								this.readCurve(u, y, x);
								x++;
							}
							g.push(y);
							f = Math.max(f, y.frames[(y.getFrameCount() - 1) * a.ColorTimeline.ENTRIES]);
						} else {
							t = "attachment";
							y = new a.AttachmentTimeline(v.length);
							y.slotIndex = p;
							for (m = x = 0;m < v.length;m++) {
								u = v[m], y.setFrame(x++, u.time, u.name);
							}
							g.push(y);
							f = Math.max(f, y.frames[y.getFrameCount() - 1]);
						}
					}
				}
			}
			if (b.bones) {
				for (var A in b.bones) {
					l = b.bones[A];
					B = c.findBoneIndex(A);
					if (-1 == B) {
						throw Error("Bone not found: " + A);
					}
					for (t in l) {
						if (v = l[t], "rotate" === t) {
							y = new a.RotateTimeline(v.length);
							y.boneIndex = B;
							for (m = x = 0;m < v.length;m++) {
								u = v[m], y.setFrame(x, u.time, u.angle), this.readCurve(u, y, x), x++;
							}
							g.push(y);
							f = Math.max(f, y.frames[(y.getFrameCount() - 1) * a.RotateTimeline.ENTRIES]);
						} else {
							if ("translate" === t || "scale" === t || "shear" === t) {
								p = 1;
								"scale" === t ? y = new a.ScaleTimeline(v.length) : "shear" === t ? y = new a.ShearTimeline(v.length) : (y = new a.TranslateTimeline(v.length), p = e);
								y.boneIndex = B;
								for (m = x = 0;m < v.length;m++) {
									var u = v[m], D = this.getValue(u, "x", 0), G = this.getValue(u, "y", 0);
									y.setFrame(x, u.time, D * p, G * p);
									this.readCurve(u, y, x);
									x++;
								}
								g.push(y);
								f = Math.max(f, y.frames[(y.getFrameCount() - 1) * a.TranslateTimeline.ENTRIES]);
							} else {
								throw Error("Invalid timeline type for a bone: " + t + " (" + A + ")");
							}
						}
					}
				}
			}
			if (b.ik) {
				for (var F in b.ik) {
					l = b.ik[F];
					x = c.findIkConstraint(F);
					y = new a.IkConstraintTimeline(l.length);
					y.ikConstraintIndex = c.ikConstraints.indexOf(x);
					for (m = x = 0;m < l.length;m++) {
						u = l[m], y.setFrame(x, u.time, this.getValue(u, "mix", 1), this.getValue(u, "bendPositive", !0) ? 1 : -1), this.readCurve(u, y, x), x++;
					}
					g.push(y);
					f = Math.max(f, y.frames[(y.getFrameCount() - 1) * a.IkConstraintTimeline.ENTRIES]);
				}
			}
			if (b.transform) {
				for (F in b.transform) {
					l = b.transform[F];
					x = c.findTransformConstraint(F);
					y = new a.TransformConstraintTimeline(l.length);
					y.transformConstraintIndex = c.transformConstraints.indexOf(x);
					for (m = x = 0;m < l.length;m++) {
						u = l[m], y.setFrame(x, u.time, this.getValue(u, "rotateMix", 1), this.getValue(u, "translateMix", 1), this.getValue(u, "scaleMix", 1), this.getValue(u, "shearMix", 1)), this.readCurve(u, y, x), x++;
					}
					g.push(y);
					f = Math.max(f, y.frames[(y.getFrameCount() - 1) * a.TransformConstraintTimeline.ENTRIES]);
				}
			}
			if (b.paths) {
				for (F in b.paths) {
					l = b.paths[F];
					A = c.findPathConstraintIndex(F);
					if (-1 == A) {
						throw Error("Path constraint not found: " + F);
					}
					B = c.pathConstraints[A];
					for (t in l) {
						if (v = l[t], "position" === t || "spacing" === t) {
							p = 1;
							if ("spacing" === t) {
								if (y = new a.PathConstraintSpacingTimeline(v.length), B.spacingMode == a.SpacingMode.Length || B.spacingMode == a.SpacingMode.Fixed) {
									p = e;
								}
							} else {
								y = new a.PathConstraintPositionTimeline(v.length), B.positionMode == a.PositionMode.Fixed && (p = e);
							}
							y.pathConstraintIndex = A;
							for (m = x = 0;m < v.length;m++) {
								u = v[m], y.setFrame(x, u.time, this.getValue(u, t, 0) * p), this.readCurve(u, y, x), x++;
							}
							g.push(y);
							f = Math.max(f, y.frames[(y.getFrameCount() - 1) * a.PathConstraintPositionTimeline.ENTRIES]);
						} else {
							if ("mix" === t) {
								y = new a.PathConstraintMixTimeline(v.length);
								y.pathConstraintIndex = A;
								for (m = x = 0;m < v.length;m++) {
									u = v[m], y.setFrame(x, u.time, this.getValue(u, "rotateMix", 1), this.getValue(u, "translateMix", 1)), this.readCurve(u, y, x), x++;
								}
								g.push(y);
								f = Math.max(f, y.frames[(y.getFrameCount() - 1) * a.PathConstraintMixTimeline.ENTRIES]);
							}
						}
					}
				}
			}
			if (b.deform) {
				for (var C in b.deform) {
					A = b.deform[C];
					B = c.findSkin(C);
					if (null == B) {
						throw Error("Skin not found: " + C);
					}
					for (k in A) {
						l = A[k];
						p = c.findSlotIndex(k);
						if (-1 == p) {
							throw Error("Slot not found: " + l.name);
						}
						for (t in l) {
							v = l[t];
							x = B.getAttachment(p, t);
							if (null == x) {
								throw Error("Deform attachment not found: " + v.name);
							}
							var D = null != x.bones, G = x.vertices, J = D ? G.length / 3 * 2 : G.length, y = new a.DeformTimeline(v.length);
							y.slotIndex = p;
							y.attachment = x;
							for (F = x = 0;F < v.length;F++) {
								var u = v[F], I, Q = this.getValue(u, "vertices", null);
								if (null == Q) {
									I = D ? a.Utils.newFloatArray(J) : G;
								} else {
									I = a.Utils.newFloatArray(J);
									m = this.getValue(u, "offset", 0);
									a.Utils.arrayCopy(Q, 0, I, m, Q.length);
									if (1 != e) {
										for (Q = m + Q.length;m < Q;m++) {
											I[m] *= e;
										}
									}
									if (!D) {
										for (m = 0;m < J;m++) {
											I[m] += G[m];
										}
									}
								}
								y.setFrame(x, u.time, I);
								this.readCurve(u, y, x);
								x++;
							}
							g.push(y);
							f = Math.max(f, y.frames[y.getFrameCount() - 1]);
						}
					}
				}
			}
			e = b.drawOrder;
			null == e && (e = b.draworder);
			if (null != e) {
				y = new a.DrawOrderTimeline(e.length);
				k = c.slots.length;
				for (F = x = 0;F < e.length;F++) {
					t = e[F];
					C = null;
					v = this.getValue(t, "offsets", null);
					if (null != v) {
						C = a.Utils.newArray(k, -1);
						u = a.Utils.newArray(k - v.length, 0);
						for (m = A = l = 0;m < v.length;m++) {
							B = v[m];
							p = c.findSlotIndex(B.slot);
							if (-1 == p) {
								throw Error("Slot not found: " + B.slot);
							}
							for (;l != p;) {
								u[A++] = l++;
							}
							C[l + B.offset] = l++;
						}
						for (;l < k;) {
							u[A++] = l++;
						}
						for (m = k - 1;0 <= m;m--) {
							-1 == C[m] && (C[m] = u[--A]);
						}
					}
					y.setFrame(x++, t.time, C);
				}
				g.push(y);
				f = Math.max(f, y.frames[y.getFrameCount() - 1]);
			}
			if (b.events) {
				y = new a.EventTimeline(b.events.length);
				for (m = x = 0;m < b.events.length;m++) {
					e = b.events[m];
					k = c.findEvent(e.name);
					if (null == k) {
						throw Error("Event not found: " + e.name);
					}
					p = new a.Event(e.time, k);
					p.intValue = this.getValue(e, "int", k.intValue);
					p.floatValue = this.getValue(e, "float", k.floatValue);
					p.stringValue = this.getValue(e, "string", k.stringValue);
					y.setFrame(x++, p);
				}
				g.push(y);
				f = Math.max(f, y.frames[y.getFrameCount() - 1]);
			}
			if (isNaN(f)) {
				throw Error("Error while parsing animation, duration is NaN");
			}
			c.animations.push(new a.Animation(h, g, f));
		};
		b.prototype.readCurve = function(a, b, c) {
			a.curve && ("stepped" === a.curve ? b.setStepped(c) : "[object Array]" === Object.prototype.toString.call(a.curve) && (a = a.curve, b.setCurve(c, a[0], a[1], a[2], a[3])));
		};
		b.prototype.getValue = function(a, b, c) {
			return void 0 !== a[b] ? a[b] : c;
		};
		b.blendModeFromString = function(b) {
			b = b.toLowerCase();
			if ("normal" == b) {
				return a.BlendMode.Normal;
			}
			if ("additive" == b) {
				return a.BlendMode.Additive;
			}
			if ("multiply" == b) {
				return a.BlendMode.Multiply;
			}
			if ("screen" == b) {
				return a.BlendMode.Screen;
			}
			throw Error("Unknown blend mode: " + b);
		};
		b.positionModeFromString = function(b) {
			b = b.toLowerCase();
			if ("fixed" == b) {
				return a.PositionMode.Fixed;
			}
			if ("percent" == b) {
				return a.PositionMode.Percent;
			}
			throw Error("Unknown position mode: " + b);
		};
		b.spacingModeFromString = function(b) {
			b = b.toLowerCase();
			if ("length" == b) {
				return a.SpacingMode.Length;
			}
			if ("fixed" == b) {
				return a.SpacingMode.Fixed;
			}
			if ("percent" == b) {
				return a.SpacingMode.Percent;
			}
			throw Error("Unknown position mode: " + b);
		};
		b.rotateModeFromString = function(b) {
			b = b.toLowerCase();
			if ("tangent" == b) {
				return a.RotateMode.Tangent;
			}
			if ("chain" == b) {
				return a.RotateMode.Chain;
			}
			if ("chainscale" == b) {
				return a.RotateMode.ChainScale;
			}
			throw Error("Unknown rotate mode: " + b);
		};
		b.transformModeFromString = function(b) {
			b = b.toLowerCase();
			if ("normal" == b) {
				return a.TransformMode.Normal;
			}
			if ("onlytranslation" == b) {
				return a.TransformMode.OnlyTranslation;
			}
			if ("norotationorreflection" == b) {
				return a.TransformMode.NoRotationOrReflection;
			}
			if ("noscale" == b) {
				return a.TransformMode.NoScale;
			}
			if ("noscaleorreflection" == b) {
				return a.TransformMode.NoScaleOrReflection;
			}
			throw Error("Unknown transform mode: " + b);
		};
		return b;
	}();
	a.SkeletonJson = f;
	var l = function() {
		return function(a, f, h, c) {
			this.mesh = a;
			this.skin = f;
			this.slotIndex = h;
			this.parent = c;
		};
	}();
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function a(a) {
			this.attachments = [];
			if (null == a) {
				throw Error("name cannot be null.");
			}
			this.name = a;
		}
		a.prototype.addAttachment = function(a, f, h) {
			if (null == h) {
				throw Error("attachment cannot be null.");
			}
			var b = this.attachments;
			a >= b.length && (b.length = a + 1);
			b[a] || (b[a] = {});
			b[a][f] = h;
		};
		a.prototype.getAttachment = function(a, f) {
			return (a = this.attachments[a]) ? a[f] : null;
		};
		a.prototype.attachAll = function(a, f) {
			for (var b = 0, c = 0;c < a.slots.length;c++) {
				var e = a.slots[c], g = e.getAttachment();
				if (g && b < f.attachments.length) {
					var k = f.attachments[b], l;
					for (l in k) {
						if (g == k[l]) {
							g = this.getAttachment(b, l);
							null != g && e.setAttachment(g);
							break;
						}
					}
				}
				b++;
			}
		};
		return a;
	}();
	a.Skin = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function f(b, f) {
			this.attachmentVertices = [];
			if (null == b) {
				throw Error("data cannot be null.");
			}
			if (null == f) {
				throw Error("bone cannot be null.");
			}
			this.data = b;
			this.bone = f;
			this.color = new a.Color;
			this.setToSetupPose();
		}
		f.prototype.getAttachment = function() {
			return this.attachment;
		};
		f.prototype.setAttachment = function(a) {
			this.attachment != a && (this.attachment = a, this.attachmentTime = this.bone.skeleton.time, this.attachmentVertices.length = 0);
		};
		f.prototype.setAttachmentTime = function(a) {
			this.attachmentTime = this.bone.skeleton.time - a;
		};
		f.prototype.getAttachmentTime = function() {
			return this.bone.skeleton.time - this.attachmentTime;
		};
		f.prototype.setToSetupPose = function() {
			this.color.setFromColor(this.data.color);
			null == this.data.attachmentName ? this.attachment = null : (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)));
		};
		return f;
	}();
	a.Slot = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		return function(f, b, k) {
			this.color = new a.Color(1, 1, 1, 1);
			if (0 > f) {
				throw Error("index must be >= 0.");
			}
			if (null == b) {
				throw Error("name cannot be null.");
			}
			if (null == k) {
				throw Error("boneData cannot be null.");
			}
			this.index = f;
			this.name = b;
			this.boneData = k;
		};
	}();
	a.SlotData = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function a(a) {
			this._image = a;
		}
		a.prototype.getImage = function() {
			return this._image;
		};
		a.filterFromString = function(a) {
			switch(a.toLowerCase()) {
				case "nearest":
					return l.Nearest;
				case "linear":
					return l.Linear;
				case "mipmap":
					return l.MipMap;
				case "mipmapnearestnearest":
					return l.MipMapNearestNearest;
				case "mipmaplinearnearest":
					return l.MipMapLinearNearest;
				case "mipmapnearestlinear":
					return l.MipMapNearestLinear;
				case "mipmaplinearlinear":
					return l.MipMapLinearLinear;
				default:
					throw Error("Unknown texture filter " + a);;
			}
		};
		a.wrapFromString = function(a) {
			switch(a.toLowerCase()) {
				case "mirroredtepeat":
					return b.MirroredRepeat;
				case "clamptoedge":
					return b.ClampToEdge;
				case "repeat":
					return b.Repeat;
				default:
					throw Error("Unknown texture wrap " + a);;
			}
		};
		return a;
	}();
	a.Texture = f;
	(function(a) {
		a[a.Nearest = 9728] = "Nearest";
		a[a.Linear = 9729] = "Linear";
		a[a.MipMap = 9987] = "MipMap";
		a[a.MipMapNearestNearest = 9984] = "MipMapNearestNearest";
		a[a.MipMapLinearNearest = 9985] = "MipMapLinearNearest";
		a[a.MipMapNearestLinear = 9986] = "MipMapNearestLinear";
		a[a.MipMapLinearLinear = 9987] = "MipMapLinearLinear";
	})(a.TextureFilter || (a.TextureFilter = {}));
	var l = a.TextureFilter;
	(function(a) {
		a[a.MirroredRepeat = 33648] = "MirroredRepeat";
		a[a.ClampToEdge = 33071] = "ClampToEdge";
		a[a.Repeat = 10497] = "Repeat";
	})(a.TextureWrap || (a.TextureWrap = {}));
	var b = a.TextureWrap, f = function() {
		return function() {
			this.height = this.width = this.v2 = this.u2 = this.v = this.u = 0;
			this.rotate = !1;
			this.originalHeight = this.originalWidth = this.offsetY = this.offsetX = 0;
		};
	}();
	a.TextureRegion = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function h(a, b) {
			this.pages = [];
			this.regions = [];
			this.load(a, b);
		}
		h.prototype.load = function(c, e) {
			if (null == e) {
				throw Error("textureLoader cannot be null.");
			}
			c = new l(c);
			for (var g = Array(4), h = null;;) {
				var f = c.readLine();
				if (null == f) {
					break;
				}
				f = f.trim();
				if (0 == f.length) {
					h = null;
				} else {
					if (h) {
						var w = new k;
						w.name = f;
						w.page = h;
						w.rotate = "true" == c.readValue();
						c.readTuple(g);
						var f = parseInt(g[0]), p = parseInt(g[1]);
						c.readTuple(g);
						var t = parseInt(g[0]), v = parseInt(g[1]);
						w.u = f / h.width;
						w.v = p / h.height;
						w.rotate ? (w.u2 = (f + v) / h.width, w.v2 = (p + t) / h.height) : (w.u2 = (f + t) / h.width, w.v2 = (p + v) / h.height);
						w.x = f;
						w.y = p;
						w.width = Math.abs(t);
						w.height = Math.abs(v);
						4 == c.readTuple(g) && 4 == c.readTuple(g) && c.readTuple(g);
						w.originalWidth = parseInt(g[0]);
						w.originalHeight = parseInt(g[1]);
						c.readTuple(g);
						w.offsetX = parseInt(g[0]);
						w.offsetY = parseInt(g[1]);
						w.index = parseInt(c.readValue());
						w.texture = h.texture;
						this.regions.push(w);
					} else {
						h = new b, h.name = f, 2 == c.readTuple(g) && (h.width = parseInt(g[0]), h.height = parseInt(g[1]), c.readTuple(g)), c.readTuple(g), h.minFilter = a.Texture.filterFromString(g[0]), h.magFilter = a.Texture.filterFromString(g[1]), w = c.readValue(), h.uWrap = a.TextureWrap.ClampToEdge, h.vWrap = a.TextureWrap.ClampToEdge, "x" == w ? h.uWrap = a.TextureWrap.Repeat : "y" == w ? h.vWrap = a.TextureWrap.Repeat : "xy" == w && (h.uWrap = h.vWrap = a.TextureWrap.Repeat), h.texture = e(f), h.texture.setFilters(h.minFilter, 
						h.magFilter), h.texture.setWraps(h.uWrap, h.vWrap), h.width = h.texture.getImage().width, h.height = h.texture.getImage().height, this.pages.push(h);
					}
				}
			}
		};
		h.prototype.findRegion = function(a) {
			for (var b = 0;b < this.regions.length;b++) {
				if (this.regions[b].name == a) {
					return this.regions[b];
				}
			}
			return null;
		};
		h.prototype.dispose = function() {
			for (var a = 0;a < this.pages.length;a++) {
				this.pages[a].texture.dispose();
			}
		};
		return h;
	}();
	a.TextureAtlas = f;
	var l = function() {
		function a(a) {
			this.index = 0;
			this.lines = a.split(/\r\n|\r|\n/);
		}
		a.prototype.readLine = function() {
			return this.index >= this.lines.length ? null : this.lines[this.index++];
		};
		a.prototype.readValue = function() {
			var a = this.readLine(), b = a.indexOf(":");
			if (-1 == b) {
				throw Error("Invalid line: " + a);
			}
			return a.substring(b + 1).trim();
		};
		a.prototype.readTuple = function(a) {
			var b = this.readLine(), c = b.indexOf(":");
			if (-1 == c) {
				throw Error("Invalid line: " + b);
			}
			for (var h = 0, c = c + 1;3 > h;h++) {
				var f = b.indexOf(",", c);
				if (-1 == f) {
					break;
				}
				a[h] = b.substr(c, f - c).trim();
				c = f + 1;
			}
			a[h] = b.substring(c).trim();
			return h + 1;
		};
		return a;
	}(), b = function() {
		return function() {
		};
	}();
	a.TextureAtlasPage = b;
	var k = function(a) {
		function b() {
			a.apply(this, arguments);
		}
		__extends(b, a);
		return b;
	}(a.TextureRegion);
	a.TextureAtlasRegion = k;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function f(b, f) {
			this.shearMix = this.scaleMix = this.translateMix = this.rotateMix = 0;
			this.temp = new a.Vector2;
			if (null == b) {
				throw Error("data cannot be null.");
			}
			if (null == f) {
				throw Error("skeleton cannot be null.");
			}
			this.data = b;
			this.rotateMix = b.rotateMix;
			this.translateMix = b.translateMix;
			this.scaleMix = b.scaleMix;
			this.shearMix = b.shearMix;
			this.bones = [];
			for (var h = 0;h < b.bones.length;h++) {
				this.bones.push(f.findBone(b.bones[h].name));
			}
			this.target = f.findBone(b.target.name);
		}
		f.prototype.apply = function() {
			this.update();
		};
		f.prototype.update = function() {
			for (var b = this.rotateMix, f = this.translateMix, h = this.scaleMix, c = this.shearMix, e = this.target, g = e.a, l = e.b, r = e.c, w = e.d, p = 0 < g * w - l * r ? a.MathUtils.degRad : -a.MathUtils.degRad, t = this.data.offsetRotation * p, p = this.data.offsetShearY * p, v = this.bones, y = 0, x = v.length;y < x;y++) {
				var m = v[y], u = !1;
				if (0 != b) {
					var B = m.a, u = m.b, A = m.c, D = m.d, G = Math.atan2(r, g) - Math.atan2(A, B) + t;
					G > a.MathUtils.PI ? G -= a.MathUtils.PI2 : G < -a.MathUtils.PI && (G += a.MathUtils.PI2);
					var G = G * b, F = Math.cos(G), G = Math.sin(G);
					m.a = F * B - G * A;
					m.b = F * u - G * D;
					m.c = G * B + F * A;
					m.d = G * u + F * D;
					u = !0;
				}
				0 != f && (u = this.temp, e.localToWorld(u.set(this.data.offsetX, this.data.offsetY)), m.worldX += (u.x - m.worldX) * f, m.worldY += (u.y - m.worldY) * f, u = !0);
				0 < h && (u = Math.sqrt(m.a * m.a + m.c * m.c), D = Math.sqrt(g * g + r * r), 1E-5 < u && (u = (u + (D - u + this.data.offsetScaleX) * h) / u), m.a *= u, m.c *= u, u = Math.sqrt(m.b * m.b + m.d * m.d), D = Math.sqrt(l * l + w * w), 1E-5 < u && (u = (u + (D - u + this.data.offsetScaleY) * h) / u), m.b *= u, m.d *= u, u = !0);
				0 < c && (u = m.b, D = m.d, B = Math.atan2(D, u), G = Math.atan2(w, l) - Math.atan2(r, g) - (B - Math.atan2(m.c, m.a)), G > a.MathUtils.PI ? G -= a.MathUtils.PI2 : G < -a.MathUtils.PI && (G += a.MathUtils.PI2), G = B + (G + p) * c, u = Math.sqrt(u * u + D * D), m.b = Math.cos(G) * u, m.d = Math.sin(G) * u, u = !0);
				u && (m.appliedValid = !1);
			}
		};
		f.prototype.getOrder = function() {
			return this.data.order;
		};
		return f;
	}();
	a.TransformConstraint = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		return function(a) {
			this.order = 0;
			this.bones = [];
			this.offsetShearY = this.offsetScaleY = this.offsetScaleX = this.offsetY = this.offsetX = this.offsetRotation = this.shearMix = this.scaleMix = this.translateMix = this.rotateMix = 0;
			if (null == a) {
				throw Error("name cannot be null.");
			}
			this.name = a;
		};
	}();
	a.TransformConstraintData = f;
})(spine || (spine = {}));
(function(a) {
	var f = function() {
		function a() {
			this.array = [];
		}
		a.prototype.add = function(a) {
			var b = this.contains(a);
			this.array[a | 0] = a | 0;
			return !b;
		};
		a.prototype.contains = function(a) {
			return void 0 != this.array[a | 0];
		};
		a.prototype.remove = function(a) {
			this.array[a | 0] = void 0;
		};
		a.prototype.clear = function() {
			this.array.length = 0;
		};
		return a;
	}();
	a.IntSet = f;
	f = function() {
		function a(a, f, h, c) {
			void 0 === a && (a = 0);
			void 0 === f && (f = 0);
			void 0 === h && (h = 0);
			void 0 === c && (c = 0);
			this.r = a;
			this.g = f;
			this.b = h;
			this.a = c;
		}
		a.prototype.set = function(a, f, h, c) {
			this.r = a;
			this.g = f;
			this.b = h;
			this.a = c;
			this.clamp();
			return this;
		};
		a.prototype.setFromColor = function(a) {
			this.r = a.r;
			this.g = a.g;
			this.b = a.b;
			this.a = a.a;
			return this;
		};
		a.prototype.setFromString = function(a) {
			a = "#" == a.charAt(0) ? a.substr(1) : a;
			this.r = parseInt(a.substr(0, 2), 16) / 255;
			this.g = parseInt(a.substr(2, 2), 16) / 255;
			this.b = parseInt(a.substr(4, 2), 16) / 255;
			this.a = (8 != a.length ? 255 : parseInt(a.substr(6, 2), 16)) / 255;
			return this;
		};
		a.prototype.add = function(a, f, h, c) {
			this.r += a;
			this.g += f;
			this.b += h;
			this.a += c;
			this.clamp();
			return this;
		};
		a.prototype.clamp = function() {
			0 > this.r ? this.r = 0 : 1 < this.r && (this.r = 1);
			0 > this.g ? this.g = 0 : 1 < this.g && (this.g = 1);
			0 > this.b ? this.b = 0 : 1 < this.b && (this.b = 1);
			0 > this.a ? this.a = 0 : 1 < this.a && (this.a = 1);
			return this;
		};
		a.WHITE = new a(1, 1, 1, 1);
		a.RED = new a(1, 0, 0, 1);
		a.GREEN = new a(0, 1, 0, 1);
		a.BLUE = new a(0, 0, 1, 1);
		a.MAGENTA = new a(1, 0, 1, 1);
		return a;
	}();
	a.Color = f;
	f = function() {
		function a() {
		}
		a.clamp = function(a, f, h) {
			return a < f ? f : a > h ? h : a;
		};
		a.cosDeg = function(b) {
			return Math.cos(b * a.degRad);
		};
		a.sinDeg = function(b) {
			return Math.sin(b * a.degRad);
		};
		a.signum = function(a) {
			return 0 < a ? 1 : 0 > a ? -1 : 0;
		};
		a.toInt = function(a) {
			return 0 < a ? Math.floor(a) : Math.ceil(a);
		};
		a.cbrt = function(a) {
			var b = Math.pow(Math.abs(a), 1 / 3);
			return 0 > a ? -b : b;
		};
		a.PI = 3.1415927;
		a.PI2 = 2 * a.PI;
		a.radiansToDegrees = 180 / a.PI;
		a.radDeg = a.radiansToDegrees;
		a.degreesToRadians = a.PI / 180;
		a.degRad = a.degreesToRadians;
		return a;
	}();
	a.MathUtils = f;
	f = function() {
		function a() {
		}
		a.arrayCopy = function(a, f, h, c, e) {
			for (var b = f;b < f + e;b++, c++) {
				h[c] = a[b];
			}
		};
		a.setArraySize = function(a, f, h) {
			void 0 === h && (h = 0);
			var b = a.length;
			if (b == f) {
				return a;
			}
			a.length = f;
			if (b < f) {
				for (;b < f;b++) {
					a[b] = h;
				}
			}
			return a;
		};
		a.ensureArrayCapacity = function(b, f, h) {
			void 0 === h && (h = 0);
			return b.length >= f ? b : a.setArraySize(b, f, h);
		};
		a.newArray = function(a, f) {
			for (var b = Array(a), c = 0;c < a;c++) {
				b[c] = f;
			}
			return b;
		};
		a.newFloatArray = function(b) {
			if (a.SUPPORTS_TYPED_ARRAYS) {
				return new Float32Array(b);
			}
			b = Array(b);
			for (var f = 0;f < b.length;f++) {
				b[f] = 0;
			}
			return b;
		};
		a.toFloatArray = function(b) {
			return a.SUPPORTS_TYPED_ARRAYS ? new Float32Array(b) : b;
		};
		a.SUPPORTS_TYPED_ARRAYS = "undefined" !== typeof Float32Array;
		return a;
	}();
	a.Utils = f;
	f = function() {
		function a() {
		}
		a.logBones = function(a) {
			for (var b = 0;b < a.bones.length;b++) {
				var f = a.bones[b];
				console.log(f.data.name + ", " + f.a + ", " + f.b + ", " + f.c + ", " + f.d + ", " + f.worldX + ", " + f.worldY);
			}
		};
		return a;
	}();
	a.DebugUtils = f;
	f = function() {
		function a(a) {
			this.items = [];
			this.instantiator = a;
		}
		a.prototype.obtain = function() {
			return 0 < this.items.length ? this.items.pop() : this.instantiator();
		};
		a.prototype.free = function(a) {
			a.reset && a.reset();
			this.items.push(a);
		};
		a.prototype.freeAll = function(a) {
			for (var b = 0;b < a.length;b++) {
				a[b].reset && a[b].reset(), this.items[b] = a[b];
			}
		};
		a.prototype.clear = function() {
			this.items.length = 0;
		};
		return a;
	}();
	a.Pool = f;
	f = function() {
		function a(a, f) {
			void 0 === a && (a = 0);
			void 0 === f && (f = 0);
			this.x = a;
			this.y = f;
		}
		a.prototype.set = function(a, f) {
			this.x = a;
			this.y = f;
			return this;
		};
		a.prototype.length = function() {
			var a = this.x, f = this.y;
			return Math.sqrt(a * a + f * f);
		};
		a.prototype.normalize = function() {
			var a = this.length();
			0 != a && (this.x /= a, this.y /= a);
			return this;
		};
		return a;
	}();
	a.Vector2 = f;
	f = function() {
		function a() {
			this.maxDelta = .064;
			this.totalTime = this.delta = this.framesPerSecond = 0;
			this.lastTime = Date.now() / 1E3;
			this.frameTime = this.frameCount = 0;
		}
		a.prototype.update = function() {
			var a = Date.now() / 1E3;
			this.delta = a - this.lastTime;
			this.frameTime += this.delta;
			this.totalTime += this.delta;
			this.delta > this.maxDelta && (this.delta = this.maxDelta);
			this.lastTime = a;
			this.frameCount++;
			1 < this.frameTime && (this.framesPerSecond = this.frameCount / this.frameTime, this.frameCount = this.frameTime = 0);
		};
		return a;
	}();
	a.TimeKeeper = f;
})(spine || (spine = {}));
(function(a) {
	(function(f) {
		var l = function(a) {
			function b(b) {
				void 0 === b && (b = "");
				a.call(this, function(a) {
					return new f.ThreeJsTexture(a);
				}, b);
			}
			__extends(b, a);
			return b;
		}(a.AssetManager);
		f.AssetManager = l;
	})(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
	(function(a) {
		var f = function() {
			function a(b, f) {
				void 0 === f && (f = 10920);
				this.indicesLength = this.verticesLength = 0;
				if (10920 < f) {
					throw Error("Can't have more than 10920 triangles per batch: " + f);
				}
				var c = this.vertices = new Float32Array(f * a.VERTEX_SIZE);
				f = this.indices = new Uint16Array(3 * f);
				this.mesh = b;
				var e = new THREE.BufferGeometry, c = this.vertexBuffer = new THREE.InterleavedBuffer(c, a.VERTEX_SIZE);
				c.dynamic = !0;
				e.addAttribute("position", new THREE.InterleavedBufferAttribute(c, 3, 0, !1));
				e.addAttribute("color", new THREE.InterleavedBufferAttribute(c, 4, 3, !1));
				e.addAttribute("uv", new THREE.InterleavedBufferAttribute(c, 2, 7, !1));
				e.setIndex(new THREE.BufferAttribute(f, 1));
				e.getIndex().dynamic = !0;
				e.drawRange.start = 0;
				e.drawRange.count = 0;
				b.geometry = e;
			}
			a.prototype.begin = function() {
				this.indicesLength = this.verticesLength = 0;
			};
			a.prototype.batch = function(b, f, c) {
				void 0 === c && (c = 0);
				for (var e = this.verticesLength / a.VERTEX_SIZE, g = this.vertices, h = this.verticesLength, k = 0;k < b.length;) {
					g[h++] = b[k++], g[h++] = b[k++], g[h++] = c, g[h++] = b[k++], g[h++] = b[k++], g[h++] = b[k++], g[h++] = b[k++], g[h++] = b[k++], g[h++] = b[k++];
				}
				this.verticesLength = h;
				b = this.indices;
				h = this.indicesLength;
				for (k = 0;k < f.length;h++, k++) {
					b[h] = f[k] + e;
				}
				this.indicesLength += f.length;
			};
			a.prototype.end = function() {
				this.vertexBuffer.needsUpdate = !0;
				this.vertexBuffer.updateRange.offset = 0;
				this.vertexBuffer.updateRange.count = this.verticesLength;
				var a = this.mesh.geometry;
				a.getIndex().needsUpdate = !0;
				a.getIndex().updateRange.offset = 0;
				a.getIndex().updateRange.count = this.indicesLength;
				a.drawRange.start = 0;
				a.drawRange.count = this.indicesLength;
			};
			a.VERTEX_SIZE = 9;
			return a;
		}();
		a.MeshBatcher = f;
	})(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
	(function(f) {
		var l = function(b) {
			function k(h) {
				b.call(this);
				this.zOffset = .1;
				this.skeleton = new a.Skeleton(h);
				h = new a.AnimationStateData(h);
				this.state = new a.AnimationState(h);
				h = this.material = new THREE.MeshBasicMaterial;
				h.side = THREE.DoubleSide;
				h.transparent = !0;
				h.alphaTest = .5;
				this.batcher = new f.MeshBatcher(this);
			}
			__extends(k, b);
			k.prototype.update = function(a) {
				var b = this.state, e = this.skeleton;
				b.update(a);
				b.apply(e);
				e.updateWorldTransform();
				this.updateGeometry();
			};
			k.prototype.updateGeometry = function() {
				var b, c, e = this.skeleton.drawOrder, g = this.batcher;
				g.begin();
				for (var f = 0, l = this.zOffset, w = 0, p = e.length;w < p;w++) {
					b = e[w];
					c = b.getAttachment();
					var t;
					if (c instanceof a.RegionAttachment) {
						t = c, b = t.updateWorldVertices(b, !1), c = k.QUAD_TRIANGLES, t = t.region.renderObject.texture;
					} else {
						if (c instanceof a.MeshAttachment) {
							t = c, b = t.updateWorldVertices(b, !1), c = t.triangles, t = t.region.renderObject.texture;
						} else {
							continue;
						}
					}
					if (null != t) {
						if (!this.material.map) {
							var v = this.material;
							v.map = t.texture;
							v.needsUpdate = !0;
						}
						this.batcher.batch(b, c, f);
						f += l;
					}
				}
				g.end();
			};
			k.createMesh = function(a) {
				var b = new THREE.BufferGeometry, e = new Float32Array(1024);
				e.set([-200, -200, 1, 0, 0, 1, 0, 0, 200, -200, 0, 1, 0, 1, 1, 0, 200, 200, 0, 0, 1, 1, 1, 1, -200, 200, 1, 1, 0, .1, 0, 1], 0);
				var e = new THREE.InterleavedBuffer(e, 8), g = new THREE.InterleavedBufferAttribute(e, 2, 0, !1);
				b.addAttribute("position", g);
				g = new THREE.InterleavedBufferAttribute(e, 4, 2, !1);
				b.addAttribute("color", g);
				new THREE.InterleavedBufferAttribute(e, 2, 6, !1);
				b.addAttribute("uv", g);
				e = new Uint16Array(1024);
				e.set([0, 1, 2, 2, 3, 0], 0);
				b.setIndex(new THREE.BufferAttribute(e, 1));
				b.drawRange.start = 0;
				b.drawRange.count = 6;
				e = new THREE.MeshBasicMaterial;
				e.vertexColors = THREE.VertexColors;
				e.transparent = !0;
				e.map = a;
				return new THREE.Mesh(b, e);
			};
			k.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
			return k;
		}(THREE.Mesh);
		f.SkeletonMesh = l;
	})(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
	(function(f) {
		var l = function(b) {
			function f(a) {
				b.call(this, a);
				this.texture = new THREE.Texture(a);
				this.texture.flipY = !1;
				this.texture.needsUpdate = !0;
			}
			__extends(f, b);
			f.prototype.setFilters = function(a, b) {
				this.texture.minFilter = f.toThreeJsTextureFilter(a);
				this.texture.magFilter = f.toThreeJsTextureFilter(b);
			};
			f.prototype.setWraps = function(a, b) {
				this.texture.wrapS = f.toThreeJsTextureWrap(a);
				this.texture.wrapT = f.toThreeJsTextureWrap(b);
			};
			f.prototype.dispose = function() {
				this.texture.dispose();
			};
			f.toThreeJsTextureFilter = function(b) {
				if (b === a.TextureFilter.Linear) {
					return THREE.LinearFilter;
				}
				if (b === a.TextureFilter.MipMap) {
					return THREE.LinearMipMapLinearFilter;
				}
				if (b === a.TextureFilter.MipMapLinearNearest) {
					return THREE.LinearMipMapNearestFilter;
				}
				if (b === a.TextureFilter.MipMapNearestLinear) {
					return THREE.NearestMipMapLinearFilter;
				}
				if (b === a.TextureFilter.MipMapNearestNearest) {
					return THREE.NearestMipMapNearestFilter;
				}
				if (b === a.TextureFilter.Nearest) {
					return THREE.NearestFilter;
				}
				throw Error("Unknown texture filter: " + b);
			};
			f.toThreeJsTextureWrap = function(b) {
				if (b === a.TextureWrap.ClampToEdge) {
					return THREE.ClampToEdgeWrapping;
				}
				if (b === a.TextureWrap.MirroredRepeat) {
					return THREE.MirroredRepeatWrapping;
				}
				if (b === a.TextureWrap.Repeat) {
					return THREE.RepeatWrapping;
				}
				throw Error("Unknown texture wrap: " + b);
			};
			return f;
		}(a.Texture);
		f.ThreeJsTexture = l;
	})(a.threejs || (a.threejs = {}));
})(spine || (spine = {}));
(function(a) {
	"object" === typeof exports && "undefined" !== typeof module ? module.exports = a() : "function" === typeof define && define.amd ? define([], a) : ("undefined" !== typeof window ? window : "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : this).opentype = a();
})(function() {
	return function f(l, b, k) {
		function h(e, q) {
			if (!b[e]) {
				if (!l[e]) {
					var g = "function" == typeof require && require;
					if (!q && g) {
						return g(e, !0);
					}
					if (c) {
						return c(e, !0);
					}
					q = Error("Cannot find module '" + e + "'");
					throw q.code = "MODULE_NOT_FOUND", q;
				}
				q = b[e] = {exports:{}};
				l[e][0].call(q.exports, function(b) {
					var c = l[e][1][b];
					return h(c ? c : b);
				}, q, q.exports, f, l, b, k);
			}
			return b[e].exports;
		}
		for (var c = "function" == typeof require && require, e = 0;e < k.length;e++) {
			h(k[e]);
		}
		return h;
	}({1:[function(f, l, b) {
		function k() {
			this.table = new Uint16Array(16);
			this.trans = new Uint16Array(288);
		}
		function h(b, c) {
			this.source = b;
			this.bitcount = this.tag = this.sourceIndex = 0;
			this.dest = c;
			this.destLen = 0;
			this.ltree = new k;
			this.dtree = new k;
		}
		function c(b, c, e, g) {
			var f;
			for (f = 0;e > f;++f) {
				b[f] = 0;
			}
			for (f = 0;30 - e > f;++f) {
				b[f + e] = f / e | 0;
			}
			e = g;
			for (f = 0;30 > f;++f) {
				c[f] = e, e += 1 << b[f];
			}
		}
		function e(b, c, e, g) {
			var f, h;
			for (f = 0;16 > f;++f) {
				b.table[f] = 0;
			}
			for (f = 0;g > f;++f) {
				b.table[c[e + f]]++;
			}
			for (f = h = b.table[0] = 0;16 > f;++f) {
				D[f] = h, h += b.table[f];
			}
			for (f = 0;g > f;++f) {
				c[e + f] && (b.trans[D[c[e + f]]++] = f);
			}
		}
		function g(b, c, e) {
			if (!c) {
				return e;
			}
			for (;24 > b.bitcount;) {
				b.tag |= b.source[b.sourceIndex++] << b.bitcount, b.bitcount += 8;
			}
			var g = b.tag & 65535 >>> 16 - c;
			return b.tag >>>= c, b.bitcount -= c, g + e;
		}
		function q(b, c) {
			for (;24 > b.bitcount;) {
				b.tag |= b.source[b.sourceIndex++] << b.bitcount, b.bitcount += 8;
			}
			var e = 0, g = 0, f = 0, h = b.tag;
			do {
				g = 2 * g + (1 & h), h >>>= 1, ++f, e += c.table[f], g -= c.table[f];
			} while (0 <= g);
			return b.tag = h, b.bitcount -= f, c.trans[e + g];
		}
		function r(b, c, e) {
			for (;;) {
				var f = q(b, c);
				if (256 === f) {
					return w;
				}
				if (256 > f) {
					b.dest[b.destLen++] = f;
				} else {
					var h, k, f = f - 257, f = g(b, v[f], y[f]);
					h = q(b, e);
					for (k = h = b.destLen - g(b, x[h], m[h]);h + f > k;++k) {
						b.dest[b.destLen++] = b.dest[k];
					}
				}
			}
		}
		var w = 0, p = new k, t = new k, v = new Uint8Array(30), y = new Uint16Array(30), x = new Uint8Array(30), m = new Uint16Array(30), u = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), B = new k, A = new Uint8Array(320), D = new Uint16Array(16);
		(function(b, c) {
			var e;
			for (e = 0;7 > e;++e) {
				b.table[e] = 0;
			}
			b.table[7] = 24;
			b.table[8] = 152;
			b.table[9] = 112;
			for (e = 0;24 > e;++e) {
				b.trans[e] = 256 + e;
			}
			for (e = 0;144 > e;++e) {
				b.trans[24 + e] = e;
			}
			for (e = 0;8 > e;++e) {
				b.trans[168 + e] = 280 + e;
			}
			for (e = 0;112 > e;++e) {
				b.trans[176 + e] = 144 + e;
			}
			for (e = 0;5 > e;++e) {
				c.table[e] = 0;
			}
			c.table[5] = 32;
			for (e = 0;32 > e;++e) {
				c.trans[e] = e;
			}
		})(p, t);
		c(v, y, 4, 3);
		c(x, m, 2, 1);
		v[28] = 0;
		y[28] = 258;
		l.exports = function(b, c) {
			var f;
			b = new h(b, c);
			do {
				c = b;
				c.bitcount-- || (c.tag = c.source[c.sourceIndex++], c.bitcount = 7);
				f = 1 & c.tag;
				switch(c = (c.tag >>>= 1, f), g(b, 2, 0)) {
					case 0:
						f = b;
						for (var k = void 0, m = void 0;8 < f.bitcount;) {
							f.sourceIndex--, f.bitcount -= 8;
						}
						if (k = f.source[f.sourceIndex + 1], k = 256 * k + f.source[f.sourceIndex], m = f.source[f.sourceIndex + 3], m = 256 * m + f.source[f.sourceIndex + 2], k !== (65535 & ~m)) {
							f = -3;
						} else {
							for (f.sourceIndex += 4;k;--k) {
								f.dest[f.destLen++] = f.source[f.sourceIndex++];
							}
							f = (f.bitcount = 0, w);
						}
						break;
					case 1:
						f = r(b, p, t);
						break;
					case 2:
						f = b;
						var k = b.ltree, m = b.dtree, l, v, y, x;
						l = g(f, 5, 257);
						v = g(f, 5, 1);
						y = g(f, 4, 4);
						for (x = 0;19 > x;++x) {
							A[x] = 0;
						}
						for (x = 0;y > x;++x) {
							var F = g(f, 3, 0);
							A[u[x]] = F;
						}
						e(B, A, 0, 19);
						for (y = 0;l + v > y;) {
							switch(x = q(f, B), x) {
								case 16:
									F = A[y - 1];
									for (x = g(f, 2, 3);x;--x) {
										A[y++] = F;
									}
									break;
								case 17:
									for (x = g(f, 3, 3);x;--x) {
										A[y++] = 0;
									}
									break;
								case 18:
									for (x = g(f, 7, 11);x;--x) {
										A[y++] = 0;
									}
									break;
								default:
									A[y++] = x;
							}
						}
						e(k, A, 0, l);
						e(m, A, l, v);
						f = r(b, b.ltree, b.dtree);
						break;
					default:
						f = -3;
				}
				if (f !== w) {
					throw Error("Data error");
				}
			} while (!c);
			return b.destLen < b.dest.length ? "function" == typeof b.dest.slice ? b.dest.slice(0, b.destLen) : b.dest.subarray(0, b.destLen) : b.dest;
		};
	}, {}], 2:[function(f, l, b) {
		b.fail = function(b) {
			throw Error(b);
		};
		b.argument = function(f, h) {
			f || b.fail(h);
		};
		b.assert = b.argument;
	}, {}], 3:[function(f, l, b) {
		b.line = function(b, f, c, e, g) {
			b.beginPath();
			b.moveTo(f, c);
			b.lineTo(e, g);
			b.stroke();
		};
	}, {}], 4:[function(f, l, b) {
		function k(b) {
			this.font = b;
		}
		function h(b) {
			this.cmap = b;
		}
		function c(b, c) {
			this.encoding = b;
			this.charset = c;
		}
		function e(c) {
			var e;
			switch(c.version) {
				case 1:
					this.names = b.standardNames.slice();
					break;
				case 2:
					this.names = Array(c.numberOfGlyphs);
					for (e = 0;e < c.numberOfGlyphs;e++) {
						this.names[e] = c.glyphNameIndex[e] < b.standardNames.length ? b.standardNames[c.glyphNameIndex[e]] : c.names[c.glyphNameIndex[e] - b.standardNames.length];
					}
					break;
				case 2.5:
					this.names = Array(c.numberOfGlyphs);
					for (e = 0;e < c.numberOfGlyphs;e++) {
						this.names[e] = b.standardNames[e + c.glyphNameIndex[e]];
					}
					break;
				case 3:
					this.names = [];
			}
		}
		k.prototype.charToGlyphIndex = function(b) {
			b = b.charCodeAt(0);
			var c = this.font.glyphs;
			if (!c) {
				return null;
			}
			for (var e = 0;e < c.length;e += 1) {
				for (var f = c.get(e), g = 0;g < f.unicodes.length;g += 1) {
					if (f.unicodes[g] === b) {
						return e;
					}
				}
			}
		};
		h.prototype.charToGlyphIndex = function(b) {
			return this.cmap.glyphIndexMap[b.charCodeAt(0)] || 0;
		};
		c.prototype.charToGlyphIndex = function(b) {
			b = b.charCodeAt(0);
			return this.charset.indexOf(this.encoding[b]);
		};
		e.prototype.nameToGlyphIndex = function(b) {
			return this.names.indexOf(b);
		};
		e.prototype.glyphIndexToName = function(b) {
			return this.names[b];
		};
		b.cffStandardStrings = ".notdef;space;exclam;quotedbl;numbersign;dollar;percent;ampersand;quoteright;parenleft;parenright;asterisk;plus;comma;hyphen;period;slash;zero;one;two;three;four;five;six;seven;eight;nine;colon;semicolon;less;equal;greater;question;at;A;B;C;D;E;F;G;H;I;J;K;L;M;N;O;P;Q;R;S;T;U;V;W;X;Y;Z;bracketleft;backslash;bracketright;asciicircum;underscore;quoteleft;a;b;c;d;e;f;g;h;i;j;k;l;m;n;o;p;q;r;s;t;u;v;w;x;y;z;braceleft;bar;braceright;asciitilde;exclamdown;cent;sterling;fraction;yen;florin;section;currency;quotesingle;quotedblleft;guillemotleft;guilsinglleft;guilsinglright;fi;fl;endash;dagger;daggerdbl;periodcentered;paragraph;bullet;quotesinglbase;quotedblbase;quotedblright;guillemotright;ellipsis;perthousand;questiondown;grave;acute;circumflex;tilde;macron;breve;dotaccent;dieresis;ring;cedilla;hungarumlaut;ogonek;caron;emdash;AE;ordfeminine;Lslash;Oslash;OE;ordmasculine;ae;dotlessi;lslash;oslash;oe;germandbls;onesuperior;logicalnot;mu;trademark;Eth;onehalf;plusminus;Thorn;onequarter;divide;brokenbar;degree;thorn;threequarters;twosuperior;registered;minus;eth;multiply;threesuperior;copyright;Aacute;Acircumflex;Adieresis;Agrave;Aring;Atilde;Ccedilla;Eacute;Ecircumflex;Edieresis;Egrave;Iacute;Icircumflex;Idieresis;Igrave;Ntilde;Oacute;Ocircumflex;Odieresis;Ograve;Otilde;Scaron;Uacute;Ucircumflex;Udieresis;Ugrave;Yacute;Ydieresis;Zcaron;aacute;acircumflex;adieresis;agrave;aring;atilde;ccedilla;eacute;ecircumflex;edieresis;egrave;iacute;icircumflex;idieresis;igrave;ntilde;oacute;ocircumflex;odieresis;ograve;otilde;scaron;uacute;ucircumflex;udieresis;ugrave;yacute;ydieresis;zcaron;exclamsmall;Hungarumlautsmall;dollaroldstyle;dollarsuperior;ampersandsmall;Acutesmall;parenleftsuperior;parenrightsuperior;266 ff;onedotenleader;zerooldstyle;oneoldstyle;twooldstyle;threeoldstyle;fouroldstyle;fiveoldstyle;sixoldstyle;sevenoldstyle;eightoldstyle;nineoldstyle;commasuperior;threequartersemdash;periodsuperior;questionsmall;asuperior;bsuperior;centsuperior;dsuperior;esuperior;isuperior;lsuperior;msuperior;nsuperior;osuperior;rsuperior;ssuperior;tsuperior;ff;ffi;ffl;parenleftinferior;parenrightinferior;Circumflexsmall;hyphensuperior;Gravesmall;Asmall;Bsmall;Csmall;Dsmall;Esmall;Fsmall;Gsmall;Hsmall;Ismall;Jsmall;Ksmall;Lsmall;Msmall;Nsmall;Osmall;Psmall;Qsmall;Rsmall;Ssmall;Tsmall;Usmall;Vsmall;Wsmall;Xsmall;Ysmall;Zsmall;colonmonetary;onefitted;rupiah;Tildesmall;exclamdownsmall;centoldstyle;Lslashsmall;Scaronsmall;Zcaronsmall;Dieresissmall;Brevesmall;Caronsmall;Dotaccentsmall;Macronsmall;figuredash;hypheninferior;Ogoneksmall;Ringsmall;Cedillasmall;questiondownsmall;oneeighth;threeeighths;fiveeighths;seveneighths;onethird;twothirds;zerosuperior;foursuperior;fivesuperior;sixsuperior;sevensuperior;eightsuperior;ninesuperior;zeroinferior;oneinferior;twoinferior;threeinferior;fourinferior;fiveinferior;sixinferior;seveninferior;eightinferior;nineinferior;centinferior;dollarinferior;periodinferior;commainferior;Agravesmall;Aacutesmall;Acircumflexsmall;Atildesmall;Adieresissmall;Aringsmall;AEsmall;Ccedillasmall;Egravesmall;Eacutesmall;Ecircumflexsmall;Edieresissmall;Igravesmall;Iacutesmall;Icircumflexsmall;Idieresissmall;Ethsmall;Ntildesmall;Ogravesmall;Oacutesmall;Ocircumflexsmall;Otildesmall;Odieresissmall;OEsmall;Oslashsmall;Ugravesmall;Uacutesmall;Ucircumflexsmall;Udieresissmall;Yacutesmall;Thornsmall;Ydieresissmall;001.000;001.001;001.002;001.003;Black;Bold;Book;Light;Medium;Regular;Roman;Semibold".split(";");
		b.cffStandardEncoding = "                                space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk plus comma hyphen period slash zero one two three four five six seven eight nine colon semicolon less equal greater question at A B C D E F G H I J K L M N O P Q R S T U V W X Y Z bracketleft backslash bracketright asciicircum underscore quoteleft a b c d e f g h i j k l m n o p q r s t u v w x y z braceleft bar braceright asciitilde                                   exclamdown cent sterling fraction yen florin section currency quotesingle quotedblleft guillemotleft guilsinglleft guilsinglright fi fl  endash dagger daggerdbl periodcentered  paragraph bullet quotesinglbase quotedblbase quotedblright guillemotright ellipsis perthousand  questiondown  grave acute circumflex tilde macron breve dotaccent dieresis  ring cedilla  hungarumlaut ogonek caron emdash                 AE  ordfeminine     Lslash Oslash OE ordmasculine      ae    dotlessi   lslash oslash oe germandbls".split(" ");
		b.cffExpertEncoding = "                                space exclamsmall Hungarumlautsmall  dollaroldstyle dollarsuperior ampersandsmall Acutesmall parenleftsuperior parenrightsuperior twodotenleader onedotenleader comma hyphen period fraction zerooldstyle oneoldstyle twooldstyle threeoldstyle fouroldstyle fiveoldstyle sixoldstyle sevenoldstyle eightoldstyle nineoldstyle colon semicolon commasuperior threequartersemdash periodsuperior questionsmall  asuperior bsuperior centsuperior dsuperior esuperior   isuperior   lsuperior msuperior nsuperior osuperior   rsuperior ssuperior tsuperior  ff fi fl ffi ffl parenleftinferior  parenrightinferior Circumflexsmall hyphensuperior Gravesmall Asmall Bsmall Csmall Dsmall Esmall Fsmall Gsmall Hsmall Ismall Jsmall Ksmall Lsmall Msmall Nsmall Osmall Psmall Qsmall Rsmall Ssmall Tsmall Usmall Vsmall Wsmall Xsmall Ysmall Zsmall colonmonetary onefitted rupiah Tildesmall                                   exclamdownsmall centoldstyle Lslashsmall   Scaronsmall Zcaronsmall Dieresissmall Brevesmall Caronsmall  Dotaccentsmall   Macronsmall   figuredash hypheninferior   Ogoneksmall Ringsmall Cedillasmall    onequarter onehalf threequarters questiondownsmall oneeighth threeeighths fiveeighths seveneighths onethird twothirds   zerosuperior onesuperior twosuperior threesuperior foursuperior fivesuperior sixsuperior sevensuperior eightsuperior ninesuperior zeroinferior oneinferior twoinferior threeinferior fourinferior fiveinferior sixinferior seveninferior eightinferior nineinferior centinferior dollarinferior periodinferior commainferior Agravesmall Aacutesmall Acircumflexsmall Atildesmall Adieresissmall Aringsmall AEsmall Ccedillasmall Egravesmall Eacutesmall Ecircumflexsmall Edieresissmall Igravesmall Iacutesmall Icircumflexsmall Idieresissmall Ethsmall Ntildesmall Ogravesmall Oacutesmall Ocircumflexsmall Otildesmall Odieresissmall OEsmall Oslashsmall Ugravesmall Uacutesmall Ucircumflexsmall Udieresissmall Yacutesmall Thornsmall Ydieresissmall".split(" ");
		b.standardNames = ".notdef .null nonmarkingreturn space exclam quotedbl numbersign dollar percent ampersand quotesingle parenleft parenright asterisk plus comma hyphen period slash zero one two three four five six seven eight nine colon semicolon less equal greater question at A B C D E F G H I J K L M N O P Q R S T U V W X Y Z bracketleft backslash bracketright asciicircum underscore grave a b c d e f g h i j k l m n o p q r s t u v w x y z braceleft bar braceright asciitilde Adieresis Aring Ccedilla Eacute Ntilde Odieresis Udieresis aacute agrave acircumflex adieresis atilde aring ccedilla eacute egrave ecircumflex edieresis iacute igrave icircumflex idieresis ntilde oacute ograve ocircumflex odieresis otilde uacute ugrave ucircumflex udieresis dagger degree cent sterling section bullet paragraph germandbls registered copyright trademark acute dieresis notequal AE Oslash infinity plusminus lessequal greaterequal yen mu partialdiff summation product pi integral ordfeminine ordmasculine Omega ae oslash questiondown exclamdown logicalnot radical florin approxequal Delta guillemotleft guillemotright ellipsis nonbreakingspace Agrave Atilde Otilde OE oe endash emdash quotedblleft quotedblright quoteleft quoteright divide lozenge ydieresis Ydieresis fraction currency guilsinglleft guilsinglright fi fl daggerdbl periodcentered quotesinglbase quotedblbase perthousand Acircumflex Ecircumflex Aacute Edieresis Egrave Iacute Icircumflex Idieresis Igrave Oacute Ocircumflex apple Ograve Uacute Ucircumflex Ugrave dotlessi circumflex tilde macron breve dotaccent ring cedilla hungarumlaut ogonek caron Lslash lslash Scaron scaron Zcaron zcaron brokenbar Eth eth Yacute yacute Thorn thorn minus multiply onesuperior twosuperior threesuperior onehalf onequarter threequarters franc Gbreve gbreve Idotaccent Scedilla scedilla Cacute cacute Ccaron ccaron dcroat".split(" ");
		b.DefaultEncoding = k;
		b.CmapEncoding = h;
		b.CffEncoding = c;
		b.GlyphNames = e;
		b.addGlyphNames = function(b) {
			for (var c, e = b.tables.cmap.glyphIndexMap, f = Object.keys(e), g = 0;g < f.length;g += 1) {
				var h = f[g];
				c = b.glyphs.get(e[h]);
				c.addUnicode(parseInt(h));
			}
			for (g = 0;g < b.glyphs.length;g += 1) {
				c = b.glyphs.get(g), b.cffEncoding ? c.name = b.cffEncoding.charset[g] : b.glyphNames.names && (c.name = b.glyphNames.glyphIndexToName(g));
			}
		};
	}, {}], 5:[function(f, l, b) {
		function k(b) {
			b = b || {};
			b.empty || (r.checkArgument(b.familyName, "When creating a new Font object, familyName is required."), r.checkArgument(b.styleName, "When creating a new Font object, styleName is required."), r.checkArgument(b.unitsPerEm, "When creating a new Font object, unitsPerEm is required."), r.checkArgument(b.ascender, "When creating a new Font object, ascender is required."), r.checkArgument(b.descender, "When creating a new Font object, descender is required."), r.checkArgument(0 > b.descender, "Descender should be negative (e.g. -512)."), 
			this.names = {fontFamily:{en:b.familyName || " "}, fontSubfamily:{en:b.styleName || " "}, fullName:{en:b.fullName || b.familyName + " " + b.styleName}, postScriptName:{en:b.postScriptName || b.familyName + b.styleName}, designer:{en:b.designer || " "}, designerURL:{en:b.designerURL || " "}, manufacturer:{en:b.manufacturer || " "}, manufacturerURL:{en:b.manufacturerURL || " "}, license:{en:b.license || " "}, licenseURL:{en:b.licenseURL || " "}, version:{en:b.version || "Version 0.1"}, description:{en:b.description || 
			" "}, copyright:{en:b.copyright || " "}, trademark:{en:b.trademark || " "}}, this.unitsPerEm = b.unitsPerEm || 1E3, this.ascender = b.ascender, this.descender = b.descender, this.createdTimestamp = b.createdTimestamp, this.tables = {os2:{usWeightClass:b.weightClass || this.usWeightClasses.MEDIUM, usWidthClass:b.widthClass || this.usWidthClasses.MEDIUM, fsSelection:b.fsSelection || this.fsSelectionValues.REGULAR}});
			this.supported = !0;
			this.glyphs = new g.GlyphSet(this, b.glyphs || []);
			this.encoding = new e.DefaultEncoding(this);
			this.substitution = new q(this);
			this.tables = this.tables || {};
		}
		var h = f("./path"), c = f("./tables/sfnt"), e = f("./encoding"), g = f("./glyphset"), q = f("./substitution"), r = f("./util");
		k.prototype.hasChar = function(b) {
			return null !== this.encoding.charToGlyphIndex(b);
		};
		k.prototype.charToGlyphIndex = function(b) {
			return this.encoding.charToGlyphIndex(b);
		};
		k.prototype.charToGlyph = function(b) {
			b = this.charToGlyphIndex(b);
			b = this.glyphs.get(b);
			return b || (b = this.glyphs.get(0)), b;
		};
		k.prototype.stringToGlyphs = function(b) {
			for (var c = [], e = 0;e < b.length;e += 1) {
				c.push(this.charToGlyph(b[e]));
			}
			return c;
		};
		k.prototype.nameToGlyphIndex = function(b) {
			return this.glyphNames.nameToGlyphIndex(b);
		};
		k.prototype.nameToGlyph = function(b) {
			b = this.nametoGlyphIndex(b);
			b = this.glyphs.get(b);
			return b || (b = this.glyphs.get(0)), b;
		};
		k.prototype.glyphIndexToName = function(b) {
			return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(b) : "";
		};
		k.prototype.getKerningValue = function(b, c) {
			b = b.index || b;
			c = c.index || c;
			var e = this.getGposKerningValue;
			return e ? e(b, c) : this.kerningPairs[b + "," + c] || 0;
		};
		k.prototype.forEachGlyph = function(b, c, e, f, g, h) {
			c = void 0 !== c ? c : 0;
			e = void 0 !== e ? e : 0;
			f = void 0 !== f ? f : 72;
			g = g || {};
			var k = void 0 === g.kerning ? !0 : g.kerning, l = 1 / this.unitsPerEm * f;
			b = this.stringToGlyphs(b);
			for (var p = 0;p < b.length;p += 1) {
				var q = b[p];
				if (h(q, c, e, f, g), q.advanceWidth && (c += q.advanceWidth * l), k && p < b.length - 1) {
					q = this.getKerningValue(q, b[p + 1]), c += q * l;
				}
			}
		};
		k.prototype.getPath = function(b, c, e, f, g) {
			var k = new h.Path;
			return this.forEachGlyph(b, c, e, f, g, function(b, c, e, f) {
				b = b.getPath(c, e, f);
				k.extend(b);
			}), k;
		};
		k.prototype.getPaths = function(b, c, e, f, g) {
			var h = [];
			return this.forEachGlyph(b, c, e, f, g, function(b, c, e, f) {
				b = b.getPath(c, e, f);
				h.push(b);
			}), h;
		};
		k.prototype.draw = function(b, c, e, f, g, h) {
			this.getPath(c, e, f, g, h).draw(b);
		};
		k.prototype.drawPoints = function(b, c, e, f, g, h) {
			this.forEachGlyph(c, e, f, g, h, function(c, e, f, g) {
				c.drawPoints(b, e, f, g);
			});
		};
		k.prototype.drawMetrics = function(b, c, e, f, g, h) {
			this.forEachGlyph(c, e, f, g, h, function(c, e, f, g) {
				c.drawMetrics(b, e, f, g);
			});
		};
		k.prototype.getEnglishName = function(b) {
			return (b = this.names[b]) ? b.en : void 0;
		};
		k.prototype.validate = function() {
			function b(b) {
				var f = e.getEnglishName(b);
				f && 0 < f.trim().length || c.push("No English " + b + " specified.");
			}
			var c = [], e = this;
			b("fontFamily");
			b("weightName");
			b("manufacturer");
			b("copyright");
			b("version");
			0 < this.unitsPerEm || c.push("No unitsPerEm specified.");
		};
		k.prototype.toTables = function() {
			return c.fontToTable(this);
		};
		k.prototype.toBuffer = function() {
			return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."), this.toArrayBuffer();
		};
		k.prototype.toArrayBuffer = function() {
			for (var b = this.toTables().encode(), c = new ArrayBuffer(b.length), e = new Uint8Array(c), f = 0;f < b.length;f++) {
				e[f] = b[f];
			}
			return c;
		};
		k.prototype.download = function() {
			var b = this.getEnglishName("fontFamily"), c = this.getEnglishName("fontSubfamily"), e = b.replace(/\s/g, "") + "-" + c + ".otf", g = this.toArrayBuffer();
			r.isBrowser() ? (window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem, window.requestFileSystem(window.TEMPORARY, g.byteLength, function(b) {
				b.root.getFile(e, {create:!0}, function(b) {
					b.createWriter(function(c) {
						var e = new DataView(g), e = new Blob([e], {type:"font/opentype"});
						c.write(e);
						c.addEventListener("writeend", function() {
							location.href = b.toURL();
						}, !1);
					});
				});
			}, function(b) {
				throw Error(b.name + ": " + b.message);
			})) : (b = f("fs"), c = r.arrayBufferToNodeBuffer(g), b.writeFileSync(e, c));
		};
		k.prototype.fsSelectionValues = {ITALIC:1, UNDERSCORE:2, NEGATIVE:4, OUTLINED:8, STRIKEOUT:16, BOLD:32, REGULAR:64, USER_TYPO_METRICS:128, WWS:256, OBLIQUE:512};
		k.prototype.usWidthClasses = {ULTRA_CONDENSED:1, EXTRA_CONDENSED:2, CONDENSED:3, SEMI_CONDENSED:4, MEDIUM:5, SEMI_EXPANDED:6, EXPANDED:7, EXTRA_EXPANDED:8, ULTRA_EXPANDED:9};
		k.prototype.usWeightClasses = {THIN:100, EXTRA_LIGHT:200, LIGHT:300, NORMAL:400, MEDIUM:500, SEMI_BOLD:600, BOLD:700, EXTRA_BOLD:800, BLACK:900};
		b.Font = k;
	}, {"./encoding":4, "./glyphset":7, "./path":11, "./substitution":12, "./tables/sfnt":31, "./util":33, fs:void 0}], 6:[function(f, l, b) {
		function k(b, c) {
			var e = c || {commands:[]};
			return {configurable:!0, get:function() {
				return "function" == typeof e && (e = e()), e;
			}, set:function(b) {
				e = b;
			}};
		}
		function h(b) {
			this.bindConstructorValues(b);
		}
		var c = f("./check"), e = f("./draw"), g = f("./path");
		h.prototype.bindConstructorValues = function(b) {
			this.index = b.index || 0;
			this.name = b.name || null;
			this.unicode = b.unicode || void 0;
			this.unicodes = b.unicodes || void 0 !== b.unicode ? [b.unicode] : [];
			b.xMin && (this.xMin = b.xMin);
			b.yMin && (this.yMin = b.yMin);
			b.xMax && (this.xMax = b.xMax);
			b.yMax && (this.yMax = b.yMax);
			b.advanceWidth && (this.advanceWidth = b.advanceWidth);
			Object.defineProperty(this, "path", k(this, b.path));
		};
		h.prototype.addUnicode = function(b) {
			0 === this.unicodes.length && (this.unicode = b);
			this.unicodes.push(b);
		};
		h.prototype.getPath = function(b, c, e, f) {
			b = void 0 !== b ? b : 0;
			c = void 0 !== c ? c : 0;
			f = void 0 !== f ? f : {xScale:1, yScale:1};
			var h = 1 / this.path.unitsPerEm * (void 0 !== e ? e : 72);
			e = f.xScale * h;
			f = f.yScale * h;
			for (var h = new g.Path, k = this.path.commands, l = 0;l < k.length;l += 1) {
				var p = k[l];
				"M" === p.type ? h.moveTo(b + p.x * e, c + -p.y * f) : "L" === p.type ? h.lineTo(b + p.x * e, c + -p.y * f) : "Q" === p.type ? h.quadraticCurveTo(b + p.x1 * e, c + -p.y1 * f, b + p.x * e, c + -p.y * f) : "C" === p.type ? h.curveTo(b + p.x1 * e, c + -p.y1 * f, b + p.x2 * e, c + -p.y2 * f, b + p.x * e, c + -p.y * f) : "Z" === p.type && h.closePath();
			}
			return h;
		};
		h.prototype.getContours = function() {
			if (void 0 === this.points) {
				return [];
			}
			for (var b = [], e = [], f = 0;f < this.points.length;f += 1) {
				var g = this.points[f];
				e.push(g);
				g.lastPointOfContour && (b.push(e), e = []);
			}
			return c.argument(0 === e.length, "There are still points left in the current contour."), b;
		};
		h.prototype.getMetrics = function() {
			for (var b = this.path.commands, c = [], e = [], f = 0;f < b.length;f += 1) {
				var g = b[f];
				"Z" !== g.type && (c.push(g.x), e.push(g.y));
				"Q" !== g.type && "C" !== g.type || (c.push(g.x1), e.push(g.y1));
				"C" === g.type && (c.push(g.x2), e.push(g.y2));
			}
			b = {xMin:Math.min.apply(null, c), yMin:Math.min.apply(null, e), xMax:Math.max.apply(null, c), yMax:Math.max.apply(null, e), leftSideBearing:this.leftSideBearing};
			return isFinite(b.xMin) || (b.xMin = 0), isFinite(b.xMax) || (b.xMax = this.advanceWidth), isFinite(b.yMin) || (b.yMin = 0), isFinite(b.yMax) || (b.yMax = 0), b.rightSideBearing = this.advanceWidth - b.leftSideBearing - (b.xMax - b.xMin), b;
		};
		h.prototype.draw = function(b, c, e, f, g) {
			this.getPath(c, e, f, g).draw(b);
		};
		h.prototype.drawPoints = function(b, c, e, f) {
			function g(c, e, f, g) {
				var h = 2 * Math.PI;
				b.beginPath();
				for (var k = 0;k < c.length;k += 1) {
					b.moveTo(e + c[k].x * g, f + c[k].y * g), b.arc(e + c[k].x * g, f + c[k].y * g, 2, 0, h, !1);
				}
				b.closePath();
				b.fill();
			}
			c = void 0 !== c ? c : 0;
			e = void 0 !== e ? e : 0;
			f = 1 / this.path.unitsPerEm * (void 0 !== f ? f : 24);
			for (var h = [], k = [], l = this.path, m = 0;m < l.commands.length;m += 1) {
				var p = l.commands[m];
				void 0 !== p.x && h.push({x:p.x, y:-p.y});
				void 0 !== p.x1 && k.push({x:p.x1, y:-p.y1});
				void 0 !== p.x2 && k.push({x:p.x2, y:-p.y2});
			}
			b.fillStyle = "blue";
			g(h, c, e, f);
			b.fillStyle = "red";
			g(k, c, e, f);
		};
		h.prototype.drawMetrics = function(b, c, f, g) {
			c = void 0 !== c ? c : 0;
			f = void 0 !== f ? f : 0;
			g = 1 / this.path.unitsPerEm * (void 0 !== g ? g : 24);
			b.lineWidth = 1;
			b.strokeStyle = "black";
			e.line(b, c, -1E4, c, 1E4);
			e.line(b, -1E4, f, 1E4, f);
			var h = this.xMin || 0, k = this.yMin || 0, l = this.xMax || 0, p = this.yMax || 0, m = this.advanceWidth || 0;
			b.strokeStyle = "blue";
			e.line(b, c + h * g, -1E4, c + h * g, 1E4);
			e.line(b, c + l * g, -1E4, c + l * g, 1E4);
			e.line(b, -1E4, f + -k * g, 1E4, f + -k * g);
			e.line(b, -1E4, f + -p * g, 1E4, f + -p * g);
			b.strokeStyle = "green";
			e.line(b, c + m * g, -1E4, c + m * g, 1E4);
		};
		b.Glyph = h;
	}, {"./check":2, "./draw":3, "./path":11}], 7:[function(f, l, b) {
		function k(b, c, f) {
			Object.defineProperty(b, c, {get:function() {
				return b.path, b[f];
			}, set:function(c) {
				b[f] = c;
			}, enumerable:!0, configurable:!0});
		}
		function h(b, c) {
			if (this.font = b, this.glyphs = {}, Array.isArray(c)) {
				for (b = 0;b < c.length;b++) {
					this.glyphs[b] = c[b];
				}
			}
			this.length = c && c.length || 0;
		}
		var c = f("./glyph");
		h.prototype.get = function(b) {
			return "function" == typeof this.glyphs[b] && (this.glyphs[b] = this.glyphs[b]()), this.glyphs[b];
		};
		h.prototype.push = function(b, c) {
			this.glyphs[b] = c;
			this.length++;
		};
		b.GlyphSet = h;
		b.glyphLoader = function(b, f) {
			return new c.Glyph({index:f, font:b});
		};
		b.ttfGlyphLoader = function(b, f, h, l, w, p) {
			return function() {
				var e = new c.Glyph({index:f, font:b});
				return e.path = function() {
					h(e, l, w);
					var c = p(b.glyphs, e);
					return c.unitsPerEm = b.unitsPerEm, c;
				}, k(e, "xMin", "_xMin"), k(e, "xMax", "_xMax"), k(e, "yMin", "_yMin"), k(e, "yMax", "_yMax"), e;
			};
		};
		b.cffGlyphLoader = function(b, f, h, k) {
			return function() {
				var e = new c.Glyph({index:f, font:b});
				return e.path = function() {
					var c = h(b, e, k);
					return c.unitsPerEm = b.unitsPerEm, c;
				}, e;
			};
		};
	}, {"./glyph":6}], 8:[function(f, l, b) {
		function k(b, e) {
			for (var c = 0, f = b.length - 1;f >= c;) {
				var h = c + f >>> 1, k = b[h].tag;
				if (k === e) {
					return h;
				}
				e > k ? c = h + 1 : f = h - 1;
			}
			return -c - 1;
		}
		var h = f("./check");
		l.exports = {searchTag:k, binSearch:function(b, e) {
			for (var c = 0, f = b.length - 1;f >= c;) {
				var h = c + f >>> 1, k = b[h];
				if (k === e) {
					return h;
				}
				e > k ? c = h + 1 : f = h - 1;
			}
			return -c - 1;
		}, getScriptNames:function() {
			var b = this.getGsubTable();
			return b ? b.scripts.map(function(b) {
				return b.tag;
			}) : [];
		}, getScriptTable:function(b, e) {
			var c = this.getGsubTable(e);
			if (c) {
				e = c.scripts;
				c = k(c.scripts, b);
				if (0 <= c) {
					return e[c].script;
				}
				b = {tag:b, script:{defaultLangSys:{reserved:0, reqFeatureIndex:65535, featureIndexes:[]}, langSysRecords:[]}};
				return e.splice(-1 - c, 0, b.script), b;
			}
		}, getLangSysTable:function(b, e, f) {
			if (b = this.getScriptTable(b, f)) {
				if ("DFLT" === e) {
					return b.defaultLangSys;
				}
				var c = k(b.langSysRecords, e);
				if (0 <= c) {
					return b.langSysRecords[c].langSys;
				}
				if (f) {
					return e = {tag:e, langSys:{reserved:0, reqFeatureIndex:65535, featureIndexes:[]}}, b.langSysRecords.splice(-1 - c, 0, e), e.langSys;
				}
			}
		}, getFeatureTable:function(b, e, f, k) {
			if (b = this.getLangSysTable(b, e, k)) {
				var c;
				b = b.featureIndexes;
				e = this.font.tables.gsub.features;
				for (var g = 0;g < b.length;g++) {
					if (c = e[b[g]], c.tag === f) {
						return c.feature;
					}
				}
				if (k) {
					return k = e.length, h.assert(0 === k || f >= e[k - 1].tag, "Features must be added in alphabetical order."), c = {tag:f, feature:{params:0, lookupListIndexes:[]}}, e.push(c), b.push(k), c.feature;
				}
			}
		}, getLookupTable:function(b, e, f, h, k) {
			if (b = this.getFeatureTable(b, e, f, k)) {
				var c;
				b = b.lookupListIndexes;
				e = this.font.tables.gsub.lookups;
				for (f = 0;f < b.length;f++) {
					if (c = e[b[f]], c.lookupType === h) {
						return c;
					}
				}
				if (k) {
					return c = {lookupType:h, lookupFlag:0, subtables:[], markFilteringSet:void 0}, h = e.length, e.push(c), b.push(h), c;
				}
			}
		}, expandCoverage:function(b) {
			if (1 === b.format) {
				return b.glyphs;
			}
			var c = [];
			b = b.ranges;
			for (var f = 0;b > f;f++) {
				for (var h = b[f], k = h.end, h = h.start;k >= h;h++) {
					c.push(h);
				}
			}
			return c;
		}};
	}, {"./check":2}], 9:[function(f, l, b) {
		function k(b, c) {
			f("fs").readFile(b, function(b, e) {
				return b ? c(b.message) : void c(null, v.nodeBufferToArrayBuffer(e));
			});
		}
		function h(b, c) {
			var e = new XMLHttpRequest;
			e.open("get", b, !0);
			e.responseType = "arraybuffer";
			e.onload = function() {
				return 200 !== e.status ? c("Font could not be loaded: " + e.statusText) : c(null, e.response);
			};
			e.send();
		}
		function c(b, c) {
			for (var e = [], f = 12, g = 0;c > g;g += 1) {
				var h = p.getTag(b, f), k = p.getULong(b, f + 4), m = p.getULong(b, f + 8), l = p.getULong(b, f + 12);
				e.push({tag:h, checksum:k, offset:m, length:l, compression:!1});
				f += 16;
			}
			return e;
		}
		function e(b, c) {
			if ("WOFF" === c.compression) {
				b = new Uint8Array(b.buffer, c.offset + 2, c.compressedLength - 2);
				var e = new Uint8Array(c.originalLength);
				if (q(b, e), e.byteLength !== c.originalLength) {
					throw Error("Decompression error: " + c.tag + " decompressed length doesn't match recorded length");
				}
				return {data:new DataView(e.buffer, 0), offset:0};
			}
			return {data:b, offset:c.offset};
		}
		function g(b) {
			var f, g, h, k = new w.Font({empty:!0});
			b = new DataView(b, 0);
			var l;
			h = p.getTag(b, 0);
			if (h === String.fromCharCode(0, 1, 0, 0)) {
				k.outlinesFormat = "truetype", h = p.getUShort(b, 4), l = c(b, h);
			} else {
				if ("OTTO" === h) {
					k.outlinesFormat = "cff", h = p.getUShort(b, 4), l = c(b, h);
				} else {
					if ("wOFF" !== h) {
						throw Error("Unsupported OpenType signature " + h);
					}
					l = p.getTag(b, 4);
					if (l === String.fromCharCode(0, 1, 0, 0)) {
						k.outlinesFormat = "truetype";
					} else {
						if ("OTTO" !== l) {
							throw Error("Unsupported OpenType flavor " + h);
						}
						k.outlinesFormat = "cff";
					}
					l = h = p.getUShort(b, 12);
					for (var q = [], t = 44, v = 0;l > v;v += 1) {
						var ba = p.getTag(b, t), T = p.getULong(b, t + 4), pa = p.getULong(b, t + 8), ra = p.getULong(b, t + 12);
						q.push({tag:ba, offset:T, compression:ra > pa ? "WOFF" : !1, compressedLength:pa, originalLength:ra});
						t += 20;
					}
					l = q;
				}
			}
			for (var qa, ea, Z, ua, sa, Ba, Ca, ya, wa, Sa, q = 0;h > q;q += 1) {
				switch(t = l[q], t.tag) {
					case "cmap":
						t = e(b, t);
						k.tables.cmap = y.parse(t.data, t.offset);
						k.encoding = new r.CmapEncoding(k.tables.cmap);
						break;
					case "fvar":
						ea = t;
						break;
					case "head":
						t = e(b, t);
						k.tables.head = D.parse(t.data, t.offset);
						k.unitsPerEm = k.tables.head.unitsPerEm;
						f = k.tables.head.indexToLocFormat;
						break;
					case "hhea":
						t = e(b, t);
						k.tables.hhea = G.parse(t.data, t.offset);
						k.ascender = k.tables.hhea.ascender;
						k.descender = k.tables.hhea.descender;
						k.numberOfHMetrics = k.tables.hhea.numberOfHMetrics;
						break;
					case "hmtx":
						Ba = t;
						break;
					case "ltag":
						t = e(b, t);
						g = J.parse(t.data, t.offset);
						break;
					case "maxp":
						t = e(b, t);
						k.tables.maxp = Q.parse(t.data, t.offset);
						k.numGlyphs = k.tables.maxp.numGlyphs;
						break;
					case "name":
						wa = t;
						break;
					case "OS/2":
						t = e(b, t);
						k.tables.os2 = N.parse(t.data, t.offset);
						break;
					case "post":
						t = e(b, t);
						k.tables.post = R.parse(t.data, t.offset);
						k.glyphNames = new r.GlyphNames(k.tables.post);
						break;
					case "glyf":
						Z = t;
						break;
					case "loca":
						ya = t;
						break;
					case "CFF ":
						qa = t;
						break;
					case "kern":
						Ca = t;
						break;
					case "GPOS":
						ua = t;
						break;
					case "GSUB":
						sa = t;
						break;
					case "meta":
						Sa = t;
				}
			}
			wa = e(b, wa);
			if (k.tables.name = M.parse(wa.data, wa.offset, g), k.names = k.tables.name, Z && ya) {
				f = 0 === f, ya = e(b, ya), ya = I.parse(ya.data, ya.offset, k.numGlyphs, f), Z = e(b, Z), k.glyphs = u.parse(Z.data, Z.offset, ya, k);
			} else {
				if (!qa) {
					throw Error("Font doesn't contain TrueType or CFF outlines.");
				}
				Z = e(b, qa);
				x.parse(Z.data, Z.offset, k);
			}
			Ba = e(b, Ba);
			(F.parse(Ba.data, Ba.offset, k.numberOfHMetrics, k.numGlyphs, k.glyphs), r.addGlyphNames(k), Ca) ? (Ca = e(b, Ca), k.kerningPairs = C.parse(Ca.data, Ca.offset)) : k.kerningPairs = {};
			ua && (ua = e(b, ua), B.parse(ua.data, ua.offset, k));
			sa && (sa = e(b, sa), k.tables.gsub = A.parse(sa.data, sa.offset));
			ea && (ea = e(b, ea), k.tables.fvar = m.parse(ea.data, ea.offset, k.names));
			Sa && (Sa = e(b, Sa), k.tables.meta = H.parse(Sa.data, Sa.offset), k.metas = k.tables.meta);
			return k;
		}
		var q = f("tiny-inflate"), r = f("./encoding"), w = f("./font");
		l = f("./glyph");
		var p = f("./parse"), t = f("./path"), v = f("./util"), y = f("./tables/cmap"), x = f("./tables/cff"), m = f("./tables/fvar"), u = f("./tables/glyf"), B = f("./tables/gpos"), A = f("./tables/gsub"), D = f("./tables/head"), G = f("./tables/hhea"), F = f("./tables/hmtx"), C = f("./tables/kern"), J = f("./tables/ltag"), I = f("./tables/loca"), Q = f("./tables/maxp"), M = f("./tables/name"), N = f("./tables/os2"), R = f("./tables/post"), H = f("./tables/meta");
		b._parse = p;
		b.Font = w.Font;
		b.Glyph = l.Glyph;
		b.Path = t.Path;
		b.parse = g;
		b.load = function(b, c) {
			("undefined" == typeof window ? k : h)(b, function(b, e) {
				if (b) {
					return c(b);
				}
				var f;
				try {
					f = g(e);
				} catch (V) {
					return c(V, null);
				}
				return c(null, f);
			});
		};
		b.loadSync = function(b) {
			b = f("fs").readFileSync(b);
			return g(v.nodeBufferToArrayBuffer(b));
		};
	}, {"./encoding":4, "./font":5, "./glyph":6, "./parse":10, "./path":11, "./tables/cff":14, "./tables/cmap":15, "./tables/fvar":16, "./tables/glyf":17, "./tables/gpos":18, "./tables/gsub":19, "./tables/head":20, "./tables/hhea":21, "./tables/hmtx":22, "./tables/kern":23, "./tables/loca":24, "./tables/ltag":25, "./tables/maxp":26, "./tables/meta":27, "./tables/name":28, "./tables/os2":29, "./tables/post":30, "./util":33, fs:void 0, "tiny-inflate":1}], 10:[function(f, l, b) {
		function k(b, c) {
			return b.getUint16(c, !1);
		}
		function h(b, c) {
			this.data = b;
			this.offset = c;
			this.relativeOffset = 0;
		}
		var c = f("./check");
		b.getByte = function(b, c) {
			return b.getUint8(c);
		};
		b.getCard8 = b.getByte;
		b.getUShort = b.getCard16 = k;
		b.getShort = function(b, c) {
			return b.getInt16(c, !1);
		};
		b.getULong = function(b, c) {
			return b.getUint32(c, !1);
		};
		b.getFixed = function(b, c) {
			var e = b.getInt16(c, !1);
			b = b.getUint16(c + 2, !1);
			return e + b / 65535;
		};
		b.getTag = function(b, c) {
			for (var e = "", f = c;c + 4 > f;f += 1) {
				e += String.fromCharCode(b.getInt8(f));
			}
			return e;
		};
		b.getOffset = function(b, c, e) {
			for (var f = 0, g = 0;e > g;g += 1) {
				f <<= 8, f += b.getUint8(c + g);
			}
			return f;
		};
		b.getBytes = function(b, c, e) {
			for (var f = [];e > c;c += 1) {
				f.push(b.getUint8(c));
			}
			return f;
		};
		b.bytesToString = function(b) {
			for (var c = "", e = 0;e < b.length;e += 1) {
				c += String.fromCharCode(b[e]);
			}
			return c;
		};
		var e = {"byte":1, uShort:2, "short":2, uLong:4, fixed:4, longDateTime:8, tag:4};
		h.prototype.parseByte = function() {
			var b = this.data.getUint8(this.offset + this.relativeOffset);
			return this.relativeOffset += 1, b;
		};
		h.prototype.parseChar = function() {
			var b = this.data.getInt8(this.offset + this.relativeOffset);
			return this.relativeOffset += 1, b;
		};
		h.prototype.parseCard8 = h.prototype.parseByte;
		h.prototype.parseUShort = function() {
			var b = this.data.getUint16(this.offset + this.relativeOffset);
			return this.relativeOffset += 2, b;
		};
		h.prototype.parseCard16 = h.prototype.parseUShort;
		h.prototype.parseSID = h.prototype.parseUShort;
		h.prototype.parseOffset16 = h.prototype.parseUShort;
		h.prototype.parseShort = function() {
			var b = this.data.getInt16(this.offset + this.relativeOffset);
			return this.relativeOffset += 2, b;
		};
		h.prototype.parseF2Dot14 = function() {
			var b = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
			return this.relativeOffset += 2, b;
		};
		h.prototype.parseULong = function() {
			var c = b.getULong(this.data, this.offset + this.relativeOffset);
			return this.relativeOffset += 4, c;
		};
		h.prototype.parseFixed = function() {
			var c = b.getFixed(this.data, this.offset + this.relativeOffset);
			return this.relativeOffset += 4, c;
		};
		h.prototype.parseString = function(b) {
			var c = this.data, e = this.offset + this.relativeOffset, f = "";
			this.relativeOffset += b;
			for (var g = 0;b > g;g++) {
				f += String.fromCharCode(c.getUint8(e + g));
			}
			return f;
		};
		h.prototype.parseTag = function() {
			return this.parseString(4);
		};
		h.prototype.parseLongDateTime = function() {
			var c = b.getULong(this.data, this.offset + this.relativeOffset + 4);
			return c -= 2082844800, this.relativeOffset += 8, c;
		};
		h.prototype.parseVersion = function() {
			var b = k(this.data, this.offset + this.relativeOffset), c = k(this.data, this.offset + this.relativeOffset + 2);
			return this.relativeOffset += 4, b + c / 4096 / 10;
		};
		h.prototype.skip = function(b, c) {
			void 0 === c && (c = 1);
			this.relativeOffset += e[b] * c;
		};
		h.prototype.parseOffset16List = h.prototype.parseUShortList = function(b) {
			void 0 === b && (b = this.parseUShort());
			for (var c = Array(b), e = this.data, f = this.offset + this.relativeOffset, g = 0;b > g;g++) {
				c[g] = e.getUint16(f), f += 2;
			}
			return this.relativeOffset += 2 * b, c;
		};
		h.prototype.parseList = function(b, c) {
			c || (c = b, b = this.parseUShort());
			for (var e = Array(b), f = 0;b > f;f++) {
				e[f] = c.call(this);
			}
			return e;
		};
		h.prototype.parseRecordList = function(b, c) {
			c || (c = b, b = this.parseUShort());
			for (var e = Array(b), f = Object.keys(c), g = 0;b > g;g++) {
				for (var h = {}, k = 0;k < f.length;k++) {
					var l = f[k];
					h[l] = c[l].call(this);
				}
				e[g] = h;
			}
			return e;
		};
		h.prototype.parseStruct = function(b) {
			if ("function" == typeof b) {
				return b.call(this);
			}
			for (var c = Object.keys(b), e = {}, f = 0;f < c.length;f++) {
				var g = c[f];
				e[g] = b[g].call(this);
			}
			return e;
		};
		h.prototype.parsePointer = function(b) {
			var c = this.parseOffset16();
			return 0 < c ? (new h(this.data, this.offset + c)).parseStruct(b) : void 0;
		};
		h.prototype.parseListOfLists = function(b) {
			for (var c = this.parseOffset16List(), e = c.length, f = this.relativeOffset, g = Array(e), h = 0;e > h;h++) {
				var k = c[h];
				if (0 !== k) {
					if (this.relativeOffset = k, b) {
						for (var l = this.parseOffset16List(), m = Array(l.length), q = 0;q < l.length;q++) {
							this.relativeOffset = k + l[q], m[q] = b.call(this);
						}
						g[h] = m;
					} else {
						g[h] = this.parseUShortList();
					}
				} else {
					g[h] = void 0;
				}
			}
			return this.relativeOffset = f, g;
		};
		h.prototype.parseCoverage = function() {
			var b = this.offset + this.relativeOffset, e = this.parseUShort(), f = this.parseUShort();
			if (1 === e) {
				return {format:1, glyphs:this.parseUShortList(f)};
			}
			if (2 === e) {
				b = Array(f);
				for (e = 0;f > e;e++) {
					b[e] = {start:this.parseUShort(), end:this.parseUShort(), index:this.parseUShort()};
				}
				return {format:2, ranges:b};
			}
			c.assert(!1, "0x" + b.toString(16) + ": Coverage format must be 1 or 2.");
		};
		h.prototype.parseClassDef = function() {
			var b = this.offset + this.relativeOffset, e = this.parseUShort();
			return 1 === e ? {format:1, startGlyph:this.parseUShort(), classes:this.parseUShortList()} : 2 === e ? {format:2, ranges:this.parseRecordList({start:h.uShort, end:h.uShort, classId:h.uShort})} : void c.assert(!1, "0x" + b.toString(16) + ": ClassDef format must be 1 or 2.");
		};
		h.list = function(b, c) {
			return function() {
				return this.parseList(b, c);
			};
		};
		h.recordList = function(b, c) {
			return function() {
				return this.parseRecordList(b, c);
			};
		};
		h.pointer = function(b) {
			return function() {
				return this.parsePointer(b);
			};
		};
		h.tag = h.prototype.parseTag;
		h.byte = h.prototype.parseByte;
		h.uShort = h.offset16 = h.prototype.parseUShort;
		h.uShortList = h.prototype.parseUShortList;
		h.struct = h.prototype.parseStruct;
		h.coverage = h.prototype.parseCoverage;
		h.classDef = h.prototype.parseClassDef;
		var g = {reserved:h.uShort, reqFeatureIndex:h.uShort, featureIndexes:h.uShortList};
		h.prototype.parseScriptList = function() {
			return this.parsePointer(h.recordList({tag:h.tag, script:h.pointer({defaultLangSys:h.pointer(g), langSysRecords:h.recordList({tag:h.tag, langSys:h.pointer(g)})})}));
		};
		h.prototype.parseFeatureList = function() {
			return this.parsePointer(h.recordList({tag:h.tag, feature:h.pointer({featureParams:h.offset16, lookupListIndexes:h.uShortList})}));
		};
		h.prototype.parseLookupList = function(b) {
			return this.parsePointer(h.list(h.pointer(function() {
				var e = this.parseUShort();
				c.argument(1 <= e && 8 >= e, "GSUB lookup type " + e + " unknown.");
				var f = this.parseUShort(), g = 16 & f;
				return {lookupType:e, lookupFlag:f, subtables:this.parseList(h.pointer(b[e])), markFilteringSet:g ? this.parseUShort() : void 0};
			})));
		};
		b.Parser = h;
	}, {"./check":2}], 11:[function(f, l, b) {
		function k() {
			this.commands = [];
			this.fill = "black";
			this.stroke = null;
			this.strokeWidth = 1;
		}
		k.prototype.moveTo = function(b, c) {
			this.commands.push({type:"M", x:b, y:c});
		};
		k.prototype.lineTo = function(b, c) {
			this.commands.push({type:"L", x:b, y:c});
		};
		k.prototype.curveTo = k.prototype.bezierCurveTo = function(b, c, e, f, k, l) {
			this.commands.push({type:"C", x1:b, y1:c, x2:e, y2:f, x:k, y:l});
		};
		k.prototype.quadTo = k.prototype.quadraticCurveTo = function(b, c, e, f) {
			this.commands.push({type:"Q", x1:b, y1:c, x:e, y:f});
		};
		k.prototype.close = k.prototype.closePath = function() {
			this.commands.push({type:"Z"});
		};
		k.prototype.extend = function(b) {
			b.commands && (b = b.commands);
			Array.prototype.push.apply(this.commands, b);
		};
		k.prototype.draw = function(b) {
			b.beginPath();
			for (var c = 0;c < this.commands.length;c += 1) {
				var e = this.commands[c];
				"M" === e.type ? b.moveTo(e.x, e.y) : "L" === e.type ? b.lineTo(e.x, e.y) : "C" === e.type ? b.bezierCurveTo(e.x1, e.y1, e.x2, e.y2, e.x, e.y) : "Q" === e.type ? b.quadraticCurveTo(e.x1, e.y1, e.x, e.y) : "Z" === e.type && b.closePath();
			}
			this.fill && (b.fillStyle = this.fill, b.fill());
			this.stroke && (b.strokeStyle = this.stroke, b.lineWidth = this.strokeWidth, b.stroke());
		};
		k.prototype.toPathData = function(b) {
			function c() {
				for (var c = "", e = 0;e < arguments.length;e += 1) {
					var f = arguments[e];
					0 <= f && 0 < e && (c += " ");
					c += Math.round(f) === f ? "" + Math.round(f) : f.toFixed(b);
				}
				return c;
			}
			b = void 0 !== b ? b : 2;
			for (var e = "", f = 0;f < this.commands.length;f += 1) {
				var h = this.commands[f];
				"M" === h.type ? e += "M" + c(h.x, h.y) : "L" === h.type ? e += "L" + c(h.x, h.y) : "C" === h.type ? e += "C" + c(h.x1, h.y1, h.x2, h.y2, h.x, h.y) : "Q" === h.type ? e += "Q" + c(h.x1, h.y1, h.x, h.y) : "Z" === h.type && (e += "Z");
			}
			return e;
		};
		k.prototype.toSVG = function(b) {
			var c = '<path d="';
			return c += this.toPathData(b), c += '"', this.fill && "black" !== this.fill && (c += null === this.fill ? ' fill="none"' : ' fill="' + this.fill + '"'), this.stroke && (c += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"'), c + "/>";
		};
		b.Path = k;
	}, {}], 12:[function(f, l, b) {
		function k(b, e, f) {
			b = b.subtables;
			for (var c = 0;c < b.length;c++) {
				var g = b[c];
				if (g.substFormat === e) {
					return g;
				}
			}
			return f ? (b.push(f), f) : void 0;
		}
		var h = f("./check");
		f = f("./layout");
		b = function(b) {
			this.font = b;
		};
		b.prototype = f;
		b.prototype.getGsubTable = function(b) {
			var c = this.font.tables.gsub;
			return !c && b && (this.font.tables.gsub = c = {version:1, scripts:[{tag:"DFLT", script:{defaultLangSys:{reserved:0, reqFeatureIndex:65535, featureIndexes:[]}, langSysRecords:[]}}], features:[], lookups:[]}), c;
		};
		b.prototype.getSingle = function(b, e, f) {
			var c = [];
			b = this.getLookupTable(e, f, b, 1);
			if (!b) {
				return c;
			}
			b = b.subtables;
			for (e = 0;e < b.length;e++) {
				var g;
				g = b[e];
				f = this.expandCoverage(g.coverage);
				if (1 === g.substFormat) {
					var h = g.deltaGlyphId;
					for (g = 0;g < f.length;g++) {
						var k = f[g];
						c.push({sub:k, by:k + h});
					}
				} else {
					for (h = g.substitute, g = 0;g < f.length;g++) {
						c.push({sub:f[g], by:h[g]});
					}
				}
			}
			return c;
		};
		b.prototype.getAlternates = function(b, e, f) {
			var c = [];
			b = this.getLookupTable(e, f, b, 3);
			if (!b) {
				return c;
			}
			b = b.subtables;
			for (e = 0;e < b.length;e++) {
				var g = b[e];
				f = this.expandCoverage(g.coverage);
				for (var g = g.alternateSets, h = 0;h < f.length;h++) {
					c.push({sub:f[h], by:g[h]});
				}
			}
			return c;
		};
		b.prototype.getLigatures = function(b, e, f) {
			var c = [];
			b = this.getLookupTable(e, f, b, 4);
			if (!b) {
				return [];
			}
			b = b.subtables;
			for (e = 0;e < b.length;e++) {
				var g = b[e];
				f = this.expandCoverage(g.coverage);
				for (var g = g.ligatureSets, h = 0;h < f.length;h++) {
					for (var k = f[h], l = g[h], v = 0;v < l.length;v++) {
						var y = l[v];
						c.push({sub:[k].concat(y.components), by:y.ligGlyph});
					}
				}
			}
			return c;
		};
		b.prototype.addSingle = function(b, e, f, l) {
			b = this.getLookupTable(f, l, b, 1, !0);
			b = k(b, 2, {substFormat:2, coverage:{format:1, glyphs:[]}, substitute:[]});
			h.assert(1 === b.coverage.format, "Ligature: unable to modify coverage table format " + b.coverage.format);
			f = e.sub;
			l = this.binSearch(b.coverage.glyphs, f);
			0 > l && (l = -1 - l, b.coverage.glyphs.splice(l, 0, f), b.substitute.splice(l, 0, 0));
			b.substitute[l] = e.by;
		};
		b.prototype.addAlternate = function(b, e, f, l) {
			b = this.getLookupTable(f, l, b, 3, !0);
			b = k(b, 1, {substFormat:1, coverage:{format:1, glyphs:[]}, alternateSets:[]});
			h.assert(1 === b.coverage.format, "Ligature: unable to modify coverage table format " + b.coverage.format);
			f = e.sub;
			l = this.binSearch(b.coverage.glyphs, f);
			0 > l && (l = -1 - l, b.coverage.glyphs.splice(l, 0, f), b.alternateSets.splice(l, 0, 0));
			b.alternateSets[l] = e.by;
		};
		b.prototype.addLigature = function(b, e, f, k) {
			b = this.getLookupTable(f || "DFLT", k || "DFLT", b, 4, !0);
			(f = b.subtables[0]) || (f = {substFormat:1, coverage:{format:1, glyphs:[]}, ligatureSets:[]}, b.subtables[0] = f);
			h.assert(1 === f.coverage.format, "Ligature: unable to modify coverage table format " + f.coverage.format);
			k = e.sub[0];
			b = e.sub.slice(1);
			e = {ligGlyph:e.by, components:b};
			var c = this.binSearch(f.coverage.glyphs, k);
			if (0 <= c) {
				f = f.ligatureSets[c];
				for (k = 0;k < f.length;k++) {
					a: {
						var c = f[k].components, g = c.length;
						if (g !== b.length) {
							c = !1;
						} else {
							for (var l = 0;g > l;l++) {
								if (c[l] !== b[l]) {
									c = !1;
									break a;
								}
							}
							c = !0;
						}
					}
					if (c) {
						return;
					}
				}
				f.push(e);
			} else {
				c = -1 - c, f.coverage.glyphs.splice(c, 0, k), f.ligatureSets.splice(c, 0, [e]);
			}
		};
		b.prototype.getFeature = function(b, e, f) {
			if (e = e || "DFLT", f = f || "DFLT", /ss\d\d/.test(b)) {
				return this.getSingle(b, e, f);
			}
			switch(b) {
				case "aalt":
				;
				case "salt":
					return this.getSingle(b, e, f).concat(this.getAlternates(b, e, f));
				case "dlig":
				;
				case "liga":
				;
				case "rlig":
					return this.getLigatures(b, e, f);
			}
		};
		b.prototype.add = function(b, e, f, h) {
			if (f = f || "DFLT", h = h || "DFLT", /ss\d\d/.test(b)) {
				return this.addSingle(b, e, f, h);
			}
			switch(b) {
				case "aalt":
				;
				case "salt":
					return "number" == typeof e.by ? this.addSingle(b, e, f, h) : this.addAlternate(b, e, f, h);
				case "dlig":
				;
				case "liga":
				;
				case "rlig":
					return this.addLigature(b, e, f, h);
			}
		};
		l.exports = b;
	}, {"./check":2, "./layout":8}], 13:[function(f, l, b) {
		function k(b, c, e) {
			var f;
			for (f = 0;f < c.length;f += 1) {
				var g = c[f];
				this[g.name] = g.value;
			}
			if (this.tableName = b, this.fields = c, e) {
				for (b = Object.keys(e), f = 0;f < b.length;f += 1) {
					c = b[f], g = e[c], void 0 !== this[c] && (this[c] = g);
				}
			}
		}
		function h(b, c, e) {
			void 0 === e && (e = c.length);
			var f = Array(c.length + 1);
			f[0] = {name:b + "Count", type:"USHORT", value:e};
			for (e = 0;e < c.length;e++) {
				f[e + 1] = {name:b + e, type:"USHORT", value:c[e]};
			}
			return f;
		}
		function c(b, c, e) {
			var f = c.length, g = Array(f + 1);
			g[0] = {name:b + "Count", type:"USHORT", value:f};
			for (var h = 0;f > h;h++) {
				g[h + 1] = {name:b + h, type:"TABLE", value:e(c[h], h)};
			}
			return g;
		}
		function e(b, c, e) {
			var f = c.length, g = [];
			g[0] = {name:b + "Count", type:"USHORT", value:f};
			for (b = 0;f > b;b++) {
				g = g.concat(e(c[b], b));
			}
			return g;
		}
		function g(b) {
			1 === b.format ? k.call(this, "coverageTable", [{name:"coverageFormat", type:"USHORT", value:1}].concat(h("glyph", b.glyphs))) : p.assert(!1, "Can't create coverage table format 2 yet.");
		}
		function q(b) {
			k.call(this, "scriptListTable", e("scriptRecord", b, function(b, c) {
				var f = b.script, g = f.defaultLangSys;
				return p.assert(!!g, "Unable to write GSUB: script " + b.tag + " has no default language system."), [{name:"scriptTag" + c, type:"TAG", value:b.tag}, {name:"script" + c, type:"TABLE", value:new k("scriptTable", [{name:"defaultLangSys", type:"TABLE", value:new k("defaultLangSys", [{name:"lookupOrder", type:"USHORT", value:0}, {name:"reqFeatureIndex", type:"USHORT", value:g.reqFeatureIndex}].concat(h("featureIndex", g.featureIndexes)))}].concat(e("langSys", f.langSysRecords, function(b, c) {
					var e = b.langSys;
					return [{name:"langSysTag" + c, type:"TAG", value:b.tag}, {name:"langSys" + c, type:"TABLE", value:new k("langSys", [{name:"lookupOrder", type:"USHORT", value:0}, {name:"reqFeatureIndex", type:"USHORT", value:e.reqFeatureIndex}].concat(h("featureIndex", e.featureIndexes)))}];
				})))}];
			}));
		}
		function r(b) {
			k.call(this, "featureListTable", e("featureRecord", b, function(b, c) {
				var e = b.feature;
				return [{name:"featureTag" + c, type:"TAG", value:b.tag}, {name:"feature" + c, type:"TABLE", value:new k("featureTable", [{name:"featureParams", type:"USHORT", value:e.featureParams}].concat(h("lookupListIndex", e.lookupListIndexes)))}];
			}));
		}
		function w(b, e) {
			k.call(this, "lookupListTable", c("lookup", b, function(b) {
				var f = e[b.lookupType];
				return p.assert(!!f, "Unable to write GSUB lookup type " + b.lookupType + " tables."), new k("lookupTable", [{name:"lookupType", type:"USHORT", value:b.lookupType}, {name:"lookupFlag", type:"USHORT", value:b.lookupFlag}].concat(c("subtable", b.subtables, f)));
			}));
		}
		var p = f("./check"), t = f("./types").encode, v = f("./types").sizeOf;
		k.prototype.encode = function() {
			return t.TABLE(this);
		};
		k.prototype.sizeOf = function() {
			return v.TABLE(this);
		};
		g.prototype = Object.create(k.prototype);
		g.prototype.constructor = g;
		q.prototype = Object.create(k.prototype);
		q.prototype.constructor = q;
		r.prototype = Object.create(k.prototype);
		r.prototype.constructor = r;
		w.prototype = Object.create(k.prototype);
		w.prototype.constructor = w;
		b.Record = b.Table = k;
		b.Coverage = g;
		b.ScriptList = q;
		b.FeatureList = r;
		b.LookupList = w;
		b.ushortList = h;
		b.tableList = c;
		b.recordList = e;
	}, {"./check":2, "./types":32}], 14:[function(f, l, b) {
		function k(b, c) {
			if (b === c) {
				return !0;
			}
			if (Array.isArray(b) && Array.isArray(c)) {
				if (b.length !== c.length) {
					return !1;
				}
				for (var e = 0;e < b.length;e += 1) {
					if (!k(b[e], c[e])) {
						return !1;
					}
				}
				return !0;
			}
			return !1;
		}
		function h(b, c, e) {
			var f, g, h, k = [], m = [];
			h = u.getCard16(b, c);
			if (0 !== h) {
				var l = u.getByte(b, c + 2);
				g = c + (h + 1) * l + 2;
				var p = c + 3;
				for (f = 0;h + 1 > f;f += 1) {
					k.push(u.getOffset(b, p, l)), p += l;
				}
				h = g + k[h];
			} else {
				h = c + 2;
			}
			for (f = 0;f < k.length - 1;f += 1) {
				l = u.getBytes(b, g + k[f], g + k[f + 1]), e && (l = e(l)), m.push(l);
			}
			return {objects:m, startOffset:c, endOffset:h};
		}
		function c(b, c) {
			var e, f, g, h;
			if (28 === c) {
				return e = b.parseByte(), f = b.parseByte(), e << 8 | f;
			}
			if (29 === c) {
				return e = b.parseByte(), f = b.parseByte(), g = b.parseByte(), h = b.parseByte(), e << 24 | f << 16 | g << 8 | h;
			}
			if (30 === c) {
				c = "";
				for (e = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];;) {
					g = b.parseByte();
					f = g >> 4;
					g &= 15;
					if (15 === f) {
						break;
					}
					if (c += e[f], 15 === g) {
						break;
					}
					c += e[g];
				}
				return parseFloat(c);
			}
			if (32 <= c && 246 >= c) {
				return c - 139;
			}
			if (247 <= c && 250 >= c) {
				return e = b.parseByte(), 256 * (c - 247) + e + 108;
			}
			if (251 <= c && 254 >= c) {
				return e = b.parseByte(), 256 * -(c - 251) - e - 108;
			}
			throw Error("Invalid b0 " + c);
		}
		function e(b, e, f) {
			var g = new u.Parser(b, void 0 !== e ? e : 0);
			e = [];
			var h = [];
			for (f = void 0 !== f ? f : b.length;g.relativeOffset < f;) {
				b = g.parseByte(), 21 >= b ? (12 === b && (b = 1200 + g.parseByte()), e.push([b, h]), h = []) : h.push(c(g, b));
			}
			f = {};
			for (b = 0;b < e.length;b += 1) {
				g = e[b][0];
				h = e[b][1];
				if (h = 1 === h.length ? h[0] : h, f.hasOwnProperty(g)) {
					throw Error("Object " + f + " already has key " + g);
				}
				f[g] = h;
			}
			return f;
		}
		function g(b, c) {
			return 390 >= c ? x.cffStandardStrings[c] : b[c - 391];
		}
		function q(b, c, e) {
			for (var f = {}, h = 0;h < c.length;h += 1) {
				var k = c[h], m = b[k.op];
				void 0 === m && (m = void 0 !== k.value ? k.value : null);
				"SID" === k.type && (m = g(e, m));
				f[k.name] = m;
			}
			return f;
		}
		function r(b, c, e) {
			function f(b, c) {
				w && q.closePath();
				q.moveTo(b, c);
				w = !0;
			}
			function g() {
				0 !== r.length % 2 && !v && (u = r.shift() + b.nominalWidthX);
				t += r.length >> 1;
				r.length = 0;
				v = !0;
			}
			function h(e) {
				for (var A, C, B, D, F, G, I, J, M, H, N = 0;N < e.length;) {
					switch(F = e[N], N += 1, F) {
						case 1:
							g();
							break;
						case 3:
							g();
							break;
						case 4:
							1 < r.length && !v && (u = r.shift() + b.nominalWidthX, v = !0);
							x += r.pop();
							f(y, x);
							break;
						case 5:
							for (;0 < r.length;) {
								y += r.shift(), x += r.shift(), q.lineTo(y, x);
							}
							break;
						case 6:
							for (;0 < r.length && (y += r.shift(), q.lineTo(y, x), 0 !== r.length);) {
								x += r.shift(), q.lineTo(y, x);
							}
							break;
						case 7:
							for (;0 < r.length && (x += r.shift(), q.lineTo(y, x), 0 !== r.length);) {
								y += r.shift(), q.lineTo(y, x);
							}
							break;
						case 8:
							for (;0 < r.length;) {
								k = y + r.shift(), m = x + r.shift(), l = k + r.shift(), p = m + r.shift(), y = l + r.shift(), x = p + r.shift(), q.curveTo(k, m, l, p, y, x);
							}
							break;
						case 10:
							F = r.pop() + b.subrsBias;
							(F = b.subrs[F]) && h(F);
							break;
						case 11:
							return;
						case 12:
							switch(F = e[N], N += 1, F) {
								case 35:
									k = y + r.shift();
									m = x + r.shift();
									l = k + r.shift();
									p = m + r.shift();
									F = l + r.shift();
									G = p + r.shift();
									I = F + r.shift();
									J = G + r.shift();
									M = I + r.shift();
									H = J + r.shift();
									y = M + r.shift();
									x = H + r.shift();
									r.shift();
									q.curveTo(k, m, l, p, F, G);
									q.curveTo(I, J, M, H, y, x);
									break;
								case 34:
									k = y + r.shift();
									m = x;
									l = k + r.shift();
									p = m + r.shift();
									F = l + r.shift();
									G = p;
									I = F + r.shift();
									J = p;
									M = I + r.shift();
									H = x;
									y = M + r.shift();
									q.curveTo(k, m, l, p, F, G);
									q.curveTo(I, J, M, H, y, x);
									break;
								case 36:
									k = y + r.shift();
									m = x + r.shift();
									l = k + r.shift();
									p = m + r.shift();
									F = l + r.shift();
									G = p;
									I = F + r.shift();
									J = p;
									M = I + r.shift();
									H = J + r.shift();
									y = M + r.shift();
									q.curveTo(k, m, l, p, F, G);
									q.curveTo(I, J, M, H, y, x);
									break;
								case 37:
									k = y + r.shift();
									m = x + r.shift();
									l = k + r.shift();
									p = m + r.shift();
									F = l + r.shift();
									G = p + r.shift();
									I = F + r.shift();
									J = G + r.shift();
									M = I + r.shift();
									H = J + r.shift();
									Math.abs(M - y) > Math.abs(H - x) ? y = M + r.shift() : x = H + r.shift();
									q.curveTo(k, m, l, p, F, G);
									q.curveTo(I, J, M, H, y, x);
									break;
								default:
									console.log("Glyph " + c.index + ": unknown operator 1200" + F), r.length = 0;
							}
							break;
						case 14:
							0 < r.length && !v && (u = r.shift() + b.nominalWidthX, v = !0);
							w && (q.closePath(), w = !1);
							break;
						case 18:
							g();
							break;
						case 19:
						;
						case 20:
							g();
							N += t + 7 >> 3;
							break;
						case 21:
							2 < r.length && !v && (u = r.shift() + b.nominalWidthX, v = !0);
							x += r.pop();
							y += r.pop();
							f(y, x);
							break;
						case 22:
							1 < r.length && !v && (u = r.shift() + b.nominalWidthX, v = !0);
							y += r.pop();
							f(y, x);
							break;
						case 23:
							g();
							break;
						case 24:
							for (;2 < r.length;) {
								k = y + r.shift(), m = x + r.shift(), l = k + r.shift(), p = m + r.shift(), y = l + r.shift(), x = p + r.shift(), q.curveTo(k, m, l, p, y, x);
							}
							y += r.shift();
							x += r.shift();
							q.lineTo(y, x);
							break;
						case 25:
							for (;6 < r.length;) {
								y += r.shift(), x += r.shift(), q.lineTo(y, x);
							}
							k = y + r.shift();
							m = x + r.shift();
							l = k + r.shift();
							p = m + r.shift();
							y = l + r.shift();
							x = p + r.shift();
							q.curveTo(k, m, l, p, y, x);
							break;
						case 26:
							for (r.length % 2 && (y += r.shift());0 < r.length;) {
								k = y, m = x + r.shift(), l = k + r.shift(), p = m + r.shift(), y = l, x = p + r.shift(), q.curveTo(k, m, l, p, y, x);
							}
							break;
						case 27:
							for (r.length % 2 && (x += r.shift());0 < r.length;) {
								k = y + r.shift(), m = x, l = k + r.shift(), p = m + r.shift(), y = l + r.shift(), x = p, q.curveTo(k, m, l, p, y, x);
							}
							break;
						case 28:
							A = e[N];
							C = e[N + 1];
							r.push((A << 24 | C << 16) >> 16);
							N += 2;
							break;
						case 29:
							F = r.pop() + b.gsubrsBias;
							(F = b.gsubrs[F]) && h(F);
							break;
						case 30:
							for (;0 < r.length && (k = y, m = x + r.shift(), l = k + r.shift(), p = m + r.shift(), y = l + r.shift(), x = p + (1 === r.length ? r.shift() : 0), q.curveTo(k, m, l, p, y, x), 0 !== r.length);) {
								k = y + r.shift(), m = x, l = k + r.shift(), p = m + r.shift(), x = p + r.shift(), y = l + (1 === r.length ? r.shift() : 0), q.curveTo(k, m, l, p, y, x);
							}
							break;
						case 31:
							for (;0 < r.length && (k = y + r.shift(), m = x, l = k + r.shift(), p = m + r.shift(), x = p + r.shift(), y = l + (1 === r.length ? r.shift() : 0), q.curveTo(k, m, l, p, y, x), 0 !== r.length);) {
								k = y, m = x + r.shift(), l = k + r.shift(), p = m + r.shift(), y = l + r.shift(), x = p + (1 === r.length ? r.shift() : 0), q.curveTo(k, m, l, p, y, x);
							}
							break;
						default:
							32 > F ? console.log("Glyph " + c.index + ": unknown operator " + F) : 247 > F ? r.push(F - 139) : 251 > F ? (A = e[N], N += 1, r.push(256 * (F - 247) + A + 108)) : 255 > F ? (A = e[N], N += 1, r.push(256 * -(F - 251) - A - 108)) : (A = e[N], C = e[N + 1], B = e[N + 2], D = e[N + 3], N += 4, r.push((A << 24 | C << 16 | B << 8 | D) / 65536));
					}
				}
			}
			var k, m, l, p, q = new B.Path, r = [], t = 0, v = !1, u = b.defaultWidthX, w = !1, y = 0, x = 0;
			return h(e), c.advanceWidth = u, q;
		}
		function w(b) {
			return 1240 > b.length ? 107 : 33900 > b.length ? 1131 : 32768;
		}
		function p(b, c) {
			var e, f = x.cffStandardStrings.indexOf(b);
			return f = c.indexOf(b), 0 <= f ? e = f + x.cffStandardStrings.length : (e = x.cffStandardStrings.length + c.length, c.push(b)), e;
		}
		function t(b, c, e) {
			for (var f = {}, g = 0;g < b.length;g += 1) {
				var h = b[g], m = c[h.name];
				void 0 === m || k(m, h.value) || ("SID" === h.type && (m = p(m, e)), f[h.op] = {name:h.name, type:h.type, value:m});
			}
			return f;
		}
		function v(b, c) {
			var e = new A.Record("Top DICT", [{name:"dict", type:"DICT", value:{}}]);
			return e.dict = t(D, b, c), e;
		}
		function y(b) {
			var c = new A.Record("Top DICT INDEX", [{name:"topDicts", type:"INDEX", value:[]}]);
			return c.topDicts = [{name:"topDict_0", type:"TABLE", value:b}], c;
		}
		var x = f("../encoding"), m = f("../glyphset"), u = f("../parse"), B = f("../path"), A = f("../table"), D = [{name:"version", op:0, type:"SID"}, {name:"notice", op:1, type:"SID"}, {name:"copyright", op:1200, type:"SID"}, {name:"fullName", op:2, type:"SID"}, {name:"familyName", op:3, type:"SID"}, {name:"weight", op:4, type:"SID"}, {name:"isFixedPitch", op:1201, type:"number", value:0}, {name:"italicAngle", op:1202, type:"number", value:0}, {name:"underlinePosition", op:1203, type:"number", value:-100}, 
		{name:"underlineThickness", op:1204, type:"number", value:50}, {name:"paintType", op:1205, type:"number", value:0}, {name:"charstringType", op:1206, type:"number", value:2}, {name:"fontMatrix", op:1207, type:"real real real real real real".split(" "), value:[.001, 0, 0, .001, 0, 0]}, {name:"uniqueId", op:13, type:"number"}, {name:"fontBBox", op:5, type:["number", "number", "number", "number"], value:[0, 0, 0, 0]}, {name:"strokeWidth", op:1208, type:"number", value:0}, {name:"xuid", op:14, type:[], 
		value:null}, {name:"charset", op:15, type:"offset", value:0}, {name:"encoding", op:16, type:"offset", value:0}, {name:"charStrings", op:17, type:"offset", value:0}, {name:"private", op:18, type:["number", "offset"], value:[0, 0]}], G = [{name:"subrs", op:19, type:"offset", value:0}, {name:"defaultWidthX", op:20, type:"number", value:0}, {name:"nominalWidthX", op:21, type:"number", value:0}];
		b.parse = function(b, c, f) {
			f.tables.cff = {};
			var k;
			k = {};
			k = (k.formatMajor = u.getCard8(b, c), k.formatMinor = u.getCard8(b, c + 1), k.size = u.getCard8(b, c + 2), k.offsetSize = u.getCard8(b, c + 3), k.startOffset = c, k.endOffset = c + 4, k);
			k = h(b, k.endOffset, u.bytesToString);
			k = h(b, k.endOffset);
			var l = h(b, k.endOffset, u.bytesToString), p = h(b, l.endOffset);
			f.gsubrs = p.objects;
			f.gsubrsBias = w(f.gsubrs);
			p = new DataView((new Uint8Array(k.objects[0])).buffer);
			k = l.objects;
			p = e(p, 0, p.byteLength);
			p = q(p, D, k);
			f.tables.cff.topDict = p;
			k = c + p["private"][1];
			var t;
			t = l.objects;
			var v = e(b, k, p["private"][0]);
			t = q(v, G, t);
			(f.defaultWidthX = t.defaultWidthX, f.nominalWidthX = t.nominalWidthX, 0 !== t.subrs) ? (k = h(b, k + t.subrs), f.subrs = k.objects, f.subrsBias = w(f.subrs)) : (f.subrs = [], f.subrsBias = 0);
			k = h(b, c + p.charStrings);
			f.nGlyphs = k.objects.length;
			t = f.nGlyphs;
			var v = l.objects, y, A, B, C = new u.Parser(b, c + p.charset);
			--t;
			l = [".notdef"];
			y = C.parseCard8();
			if (0 === y) {
				for (y = 0;t > y;y += 1) {
					A = C.parseSID(), l.push(g(v, A));
				}
			} else {
				if (1 === y) {
					for (;l.length <= t;) {
						for (A = C.parseSID(), B = C.parseCard8(), y = 0;B >= y;y += 1) {
							l.push(g(v, A)), A += 1;
						}
					}
				} else {
					if (2 !== y) {
						throw Error("Unknown charset format " + y);
					}
					for (;l.length <= t;) {
						for (A = C.parseSID(), B = C.parseCard16(), y = 0;B >= y;y += 1) {
							l.push(g(v, A)), A += 1;
						}
					}
				}
			}
			if (0 === p.encoding) {
				b = new x.CffEncoding(x.cffStandardEncoding, l);
			} else {
				if (1 === p.encoding) {
					b = new x.CffEncoding(x.cffExpertEncoding, l);
				} else {
					t = {};
					b = new u.Parser(b, c + p.encoding);
					c = b.parseCard8();
					if (0 === c) {
						for (v = b.parseCard8(), c = 0;v > c;c += 1) {
							p = b.parseCard8(), t[p] = c;
						}
					} else {
						if (1 !== c) {
							throw Error("Unknown encoding format " + c);
						}
						v = b.parseCard8();
						p = 1;
						for (c = 0;v > c;c += 1) {
							for (C = b.parseCard8(), y = b.parseCard8(), A = C;C + y >= A;A += 1) {
								t[A] = p, p += 1;
							}
						}
					}
					b = new x.CffEncoding(t, l);
				}
			}
			f.cffEncoding = b;
			f.encoding = f.encoding || f.cffEncoding;
			f.glyphs = new m.GlyphSet(f);
			for (b = 0;b < f.nGlyphs;b += 1) {
				f.glyphs.push(b, m.cffGlyphLoader(f, b, r, k.objects[b]));
			}
		};
		b.make = function(b, c) {
			for (var e, f = new A.Table("CFF ", [{name:"header", type:"RECORD"}, {name:"nameIndex", type:"RECORD"}, {name:"topDictIndex", type:"RECORD"}, {name:"stringIndex", type:"RECORD"}, {name:"globalSubrIndex", type:"RECORD"}, {name:"charsets", type:"RECORD"}, {name:"charStringsIndex", type:"RECORD"}, {name:"privateDict", type:"RECORD"}]), g = 1 / c.unitsPerEm, g = {version:c.version, fullName:c.fullName, familyName:c.familyName, weight:c.weightName, fontBBox:c.fontBBox || [0, 0, 0, 0], fontMatrix:[g, 
			0, 0, g, 0, 0], charset:999, encoding:0, charStrings:999, "private":[0, 999]}, h = [], k = 1;k < b.length;k += 1) {
				e = b.get(k), h.push(e.name);
			}
			e = [];
			f.header = new A.Record("Header", [{name:"major", type:"Card8", value:1}, {name:"minor", type:"Card8", value:0}, {name:"hdrSize", type:"Card8", value:4}, {name:"major", type:"Card8", value:1}]);
			c = [c.postScriptName];
			k = new A.Record("Name INDEX", [{name:"names", type:"INDEX", value:[]}]);
			k.names = [];
			for (var m = 0;m < c.length;m += 1) {
				k.names.push({name:"name_" + m, type:"NAME", value:c[m]});
			}
			f.nameIndex = k;
			c = v(g, e);
			f.topDictIndex = y(c);
			f.globalSubrIndex = new A.Record("Global Subr INDEX", [{name:"subrs", type:"INDEX", value:[]}]);
			k = new A.Record("Charsets", [{name:"format", type:"Card8", value:0}]);
			for (m = 0;m < h.length;m += 1) {
				var l = p(h[m], e);
				k.fields.push({name:"glyph_" + m, type:"SID", value:l});
			}
			f.charsets = k;
			h = new A.Record("CharStrings INDEX", [{name:"charStrings", type:"INDEX", value:[]}]);
			for (k = 0;k < b.length;k += 1) {
				var m = b.get(k), l = [], q = m.path;
				l.push({name:"width", type:"NUMBER", value:m.advanceWidth});
				for (var r = 0, u = 0, w = 0;w < q.commands.length;w += 1) {
					var x = q.commands[w];
					if ("Q" === x.type) {
						var B = 1 / 3, C = 2 / 3, x = {type:"C", x:x.x, y:x.y, x1:B * r + C * x.x1, y1:B * u + C * x.y1, x2:B * x.x + C * x.x1, y2:B * x.y + C * x.y1}
					}
					if ("M" === x.type) {
						r = Math.round(x.x - r), u = Math.round(x.y - u), l.push({name:"dx", type:"NUMBER", value:r}), l.push({name:"dy", type:"NUMBER", value:u}), l.push({name:"rmoveto", type:"OP", value:21}), r = Math.round(x.x), u = Math.round(x.y);
					} else {
						if ("L" === x.type) {
							r = Math.round(x.x - r), u = Math.round(x.y - u), l.push({name:"dx", type:"NUMBER", value:r}), l.push({name:"dy", type:"NUMBER", value:u}), l.push({name:"rlineto", type:"OP", value:5}), r = Math.round(x.x), u = Math.round(x.y);
						} else {
							if ("C" === x.type) {
								var B = Math.round(x.x1 - r), C = Math.round(x.y1 - u), D = Math.round(x.x2 - x.x1), F = Math.round(x.y2 - x.y1), r = Math.round(x.x - x.x2), u = Math.round(x.y - x.y2);
								l.push({name:"dx1", type:"NUMBER", value:B});
								l.push({name:"dy1", type:"NUMBER", value:C});
								l.push({name:"dx2", type:"NUMBER", value:D});
								l.push({name:"dy2", type:"NUMBER", value:F});
								l.push({name:"dx", type:"NUMBER", value:r});
								l.push({name:"dy", type:"NUMBER", value:u});
								l.push({name:"rrcurveto", type:"OP", value:8});
								r = Math.round(x.x);
								u = Math.round(x.y);
							}
						}
					}
				}
				l = (l.push({name:"endchar", type:"OP", value:14}), l);
				h.charStrings.push({name:m.name, type:"CHARSTRING", value:l});
			}
			f.charStringsIndex = h;
			b = new A.Record("Private DICT", [{name:"dict", type:"DICT", value:{}}]);
			b = (b.dict = t(G, {}, e), b);
			f.privateDict = b;
			b = new A.Record("String INDEX", [{name:"strings", type:"INDEX", value:[]}]);
			b.strings = [];
			for (h = 0;h < e.length;h += 1) {
				b.strings.push({name:"string_" + h, type:"STRING", value:e[h]});
			}
			f.stringIndex = b;
			b = f.header.sizeOf() + f.nameIndex.sizeOf() + f.topDictIndex.sizeOf() + f.stringIndex.sizeOf() + f.globalSubrIndex.sizeOf();
			return g.charset = b, g.encoding = 0, g.charStrings = g.charset + f.charsets.sizeOf(), g.private[1] = g.charStrings + f.charStringsIndex.sizeOf(), c = v(g, e), f.topDictIndex = y(c), f;
		};
	}, {"../encoding":4, "../glyphset":7, "../parse":10, "../path":11, "../table":13}], 15:[function(f, l, b) {
		function k(b, c, e) {
			b.segments.push({end:c, start:c, delta:-(c - e), offset:0});
		}
		var h = f("../check"), c = f("../parse"), e = f("../table");
		b.parse = function(b, e) {
			var f, g = {};
			g.version = c.getUShort(b, e);
			h.argument(0 === g.version, "cmap table version should be 0.");
			g.numTables = c.getUShort(b, e + 2);
			var k = -1;
			for (f = g.numTables - 1;0 <= f;--f) {
				var l = c.getUShort(b, e + 4 + 8 * f), q = c.getUShort(b, e + 4 + 8 * f + 2);
				if (3 === l && (0 === q || 1 === q || 10 === q)) {
					k = c.getULong(b, e + 4 + 8 * f + 4);
					break;
				}
			}
			if (-1 === k) {
				return null;
			}
			f = new c.Parser(b, e + k);
			if (g.format = f.parseUShort(), 12 === g.format) {
				f.parseUShort();
				g.length = f.parseULong();
				g.language = f.parseULong();
				var y;
				g.groupCount = y = f.parseULong();
				g.glyphIndexMap = {};
				for (b = 0;y > b;b += 1) {
					for (q = f.parseULong(), k = f.parseULong(), l = f.parseULong();k >= q;q += 1) {
						g.glyphIndexMap[q] = l, l++;
					}
				}
			} else {
				if (4 !== g.format) {
					throw Error("Only format 4 and 12 cmap tables are supported.");
				}
				var x = k;
				g.length = f.parseUShort();
				g.language = f.parseUShort();
				g.segCount = k = f.parseUShort() >> 1;
				f.skip("uShort", 3);
				g.glyphIndexMap = {};
				f = new c.Parser(b, e + x + 14);
				var l = new c.Parser(b, e + x + 16 + 2 * k), q = new c.Parser(b, e + x + 16 + 4 * k), m = new c.Parser(b, e + x + 16 + 6 * k), x = e + x + 16 + 8 * k;
				for (e = 0;k - 1 > e;e += 1) {
					for (var u = f.parseUShort(), B = l.parseUShort(), A = q.parseShort(), D = m.parseUShort(), G = B;u >= G;G += 1) {
						0 !== D ? (x = m.offset + m.relativeOffset - 2, x += D, x += 2 * (G - B), y = c.getUShort(b, x), 0 !== y && (y = y + A & 65535)) : y = G + A & 65535, g.glyphIndexMap[G] = y;
					}
				}
			}
			return g;
		};
		b.make = function(b) {
			var c, f = new e.Table("cmap", [{name:"version", type:"USHORT", value:0}, {name:"numTables", type:"USHORT", value:1}, {name:"platformID", type:"USHORT", value:3}, {name:"encodingID", type:"USHORT", value:1}, {name:"offset", type:"ULONG", value:12}, {name:"format", type:"USHORT", value:4}, {name:"length", type:"USHORT", value:0}, {name:"language", type:"USHORT", value:0}, {name:"segCountX2", type:"USHORT", value:0}, {name:"searchRange", type:"USHORT", value:0}, {name:"entrySelector", type:"USHORT", 
			value:0}, {name:"rangeShift", type:"USHORT", value:0}]);
			f.segments = [];
			for (c = 0;c < b.length;c += 1) {
				for (var g = b.get(c), h = 0;h < g.unicodes.length;h += 1) {
					k(f, g.unicodes[h], c);
				}
				f.segments = f.segments.sort(function(b, c) {
					return b.start - c.start;
				});
			}
			f.segments.push({end:65535, start:65535, delta:1, offset:0});
			b = f.segments.length;
			f.segCountX2 = 2 * b;
			f.searchRange = 2 * Math.pow(2, Math.floor(Math.log(b) / Math.log(2)));
			f.entrySelector = Math.log(f.searchRange / 2) / Math.log(2);
			f.rangeShift = f.segCountX2 - f.searchRange;
			var g = [], h = [], l = [], v = [], y = [];
			for (c = 0;b > c;c += 1) {
				var x = f.segments[c], g = g.concat({name:"end_" + c, type:"USHORT", value:x.end}), h = h.concat({name:"start_" + c, type:"USHORT", value:x.start}), l = l.concat({name:"idDelta_" + c, type:"SHORT", value:x.delta}), v = v.concat({name:"idRangeOffset_" + c, type:"USHORT", value:x.offset});
				void 0 !== x.glyphId && (y = y.concat({name:"glyph_" + c, type:"USHORT", value:x.glyphId}));
			}
			return f.fields = f.fields.concat(g), f.fields.push({name:"reservedPad", type:"USHORT", value:0}), f.fields = f.fields.concat(h), f.fields = f.fields.concat(l), f.fields = f.fields.concat(v), f.fields = f.fields.concat(y), f.length = 2 * g.length + 16 + 2 * h.length + 2 * l.length + 2 * v.length + 2 * y.length, f;
		};
	}, {"../check":2, "../parse":10, "../table":13}], 16:[function(f, l, b) {
		function k(b, c) {
			var e = JSON.stringify(b), f = 256, g;
			for (g in c) {
				var h = parseInt(g);
				if (h && !(256 > h)) {
					if (JSON.stringify(c[g]) === e) {
						return h;
					}
					h >= f && (f = h + 1);
				}
			}
			return c[f] = b, f;
		}
		function h(b, c, e) {
			e = k(c.name, e);
			return [{name:"tag_" + b, type:"TAG", value:c.tag}, {name:"minValue_" + b, type:"FIXED", value:c.minValue << 16}, {name:"defaultValue_" + b, type:"FIXED", value:c.defaultValue << 16}, {name:"maxValue_" + b, type:"FIXED", value:c.maxValue << 16}, {name:"flags_" + b, type:"USHORT", value:0}, {name:"nameID_" + b, type:"USHORT", value:e}];
		}
		function c(b, c, e) {
			var f = {};
			b = new r.Parser(b, c);
			return f.tag = b.parseTag(), f.minValue = b.parseFixed(), f.defaultValue = b.parseFixed(), f.maxValue = b.parseFixed(), b.skip("uShort", 1), f.name = e[b.parseUShort()] || {}, f;
		}
		function e(b, c, e, f) {
			f = k(c.name, f);
			f = [{name:"nameID_" + b, type:"USHORT", value:f}, {name:"flags_" + b, type:"USHORT", value:0}];
			for (var g = 0;g < e.length;++g) {
				var h = e[g].tag;
				f.push({name:"axis_" + b + " " + h, type:"FIXED", value:c.coordinates[h] << 16});
			}
			return f;
		}
		function g(b, c, e, f) {
			var g = {};
			b = new r.Parser(b, c);
			g.name = f[b.parseUShort()] || {};
			b.skip("uShort", 1);
			g.coordinates = {};
			for (f = 0;f < e.length;++f) {
				g.coordinates[e[f].tag] = b.parseFixed();
			}
			return g;
		}
		var q = f("../check"), r = f("../parse"), w = f("../table");
		b.make = function(b, c) {
			var f = new w.Table("fvar", [{name:"version", type:"ULONG", value:65536}, {name:"offsetToData", type:"USHORT", value:0}, {name:"countSizePairs", type:"USHORT", value:2}, {name:"axisCount", type:"USHORT", value:b.axes.length}, {name:"axisSize", type:"USHORT", value:20}, {name:"instanceCount", type:"USHORT", value:b.instances.length}, {name:"instanceSize", type:"USHORT", value:4 + 4 * b.axes.length}]);
			f.offsetToData = f.sizeOf();
			for (var g = 0;g < b.axes.length;g++) {
				f.fields = f.fields.concat(h(g, b.axes[g], c));
			}
			for (g = 0;g < b.instances.length;g++) {
				f.fields = f.fields.concat(e(g, b.instances[g], b.axes, c));
			}
			return f;
		};
		b.parse = function(b, e, f) {
			var h = new r.Parser(b, e), k = h.parseULong();
			q.argument(65536 === k, "Unsupported fvar table version.");
			var l = h.parseOffset16();
			h.skip("uShort", 1);
			for (var p = h.parseUShort(), t = h.parseUShort(), k = h.parseUShort(), h = h.parseUShort(), v = [], w = 0;p > w;w++) {
				v.push(c(b, e + l + w * t, f));
			}
			w = [];
			e = e + l + p * t;
			for (l = 0;k > l;l++) {
				w.push(g(b, e + l * h, v, f));
			}
			return {axes:v, instances:w};
		};
	}, {"../check":2, "../parse":10, "../table":13}], 17:[function(f, l, b) {
		function k(b, c, e, f, g) {
			var h;
			return 0 < (c & f) ? (h = b.parseByte(), 0 === (c & g) && (h = -h), h = e + h) : h = 0 < (c & g) ? e : e + b.parseShort(), h;
		}
		function h(b, c, e) {
			c = new r.Parser(c, e);
			b.numberOfContours = c.parseShort();
			b._xMin = c.parseShort();
			b._yMin = c.parseShort();
			b._xMax = c.parseShort();
			b._yMax = c.parseShort();
			var f;
			if (0 < b.numberOfContours) {
				var h, l = b.endPointIndices = [];
				for (h = 0;h < b.numberOfContours;h += 1) {
					l.push(c.parseUShort());
				}
				b.instructionLength = c.parseUShort();
				b.instructions = [];
				for (h = 0;h < b.instructionLength;h += 1) {
					b.instructions.push(c.parseByte());
				}
				var p = l[l.length - 1] + 1;
				e = [];
				for (h = 0;p > h;h += 1) {
					if (f = c.parseByte(), e.push(f), 0 < (8 & f)) {
						for (var q = c.parseByte(), t = 0;q > t;t += 1) {
							e.push(f), h += 1;
						}
					}
				}
				if (g.argument(e.length === p, "Bad flags."), 0 < l.length) {
					t = [];
					if (0 < p) {
						for (h = 0;p > h;h += 1) {
							f = e[h], q = {}, q.onCurve = !!(1 & f), q.lastPointOfContour = 0 <= l.indexOf(h), t.push(q);
						}
						for (h = l = 0;p > h;h += 1) {
							f = e[h], q = t[h], q.x = k(c, f, l, 2, 16), l = q.x;
						}
						for (h = l = 0;p > h;h += 1) {
							f = e[h], q = t[h], q.y = k(c, f, l, 4, 32), l = q.y;
						}
					}
					b.points = t;
				} else {
					b.points = [];
				}
			} else {
				if (0 === b.numberOfContours) {
					b.points = [];
				} else {
					for (b.isComposite = !0, b.points = [], b.components = [], f = !0;f;) {
						e = c.parseUShort(), f = {glyphIndex:c.parseUShort(), xScale:1, scale01:0, scale10:0, yScale:1, dx:0, dy:0}, 0 < (1 & e) ? 0 < (2 & e) ? (f.dx = c.parseShort(), f.dy = c.parseShort()) : f.matchedPoints = [c.parseUShort(), c.parseUShort()] : 0 < (2 & e) ? (f.dx = c.parseChar(), f.dy = c.parseChar()) : f.matchedPoints = [c.parseByte(), c.parseByte()], 0 < (8 & e) ? f.xScale = f.yScale = c.parseF2Dot14() : 0 < (64 & e) ? (f.xScale = c.parseF2Dot14(), f.yScale = c.parseF2Dot14()) : 0 < (128 & 
						e) && (f.xScale = c.parseF2Dot14(), f.scale01 = c.parseF2Dot14(), f.scale10 = c.parseF2Dot14(), f.yScale = c.parseF2Dot14()), b.components.push(f), f = !!(32 & e);
					}
				}
			}
		}
		function c(b, c) {
			for (var e = [], f = 0;f < b.length;f += 1) {
				var g = b[f];
				e.push({x:c.xScale * g.x + c.scale01 * g.y + c.dx, y:c.scale10 * g.x + c.yScale * g.y + c.dy, onCurve:g.onCurve, lastPointOfContour:g.lastPointOfContour});
			}
			return e;
		}
		function e(b, e) {
			if (e.isComposite) {
				for (var f = 0;f < e.components.length;f += 1) {
					var h = e.components[f], k = b.get(h.glyphIndex);
					if (k.getPath(), k.points) {
						if (void 0 !== h.matchedPoints) {
							if (h.matchedPoints[0] > e.points.length - 1 || h.matchedPoints[1] > k.points.length - 1) {
								throw Error("Matched points out of range in " + e.name);
							}
							var l = e.points[h.matchedPoints[0]], p = k.points[h.matchedPoints[1]], h = {xScale:h.xScale, scale01:h.scale01, scale10:h.scale10, yScale:h.yScale, dx:0, dy:0}, p = c([p], h)[0];
							h.dx = l.x - p.x;
							h.dy = l.y - p.y;
						}
						k = c(k.points, h);
						e.points = e.points.concat(k);
					}
				}
			}
			var q;
			e = e.points;
			b = new w.Path;
			if (e) {
				f = [];
				k = [];
				for (l = 0;l < e.length;l += 1) {
					p = e[l], k.push(p), p.lastPointOfContour && (f.push(k), k = []);
				}
				e = (g.argument(0 === k.length, "There are still points left in the current contour."), f);
				for (f = 0;f < e.length;f += 1) {
					var r, k = e[f], l = k[0], p = k[k.length - 1];
					l.onCurve ? (q = null, r = !0) : (l = p.onCurve ? p : {x:(l.x + p.x) / 2, y:(l.y + p.y) / 2}, q = l, r = !1);
					b.moveTo(l.x, l.y);
					for (h = r ? 1 : 0;h < k.length;h += 1) {
						var t = k[h], G = 0 === h ? l : k[h - 1];
						if (G.onCurve && t.onCurve) {
							b.lineTo(t.x, t.y);
						} else {
							if (G.onCurve && !t.onCurve) {
								q = t;
							} else {
								if (G.onCurve || t.onCurve) {
									if (G.onCurve || !t.onCurve) {
										throw Error("Invalid state.");
									}
									b.quadraticCurveTo(q.x, q.y, t.x, t.y);
									q = null;
								} else {
									b.quadraticCurveTo(G.x, G.y, (G.x + t.x) / 2, (G.y + t.y) / 2), q = t;
								}
							}
						}
					}
					l !== p && (q ? b.quadraticCurveTo(q.x, q.y, l.x, l.y) : b.lineTo(l.x, l.y));
				}
				q = (b.closePath(), b);
			} else {
				q = b;
			}
			return q;
		}
		var g = f("../check"), q = f("../glyphset"), r = f("../parse"), w = f("../path");
		b.parse = function(b, c, f, g) {
			var k, l = new q.GlyphSet(g);
			for (k = 0;k < f.length - 1;k += 1) {
				var p = f[k];
				p !== f[k + 1] ? l.push(k, q.ttfGlyphLoader(g, k, h, b, c + p, e)) : l.push(k, q.glyphLoader(g, k));
			}
			return l;
		};
	}, {"../check":2, "../glyphset":7, "../parse":10, "../path":11}], 18:[function(f, l, b) {
		function k(b, c) {
			b = new r.Parser(b, c);
			c = b.parseUShort();
			for (var e = [], f = 0;c > f;f++) {
				e[b.parseTag()] = {offset:b.parseUShort()};
			}
			return e;
		}
		function h(b, c) {
			b = new r.Parser(b, c);
			var e = b.parseUShort();
			c = b.parseUShort();
			if (1 === e) {
				return b.parseUShortList(c);
			}
			if (2 === e) {
				for (e = [];c--;) {
					for (var f = b.parseUShort(), g = b.parseUShort(), h = b.parseUShort();g >= f;f++) {
						e[h++] = f;
					}
				}
				return e;
			}
		}
		function c(b, c) {
			b = new r.Parser(b, c);
			c = b.parseUShort();
			if (1 === c) {
				var e = b.parseUShort();
				c = b.parseUShort();
				var f = b.parseUShortList(c);
				return function(b) {
					return f[b - e] || 0;
				};
			}
			if (2 === c) {
				c = b.parseUShort();
				for (var g = [], h = [], k = [], l = 0;c > l;l++) {
					g[l] = b.parseUShort(), h[l] = b.parseUShort(), k[l] = b.parseUShort();
				}
				return function(b) {
					for (var c = 0, e = g.length - 1;e > c;) {
						var f = c + e + 1 >> 1;
						b < g[f] ? e = f - 1 : c = f;
					}
					return g[c] <= b && b <= h[c] ? k[c] || 0 : 0;
				};
			}
		}
		function e(b, e) {
			var f, g = new r.Parser(b, e), k = g.parseUShort(), l = g.parseUShort(), l = h(b, e + l), m = g.parseUShort(), p = g.parseUShort();
			if (4 === m && 0 === p) {
				var q = {};
				if (1 === k) {
					b = g.parseUShort();
					var w = [];
					e = g.parseOffset16List(b);
					for (k = 0;b > k;k++) {
						var D = e[k], G = q[D];
						if (!G) {
							for (G = {}, g.relativeOffset = D, D = g.parseUShort();D--;) {
								var F = g.parseUShort();
								m && (f = g.parseShort());
								p && g.parseShort();
								G[F] = f;
							}
						}
						w[l[k]] = G;
					}
					return function(b, c) {
						return (b = w[b]) ? b[c] : void 0;
					};
				}
				if (2 === k) {
					var G = g.parseUShort(), D = g.parseUShort(), q = g.parseUShort(), k = g.parseUShort(), C = c(b, e + G), J = c(b, e + D), I = [];
					for (b = 0;q > b;b++) {
						for (e = I[b] = [], G = 0;k > G;G++) {
							m && (f = g.parseShort()), p && g.parseShort(), e[G] = f;
						}
					}
					var Q = {};
					for (b = 0;b < l.length;b++) {
						Q[l[b]] = 1;
					}
					return function(b, c) {
						if (Q[b]) {
							return b = C(b), c = J(c), (b = I[b]) ? b[c] : void 0;
						}
					};
				}
			}
		}
		function g(b, c) {
			var f = new r.Parser(b, c), g = f.parseUShort(), h = f.parseUShort(), k = 16 & h, l = f.parseUShort(), p = f.parseOffset16List(l), f = {lookupType:g, lookupFlag:h, markFilteringSet:k ? f.parseUShort() : -1};
			if (2 === g) {
				for (var q = [], g = 0;l > g;g++) {
					q.push(e(b, c + p[g]));
				}
				f.getKerningValue = function(b, c) {
					for (var e = q.length;e--;) {
						var f = q[e](b, c);
						if (void 0 !== f) {
							return f;
						}
					}
					return 0;
				};
			}
			return f;
		}
		var q = f("../check"), r = f("../parse");
		b.parse = function(b, c, e) {
			var f = new r.Parser(b, c), h = f.parseFixed();
			q.argument(1 === h, "Unsupported GPOS table version.");
			k(b, c + f.parseUShort());
			k(b, c + f.parseUShort());
			var l = f.parseUShort();
			f.relativeOffset = l;
			h = f.parseUShort();
			f = f.parseOffset16List(h);
			c += l;
			for (l = 0;h > l;l++) {
				var m = g(b, c + f[l]);
				2 !== m.lookupType || e.getGposKerningValue || (e.getGposKerningValue = m.getKerningValue);
			}
		};
	}, {"../check":2, "../parse":10}], 19:[function(f, l, b) {
		var k = f("../check"), h = f("../parse").Parser, c = Array(9), e = f("../table");
		c[1] = function() {
			var b = this.offset + this.relativeOffset, c = this.parseUShort();
			return 1 === c ? {substFormat:1, coverage:this.parsePointer(h.coverage), deltaGlyphId:this.parseUShort()} : 2 === c ? {substFormat:2, coverage:this.parsePointer(h.coverage), substitute:this.parseOffset16List()} : void k.assert(!1, "0x" + b.toString(16) + ": lookup type 1 format must be 1 or 2.");
		};
		c[2] = function() {
			var b = this.parseUShort();
			return k.argument(1 === b, "GSUB Multiple Substitution Subtable identifier-format must be 1"), {substFormat:b, coverage:this.parsePointer(h.coverage), sequences:this.parseListOfLists()};
		};
		c[3] = function() {
			var b = this.parseUShort();
			return k.argument(1 === b, "GSUB Alternate Substitution Subtable identifier-format must be 1"), {substFormat:b, coverage:this.parsePointer(h.coverage), alternateSets:this.parseListOfLists()};
		};
		c[4] = function() {
			var b = this.parseUShort();
			return k.argument(1 === b, "GSUB ligature table identifier-format must be 1"), {substFormat:b, coverage:this.parsePointer(h.coverage), ligatureSets:this.parseListOfLists(function() {
				return {ligGlyph:this.parseUShort(), components:this.parseUShortList(this.parseUShort() - 1)};
			})};
		};
		var g = {sequenceIndex:h.uShort, lookupListIndex:h.uShort};
		c[5] = function() {
			var b = this.offset + this.relativeOffset, c = this.parseUShort();
			if (1 === c) {
				return {substFormat:c, coverage:this.parsePointer(h.coverage), ruleSets:this.parseListOfLists(function() {
					var b = this.parseUShort(), c = this.parseUShort();
					return {input:this.parseUShortList(b - 1), lookupRecords:this.parseRecordList(c, g)};
				})};
			}
			if (2 === c) {
				return {substFormat:c, coverage:this.parsePointer(h.coverage), classDef:this.parsePointer(h.classDef), classSets:this.parseListOfLists(function() {
					var b = this.parseUShort(), c = this.parseUShort();
					return {classes:this.parseUShortList(b - 1), lookupRecords:this.parseRecordList(c, g)};
				})};
			}
			if (3 === c) {
				var b = this.parseUShort(), e = this.parseUShort();
				return {substFormat:c, coverages:this.parseList(b, h.pointer(h.coverage)), lookupRecords:this.parseRecordList(e, g)};
			}
			k.assert(!1, "0x" + b.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
		};
		c[6] = function() {
			var b = this.offset + this.relativeOffset, c = this.parseUShort();
			return 1 === c ? {substFormat:1, coverage:this.parsePointer(h.coverage), chainRuleSets:this.parseListOfLists(function() {
				return {backtrack:this.parseUShortList(), input:this.parseUShortList(this.parseShort() - 1), lookahead:this.parseUShortList(), lookupRecords:this.parseRecordList(g)};
			})} : 2 === c ? {substFormat:2, coverage:this.parsePointer(h.coverage), backtrackClassDef:this.parsePointer(h.classDef), inputClassDef:this.parsePointer(h.classDef), lookaheadClassDef:this.parsePointer(h.classDef), chainClassSet:this.parseListOfLists(function() {
				return {backtrack:this.parseUShortList(), input:this.parseUShortList(this.parseShort() - 1), lookahead:this.parseUShortList(), lookupRecords:this.parseRecordList(g)};
			})} : 3 === c ? {substFormat:3, backtrackCoverage:this.parseList(h.pointer(h.coverage)), inputCoverage:this.parseList(h.pointer(h.coverage)), lookaheadCoverage:this.parseList(h.pointer(h.coverage)), lookupRecords:this.parseRecordList(g)} : void k.assert(!1, "0x" + b.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
		};
		c[7] = function() {
			var b = this.parseUShort();
			k.argument(1 === b, "GSUB Extension Substitution subtable identifier-format must be 1");
			var b = this.parseUShort(), e = new h(this.data, this.offset + this.parseULong());
			return {substFormat:1, lookupType:b, extension:c[b].call(e)};
		};
		c[8] = function() {
			var b = this.parseUShort();
			return k.argument(1 === b, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), {substFormat:b, coverage:this.parsePointer(h.coverage), backtrackCoverage:this.parseList(h.pointer(h.coverage)), lookaheadCoverage:this.parseList(h.pointer(h.coverage)), substitutes:this.parseUShortList()};
		};
		var q = Array(9);
		q[1] = function(b) {
			return 1 === b.substFormat ? new e.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:1}, {name:"coverage", type:"TABLE", value:new e.Coverage(b.coverage)}, {name:"deltaGlyphID", type:"USHORT", value:b.deltaGlyphId}]) : new e.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:2}, {name:"coverage", type:"TABLE", value:new e.Coverage(b.coverage)}].concat(e.ushortList("substitute", b.substitute)));
		};
		q[3] = function(b) {
			return k.assert(1 === b.substFormat, "Lookup type 3 substFormat must be 1."), new e.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:1}, {name:"coverage", type:"TABLE", value:new e.Coverage(b.coverage)}].concat(e.tableList("altSet", b.alternateSets, function(b) {
				return new e.Table("alternateSetTable", e.ushortList("alternate", b));
			})));
		};
		q[4] = function(b) {
			return k.assert(1 === b.substFormat, "Lookup type 4 substFormat must be 1."), new e.Table("substitutionTable", [{name:"substFormat", type:"USHORT", value:1}, {name:"coverage", type:"TABLE", value:new e.Coverage(b.coverage)}].concat(e.tableList("ligSet", b.ligatureSets, function(b) {
				return new e.Table("ligatureSetTable", e.tableList("ligature", b, function(b) {
					return new e.Table("ligatureTable", [{name:"ligGlyph", type:"USHORT", value:b.ligGlyph}].concat(e.ushortList("component", b.components, b.components.length + 1)));
				}));
			})));
		};
		b.parse = function(b, e) {
			b = new h(b, e || 0);
			e = b.parseVersion();
			return k.argument(1 === e, "Unsupported GSUB table version."), {version:e, scripts:b.parseScriptList(), features:b.parseFeatureList(), lookups:b.parseLookupList(c)};
		};
		b.make = function(b) {
			return new e.Table("GSUB", [{name:"version", type:"ULONG", value:65536}, {name:"scripts", type:"TABLE", value:new e.ScriptList(b.scripts)}, {name:"features", type:"TABLE", value:new e.FeatureList(b.features)}, {name:"lookups", type:"TABLE", value:new e.LookupList(b.lookups, q)}]);
		};
	}, {"../check":2, "../parse":10, "../table":13}], 20:[function(f, l, b) {
		var k = f("../check"), h = f("../parse"), c = f("../table");
		b.parse = function(b, c) {
			var e = {};
			b = new h.Parser(b, c);
			return e.version = b.parseVersion(), e.fontRevision = Math.round(1E3 * b.parseFixed()) / 1E3, e.checkSumAdjustment = b.parseULong(), e.magicNumber = b.parseULong(), k.argument(1594834165 === e.magicNumber, "Font header has wrong magic number."), e.flags = b.parseUShort(), e.unitsPerEm = b.parseUShort(), e.created = b.parseLongDateTime(), e.modified = b.parseLongDateTime(), e.xMin = b.parseShort(), e.yMin = b.parseShort(), e.xMax = b.parseShort(), e.yMax = b.parseShort(), e.macStyle = b.parseUShort(), 
			e.lowestRecPPEM = b.parseUShort(), e.fontDirectionHint = b.parseShort(), e.indexToLocFormat = b.parseShort(), e.glyphDataFormat = b.parseShort(), e;
		};
		b.make = function(b) {
			var e = Math.round((new Date).getTime() / 1E3) + 2082844800, f = e;
			return b.createdTimestamp && (f = b.createdTimestamp + 2082844800), new c.Table("head", [{name:"version", type:"FIXED", value:65536}, {name:"fontRevision", type:"FIXED", value:65536}, {name:"checkSumAdjustment", type:"ULONG", value:0}, {name:"magicNumber", type:"ULONG", value:1594834165}, {name:"flags", type:"USHORT", value:0}, {name:"unitsPerEm", type:"USHORT", value:1E3}, {name:"created", type:"LONGDATETIME", value:f}, {name:"modified", type:"LONGDATETIME", value:e}, {name:"xMin", type:"SHORT", 
			value:0}, {name:"yMin", type:"SHORT", value:0}, {name:"xMax", type:"SHORT", value:0}, {name:"yMax", type:"SHORT", value:0}, {name:"macStyle", type:"USHORT", value:0}, {name:"lowestRecPPEM", type:"USHORT", value:0}, {name:"fontDirectionHint", type:"SHORT", value:2}, {name:"indexToLocFormat", type:"SHORT", value:0}, {name:"glyphDataFormat", type:"SHORT", value:0}], b);
		};
	}, {"../check":2, "../parse":10, "../table":13}], 21:[function(f, l, b) {
		var k = f("../parse"), h = f("../table");
		b.parse = function(b, e) {
			var c = {};
			b = new k.Parser(b, e);
			return c.version = b.parseVersion(), c.ascender = b.parseShort(), c.descender = b.parseShort(), c.lineGap = b.parseShort(), c.advanceWidthMax = b.parseUShort(), c.minLeftSideBearing = b.parseShort(), c.minRightSideBearing = b.parseShort(), c.xMaxExtent = b.parseShort(), c.caretSlopeRise = b.parseShort(), c.caretSlopeRun = b.parseShort(), c.caretOffset = b.parseShort(), b.relativeOffset += 8, c.metricDataFormat = b.parseShort(), c.numberOfHMetrics = b.parseUShort(), c;
		};
		b.make = function(b) {
			return new h.Table("hhea", [{name:"version", type:"FIXED", value:65536}, {name:"ascender", type:"FWORD", value:0}, {name:"descender", type:"FWORD", value:0}, {name:"lineGap", type:"FWORD", value:0}, {name:"advanceWidthMax", type:"UFWORD", value:0}, {name:"minLeftSideBearing", type:"FWORD", value:0}, {name:"minRightSideBearing", type:"FWORD", value:0}, {name:"xMaxExtent", type:"FWORD", value:0}, {name:"caretSlopeRise", type:"SHORT", value:1}, {name:"caretSlopeRun", type:"SHORT", value:0}, {name:"caretOffset", 
			type:"SHORT", value:0}, {name:"reserved1", type:"SHORT", value:0}, {name:"reserved2", type:"SHORT", value:0}, {name:"reserved3", type:"SHORT", value:0}, {name:"reserved4", type:"SHORT", value:0}, {name:"metricDataFormat", type:"SHORT", value:0}, {name:"numberOfHMetrics", type:"USHORT", value:0}], b);
		};
	}, {"../parse":10, "../table":13}], 22:[function(f, l, b) {
		var k = f("../parse"), h = f("../table");
		b.parse = function(b, e, f, h, l) {
			var c, g;
			b = new k.Parser(b, e);
			for (e = 0;h > e;e += 1) {
				f > e && (c = b.parseUShort(), g = b.parseShort());
				var q = l.get(e);
				q.advanceWidth = c;
				q.leftSideBearing = g;
			}
		};
		b.make = function(b) {
			for (var c = new h.Table("hmtx", []), f = 0;f < b.length;f += 1) {
				var k = b.get(f), l = k.leftSideBearing || 0;
				c.fields.push({name:"advanceWidth_" + f, type:"USHORT", value:k.advanceWidth || 0});
				c.fields.push({name:"leftSideBearing_" + f, type:"SHORT", value:l});
			}
			return c;
		};
	}, {"../parse":10, "../table":13}], 23:[function(f, l, b) {
		var k = f("../check"), h = f("../parse");
		b.parse = function(b, e) {
			var c = {};
			b = new h.Parser(b, e);
			e = b.parseUShort();
			k.argument(0 === e, "Unsupported kern table version.");
			b.skip("uShort", 1);
			e = b.parseUShort();
			k.argument(0 === e, "Unsupported kern sub-table version.");
			b.skip("uShort", 2);
			e = b.parseUShort();
			b.skip("uShort", 3);
			for (var f = 0;e > f;f += 1) {
				var l = b.parseUShort(), w = b.parseUShort(), p = b.parseShort();
				c[l + "," + w] = p;
			}
			return c;
		};
	}, {"../check":2, "../parse":10}], 24:[function(f, l, b) {
		var k = f("../parse");
		b.parse = function(b, c, e, f) {
			b = new k.Parser(b, c);
			c = f ? b.parseUShort : b.parseULong;
			for (var g = [], h = 0;e + 1 > h;h += 1) {
				var l = c.call(b);
				f && (l *= 2);
				g.push(l);
			}
			return g;
		};
	}, {"../parse":10}], 25:[function(f, l, b) {
		var k = f("../check"), h = f("../parse"), c = f("../table");
		b.make = function(b) {
			for (var e = new c.Table("ltag", [{name:"version", type:"ULONG", value:1}, {name:"flags", type:"ULONG", value:0}, {name:"numTags", type:"ULONG", value:b.length}]), f = "", h = 12 + 4 * b.length, k = 0;k < b.length;++k) {
				var l = f.indexOf(b[k]);
				0 > l && (l = f.length, f += b[k]);
				e.fields.push({name:"offset " + k, type:"USHORT", value:h + l});
				e.fields.push({name:"length " + k, type:"USHORT", value:b[k].length});
			}
			return e.fields.push({name:"stringPool", type:"CHARARRAY", value:f}), e;
		};
		b.parse = function(b, c) {
			var e = new h.Parser(b, c), f = e.parseULong();
			k.argument(1 === f, "Unsupported ltag table version.");
			e.skip("uLong", 1);
			for (var f = e.parseULong(), g = [], l = 0;f > l;l++) {
				for (var t = "", v = c + e.parseUShort(), y = e.parseUShort(), x = v;v + y > x;++x) {
					t += String.fromCharCode(b.getInt8(x));
				}
				g.push(t);
			}
			return g;
		};
	}, {"../check":2, "../parse":10, "../table":13}], 26:[function(f, l, b) {
		var k = f("../parse"), h = f("../table");
		b.parse = function(b, e) {
			var c = {};
			b = new k.Parser(b, e);
			return c.version = b.parseVersion(), c.numGlyphs = b.parseUShort(), 1 === c.version && (c.maxPoints = b.parseUShort(), c.maxContours = b.parseUShort(), c.maxCompositePoints = b.parseUShort(), c.maxCompositeContours = b.parseUShort(), c.maxZones = b.parseUShort(), c.maxTwilightPoints = b.parseUShort(), c.maxStorage = b.parseUShort(), c.maxFunctionDefs = b.parseUShort(), c.maxInstructionDefs = b.parseUShort(), c.maxStackElements = b.parseUShort(), c.maxSizeOfInstructions = b.parseUShort(), c.maxComponentElements = 
			b.parseUShort(), c.maxComponentDepth = b.parseUShort()), c;
		};
		b.make = function(b) {
			return new h.Table("maxp", [{name:"version", type:"FIXED", value:20480}, {name:"numGlyphs", type:"USHORT", value:b}]);
		};
	}, {"../parse":10, "../table":13}], 27:[function(f, l, b) {
		var k = f("../types").decode, h = f("../check"), c = f("../parse"), e = f("../table");
		b.parse = function(b, e) {
			var f = new c.Parser(b, e), g = f.parseULong();
			h.argument(1 === g, "Unsupported META table version.");
			f.parseULong();
			f.parseULong();
			for (var g = f.parseULong(), l = {}, q = 0;g > q;q++) {
				var v = f.parseTag(), y = f.parseULong(), x = f.parseULong(), y = k.UTF8(b, e + y, x);
				l[v] = y;
			}
			return l;
		};
		b.make = function(b) {
			var c = Object.keys(b).length, f = "", g = 16 + 12 * c, c = new e.Table("meta", [{name:"version", type:"ULONG", value:1}, {name:"flags", type:"ULONG", value:0}, {name:"offset", type:"ULONG", value:g}, {name:"numTags", type:"ULONG", value:c}]), h;
			for (h in b) {
				var k = f.length, f = f + b[h];
				c.fields.push({name:"tag " + h, type:"TAG", value:h});
				c.fields.push({name:"offset " + h, type:"ULONG", value:g + k});
				c.fields.push({name:"length " + h, type:"ULONG", value:b[h].length});
			}
			return c.fields.push({name:"stringPool", type:"CHARARRAY", value:f}), c;
		};
	}, {"../check":2, "../parse":10, "../table":13, "../types":32}], 28:[function(f, l, b) {
		function k(b, c, e) {
			switch(b) {
				case 0:
					return x;
				case 1:
					return u[e] || m[c];
				case 3:
					if (1 === c || 10 === c) {
						return x;
					}
				;
			}
		}
		function h(b) {
			var c = {}, e;
			for (e in b) {
				c[b[e]] = parseInt(e);
			}
			return c;
		}
		function c(b, c, e, f, g, h) {
			return new w.Record("NameRecord", [{name:"platformID", type:"USHORT", value:b}, {name:"encodingID", type:"USHORT", value:c}, {name:"languageID", type:"USHORT", value:e}, {name:"nameID", type:"USHORT", value:f}, {name:"length", type:"USHORT", value:g}, {name:"offset", type:"USHORT", value:h}]);
		}
		function e(b, c) {
			var e;
			a: {
				e = b.length;
				var f = c.length - e + 1, g = 0;
				b: for (;f > g;g++) {
					for (;f > g;) {
						for (var h = 0;e > h;h++) {
							if (c[g + h] !== b[h]) {
								continue b;
							}
						}
						e = g;
						break a;
					}
				}
				e = -1;
			}
			if (0 > e) {
				for (e = c.length, f = 0, g = b.length;g > f;++f) {
					c.push(b[f]);
				}
			}
			return e;
		}
		l = f("../types");
		var g = l.decode, q = l.encode, r = f("../parse"), w = f("../table"), p = "copyright fontFamily fontSubfamily uniqueID fullName version postScriptName trademark manufacturer designer description manufacturerURL designerURL license licenseURL reserved preferredFamily preferredSubfamily compatibleFullName sampleText postScriptFindFontName wwsFamily wwsSubfamily".split(" "), t = {0:"en", 1:"fr", 2:"de", 3:"it", 4:"nl", 5:"sv", 6:"es", 7:"da", 8:"pt", 9:"no", 10:"he", 11:"ja", 12:"ar", 13:"fi", 14:"el", 
		15:"is", 16:"mt", 17:"tr", 18:"hr", 19:"zh-Hant", 20:"ur", 21:"hi", 22:"th", 23:"ko", 24:"lt", 25:"pl", 26:"hu", 27:"es", 28:"lv", 29:"se", 30:"fo", 31:"fa", 32:"ru", 33:"zh", 34:"nl-BE", 35:"ga", 36:"sq", 37:"ro", 38:"cz", 39:"sk", 40:"si", 41:"yi", 42:"sr", 43:"mk", 44:"bg", 45:"uk", 46:"be", 47:"uz", 48:"kk", 49:"az-Cyrl", 50:"az-Arab", 51:"hy", 52:"ka", 53:"mo", 54:"ky", 55:"tg", 56:"tk", 57:"mn-CN", 58:"mn", 59:"ps", 60:"ks", 61:"ku", 62:"sd", 63:"bo", 64:"ne", 65:"sa", 66:"mr", 67:"bn", 
		68:"as", 69:"gu", 70:"pa", 71:"or", 72:"ml", 73:"kn", 74:"ta", 75:"te", 76:"si", 77:"my", 78:"km", 79:"lo", 80:"vi", 81:"id", 82:"tl", 83:"ms", 84:"ms-Arab", 85:"am", 86:"ti", 87:"om", 88:"so", 89:"sw", 90:"rw", 91:"rn", 92:"ny", 93:"mg", 94:"eo", 128:"cy", 129:"eu", 130:"ca", 131:"la", 132:"qu", 133:"gn", 134:"ay", 135:"tt", 136:"ug", 137:"dz", 138:"jv", 139:"su", 140:"gl", 141:"af", 142:"br", 143:"iu", 144:"gd", 145:"gv", 146:"ga", 147:"to", 148:"el-polyton", 149:"kl", 150:"az", 151:"nn"}, 
		v = {0:0, 1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0, 8:0, 9:0, 10:5, 11:1, 12:4, 13:0, 14:6, 15:0, 16:0, 17:0, 18:0, 19:2, 20:4, 21:9, 22:21, 23:3, 24:29, 25:29, 26:29, 27:29, 28:29, 29:0, 30:0, 31:4, 32:7, 33:25, 34:0, 35:0, 36:0, 37:0, 38:29, 39:29, 40:0, 41:5, 42:7, 43:7, 44:7, 45:7, 46:7, 47:7, 48:7, 49:7, 50:4, 51:24, 52:23, 53:7, 54:7, 55:7, 56:7, 57:27, 58:7, 59:4, 60:4, 61:4, 62:4, 63:26, 64:9, 65:9, 66:9, 67:13, 68:13, 69:11, 70:10, 71:12, 72:17, 73:16, 74:14, 75:15, 76:18, 77:19, 78:20, 79:22, 
		80:30, 81:0, 82:0, 83:0, 84:4, 85:28, 86:28, 87:28, 88:0, 89:0, 90:0, 91:0, 92:0, 93:0, 94:0, 128:0, 129:0, 130:0, 131:0, 132:0, 133:0, 134:0, 135:7, 136:4, 137:26, 138:0, 139:0, 140:0, 141:0, 142:0, 143:28, 144:0, 145:0, 146:0, 147:0, 148:6, 149:0, 150:0, 151:0}, y = {1078:"af", 1052:"sq", 1156:"gsw", 1118:"am", 5121:"ar-DZ", 15361:"ar-BH", 3073:"ar", 2049:"ar-IQ", 11265:"ar-JO", 13313:"ar-KW", 12289:"ar-LB", 4097:"ar-LY", 6145:"ary", 8193:"ar-OM", 16385:"ar-QA", 1025:"ar-SA", 10241:"ar-SY", 
		7169:"aeb", 14337:"ar-AE", 9217:"ar-YE", 1067:"hy", 1101:"as", 2092:"az-Cyrl", 1068:"az", 1133:"ba", 1069:"eu", 1059:"be", 2117:"bn", 1093:"bn-IN", 8218:"bs-Cyrl", 5146:"bs", 1150:"br", 1026:"bg", 1027:"ca", 3076:"zh-HK", 5124:"zh-MO", 2052:"zh", 4100:"zh-SG", 1028:"zh-TW", 1155:"co", 1050:"hr", 4122:"hr-BA", 1029:"cs", 1030:"da", 1164:"prs", 1125:"dv", 2067:"nl-BE", 1043:"nl", 3081:"en-AU", 10249:"en-BZ", 4105:"en-CA", 9225:"en-029", 16393:"en-IN", 6153:"en-IE", 8201:"en-JM", 17417:"en-MY", 
		5129:"en-NZ", 13321:"en-PH", 18441:"en-SG", 7177:"en-ZA", 11273:"en-TT", 2057:"en-GB", 1033:"en", 12297:"en-ZW", 1061:"et", 1080:"fo", 1124:"fil", 1035:"fi", 2060:"fr-BE", 3084:"fr-CA", 1036:"fr", 5132:"fr-LU", 6156:"fr-MC", 4108:"fr-CH", 1122:"fy", 1110:"gl", 1079:"ka", 3079:"de-AT", 1031:"de", 5127:"de-LI", 4103:"de-LU", 2055:"de-CH", 1032:"el", 1135:"kl", 1095:"gu", 1128:"ha", 1037:"he", 1081:"hi", 1038:"hu", 1039:"is", 1136:"ig", 1057:"id", 1117:"iu", 2141:"iu-Latn", 2108:"ga", 1076:"xh", 
		1077:"zu", 1040:"it", 2064:"it-CH", 1041:"ja", 1099:"kn", 1087:"kk", 1107:"km", 1158:"quc", 1159:"rw", 1089:"sw", 1111:"kok", 1042:"ko", 1088:"ky", 1108:"lo", 1062:"lv", 1063:"lt", 2094:"dsb", 1134:"lb", 1071:"mk", 2110:"ms-BN", 1086:"ms", 1100:"ml", 1082:"mt", 1153:"mi", 1146:"arn", 1102:"mr", 1148:"moh", 1104:"mn", 2128:"mn-CN", 1121:"ne", 1044:"nb", 2068:"nn", 1154:"oc", 1096:"or", 1123:"ps", 1045:"pl", 1046:"pt", 2070:"pt-PT", 1094:"pa", 1131:"qu-BO", 2155:"qu-EC", 3179:"qu", 1048:"ro", 1047:"rm", 
		1049:"ru", 9275:"smn", 4155:"smj-NO", 5179:"smj", 3131:"se-FI", 1083:"se", 2107:"se-SE", 8251:"sms", 6203:"sma-NO", 7227:"sms", 1103:"sa", 7194:"sr-Cyrl-BA", 3098:"sr", 6170:"sr-Latn-BA", 2074:"sr-Latn", 1132:"nso", 1074:"tn", 1115:"si", 1051:"sk", 1060:"sl", 11274:"es-AR", 16394:"es-BO", 13322:"es-CL", 9226:"es-CO", 5130:"es-CR", 7178:"es-DO", 12298:"es-EC", 17418:"es-SV", 4106:"es-GT", 18442:"es-HN", 2058:"es-MX", 19466:"es-NI", 6154:"es-PA", 15370:"es-PY", 10250:"es-PE", 20490:"es-PR", 3082:"es", 
		1034:"es", 21514:"es-US", 14346:"es-UY", 8202:"es-VE", 2077:"sv-FI", 1053:"sv", 1114:"syr", 1064:"tg", 2143:"tzm", 1097:"ta", 1092:"tt", 1098:"te", 1054:"th", 1105:"bo", 1055:"tr", 1090:"tk", 1152:"ug", 1058:"uk", 1070:"hsb", 1056:"ur", 2115:"uz-Cyrl", 1091:"uz", 1066:"vi", 1106:"cy", 1160:"wo", 1157:"sah", 1144:"ii", 1130:"yo"}, x = "utf-16", m = {0:"macintosh", 1:"x-mac-japanese", 2:"x-mac-chinesetrad", 3:"x-mac-korean", 6:"x-mac-greek", 7:"x-mac-cyrillic", 9:"x-mac-devanagai", 10:"x-mac-gurmukhi", 
		11:"x-mac-gujarati", 12:"x-mac-oriya", 13:"x-mac-bengali", 14:"x-mac-tamil", 15:"x-mac-telugu", 16:"x-mac-kannada", 17:"x-mac-malayalam", 18:"x-mac-sinhalese", 19:"x-mac-burmese", 20:"x-mac-khmer", 21:"x-mac-thai", 22:"x-mac-lao", 23:"x-mac-georgian", 24:"x-mac-armenian", 25:"x-mac-chinesesimp", 26:"x-mac-tibetan", 27:"x-mac-mongolian", 28:"x-mac-ethiopic", 29:"x-mac-ce", 30:"x-mac-vietnamese", 31:"x-mac-extarabic"}, u = {15:"x-mac-icelandic", 17:"x-mac-turkish", 18:"x-mac-croatian", 24:"x-mac-ce", 
		25:"x-mac-ce", 26:"x-mac-ce", 27:"x-mac-ce", 28:"x-mac-ce", 30:"x-mac-icelandic", 37:"x-mac-romanian", 38:"x-mac-ce", 39:"x-mac-ce", 40:"x-mac-ce", 143:"x-mac-inuit", 146:"x-mac-gaelic"};
		b.parse = function(b, c, e) {
			var f = {};
			c = new r.Parser(b, c);
			for (var h = c.parseUShort(), l = c.parseUShort(), m = c.offset + c.parseUShort(), q = 0;l > q;q++) {
				var u = c.parseUShort(), v = c.parseUShort(), w = c.parseUShort(), A = c.parseUShort(), A = p[A] || A, B = c.parseUShort(), D = c.parseUShort(), ha;
				a: {
					switch(u) {
						case 0:
							if (65535 === w) {
								ha = "und";
								break a;
							}
							if (e) {
								ha = e[w];
								break a;
							}
							break;
						case 1:
							ha = t[w];
							break a;
						case 3:
							ha = y[w];
							break a;
					}
					ha = void 0;
				}
				u = k(u, v, w);
				void 0 !== u && void 0 !== ha && (u = u === x ? g.UTF16(b, m + D, B) : g.MACSTRING(b, m + D, B, u)) && (v = f[A], void 0 === v && (v = f[A] = {}), v[ha] = u);
			}
			return 1 === h && c.parseUShort(), f;
		};
		b.make = function(b, f) {
			var g, l = [], m = {}, r = h(p), u;
			for (u in b) {
				var x = r[u];
				if (void 0 === x && (x = u), g = parseInt(x), isNaN(g)) {
					throw Error('Name table entry "' + u + '" does not exist, see nameTableNames for complete list.');
				}
				m[g] = b[u];
				l.push(g);
			}
			u = h(t);
			x = h(y);
			b = [];
			for (var r = [], A = 0;A < l.length;A++) {
				g = l[A];
				var B = m[g], N;
				for (N in B) {
					var R = B[N], H = 1, ba = u[N], ha = v[ba], Y = k(H, ha, ba), Y = q.MACSTRING(R, Y);
					void 0 === Y && (H = 0, ba = f.indexOf(N), 0 > ba && (ba = f.length, f.push(N)), ha = 4, Y = q.UTF16(R));
					var ga = e(Y, r);
					b.push(c(H, ha, ba, g, Y.length, ga));
					H = x[N];
					void 0 !== H && (R = q.UTF16(R), ba = e(R, r), b.push(c(3, 1, H, g, R.length, ba)));
				}
			}
			b.sort(function(b, c) {
				return b.platformID - c.platformID || b.encodingID - c.encodingID || b.languageID - c.languageID || b.nameID - c.nameID;
			});
			f = new w.Table("name", [{name:"format", type:"USHORT", value:0}, {name:"count", type:"USHORT", value:b.length}, {name:"stringOffset", type:"USHORT", value:6 + 12 * b.length}]);
			for (g = 0;g < b.length;g++) {
				f.fields.push({name:"record_" + g, type:"RECORD", value:b[g]});
			}
			return f.fields.push({name:"strings", type:"LITERAL", value:r}), f;
		};
	}, {"../parse":10, "../table":13, "../types":32}], 29:[function(f, l, b) {
		var k = f("../parse"), h = f("../table"), c = [{begin:0, end:127}, {begin:128, end:255}, {begin:256, end:383}, {begin:384, end:591}, {begin:592, end:687}, {begin:688, end:767}, {begin:768, end:879}, {begin:880, end:1023}, {begin:11392, end:11519}, {begin:1024, end:1279}, {begin:1328, end:1423}, {begin:1424, end:1535}, {begin:42240, end:42559}, {begin:1536, end:1791}, {begin:1984, end:2047}, {begin:2304, end:2431}, {begin:2432, end:2559}, {begin:2560, end:2687}, {begin:2688, end:2815}, {begin:2816, 
		end:2943}, {begin:2944, end:3071}, {begin:3072, end:3199}, {begin:3200, end:3327}, {begin:3328, end:3455}, {begin:3584, end:3711}, {begin:3712, end:3839}, {begin:4256, end:4351}, {begin:6912, end:7039}, {begin:4352, end:4607}, {begin:7680, end:7935}, {begin:7936, end:8191}, {begin:8192, end:8303}, {begin:8304, end:8351}, {begin:8352, end:8399}, {begin:8400, end:8447}, {begin:8448, end:8527}, {begin:8528, end:8591}, {begin:8592, end:8703}, {begin:8704, end:8959}, {begin:8960, end:9215}, {begin:9216, 
		end:9279}, {begin:9280, end:9311}, {begin:9312, end:9471}, {begin:9472, end:9599}, {begin:9600, end:9631}, {begin:9632, end:9727}, {begin:9728, end:9983}, {begin:9984, end:10175}, {begin:12288, end:12351}, {begin:12352, end:12447}, {begin:12448, end:12543}, {begin:12544, end:12591}, {begin:12592, end:12687}, {begin:43072, end:43135}, {begin:12800, end:13055}, {begin:13056, end:13311}, {begin:44032, end:55215}, {begin:55296, end:57343}, {begin:67840, end:67871}, {begin:19968, end:40959}, {begin:57344, 
		end:63743}, {begin:12736, end:12783}, {begin:64256, end:64335}, {begin:64336, end:65023}, {begin:65056, end:65071}, {begin:65040, end:65055}, {begin:65104, end:65135}, {begin:65136, end:65279}, {begin:65280, end:65519}, {begin:65520, end:65535}, {begin:3840, end:4095}, {begin:1792, end:1871}, {begin:1920, end:1983}, {begin:3456, end:3583}, {begin:4096, end:4255}, {begin:4608, end:4991}, {begin:5024, end:5119}, {begin:5120, end:5759}, {begin:5760, end:5791}, {begin:5792, end:5887}, {begin:6016, 
		end:6143}, {begin:6144, end:6319}, {begin:10240, end:10495}, {begin:40960, end:42127}, {begin:5888, end:5919}, {begin:66304, end:66351}, {begin:66352, end:66383}, {begin:66560, end:66639}, {begin:118784, end:119039}, {begin:119808, end:120831}, {begin:1044480, end:1048573}, {begin:65024, end:65039}, {begin:917504, end:917631}, {begin:6400, end:6479}, {begin:6480, end:6527}, {begin:6528, end:6623}, {begin:6656, end:6687}, {begin:11264, end:11359}, {begin:11568, end:11647}, {begin:19904, end:19967}, 
		{begin:43008, end:43055}, {begin:65536, end:65663}, {begin:65856, end:65935}, {begin:66432, end:66463}, {begin:66464, end:66527}, {begin:66640, end:66687}, {begin:66688, end:66735}, {begin:67584, end:67647}, {begin:68096, end:68191}, {begin:119552, end:119647}, {begin:73728, end:74751}, {begin:119648, end:119679}, {begin:7040, end:7103}, {begin:7168, end:7247}, {begin:7248, end:7295}, {begin:43136, end:43231}, {begin:43264, end:43311}, {begin:43312, end:43359}, {begin:43520, end:43615}, {begin:65936, 
		end:65999}, {begin:66E3, end:66047}, {begin:66208, end:66271}, {begin:127024, end:127135}];
		b.unicodeRanges = c;
		b.getUnicodeRange = function(b) {
			for (var e = 0;e < c.length;e += 1) {
				var f = c[e];
				if (b >= f.begin && b < f.end) {
					return e;
				}
			}
			return -1;
		};
		b.parse = function(b, c) {
			var e = {};
			b = new k.Parser(b, c);
			e.version = b.parseUShort();
			e.xAvgCharWidth = b.parseShort();
			e.usWeightClass = b.parseUShort();
			e.usWidthClass = b.parseUShort();
			e.fsType = b.parseUShort();
			e.ySubscriptXSize = b.parseShort();
			e.ySubscriptYSize = b.parseShort();
			e.ySubscriptXOffset = b.parseShort();
			e.ySubscriptYOffset = b.parseShort();
			e.ySuperscriptXSize = b.parseShort();
			e.ySuperscriptYSize = b.parseShort();
			e.ySuperscriptXOffset = b.parseShort();
			e.ySuperscriptYOffset = b.parseShort();
			e.yStrikeoutSize = b.parseShort();
			e.yStrikeoutPosition = b.parseShort();
			e.sFamilyClass = b.parseShort();
			e.panose = [];
			for (c = 0;10 > c;c++) {
				e.panose[c] = b.parseByte();
			}
			return e.ulUnicodeRange1 = b.parseULong(), e.ulUnicodeRange2 = b.parseULong(), e.ulUnicodeRange3 = b.parseULong(), e.ulUnicodeRange4 = b.parseULong(), e.achVendID = String.fromCharCode(b.parseByte(), b.parseByte(), b.parseByte(), b.parseByte()), e.fsSelection = b.parseUShort(), e.usFirstCharIndex = b.parseUShort(), e.usLastCharIndex = b.parseUShort(), e.sTypoAscender = b.parseShort(), e.sTypoDescender = b.parseShort(), e.sTypoLineGap = b.parseShort(), e.usWinAscent = b.parseUShort(), e.usWinDescent = 
			b.parseUShort(), 1 <= e.version && (e.ulCodePageRange1 = b.parseULong(), e.ulCodePageRange2 = b.parseULong()), 2 <= e.version && (e.sxHeight = b.parseShort(), e.sCapHeight = b.parseShort(), e.usDefaultChar = b.parseUShort(), e.usBreakChar = b.parseUShort(), e.usMaxContent = b.parseUShort()), e;
		};
		b.make = function(b) {
			return new h.Table("OS/2", [{name:"version", type:"USHORT", value:3}, {name:"xAvgCharWidth", type:"SHORT", value:0}, {name:"usWeightClass", type:"USHORT", value:0}, {name:"usWidthClass", type:"USHORT", value:0}, {name:"fsType", type:"USHORT", value:0}, {name:"ySubscriptXSize", type:"SHORT", value:650}, {name:"ySubscriptYSize", type:"SHORT", value:699}, {name:"ySubscriptXOffset", type:"SHORT", value:0}, {name:"ySubscriptYOffset", type:"SHORT", value:140}, {name:"ySuperscriptXSize", type:"SHORT", 
			value:650}, {name:"ySuperscriptYSize", type:"SHORT", value:699}, {name:"ySuperscriptXOffset", type:"SHORT", value:0}, {name:"ySuperscriptYOffset", type:"SHORT", value:479}, {name:"yStrikeoutSize", type:"SHORT", value:49}, {name:"yStrikeoutPosition", type:"SHORT", value:258}, {name:"sFamilyClass", type:"SHORT", value:0}, {name:"bFamilyType", type:"BYTE", value:0}, {name:"bSerifStyle", type:"BYTE", value:0}, {name:"bWeight", type:"BYTE", value:0}, {name:"bProportion", type:"BYTE", value:0}, {name:"bContrast", 
			type:"BYTE", value:0}, {name:"bStrokeVariation", type:"BYTE", value:0}, {name:"bArmStyle", type:"BYTE", value:0}, {name:"bLetterform", type:"BYTE", value:0}, {name:"bMidline", type:"BYTE", value:0}, {name:"bXHeight", type:"BYTE", value:0}, {name:"ulUnicodeRange1", type:"ULONG", value:0}, {name:"ulUnicodeRange2", type:"ULONG", value:0}, {name:"ulUnicodeRange3", type:"ULONG", value:0}, {name:"ulUnicodeRange4", type:"ULONG", value:0}, {name:"achVendID", type:"CHARARRAY", value:"XXXX"}, {name:"fsSelection", 
			type:"USHORT", value:0}, {name:"usFirstCharIndex", type:"USHORT", value:0}, {name:"usLastCharIndex", type:"USHORT", value:0}, {name:"sTypoAscender", type:"SHORT", value:0}, {name:"sTypoDescender", type:"SHORT", value:0}, {name:"sTypoLineGap", type:"SHORT", value:0}, {name:"usWinAscent", type:"USHORT", value:0}, {name:"usWinDescent", type:"USHORT", value:0}, {name:"ulCodePageRange1", type:"ULONG", value:0}, {name:"ulCodePageRange2", type:"ULONG", value:0}, {name:"sxHeight", type:"SHORT", value:0}, 
			{name:"sCapHeight", type:"SHORT", value:0}, {name:"usDefaultChar", type:"USHORT", value:0}, {name:"usBreakChar", type:"USHORT", value:0}, {name:"usMaxContext", type:"USHORT", value:0}], b);
		};
	}, {"../parse":10, "../table":13}], 30:[function(f, l, b) {
		var k = f("../encoding"), h = f("../parse"), c = f("../table");
		b.parse = function(b, c) {
			var e = {};
			c = new h.Parser(b, c);
			switch(e.version = c.parseVersion(), e.italicAngle = c.parseFixed(), e.underlinePosition = c.parseShort(), e.underlineThickness = c.parseShort(), e.isFixedPitch = c.parseULong(), e.minMemType42 = c.parseULong(), e.maxMemType42 = c.parseULong(), e.minMemType1 = c.parseULong(), e.maxMemType1 = c.parseULong(), e.version) {
				case 1:
					e.names = k.standardNames.slice();
					break;
				case 2:
					e.numberOfGlyphs = c.parseUShort();
					e.glyphNameIndex = Array(e.numberOfGlyphs);
					for (b = 0;b < e.numberOfGlyphs;b++) {
						e.glyphNameIndex[b] = c.parseUShort();
					}
					e.names = [];
					for (b = 0;b < e.numberOfGlyphs;b++) {
						if (e.glyphNameIndex[b] >= k.standardNames.length) {
							var f = c.parseChar();
							e.names.push(c.parseString(f));
						}
					}
					break;
				case 2.5:
					for (e.numberOfGlyphs = c.parseUShort(), e.offset = Array(e.numberOfGlyphs), b = 0;b < e.numberOfGlyphs;b++) {
						e.offset[b] = c.parseChar();
					}
				;
			}
			return e;
		};
		b.make = function() {
			return new c.Table("post", [{name:"version", type:"FIXED", value:196608}, {name:"italicAngle", type:"FIXED", value:0}, {name:"underlinePosition", type:"FWORD", value:0}, {name:"underlineThickness", type:"FWORD", value:0}, {name:"isFixedPitch", type:"ULONG", value:0}, {name:"minMemType42", type:"ULONG", value:0}, {name:"maxMemType42", type:"ULONG", value:0}, {name:"minMemType1", type:"ULONG", value:0}, {name:"maxMemType1", type:"ULONG", value:0}]);
		};
	}, {"../encoding":4, "../parse":10, "../table":13}], 31:[function(f, l, b) {
		function k(b) {
			for (;0 !== b.length % 4;) {
				b.push(0);
			}
			for (var c = 0, e = 0;e < b.length;e += 4) {
				c += (b[e] << 24) + (b[e + 1] << 16) + (b[e + 2] << 8) + b[e + 3];
			}
			return c % Math.pow(2, 32);
		}
		function h(b, c, e, f) {
			return new q.Record("Table Record", [{name:"tag", type:"TAG", value:void 0 !== b ? b : ""}, {name:"checkSum", type:"ULONG", value:void 0 !== c ? c : 0}, {name:"offset", type:"ULONG", value:void 0 !== e ? e : 0}, {name:"length", type:"ULONG", value:void 0 !== f ? f : 0}]);
		}
		function c(b) {
			var c = new q.Table("sfnt", [{name:"version", type:"TAG", value:"OTTO"}, {name:"numTables", type:"USHORT", value:0}, {name:"searchRange", type:"USHORT", value:0}, {name:"entrySelector", type:"USHORT", value:0}, {name:"rangeShift", type:"USHORT", value:0}]);
			c.tables = b;
			c.numTables = b.length;
			var e = Math.pow(2, Math.log(c.numTables) / Math.log(2) | 0);
			c.searchRange = 16 * e;
			c.entrySelector = Math.log(e) / Math.log(2) | 0;
			c.rangeShift = 16 * c.numTables - c.searchRange;
			for (var e = [], f = [], l = c.sizeOf() + h().sizeOf() * c.numTables;0 !== l % 4;) {
				l += 1, f.push({name:"padding", type:"BYTE", value:0});
			}
			for (var m = 0;m < b.length;m += 1) {
				var p = b[m];
				g.argument(4 === p.tableName.length, "Table name" + p.tableName + " is invalid.");
				var r = p.sizeOf(), t = h(p.tableName, k(p.encode()), l, r);
				e.push({name:t.tag + " Table Record", type:"RECORD", value:t});
				f.push({name:p.tableName + " table", type:"RECORD", value:p});
				l += r;
				for (g.argument(!isNaN(l), "Something went wrong calculating the offset.");0 !== l % 4;) {
					l += 1, f.push({name:"padding", type:"BYTE", value:0});
				}
			}
			return e.sort(function(b, c) {
				return b.value.tag > c.value.tag ? 1 : -1;
			}), c.fields = c.fields.concat(e), c.fields = c.fields.concat(f), c;
		}
		function e(b, c, e) {
			for (var f = 0;f < c.length;f += 1) {
				var g = b.charToGlyphIndex(c[f]);
				if (0 < g) {
					return b.glyphs.get(g).getMetrics();
				}
			}
			return e;
		}
		var g = f("../check"), q = f("../table"), r = f("./cmap"), w = f("./cff"), p = f("./head"), t = f("./hhea"), v = f("./hmtx"), y = f("./ltag"), x = f("./maxp"), m = f("./name"), u = f("./os2"), B = f("./post"), A = f("./gsub"), D = f("./meta");
		b.computeCheckSum = k;
		b.make = c;
		b.fontToTable = function(b) {
			for (var f, g = [], h = [], l = [], q = [], G = [], N = [], R = [], H = 0, ba = 0, ha = 0, Y = 0, ga = 0, S = 0;S < b.glyphs.length;S += 1) {
				var V = b.glyphs.get(S), L = 0 | V.unicode;
				if (isNaN(V.advanceWidth)) {
					throw Error("Glyph " + V.name + " (" + S + "): advanceWidth is not a number.");
				}
				(f > L || void 0 === f) && 0 < L && (f = L);
				L > H && (H = L);
				L = u.getUnicodeRange(L);
				if (32 > L) {
					ba |= 1 << L;
				} else {
					if (64 > L) {
						ha |= 1 << L - 32;
					} else {
						if (96 > L) {
							Y |= 1 << L - 64;
						} else {
							if (!(123 > L)) {
								throw Error("Unicode ranges bits > 123 are reserved for internal usage");
							}
							ga |= 1 << L - 96;
						}
					}
				}
				".notdef" !== V.name && (L = V.getMetrics(), g.push(L.xMin), h.push(L.yMin), l.push(L.xMax), q.push(L.yMax), N.push(L.leftSideBearing), R.push(L.rightSideBearing), G.push(V.advanceWidth));
			}
			S = Math.min.apply(null, g);
			h = Math.min.apply(null, h);
			l = Math.max.apply(null, l);
			q = Math.max.apply(null, q);
			g = Math.max.apply(null, G);
			for (L = V = 0;L < G.length;L += 1) {
				V += G[L];
			}
			S = {xMin:S, yMin:h, xMax:l, yMax:q, advanceWidthMax:g, advanceWidthAvg:V / G.length, minLeftSideBearing:Math.min.apply(null, N), maxLeftSideBearing:Math.max.apply(null, N), minRightSideBearing:Math.min.apply(null, R)};
			S.ascender = b.ascender;
			S.descender = b.descender;
			G = p.make({flags:3, unitsPerEm:b.unitsPerEm, xMin:S.xMin, yMin:S.yMin, xMax:S.xMax, yMax:S.yMax, lowestRecPPEM:3, createdTimestamp:b.createdTimestamp});
			N = t.make({ascender:S.ascender, descender:S.descender, advanceWidthMax:S.advanceWidthMax, minLeftSideBearing:S.minLeftSideBearing, minRightSideBearing:S.minRightSideBearing, xMaxExtent:S.maxLeftSideBearing + (S.xMax - S.xMin), numberOfHMetrics:b.glyphs.length});
			R = x.make(b.glyphs.length);
			f = u.make({xAvgCharWidth:Math.round(S.advanceWidthAvg), usWeightClass:b.tables.os2.usWeightClass, usWidthClass:b.tables.os2.usWidthClass, usFirstCharIndex:f, usLastCharIndex:H, ulUnicodeRange1:ba, ulUnicodeRange2:ha, ulUnicodeRange3:Y, ulUnicodeRange4:ga, fsSelection:b.tables.os2.fsSelection, sTypoAscender:S.ascender, sTypoDescender:S.descender, sTypoLineGap:0, usWinAscent:S.yMax, usWinDescent:Math.abs(S.yMin), ulCodePageRange1:1, sxHeight:e(b, "xyvw", {yMax:Math.round(S.ascender / 2)}).yMax, 
			sCapHeight:e(b, "HIKLEFJMNTZBDPRAGOQSUVWXY", S).yMax, usDefaultChar:b.hasChar(" ") ? 32 : 0, usBreakChar:b.hasChar(" ") ? 32 : 0});
			H = v.make(b.glyphs);
			ba = r.make(b.glyphs);
			ha = b.getEnglishName("fontFamily");
			Y = b.getEnglishName("fontSubfamily");
			ga = ha + " " + Y;
			(q = b.getEnglishName("postScriptName")) || (q = ha.replace(/\s/g, "") + "-" + Y);
			var l = {}, W;
			for (W in b.names) {
				l[W] = b.names[W];
			}
			l.uniqueID || (l.uniqueID = {en:b.getEnglishName("manufacturer") + ":" + ga});
			l.postScriptName || (l.postScriptName = {en:q});
			l.preferredFamily || (l.preferredFamily = b.names.fontFamily);
			l.preferredSubfamily || (l.preferredSubfamily = b.names.fontSubfamily);
			h = [];
			W = m.make(l, h);
			l = 0 < h.length ? y.make(h) : void 0;
			h = B.make();
			Y = w.make(b.glyphs, {version:b.getEnglishName("version"), fullName:ga, familyName:ha, weightName:Y, postScriptName:q, unitsPerEm:b.unitsPerEm, fontBBox:[0, S.yMin, S.ascender, S.advanceWidthMax]});
			ha = b.metas && 0 < Object.keys(b.metas).length ? D.make(b.metas) : void 0;
			W = [G, N, R, f, W, ba, h, Y, H];
			l && W.push(l);
			b.tables.gsub && W.push(A.make(b.tables.gsub));
			ha && W.push(ha);
			b = c(W);
			W = b.encode();
			W = k(W);
			f = b.fields;
			H = !1;
			for (S = 0;S < f.length;S += 1) {
				if ("head table" === f[S].name) {
					f[S].value.checkSumAdjustment = 2981146554 - W;
					H = !0;
					break;
				}
			}
			if (!H) {
				throw Error("Could not find head table with checkSum to adjust.");
			}
			return b;
		};
	}, {"../check":2, "../table":13, "./cff":14, "./cmap":15, "./gsub":19, "./head":20, "./hhea":21, "./hmtx":22, "./ltag":25, "./maxp":26, "./meta":27, "./name":28, "./os2":29, "./post":30}], 32:[function(f, l, b) {
		function k(b) {
			return function() {
				return b;
			};
		}
		var h = f("./check");
		f = {};
		var c = {}, e = {};
		c.BYTE = function(b) {
			return h.argument(0 <= b && 255 >= b, "Byte value should be between 0 and 255."), [b];
		};
		e.BYTE = k(1);
		c.CHAR = function(b) {
			return [b.charCodeAt(0)];
		};
		e.CHAR = k(1);
		c.CHARARRAY = function(b) {
			for (var c = [], e = 0;e < b.length;e += 1) {
				c[e] = b.charCodeAt(e);
			}
			return c;
		};
		e.CHARARRAY = function(b) {
			return b.length;
		};
		c.USHORT = function(b) {
			return [b >> 8 & 255, 255 & b];
		};
		e.USHORT = k(2);
		c.SHORT = function(b) {
			return 32768 <= b && (b = -(65536 - b)), [b >> 8 & 255, 255 & b];
		};
		e.SHORT = k(2);
		c.UINT24 = function(b) {
			return [b >> 16 & 255, b >> 8 & 255, 255 & b];
		};
		e.UINT24 = k(3);
		c.ULONG = function(b) {
			return [b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
		};
		e.ULONG = k(4);
		c.LONG = function(b) {
			return 2147483648 <= b && (b = -(4294967296 - b)), [b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
		};
		e.LONG = k(4);
		c.FIXED = c.ULONG;
		e.FIXED = e.ULONG;
		c.FWORD = c.SHORT;
		e.FWORD = e.SHORT;
		c.UFWORD = c.USHORT;
		e.UFWORD = e.USHORT;
		c.LONGDATETIME = function(b) {
			return [0, 0, 0, 0, b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
		};
		e.LONGDATETIME = k(8);
		c.TAG = function(b) {
			return h.argument(4 === b.length, "Tag should be exactly 4 ASCII characters."), [b.charCodeAt(0), b.charCodeAt(1), b.charCodeAt(2), b.charCodeAt(3)];
		};
		e.TAG = k(4);
		c.Card8 = c.BYTE;
		e.Card8 = e.BYTE;
		c.Card16 = c.USHORT;
		e.Card16 = e.USHORT;
		c.OffSize = c.BYTE;
		e.OffSize = e.BYTE;
		c.SID = c.USHORT;
		e.SID = e.USHORT;
		c.NUMBER = function(b) {
			return -107 <= b && 107 >= b ? [b + 139] : 108 <= b && 1131 >= b ? (b -= 108, [(b >> 8) + 247, 255 & b]) : -1131 <= b && -108 >= b ? (b = -b - 108, [(b >> 8) + 251, 255 & b]) : -32768 <= b && 32767 >= b ? c.NUMBER16(b) : c.NUMBER32(b);
		};
		e.NUMBER = function(b) {
			return c.NUMBER(b).length;
		};
		c.NUMBER16 = function(b) {
			return [28, b >> 8 & 255, 255 & b];
		};
		e.NUMBER16 = k(3);
		c.NUMBER32 = function(b) {
			return [29, b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b];
		};
		e.NUMBER32 = k(5);
		c.REAL = function(b) {
			var c = b.toString(), e = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(c);
			e && (c = parseFloat("1e" + ((e[2] ? +e[2] : 0) + e[1].length)), c = (Math.round(b * c) / c).toString());
			var f = "";
			b = 0;
			for (e = c.length;e > b;b += 1) {
				var h = c[b], f = f + ("e" === h ? "-" === c[++b] ? "c" : "b" : "." === h ? "a" : "-" === h ? "e" : h)
			}
			f += 1 & f.length ? "f" : "ff";
			c = [30];
			b = 0;
			for (e = f.length;e > b;b += 2) {
				c.push(parseInt(f.substr(b, 2), 16));
			}
			return c;
		};
		e.REAL = function(b) {
			return c.REAL(b).length;
		};
		c.NAME = c.CHARARRAY;
		e.NAME = e.CHARARRAY;
		c.STRING = c.CHARARRAY;
		e.STRING = e.CHARARRAY;
		f.UTF8 = function(b, c, e) {
			for (var f = [], h = 0;e > h;h++, c += 1) {
				f[h] = b.getUint8(c);
			}
			return String.fromCharCode.apply(null, f);
		};
		f.UTF16 = function(b, c, e) {
			var f = [];
			e /= 2;
			for (var h = 0;e > h;h++, c += 2) {
				f[h] = b.getUint16(c);
			}
			return String.fromCharCode.apply(null, f);
		};
		c.UTF16 = function(b) {
			for (var c = [], e = 0;e < b.length;e += 1) {
				var f = b.charCodeAt(e);
				c[c.length] = f >> 8 & 255;
				c[c.length] = 255 & f;
			}
			return c;
		};
		e.UTF16 = function(b) {
			return 2 * b.length;
		};
		var g = {"x-mac-croatian":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u0160\u2122\u00b4\u00a8\u2260\u017d\u00d8\u221e\u00b1\u2264\u2265\u2206\u00b5\u2202\u2211\u220f\u0161\u222b\u00aa\u00ba\u03a9\u017e\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u0106\u00ab\u010c\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u0110\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\uf8ff\u00a9\u2044\u20ac\u2039\u203a\u00c6\u00bb\u2013\u00b7\u201a\u201e\u2030\u00c2\u0107\u00c1\u010d\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\u0111\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u03c0\u00cb\u02da\u00b8\u00ca\u00e6\u02c7", 
		"x-mac-cyrillic":"\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\u2020\u00b0\u0490\u00a3\u00a7\u2022\u00b6\u0406\u00ae\u00a9\u2122\u0402\u0452\u2260\u0403\u0453\u221e\u00b1\u2264\u2265\u0456\u00b5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040a\u045a\u0458\u0405\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u040b\u045b\u040c\u045c\u0455\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u201e\u040e\u045e\u040f\u045f\u2116\u0401\u0451\u044f\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e", 
		"x-mac-gaelic":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u1e02\u00b1\u2264\u2265\u1e03\u010a\u010b\u1e0a\u1e0b\u1e1e\u1e1f\u0120\u0121\u1e40\u00e6\u00f8\u1e41\u1e56\u1e57\u027c\u0192\u017f\u1e60\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u1e61\u1e9b\u00ff\u0178\u1e6a\u20ac\u2039\u203a\u0176\u0177\u1e6b\u00b7\u1ef2\u1ef3\u204a\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\u2663\u00d2\u00da\u00db\u00d9\u0131\u00dd\u00fd\u0174\u0175\u1e84\u1e85\u1e80\u1e81\u1e82\u1e83", 
		"x-mac-greek":"\u00c4\u00b9\u00b2\u00c9\u00b3\u00d6\u00dc\u0385\u00e0\u00e2\u00e4\u0384\u00a8\u00e7\u00e9\u00e8\u00ea\u00eb\u00a3\u2122\u00ee\u00ef\u2022\u00bd\u2030\u00f4\u00f6\u00a6\u20ac\u00f9\u00fb\u00fc\u2020\u0393\u0394\u0398\u039b\u039e\u03a0\u00df\u00ae\u00a9\u03a3\u03aa\u00a7\u2260\u00b0\u00b7\u0391\u00b1\u2264\u2265\u00a5\u0392\u0395\u0396\u0397\u0399\u039a\u039c\u03a6\u03ab\u03a8\u03a9\u03ac\u039d\u00ac\u039f\u03a1\u2248\u03a4\u00ab\u00bb\u2026\u00a0\u03a5\u03a7\u0386\u0388\u0153\u2013\u2015\u201c\u201d\u2018\u2019\u00f7\u0389\u038a\u038c\u038e\u03ad\u03ae\u03af\u03cc\u038f\u03cd\u03b1\u03b2\u03c8\u03b4\u03b5\u03c6\u03b3\u03b7\u03b9\u03be\u03ba\u03bb\u03bc\u03bd\u03bf\u03c0\u03ce\u03c1\u03c3\u03c4\u03b8\u03c9\u03c2\u03c7\u03c5\u03b6\u03ca\u03cb\u0390\u03b0\u00ad", 
		"x-mac-icelandic":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u00dd\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u00e6\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u2044\u20ac\u00d0\u00f0\u00de\u00fe\u00fd\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7", 
		"x-mac-inuit":"\u1403\u1404\u1405\u1406\u140a\u140b\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144e\u144f\u1450\u1451\u1455\u1456\u1466\u146d\u146e\u146f\u1470\u1472\u1473\u1483\u148b\u148c\u148d\u148e\u1490\u1491\u00b0\u14a1\u14a5\u14a6\u2022\u00b6\u14a7\u00ae\u00a9\u2122\u14a8\u14aa\u14ab\u14bb\u14c2\u14c3\u14c4\u14c5\u14c7\u14c8\u14d0\u14ef\u14f0\u14f1\u14f2\u14f4\u14f5\u1505\u14d5\u14d6\u14d7\u14d8\u14da\u14db\u14ea\u1528\u1529\u152a\u152b\u152d\u2026\u00a0\u152e\u153e\u1555\u1556\u1557\u2013\u2014\u201c\u201d\u2018\u2019\u1558\u1559\u155a\u155d\u1546\u1547\u1548\u1549\u154b\u154c\u1550\u157f\u1580\u1581\u1582\u1583\u1584\u1585\u158f\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15a0\u15a1\u15a2\u15a3\u15a4\u15a5\u15a6\u157c\u0141\u0142", 
		"x-mac-ce":"\u00c4\u0100\u0101\u00c9\u0104\u00d6\u00dc\u00e1\u0105\u010c\u00e4\u010d\u0106\u0107\u00e9\u0179\u017a\u010e\u00ed\u010f\u0112\u0113\u0116\u00f3\u0117\u00f4\u00f6\u00f5\u00fa\u011a\u011b\u00fc\u2020\u00b0\u0118\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u0119\u00a8\u2260\u0123\u012e\u012f\u012a\u2264\u2265\u012b\u0136\u2202\u2211\u0142\u013b\u013c\u013d\u013e\u0139\u013a\u0145\u0146\u0143\u00ac\u221a\u0144\u0147\u2206\u00ab\u00bb\u2026\u00a0\u0148\u0150\u00d5\u0151\u014c\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u014d\u0154\u0155\u0158\u2039\u203a\u0159\u0156\u0157\u0160\u201a\u201e\u0161\u015a\u015b\u00c1\u0164\u0165\u00cd\u017d\u017e\u016a\u00d3\u00d4\u016b\u016e\u00da\u016f\u0170\u0171\u0172\u0173\u00dd\u00fd\u0137\u017b\u0141\u017c\u0122\u02c7", 
		macintosh:"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u00e6\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u2044\u20ac\u2039\u203a\ufb01\ufb02\u2021\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7", 
		"x-mac-romanian":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u0102\u0218\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u0103\u0219\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u2044\u20ac\u2039\u203a\u021a\u021b\u2021\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7", 
		"x-mac-turkish":"\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u00e6\u00f8\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\u00ff\u0178\u011e\u011f\u0130\u0131\u015e\u015f\u2021\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\uf8ff\u00d2\u00da\u00db\u00d9\uf8a0\u02c6\u02dc\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7"};
		f.MACSTRING = function(b, c, e, f) {
			f = g[f];
			if (void 0 !== f) {
				for (var h = "", k = 0;e > k;k++) {
					var l = b.getUint8(c + k), h = h + (127 >= l ? String.fromCharCode(l) : f[127 & l])
				}
				return h;
			}
		};
		var q = "function" == typeof WeakMap && new WeakMap, r;
		c.MACSTRING = function(b, c) {
			var e;
			a: {
				if (!r) {
					for (e in r = {}, g) {
						r[e] = new String(e);
					}
				}
				e = r[c];
				if (void 0 !== e) {
					if (q) {
						var f = q.get(e);
						if (void 0 !== f) {
							e = f;
							break a;
						}
					}
					c = g[c];
					if (void 0 !== c) {
						for (var f = {}, h = 0;h < c.length;h++) {
							f[c.charCodeAt(h)] = h + 128;
						}
						e = (q && q.set(e, f), f);
						break a;
					}
				}
				e = void 0;
			}
			if (void 0 !== e) {
				c = [];
				for (f = 0;f < b.length;f++) {
					h = b.charCodeAt(f);
					if (128 <= h && (h = e[h], void 0 === h)) {
						return;
					}
					c[f] = h;
				}
				return c;
			}
		};
		e.MACSTRING = function(b, e) {
			b = c.MACSTRING(b, e);
			return void 0 !== b ? b.length : 0;
		};
		c.INDEX = function(b) {
			var e, f = 1, h = [f], g = [];
			for (e = 0;e < b.length;e += 1) {
				var k = c.OBJECT(b[e]);
				Array.prototype.push.apply(g, k);
				f += k.length;
				h.push(f);
			}
			if (0 === g.length) {
				return [0, 0];
			}
			var k = [], f = 1 + Math.floor(Math.log(f) / Math.log(2)) / 8 | 0, l = [void 0, c.BYTE, c.USHORT, c.UINT24, c.ULONG][f];
			for (e = 0;e < h.length;e += 1) {
				var p = l(h[e]);
				Array.prototype.push.apply(k, p);
			}
			return Array.prototype.concat(c.Card16(b.length), c.OffSize(f), k, g);
		};
		e.INDEX = function(b) {
			return c.INDEX(b).length;
		};
		c.DICT = function(b) {
			for (var e = [], f = Object.keys(b), h = f.length, g = 0;h > g;g += 1) {
				var k = parseInt(f[g], 0), l = b[k], e = e.concat(c.OPERAND(l.value, l.type)), e = e.concat(c.OPERATOR(k))
			}
			return e;
		};
		e.DICT = function(b) {
			return c.DICT(b).length;
		};
		c.OPERATOR = function(b) {
			return 1200 > b ? [b] : [12, b - 1200];
		};
		c.OPERAND = function(b, e) {
			var f = [];
			if (Array.isArray(e)) {
				for (var g = 0;g < e.length;g += 1) {
					h.argument(b.length === e.length, "Not enough arguments given for type" + e), f = f.concat(c.OPERAND(b[g], e[g]));
				}
			} else {
				if ("SID" === e) {
					f = f.concat(c.NUMBER(b));
				} else {
					if ("offset" === e) {
						f = f.concat(c.NUMBER32(b));
					} else {
						if ("number" === e) {
							f = f.concat(c.NUMBER(b));
						} else {
							if ("real" !== e) {
								throw Error("Unknown operand type " + e);
							}
							f = f.concat(c.REAL(b));
						}
					}
				}
			}
			return f;
		};
		c.OP = c.BYTE;
		e.OP = e.BYTE;
		var w = "function" == typeof WeakMap && new WeakMap;
		c.CHARSTRING = function(b) {
			if (w) {
				var e = w.get(b);
				if (void 0 !== e) {
					return e;
				}
			}
			for (var e = [], f = b.length, h = 0;f > h;h += 1) {
				var g = b[h], e = e.concat(c[g.type](g.value))
			}
			return w && w.set(b, e), e;
		};
		e.CHARSTRING = function(b) {
			return c.CHARSTRING(b).length;
		};
		c.OBJECT = function(b) {
			var e = c[b.type];
			return h.argument(void 0 !== e, "No encoding function for type " + b.type), e(b.value);
		};
		e.OBJECT = function(b) {
			var c = e[b.type];
			return h.argument(void 0 !== c, "No sizeOf function for type " + b.type), c(b.value);
		};
		c.TABLE = function(b) {
			var e, f = [], g = b.fields.length, k = [], l = [];
			for (e = 0;g > e;e += 1) {
				var p = b.fields[e], q = c[p.type];
				h.argument(void 0 !== q, "No encoding function for field type " + p.type + " (" + p.name + ")");
				var r = b[p.name];
				void 0 === r && (r = p.value);
				q = q(r);
				"TABLE" === p.type ? (l.push(f.length), f = f.concat([0, 0]), k.push(q)) : f = f.concat(q);
			}
			for (e = 0;e < k.length;e += 1) {
				g = l[e], p = f.length, h.argument(65536 > p, "Table " + b.tableName + " too big."), f[g] = p >> 8, f[g + 1] = 255 & p, f = f.concat(k[e]);
			}
			return f;
		};
		e.TABLE = function(b) {
			for (var c = 0, f = b.fields.length, g = 0;f > g;g += 1) {
				var k = b.fields[g], l = e[k.type];
				h.argument(void 0 !== l, "No sizeOf function for field type " + k.type + " (" + k.name + ")");
				var p = b[k.name];
				void 0 === p && (p = k.value);
				c += l(p);
				"TABLE" === k.type && (c += 2);
			}
			return c;
		};
		c.RECORD = c.TABLE;
		e.RECORD = e.TABLE;
		c.LITERAL = function(b) {
			return b;
		};
		e.LITERAL = function(b) {
			return b.length;
		};
		b.decode = f;
		b.encode = c;
		b.sizeOf = e;
	}, {"./check":2}], 33:[function(f, l, b) {
		b.isBrowser = function() {
			return "undefined" != typeof window;
		};
		b.isNode = function() {
			return "undefined" == typeof window;
		};
		b.nodeBufferToArrayBuffer = function(b) {
			for (var f = new ArrayBuffer(b.length), c = new Uint8Array(f), e = 0;e < b.length;++e) {
				c[e] = b[e];
			}
			return f;
		};
		b.arrayBufferToNodeBuffer = function(b) {
			var f = new Buffer(b.byteLength);
			b = new Uint8Array(b);
			for (var c = 0;c < f.length;++c) {
				f[c] = b[c];
			}
			return f;
		};
		b.checkArgument = function(b, f) {
			if (!b) {
				throw f;
			}
		};
	}, {}]}, {}, [9])(9);
});
var BufferAttribute = THREE.BufferAttribute, BufferGeometry = THREE.BufferGeometry, Clock = THREE.Clock, Face3 = THREE.Face3, Geometry = THREE.Geometry, Object3D = THREE.Object3D, Raycaster = THREE.Raycaster, Material = THREE.Material, LineBasicMaterial = THREE.LineBasicMaterial, LineDashedMaterial = THREE.LineDashedMaterial, MeshBasicMaterial = THREE.MeshBasicMaterial, MeshDepthMaterial = THREE.MeshDepthMaterial, MeshLambertMaterial = THREE.MeshLambertMaterial, MeshNormalMaterial = THREE.MeshNormalMaterial, 
MeshPhongMaterial = THREE.MeshPhongMaterial, MeshPhysicalMaterial = THREE.MeshPhysicalMaterial, MeshStandardMaterial = THREE.MeshStandardMaterial, MultiMaterial = THREE.MultiMaterial, PointsMaterial = THREE.PointsMaterial, RawShaderMaterial = THREE.RawShaderMaterial, ShaderMaterial = THREE.ShaderMaterial, SpriteMaterial = THREE.SpriteMaterial, BoxBufferGeometry = THREE.BoxBufferGeometry, BoxGeometry = THREE.BoxGeometry, CircleBufferGeometry = THREE.CircleBufferGeometry, CircleGeometry = THREE.CircleGeometry, 
ConeBufferGeometry = THREE.ConeBufferGeometry, ConeGeometry = THREE.ConeGeometry, CylinderBufferGeometry = THREE.CylinderBufferGeometry, CylinderGeometry = THREE.CylinderGeometry, DodecahedronBufferGeometry = THREE.DodecahedronBufferGeometry, DodecahedronGeometry = THREE.DodecahedronGeometry, ExtrudeGeometry = THREE.ExtrudeGeometry, IcosahedronBufferGeometry = THREE.IcosahedronBufferGeometry, IcosahedronGeometry = THREE.IcosahedronGeometry, LatheBufferGeometry = THREE.LatheBufferGeometry, LatheGeometry = 
THREE.LatheGeometry, OctahedronBufferGeometry = THREE.OctahedronBufferGeometry, OctahedronGeometry = THREE.OctahedronGeometry, ParametricBufferGeometry = THREE.ParametricBufferGeometry, ParametricGeometry = THREE.ParametricGeometry, PlaneBufferGeometry = THREE.PlaneBufferGeometry, PlaneGeometry = THREE.PlaneGeometry, PolyhedronBufferGeometry = THREE.PolyhedronBufferGeometry, PolyhedronGeometry = THREE.PolyhedronGeometry, RingBufferGeometry = THREE.RingBufferGeometry, RingGeometry = THREE.RingGeometry, 
ShapeGeometry = THREE.ShapeGeometry, SphereBufferGeometry = THREE.SphereBufferGeometry, SphereGeometry = THREE.SphereGeometry, TetrahedronBufferGeometry = THREE.TetrahedronBufferGeometry, TetrahedronGeometry = THREE.TetrahedronGeometry, TextGeometry = THREE.TextGeometry, TorusBufferGeometry = THREE.TorusBufferGeometry, TorusGeometry = THREE.TorusGeometry, TorusKnotBufferGeometry = THREE.TorusKnotBufferGeometry, TorusKnotGeometry = THREE.TorusKnotGeometry, TubeGeometry = THREE.TubeGeometry, TubeBufferGeometry = 
THREE.TubeBufferGeometry, Box2 = THREE.Box2, Box3 = THREE.Box3, Color = THREE.Color, Euler = THREE.Euler, Frustum = THREE.Frustum, Matrix3 = THREE.Matrix3, Matrix4 = THREE.Matrix4, Plane = THREE.Plane, Quarternion = THREE.Quarternion, Ray = THREE.Ray, Sphere = THREE.Sphere, Spline = THREE.Spline, Triangle = THREE.Triangle, Vector2 = THREE.Vector2, Vector3 = THREE.Vector3, Vector4 = THREE.Vector4, LOD = THREE.LOD, LensFlare = THREE.LensFlare;
THREE.Object3D.prototype.folded = !1;
THREE.Object3D.prototype.hidden = !1;
THREE.Object3D.prototype.initialize = function() {
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].initialize();
	}
};
THREE.Object3D.prototype.update = function() {
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].update();
	}
};
THREE.Object3D.prototype.dispose = function() {
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].dispose();
	}
};
THREE.Object3D.prototype.removeAll = function() {
	for (var a = this.children.length - 1;-1 < a;a--) {
		this.remove(this.children[a]);
	}
};
THREE.Object3D.prototype.destroy = function() {
	for (;0 < this.children.length;) {
		this.children[0].destroy();
	}
	null !== this.parent && (this.dispose && this.dispose(), this.parent.remove(this));
};
THREE.Object3D.prototype.toJSON = function(a, f, l) {
	function b(a) {
		var b = [], c;
		for (c in a) {
			var e = a[c];
			delete e.metadata;
			b.push(e);
		}
		return b;
	}
	var k = void 0 === a, h = {};
	k && (a = {fonts:{}, videos:{}, images:{}, audio:{}, geometries:{}, materials:{}, textures:{}}, h.metadata = {version:Nunu.VERSION, type:"NunuProgram"});
	var c = {};
	c.uuid = this.uuid;
	c.type = this.type;
	c.name = this.name;
	c.folded = this.folded;
	c.hidden = this.hidden;
	c.castShadow = this.castShadow;
	c.receiveShadow = this.receiveShadow;
	c.visible = this.visible;
	c.matrixAutoUpdate = this.matrixAutoUpdate;
	c.matrix = this.matrix.toArray();
	"{}" !== JSON.stringify(this.userData) && (c.userData = this.userData);
	void 0 !== this.geometry && (void 0 === a.geometries[this.geometry.uuid] && (a.geometries[this.geometry.uuid] = this.geometry.toJSON(a)), c.geometry = this.geometry.uuid);
	void 0 !== this.material && (void 0 === a.materials[this.material.uuid] && (a.materials[this.material.uuid] = this.material.toJSON(a)), c.material = this.material.uuid);
	void 0 !== f && f(a, c);
	if (!1 !== l && 0 < this.children.length) {
		for (c.children = [], f = 0;f < this.children.length;f++) {
			this.children[f].hidden || c.children.push(this.children[f].toJSON(a).object);
		}
	}
	k && (h.geometries = b(a.geometries), h.materials = b(a.materials), h.textures = b(a.textures), h.images = b(a.images), h.videos = b(a.videos), h.audio = b(a.audio), h.fonts = b(a.fonts));
	h.object = c;
	return h;
};
THREE.Vector3.fromJSON = function(a) {
	return new THREE.Vector3(a.x, a.y, a.z);
};
THREE.Vector3.prototype.toJSON = function() {
	return {x:this.x, y:this.y, z:this.z};
};
THREE.Vector2.fromJSON = function(a) {
	return new THREE.Vector2(a.x, a.y);
};
THREE.Vector2.prototype.toJSON = function() {
	return {x:this.x, y:this.y};
};
THREE.Texture.prototype.toJSON = function(a) {
	if (void 0 !== a.textures[this.uuid]) {
		return a.textures[this.uuid];
	}
	var f = {metadata:{version:Nunu.VERSION, type:"Texture"}, uuid:this.uuid, name:this.name, category:this.category, mapping:this.mapping, repeat:[this.repeat.x, this.repeat.y], offset:[this.offset.x, this.offset.y], wrap:[this.wrapS, this.wrapT], minFilter:this.minFilter, magFilter:this.magFilter, anisotropy:this.anisotropy, flipY:this.flipY};
	return a.textures[this.uuid] = f;
};
THREE.LightShadow.prototype.toJSON = function() {
	var a = {};
	a.bias = this.bias;
	a.radius = this.radius;
	a.mapSize = {};
	a.mapSize.x = this.mapSize.x;
	a.mapSize.y = this.mapSize.y;
	a.camera = {};
	a.camera.top = this.camera.top;
	a.camera.bottom = this.camera.bottom;
	a.camera.far = this.camera.far;
	a.camera.near = this.camera.near;
	a.camera.left = this.camera.left;
	a.camera.right = this.camera.right;
	return a;
};
THREE.LightShadow.prototype.fromJSON = function(a) {
	void 0 !== a.bias && (this.bias = a.bias);
	void 0 !== a.radius && (this.radius = a.radius);
	if (void 0 !== a.mapSize) {
		var f = a.mapSize;
		this.mapSize.set(f.x, f.y);
	}
	void 0 !== a.camera && (a = a.camera, this.camera.top = a.top, this.camera.bottom = a.bottom, this.camera.left = a.left, this.camera.right = a.right, this.camera.near = a.near, this.camera.far = a.far);
};
THREE.Fog.NONE = 0;
THREE.Fog.LINEAR = 1;
THREE.Fog.EXPONENTIAL = 2;
function Key() {
	this.just_released = this.just_pressed = this.pressed = !1;
}
Key.DOWN = -1;
Key.UP = 1;
Key.RESET = 0;
Key.prototype.update = function(a) {
	this.just_released = this.just_pressed = !1;
	a === Key.DOWN ? (!1 === this.pressed && (this.just_pressed = !0), this.pressed = !0) : a === Key.UP ? (this.pressed && (this.just_released = !0), this.pressed = !1) : a === Key.RESET && (this.just_pressed = this.just_released = !1);
};
Key.prototype.set = function(a, f, l) {
	this.just_pressed = a;
	this.pressed = f;
	this.just_released = l;
};
Key.prototype.reset = function() {
	this.just_released = this.pressed = this.just_pressed = !1;
};
function Keyboard() {
}
Keyboard.initialize = function() {
	Keyboard.keys = [];
	Keyboard.actions = [];
	for (var a = 0;256 > a;a++) {
		Keyboard.keys.push(new Key);
	}
	Keyboard.events = [];
	Keyboard.events.push([window, "keydown", function(a) {
		Keyboard.actions.push(a.keyCode);
		Keyboard.actions.push(Key.DOWN);
	}]);
	Keyboard.events.push([window, "keyup", function(a) {
		Keyboard.actions.push(a.keyCode);
		Keyboard.actions.push(Key.UP);
	}]);
	for (a = 0;a < Keyboard.events.length;a++) {
		var f = Keyboard.events[a];
		f[0].addEventListener(f[1], f[2]);
	}
};
Keyboard.update = function() {
	for (var a = 0;Keyboard.actions.length > a;) {
		var f = Keyboard.actions.shift(), l = Keyboard.actions.shift();
		Keyboard.keys[f].update(l);
		if (Keyboard.keys[f].just_released || Keyboard.keys[f].just_pressed) {
			Keyboard.actions.push(f), Keyboard.actions.push(Key.RESET), a += 2;
		}
	}
};
Keyboard.reset = function() {
	Keyboard.actions = [];
	for (var a = 0;a < Keyboard.keys.length;a++) {
		Keyboard.keys[a].reset();
	}
};
Keyboard.keyPressed = function(a) {
	return 256 > a && Keyboard.keys[a].pressed;
};
Keyboard.keyJustPressed = function(a) {
	return 256 > a && Keyboard.keys[a].just_pressed;
};
Keyboard.keyJustReleased = function(a) {
	return 256 > a && Keyboard.keys[a].just_released;
};
Keyboard.dispose = function() {
	for (var a = 0;a < Keyboard.events.length;a++) {
		var f = Keyboard.events[a];
		f[0].removeEventListener(f[1], f[2]);
	}
};
Keyboard.BACKSPACE = 8;
Keyboard.TAB = 9;
Keyboard.ENTER = 13;
Keyboard.SHIFT = 16;
Keyboard.CTRL = 17;
Keyboard.ALT = 18;
Keyboard.CAPS_LOCK = 20;
Keyboard.ESC = 27;
Keyboard.SPACEBAR = 32;
Keyboard.PAGE_UP = 33;
Keyboard.PAGE_DOWN = 34;
Keyboard.END = 35;
Keyboard.HOME = 36;
Keyboard.INSERT = 45;
Keyboard.DEL = 46;
Keyboard.LEFT = 37;
Keyboard.RIGHT = 39;
Keyboard.UP = 38;
Keyboard.DOWN = 40;
Keyboard.NUM0 = 48;
Keyboard.NUM1 = 49;
Keyboard.NUM2 = 50;
Keyboard.NUM3 = 51;
Keyboard.NUM4 = 52;
Keyboard.NUM5 = 53;
Keyboard.NUM6 = 54;
Keyboard.NUM7 = 55;
Keyboard.NUM8 = 56;
Keyboard.NUM9 = 57;
Keyboard.A = 65;
Keyboard.B = 66;
Keyboard.C = 67;
Keyboard.D = 68;
Keyboard.E = 69;
Keyboard.F = 70;
Keyboard.G = 71;
Keyboard.H = 72;
Keyboard.I = 73;
Keyboard.J = 74;
Keyboard.K = 75;
Keyboard.L = 76;
Keyboard.M = 77;
Keyboard.N = 78;
Keyboard.O = 79;
Keyboard.P = 80;
Keyboard.Q = 81;
Keyboard.R = 82;
Keyboard.S = 83;
Keyboard.T = 84;
Keyboard.U = 85;
Keyboard.V = 86;
Keyboard.W = 87;
Keyboard.X = 88;
Keyboard.Y = 89;
Keyboard.Z = 90;
Keyboard.F1 = 112;
Keyboard.F2 = 113;
Keyboard.F3 = 114;
Keyboard.F4 = 115;
Keyboard.F5 = 116;
Keyboard.F6 = 117;
Keyboard.F7 = 118;
Keyboard.F8 = 119;
Keyboard.F9 = 120;
Keyboard.F10 = 121;
Keyboard.F11 = 122;
Keyboard.F12 = 123;
function Mouse() {
}
Mouse.initialize = function() {
	Mouse._keys = [];
	Mouse._position = new THREE.Vector2(0, 0);
	Mouse._position_updated = !1;
	Mouse._delta = new THREE.Vector2(0, 0);
	Mouse._wheel = 0;
	Mouse._wheel_updated = !1;
	Mouse._double_clicked = !1;
	Mouse.keys = [];
	Mouse.position = new THREE.Vector2(0, 0);
	Mouse.delta = new THREE.Vector2(0, 0);
	Mouse.wheel = 0;
	Mouse.double_clicked = !1;
	Mouse.canvas = null;
	Mouse.events = [];
	for (var a = 0;3 > a;a++) {
		Mouse._keys.push(new Key), Mouse.keys.push(new Key);
	}
	void 0 !== window.onmousewheel ? Mouse.events.push([window, "mousewheel", function(a) {
		Mouse._wheel = a.deltaY;
		Mouse._wheel_updated = !0;
	}]) : void 0 !== window.addEventListener ? Mouse.events.push([window, "DOMMouseScroll", function(a) {
		Mouse._wheel = 30 * a.detail;
		Mouse._wheel_updated = !0;
	}]) : Mouse.events.push([window, "wheel", function(a) {
		Mouse._wheel = a.deltaY;
		Mouse._wheel_updated = !0;
	}]);
	if ("ontouchstart" in window || 0 < navigator.msMaxTouchPoints) {
		var f = new Vector2(0, 0);
		Mouse.events.push([window, "touchstart", function(a) {
			a = a.touches[0];
			f.set(a.clientX, a.clientY);
			Mouse.updateKey(Mouse.LEFT, Key.DOWN);
		}]);
		Mouse.events.push([window, "touchend", function(a) {
			Mouse.updateKey(Mouse.LEFT, Key.UP);
		}]);
		Mouse.events.push([window, "touchmove", function(a) {
			a = a.touches[0];
			if (null !== Mouse.canvas) {
				var b = Mouse.canvas.getBoundingClientRect();
				Mouse.updatePosition(a.clientX - b.left, a.clientY - b.top, a.clientX - f.x, a.clientY - f.y);
			} else {
				Mouse.updatePosition(a.clientX, a.clientY, a.clientX - f.x, a.clientY - f.y);
			}
			f.set(a.clientX, a.clientY);
		}]);
	} else {
		Mouse.events.push([window, "mousemove", function(a) {
			if (null !== Mouse.canvas) {
				var b = Mouse.canvas.getBoundingClientRect();
				Mouse.updatePosition(a.clientX - b.left, a.clientY - b.top, a.movementX, a.movementY);
			} else {
				Mouse.updatePosition(a.clientX, a.clientY, a.movementX, a.movementY);
			}
		}]), Mouse.events.push([window, "mousedown", function(a) {
			Mouse.updateKey(a.which - 1, Key.DOWN);
		}]), Mouse.events.push([window, "mouseup", function(a) {
			Mouse.updateKey(a.which - 1, Key.UP);
		}]);
	}
	Mouse.events.push([window, "dblclick", function(a) {
		Mouse._double_clicked = !0;
	}]);
	for (a = 0;a < Mouse.events.length;a++) {
		var l = Mouse.events[a];
		l[0].addEventListener(l[1], l[2], !1);
	}
};
Mouse.LEFT = 0;
Mouse.MIDDLE = 1;
Mouse.RIGHT = 2;
Mouse.setCanvas = function(a) {
	Mouse.canvas = a;
	a.mouseInside = !1;
	a.addEventListener("mouseenter", function() {
		this.mouseInside = !0;
	}, !1);
	a.addEventListener("mouseleave", function() {
		this.mouseInside = !1;
	}, !1);
};
Mouse.insideCanvas = function() {
	return null === Mouse.canvas ? !1 : Mouse.canvas.mouseInside;
};
Mouse.setLock = function(a) {
	null !== Mouse.canvas && (a ? Mouse.canvas.requestPointerLock ? Mouse.canvas.requestPointerLock() : Mouse.canvas.mozRequestPointerLock ? Mouse.canvas.mozRequestPointerLock() : Mouse.canvas.webkitRequestPointerLock && Mouse.canvas.webkitRequestPointerLock() : document.exitPointerLock ? document.exitPointerLock() : document.mozExitPointerLock ? document.mozExitPointerLock() : document.webkitExitPointerLock && document.webkitExitPointerLock());
};
Mouse.buttonPressed = function(a) {
	return Mouse.keys[a].pressed;
};
Mouse.buttonDoubleClicked = function() {
	return Mouse.double_clicked;
};
Mouse.buttonJustPressed = function(a) {
	return Mouse.keys[a].just_pressed;
};
Mouse.buttonJustReleased = function(a) {
	return Mouse.keys[a].just_released;
};
Mouse.updatePosition = function(a, f, l, b) {
	Mouse._position.set(a, f);
	Mouse._delta.x += l;
	Mouse._delta.y += b;
	Mouse._position_updated = !0;
};
Mouse.updateKey = function(a, f) {
	-1 < a && Mouse._keys[a].update(f);
};
Mouse.update = function() {
	for (var a = 0;a < Mouse._keys.length;a++) {
		Mouse._keys[a].just_pressed && Mouse.keys[a].just_pressed && (Mouse._keys[a].just_pressed = !1), Mouse._keys[a].just_released && Mouse.keys[a].just_released && (Mouse._keys[a].just_released = !1), Mouse.keys[a].set(Mouse._keys[a].just_pressed, Mouse._keys[a].pressed, Mouse._keys[a].just_released);
	}
	Mouse._wheel_updated ? (Mouse.wheel = Mouse._wheel, Mouse._wheel_updated = !1) : Mouse.wheel = 0;
	Mouse._double_clicked ? (Mouse.double_clicked = !0, Mouse._double_clicked = !1) : Mouse.double_clicked = !1;
	Mouse._position_updated ? (Mouse.delta.x = Mouse._delta.x, Mouse.delta.y = Mouse._delta.y, Mouse._delta.set(0, 0), Mouse.position.x = Mouse._position.x, Mouse.position.y = Mouse._position.y, Mouse._position_updated = !1) : (Mouse.delta.x = 0, Mouse.delta.y = 0);
};
Mouse.dispose = function() {
	for (var a = 0;a < Mouse.events.length;a++) {
		var f = Mouse.events[a];
		f[0].removeEventListener(f[1], f[2]);
	}
};
function VRControls(a, f) {
	function l(a) {
		for (var h = 0;h < a.length;h++) {
			if ("VRDisplay" in window && a[h] instanceof VRDisplay || "PositionSensorVRDevice" in window && a[h] instanceof PositionSensorVRDevice) {
				b.vr_input = a[h];
				break;
			}
		}
		b.vr_input || f && f("VR input not available");
	}
	this.vr_input = null;
	this.scale = 1;
	this.standing = !1;
	this.userHeight = 1.6;
	this.object = null;
	void 0 !== a && (this.object = a);
	this.position = new THREE.Vector3;
	this.quaternion = new THREE.Quaternion;
	var b = this;
	void 0 !== navigator.getVRDisplays && navigator.getVRDisplays().then(l);
}
VRControls.prototype.update = function() {
	if (null !== this.vr_input) {
		var a = this.vr_input.getPose();
		null !== a.orientation && this.quaternion.fromArray(a.orientation);
		null !== a.position ? this.position.fromArray(a.position) : this.position.set(0, 0, 0);
		this.standing && (this.position.y += this.userHeight);
		this.position.multiplyScalar(this.scale);
		null !== this.object && (this.object.position.copy(this.position), this.object.quaternion.copy(this.quaternion));
	}
};
VRControls.prototype.dispose = function() {
	this.vr_input = null;
};
VRControls.prototype.resetPose = function() {
	null !== this.vr_input && this.vr_input.resetPose();
};
VRControls.prototype.attachObject = function(a) {
	this.object = a;
};
function Font(a) {
	this.name = "font";
	this.uuid = THREE.Math.generateUUID();
	this.type = "Font";
	this.encoding = this.format = "";
	this.font = this.data = null;
	if (void 0 !== a) {
		if ("object" === typeof a) {
			this.font = this.data = a, this.name = a.original_font_information.fullName, this.encoding = this.format = "json";
		} else {
			if (this.encoding = a.split(".").pop().toLowerCase(), "json" === this.encoding) {
				this.font = this.data = JSON.parse(FileSystem.readFile(a)), this.name = this.data.original_font_information.fullName, this.format = "json";
			} else {
				if ("ttf" === this.encoding || "otf" === this.encoding || "ttc" === this.encoding || "otc" === this.encoding) {
					this.data = FileSystem.readFileArrayBuffer(a), this.font = (new TTFLoader).parse(this.data), this.name = this.font.original_font_information.fullName, this.format = "arraybuffer";
				}
			}
		}
	}
}
Font.prototype.isFont = !0;
Font.prototype.generateShapes = function(a, f, l) {
	void 0 === f && (f = 100);
	void 0 === l && (l = 10);
	var b = this.font;
	a = String(a).split("");
	var k = f / b.resolution, h = 0;
	f = [];
	for (var c = 0;c < a.length;c++) {
		var e;
		e = k;
		var g = h, q = b.glyphs[a[c]] || b.glyphs["?"];
		if (q) {
			var r = new THREE.ShapePath, w = [], p = THREE.ShapeUtils.b2, t = THREE.ShapeUtils.b3, v, y, x, m, u, B, A, D;
			if (q.o) {
				for (var G = q._cachedOutline || (q._cachedOutline = q.o.split(" ")), F = 0, C = G.length;F < C;) {
					if (x = G[F++], "m" === x && (v = G[F++] * e + g, y = G[F++] * e, r.moveTo(v, y)), "l" === x) {
						v = G[F++] * e + g, y = G[F++] * e, r.lineTo(v, y);
					} else {
						if ("q" === x) {
							if (v = G[F++] * e + g, y = G[F++] * e, u = G[F++] * e + g, B = G[F++] * e, r.quadraticCurveTo(u, B, v, y), m = w[w.length - 1]) {
								x = m.x;
								m = m.y;
								for (var J = 1;J <= l;J++) {
									var I = J / l;
									p(I, x, u, v);
									p(I, m, B, y);
								}
							}
						} else {
							if ("b" === x && (v = G[F++] * e + g, y = G[F++] * e, u = G[F++] * e + g, B = G[F++] * e, A = G[F++] * e + g, D = G[F++] * e, r.bezierCurveTo(u, B, A, D, v, y), m = w[w.length - 1])) {
								for (x = m.x, m = m.y, J = 1;J <= l;J++) {
									I = J / l, t(I, x, u, A, v), t(I, m, B, D, y);
								}
							}
						}
					}
				}
			}
			e = {offset:q.ha * e, path:r};
		} else {
			e = void 0;
		}
		h += e.offset;
		f.push(e.path);
	}
	l = [];
	for (b = 0;b < f.length;b++) {
		Array.prototype.push.apply(l, f[b].toShapes());
	}
	return l;
};
Font.prototype.toJSON = function(a) {
	if (void 0 !== a.fonts[this.uuid]) {
		return a.fonts[this.uuid];
	}
	var f = {};
	f.name = this.name;
	f.uuid = this.uuid;
	f.type = this.type;
	f.encoding = this.encoding;
	"arraybuffer" === this.format ? (f.data = Base64Utils.fromArraybuffer(this.data), f.format = "base64") : "json" === this.format && (f.data = this.data, f.format = this.format);
	return a.fonts[this.uuid] = f;
};
function Video(a) {
	this.name = "video";
	this.uuid = THREE.Math.generateUUID();
	this.type = "Video";
	this.encoding = this.format = "";
	this.data = null;
	void 0 !== a && (this.encoding = a.split(".").pop().toLowerCase(), this.data = "data:video/" + this.encoding + ";base64," + FileSystem.readFileBase64(a), this.format = "base64");
}
Video.prototype.toJSON = function(a) {
	if (void 0 !== a.videos[this.uuid]) {
		return a.videos[this.uuid];
	}
	var f = {};
	f.name = this.name;
	f.uuid = this.uuid;
	f.type = this.type;
	f.encoding = this.encoding;
	f.format = this.format;
	f.data = this.data;
	return a.videos[this.uuid] = f;
};
function Audio(a) {
	this.name = "audio";
	this.uuid = THREE.Math.generateUUID();
	this.type = "Audio";
	this.encoding = this.format = "";
	this.data = null;
	void 0 !== a && (this.data = FileSystem.readFileArrayBuffer(a), this.encoding = a.split(".").pop().toLowerCase(), this.format = "arraybuffer");
}
Audio.prototype.toJSON = function(a) {
	if (void 0 !== a.audio[this.uuid]) {
		return a.audio[this.uuid];
	}
	var f = {};
	f.name = this.name;
	f.uuid = this.uuid;
	f.type = this.type;
	f.encoding = this.encoding;
	f.data = Base64Utils.fromArraybuffer(this.data);
	f.format = "base64";
	return a.audio[this.uuid] = f;
};
function Image(a) {
	this.name = "image";
	this.uuid = THREE.Math.generateUUID();
	this.type = "Image";
	this.encoding = this.format = "";
	this.data = null;
	void 0 !== a && (this.encoding = a.split(".").pop().toLowerCase(), "gif" === this.encoding ? (this.data = "data:image/" + this.encoding + ";base64," + FileSystem.readFileBase64(a), this.format = "base64") : "tga" === this.encoding ? (a = (new THREE.TGALoader).parse(FileSystem.readFileArrayBuffer(a)), this.encoding = "jpeg", this.format = "base64", this.data = a.toDataURL("image/jpeg", .8)) : (this.format = "url", this.data = a));
}
Image.prototype.encodeData = function() {
	var a = document.createElement("img");
	a.src = this.data;
	var f = document.createElement("canvas");
	f.width = a.width;
	f.height = a.height;
	var l = f.getContext("2d");
	l.drawImage(a, 0, 0, a.width, a.height);
	for (var b = !1, a = l.getImageData(0, 0, a.width, a.height).data, l = 3;l < a.length;l += 4) {
		if (255 !== a[l]) {
			b = !0;
			break;
		}
	}
	b ? (this.format = "base64", this.encoding = "png", this.data = f.toDataURL("image/png")) : (this.format = "base64", this.encoding = "jpeg", this.data = f.toDataURL("image/jpeg", .8));
};
Image.prototype.toJSON = function(a) {
	if (void 0 !== a.images[this.uuid]) {
		return a.images[this.uuid];
	}
	"url" === this.format && this.encodeData();
	var f = {};
	f.name = this.name;
	f.uuid = this.uuid;
	f.type = this.type;
	f.encoding = this.encoding;
	f.format = this.format;
	f.data = this.data;
	return a.images[this.uuid] = f;
};
function CanvasTexture(a, f, l, b, k, h, c, e, g, q, r) {
	THREE.Texture.call(this, document.createElement("canvas"), l, b, k, h, c, e, g, q, r);
	this.name = "canvas";
	this.category = "Canvas";
	this.width = void 0 !== a ? a : 512;
	this.height = void 0 !== f ? f : 512;
	this.image.width = a;
	this.image.height = f;
	this.context = this.image.getContext("2d");
	this.context.font = "Normal 55px Arial";
	this.context.textAlign = "center";
	this.context.fillStyle = "#FF0000";
	this.context.fillText("Canvas Texture", this.width / 2, this.height / 2);
	this.needsUpdate = !0;
}
CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
CanvasTexture.prototype.toJSON = function(a) {
	a = THREE.Texture.prototype.toJSON.call(this, a);
	a.width = this.width;
	a.height = this.height;
	return a;
};
function VideoTexture(a, f, l, b, k, h) {
	function c() {
		a.readyState >= a.HAVE_CURRENT_DATA && (e.needsUpdate = !0);
		e.disposed || requestAnimationFrame(c);
	}
	"string" === typeof a ? this.video = new Video(a) : a instanceof Video && (this.video = a);
	THREE.Texture.call(this, document.createElement("video"), f, l, b, THREE.LinearFilter, THREE.LinearFilter, THREE.RGBFormat, k, h);
	this.disposed = this.generateMipmaps = !1;
	this.name = "video";
	this.category = "Video";
	this.loop = this.autoplay = !0;
	this.image.autoplay = this.autoplay;
	this.image.loop = this.loop;
	this.image.src = this.video.data;
	var e = this;
	a = this.image;
	c();
}
VideoTexture.prototype = Object.create(THREE.Texture.prototype);
VideoTexture.prototype.dispose = function() {
	THREE.Texture.prototype.dispose.call(this);
	this.disposed = !0;
	this.image.paused || this.image.pause();
};
VideoTexture.prototype.toJSON = function(a) {
	var f = THREE.Texture.prototype.toJSON.call(this, a);
	a = this.video.toJSON(a);
	f.video = a.uuid;
	f.loop = this.loop;
	f.autoplay = this.autoplay;
	return f;
};
function WebcamTexture(a, f, l, b, k, h, c) {
	function e() {
		g.readyState >= g.HAVE_CURRENT_DATA && (q.needsUpdate = !0);
		q.disposed || requestAnimationFrame(e);
	}
	var g = document.createElement("video");
	g.autoplay = !0;
	g.loop = !0;
	navigator.webkitGetUserMedia ? navigator.webkitGetUserMedia({video:!0}, function(a) {
		g.src = URL.createObjectURL(a);
	}, function(a) {
		console.warn("NunuStudio: No webcam available");
	}) : navigator.mediaDevices.getUserMedia && navigator.mediaDevices.getUserMedia({video:!0}).then(function(a) {
		g.src = URL.createObjectURL(a);
	}).catch(function(a) {
		console.warn("NunuStudio: No webcam available");
	});
	THREE.Texture.call(this, g, a, f, l, THREE.LinearFilter, THREE.LinearFilter, THREE.RGBFormat, h, c);
	this.disposed = this.generateMipmaps = !1;
	this.name = "webcam";
	this.category = "Webcam";
	var q = this;
	e();
}
WebcamTexture.prototype = Object.create(THREE.Texture.prototype);
WebcamTexture.prototype.dispose = function() {
	THREE.Texture.prototype.dispose.call(this);
	this.disposed = !0;
	this.image.paused || this.image.pause();
};
function Texture(a, f, l, b, k, h, c, e, g, q) {
	this.img = "string" === typeof a ? new Image(a) : a;
	THREE.Texture.call(this, document.createElement("img"), f, l, b, k, h, c, e, g, q);
	var r = this;
	this.disposed = !1;
	this.name = "texture";
	this.category = "Image";
	this.image.src = this.img.data;
	this.image.onload = function() {
		r.needsUpdate = !0;
	};
	if ("gif" === this.img.encoding) {
		var w = function() {
			r.disposed || (r.needsUpdate = !0, requestAnimationFrame(w));
		};
		w();
	}
}
Texture.prototype = Object.create(THREE.Texture.prototype);
Texture.prototype.dispose = function() {
	THREE.Texture.prototype.dispose.call(this);
	this.disposed = !0;
};
Texture.prototype.toJSON = function(a) {
	var f = THREE.Texture.prototype.toJSON.call(this, a);
	a = this.img.toJSON(a);
	f.image = a.uuid;
	return f;
};
function FontLoader(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}
FontLoader.prototype.load = function(a, f, l, b) {
	(new THREE.XHRLoader(this.manager)).load(a, function(a) {
		f(new Font(JSON.parse(a)));
	}, l, b);
};
FontLoader.prototype.parse = function(a) {
	if (void 0 !== a.data) {
		var f = new Font;
		f.name = a.name;
		f.uuid = a.uuid;
		f.encoding = a.encoding;
		"base64" === a.format ? (f.format = "arraybuffer", f.data = ArraybufferUtils.fromBase64(a.data), f.font = (new TTFLoader).parse(f.data)) : (f.format = a.format, f.data = a.data, f.font = a.data);
		return f;
	}
	return new Font(a);
};
function ImageLoader(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}
ImageLoader.prototype.load = function(a, f, l, b) {
	var k = this;
	(new THREE.XHRLoader(this.manager)).load(a, function(a) {
		k.parse(JSON.parse(a), f);
	}, l, b);
};
ImageLoader.prototype.parse = function(a, f) {
	f = new Image;
	f.name = a.name;
	f.uuid = a.uuid;
	f.format = a.format;
	f.encoding = a.encoding;
	f.data = a.data;
	return f;
};
function VideoLoader(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}
VideoLoader.prototype.load = function(a, f, l, b) {
	var k = this;
	(new THREE.XHRLoader(this.manager)).load(a, function(a) {
		k.parse(JSON.parse(a), f);
	}, l, b);
};
VideoLoader.prototype.parse = function(a, f) {
	f = new Video;
	f.name = a.name;
	f.uuid = a.uuid;
	f.format = a.format;
	f.encoding = a.encoding;
	f.data = a.data;
	return f;
};
function AudioLoader(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}
AudioLoader.prototype.load = function(a, f, l, b) {
	(new THREE.XHRLoader(this.manager)).load(a, function(a) {
		self.parse(JSON.parse(a), f);
	}, l, b);
};
AudioLoader.prototype.parse = function(a) {
	var f = new Audio;
	f.name = a.name;
	f.uuid = a.uuid;
	f.encoding = a.encoding;
	f.format = "arraybuffer";
	f.data = ArraybufferUtils.fromBase64(a.data);
	return f;
};
function TextureLoader(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
	this.images = [];
	this.videos = [];
	this.fonts = [];
}
TextureLoader.prototype.load = function(a, f, l, b) {
	var k = this;
	(new THREE.XHRLoader(this.manager)).load(a, function(a) {
		k.parse(JSON.parse(a), f);
	}, l, b);
};
TextureLoader.prototype.parse = function(a, f) {
	var l;
	l = a.category;
	"Video" === l ? (void 0 === a.video && console.warn("TextureLoader: No video specified for", a.uuid), void 0 === this.videos[a.video] && console.warn("TextureLoader: Undefined video", a.video), l = new VideoTexture(this.videos[a.video])) : "Webcam" === l ? l = new WebcamTexture : "Canvas" === l ? l = new CanvasTexture(a.width, a.height) : (void 0 === a.image && console.warn("TextureLoader: No image specified for", a.uuid), void 0 === this.images[a.image] && console.warn("TextureLoader: Undefined image", 
	a.image), l = new Texture(this.images[a.image]));
	l.uuid = a.uuid;
	l.name = a.name;
	l.mapping = a.mapping;
	l.offset = new THREE.Vector2(a.offset[0], a.offset[1]);
	l.repeat = new THREE.Vector2(a.repeat[0], a.repeat[1]);
	l.wrapS = a.wrap[0];
	l.wrapT = a.wrap[1];
	l.minFilter = a.minFilter;
	l.magFilter = a.magFilter;
	l.anisotropy = a.anisotropy;
	l.flipY = a.flipY;
	void 0 !== f && f(l);
	return l;
};
TextureLoader.prototype.setImages = function(a) {
	this.images = a;
	return this;
};
TextureLoader.prototype.setVideos = function(a) {
	this.videos = a;
	return this;
};
TextureLoader.prototype.setFonts = function(a) {
	this.fonts = a;
	return this;
};
function ObjectLoader(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
	this.texturePath = "";
}
ObjectLoader.prototype.load = function(a, f, l, b) {
	"" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
	var k = this;
	(new THREE.XHRLoader(this.manager)).load(a, function(a) {
		k.parse(JSON.parse(a), f);
	}, l, b);
};
ObjectLoader.prototype.parse = function(a, f) {
	var l = this.parseGeometries(a.geometries), b = this.parseImages(a.images), k = this.parseVideos(a.videos), h = this.parseAudio(a.audio), c = this.parseFonts(a.fonts), b = this.parseTextures(a.textures, b, k), k = this.parseMaterials(a.materials, b), l = this.parseObject(a.object, l, k, b, h, c);
	a.animations && (l.animations = this.parseAnimations(a.animations));
	void 0 !== a.images && 0 !== a.images.length || void 0 === f || f(l);
	return l;
};
ObjectLoader.prototype.setTexturePath = function(a) {
	this.texturePath = a;
};
ObjectLoader.prototype.setCrossOrigin = function(a) {
	this.crossOrigin = a;
};
ObjectLoader.prototype.parseGeometries = function(a) {
	var f = [];
	if (void 0 !== a) {
		for (var l = new THREE.JSONLoader, b = new THREE.BufferGeometryLoader, k = 0;k < a.length;k++) {
			var h, c = a[k];
			switch(c.type) {
				case "PlaneGeometry":
				;
				case "PlaneBufferGeometry":
					h = new THREE[c.type](c.width, c.height, c.widthSegments, c.heightSegments);
					break;
				case "BoxGeometry":
				;
				case "BoxBufferGeometry":
				;
				case "CubeGeometry":
					h = new THREE[c.type](c.width, c.height, c.depth, c.widthSegments, c.heightSegments, c.depthSegments);
					break;
				case "CircleGeometry":
				;
				case "CircleBufferGeometry":
					h = new THREE[c.type](c.radius, c.segments, c.thetaStart, c.thetaLength);
					break;
				case "CylinderGeometry":
				;
				case "CylinderBufferGeometry":
					h = new THREE[c.type](c.radiusTop, c.radiusBottom, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
					break;
				case "ConeGeometry":
				;
				case "ConeBufferGeometry":
					h = new THREE[c.type](c.radius, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
					break;
				case "SphereGeometry":
				;
				case "SphereBufferGeometry":
					h = new THREE[c.type](c.radius, c.widthSegments, c.heightSegments, c.phiStart, c.phiLength, c.thetaStart, c.thetaLength);
					break;
				case "DodecahedronGeometry":
				;
				case "IcosahedronGeometry":
				;
				case "OctahedronGeometry":
				;
				case "TetrahedronGeometry":
					h = new THREE[c.type](c.radius, c.detail);
					break;
				case "RingGeometry":
				;
				case "RingBufferGeometry":
					h = new THREE[c.type](c.innerRadius, c.outerRadius, c.thetaSegments, c.phiSegments, c.thetaStart, c.thetaLength);
					break;
				case "TorusGeometry":
				;
				case "TorusBufferGeometry":
					h = new THREE[c.type](c.radius, c.tube, c.radialSegments, c.tubularSegments, c.arc);
					break;
				case "TorusKnotGeometry":
				;
				case "TorusKnotBufferGeometry":
					h = new THREE[c.type](c.radius, c.tube, c.tubularSegments, c.radialSegments, c.p, c.q);
					break;
				case "LatheGeometry":
				;
				case "LatheBufferGeometry":
					h = new THREE[c.type](c.points, c.segments, c.phiStart, c.phiLength);
					break;
				case "BufferGeometry":
					h = b.parse(c);
					break;
				case "Geometry":
					h = l.parse(c.data, this.texturePath).geometry;
					break;
				default:
					console.warn("ObjectLoader: Unsupported geometry type " + c.type);
					continue;
			}
			h.uuid = c.uuid;
			h.name = void 0 !== c.name ? c.name : "geometry";
			f[c.uuid] = h;
		}
	}
	return f;
};
ObjectLoader.prototype.parseMaterials = function(a, f) {
	var l = [], b = new THREE.MaterialLoader;
	b.setTextures(f);
	if (void 0 !== a) {
		for (f = 0;f < a.length;f++) {
			var k = b.parse(a[f]);
			l[k.uuid] = k;
		}
	}
	return l;
};
ObjectLoader.prototype.parseAnimations = function(a) {
	for (var f = [], l = 0;l < a.length;l++) {
		var b = THREE.AnimationClip.parse(a[l]);
		f.push(b);
	}
	return f;
};
ObjectLoader.prototype.parseImages = function(a) {
	var f = new ImageLoader, l = [];
	if (void 0 !== a) {
		for (var b = 0;b < a.length;b++) {
			l[a[b].uuid] = f.parse(a[b]);
		}
	}
	return l;
};
ObjectLoader.prototype.parseVideos = function(a) {
	var f = new VideoLoader, l = [];
	if (void 0 !== a) {
		for (var b = 0;b < a.length;b++) {
			l[a[b].uuid] = f.parse(a[b]);
		}
	}
	return l;
};
ObjectLoader.prototype.parseAudio = function(a) {
	var f = new AudioLoader, l = [];
	if (void 0 !== a) {
		for (var b = 0;b < a.length;b++) {
			l[a[b].uuid] = f.parse(a[b]);
		}
	}
	return l;
};
ObjectLoader.prototype.parseFonts = function(a) {
	var f = new FontLoader, l = [];
	if (void 0 !== a) {
		for (var b = 0;b < a.length;b++) {
			l[a[b].uuid] = f.parse(a[b]);
		}
	}
	return l;
};
ObjectLoader.prototype.parseTextures = function(a, f, l) {
	var b = new TextureLoader;
	b.setImages(f);
	b.setVideos(l);
	f = [];
	if (void 0 !== a) {
		for (l = 0;l < a.length;l++) {
			var k = b.parse(a[l]);
			f[k.uuid] = k;
		}
	}
	return f;
};
ObjectLoader.prototype.parseObject = function(a, f, l, b, k, h) {
	function c(a) {
		void 0 === b[a] && console.warn("ObjectLoader: Undefined texture", a);
		return b[a];
	}
	function e(a) {
		void 0 === f[a] && console.warn("ObjectLoader: Undefined geometry", a);
		return f[a];
	}
	function g(a) {
		void 0 === l[a] && console.warn("ObjectLoader: Undefined material", a);
		return l[a];
	}
	function q(a) {
		void 0 === h[a] && console.warn("ObjectLoader: Undefined font", a);
		return h[a];
	}
	function r(a) {
		void 0 === k[a] && console.warn("ObjectLoader: Undefined audio", a);
		return k[a];
	}
	var w = new THREE.Matrix4, p;
	switch(a.type) {
		case "SpineAnimation":
			for (var t = 0;t < a.textures.length;t++) {
				a.textures[t].texture = c(a.textures[t].texture);
			}
			p = new SpineAnimation(a.json, a.atlas, "", a.textures);
			break;
		case "Audio":
			p = new AudioEmitter(r(a.audio));
			p.autoplay = a.autoplay;
			p.startTime = a.startTime;
			p.playbackRate = a.playbackRate;
			p.loop = void 0 !== a.source ? a.source.loop : a.loop;
			break;
		case "Physics":
			p = new PhysicsObject;
			p.body.type = a.body.type;
			p.body.mass = a.body.mass;
			p.body.linearDamping = a.body.linearDamping;
			p.body.angularDamping = a.body.angularDamping;
			p.body.allowSleep = a.body.allowSleep;
			p.body.sleepSpeedLimit = a.body.sleepSpeedLimit;
			p.body.sleepTimeLimit = a.body.sleepTimeLimit;
			p.body.collisionFilterGroup = a.body.collisionFilterGroup;
			p.body.collisionFilterMask = a.body.collisionFilterMask;
			p.body.fixedRotation = a.body.fixedRotation;
			for (var v = a.body.shapes, t = 0;t < v.length;t++) {
				var y = v[t];
				y.type === CANNON.Shape.types.SPHERE ? p.body.addShape(new CANNON.Sphere(y.radius)) : y.type === CANNON.Shape.types.BOX ? p.body.addShape(new CANNON.Box(new CANNON.Vec3(y.halfExtents.x, y.halfExtents.y, y.halfExtents.z))) : y.type === CANNON.Shape.types.PARTICLE ? p.body.addShape(new CANNON.Particle) : y.type === CANNON.Shape.types.PLANE ? p.body.addShape(new CANNON.Plane) : y.type === CANNON.Shape.types.CONVEXPOLYHEDRON && p.body.addShape(new CANNON.ConvexPolyhedron(y.vertices, y.faces));
			}
			break;
		case "ParticleEmiter":
			void 0 !== a.group && (p = a.group, p.texture.value = c(p.texture.value), p.textureFrames = THREE.Vector2(p.textureFrames));
			if (void 0 !== a.emitter) {
				for (p = a.emitter, p.position.value = THREE.Vector3.fromJSON(p.position.value), p.position.spread = THREE.Vector3.fromJSON(p.position.spread), p.velocity.value = THREE.Vector3.fromJSON(p.velocity.value), p.velocity.spread = THREE.Vector3.fromJSON(p.velocity.spread), p.acceleration.value = THREE.Vector3.fromJSON(p.acceleration.value), p.acceleration.spread = THREE.Vector3.fromJSON(p.acceleration.spread), t = 0;t < p.color.value.length;t++) {
					p.color.value[t] = new THREE.Color(p.color.value[t]), p.color.spread[t] = THREE.Vector3.fromJSON(p.color.spread[t]);
				}
			}
			p = new ParticleEmitter(a.group, a.emitter);
			break;
		case "Text3D":
			p = new Text3D(a.text, g(a.material), q(a.font), a.height, a.bevel, a.bevel_thickness, a.bevel_size, a.size, a.curve_segments);
			break;
		case "Program":
			p = new Program(a.name);
			p.description = a.description;
			p.author = a.author;
			p.version = a.version;
			p.vr = a.vr;
			p.vr_scale = a.vr_scale;
			void 0 !== a.lock_pointer && (p.lock_pointer = a.lock_pointer);
			void 0 !== a.default_scene && (p.default_scene = a.default_scene);
			break;
		case "LeapDevice":
			p = new LeapMotion;
			p.mode = a.mode;
			p.use_arm = a.use_arm;
			void 0 !== a.debug_model && (p.debug_model = a.debug_model);
			void 0 !== a.gestures_enabled && (p.gestures_enabled = a.gestures_enabled);
			void 0 !== a.poses_enabled && (p.poses_enabled = a.poses_enabled);
			break;
		case "Kinect":
			p = new KinectDevice;
			void 0 !== a.debug_model && (p.debug_model = a.debug_model);
			break;
		case "Sky":
			p = new Sky(a.auto_update, a.day_time, a.sun_distance, a.time);
			void 0 !== a.sun && p.sun.shadow.fromJSON(a.sun.shadow);
			break;
		case "Scene":
			p = new Scene;
			void 0 !== a.background && Number.isInteger(a.background) && (p.background = new THREE.Color(a.background));
			void 0 !== a.fog && ("Fog" === a.fog.type ? p.fog = new THREE.Fog(a.fog.color, a.fog.near, a.fog.far) : "FogExp2" === a.fog.type && (p.fog = new THREE.FogExp2(a.fog.color, a.fog.density)));
			void 0 !== a.cameras && (p.cameras = a.cameras);
			void 0 !== a.world && p.world.gravity.set(a.world.gravity.x, a.world.gravity.y, a.world.gravity.z);
			break;
		case "PerspectiveCamera":
			p = new PerspectiveCamera(a.fov, a.aspect, a.near, a.far);
			void 0 !== a.focus && (p.focus = a.focus);
			void 0 !== a.zoom && (p.zoom = a.zoom);
			void 0 !== a.filmGauge && (p.filmGauge = a.filmGauge);
			void 0 !== a.filmOffset && (p.filmOffset = a.filmOffset);
			void 0 !== a.view && (p.view = Object.assign({}, a.view));
			void 0 !== a.viewport && p.viewport.fromArray(a.viewport);
			void 0 !== a.offset && p.offset.fromArray(a.offset);
			void 0 !== a.clear_color && (p.clear_color = a.clear_color);
			void 0 !== a.clear_depth && (p.clear_depth = a.clear_depth);
			break;
		case "OrthographicCamera":
			p = new OrthographicCamera(a.size, a.aspect, a.mode, a.near, a.far);
			void 0 !== a.viewport && p.viewport.fromArray(a.viewport);
			void 0 !== a.offset && p.offset.fromArray(a.offset);
			void 0 !== a.clear_color && (p.clear_color = a.clear_color);
			void 0 !== a.clear_depth && (p.clear_depth = a.clear_depth);
			break;
		case "Script":
			p = new Script(a.code);
			break;
		case "RectAreaLight":
			p = new RectAreaLight(a.color, a.intensity, a.width, a.height);
			break;
		case "AmbientLight":
			p = new AmbientLight(a.color, a.intensity);
			break;
		case "DirectionalLight":
			p = new DirectionalLight(a.color, a.intensity);
			break;
		case "PointLight":
			p = new PointLight(a.color, a.intensity, a.distance, a.decay);
			break;
		case "SpotLight":
			p = new SpotLight(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay);
			break;
		case "HemisphereLight":
			p = new HemisphereLight(a.color, a.groundColor, a.intensity);
			break;
		case "Mesh":
			p = new Mesh(e(a.geometry), g(a.material));
			break;
		case "SkinnedMesh":
			p = new SkinnedMesh(e(a.geometry), g(a.material));
			break;
		case "LOD":
			p = new THREE.LOD;
			break;
		case "Line":
			p = new THREE.Line(e(a.geometry), g(a.material), a.mode);
			break;
		case "PointCloud":
		;
		case "Points":
			p = new THREE.Points(e(a.geometry), g(a.material));
			break;
		case "Sprite":
			p = new Sprite(g(a.material));
			break;
		case "Group":
			p = new Container;
			break;
		case "Bone":
			p = new Bone;
			break;
		default:
			p = new Container;
	}
	p.uuid = a.uuid;
	void 0 !== a.name && (p.name = a.name);
	void 0 !== a.hidden && (p.hidden = a.hidden);
	void 0 !== a.folded && (p.folded = a.folded);
	void 0 !== a.matrix ? (w.fromArray(a.matrix), w.decompose(p.position, p.quaternion, p.scale)) : (void 0 !== a.position && p.position.fromArray(a.position), void 0 !== a.rotation && p.rotation.fromArray(a.rotation), void 0 !== a.scale && p.scale.fromArray(a.scale));
	void 0 !== a.castShadow && (p.castShadow = a.castShadow);
	void 0 !== a.receiveShadow && (p.receiveShadow = a.receiveShadow);
	void 0 !== a.shadow && p.shadow.fromJSON(a.shadow);
	void 0 !== a.visible && (p.visible = a.visible);
	void 0 !== a.userData && (p.userData = a.userData);
	if (void 0 !== a.children) {
		for (var x in a.children) {
			p.add(this.parseObject(a.children[x], f, l, b, k, h));
		}
	}
	void 0 !== a.matrixAutoUpdate && (p.matrixAutoUpdate = a.matrixAutoUpdate, p.matrixAutoUpdate || (p.updateMatrix(), p.updateMatrixWorld(!0)));
	if ("Program" === a.type) {
		p.materials = l, p.textures = b, p.fonts = h, p.audio = k;
	} else {
		if ("Scene" === a.type) {
			for (t = 0;t < p.cameras.length;t++) {
				x = p.getCamera(p.cameras[t]), null !== x ? p.cameras[t] = x : p.cameras.splice(t, 1);
			}
		} else {
			if ("LOD" === a.type) {
				for (a = a.levels, w = 0;w < a.length;w++) {
					t = a[w], x = p.getObjectByProperty("uuid", t.object), void 0 !== x && p.addLevel(x, t.distance);
				}
			}
		}
	}
	return p;
};
function TTFLoader(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
	this.reversed = !1;
}
TTFLoader.prototype.load = function(a, f, l, b) {
	var k = this, h = new THREE.XHRLoader(this.manager);
	h.setResponseType("arraybuffer");
	h.load(a, function(a) {
		a = k.parse(a);
		void 0 !== f && f(a);
	}, l, b);
};
TTFLoader.prototype.parse = function(a) {
	a = opentype.parse(a);
	return TTFLoader.convert(a, this.reversed);
};
TTFLoader.convert = function(a, f) {
	for (var l = 1E5 / (72 * (a.unitsPerEm || 2048)), b = {glyphs:{}}, k = 0;k < a.glyphs.length;k++) {
		var h = a.glyphs.glyphs[k];
		if (void 0 !== h.unicode) {
			var c = {};
			c.ha = Math.round(h.advanceWidth * l);
			c.x_min = Math.round(h.xMin * l);
			c.x_max = Math.round(h.xMax * l);
			c.o = "";
			f && (h.path.commands = TTFLoader.reverseCommands(h.path.commands));
			h.path.commands.forEach(function(a, b) {
				"c" === a.type.toLowerCase() && (a.type = "b");
				c.o += a.type.toLowerCase();
				c.o += " ";
				void 0 !== a.x && void 0 !== a.y && (c.o += Math.round(a.x * l), c.o += " ", c.o += Math.round(a.y * l), c.o += " ");
				void 0 !== a.x1 && void 0 !== a.y1 && (c.o += Math.round(a.x1 * l), c.o += " ", c.o += Math.round(a.y1 * l), c.o += " ");
				void 0 !== a.x2 && void 0 !== a.y2 && (c.o += Math.round(a.x2 * l), c.o += " ", c.o += Math.round(a.y2 * l), c.o += " ");
			});
			b.glyphs[String.fromCharCode(h.unicode)] = c;
		}
	}
	b.resolution = 1E3;
	b.original_font_information = a.names;
	b.unitsPerEm = a.unitsPerEm;
	b.ascender = Math.round(a.ascender * l);
	b.descender = Math.round(a.descender * l);
	b.underlinePosition = a.tables.post.underlinePosition;
	b.underlineThickness = a.tables.post.underlineThickness;
	b.boundingBox = {yMin:a.tables.head.yMin, xMin:a.tables.head.xMin, yMax:a.tables.head.yMax, xMax:a.tables.head.xMax};
	return b;
};
TTFLoader.reverseCommands = function(a) {
	var f = [], l;
	a.forEach(function(a) {
		"m" === a.type.toLowerCase() ? (l = [a], f.push(l)) : "z" !== a.type.toLowerCase() && l.push(a);
	});
	var b = [];
	f.forEach(function(a) {
		var f = {type:"m", x:a[a.length - 1].x, y:a[a.length - 1].y};
		b.push(f);
		for (var c = a.length - 1;0 < c;c--) {
			var e = a[c], f = {type:e.type};
			void 0 !== e.x2 && void 0 !== e.y2 ? (f.x1 = e.x2, f.y1 = e.y2, f.x2 = e.x1, f.y2 = e.y1) : void 0 !== e.x1 && void 0 !== e.y1 && (f.x1 = e.x1, f.y1 = e.y1);
			f.x = a[c - 1].x;
			f.y = a[c - 1].y;
			b.push(f);
		}
	});
	return b;
};
function LeapMotion() {
	THREE.Object3D.call(this);
	this.type = "LeapDevice";
	this.name = "leap";
	this.poses_enabled = this.gestures_enabled = this.debug_model = !0;
	this.mode = LeapMotion.DESK;
	this.use_arm = !1;
	this.bone_meshes = [];
	this.arm_meshes = [];
	this.material = new THREE.MeshPhongMaterial;
	this.geometry = new THREE.BoxBufferGeometry(1, 1, 1);
	this.physics_world = null;
	this.physics_bodys = [];
	this.gesture = [];
	for (var a = 0;10 > a;a++) {
		this.gesture[a] = !1;
	}
	this.pose = [];
	for (a = 0;3 > a;a++) {
		this.pose[a] = !1;
	}
	this.data = null;
}
LeapMotion.prototype = Object.create(THREE.Object3D.prototype);
LeapMotion.DESK = 0;
LeapMotion.HDM = 1;
LeapMotion.SWIPE = 0;
LeapMotion.SWIPE_LEFT = 1;
LeapMotion.SWIPE_RIGHT = 2;
LeapMotion.SWIPE_FRONT = 3;
LeapMotion.SWIPE_BACK = 4;
LeapMotion.SWIPE_UP = 5;
LeapMotion.SWIPE_DOWN = 6;
LeapMotion.CIRCLE = 7;
LeapMotion.SCREEN_TAP = 8;
LeapMotion.KEY_TAP = 9;
LeapMotion.CLOSED = 0;
LeapMotion.OPEN = 1;
LeapMotion.POINTING = 2;
LeapMotion.prototype.initialize = function() {
	var a = this;
	Leap.loop({background:!0}, function(f) {
		a.data = f;
	}).connect();
	for (var f = 0;f < this.children.length;f++) {
		this.children[f].initialize();
	}
};
LeapMotion.prototype.update = function() {
	null !== this.data && (this.gestures_enabled && this.updateGestures(), this.poses_enabled && this.updatePoses(), this.debug_model && this.updateDebugModel());
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].update();
	}
};
LeapMotion.prototype.checkGesture = function(a) {
	return void 0 !== this.gesture[a] ? this.gesture[a] : !1;
};
LeapMotion.prototype.checkPose = function(a) {
	return void 0 !== this.pose[a] ? this.pose[a] : !1;
};
LeapMotion.prototype.setMode = function(a) {
	this.mode = a;
};
LeapMotion.prototype.updatePoses = function() {
	for (var a = 0;a < this.pose.length;a++) {
		this.pose[a] = !0;
	}
	for (var f = 0;f < this.data.hands.length;f++) {
		for (var l = this.data.hands[f], b = l.sphereCenter, b = new THREE.Vector3(b[0], b[1], b[2]), k = [], h = 0, c, a = 0;a < this.pose.length;a++) {
			this.pose[a] = !0;
		}
		for (var e = [], a = 0;a < l.fingers.length;a++) {
			c = l.fingers[a], e.push(c.direction), c = c.distal.nextJoint, c = new THREE.Vector3(c[0], c[1], c[2]), k.push(b.distanceTo(c) / l._scaleFactor), 0 !== a && (.3 > e[a][2] && (this.pose[LeapMotion.CLOSED] = !1), -.5 < e[a][2] && (this.pose[LeapMotion.OPEN] = !1), 1 === a ? h = k[1] : h < 2 * k[a] - 15 && (this.pose[LeapMotion.POINTING] = !1));
		}
		h < 2 * k[0] - 15 && (this.pose[LeapMotion.POINTING] = !1);
	}
};
LeapMotion.prototype.updateGestures = function() {
	for (var a = 0;a < this.gesture.length;a++) {
		this.gesture[a] = !1;
	}
	var f = this;
	this.data.valid && 0 < this.data.gestures.length && this.data.gestures.forEach(function(a) {
		"swipe" === a.type ? (f.gesture[LeapMotion.SWIPE] = !0, 0 < a.direction[0] ? f.gesture[LeapMotion.SWIPE_RIGHT] = !0 : f.gesture[LeapMotion.SWIPE_LEFT] = !0, 0 < a.direction[1] ? f.gesture[LeapMotion.SWIPE_UP] = !0 : f.gesture[LeapMotion.SWIPE_DOWN] = !0, 0 < a.direction[2] ? f.gesture[LeapMotion.SWIPE_FRONT] = !0 : f.gesture[LeapMotion.SWIPE_BACK] = !0) : "circle" === a.type ? f.gesture[LeapMotion.CIRCLE] = !0 : "keyTap" === a.type ? f.gesture[LeapMotion.KEY_TAP] = !0 : "screenTap" === a.type && 
		(f.gesture[LeapMotion.SCREEN_TAP] = !0);
	});
};
LeapMotion.prototype.updateDebugModel = function() {
	var a = this;
	this.arm_meshes.forEach(function(b) {
		a.remove(b);
	});
	this.bone_meshes.forEach(function(b) {
		a.remove(b);
	});
	for (var f = 0, l = 0, b = 0;b < this.data.hands.length;b++) {
		for (var k = this.data.hands[b], h = 0;h < k.fingers.length;h++) {
			for (var c = k.fingers[h], e = 0;e < c.bones.length;e++) {
				var g = c.bones[e];
				if (0 !== f) {
					var q = this.bone_meshes[f] || this.addMesh(this.bone_meshes);
					this.updateMesh(g, q);
				}
				f++;
			}
		}
		this.show_arm && (k = k.arm, h = this.arm_meshes[l++] || this.addMesh(this.arm_meshes), this.updateMesh(k, h), h.scale.set(k.width / 1200, k.width / 300, k.length / 150));
	}
	null !== this.physics_world && this.updatePhysics();
};
LeapMotion.prototype.updatePhysics = function() {
	for (var a = 0;a < this.physics_bodys.length;a++) {
		this.physics_world.removeBody(this.physics_bodys[a].pop());
	}
	this.children.forEach(function(a, l) {
		a = new THREE.BoundingBoxHelper(a);
		a.update();
		l = new THREE.Vector3(a.box.max.x - a.box.min.x, a.box.max.y - a.box.min.y, a.box.max.z - a.box.min.z);
		l.x *= this.scale.x;
		l.y *= this.scale.y;
		l.z *= this.scale.z;
		l.divideScalar(2);
		a = a.box.center();
		a.x *= this.scale.x;
		a.y *= this.scale.y;
		a.z *= this.scale.z;
		a.add(this.position);
		l = new CANNON.Box(new CANNON.Vec3(l.x, l.y, l.z));
		var b = new CANNON.Body({mass:0});
		b.addShape(l);
		b.position.set(a.x - this.position.x, a.y - this.position.y, a.z - this.position.z);
		b.updateMassProperties();
		this.physics_bodys.push(b);
		this.physics_world.addBody(b);
	});
};
LeapMotion.prototype.addMesh = function(a) {
	var f = new Mesh(this.geometry, this.material);
	f.castShadow = this.castShadow;
	f.receiveShadow = this.receiveShadow;
	a.push(f);
	return f;
};
LeapMotion.prototype.updateMesh = function(a, f) {
	f.position.fromArray(a.center());
	f.position.divideScalar(150);
	f.setRotationFromMatrix((new THREE.Matrix4).fromArray(a.matrix()));
	f.scale.set(a.width / 150, a.width / 150, a.length / 150);
	this.add(f);
};
LeapMotion.prototype.getMovement = function() {
	var a = this.data.gestures[0].position, f = this.data.gestures[0].startPosition, a = new THREE.Vector3(a[0] - f[0], a[1] - f[1], a[2] - f[2]);
	a.divideScalar(this.data.currentFrameRate);
	return a;
};
LeapMotion.prototype.toJSON = function(a) {
	a = THREE.Object3D.prototype.toJSON.call(this, a);
	a.object.type = this.type;
	a.object.debug_model = this.debug_model;
	a.object.gestures_enabled = this.gestures_enabled;
	a.object.poses_enabled = this.poses_enabled;
	a.object.mode = this.mode;
	a.object.use_arm = this.use_arm;
	return a;
};
function KinectDevice() {
	THREE.Object3D.call(this);
	this.type = "Kinect";
	this.name = "kinect";
	this.socket = new WebSocket("ws://127.0.0.1:8181");
	this.connected = !1;
	this.debug_model = !0;
	this.data_timeout = 0;
	this.data = this.camera = null;
	this.data_received = !1;
	var a = this;
	this.socket.onopen = function() {
		a.connected = !0;
	};
	this.socket.onclose = function() {
		a.connected = !1;
	};
	this.socket.onmessage = function(f) {
		"string" === typeof f.data ? (a.data = JSON.parse(f.data), a.data_received = !0, a.data_timeout = KinectDevice.DATA_TIMEOUT) : f.data instanceof Blob && (a.camera = f.data);
	};
}
KinectDevice.DATA_TIMEOUT = 20;
KinectDevice.DEPTH = 0;
KinectDevice.COLOR = 1;
KinectDevice.JOINTS_NAME = [["head", "shouldercenter"], ["shouldercenter", "shoulderright"], ["shouldercenter", "shoulderleft"], ["shoulderright", "elbowright"], ["shoulderleft", "elbowleft"], ["elbowright", "wristright"], ["elbowleft", "wristleft"], ["wristright", "handright"], ["wristleft", "handleft"], ["shouldercenter", "spine"], ["spine", "hipcenter"], ["hipcenter", "hipright"], ["hipcenter", "hipleft"], ["hipright", "kneeright"], ["hipleft", "kneeleft"], ["kneeright", "ankleright"], ["kneeleft", 
"ankleleft"], ["ankleright", "footright"], ["ankleleft", "footleft"]];
KinectDevice.prototype = Object.create(THREE.Object3D.prototype);
KinectDevice.prototype.update = function() {
	if (null !== this.data) {
		if (this.data_received) {
			for (this.data_received = !1;0 < this.children.length;) {
				this.children.pop();
			}
			if (this.debug_model) {
				for (var a = new THREE.SphereGeometry(.04, 6, 6), f = new THREE.MeshPhongMaterial(16711680), l = 0;l < this.data.skeletons.length;l++) {
					for (var b = this.data.skeletons[l].joints, k = 0;k < b.length;k++) {
						var h = new Mesh(a, f);
						h.position.set(b[k].x, b[k].y, b[k].z);
						h.castShadow = !0;
						this.add(h);
					}
				}
			}
		} else {
			if (0 < this.data_timeout && (this.data_timeout--, 0 === this.data_timeout)) {
				for (;0 < this.children.length;) {
					this.children.pop();
				}
			}
		}
	}
	for (k = 0;k < this.children.length;k++) {
		this.children[k].update();
	}
};
KinectDevice.prototype.isConnected = function() {
	return this.connected;
};
KinectDevice.prototype.setCameraMode = function(a) {
	a === KinectDevice.COLOR ? socket.send("Color") : a === KinectDevice.DEPTH && socket.send("Depth");
};
KinectDevice.prototype.toJSON = function(a) {
	a = THREE.Object3D.prototype.toJSON.call(this, a);
	a.object.debug_model = this.debug_model;
	return a;
};
function Mesh(a, f) {
	THREE.Mesh.call(this, a, f);
	this.name = "model";
	this.castShadow = this.receiveShadow = !0;
}
Mesh.prototype = Object.create(THREE.Mesh.prototype);
Mesh.prototype.dispose = function() {
	null !== this.material && void 0 !== this.material.dispose && this.material.dispose();
	this.geometry.dispose();
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].dispose();
	}
};
function SkinnedMesh(a, f, l) {
	THREE.SkinnedMesh.call(this, a, f, l);
	this.name = "model";
	this.castShadow = this.receiveShadow = !0;
}
SkinnedMesh.prototype = Object.create(THREE.SkinnedMesh.prototype);
SkinnedMesh.prototype.dispose = function() {
	null !== this.material && void 0 !== this.material.dispose && this.material.dispose();
	this.geometry.dispose();
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].dispose();
	}
};
function Text3D(a, f, l, b, k, h, c, e, g) {
	THREE.Mesh.call(this, void 0, f);
	this.name = "text";
	this.type = "Text3D";
	this.font = l;
	this.text = void 0 !== a ? a : "text";
	this.size = void 0 !== e ? e : 1;
	this.height = void 0 !== b ? b : .5;
	this.curve_segments = void 0 !== g ? g : 15;
	this.bevel = void 0 !== k ? k : !1;
	this.bevel_thickness = void 0 !== h ? h : .1;
	this.bevel_size = void 0 !== c ? c : .05;
	this.setText(this.text);
	this.castShadow = this.receiveShadow = !0;
}
Text3D.prototype = Object.create(THREE.Mesh.prototype);
Text3D.prototype.setFont = function(a) {
	this.font = a;
	this.setText();
};
Text3D.prototype.setText = function(a) {
	void 0 !== a && (this.text = a);
	void 0 !== this.geometry && this.geometry.dispose();
	this.geometry = new THREE.TextGeometry(this.text, {size:this.size, curveSegments:this.curve_segments, font:this.font, height:this.height, bevelEnabled:this.bevel, bevelSize:this.bevel_size, bevelThickness:this.bevel_thickness});
};
Text3D.prototype.dispose = function() {
	void 0 !== this.material.dispose && this.material.dispose();
	void 0 !== this.geometry && this.geometry.dispose();
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].dispose();
	}
};
Text3D.prototype.toJSON = function(a) {
	var f = this.geometry;
	this.geometry = void 0;
	var l = this.font;
	a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, f) {
		l = l.toJSON(a);
	});
	a.object.text = this.text;
	a.object.font = l.uuid;
	a.object.size = this.size;
	a.object.curve_segments = this.curve_segments;
	a.object.height = this.height;
	a.object.bevel = this.bevel;
	a.object.bevel_thickness = this.bevel_thickness;
	a.object.bevel_size = this.bevel_size;
	this.geometry = f;
	return a;
};
function Sprite(a) {
	THREE.Sprite.call(this, a);
	this.name = "sprite";
	this.type = "Sprite";
}
Sprite.prototype = Object.create(THREE.Sprite.prototype);
Sprite.prototype.dispose = function() {
	null !== this.material && void 0 !== this.material.dispose && this.material.dispose();
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].dispose();
	}
};
function TextSprite(a, f) {
	THREE.TextSprite.call(this, new THREE.SpriteMaterial({color:16777215}));
	this.name = "sprite";
	this.type = "TextSprite";
	this.font = f;
	this.text = a;
}
TextSprite.prototype = Object.create(THREE.Sprite.prototype);
TextSprite.prototype.setFont = function(a) {
	this.font = a;
	this.setText();
};
TextSprite.prototype.setText = function(a) {
	void 0 !== a && (this.text = a);
};
TextSprite.prototype.dispose = function() {
	null !== this.material && void 0 !== this.material.dispose && this.material.dispose();
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].dispose();
	}
};
TextSprite.prototype.toJSON = function(a) {
	var f = this.material;
	this.material = void 0;
	var l = this.font;
	a = THREE.Sprite.prototype.toJSON.call(this, a, function(a, f) {
		l = l.toJSON(a);
	});
	a.object.text = this.text;
	a.object.font = l.uuid;
	this.material = f;
	return a;
};
function PointLight(a, f, l, b) {
	THREE.PointLight.call(this, a, f, l, b);
	this.name = "point light";
	this.castShadow = !0;
	this.shadow.camera.near = .05;
	this.shadow.camera.far = 5E3;
	this.shadow.bias = .01;
}
PointLight.prototype = Object.create(THREE.PointLight.prototype);
PointLight.prototype.updateShadowMap = function() {
	this.shadow.map.dispose();
	this.shadow.map = null;
	this.shadow.camera.updateProjectionMatrix();
};
function SpotLight(a, f, l, b, k, h) {
	THREE.SpotLight.call(this, a, f, l, b, k, h);
	this.name = "spotlight";
	this.castShadow = !0;
	this.shadow.camera.near = .05;
	this.shadow.camera.far = 5E3;
	this.shadow.mapSize.width = 512;
	this.shadow.mapSize.height = 512;
}
SpotLight.prototype = Object.create(THREE.SpotLight.prototype);
SpotLight.prototype.updateShadowMap = function() {
	this.shadow.map.dispose();
	this.shadow.map = null;
	this.shadow.camera.updateProjectionMatrix();
};
function AmbientLight(a) {
	THREE.AmbientLight.call(this, a);
	this.name = "ambient light";
	this.matrixAutoUpdate = !1;
}
AmbientLight.prototype = Object.create(THREE.AmbientLight.prototype);
function DirectionalLight(a, f) {
	THREE.DirectionalLight.call(this, a, f);
	this.name = "directional light";
	this.castShadow = !0;
	this.shadow.camera.near = .5;
	this.shadow.camera.far = 1E4;
}
DirectionalLight.prototype = Object.create(THREE.DirectionalLight.prototype);
DirectionalLight.prototype.updateShadowMap = function() {
	this.shadow.map.dispose();
	this.shadow.map = null;
	this.shadow.camera.updateProjectionMatrix();
};
function HemisphereLight(a, f, l) {
	THREE.HemisphereLight.call(this, a, f, l);
	this.name = "hemisphere light";
}
HemisphereLight.prototype = Object.create(THREE.HemisphereLight.prototype);
function RectAreaLight(a, f, l, b) {
	THREE.RectAreaLight.call(this, a, f, l, b);
	this.name = "rectarea light";
}
RectAreaLight.prototype = Object.create(THREE.RectAreaLight.prototype);
RectAreaLight.prototype.toJSON = function(a) {
	a = Light.prototype.toJSON.call(this, a);
	a.object.width = this.width;
	a.object.height = this.height;
	return a;
};
function Sky(a, f, l, b) {
	THREE.Object3D.call(this);
	this.name = "sky";
	this.type = "Sky";
	this.clock = new THREE.Clock;
	this.hemisphere = new HemisphereLight(16777215, 16777215, .5);
	this.hemisphere.color.setHSL(.6, 1, .6);
	this.hemisphere.groundColor.setHSL(.1, 1, .75);
	this.hemisphere.position.set(0, 500, 0);
	this.hemisphere.hidden = !0;
	this.hemisphere.matrixAutoUpdate = !1;
	this.add(this.hemisphere);
	this.sun = new DirectionalLight(Sky.sun_color, .3);
	this.sun.castShadow = !0;
	this.sun.hidden = !0;
	this.add(this.sun);
	var k = {top_color:{type:"c", value:new THREE.Color(0, .46, 1)}, bottom_color:{type:"c", value:new THREE.Color(1, 1, 1)}, offset:{type:"f", value:20}, exponent:{type:"f", value:.4}};
	k.top_color.value.copy(this.hemisphere.color);
	var h = new THREE.SphereBufferGeometry(1E3, 16, 16), k = new THREE.ShaderMaterial({vertexShader:"varying vec3 vWorldPosition; \r\tvoid main() \r\t{ \r\t\tvec4 worldPosition = modelMatrix * vec4(position, 1.0); \r\t\tvWorldPosition = worldPosition.xyz; \r\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); \r\t}", fragmentShader:"uniform vec3 top_color; \r\tuniform vec3 bottom_color; \r\tuniform float offset; \r\tuniform float exponent; \r\tvarying vec3 vWorldPosition; \r\tvoid main() \r\t{ \r\t\tfloat h = normalize(vWorldPosition + offset).y; \r\t\tgl_FragColor = vec4(mix(bottom_color, top_color, max(pow(max(h , 0.0), exponent), 0.0)), 1.0); \r\t}", 
	uniforms:k, side:THREE.BackSide});
	this.sky = new THREE.Mesh(h, k);
	this.sky.hidden = !0;
	this.sky.matrixAutoUpdate = !1;
	this.add(this.sky);
	this.sky.raycast = function() {
		return null;
	};
	this.auto_update = void 0 !== a ? a : !0;
	this.sun_distance = void 0 !== l ? l : 500;
	this.day_time = void 0 !== f ? f : 240;
	this.time = void 0 !== b ? b : 150;
	this.updateSky();
}
Sky.prototype = Object.create(THREE.Object3D.prototype);
Sky.color_top = [new THREE.Color(7844859), new THREE.Color(30463), new THREE.Color(220086), new THREE.Color(9273)];
Sky.color_bottom = [new THREE.Color(15461606), new THREE.Color(16777215), new THREE.Color(16705495), new THREE.Color(26023)];
Sky.sun_color = 16777130;
Sky.moon_color = 8947967;
Sky.prototype.initialize = function() {
	this.updateSky();
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].initialize();
	}
};
Sky.prototype.update = function() {
	this.auto_update && (this.time += this.clock.getDelta(), this.time > this.day_time && (this.time -= this.day_time), this.updateSky());
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].update();
	}
};
Sky.prototype.updateSky = function() {
	var a = this.time / this.day_time;
	if (.25 > a) {
		this.sky.material.uniforms.top_color.value.setRGB(Sky.color_top[3].r, Sky.color_top[3].g, Sky.color_top[3].b), this.sky.material.uniforms.bottom_color.value.setRGB(Sky.color_bottom[3].r, Sky.color_bottom[3].g, Sky.color_bottom[3].b);
	} else {
		if (.292 > a) {
			var f = 23.81 * (a - .25), l = 1 - f;
			this.sky.material.uniforms.top_color.value.setRGB(l * Sky.color_top[3].r + f * Sky.color_top[0].r, l * Sky.color_top[3].g + f * Sky.color_top[0].g, l * Sky.color_top[3].b + f * Sky.color_top[0].b);
			this.sky.material.uniforms.bottom_color.value.setRGB(l * Sky.color_bottom[3].r + f * Sky.color_bottom[0].r, l * Sky.color_bottom[3].g + f * Sky.color_bottom[0].g, l * Sky.color_bottom[3].b + f * Sky.color_bottom[0].b);
		} else {
			.4167 > a ? (this.sky.material.uniforms.top_color.value.setRGB(Sky.color_top[0].r, Sky.color_top[0].g, Sky.color_top[0].b), this.sky.material.uniforms.bottom_color.value.setRGB(Sky.color_bottom[0].r, Sky.color_bottom[0].g, Sky.color_bottom[0].b)) : .5 > a ? (f = 12 * (a - .4167), l = 1 - f, this.sky.material.uniforms.top_color.value.setRGB(l * Sky.color_top[0].r + f * Sky.color_top[1].r, l * Sky.color_top[0].g + f * Sky.color_top[1].g, l * Sky.color_top[0].b + f * Sky.color_top[1].b), this.sky.material.uniforms.bottom_color.value.setRGB(l * 
			Sky.color_bottom[0].r + f * Sky.color_bottom[1].r, l * Sky.color_bottom[0].g + f * Sky.color_bottom[1].g, l * Sky.color_bottom[0].b + f * Sky.color_bottom[1].b)) : .708 > a ? (this.sky.material.uniforms.top_color.value.setRGB(Sky.color_top[1].r, Sky.color_top[1].g, Sky.color_top[1].b), this.sky.material.uniforms.bottom_color.value.setRGB(Sky.color_bottom[1].r, Sky.color_bottom[1].g, Sky.color_bottom[1].b)) : .75 > a ? (f = 23.81 * (a - .708), l = 1 - f, this.sky.material.uniforms.top_color.value.setRGB(l * 
			Sky.color_top[1].r + f * Sky.color_top[2].r, l * Sky.color_top[1].g + f * Sky.color_top[2].g, l * Sky.color_top[1].b + f * Sky.color_top[2].b), this.sky.material.uniforms.bottom_color.value.setRGB(l * Sky.color_bottom[1].r + f * Sky.color_bottom[2].r, l * Sky.color_bottom[1].g + f * Sky.color_bottom[2].g, l * Sky.color_bottom[1].b + f * Sky.color_bottom[2].b)) : .8333 > a ? (f = 12.048 * (a - .75), l = 1 - f, this.sky.material.uniforms.top_color.value.setRGB(l * Sky.color_top[2].r + f * Sky.color_top[3].r, 
			l * Sky.color_top[2].g + f * Sky.color_top[3].g, l * Sky.color_top[2].b + f * Sky.color_top[3].b), this.sky.material.uniforms.bottom_color.value.setRGB(l * Sky.color_bottom[2].r + f * Sky.color_bottom[3].r, l * Sky.color_bottom[2].g + f * Sky.color_bottom[3].g, l * Sky.color_bottom[2].b + f * Sky.color_bottom[3].b)) : (this.sky.material.uniforms.top_color.value.setRGB(Sky.color_top[3].r, Sky.color_top[3].g, Sky.color_top[3].b), this.sky.material.uniforms.bottom_color.value.setRGB(Sky.color_bottom[3].r, 
			Sky.color_bottom[3].g, Sky.color_bottom[3].b));
		}
	}
	.2 > a ? this.sun.color.setHex(Sky.moon_color) : .3 > a ? (f = 10 * (a - .2), .5 > f ? (this.sun.intensity = .3 * (2 - 2 * f), this.sun.color.setHex(Sky.moon_color)) : (this.sun.intensity = .6 * f, this.sun.color.setHex(Sky.sun_color))) : .7 > a ? this.sun.color.setHex(Sky.sun_color) : .8 > a ? (f = 10 * (a - .7), .5 > f ? (this.sun.intensity = .3 * (2 - 2 * f), this.sun.color.setHex(Sky.sun_color)) : (this.sun.intensity = .6 * f, this.sun.color.setHex(Sky.moon_color))) : this.sun.color.setHex(Sky.moon_color);
	f = MathUtils.pi2 * a - MathUtils.pid2;
	.25 < a && .75 > a ? (this.sun.position.x = this.sun_distance * Math.cos(f), this.sun.position.y = this.sun_distance * Math.sin(f)) : (this.sun.position.x = this.sun_distance * Math.cos(f + Math.PI), this.sun.position.y = this.sun_distance * Math.sin(f + Math.PI));
};
Sky.prototype.toJSON = function(a) {
	a = THREE.Object3D.prototype.toJSON.call(this, a);
	a.object.auto_update = this.auto_update;
	a.object.sun_distance = this.sun_distance;
	a.object.day_time = this.day_time;
	a.object.time = this.time;
	a.object.sun = {};
	a.object.sun.shadow = this.sun.shadow.toJSON();
	return a;
};
function PerspectiveCamera(a, f, l, b) {
	void 0 === l && (l = .1);
	void 0 === b && (b = 1E5);
	THREE.PerspectiveCamera.call(this, a, f, l, b);
	this.name = "camera";
	this.offset = new THREE.Vector2(0, 0);
	this.viewport = new THREE.Vector2(1, 1);
	this.clear_depth = this.clear_color = !1;
	this.listener = new THREE.AudioListener;
}
PerspectiveCamera.prototype = Object.create(THREE.PerspectiveCamera.prototype);
PerspectiveCamera.prototype.initialize = function() {
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].initialize();
	}
};
PerspectiveCamera.prototype.destroy = function() {
	var a = ObjectUtils.getScene(this);
	null !== a && a.removeCamera(this);
	THREE.Object3D.prototype.destroy.call(this);
};
PerspectiveCamera.prototype.updateMatrixWorld = function(a) {
	!0 === this.matrixAutoUpdate && this.updateMatrix();
	if (!0 === this.matrixWorldNeedsUpdate || !0 === a) {
		null !== this.parent ? this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix) : this.matrixWorld = this.matrix, this.matrixWorldNeedsUpdate = !1, a = !0;
	}
	for (var f = this.children, l = 0;l < f.length;l++) {
		f[l].updateMatrixWorld(a);
	}
};
PerspectiveCamera.prototype.updateProjectionMatrix = function() {
	var a = this.near * Math.tan(.5 * THREE.Math.DEG2RAD * this.fov) / this.zoom, f = 2 * a, l = this.aspect * f * (void 0 !== this.viewport ? this.viewport.x / this.viewport.y : 1), b = -.5 * l;
	0 !== this.filmOffset && (b += this.near * this.filmOffset / this.getFilmWidth());
	this.projectionMatrix.makeFrustum(b, b + l, a - f, a, this.near, this.far);
};
PerspectiveCamera.prototype.toJSON = function(a) {
	a = THREE.PerspectiveCamera.prototype.toJSON.call(this, a);
	a.object.clear_color = this.clear_color;
	a.object.clear_depth = this.clear_depth;
	a.object.viewport = this.viewport.toArray();
	a.object.offset = this.offset.toArray();
	return a;
};
function OrthographicCamera(a, f, l, b, k) {
	void 0 === b && (b = 0);
	void 0 === k && (k = 1E5);
	THREE.OrthographicCamera.call(this, -1, 1, 1, -1, b, k);
	this.name = "camera";
	this.size = void 0 != a ? a : 10;
	this.aspect = void 0 != f ? f : 1;
	this.mode = void 0 !== l ? l : OrthographicCamera.FIXED_VERTICAL;
	this.offset = new THREE.Vector2(0, 0);
	this.viewport = new THREE.Vector2(1, 1);
	this.clear_depth = this.clear_color = !1;
	this.updateProjectionMatrix();
	this.listener = new THREE.AudioListener;
}
OrthographicCamera.prototype = Object.create(THREE.OrthographicCamera.prototype);
OrthographicCamera.FIXED_VERTICAL = 0;
OrthographicCamera.FIXED_HORIZONTAL = 1;
OrthographicCamera.prototype.initialize = function() {
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].initialize();
	}
};
OrthographicCamera.prototype.destroy = function() {
	var a = ObjectUtils.getScene(this);
	null !== a && a.removeCamera(this);
	THREE.Object3D.prototype.destroy.call(this);
};
OrthographicCamera.prototype.updateProjectionMatrix = function() {
	this.mode === OrthographicCamera.FIXED_VERTICAL ? (this.top = this.size / 2, this.bottom = -this.top, this.right = this.viewport.x / this.viewport.y * this.aspect * this.top, this.left = -this.right) : this.mode === OrthographicCamera.FIXED_HORIZONTAL && (this.right = this.size / 2, this.left = -this.right, this.top = this.right / this.aspect * (this.viewport.x / this.viewport.y), this.bottom = -this.top);
	THREE.OrthographicCamera.prototype.updateProjectionMatrix.call(this);
};
OrthographicCamera.prototype.toJSON = function(a) {
	a = THREE.OrthographicCamera.prototype.toJSON.call(this, a);
	a.object.size = this.size;
	a.object.aspect = this.aspect;
	a.object.mode = this.mode;
	a.object.clear_color = this.clear_color;
	a.object.clear_depth = this.clear_depth;
	a.object.viewport = this.viewport.toArray();
	a.object.offset = this.offset.toArray();
	return a;
};
function AudioEmitter(a) {
	THREE.Audio.call(this, AudioEmitter.listener);
	this.name = "audio";
	this.type = "Audio";
	this.audio = void 0 !== a ? a : null;
	this.autoplay = !0;
	this.playbackRate = 1;
	this.startTime = 0;
	this.loop = !0;
	this.isPlaying = !1;
	this.hasPlaybackControl = !0;
}
AudioEmitter.listener = new THREE.AudioListener;
AudioEmitter.prototype = Object.create(THREE.Audio.prototype);
AudioEmitter.prototype.initialize = function() {
	var a = this;
	null !== this.audio && THREE.AudioContext.getContext().decodeAudioData(this.audio.data, function(f) {
		a.setBuffer(f);
	});
	for (var f = 0;f < this.children.length;f++) {
		this.children[f].initialize();
	}
};
AudioEmitter.prototype.dispose = function() {
	this.isPlaying && (this.stop(), this.disconnect());
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].dispose();
	}
};
AudioEmitter.prototype.toJSON = function(a) {
	var f = this.audio;
	a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, b) {
		f = f.toJSON(a);
	});
	a.object.audio = f.uuid;
	a.object.autoplay = this.autoplay;
	a.object.startTime = this.startTime;
	a.object.playbackRate = this.playbackRate;
	a.object.loop = this.loop;
	return a;
};
function Script(a) {
	THREE.Object3D.call(this);
	this.type = "Script";
	this.name = "script";
	this.script = null;
	this.setCode(void 0 !== a ? a : Script.default);
	this.scene = this.program = null;
}
Script.prototype = Object.create(THREE.Object3D.prototype);
Script.default = "this.initialize = function()\n{\n\t//TODO <INITIALIZATION CODE>\n};\n\nthis.update = function()\n{\n\t//TODO <UPDATE CODE>\n};\n\nthis.onMouseOver = function()\n{\n\t//TODO <MOUSE OVER CHILDREN CODE>\n};\n\nthis.onResize = function()\n{\n\t//TODO <RESIZE CODE>\n};\n\nthis.onExit = function()\n{\n\t//TODO <APP EXIT CODE>\n};";
Script.prototype.initialize = function() {
	for (var a = this;null !== a.parent;) {
		a = a.parent, a instanceof Scene ? this.scene = a : a instanceof Program && (this.program = a);
	}
	void 0 !== this.script.initialize && this.script.initialize.call(this);
	for (a = 0;a < this.children.length;a++) {
		this.children[a].initialize();
	}
};
Script.prototype.update = function() {
	if (void 0 !== this.script.onMouseOver) {
		var a = this.scene.raycaster.intersectObjects(this.children, !0);
		0 < a.length && this.script.onMouseOver.call(this, a);
	}
	void 0 !== this.script.update && this.script.update.call(this);
	for (a = 0;a < this.children.length;a++) {
		this.children[a].update();
	}
};
Script.prototype.setCode = function(a) {
	try {
		this.code = a, this.script = new new Function(this.code);
	} catch (f) {
		console.warn("NunuStudio: Error compiling script code"), this.script = new function() {
		};
	}
};
Script.prototype.toJSON = function(a) {
	a = THREE.Object3D.prototype.toJSON.call(this, a);
	a.object.code = this.code;
	return a;
};
function PhysicsObject() {
	THREE.Object3D.call(this);
	this.name = "physics";
	this.type = "Physics";
	this.body = new CANNON.Body;
	this.body.type = CANNON.Body.DYNAMIC;
	this.body.mass = 1;
	this.world = null;
}
PhysicsObject.prototype = Object.create(THREE.Object3D.prototype);
PhysicsObject.prototype.initialize = function() {
	this.body.position.copy(this.position);
	this.body.quaternion.copy(this.quaternion);
	for (var a = this;null !== a.parent;) {
		a = a.parent, a instanceof Scene && (this.world = a.world, this.world.addBody(this.body));
	}
	for (a = 0;a < this.children.length;a++) {
		this.children[a].initialize();
	}
};
PhysicsObject.prototype.update = function() {
	this.position.copy(this.body.position);
	this.body.fixedRotation || this.quaternion.copy(this.body.quaternion);
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].update();
	}
};
PhysicsObject.prototype.addShape = function(a) {
	a instanceof CANNON.Shape && this.body.addShape(a);
};
PhysicsObject.prototype.toJSON = function(a) {
	a = THREE.Object3D.prototype.toJSON.call(this, a);
	a.object.body = {};
	a.object.body.type = this.body.type;
	a.object.body.mass = this.body.mass;
	a.object.body.linearDamping = this.body.linearDamping;
	a.object.body.angularDamping = this.body.angularDamping;
	a.object.body.allowSleep = this.body.allowSleep;
	a.object.body.sleepSpeedLimit = this.body.sleepSpeedLimit;
	a.object.body.sleepTimeLimit = this.body.sleepTimeLimit;
	a.object.body.collisionFilterGroup = this.body.collisionFilterGroup;
	a.object.body.collisionFilterMask = this.body.collisionFilterMask;
	a.object.body.fixedRotation = this.body.fixedRotation;
	a.object.body.shapes = [];
	for (var f = this.body.shapes, l = 0;l < f.length;l++) {
		var b = f[l], k = {};
		k.type = b.type;
		b.type === CANNON.Shape.types.SPHERE ? k.radius = b.radius : b.type === CANNON.Shape.types.BOX ? (k.halfExtents = {}, k.halfExtents.x = b.halfExtents.x, k.halfExtents.y = b.halfExtents.y, k.halfExtents.z = b.halfExtents.z) : b.type === CANNON.Shape.types.CONVEXPOLYHEDRON && (k.vertices = b.vertices, k.faces = b.faces);
		a.object.body.shapes[l] = k;
	}
	return a;
};
function SpineAnimation(a, f, l, b) {
	if (void 0 !== b) {
		var k = new spine.TextureAtlas(f, function(a) {
			for (var c = 0;c < b.length;c++) {
				if (b[c].name === a) {
					return a = new SpineTexture(b[c].texture), c = a.texture.image, c.width = 1024, c.height = 1024, a;
				}
			}
		})
	} else {
		b = [], k = new spine.TextureAtlas(f, function(a) {
			var c = new SpineTexture(new Texture(new Image(l + "\\" + a))), e = c.texture.image;
			e.width = 1024;
			e.height = 1024;
			b.push({name:a, texture:c.texture});
			return c;
		});
	}
	k = new spine.AtlasAttachmentLoader(k);
	k = (new spine.SkeletonJson(k)).readSkeletonData(a);
	THREE.Mesh.call(this);
	this.zOffset = .1;
	this.skeleton = new spine.Skeleton(k);
	k = new spine.AnimationStateData(k);
	this.state = new spine.AnimationState(k);
	this.batcher = new spine.threejs.MeshBatcher(this);
	k = new THREE.MeshBasicMaterial;
	k.side = THREE.DoubleSide;
	k.transparent = !0;
	k.name = "spine";
	k.alphaTest = .5;
	this.material = k;
	this.json = a;
	this.atlas = f;
	this.textures = b;
	this.name = "spine";
	this.type = "SpineAnimation";
	this.scale.set(.01, .01, .01);
	this.frustumCulled = !1;
	this.castShadow = this.receiveShadow = !0;
	this.clock = new THREE.Clock;
}
SpineAnimation.prototype = Object.create(THREE.Mesh.prototype);
SpineAnimation.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
SpineAnimation.prototype.update = function() {
	var a = this.state, f = this.skeleton;
	a.update(this.clock.getDelta());
	a.apply(f);
	f.updateWorldTransform();
	this.updateGeometry();
	for (a = 0;a < this.children.length;a++) {
		this.children[a].update();
	}
};
SpineAnimation.prototype.getAnimations = function() {
	return this.state.data.skeletonData.animations;
};
SpineAnimation.prototype.setAnimation = function(a, f) {
	try {
		this.state.setAnimation(a, f, !0);
	} catch (l) {
	}
};
SpineAnimation.prototype.getSkins = function() {
	return this.state.data.skeletonData.skins;
};
SpineAnimation.prototype.updateGeometry = function() {
	var a, f, l = this.skeleton.drawOrder, b = 0, k = this.batcher;
	k.begin();
	for (var h = 0, c = l.length;h < c;h++) {
		a = l[h];
		f = a.getAttachment();
		var e;
		if (f instanceof spine.RegionAttachment) {
			e = f, a = e.updateWorldVertices(a, !1), f = SpineAnimation.QUAD_TRIANGLES, e = e.region.renderObject.texture;
		} else {
			if (f instanceof spine.MeshAttachment) {
				e = f, a = e.updateWorldVertices(a, !1), f = e.triangles, e = e.region.renderObject.texture;
			} else {
				continue;
			}
		}
		if (null !== e) {
			if (!this.material.map) {
				var g = this.material;
				g.map = e.texture;
				g.needsUpdate = !0;
			}
			k.batch(a, f, b);
			b += this.zOffset;
		}
	}
	k.end();
};
SpineAnimation.prototype.toJSON = function(a) {
	var f = this.geometry, l = this.material;
	this.material = this.geometry = void 0;
	var b = [], k = this;
	a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, c) {
		for (c = 0;c < k.textures.length;c++) {
			var e = k.textures[c].texture.toJSON(a);
			b.push({name:k.textures[c].name, texture:e.uuid});
		}
	});
	a.object.json = this.json;
	a.object.atlas = this.atlas;
	a.object.textures = b;
	this.geometry = f;
	this.material = l;
	return a;
};
function SpineTexture(a) {
	spine.Texture.call(this, a.image);
	this.texture = a;
	this.texture.flipY = !1;
}
SpineTexture.prototype = Object.create(spine.Texture.prototype);
SpineTexture.prototype.setFilters = function(a, f) {
	this.texture.minFilter = SpineTexture.getTextureFilter(a);
	this.texture.magFilter = SpineTexture.getTextureFilter(f);
};
SpineTexture.prototype.setWraps = function(a, f) {
	this.texture.wrapS = SpineTexture.getTextureWrap(a);
	this.texture.wrapT = SpineTexture.getTextureWrap(f);
};
SpineTexture.prototype.dispose = function() {
	this.texture.dispose();
};
SpineTexture.getTextureFilter = function(a) {
	return a === spine.TextureFilter.Linear ? THREE.LinearFilter : a === spine.TextureFilter.MipMap || a === spine.TextureFilter.MipMapLinearLinear ? THREE.LinearMipMapLinearFilter : a === spine.TextureFilter.MipMapLinearNearest ? THREE.LinearMipMapNearestFilter : a === spine.TextureFilter.MipMapNearestLinear ? THREE.NearestMipMapLinearFilter : a === spine.TextureFilter.MipMapNearestNearest ? THREE.NearestMipMapNearestFilter : a === spine.TextureFilter.Nearest ? THREE.NearestFilter : null;
};
SpineTexture.getTextureWrap = function(a) {
	if (a === spine.TextureWrap.ClampToEdge) {
		return THREE.ClampToEdgeWrapping;
	}
	if (a === spine.TextureWrap.MirroredRepeat) {
		return THREE.MirroredRepeatWrapping;
	}
	if (a === spine.TextureWrap.Repeat) {
		return THREE.RepeatWrapping;
	}
};
function Bone() {
	THREE.Bone.call(this);
	this.name = "bone";
}
Bone.prototype = Object.create(THREE.Bone.prototype);
function Container() {
	THREE.Object3D.call(this);
	this.name = "container";
	this.type = "Group";
}
Container.prototype = Object.create(THREE.Object3D.prototype);
function ParticleEmitter(a, f) {
	THREE.Object3D.call(this);
	this.type = "ParticleEmiter";
	this.name = "particle";
	this.clock = new THREE.Clock;
	this.group = void 0 !== a ? new SPE.Group(a) : new SPE.Group({texture:{value:new Texture(new Image("data/particle.png"))}, maxParticleCount:2E3, blending:THREE.AdditiveBlending, hasPerspective:!0});
	this.group.mesh.frustumCulled = !1;
	this.emitter = void 0 !== f ? new SPE.Emitter(f) : new SPE.Emitter({particleCount:2E3, type:SPE.distributions.BOX, maxAge:{value:2, spread:0}, velocity:{value:new THREE.Vector3(0, 25, 0), spread:new THREE.Vector3(10, 7.5, 10)}, acceleration:{value:new THREE.Vector3(0, -10, 0), spread:new THREE.Vector3(10, 0, 10)}, color:{value:[new THREE.Color(1, 1, 1)], spread:[new THREE.Vector3(0, 0, 0)]}});
	this.group.addEmitter(this.emitter);
}
ParticleEmitter.prototype = Object.create(THREE.Object3D.prototype);
ParticleEmitter.prototype.initialize = function() {
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].initialize();
	}
	this.clock.getDelta();
	this.add(this.group.mesh);
};
ParticleEmitter.prototype.update = function() {
	this.group.tick(this.clock.getDelta());
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].update();
	}
};
ParticleEmitter.prototype.dispose = function() {
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].dispose();
	}
};
ParticleEmitter.prototype.toJSON = function(a) {
	var f = this.group.texture;
	a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, b) {
		f = f.toJSON(a);
	});
	a.object.group = {};
	a.object.group.texture = {};
	a.object.group.texture.value = f.uuid;
	a.object.group.textureFrames = this.group.textureFrames;
	a.object.group.textureFrameCount = this.group.textureFrameCount;
	a.object.group.textureLoop = this.group.textureLoop;
	a.object.group.hasPerspective = this.group.hasPerspective;
	a.object.group.colorize = this.group.colorize;
	a.object.group.maxParticleCount = this.group.maxParticleCount;
	a.object.group.blending = this.group.blending;
	a.object.group.scale = this.group.scale;
	a.object.group.depthWrite = this.group.depthWrite;
	a.object.group.depthTest = this.group.depthTest;
	a.object.group.fog = this.group.fog;
	a.object.emitter = {};
	a.object.emitter.uuid = this.emitter.uuid;
	a.object.emitter.direction = this.emitter.direction;
	a.object.emitter.particleCount = this.emitter.particleCount;
	a.object.emitter.duration = this.emitter.duration;
	a.object.emitter.type = this.emitter.type;
	a.object.emitter.maxAge = {};
	a.object.emitter.maxAge.value = this.emitter.maxAge.value;
	a.object.emitter.maxAge.spread = this.emitter.maxAge.spread;
	a.object.emitter.position = {};
	a.object.emitter.position.value = this.emitter.position.value;
	a.object.emitter.position.spread = this.emitter.position.spread;
	a.object.emitter.velocity = {};
	a.object.emitter.velocity.value = this.emitter.velocity.value;
	a.object.emitter.velocity.spread = this.emitter.velocity.spread;
	a.object.emitter.acceleration = {};
	a.object.emitter.acceleration.value = this.emitter.acceleration.value;
	a.object.emitter.acceleration.spread = this.emitter.acceleration.spread;
	a.object.emitter.wiggle = {};
	a.object.emitter.wiggle.value = this.emitter.wiggle.value;
	a.object.emitter.wiggle.spread = this.emitter.wiggle.spread;
	a.object.emitter.opacity = {};
	a.object.emitter.opacity.value = this.emitter.opacity.value;
	a.object.emitter.opacity.spread = this.emitter.opacity.spread;
	a.object.emitter.size = {};
	a.object.emitter.size.value = this.emitter.size.value;
	a.object.emitter.size.spread = this.emitter.size.spread;
	a.object.emitter.angle = {};
	a.object.emitter.angle.value = this.emitter.angle.value;
	a.object.emitter.angle.spread = this.emitter.angle.spread;
	a.object.emitter.color = {};
	a.object.emitter.color.value = this.emitter.color.value;
	a.object.emitter.color.spread = this.emitter.color.spread;
	return a;
};
function Program(a) {
	THREE.Object3D.call(this);
	this.type = "Program";
	this.matrixAutoUpdate = !1;
	this.name = void 0 !== a ? a : "program";
	this.author = this.description = "";
	this.version = "0";
	this.vr = this.lock_pointer = !1;
	this.vr_scale = 1;
	this.antialiasing = !1;
	this.shadows = !0;
	this.shadows_type = THREE.PCFSoftShadowMap;
	this.images = [];
	this.videos = [];
	this.audio = [];
	this.fonts = [];
	this.materials = [];
	this.textures = [];
	this.geometries = [];
	this.canvas = this.renderer = this.scene = this.default_camera = this.default_scene = null;
}
Program.prototype = Object.create(THREE.Object3D.prototype);
Program.prototype.initialize = function() {
	if (null !== this.default_scene) {
		for (var a = 0;a < this.children.length;a++) {
			if (this.children[a].uuid === this.default_scene) {
				this.setScene(this.children[a]);
				break;
			}
		}
	} else {
		0 < this.children.length && this.setScene(this.children[0]);
	}
	this.canvas = this.renderer.domElement;
	this.lock_pointer && Mouse.setLock(!0);
};
Program.prototype.update = function() {
	this.scene.update();
};
Program.prototype.render = function(a) {
	var f = a.domElement.width, l = a.domElement.height;
	a.setScissorTest(!0);
	for (var b = 0;b < this.scene.cameras.length;b++) {
		var k = this.scene.cameras[b];
		k.clear_color && a.clearColor();
		k.clear_depth && a.clearDepth();
		a.setViewport(f * k.offset.x, l * k.offset.y, f * k.viewport.x, l * k.viewport.y);
		a.setScissor(f * k.offset.x, l * k.offset.y, f * k.viewport.x, l * k.viewport.y);
		a.render(this.scene, k);
	}
	a.setScissorTest(!1);
};
Program.prototype.resize = function(a, f) {
	for (var l = 0;l < this.scene.cameras.length;l++) {
		this.scene.cameras[l].aspect = a / f, this.scene.cameras[l].updateProjectionMatrix();
	}
};
Program.prototype.getMaterialByName = function(a) {
	for (var f in this.materials) {
		if (this.materials[f].name === a) {
			return this.materials[f];
		}
	}
	return null;
};
Program.prototype.addMaterial = function(a) {
	a instanceof THREE.Material && (this.materials[a.uuid] = a);
};
Program.prototype.removeMaterial = function(a, f, l) {
	void 0 === f && (f = new THREE.MeshBasicMaterial);
	void 0 === l && (l = new THREE.SpriteMaterial);
	a instanceof THREE.Material && (delete this.materials[a.uuid], this.traverse(function(b) {
		void 0 !== b.material && b.material.uuid === a.uuid && (b.material = b instanceof THREE.Sprite ? l : f);
	}));
};
Program.prototype.getTextureByName = function(a) {
	for (var f in this.textures) {
		if (this.textures[f].name === a) {
			return this.textures[f];
		}
	}
	return null;
};
Program.prototype.addTexture = function(a) {
	this.textures[a.uuid] = a;
};
Program.prototype.removeTexture = function(a, f) {
	void 0 === f && (f = new THREE.Texture);
	a instanceof THREE.Texture && (delete this.textures[a.uuid], this.traverse(function(l) {
		void 0 !== l.material ? (l = l.material, null != l.map && l.map.uuid === a.uuid ? (l.map = f, l.needsUpdate = !0) : null != l.bumpMap && l.bumpMap.uuid === a.uuid ? (l.bumpMap = f, l.needsUpdate = !0) : null != l.normalMap && l.normalMap.uuid === a.uuid ? (l.normalMap = f, l.needsUpdate = !0) : null != l.displacementMap && l.displacementMap.uuid === a.uuid ? (l.displacementMap = f, l.needsUpdate = !0) : null != l.specularMap && l.specularMap.uuid === a.uuid ? (l.specularMap = f, l.needsUpdate = 
		!0) : null != l.emissiveMap && l.emissiveMap.uuid === a.uuid ? (l.emissiveMap = f, l.needsUpdate = !0) : null != l.alphaMap && l.alphaMap.uuid === a.uuid ? (l.alphaMap = f, l.needsUpdate = !0) : null != l.roughnessMap && l.roughnessMap.uuid === a.uuid ? (l.roughnessMap = f, l.needsUpdate = !0) : null != l.metalnessMap && l.metalnessMap.uuid === a.uuid && (l.metalnessMap = f, l.needsUpdate = !0)) : l instanceof ParticleEmitter && l.group.texture.uuid === a.uuid && (l.group.texture = f);
	}));
};
Program.prototype.getFontByName = function(a) {
	for (var f in this.fonts) {
		if (this.fonts[f].name === a) {
			return this.fonts[f];
		}
	}
	return null;
};
Program.prototype.addFont = function(a) {
	a instanceof Font && (this.fonts[a.uuid] = a);
};
Program.prototype.removeFont = function(a, f) {
	void 0 === f && (f = new Font);
	a instanceof Font && (delete this.fonts[a.uuid], this.traverse(function(l) {
		void 0 !== l.font && l.font.uuid === a.uuid && l.setFont(f);
	}));
};
Program.prototype.getAudioByName = function(a) {
	for (var f in this.audio) {
		if (this.audio[f].name === a) {
			return this.audio[f];
		}
	}
	return null;
};
Program.prototype.addAudio = function(a) {
	a instanceof Audio && (this.audio[a.uuid] = a);
};
Program.prototype.removeAudio = function(a, f) {
	void 0 === f && (f = new Audio);
	a instanceof Audio && (delete this.audio[a.uuid], this.traverse(function(l) {
		void 0 !== l.audio && l.audio.uuid === a.uuid && l.setFont(f);
	}));
};
Program.prototype.setScene = function(a) {
	a instanceof Scene ? this.scene = a : "string" === typeof a && (this.scene = this.getObjectByName(a));
	null !== this.scene && (this.scene.initialize(), 0 === this.scene.cameras.length && this.scene.cameras.push(this.default_camera));
};
Program.prototype.remove = function(a) {
	var f = this.children.indexOf(a);
	-1 < f && (this.children.splice(f, 1), a.parent = null);
	0 === this.children.length && (this.scene = null);
};
Program.prototype.add = function(a) {
	a instanceof Scene && (this.children.push(a), a.parent = this, 1 === this.children.length && (this.scene = this.children[0]));
};
Program.prototype.clone = function() {
	return (new ObjectLoader).parse(this.toJSON());
};
Program.prototype.setInitialScene = function(a) {
	this.default_scene = a.uuid;
};
Program.prototype.addDefaultScene = function(a) {
	void 0 === a && (a = new THREE.MeshStandardMaterial({roughness:.6, metalness:.2}), a.name = "default");
	var f = new Scene, l = new Sky;
	l.auto_update = !1;
	f.add(l);
	var l = new THREE.BoxBufferGeometry(1, 1, 1), b = new Mesh(l, a);
	b.receiveShadow = !0;
	b.castShadow = !0;
	b.name = "box";
	f.add(b);
	b = new Mesh(l, a);
	b.scale.set(20, 1, 20);
	b.position.set(0, -1, 0);
	b.receiveShadow = !0;
	b.castShadow = !0;
	b.name = "ground";
	f.add(b);
	this.add(f);
};
Program.prototype.dispose = function() {
	for (var a = 0;a < this.materials.length;a++) {
		this.materials[a].dispose();
	}
	for (a = 0;a < this.textures.length;a++) {
		this.textures[a].dispose();
	}
	for (a = 0;a < this.children.length;a++) {
		this.children[a].dispose();
	}
};
Program.prototype.toJSON = function(a, f) {
	var l = this;
	a = THREE.Object3D.prototype.toJSON.call(this, a, function(a, k) {
		if (!1 !== f) {
			k = l.textures;
			for (var b in k) {
				var c = k[b];
				void 0 === a.textures[c.uuid] && (a.textures[c.uuid] = c.toJSON(a));
			}
			k = l.materials;
			for (b in k) {
				c = k[b], void 0 === a.materials[c.uuid] && (a.materials[c.uuid] = c.toJSON(a));
			}
			k = l.fonts;
			for (b in k) {
				c = k[b], void 0 === a.fonts[c.uuid] && (a.fonts[c.uuid] = c.toJSON(a));
			}
			k = l.audio;
			for (b in k) {
				c = k[b], void 0 === a.audio[c.uuid] && (a.audio[c.uuid] = c.toJSON(a));
			}
		}
	});
	a.object.author = this.author;
	a.object.description = this.description;
	a.object.version = this.version;
	a.object.lock_pointer = this.lock_pointer;
	a.object.vr = this.vr;
	a.object.vr_scale = this.vr_scale;
	null !== this.default_scene && (a.object.default_scene = this.default_scene);
	return a;
};
function Scene() {
	THREE.Scene.call(this);
	this.name = "scene";
	this.matrixAutoUpdate = !1;
	this.world = new CANNON.World;
	this.world.defaultContactMaterial.contactEquationStiffness = 1E9;
	this.world.defaultContactMaterial.contactEquationRelaxation = 4;
	this.world.quatNormalizeSkip = 0;
	this.world.quatNormalizeFast = !1;
	this.world.gravity.set(0, -9.8, 0);
	this.world.broadphase = new CANNON.NaiveBroadphase;
	this.world.solver = new CANNON.SplitSolver(new CANNON.GSSolver);
	this.world.solver.tolerance = .1;
	this.world.solver.iterations = 7;
	this.cameras = [];
	this.clock = new THREE.Clock;
	this.raycaster = new THREE.Raycaster;
	this.canvas = null;
	this.mouse = new Vector2(0, 0);
}
Scene.prototype = Object.create(THREE.Scene.prototype);
Scene.prototype.initialize = function() {
	for (var a = 0;a < this.children.length;a++) {
		this.children[a].initialize();
	}
	this.canvas = this.parent.renderer.domElement;
	this.clock.start();
};
Scene.prototype.update = function() {
	this.mouse.set(Mouse.position.x / this.canvas.width * 2 - 1, -2 * Mouse.position.y / this.canvas.height + 1);
	0 < this.cameras.length && this.raycaster.setFromCamera(this.mouse, this.cameras[0]);
	var a = this.clock.getDelta();
	this.world.step(.05 > a ? a : .05);
	for (a = 0;a < this.children.length;a++) {
		this.children[a].update();
	}
};
Scene.prototype.getCamera = function(a, f) {
	void 0 === f && (f = this);
	if (a === f.uuid) {
		return f;
	}
	f = f.children;
	for (var l = 0;l < f.length;l++) {
		var b = this.getCamera(a, f[l]);
		if (null !== b) {
			return b;
		}
	}
	return null;
};
Scene.prototype.addCamera = function(a) {
	this.cameras.push(a);
};
Scene.prototype.removeCamera = function(a) {
	a = this.cameras.indexOf(a);
	-1 < a && this.cameras.splice(a, 1);
};
Scene.prototype.setFogMode = function(a) {
	var f = null !== this.fog ? this.fog.color.getHex() : "#FFFFFF";
	a === THREE.Fog.LINEAR ? this.fog = new THREE.Fog(f, 5, 20) : a === THREE.Fog.EXPONENTIAL ? this.fog = new THREE.FogExp2(f, .01) : a === THREE.Fog.NONE && (this.fog = null);
};
Scene.prototype.toJSON = function(a) {
	a = THREE.Scene.prototype.toJSON.call(this, a);
	a.object.cameras = [];
	for (var f = 0;f < this.cameras.length;f++) {
		a.object.cameras.push(this.cameras[f].uuid);
	}
	a.object.world = {};
	a.object.world.gravity = this.world.gravity;
	a.object.world.quatNormalizeSkip = this.world.quatNormalizeSkip;
	a.object.world.quatNormalizeFast = this.world.quatNormalizeFast;
	a.object.world.solver = {};
	a.object.world.solver.tolerance = this.world.solver.tolerance;
	a.object.world.solver.iterations = this.world.solver.iterations;
	return a;
};
function Base64Utils() {
}
Base64Utils.fromArraybuffer = function(a) {
	var f = "";
	a = new Uint8Array(a);
	for (var l = a.byteLength % 3, b = a.byteLength - l, k, h, c, e, g = 0;g < b;g += 3) {
		e = a[g] << 16 | a[g + 1] << 8 | a[g + 2], k = (e & 16515072) >> 18, h = (e & 258048) >> 12, c = (e & 4032) >> 6, e &= 63, f += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[k] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[h] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[c] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[e];
	}
	1 === l ? (e = a[b], f += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(e & 252) >> 2] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(e & 3) << 4] + "==") : 2 === l && (e = a[b] << 8 | a[b + 1], f += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(e & 64512) >> 10] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(e & 1008) >> 4] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(e & 15) << 2] + 
	"=");
	return f;
};
Base64Utils.fromBinaryString = function(a) {
	for (var f = "", l = a.length % 3, b = a.length - l, k, h, c, e = 0;e < b;e += 3) {
		k = a.charCodeAt(e) & 255, h = a.charCodeAt(e + 1), c = a.charCodeAt(e + 2), f += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(k >> 2), f += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((k & 3) << 4 | (h & 240) >> 4), f += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((h & 15) << 2 | (c & 192) >> 6), f += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(c & 63);
	}
	1 === l ? (k = a.charCodeAt(e) & 255, f += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(k >> 2), f += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((k & 3) << 4), f += "==") : 2 === l && (k = a.charCodeAt(e) & 255, h = a.charCodeAt(e + 1), f += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(k >> 2), f += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((k & 3) << 4 | (h & 240) >> 4), f += 
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((h & 15) << 2), f += "=");
	return f;
};
function ArraybufferUtils() {
}
ArraybufferUtils.fromBinaryString = function(a) {
	for (var f = a.length, l = new ArrayBuffer(f), b = new Uint8Array(l), k = 0;k < f;k++) {
		b[k] = a.charCodeAt(k);
	}
	return l;
};
ArraybufferUtils.fromBase64 = function(a) {
	for (var f = a.length / 4 * 3, l = new ArrayBuffer(f), b = new Uint8Array(l), k, h, c, e, g = 0, q = 0;g < f;g += 3) {
		k = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(q++)), h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(q++)), c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(q++)), e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(q++)), b[g] = k << 2 | h >> 4, 64 !== c && (b[g + 1] = (h & 15) << 4 | c >> 2), 64 !== e && (b[g + 2] = (c & 3) << 6 | e);
	}
	return l;
};
function MathUtils() {
}
MathUtils.pi2 = 2 * Math.PI;
MathUtils.pid2 = Math.PI / 2;
function ObjectUtils() {
}
ObjectUtils.getFonts = function(a, f) {
	void 0 === f && (f = []);
	a.traverse(function(a) {
		a.font instanceof Font && void 0 === f[a.font.uuid] && (f[a.font.uuid] = a.font);
	});
	return f;
};
ObjectUtils.getAudio = function(a, f) {
	void 0 === f && (f = []);
	a.traverse(function(a) {
		a.audio instanceof Audio && void 0 === f[a.audio.uuid] && (f[a.audio.uuid] = a.audio);
	});
	return f;
};
ObjectUtils.getMaterials = function(a, f) {
	function l(a) {
		void 0 === f[a.uuid] && (f[a.uuid] = a);
	}
	void 0 === f && (f = []);
	a.traverse(function(a) {
		if (!(void 0 === a.material || a.hidden || a instanceof Sky || a instanceof SpineAnimation)) {
			if (a.material instanceof THREE.Material) {
				l(a.material);
			} else {
				if (a.material instanceof THREE.MultiMaterial) {
					for (var b = a.material.materials, f = 0;f < b.length;f++) {
						l(b[f]);
					}
				}
			}
			if (void 0 !== a.materials) {
				for (f = 0;f < a.materials.length;f++) {
					l(a.materials[f]);
				}
			}
		}
	});
	return f;
};
ObjectUtils.getTextures = function(a, f) {
	function l(a) {
		null != a && void 0 === f[a.uuid] && (f[a.uuid] = a);
	}
	void 0 === f && (f = []);
	a.traverse(function(a) {
		void 0 !== a.material ? (a = a.material, l(a.map), l(a.bumpMap), l(a.normalMap), l(a.displacementMap), l(a.specularMap), l(a.emissiveMap), l(a.alphaMap), l(a.roughnessMap), l(a.metalnessMap)) : a instanceof ParticleEmitter && l(a.group.texture);
	});
	return f;
};
ObjectUtils.getScene = function(a) {
	for (;null !== a.parent;) {
		if (a = a.parent, a instanceof Scene) {
			return a;
		}
	}
	return null;
};
ObjectUtils.getRoot = function(a) {
	for (;null !== a.parent;) {
		a = a.parent;
	}
	return a;
};
ObjectUtils.setMatrixAutoUpdate = function(a, f) {
	a.traverse(function(a) {
		a.matrixAutoUpdate = f;
	});
};
ObjectUtils.setShadowReceiving = function(a, f) {
	a.traverse(function(a) {
		a.receiveShadow = f;
	});
};
ObjectUtils.setShadowCasting = function(a, f) {
	a.traverse(function(a) {
		a.castShadow = f;
	});
};
ObjectUtils.isChildOf = function(a, f) {
	for (var l = 0;l < a.children.length;l++) {
		if (a.children[l] === f || ObjectUtils.isChildOf(a.children[l], f)) {
			return !0;
		}
	}
	return !1;
};
var PI2 = Math.PI / 2;
function Mesh2shape() {
}
Mesh2shape.Type = {BOX:"Box", CYLINDER:"Cylinder", SPHERE:"Sphere", HULL:"ConvexPolyhedron"};
Mesh2shape.createShape = function(a, f) {
	if (void 0 !== f) {
		return f === Mesh2shape.Type.BOX ? Mesh2shape.createBoundingBoxShape(a) : f === Mesh2shape.Type.CYLINDER ? Mesh2shape.createBoundingCylinderShape(a, options) : f === Mesh2shape.Type.SPHERE ? Mesh2shape.createBoundingSphereShape(a, options) : f === Mesh2shape.Type.HULL ? Mesh2shape.createConvexPolyhedron(a) : null;
	}
	var l = Mesh2shape.getGeometry(a);
	if (!l) {
		return null;
	}
	f = l.metadata ? l.metadata.type : l.type;
	switch(f) {
		case "BoxGeometry":
		;
		case "BoxBufferGeometry":
			return Mesh2shape.createBoxShape(l);
		case "CylinderGeometry":
		;
		case "CylinderBufferGeometry":
			return Mesh2shape.createCylinderShape(l);
		case "PlaneGeometry":
		;
		case "PlaneBufferGeometry":
			return Mesh2shape.createPlaneShape(l);
		case "SphereGeometry":
		;
		case "SphereBufferGeometry":
			return Mesh2shape.createSphereShape(l);
		case "TubeGeometry":
			return Mesh2shape.createTubeShape(l);
		case "Geometry":
		;
		case "BufferGeometry":
			return Mesh2shape.createConvexPolyhedron(a);
		default:
			return console.warn("Unrecognized geometry: Using bounding box as shape.", l.type), Mesh2shape.createBoxShape(l);
	}
};
Mesh2shape.createBoxShape = function(a) {
	if (!Mesh2shape.getVertices(a).length) {
		return null;
	}
	a.computeBoundingBox();
	a = a.boundingBox;
	return new CANNON.Box(new CANNON.Vec3((a.max.x - a.min.x) / 2, (a.max.y - a.min.y) / 2, (a.max.z - a.min.z) / 2));
};
Mesh2shape.createBoundingBoxShape = function(a) {
	var f, l = new THREE.BoundingBoxHelper(a);
	l.update();
	var b = l.box;
	if (!isFinite(b.min.lengthSq())) {
		return null;
	}
	b = new CANNON.Box(new CANNON.Vec3((b.max.x - b.min.x) / 2, (b.max.y - b.min.y) / 2, (b.max.z - b.min.z) / 2));
	a.updateMatrixWorld();
	f = new THREE.Vector3;
	f.setFromMatrixPosition(a.matrixWorld);
	a = l.position.sub(f);
	a.lengthSq() && (b.offset = a);
	return b;
};
Mesh2shape.createConvexPolyhedron = function(a) {
	var f, l, b;
	f = Mesh2shape.getGeometry(a);
	f instanceof THREE.BufferGeometry && (f = (new THREE.Geometry).fromBufferGeometry(f));
	if (!f || !f.vertices.length) {
		return null;
	}
	for (a = 0;a < f.vertices.length;a++) {
		f.vertices[a].x += 1E-4 * (Math.random() - .5), f.vertices[a].y += 1E-4 * (Math.random() - .5), f.vertices[a].z += 1E-4 * (Math.random() - .5);
	}
	b = (new quickhull)(f);
	console.log(b);
	f = Array(b.vertices.length);
	for (a = 0;a < b.vertices.length;a++) {
		f[a] = new CANNON.Vec3(b.vertices[a].x, b.vertices[a].y, b.vertices[a].z);
	}
	l = Array(b.faces.length);
	for (a = 0;a < b.faces.length;a++) {
		l[a] = [b.faces[a].a, b.faces[a].b, b.faces[a].c];
	}
	return new CANNON.ConvexPolyhedron(f, l);
};
Mesh2shape.createCylinderShape = function(a) {
	a = a.metadata ? a.metadata.parameters : a.parameters;
	a = new CANNON.Cylinder(a.radiusTop, a.radiusBottom, a.height, a.radialSegments);
	a.orientation = new CANNON.Quaternion;
	a.orientation.setFromEuler(THREE.Math.degToRad(-90), 0, 0, "XYZ").normalize();
	return a;
};
Mesh2shape.createBoundingCylinderShape = function(a, f) {
	var l = ["x", "y", "z"];
	f = f.cylinderAxis || "y";
	l = l.splice(l.indexOf(f), 1) && l;
	a = Mesh2shape.getGeometry(a);
	a.computeBoundingBox();
	a.computeBoundingSphere();
	l = .5 * Math.max(a.boundingBox.max[l[0]] - a.boundingBox.min[l[0]], a.boundingBox.max[l[1]] - a.boundingBox.min[l[1]]);
	a = new CANNON.Cylinder(l, l, a.boundingBox.max[f] - a.boundingBox.min[f], 12);
	a.orientation = new CANNON.Quaternion;
	a.orientation.setFromEuler("y" === f ? PI2 : 0, "z" === f ? PI2 : 0, 0, "XYZ").normalize();
	return a;
};
Mesh2shape.createPlaneShape = function(a) {
	a.computeBoundingBox();
	a = a.boundingBox;
	return new CANNON.Box(new CANNON.Vec3((a.max.x - a.min.x) / 2 || .1, (a.max.y - a.min.y) / 2 || .1, (a.max.z - a.min.z) / 2 || .1));
};
Mesh2shape.createSphereShape = function(a) {
	return new CANNON.Sphere((a.metadata ? a.metadata.parameters : a.parameters).radius);
};
Mesh2shape.createBoundingSphereShape = function(a, f) {
	a = Mesh2shape.getGeometry(a);
	a.computeBoundingSphere();
	return new CANNON.Sphere(f.sphereRadius || a.boundingSphere.radius);
};
Mesh2shape.createTubeShape = function(a) {
	var f = new THREE.BufferGeometry;
	f.fromGeometry(a);
	return createTrimeshShape(f);
};
Mesh2shape.createTrimeshShape = function(a) {
	var f = Mesh2shape.getVertices(a);
	if (!f.length) {
		return null;
	}
	a = Object.keys(f).map(Number);
	return new CANNON.Trimesh(f, a);
};
Mesh2shape.getGeometry = function(a) {
	var f = Mesh2shape.getMeshes(a);
	if (0 === f.length) {
		return null;
	}
	var l = new THREE.Geometry;
	if (1 === f.length) {
		a = new THREE.Vector3;
		var b = new THREE.Quaternion, k = new THREE.Vector3, l = f[0].geometry.clone();
		l.metadata = f[0].geometry.metadata;
		f[0].updateMatrixWorld();
		f[0].matrixWorld.decompose(a, b, k);
		return l.scale(k.x, k.y, k.z);
	}
	for (b = new THREE.Geometry;k = f.pop();) {
		k.updateMatrixWorld(), k.geometry instanceof THREE.BufferGeometry ? (l.fromBufferGeometry(k.geometry), b.merge(l, k.matrixWorld)) : b.merge(k.geometry, k.matrixWorld);
	}
	f = new THREE.Matrix4;
	f.scale(a.scale);
	b.applyMatrix(f);
	return b;
};
Mesh2shape.getVertices = function(a) {
	a.attributes || (a = (new THREE.BufferGeometry).fromGeometry(a));
	return a.attributes.position.array;
};
Mesh2shape.getMeshes = function(a) {
	var f = [];
	a.traverse(function(a) {
		"Mesh" === a.type && f.push(a);
	});
	return f;
};
function FileSystem() {
}
try {
	FileSystem.fs = require("fs");
} catch (a) {
}
FileSystem.readFile = function(a, f, l) {
	void 0 === f && (f = !0);
	if (void 0 !== FileSystem.fs) {
		if (f) {
			return FileSystem.fs.readFileSync(a, "utf8");
		}
		FileSystem.fs.readFile(a, "utf8", l);
	} else {
		var b = new XMLHttpRequest;
		b.overrideMimeType("text/plain");
		b.open("GET", a, !f);
		b.onreadystatechange = function() {
			200 !== b.status && 0 !== b.status || void 0 === l || l(b.responseText);
		};
		b.send(null);
		return b.responseText;
	}
};
FileSystem.readFileArrayBuffer = function(a) {
	if (void 0 !== FileSystem.fs) {
		a = FileSystem.fs.readFileSync(a);
		for (var f = a.length, l = new ArrayBuffer(f), b = new Uint8Array(l), k = 0;k < f;k++) {
			b[k] = a[k];
		}
		return l;
	}
	f = new XMLHttpRequest;
	f.open("GET", a, !1);
	f.overrideMimeType("text/plain; charset=x-user-defined");
	f.send(null);
	return ArraybufferUtils.fromBinaryString(f.response);
};
FileSystem.readFileBase64 = function(a) {
	if (void 0 !== FileSystem.fs) {
		return a = FileSystem.fs.readFileSync(a), (new Buffer(a)).toString("base64");
	}
	var f = new XMLHttpRequest;
	f.open("GET", a, !1);
	f.overrideMimeType("text/plain; charset=x-user-defined");
	f.send(null);
	return Base64Utils.fromBinaryString(f.response);
};
FileSystem.writeFile = function(a, f) {
	void 0 !== FileSystem.fs && (a = FileSystem.fs.createWriteStream(a, "utf8"), a.write(f), a.end());
};
FileSystem.copyFile = function(a, f) {
	void 0 !== FileSystem.fs && FileSystem.fs.createReadStream(a).pipe(FileSystem.fs.createWriteStream(f));
};
FileSystem.makeDirectory = function(a) {
	if (void 0 !== FileSystem.fs) {
		try {
			FileSystem.fs.mkdirSync(a);
		} catch (f) {
		}
	}
};
FileSystem.getFilesDirectory = function(a) {
	if (void 0 !== FileSystem.fs) {
		try {
			return FileSystem.fs.readdirSync(a);
		} catch (f) {
		}
	}
	return [];
};
FileSystem.copyFolder = function(a, f) {
	if (void 0 !== FileSystem.fs) {
		FileSystem.makeDirectory(f);
		for (var l = FileSystem.fs.readdirSync(a), b = 0;b < l.length;b++) {
			var k = a + "\\" + l[b], h = f + "\\" + l[b], c = FileSystem.fs.statSync(k);
			c.isDirectory() ? FileSystem.copyFolder(k, h) : c.isSymbolicLink() ? FileSystem.fs.symlinkSync(FileSystem.fs.readlinkSync(k), h) : FileSystem.copyFile(k, h);
		}
	}
};
FileSystem.chooseFile = function(a, f, l) {
	var b = document.createElement("input");
	b.type = "file";
	b.accept = void 0 !== f ? f : "";
	void 0 !== l && (b.nwsaveas = !0 !== l ? l : "file");
	b.onchange = function(f) {
		void 0 !== a && a(b.files);
	};
	b.click();
};
FileSystem.getFileName = function(a) {
	return a.substring(a.lastIndexOf("\\") + 1, a.lastIndexOf("."));
};
FileSystem.getFileExtension = function(a) {
	return a.substring(a.lastIndexOf(".") + 1, a.length);
};
function NunuRuntime(a) {
	this.program = null;
	void 0 === a ? (this.canvas = document.createElement("canvas"), this.canvas.style.position = "absolute", this.canvas.style.left = "0px", this.canvas.style.top = "0px", this.canvas.style.width = window.innerWidth + "px", this.canvas.style.height = window.innerHeight + "px", this.canvas.width = window.innerWidth, this.canvas.height = window.innerHeight, document.body.appendChild(this.canvas), this.canvas_resize = !0) : (this.canvas = a, this.canvas_resize = !1);
	this.renderer = new THREE.WebGLRenderer({canvas:this.canvas, antialias:!0});
	this.renderer.autoClear = !1;
	this.renderer.shadowMap.enabled = !0;
	this.renderer.shadowMap.type = THREE.PCFShadowMap;
	this.renderer.setSize(this.canvas.width, this.canvas.height);
}
NunuRuntime.fullscreen = !1;
NunuRuntime.prototype.loadProgram = function(a) {
	var f = new ObjectLoader;
	a = JSON.parse(FileSystem.readFile(a));
	this.program = f.parse(a);
};
NunuRuntime.prototype.run = function() {
	if (null === this.program) {
		console.warn("nunuStudio: no program is loaded [app.loadPogram(fname)]");
	} else {
		Keyboard.initialize();
		Mouse.initialize();
		Mouse.setCanvas(this.canvas);
		!0 === this.program.vr && (this.vr_controls = new VRControls, this.vr_effect = new THREE.VREffect(this.renderer));
		this.program.default_camera = new PerspectiveCamera(60, this.canvas.width / this.canvas.height, .1, 1E6);
		this.program.default_camera.position.set(0, 5, -5);
		this.program.renderer = this.renderer;
		this.program.initialize();
		this.program.resize(this.canvas.width, this.canvas.height);
		var a = this, f = function() {
			null !== a.program && (requestAnimationFrame(f), a.update());
		};
		f();
	}
};
NunuRuntime.prototype.update = function() {
	Mouse.update();
	Keyboard.update();
	this.program.update();
	this.program.render(this.renderer);
};
NunuRuntime.prototype.exit = function() {
	null !== this.program && (this.program.dispose(), this.program = null);
	Mouse.dispose();
	Keyboard.dispose();
	if (void 0 !== this.onExit) {
		this.onExit();
	}
	void 0 !== NunuRuntime.gui && (NunuRuntime.gui.App.closeAllWindows(), NunuRuntime.gui.App.quit());
};
NunuRuntime.prototype.resize = function() {
	null !== this.canvas && this.canvas_resize && (this.canvas.style.width = window.innerWidth + "px", this.canvas.style.height = window.innerHeight + "px", this.canvas.width = window.innerWidth, this.canvas.height = window.innerHeight);
	null !== this.program && void 0 !== this.renderer && (this.renderer.setSize(this.canvas.width, this.canvas.height), this.program.resize(this.canvas.width, this.canvas.height));
};
NunuRuntime.prototype.setOnExit = function(a) {
	this.onExit = a;
};
NunuRuntime.setFullscreen = function(a, f) {
	(NunuRuntime.fullscreen = a) ? (void 0 === f && (f = document.body), f.requestFullscreen = f.requestFullscreen || f.mozRequestFullScreen || f.webkitRequestFullscreen || f.msRequestFullscreen, f.requestFullscreen && f.requestFullscreen()) : (document.exitFullscreen = document.exitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen, document.exitFullscreen && document.exitFullscreen());
};
NunuRuntime.webvrAvailable = function() {
	return void 0 !== navigator.getVRDisplays;
};

